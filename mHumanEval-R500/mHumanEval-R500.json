[
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"\u0422\u0430 \u0431\u04af\u0445\u044d\u043b \u0442\u043e\u043e\u043d\u044b \u0436\u0430\u0433\u0441\u0430\u0430\u043b\u0442\u044b\u0433 \u0430\u0432\u0447 \u04af\u0437\u043d\u044d. \u0422\u0430 \u0445\u0430\u043c\u0433\u0438\u0439\u043d \u0442\u043e\u043c \u0442\u043e\u043c \u0430\u043d\u0445\u043d\u044b \u04af\u043d\u044d \u0446\u044d\u043d\u0438\u0439\u0433 \u043e\u043b\u0436, \u0442\u04af\u04af\u043d\u0438\u0439 \u0442\u043e\u043e\u043d \u0442\u043e\u043e\u043d\u044b \u043d\u0438\u0439\u043b\u0431\u044d\u0440\u0438\u0439\u0433 \u0431\u0443\u0446\u0430\u0430\u0445 \u0445\u044d\u0440\u044d\u0433\u0442\u044d\u0439. \u0416\u0438\u0448\u044d\u044d \u043d\u044c: lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] \u04af\u0440 \u0434\u04af\u043d \u043d\u044c 10 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] \u04af\u0440 \u0434\u04af\u043d \u043d\u044c 25 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] \u04af\u0440 \u0434\u04af\u043d \u043d\u044c 13 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] \u04af\u0440 \u0434\u04af\u043d \u043d\u044c 11 lst = [0,81,12,3,21,1] \u04af\u0440 \u0434\u04af\u043d \u043d\u044c 3 lst = [0,8,1,2,1,7] \u04af\u0440 \u0434\u04af\u043d \u043d\u044c\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"\u0425\u044d\u0440\u044d\u0432 \u0438\u0439\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0431\u0430\u0439\u0445\u0433\u04af\u0439 \u0431\u043e\u043b -1 \u0431\u0443\u0446\u0430\u0430\u043d\u0430. \u04e9\u0433\u04e9\u0433\u0434\u0441\u04e9\u043d \u043c\u0430\u0441\u0441\u0438\u0432 \u043d\u044c \u0434\u0430\u0432\u0442\u0430\u0433\u0434\u0430\u043b\u0442\u0430\u0439 \u04af\u043d\u044d \u0446\u044d\u043d\u0438\u0439\u0433 \u0430\u0433\u0443\u0443\u043b\u0434\u0430\u0433\u0433\u04af\u0439. \u0416\u0438\u0448\u044d\u044d \u043d\u044c: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    \u0426\u044d\u043d\u0433\u044d\u0433 \u0442\u043e\u043e\u043d\u044b \u043c\u0430\u0441\u0441\u0438\u0432 \u04e9\u0433\u0432\u04e9\u043b, \u0445\u043e\u043e\u0441\u043e\u043d \u0431\u0438\u0448 \u0442\u043e\u043e\u043d\u044b \u0430\u043b\u0438\u0432\u0430\u0430 \u0434\u044d\u0434 \u043c\u0430\u0441\u0441\u0438\u0432\u044b\u043d \u0445\u0430\u043c\u0433\u0438\u0439\u043d \u0431\u0430\u0433\u0430 \u043d\u0438\u0439\u043b\u0431\u044d\u0440\u0438\u0439\u0433 \u043e\u043b\u043e\u0445. \u0416\u0438\u0448\u044d\u044d minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" kurung adalah string \"<\" wan \">\". return True jika setiap kurung pembuka memiliki kurung penutup nang sesuai.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Kembalikan daftar faktor prima dari bilangan bulat tertentu dalam urutan dari terkecil ke terbesar. Masing-masing faktor harus didaftarkan jumlah kali sesuai dengan berapa kali muncul dalam faktorisasi. Jumlah masukan harus sama dengan produk dari semua faktor\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Balikkeun unsur unik nu geus disortir dina daptar\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Dibikeun hiji susunan wilangan bulat, susunan wilangan bulat nu aya antara 1 jeung 9 kaasup, ngabalikeun susunan nu hasil, terus ngaganti unggal digit ku ngaran nu pakait ti \"Hiji\", \"Dua\", \"Tilu\", \"Opat\", \"Lima\", \" genep\", \"Tujuh\", \" Dalapan\", \" Salapan\". Misalna: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> susunan arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> susunan balik arr -> [8, 5, 4, 3, 2, 2, 1, 1] balikkeun [\"Dua\", \"Lima\", \"Tilu\", \"Dua\", \"Dua\", \"Hiji\", \"Hiji\"] Lamun susunan kosong, balikkeun susunan kosong: arr = [] balikkeun [] Lamun susunan boga nomer aneh, teu malire: arr = [1, -1, 55] -> susunan -> [1, 1, 55]\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Dibikeun hiji wilangan bulat positif n, Anjeun kudu nyieun tumpukan n tingkat batu. Tingkat kahiji ngabogaan n batu. Jumlah batu di tingkat saterusna nya\u00e9ta: - angka ganjil saterusna lamun n ganjil. - angka komo saterusna lamun n nya\u00e9ta komo. Balikkeun jumlah batu di unggal tingkat dina daptar, dimana unsur di ind\u00e9ks i ngagambarkeun jumlah batu di tingkat (i+1). Conto:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    \u010ce je na voljo niz celotnih \u0161tevil, razvrsti celotne \u0161tevilke med 1 in 9 vklju\u010dno, obrni rezultatno vrsto in nato nadomesti vsako \u0161tevko z ustreznim imenom iz \"Enega\", \"Dva\", \"Tri\", \"\u010cetiri\", \"Pet\", \"\u0160est\", \"Sedem\", \"Osem\", \"Devet\". Na primer: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> razvrsti arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> obrni arr -> [8, 5, 4, 3, 2, 2, 1, 1] vrni [\"Osem\", \"\u0160tirje\", \"\u0160tiri\", \"Dva\", \"Dva\", \"Dva\", \"Eno\", \"Eno\"] \u010ce je niz prazen, vrni niz: arr = [] vrni [] \u010ce ima niz kak\u0161no \u010dudno \u0161tevilo, ga ignoriraj: arr = [1, -1, 55] -> razvrsti\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filtrirajte vnosni seznam nizov samo za tiste, ki se za\u010dnejo z dolo\u010deno prednovo.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero vzame seznam celih \u0161tevil kot vhod. Vrne True, \u010de sta na seznamu dva razli\u010dna elementa, ki se zbrajo na ni\u010d, in False, \u010de ne.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    \u0648\u064e\u0644\u064e\u0643\u0650\u0646\u0652 \u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\u0646\u0652\u0647\u064f. \u0648\u064e\u0644\u064e\u0627 \u062a\u064e\u0646\u0652\u062a\u064e\u0642\u0650\u0644\u064f \u0645\u0650\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"\u0631\u064f\u062f\u064e\u0651 \u0639\u064e\u062f\u064e\u062f\u064e \u0641\u0650\u0628\u064f\u0648\u0646\u064e\u0643\u0652\u064a\u0650 \u0646\u064e\u0648\u0652\u0645\u064e\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"\u0627\u0650\u0643\u0652\u062a\u064f\u0628\u0652 \u0641\u064e\u0639\u0652\u0644\u064e\u0629\u064b \u062a\u064e\u0642\u0652\u0628\u064e\u0644\u064f \u0642\u0650\u064a\u064e\u0627\u0645\u064e\u0629\u064e \u0633\u064f\u0644\u064f\u0648\u0644\u064d \u0643\u064e\u0645\u064f\u0639\u064e\u062f\u064e\u0651\u062f\u064d\u060c \u062a\u064e\u062d\u0652\u0630\u0650\u0641\u064f \u0627\u0644\u0633\u064f\u0651\u0644\u064f\u0648\u0644\u064e \u0627\u0644\u064e\u0651\u062a\u0650\u064a \u0644\u064e\u0647\u064e\u0627 \u0637\u064f\u0648\u0644\u064c \u063a\u064e\u0631\u0650\u064a\u0628\u064c\u060c \u0648\u064e\u062a\u064e\u0631\u064f\u062f\u064f\u0651 \u0627\u0644\u0652\u0642\u0650\u064a\u064e\u0627\u0645\u064e\u0629\u064e \u0627\u0644\u0652\u0645\u064f\u062a\u064e\u0646\u064e\u0648\u0650\u0651\u062c\u064e\u0629\u064e \u0628\u0650\u062a\u064e\u0631\u0652\u062a\u0650\u064a\u0628\u064d \u0645\u064f\u0646\u064e\u0648\u064e\u0651\u062c\u064d\u060c \u0641\u064e\u0627\u0644\u0652\u0642\u0650\u064a\u064e\u0627\u0645\u064e\u0629\u064f \u062f\u064e\u0627\u0626\u0650\u0645\u064b\u0627 \u0642\u0650\u064a\u064e\u0627\u0645\u064e\u0629\u064f \u0633\u064f\u0644\u064f\u0648\u0644\u064d \u0648\u064e\u0644\u064e\u0627 \u0645\u064e\u0635\u0652\u0641\u064f\u0648\u0641\u064e\u0629\u064f \u0623\u064e\u0631\u0652\u0642\u064e\u0627\u0645\u064d\u060c \u0648\u064e\u0642\u064e\u062f\u0652 \u062a\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    \u0628\u06d5 \u062f\u0627\u0646\u0627\u0646\u06cc \u06a9\u06c6\u0645\u06d5\u06b5\u06ce\u06a9 \u0698\u0645\u0627\u0631\u06d5 \u062a\u06d5\u0648\u0627\u0648 n\u060c \u06a9\u06d5\u0645\u062a\u0631\u06cc\u0646 \u06a9\u06c6\u06cc \u06be\u06d5\u0631 \u06a9\u06c6\u0645\u06d5\u06b5\u06ce\u06a9\u06cc \u062e\u0648\u0627\u0631\u06d5\u0648\u06d5\u06cc \u0698\u0645\u0627\u0631\u06d5 n \u06a9\u06d5 \u0628\u06d5\u062a\u0627\u06b5 \u0646\u06cc\u06cc\u06d5 \u0628\u062f\u06c6\u0632\u06d5\u0631\u06d5\u0648\u06d5. \u0646\u0645\u0648\u0648\u0646\u06d5 minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u06af\u06d5\u0695\u0627\u0646\u062f\u0646\u06d5\u0648\u06d5\u06cc \u062a\u0648\u062e\u0645\u06d5 \u0647\u0627\u0648\u0628\u06d5\u0634\u06d5 \u06cc\u06d5\u06a9\u062c\u0627\u0631 \u062c\u06cc\u0627\u0648\u0627\u0632\u06d5\u06a9\u0627\u0646 \u0628\u06c6 \u062f\u0648\u0648 \u0644\u06cc\u0633\u062a.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    T\u00e1 l\u00edon ioml\u00e1n dearfach n agat. Caithfidh t\u00fa sraith ioml\u00e1n a a fhad n a chruth\u00fa. Maidir le gach i (1 \u2030\u00a4 i \u2030\u00a4 n), luach a[i] = i * i - i + 1. \u00cdosl\u00f3d\u00e1il l\u00edon na dtr\u00ed\u00faile (a[i], a[j], a[k]) de a \u00e1it a bhfuil i < j < k, agus a[i] + a[j] + a[k] is ioma\u00ed de 3.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" I gc\u00e1s sreang ar leith, flip carachtair bheag go m\u00f3r agus m\u00f3r go mion.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is feidhm \u00e9 a ghlacann sraith agus a thugann sraith ar ais gan vu\u00e1laigh.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    \u7d66\u4e88\u4e00\u500b\u6b63\u6574\u6578,\u4ee5\u7f85\u99ac\u6578\u5b57\u7b49\u50f9\u70ba\u5b57\u7b26\u4e32,\u4e26\u4ee5\u5c0f\u5beb\u8fd4\u56de.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    \u7d66\u4e88\u4e00\u500b\u6574\u6578\u6578\u7684\u6578\u5217, \u627e\u51fa\u4efb\u4f55\u975e\u7a7a\u5b50\u6578\u5217\u7684\u6700\u5c0f\u7e3d\u548c.\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    \u7d66\u5b9a\u4e00\u500b\u975e\u8ca0\u6574\u6578\u7684\u6578\u5217,\u5728\u6392\u5e8f\u5f8c\u8fd4\u56de\u7d66\u5b9a\u6578\u5217\u7684\u526f\u672c,\u5982\u679c\u7e3d\u548c (\u7b2c\u4e00\u6307\u6578\u503c,\u6700\u5f8c\u6307\u6578\u503c) \u662f\u5947\u6578,\u5247\u5c07\u8a72\u6578\u5217\u6392\u5e8f\u6210\u4e0a\u5347\u9806\u5e8f,\u5982\u679c\u7e3d\u548c (\u7b2c\u4e00\u6307\u6578\u503c,\u6700\u5f8c\u6307\u6578\u503c) \u662f\u5076\u6578,\u5247\u5c07\u5176\u6392\u5e8f\u6210\u4e0b\u964d\u9806\u5e8f. \u6ce8\u610f: *\u4e0d\u8981\u6539\u8b8a\u7d66\u5b9a\u6578\u5217. \u4f8b: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Bu kata'da, negatif olmayan tam say\u0131lar dizisini, ikili temsilindeki birlerin say\u0131s\u0131na g\u00f6re y\u00fckselen s\u0131rayla s\u0131ralaman\u0131z gerekir.\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Pozitif bir tamsay\u0131 n verilmi\u015fse, tek basamaklar\u0131n \u00e7arp\u0131m\u0131n\u0131 g\u00f6nder. E\u011fer t\u00fcm basamaklar \u00e7iftse 0 g\u00f6nder. \u00d6rne\u011fin: basamaklar ((1) == 1 basamak ((4) == 0 basamak ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Size bir s\u0131n\u0131f\u0131n ad\u0131 (bir dize) ve bir uzant\u0131 listesi verilecektir. Uzant\u0131lar s\u0131n\u0131fa ek s\u0131n\u0131flar y\u00fcklemek i\u00e7in kullan\u0131lacak. Uzant\u0131n\u0131n g\u00fcc\u00fc \u015f\u00f6yle olacakt\u0131r: CAP uzant\u0131n\u0131n ad\u0131ndaki b\u00fcy\u00fck harflerin say\u0131s\u0131 olsun ve SM uzant\u0131n\u0131n ad\u0131ndaki k\u00fc\u00e7\u00fck harflerin say\u0131s\u0131 olsun, kuvvet CAP - SM kesir taraf\u0131ndan verilecektir. En g\u00fc\u00e7l\u00fc uzant\u0131y\u0131 bulmal\u0131 ve bu formatta bir dize d\u00f6nd\u00fcrmelisiniz: ClassName.StrongestExtensionName. Ayn\u0131 kuvvete sahip iki veya daha fazla uzant\u0131 varsa, listede ilk gelenini se\u00e7melisiniz. \u00d6rne\u011fin, size s\u0131n\u0131f olarak \"Par\u00e7alar\" ve uzant\u0131lar\u0131n bir listesi verilirse: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] sonra 'SviRNGSliCes' i geri d\u00f6nd\u00fcrmelisiniz,\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    \u0905\u0924\u094d\u0930 \u0915\u092e\u094d\u092a\u093e\u092f\u093e\u0903 \u0935\u093e \u0930\u093f\u0915\u094d\u0924\u0938\u094d\u0925\u093e\u0928\u093e\u0928\u093e\u0902 \u0926\u094d\u0935\u093e\u0930\u093e \u0935\u093f\u092d\u0915\u094d\u0924\u0903 \u0936\u092c\u094d\u0926\u0903 \u092a\u094d\u0930\u0926\u0924\u094d\u0924\u0903 \u0905\u0938\u094d\u0924\u093f \u0964 \u092d\u0935\u0924\u093e\u0902 \u0915\u093e\u0930\u094d\u092f\u092e\u094d \u0905\u0938\u094d\u0924\u093f \u092f\u0924\u094d \u0936\u092c\u094d\u0926\u093e\u0928\u093e\u0902 \u092e\u0927\u094d\u092f\u0947 \u0935\u093f\u092d\u0915\u094d\u0924\u0903 \u0936\u092c\u094d\u0926\u0903 \u092a\u0941\u0928\u0903 \u0932\u092d\u0947\u0924 \u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u093e\u0930\u094d\u0925\u0903 words_string (\u0915. \u0936\u092c\u094d\u0926\u0903) == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string (\u0915. \u0936\u092c\u094d\u0926\u0903) == [\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"\u0928-\u090b\u0923\u093e\u0924\u094d\u092e\u0915\u0902 \u092a\u0942\u0930\u094d\u0923\u093e\u0919\u094d\u0915\u0902 \u0917\u0943\u0939\u0940\u0924\u094d\u0935\u093e \u092a\u094d\u0930\u0925\u092e\u0902 \u090f\u0928 \u092a\u0942\u0930\u094d\u0923\u093e\u0919\u094d\u0915\u0902, \u090f\u0928-\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\u094d\u092f\u0947\u092f\u0938\u0902\u0916\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u0926\u094d\u0935\u094c \u0938\u0902\u0916\u094d\u092f\u093e\u0903 x \u0924\u0925\u093e y \u0938\u092e\u093e\u0938\u093e\u0928\u094d\u0924\u093e\u0903\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Du f\u00e5r en 2-dimensional data, som en indlejret lister, som ligner matrix, men i mods\u00e6tning til matrix, kan hver r\u00e6kke indeholde et andet antal kolonner. Givet lst, og heltal x, finde heltal x i listen, og returnere liste over tupler, [(x1, y1), (x2, y2)...] s\u00e5dan at hver tuple er en koordinat - (r\u00e6kke, kolonner), der starter med 0. Sortere koordinater oprindeligt efter r\u00e6kker i stigende r\u00e6kkef\u00f8lge. Ogs\u00e5, sortere koordinater af r\u00e6kken efter kolonner i faldende r\u00e6kkef\u00f8lge. Eksempler: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1] ], 1) == [0, 0, 0, 0, 0, 1, 4], 0, (2, 5), (2, 0) get_(], 1) [] == [[r\u00e6kke [1], [1,\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Returnerer sorterede unikke f\u00e6lles elementer for to lister.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels er en funktion, der tager streng og returnerer streng uden vokaler.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"\u0986\u09aa\u09a8\u09be\u09b0 \u0995\u09be\u099c \u09b9\u09b2 \u098f\u09ae\u09a8 \u098f\u0995\u099f\u09bf \u09ab\u09be\u0982\u09b6\u09a8 \u09b2\u09bf\u0996\u09a4\u09c7 \u09af\u09be \u09b8\u09a4\u09cd\u09af \u09ab\u09c7\u09b0\u09a4 \u09a6\u09c7\u09af\u09bc \u09af\u09a6\u09bf \u098f\u0995\u099f\u09bf \u09b8\u0982\u0996\u09cd\u09af\u09be x n \u098f\u09b0 \u098f\u0995\u099f\u09bf \u09b8\u09be\u09a7\u09be\u09b0\u09a3 \u09b6\u0995\u09cd\u09a4\u09bf \u09b9\u09af\u09bc \u098f\u09ac\u0982 \u0985\u09a8\u09cd\u09af \u0995\u09cd\u09b7\u09c7\u09a4\u09cd\u09b0\u09c7 \u09ae\u09bf\u09a5\u09cd\u09af\u09be \u09b9\u09af\u09bc\u0964 x n \u098f\u09b0 \u098f\u0995\u099f\u09bf \u09b8\u09be\u09a7\u09be\u09b0\u09a3 \u09b6\u0995\u09cd\u09a4\u09bf \u09af\u09a6\u09bf n**int=x \u0989\u09a6\u09be\u09b9\u09b0\u09a3\u09b8\u09cd\u09ac\u09b0\u09c2\u09aa\u0983 is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u098f\u0995\u099f\u09bf \u09a7\u09a8\u09be\u09a4\u09cd\u09ae\u0995 \u09aa\u09c2\u09b0\u09cd\u09a3\u09b8\u0982\u0996\u09cd\u09af\u09be n \u09a6\u09c7\u0993\u09af\u09bc\u09be \u09b9\u09b2\u09c7, \u098f\u0995\u099f\u09bf \u099f\u09bf\u09aa\u09b2 \u09ab\u09c7\u09b0\u09a4 \u09a6\u09bf\u09a8 \u09af\u09be\u09b0 \u09ae\u09a7\u09cd\u09af\u09c7 \u09b0\u09af\u09bc\u09c7\u099b\u09c7 \u098f\u09ae\u09a8 \u09b8\u09ae \u098f\u09ac\u0982 \u0985\u09b8\u09cd\u09ac\u09be\u09ad\u09be\u09ac\u09bf\u0995 \u09aa\u09c2\u09b0\u09cd\u09a3\u09b8\u0982\u0996\u09cd\u09af\u09be \u09aa\u09cd\u09af\u09be\u09b2\u09bf\u09a8\u09a1\u09cd\u09b0\u09cb\u09ae\u09c7\u09b0 \u09b8\u0982\u0996\u09cd\u09af\u09be \u09af\u09be \u09aa\u09b0\u09bf\u09b8\u09c0\u09ae\u09be ((1, n), \u09b8\u09b9\u0964 \u0989\u09a6\u09be\u09b9\u09b0\u09a3 1: \u0987\u09a8\u09aa\u09c1\u099f\u0983 3 \u0986\u0989\u099f\u09aa\u09c1\u099f\u0983 (1, 2) \u09ac\u09cd\u09af\u09be\u0996\u09cd\u09af\u09be\u0983 \u09aa\u09c2\u09b0\u09cd\u09a3\u09b8\u0982\u0996\u09cd\u09af\u09be \u09aa\u09cd\u09af\u09be\u09b2\u09bf\u09a8\u09a1\u09cd\u09b0\u09cb\u09ae \u09b9\u09b2 1, 2, 3. \u09a4\u09be\u09a6\u09c7\u09b0 \u09ae\u09a7\u09cd\u09af\u09c7 \u098f\u0995\u099f\u09bf \u09b8\u09ae \u098f\u09ac\u0982 \u09a4\u09be\u09a6\u09c7\u09b0 \u09ae\u09a7\u09cd\u09af\u09c7 \u09a6\u09c1\u099f\u09bf \u0985\u09b8\u09cd\u09ac\u09be\u09ad\u09be\u09ac\u09bf\u0995\u0964 \u0989\u09a6\u09be\u09b9\u09b0\u09a3 2: \u0987\u09a8\u09aa\u09c1\u099f\u0983 12 \u0986\u0989\u099f\u09aa\u09c1\u099f\u0983 (4, 6) \u09ac\u09cd\u09af\u09be\u0996\u09cd\u09af\u09be\u0983 \u09aa\u09c2\u09b0\u09cd\u09a3\u09b8\u0982\u0996\u09cd\u09af\u09be \u09aa\u09cd\u09af\u09be\u09b2\u09bf\u09a8\u09a1\u09cd\u09b0\u09cb\u09ae \u09b9\u09b2 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u09a4\u09be\u09a6\u09c7\u09b0 \u09ae\u09a7\u09cd\u09af\u09c7 \u099a\u09be\u09b0\u099f\u09bf \u09b8\u09ae \u098f\u09ac\u0982 \u09a4\u09be\u09a6\u09c7\u09b0 \u09ae\u09a7\u09cd\u09af\u09c7 6 \u099f\u09bf \u0985\u09b8\u09cd\u09ac\u09be\u09ad\u09be\u09ac\u09bf\u0995\u0964 \u09a6\u09cd\u09b0\u09b7\u09cd\u099f\u09ac\u09cd\u09af\u0983 1. 1 <= n <= 10 ^ 3 2. \u099f\u09bf\u09aa\u09b2 \u09af\u09a5\u09be\u0995\u09cd\u09b0\u09ae\u09c7 \u09b8\u09ae \u098f\u09ac\u0982 \u0985\u09b8\u09cd\u09ac\u09be\u09ad\u09be\u09ac\u09bf\u0995 \u09aa\u09c2\u09b0\u09cd\u09a3\u09b8\u0982\u0996\u09cd\u09af\u09be \u09aa\u09cd\u09af\u09be\u09b2\u09bf\u09a8\u09a1\u09cd\u09b0\u09cb\u09ae\u09c7\u09b0 \u09b8\u0982\u0996\u09cd\u09af\u09be \u09ab\u09c7\u09b0\u09a4 \u09a6\u09bf\u09af\u09bc\u09c7\u099b\u09c7\u0964\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"\u09a4\u09be\u09b2\u09bf\u0995\u09be\u09b0 \u09b6\u09c1\u09a7\u09c1\u09ae\u09be\u09a4\u09cd\u09b0 \u09a7\u09a8\u09be\u09a4\u09cd\u09ae\u0995 \u09b8\u0982\u0996\u09cd\u09af\u09be \u09ab\u09c7\u09b0\u09a4 \u09a6\u09bf\u09a8\u0964\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0458\u0443 \u043a\u043e\u0458\u0430 \u0443\u0437\u0438\u043c\u0430 \u043d\u0438\u0437\u0430\u043a \u0438 \u0432\u0440\u0430\u045b\u0430 \u0443\u0440\u0435\u0452\u0435\u043d\u0443 \u0432\u0435\u0440\u0437\u0438\u0458\u0443. \u0420\u0435\u0452\u0435\u043d\u0430 \u0432\u0435\u0440\u0437\u0438\u0458\u0430 \u043d\u0438\u0437\u0430 \u0458\u0435 \u043d\u0438\u0437\u0430 \u0443 \u043a\u043e\u0458\u043e\u0458 \u0441\u0443 \u0441\u0432\u0435 \u0440\u0435\u0447\u0438 (\u043e\u0434\u0432\u043e\u0458\u0435\u043d\u0435 \u043f\u0440\u043e\u0441\u0442\u043e\u0440\u043e\u043c) \u0437\u0430\u043c\u0435\u045a\u0435\u043d\u0435 \u043d\u043e\u0432\u043e\u043c \u0440\u0435\u0447\u0458\u0443 \u0443 \u043a\u043e\u0458\u043e\u0458 \u0441\u0443 \u0441\u0432\u0438 \u0437\u043d\u0430\u0446\u0438 \u0440\u0430\u0441\u043f\u043e\u0440\u0435\u0452\u0435\u043d\u0438 \u0443 \u0440\u0430\u0441\u0442\u0443\u045b\u0435\u043c \u0440\u0435\u0434\u0443 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0443 ASCII \u0432\u0440\u0435\u0434\u043d\u043e\u0441\u0442\u0438. \u041d\u0430\u043f\u043e\u043c\u0435\u043d\u0430: \u0422\u0440\u0435\u0431\u0430 \u0437\u0430\u0434\u0440\u0436\u0430\u0442\u0438 \u0440\u0435\u0434\u043e\u0441\u043b\u0435\u0434 \u0440\u0435\u0447\u0438 \u0438 \u043f\u0440\u0430\u0437\u043d\u0430 \u043f\u0440\u043e\u0441\u0442\u043e\u0440\u0430 \u0443 \u0440\u0435\u0447\u0435\u043d\u0438\u0446\u0438. \u041d\u0430 \u043f\u0440\u0438\u043c\u0435\u0440: anti_shuffle (('Hi') \u0432\u0440\u0430\u045b\u0430 'Hi' anti_shuffle (('\u0437\u0434\u0440\u0430\u0432\u043e') \u0432\u0440\u0430\u045b\u0430 'ehllo' anti_shuffle (('\u0417\u0434\u0440\u0430\u0432\u043e \u0421\u0432\u0435\u0442\u0443!!!') \u0432\u0440\u0430\u045b\u0430 '\u0417\u0434\u0440\u0430\u0432\u043e!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"\u0412\u0440\u0430\u045b\u0430 \u043d\u0430\u0458\u0432\u0435\u045b\u0438 \u043f\u0440\u043e\u0441\u0442 \u0444\u0430\u043a\u0442\u043e\u0440 n. \u041f\u0440\u0435\u0442\u043f\u043e\u0441\u0442\u0430\u0432\u0438\u043c\u043e \u0434\u0430 \u0458\u0435 n > 1 \u0438 \u0434\u0430 \u043d\u0438\u0458\u0435 \u043f\u0440\u043e\u0441\u0442.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"\u0412\u0440\u0430\u045b\u0430 \u0438\u0441\u0442\u0438\u043d\u0438\u0442\u043e \u0430\u043a\u043e \u0458\u0435 \u0434\u0430\u0442 \u0431\u0440\u043e\u0458 \u043f\u0440\u043e\u0441\u0442, \u0430 \u043b\u0430\u0436\u043d\u0438 \u0443 \u0441\u0443\u043f\u0440\u043e\u0442\u043d\u043e\u043c.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"\u0924\u092a\u093e\u0908\u0901\u0915\u094b \u0915\u093e\u0930\u094d\u092f \u092d\u0928\u0947\u0915\u094b \u090f\u0909\u091f\u093e \u092f\u0938\u094d\u0924\u094b \u092a\u094d\u0930\u0915\u093e\u0930\u094d\u092f \u0915\u093e\u0930\u094d\u092f\u093e\u0928\u094d\u0935\u092f\u0928 \u0917\u0930\u094d\u0928\u0941 \u0939\u094b \u091c\u0938\u0932\u0947 x * n \u0905\u092d\u093f\u0935\u094d\u092f\u0915\u094d\u0924\u093f\u0932\u093e\u0908 \u0938\u0930\u0932 \u092c\u0928\u093e\u0909\u0928\u0947\u091b\u0964 \u092f\u0926\u093f x * n \u0915\u094b \u092e\u093e\u0928 \u092a\u0942\u0930\u094d\u0923\u093e\u0919\u094d\u0915 \u0939\u094b \u092d\u0928\u0947 \u092f\u094b \u092a\u094d\u0930\u0915\u093e\u0930\u094d\u092f\u0932\u0947 True \u092b\u0930\u094d\u0915\u093e\u0909\u0901\u091b \u0930 \u0905\u0928\u094d\u092f\u0925\u093e False \u092b\u0930\u094d\u0915\u093e\u0909\u0901\u091b\u0964 x \u0930 n \u0926\u0941\u0935\u0948 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928 \u092d\u093f\u0928\u094d\u0928\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \u092f\u0926\u093f \u0926\u093f\u0907\u090f\u0915\u094b \u0938\u0902\u0916\u094d\u092f\u093e\u0939\u0930\u0942\u0915\u094b \u0938\u0942\u091a\u0940\u092e\u093e, \u0926\u093f\u0907\u090f\u0915\u094b \u0925\u094d\u0930\u0947\u0938\u0939\u094b\u0932\u094d\u0921 \u092d\u0928\u094d\u0926\u093e \u0915\u0941\u0928\u0948 \u0926\u0941\u0908 \u0928\u092e\u094d\u092c\u0930\u0939\u0930\u0942 \u090f\u0915 \u0905\u0930\u094d\u0915\u093e\u0938\u0901\u0917 \u0928\u091c\u093f\u0915 \u091b\u0928\u094d \u092d\u0928\u0947 \u091c\u093e\u0901\u091a \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0903\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" \u0926\u093f\u0907\u090f\u0915\u094b \u0938\u094d\u091f\u094d\u0930\u093f\u0919\u0915\u093e \u0932\u093e\u0917\u093f, \u0938\u093e\u0928\u094b \u0905\u0915\u094d\u0937\u0930\u0932\u093e\u0908 \u0920\u0942\u0932\u094b \u0905\u0915\u094d\u0937\u0930\u092e\u093e \u0930 \u0920\u0942\u0932\u094b \u0905\u0915\u094d\u0937\u0930\u0932\u093e\u0908 \u0938\u093e\u0928\u094b \u0905\u0915\u094d\u0937\u0930\u092e\u093e \u092a\u0932\u094d\u091f\u093e\u0909\u0928\u0941\u0939\u094b\u0938\u094d\u0964\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \u0628\u06c7 \u0641\u06c7\u0646\u0643\u0633\u0649\u064a\u06d5\u06af\u06d5 \u0643\u0649\u0631\u06af\u06c8\u0632\u06af\u06d5\u0646 \u0646\u06c7\u062a\u06c7\u0642\u0644\u0627\u0631 \u0626\u0627\u0644\u0627\u06be\u0649\u062f\u06d5 ASCII \u0634\u06d5\u0643\u0644\u0649\u062f\u06d5 \u0645\u06c7\u0632\u0649\u0643\u0627 \u0646\u06c7\u062a\u06c7\u0642\u0644\u0649\u0631\u0649\u0646\u0649 \u0626\u0649\u067e\u0627\u062f\u0649\u0644\u06d5\u064a\u062f\u06c7. \u0633\u0649\u0632\u0646\u0649\u06ad \u06cb\u06d5\u0632\u0649\u067e\u0649\u06ad\u0649\u0632 \u0628\u06c7 \u0646\u06c7\u062a\u06c7\u0642\u0646\u0649 \u067e\u0627\u0631\u0633 \u0642\u0649\u0644\u0649\u0634 \u06cb\u06d5 \u06be\u06d5\u0631 \u0628\u0649\u0631 \u0646\u06c7\u062a\u06c7\u0642\u0646\u0649\u06ad \u0642\u0627\u0646\u0686\u0649\u0644\u0649\u0643 \u0642\u06d0\u062a\u0649\u0645 \u062f\u0627\u06cb\u0627\u0645\u0644\u0649\u0634\u0649\u062f\u0649\u063a\u0627\u0646\u0644\u0649\u0642\u0649\u063a\u0627 \u0645\u0627\u0633 \u0643\u06d0\u0644\u0649\u062f\u0649\u063a\u0627\u0646 \u067e\u06c8\u062a\u06c8\u0646 \u0633\u0627\u0646\u0644\u0627\u0631\u0646\u0649\u06ad \u062a\u0649\u0632\u0649\u0645\u0644\u0649\u0643\u0649\u0646\u0649 \u0642\u0627\u064a\u062a\u06c7\u0631\u06c7\u0634\u062a\u06c7\u0631. \u0628\u06c7 \u064a\u06d5\u0631\u062f\u06d5 \u0628\u0649\u0631 \u0631\u0649\u06cb\u0627\u064a\u06d5\u062a \u0628\u0627\u0631: 'o' - \u067e\u06c8\u062a\u06c8\u0646 \u0646\u06c7\u062a\u06c7\u0642\u060c \u062a\u06c6\u062a \u0642\u06d0\u062a\u0649\u0645 \u062f\u0627\u06cb\u0627\u0645\u0644\u0649\u0634\u0649\u062f\u06c7 'o\" - \u064a\u06d0\u0631\u0649\u0645 \u0646\u06c7\u062a\u06c7\u0642\u060c \u0626\u0649\u0643\u0643\u0649 \u0642\u06d0\u062a\u0649\u0645 \u062f\u0627\u06cb\u0627\u0645\u0644\u0649\u0634\u0649\u062f\u06c7 '. \"i\" - \u062a\u06c6\u062a \u0646\u06c7\u062a\u06c7\u0642\u060c \u0628\u0649\u0631 \u0642\u06d0\u062a\u0649\u0645 \u062f\u0627\u06cb\u0627\u0645\u0644\u0649\u0634\u0649\u062f\u06c7\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \u062a\u06c6\u06cb\u06d5\u0646\u062f\u0649\u0643\u0649 \u0646\u0648\u0645\u06c7\u0631\u0644\u0627\u0631 \u0626\u0649\u0686\u0649\u062f\u06d5\u060c \u0626\u0649\u0643\u0643\u0649 \u0646\u0648\u0645\u06c7\u0631\u0646\u0649\u06ad \u0628\u0649\u0631\u0649\u0646\u0649\u06ad \u0628\u0649\u0631\u0649\u06af\u06d5 \u064a\u06d0\u0642\u0649\u0646 \u064a\u0627\u0643\u0649 \u064a\u06d0\u0642\u0649\u0646 \u0626\u06d5\u0645\u06d5\u0633\u0644\u0649\u0643\u0649\u0646\u0649 \u062a\u06d5\u0643\u0634\u06c8\u0631\u06c8\u06ad.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\n.\u064a\u06d5\u0646\u06d5 \u0628\u0649\u0631 \u0642\u0649\u0633\u0649\u0645 \u0633\u0649\u0646\u0627\u0642 \u0645\u0649\u0633\u0627\u0644\u0644\u0627\u0631\u0646\u0649 \u0643\u06c6\u0631\u06c8\u067e \u0628\u0627\u0642\u0627\u064a\u0644\u0649\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Donn\u00e9 une liste de cha\u00eenes, o\u00f9 chaque cha\u00eene est compos\u00e9e uniquement de chiffres, retourner une liste. Chaque \u00e9l\u00e9ment i de la sortie devrait \u00eatre \"le nombre d'\u00e9l\u00e9ments impairs dans la cha\u00eene i de l'entr\u00e9e. \" o\u00f9 tous les i devraient \u00eatre remplac\u00e9s par le nombre de chiffres impairs dans la i'e cha\u00eene de l'entr\u00e9e.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"T\u00e2che \u00c9crire une fonction qui prend une cha\u00eene comme entr\u00e9e et renvoie la somme des caract\u00e8res sup\u00e9rieurs seulement' codes ASCII. Exemples: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Remplissez la fonction qui prend deux entiers et renvoie le produit de leurs chiffres unitaires.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Returliste med elementer som er inkrementert med 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Tenk deg en vei som er en perfekt rett uendelig lang linje. n biler kj\u00f8rer fra venstre til h\u00f8yre; samtidig kj\u00f8rer et annet sett av n biler fra h\u00f8yre til venstre. De to bilene starter med \u00e5 v\u00e6re veldig langt fra hverandre. Alle bilene beveger seg i samme hastighet. To biler sies \u00e5 kollidere n\u00e5r en bil som beveger seg fra venstre til h\u00f8yre treffer en bil som beveger seg fra h\u00f8yre til venstre. Men bilene er uendelig robuste og sterke; som et resultat fortsetter de \u00e5 bevege seg i sin bane som om de ikke kolliderte. Denne funksjonen gir ut antall slike kollisjoner.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Du f\u00e5r et rektangul\u00e6rt rutenett av br\u00f8nner. Hver rad representerer en enkelt br\u00f8nn, og hver 1 i en rad representerer en enkelt enhet av vann. Hver br\u00f8nn har en tilsvarende b\u00f8tte som kan brukes til \u00e5 trekke vann fra den, og alle b\u00f8tter har samme kapasitet. Din oppgave er \u00e5 bruke b\u00f8tter til \u00e5 t\u00f8mme br\u00f8nner. Utgang antall ganger du trenger \u00e5 senke b\u00f8tter. Eksempel 1: Inngang: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Utgang: 62: Inngang: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Utgang: 53: Inngang: [[:0,0,0], [0,0,0]] bucket_capacity: 5 Ut\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Mi\u0331 ci\u0331 k\u0254n\u025b ka\u0331m raar \u025b la mi\u0331 caa la\u0331t \u025b la mi\u0331 di\u0331i\u0331t k\u00e4 di\u0331t, bi\u0331 k\u0254n\u025b l\u025b loc \u025b la mi\u0331 caa mat \u025b la mi\u0331 di\u0331i\u0331t k\u00e4 di\u0331t k\u00e4 di\u0331t. C\u00e4\u00e4tni\u0331: Mi\u0331 ci\u0331 lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] bi\u0331 min ca ka\u0331m raar ku l\u025b t\u00e4 k\u025b 10 mi\u0331 ci\u0331 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] bi\u0331 min ca ka\u0331m raar ku l\u025b t\u00e4 k\u025b 25 mi\u0331 ci\u0331 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] bi\u0331 min ca ka\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Ba ji\u0331 ka\u0331m n\u00e4mb\u00e4r r\u025by de\u0331ci\u0331mal pu\u0254rmat k\u00e4 ba\u0331ldu \u025b \u0263\u00f6\u00f6 bi\u0331 j\u025b loc k\u00e4 bain\u00e4ri\u0331 pu\u0254rmat. Ba pa\u0331\u014bciin locni\u0331 k\u00e4 thi\u0331r\u025bnd, k\u025b ta\u0331a\u0331 in nyothk\u025b ni\u0331 n\u00e4mb\u00e4r bain\u00e4ri\u0331. Bi\u0331 ta\u0331a\u0331 in te thi\u0331r\u025bnd \u025b '0' ki\u025b '1'. Bi\u0331 tek\u025b ti\u0331 \u014buan ti\u0331 ba\u0331lk\u025b k\u00e4 thi\u0331r\u025bnd 'db' k\u00e4 tukd\u025b k\u025bn\u025b guutd\u025b. Bi\u0331 ta\u0331a\u0331 in ba\u0331lk\u025b thi\u0331n tek\u025b k\u025b \u0263\u00f6\u00f6 ba ji\u0331 lu\u00e4k k\u025b pu\u0254rmat. C\u00e4\u00e4tni\u0331: de\u0331ci\u0331mal_to_binary ((15) # lu\u0254c\u025b \"db1111db\" de\u0331ci\u0331mal_to_binary32) # lu\u0254c\u025b \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Mi\u0331 ca ji\u0331 ka\u0331m data mi\u0331 tek\u025b d\u00e4\u00e4kni\u0331 r\u025bw, cetk\u025b lista\u0331 tin ca mat, min c\u00e4\u00e4t k\u025b matrik, du\u014bd\u025b \u0263\u00f6\u00f6, \/ci\u0331 ta\u0331a\u0331 matrikni\u0331, bi\u0331k\u025b tek\u025b n\u00e4mb\u00e4r mi\u0331 g\u00f6l k\u00e4 k\u0254l\u00f6mni\u0331. Mi\u0331 ca lst, k\u025bn\u025b intejer x, go\u0331ri\u0331 intejeri\u0331 x r\u025by li\u0331th\u00e4, k\u025bn\u025b locni\u0331 li\u0331th du\u014b tupul, [(x1, y1), (x2, y2)...] \u025b la \u0263\u00f6\u00f6 bi\u0331 tupul \u025b k\u0254ndi\u0331r\u00ebt - (row, columns), tok\u025b k\u025b 0. C\u0254ali\u0331 k\u0254rdi\u0331n\u025bti\u0331 k\u025b nhiam \u025b la r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331 k\u025b r\u0254\u0254mni\u0331. C\u00e4\u00e4tni\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Siz\u0259 bir sinif ad\u0131 (bir simli) v\u0259 uzant\u0131lar\u0131n siyah\u0131s\u0131 veril\u0259c\u0259k. Uzant\u0131lar sinif\u0259 \u0259lav\u0259 sinifl\u0259r y\u00fckl\u0259m\u0259k \u00fc\u00e7\u00fcn istifad\u0259 edil\u0259c\u0259kdir. Uzant\u0131n\u0131n g\u00fcc\u00fc a\u015fa\u011f\u0131dak\u0131 kimidir: CAP uzant\u0131n\u0131n ad\u0131nda b\u00f6y\u00fck h\u0259rfl\u0259rin say\u0131 olsun, SM is\u0259 uzant\u0131n\u0131n ad\u0131nda ki\u00e7ik h\u0259rfl\u0259rin say\u0131 olsun, g\u00fcc CAP - SM \u0259d\u0259di il\u0259 verilir. \u018fn g\u00fccl\u00fc uzant\u0131n\u0131 tapmal\u0131 v\u0259 bu formatda bir simli qaytarmal\u0131s\u0131n\u0131z: ClassName.StrongestExtensionName. \u018fg\u0259r eyni g\u00fccl\u0259 iki v\u0259 ya daha \u00e7ox uzant\u0131 varsa, siyah\u0131da ilk g\u0259l\u0259nini se\u00e7m\u0259lisiniz. M\u0259s\u0259l\u0259n, siz\u0259 sinif v\u0259 uzant\u0131lar\u0131n siyah\u0131s\u0131 kimi \"Slices\" verilirs\u0259: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] sonra 'Slices.SEviRNGSliCes' 'S\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Real \u0259d\u0259dl\u0259ri t\u0259msil ed\u0259n tam \u0259d\u0259dl\u0259ri, \u00fcz\u0259n \u0259d\u0259dl\u0259ri v\u0259 ya simli \u0259d\u0259dl\u0259ri q\u0259bul ed\u0259n v\u0259 veril\u0259n d\u0259yi\u015f\u0259n n\u00f6v\u00fcnd\u0259 daha b\u00f6y\u00fck d\u0259yi\u015f\u0259nl\u0259ri geri qaytaran bir funksiya yarad\u0131n. D\u0259y\u0259rl\u0259r b\u0259rab\u0259rdirs\u0259, He\u00e7 bir \u015fey qaytar\u0131n. Qeyd: \u018fg\u0259r real \u0259d\u0259d simli kimi t\u0259msil olunursa, \u00fcz\u0259n n\u00f6qt\u0259 ola bil\u0259r. v\u0259 ya, compare_one{1, 2.5) \u00e2 -> 2.5 compare_one{1, \"2,3\") \u00e2 -> \"2,3\" compare_one{5,1\", \"6\") \u00e2 -> \"6\" compare_one{1\", 1) \u00e2 -> He\u00e7 bir \u015fey\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Giri\u015f siyah\u0131s\u0131n\u0131n h\u0259r iki ard\u0131c\u0131l elementi aras\u0131nda bir \"delimiter\" n\u00f6mr\u0259si daxil edin `n\u00f6mr\u0259l\u0259r\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"\u090f\u0915 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0918\u0947\u0923\u093e\u0930\u0940 \u0906\u0923\u093f \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917\u091a\u0940 \u0932\u093e\u0902\u092c\u0940 \u090f\u0915 \u0905\u092d\u093e\u091c\u094d\u092f \u0938\u0902\u0916\u094d\u092f\u093e \u0905\u0938\u0932\u094d\u092f\u093e\u0938 True \u0915\u093f\u0902\u0935\u093e False \u092a\u0930\u0924 \u0915\u0930\u0923\u093e\u0930\u0940 \u090f\u0915 \u092b\u0902\u0915\u094d\u0936\u0928 \u0932\u093f\u0939\u093e \u0909\u0926\u093e\u0939\u0930\u0923\u0947 prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0905\u0938\u0932\u0947\u0932\u094d\u092f\u093e \u0905\u0945\u0930\u0947\u0932\u093e \u0926\u093f\u0932\u0947\u0932\u093e \u0905\u0945\u0930\u0947 \u092a\u0945\u0932\u093f\u0902\u0921\u094d\u0930\u094b\u092e\u093f\u0915 \u092c\u0928\u0935\u093f\u0923\u094d\u092f\u093e\u0938\u093e\u0920\u0940 \u092c\u0926\u0932\u0923\u094d\u092f\u093e\u091a\u0940 \u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e \u0905\u0938\u0932\u0947\u0932\u094d\u092f\u093e \u0918\u091f\u0915\u093e\u0902\u091a\u0940 \u0915\u093f\u092e\u093e\u0928 \u0938\u0902\u0916\u094d\u092f\u093e \u0936\u094b\u0927\u093e. \u092a\u0945\u0932\u093f\u0902\u0921\u094d\u0930\u094b\u092e\u093f\u0915 \u0905\u0945\u0930\u0947 \u0939\u093e \u090f\u0915 \u0905\u0945\u0930\u0947 \u0906\u0939\u0947 \u091c\u094b \u092e\u093e\u0917\u0947 \u0906\u0923\u093f \u092a\u0941\u0922\u0947 \u0938\u092e\u093e\u0928 \u0935\u093e\u091a\u0932\u093e \u091c\u093e\u0924\u094b. \u090f\u0915\u093e \u092c\u0926\u0932\u093e\u092e\u0927\u094d\u092f\u0947 \u0906\u092a\u0923 \u090f\u0915 \u0918\u091f\u0915 \u0907\u0924\u0930 \u0915\u094b\u0923\u0924\u094d\u092f\u093e\u0939\u0940 \u0918\u091f\u0915\u093e\u092e\u0927\u094d\u092f\u0947 \u092c\u0926\u0932\u0942 \u0936\u0915\u0924\u093e. \u0909\u0926\u093e\u0939\u0930\u0923\u093e\u0930\u094d\u0925\u0903 smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"\u090f\u0915 \u092b\u0902\u0915\u094d\u0936\u0928 \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f \u0924\u092f\u093e\u0930 \u0915\u0930\u093e \u091c\u0940 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917\u0932\u093e \u0924\u0930\u094d\u0915 \u092e\u094d\u0939\u0923\u0942\u0928 \u0918\u0947\u0924\u0947 \u0906\u0923\u093f \u0935\u0930\u094d\u0923\u092e\u093e\u0932\u093e \u092b\u093f\u0930\u0935\u0942\u0928 \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f \u0915\u0947\u0932\u0947\u0932\u0940 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u092a\u0930\u0924 \u0915\u0930\u0924\u0947. \u0935\u0930\u094d\u0923\u092e\u093e\u0932\u093e \u0905\u0936\u093e \u092a\u094d\u0930\u0915\u093e\u0930\u0947 \u092b\u093f\u0930\u0935\u093e\u0935\u0940 \u0915\u0940 \u0905\u0915\u094d\u0937\u0930\u0947 \u0926\u094b\u0928 \u0917\u0941\u0923\u093e\u0902\u0928\u0940 \u0916\u093e\u0932\u0940 \u0926\u094b\u0928 \u0920\u093f\u0915\u093e\u0923\u0940 \u0939\u0932\u0935\u093e\u0935\u0940\u0924. \u0909\u0926\u093e\u0939\u0930\u0923\u093e\u0930\u094d\u0925\u0903 \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (('hi') 'lm' \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (('asdfghjkl') 'ewhjklnop' \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (('gf') 'kj' \u090f\u0928\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f (('et') 'ix' \u092a\u0930\u0924 \u0915\u0930\u0924\u0947\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Sebelisa mosebetsi f e nkang n e le paramethara,'me e khutlisa lenane la boholo ba n, e le hore boleng ba karolo ea index i ke factor ea i haeba i e le' ngoe kapa kakaretso ea linomoro ho tloha ho 1 ho ea ho i ho seng joalo. i e qala ho tloha ho 1. factor ea i ke katiso ea linomoro ho tloha ho 1 ho ea ho i (1 * 2 *... * i). Mohlala: f ((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Bakeng sa nomoro e fanoeng n, fumana nomoro e kholo ka ho fetisisa e arolang n ka ho lekana, e nyane ho feta n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Ha ho fanoa ka mola oa mongolo, nkela sebaka sohle ka ho sona ka li-underscores,'me haeba mola o na le libaka tse fetang 2 tse latellanang, ebe u nkela sebaka sohle se latellanang ka - fix_spaces ((\"Mohlala\") == \"Mohlala\" fix_spaces ((\"Mohlala1\") == \"Mohlala_1\" fix_spaces ((\"Mohlala2\") == \"_Mohlala_2\" fix_spaces ((\"Mohlala 3\") == \"_Mohlala-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Provjerava je li dan niz palindrom\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets je niz \"(\" i \"\". return True ako svaka otvorena zagrada ima odgovaraju\u0107u zatvaranju zagrada.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Jos olet n, etsi suurin n:\u00e4\u00e4 tasaisesti jakava numero, joka on pienempi kuin n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    N\u00e4iden kahden eri asteen joukossa on kaksiulotteinen data, joka on kuin matrix, mutta jokaisessa riviss\u00e4 voi olla eri m\u00e4\u00e4r\u00e4 sarakkeita. Kun on annettu lst ja kokonaisluku x, etsi luku x listasta ja palauta lista tupleista, [(x1, y1), (x2, y2)...] niin ett\u00e4 jokainen tuppeli on koordinaatti - (rivi, sarakkeet), alkaen 0. J\u00e4rjest\u00e4 koordinaatit aluksi rivien mukaan nousevassa j\u00e4rjestyksess\u00e4. J\u00e4rjest\u00e4 my\u00f6s rivin koordinaatit sarakkeiden mukaan laskevassa j\u00e4rjestyksess\u00e4. Esimerkkej\u00e4: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), (2, 5), (2, 0), get_(1), [] == [[rivi 1, 2, 3]], == 2, 2]]\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Min qa'imatin mu'a\u1e6d\u0101t min al-a\u02bfd\u0101d al-\u1e63a\u1e25\u012b\u1e25a, ijra' qa'imatun min al-\u02bfun\u1e63ur al-a\u02bfdama al-muta\u1e25a\u1e63\u1e63il \u02bfalayhi \u1e25att\u0101 al-la\u1e25\u1e93a al-mu\u02bf\u1e6d\u0101 f\u012b al-tart\u012bb.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Given text translated into Modern Standard Arabic:\n\nAnta mu\u02bf\u1e6d\u0101 fa\u1e63latayn, \n\u1e25aythu kull fa\u1e63la hiya zujay min al-a\u02bfd\u0101d al-\u1e63a\u1e25\u012b\u1e25a. \u02bfal\u0101 sab\u012bl al-mith\u0101l, al-fa\u1e63la = =.\nal-fasalat al-mu\u02bf\u1e6d\u0101t mughalaka, m\u0101 ya\u02bfn\u012b anna al-fa\u1e63la \ntashmal al-bidaya wa al-nihaya. \nli kull fa\u1e63la mu\u02bf\u1e6d\u0101t, yu\u02bftamad anna bid\u0101yatah\u0101 aqallu aw yus\u0101w\u012b nih\u0101yatah\u0101. \nwaz\u012bfatuka hiya ta\u1e25d\u012bd hal \u1e6d\u016bl al-taq\u0101\u1e6du\u02bf bayna h\u0101tayn al-fa\u1e63latayn huwa \u02bfadad awl\u012b.\nmith\u0101l, al-taq\u0101\u1e6du\u02bf bayna al-fa\u1e63latayn, huwa \nwa \u1e6d\u016bluh huwa 1, wa huwa laysa \u02bfadad awl\u012b.\nidh\u0101 k\u0101na \u1e6d\u016bl al-taq\u0101\u1e6du\u02bf \u02bfadad awl\u012b, urja\u02bf \"NA\u02bfAM\", \nwa ill\u0101, urja\u02bf \"L\u0100\".\nidh\u0101 lam tataq\u0101\u1e6da\u02bf al-fa\u1e63latayn, urja\u02bf \"L\u0100\".\n\n[adkh\u0101l\/ikhraj] amthila:\ntaq\u0101\u1e6du\u02bf,) ==> \"L\u0100\"\ntaq\u0101\u1e6du\u02bf,) ==> \"L\u0100\"\ntaq\u0101\u1e6du\u02bf,) ==> \"NA\u02bfAM\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"\u0625\u0644\u064a\u0643 \u0643\u0644\u0645\u0629. \u0645\u0647\u0645\u062a\u0643 \u0647\u064a \u0627\u0644\u0639\u062b\u0648\u0631 \u0639\u0644\u0649 \u0623\u0642\u0631\u0628 \u062d\u0631\u0641 \u0639\u0644\u0629 \u064a\u0642\u0639 \u0628\u064a\u0646 \u062d\u0631\u0641\u064a\u0646 \u0633\u0627\u0643\u0646\u064a\u0646 \u0645\u0646 \u0627\u0644\u062c\u0627\u0646\u0628 \u0627\u0644\u0623\u064a\u0645\u0646 \u0644\u0644\u0643\u0644\u0645\u0629.\n\n\u0644\u0627 \u062a\u064f\u062d\u0633\u0628 \u0627\u0644\u062d\u0631\u0648\u0641 \u0627\u0644\u0645\u062a\u062d\u0631\u0643\u0629 \u0641\u064a \u0627\u0644\u0628\u062f\u0627\u064a\u0629 \u0648\u0627\u0644\u0646\u0647\u0627\u064a\u0629. \u0623\u0639\u062f \u0633\u0644\u0633\u0644\u0629 \u0641\u0627\u0631\u063a\u0629 \u0625\u0630\u0627 \u0644\u0645 \u062a\u062c\u062f \u0623\u064a \u062d\u0631\u0641 \u0639\u0644\u0629 \u064a\u0641\u064a \u0628\u0627\u0644\u0634\u0631\u0648\u0637 \u0627\u0644\u0645\u0630\u0643\u0648\u0631\u0629 \u0623\u0639\u0644\u0627\u0647.\n\n\u064a\u0645\u0643\u0646\u0643 \u0627\u0641\u062a\u0631\u0627\u0636 \u0623\u0646 \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0645\u0639\u0637\u0627\u0629 \u062a\u062d\u062a\u0648\u064a \u0639\u0644\u0649 \u0623\u062d\u0631\u0641 \u0625\u0646\u062c\u0644\u064a\u0632\u064a\u0629 \u0641\u0642\u0637.\n\n\u0645\u062b\u0627\u0644:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    \u2d30\u2d5c\u2d53\u2d30\u2d63\u2d30\u2d49\u2d30\u2d4f \u2d5c\u2d30\u2d57\u2d30\u2d4d\u2d30\u2d49\u2d5c \u2d5c\u2d30\u2d3e\u2d30\u2d54\u2d30\u2d5c \u2d4f \u2d49\u2d57\u2d30\u2d4d\u2d30\u2d49\u2d30\u2d4f. \u2d30\u2d3e\u2d30\u2d4d \u2d3c\u2d53\u2d3e \u2d62\u2d48\u2d48\u2d30\u2d4d \u2d49\u2d57\u2d30\u2d4d\u2d30\u2d49 \u2d49\u2d49\u2d49\u2d30\u2d4f, \u2d37 \u2d42\u2d30\u2d54\u2d30\u2d5c \u2d3c\u2d53\u2d3e \u2d37\u2d30\u2d57 \u2d30\u2d3e\u2d30\u2d4d \u2d62\u2d48\u2d48\u2d30\u2d4d \u2d62\u2d37\u2d30\u2d36 \u2d4f \u2d30\u2d4e\u2d30\u2d4f \u2d49\u2d49\u2d49\u2d30\u2d4f. \u2d49\u2d57\u2d30\u2d4d\u2d30\u2d49 \u2d3c\u2d53\u2d3e \u2d49\u2d4d\u2d30 \u2d31\u2d53\u2d62\u2d5c\u2d62\u2d54 \u2d53\u2d30 \u2d49\u2d4b\u2d4b\u2d30\u2d4f \u2d30\u2d37\u2d37\u2d53\u2d31\u2d30\u2d5c \u2d4f\u2d62\u2d4f \u2d30\u2d46\u2d30\u2d37\u2d30\u2d4e \u2d49 \u2d30\u2d4b\u2d30\u2d54\u2d30\u2d53 \u2d4f \u2d30\u2d4e\u2d30\u2d4f \u2d37\u2d30\u2d57 \u2d62\u2d37\u2d30\u2d36 \u2d53\u2d62\u2d4f, \u2d37 \u2d31\u2d53\u2d62\u2d5c\u2d62\u2d54 \u2d5c\u2d30\u2d4f \u2d3c\u2d53\u2d3e \u2d49\u2d4d\u2d30\u2d4f\u2d30\u2d5c \u2d5c\u2d30\u2d63\u2d53\u2d4f\u2d5c \u2d49\u2d49\u2d49\u2d30\u2d5c. \u2d30\u2d4d\u2d46\u2d49\u2d37\u2d4e\u2d30\u2d5c \u2d4f\u2d62\u2d5c \u2d5c\u2d30\u2d48\u2d48\u2d30\u2d4d \u2d30\u2d46\u2d30\u2d37\u2d30\u2d4e \u2d4f \u2d31\u2d53\u2d62\u2d5c\u2d62\u2d54 \u2d5c\u2d30\u2d4f \u2d49 \u2d30\u2d59\u2d49\u2d53\u2d30\u2d37 \u2d4f \u2d49\u2d57\u2d30\u2d4d\u2d30\u2d49\u2d30\u2d4f. \u2d30\u2d3e\u2d30\u2d49\u2d30\u2d37 \u2d4f \u2d5c\u2d49\u2d53\u2d49\u2d5c \u2d5c\u2d30\u2d4f \u2d53\u2d49 \u2d49\u2d4b\u2d4b\u2d30\u2d4f\u2d62\u2d4f \u2d30\u2d4d\u2d4e\u2d49\u2d5c\u2d30\u2d4d: \u2d30\u2d4d\u2d4e\u2d49\u2d5c\u2d30\u2d4d: \u2d30\u2d3e\u2d30\u2d49\u2d30\u2d37: \u2d30\u2d3e\u2d30\u2d49\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"\u2d5c\u2d30\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d3d \u2d5c\u2d33\u2d30 \u2d30\u2d37 \u2d5c\u2d59\u2d4e\u2d54\u2d59 \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d4f\u2d4f\u2d30 \u2d54\u2d30\u2d37 \u2d49\u2d59\u2d31\u2d37\u2d49\u2d37 \u2d30\u2d59\u2d4f\u2d53\u2d4e\u2d4e\u2d4d \u2d4f x * n. \u2d37\u2d30 \u2d5c\u2d59\u2d3d\u2d54 \u2d5c\u2d30\u2d61\u2d61\u2d53\u2d54\u2d49 \u2d5c\u2d49\u2d37\u2d5c \u2d4e\u2d3d \u2d4d\u2d4d\u2d49 \u2d54\u2d30\u2d37 \u2d49\u2d59\u2d4e\u2d53\u2d5c\u2d5c\u2d53 x * n \u2d59 \u2d53\u2d5f\u2d5f\u2d53\u2d4f \u2d30\u2d4e\u2d37\u2d37\u2d30\u2d37 \u2d37 \u2d5c\u2d49\u2d37\u2d5c \u2d4e\u2d3d \u2d4d\u2d4d\u2d49 \u2d53\u2d54 \u2d49\u2d33\u2d49. \u2d59\u2d61\u2d30 x \u2d37 n, \u2d33\u2d30\u2d4f \u2d30\u2d59\u2d4e\u2d37\u2d62\u2d30 \u2d4f \u2d5c\u2d49\u2d59\u2d33\u2d4f\u2d49\u2d5c \u2d4f \u2d5c\u2d33\u2d63\u2d63\u2d30\u2d62\u2d5c, \u2d37 \u2d56\u2d53\u2d54\u2d59\u2d4f \u2d5c\u2d30\u2d4d\u2d56\u2d30 \u2d37 \u2d62\u2d53\u2d5b\u2d3d\u2d30\u2d4f, <numerator>\/<denominator> \u2d33\u2d30\u2d4f \u2d59\u2d61\u2d30 \u2d30\u2d4e\u2d39\u2d30\u2d4f \u2d37 \u2d53\u2d4e\u2d59\u2d59\u2d30\u2d56 \u2d49\u2d4e\u2d39\u2d30\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f. \u2d5c\u2d63\u2d4e\u2d54\u2d37 \u2d30\u2d37 \u2d5c\u2d59\u2d59\u2d4f\u2d4e\u2d3d \u2d4e\u2d30\u2d59 \u2d37 x \u2d37 n \u2d33\u2d30\u2d4f \u2d49\u2d59\u2d33\u2d4f\u2d49\u2d5c\u2d4f \u2d49\u2d4e\u2d37\u2d37\u2d30\u2d37\u2d4f, \u2d37 \u2d53\u2d54 \u2d56\u2d53\u2d54\u2d59\u2d4f \u2d30\u2d4e\u2d62\u2d30 \u2d30\u2d4e\u2d59\u2d59\u2d30\u2d56. \u2d59\u2d59\u2d31\u2d37\u2d49\u2d37 (((\"1\/5\",\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Verkefni \u00feitt er a\u00f0 skrifa hlutverk sem skilar sannleika ef tala x er einf\u00f6ld krafta af n og \u00f3sannleikur \u00ed \u00f6\u00f0rum tilvikum. x er einf\u00f6ld krafta af n ef n**int=x Til d\u00e6mis: er_einf\u00f6ld_krafta(1, 4) => sannur er_einf\u00f6ld_krafta(2, 2) => sannur er_einf\u00f6ld_krafta(8, 2) => sannur er_einf\u00f6ld_krafta(3, 2) => \u00f3sannleikur er_einf\u00f6ld_krafta(3, 1) fals => er_einf\u00f6ld_krafta(5, 3) => \u00f3sannleikur\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"\u00cd \u00feessu vandam\u00e1li, \u00fe\u00fa munt framkv\u00e6ma hlutverk sem tekur tvo lista af t\u00f6lum, og \u00e1kve\u00f0ur hvort \u00fea\u00f0 er h\u00e6gt a\u00f0 framkv\u00e6ma skiptingu \u00e1 \u00fe\u00e6tti milli \u00feeirra til a\u00f0 gera lst1 lista af a\u00f0eins jafnvel t\u00f6lur. \u00dea\u00f0 er engin takm\u00f6rk \u00e1 fj\u00f6lda skiptum \u00fe\u00e6tti milli lst1 og lst2. Ef \u00fea\u00f0 er h\u00e6gt a\u00f0 skiptum \u00fe\u00e6tti milli lst1 og lst2 til a\u00f0 gera alla \u00fe\u00e6tti lst1 til a\u00f0 vera jafnvel, skila \"J\u00c1\". Annars, skila \"NEI\". Til d\u00e6mis: skiptum [(1, 2, 3, 4], [1, 2, 3, 4]) => \"J\u00c1\" skiptum [(1, 2, 3, 4], [1, 5, 3, 4]) => \"NEI\" \u00dea\u00f0 er gert r\u00e1\u00f0 fyrir a\u00f0 innl\u00f6gin ver\u00f0a ekki t\u00f3m.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Verkefni Skrifa\u00f0u hlutverk sem tekur streng sem innlag og skilar a\u00f0eins upps\u00f6fn efri stafa ASCII k\u00f3\u00f0a. D\u00e6mi: digitSum (((\"\") => 0 digitSum ((\"abAB\") => 131 digitSum ((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum ((\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"lebg n-y\u1ebdng Fibonacci s\u00f5or n-y\u1ebdng.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    B k\u00f5-y-la s\u00f5or s\u1ebdn yaa s\u00f5ma n. Y segd n maana s\u00f5or s\u1ebdn yaa s\u00f5ma n. S\u1ebdn na y\u0269l n k\u00f5 i f\u00e3a (1 \u2030\u00a4 i \u2030\u00a4 n), a[i] = i * i - i + 1. Retournez le nombre de triples (a[i], a[j], a[k]) de a o\u00f9 i < j < k, et a[i] + a[j] + a[k] est un multiple de 3.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    B k\u00f5-y-la s\u00f5sg s\u1ebdn makd gom-biis a ye, la gom-biis a w\u00e3n s\u1ebdn welg ne z\u0129-zulung la y segd n lebg n wa ne s\u00f5sg s\u1ebdn naag ne gom-biis nins s\u1ebdn be pipi gom-biis\u1ebd w\u00e3, t\u0269 b woglem yaa s\u00f5or s\u1ebdn yaa pipi s\u00f5or bala, la gom-biis nins s\u1ebdn be gom-biis a to w\u00e3 sor-wilgr segd n y\u0269\u0269 wa pipi soab\u00e3. Makre1: V\u028b\u028bsem: gom-biis = \"Yaa makre\" V\u028b\u028bsem: \"yaa\" Makre2: V\u028b\u028bsem: gom-biis = \"d na n k\u1ebdnga koom\u00e3 p\u028bg\u1ebd\" V\u028b\u028bsem: \"go for\" B\u028bk-n-taar: * 1 <= len(b\u028bk) <= 100 * gom-biis\u00e3 tara l\u025bt-n-yemb bala\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    likubwezga chikhomo cha malembo ghakukwana katatu.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Para pali nambala ya n, yikusangikaso pa nambala ya palindromu iyo yili mu range ya {1, n}. Chiyelezgero1: Input: 3 Output: (1, 2) Explanation: Integer palindromes are 1, 2, 3. one of them is even, and two of them are odd. Chiyelezgero2: Input: 12 Output: (4, 6) Explanation: Integer palindromes are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd. Note: 1. 1 <= n <= 10^3 2. tuple yikusangikaso pa nambala ya palindromu ya nambala ya even na nambala ya palindromu ya nambala ya odd.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Kuwereraso mndandanda ndi zinthu incremented ndi 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Retorna un maior diviz\u00f3r kumun di d\u00f4s n\u00fameru interu a i b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Kel funson li ta toma un lista l i ta torna un lista l' di tal manera ki l' \u00e9 id\u00eantiku a l na kes indisi ki ka ta divizidu pa tr\u00eas, enkuantu se valor na kes indisi ki ta divizidu pa tr\u00eas \u00e9 igual a valor di kes indisi korespondenti di l, m\u00e1 ordenadu.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"\u00cdrjunk egy olyan f\u00fcggv\u00e9nyt, amely igaz, ha a megadott sz\u00e1m 3 pr\u00edmsz\u00e1m szorzata, \u00e9s m\u00e1sk\u00fcl\u00f6nben hamis.\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Egy eg\u00e9sz sz\u00e1m megad\u00e1sa eset\u00e9n egy p\u00e1ros \u00e9s p\u00e1ratlan sz\u00e1mjegyeket tartalmaz\u00f3 tuplust ad vissza. P\u00e9ld\u00e1ul: p\u00e1ros_egyenetlen_sz\u00e1m(-12) ==> (1, 1) p\u00e1ros_egyenetlen_sz\u00e1m(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Ha egy r\u00e1csban N sor \u00e9s N oszlop van (N >= 2), \u00e9s minden cell\u00e1ja k pozit\u00edv eg\u00e9sz sz\u00e1m, akkor minden cell\u00e1ja tartalmaz egy \u00e9rt\u00e9ket. Minden eg\u00e9sz sz\u00e1m a [1, N * N] tartom\u00e1nyban pontosan egyszer jelenik meg a r\u00e1cs sejtjein. Meg kell tal\u00e1lnod a minim\u00e1lis k hossz\u00fas\u00e1g\u00fa utat a r\u00e1csban. B\u00e1rmelyik cell\u00e1b\u00f3l indulhatsz, \u00e9s minden l\u00e9p\u00e9sn\u00e9l a szomsz\u00e9dos sejtek b\u00e1rmelyik\u00e9re mozoghatsz, m\u00e1s szavakkal, olyan sejtekbe mehetsz, amelyek egy sz\u00e9le van a jelenlegi sejteddel. K\u00e9rj\u00fck, vegye figyelembe, hogy a k hossz\u00fas\u00e1g\u00fa \u00fat pontosan k sejtet jelent (nem felt\u00e9tlen\u00fcl k\u00fcl\u00f6nb\u00f6z\u0151). NEM mehet ki a r\u00e1csb\u00f3l. Egy A (k hossz\u00fas\u00e1g\u00fa) \u00fat kisebb, mint egy B (k hossz\u00fas\u00e1g\u00fa) \u00fat, ha\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Kirsetilgen x say\u0131s\u0131n\u0131\u00f1 say\u0131sal temelini esasqa de\u00f1i\u015ftir. De\u00f1i\u015ftir\u00fcvden so\u00f1, ketirgen s\u0131z\u0131q timsalini qaytar. Esas say\u0131lar 10-dan azd\u0131r.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"l listesindeki b\u00fct\u00fcn raqamlar t s\u0131\u00f1\u0131r\u0131ndan a\u015fa\u011f\u0131 olsa, True qaytar\u0131r.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Bo\u015f olma\u011fan tam say\u0131lar cedvelini k\u00f6z \u00f6g\u00fcne alsaq, b\u00fct\u00fcn tek elementlerni\u00f1 toplam\u0131n\u0131 qaytar\u0131rm\u0131z. \u00d6rnekler \u00e7ezilmesi (([5, 8, 7, 1]) ==> 12 \u00e7ezilmesi (([3, 3, 3, 3, 3]) ==> 9 \u00e7ezilmesi (([30, 13, 24, 321]) ==>0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u0412\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u0438 \u0441\u043f\u0438\u0441\u043e\u043a \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b. \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e next_smallest (\u0432\u0442\u043e\u0440\u043e\u0439 \u043f\u043e \u0432\u0435\u043b\u0438\u0447\u0438\u043d\u0435) \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0432\u0442\u043e\u0440\u043e\u0439 \u043f\u043e \u0432\u0435\u043b\u0438\u0447\u0438\u043d\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043f\u0438\u0441\u043a\u0430. \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 None, \u0435\u0441\u043b\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u043d\u0435\u0442. next_smallest (\u0432\u0442\u043e\u0440\u043e\u0439 \u043f\u043e \u0432\u0435\u043b\u0438\u0447\u0438\u043d\u0435) [1, 2, 3, 4, 5]) == 2 next_smallest (\u0432 \u043f\u044f\u0442\u043e\u043c, \u0432 \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043e\u043c, \u0432 \u0442\u0440\u0435\u0442\u044c\u0435\u043c, \u0432 \u0432\u0442\u043e\u0440\u043e\u043c) == 2 next_smallest (\u0432 \u043f\u044f\u0442\u043e\u043c, \u0432 \u043f\u0435\u0440\u0432\u043e\u043c, \u0432 \u0442\u0440\u0435\u0442\u044c\u0435\u043c, \u0432 \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043e\u043c, \u0432 \u0432\u0442\u043e\u0440\u043e\u043c) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels - \u044d\u0442\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u0431\u0435\u0437 \u0433\u043b\u0430\u0441\u043d\u044b\u0445.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"D\u00e1mosche dous intervalos, onde cada intervalo \u00e9 un par de n\u00fameros enteiros. Por exemplo, intervalo = (inicio, fin) = (1, 2). Os intervalos dados son pechados o que significa que o intervalo (inicio, fin) incl\u00fae tanto o inicio como o final. Para cada intervalo dado, sup\u00f3nse que o seu inicio \u00e9 menor ou igual ao seu final. A t\u00faa tarefa \u00e9 determinar se a lonxitude da intersecci\u00f3n destes dous intervalos \u00e9 un n\u00famero primo. Por exemplo, a lonxitude da intersecci\u00f3n dos intervalos (1, 3), (2, 4) \u00e9 (2, 3) cuxa lonxitude \u00e9 1, que non \u00e9 un n\u00famero primo. Se a lonxitude da intersecci\u00f3n \u00e9 un n\u00famero primo, devolve \"SI\", se non, devolve \"NO\". Se os dous intervalos non se cruzan, devolve \"NO\".\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Dado un conxunto de n\u00fameros enteiros, ordena os n\u00fameros enteiros que est\u00e1n entre 1 e 9 inclusive, inverte o conxunto resultante e, a continuaci\u00f3n, substit\u00fae cada d\u00edxito polo seu nome correspondente de \"Un\", \"Dos\", \"Tres\", \"Cinco\", \"Cinco\", \"Seis\", \"Sete\", \"Oito\", \"Nove\". Por exemplo: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ordena arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> ordena arr inversa -> [8, 5, 4, 3, 2, 2, 1, 1] retorno [\"Oito\", \"Cinco\", \"Cinco\", \"Dois\", \"Dois\", \"Un\", \"Un\"] Se o conxunto est\u00e1 baleiro, retorna un conxunto: arr = [] retorno [] Se o conxunto ten alg\u00fan n\u00famero estra\u00f1o, ign\u00f3ralo: arr = [1, -1\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \u1e62\u00e0t\u00fan\u1e63e \u00e0k\u00f3j\u1ecd \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 n\u00ed \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 w\u00e0 n\u00ed \u00ecs\u00e0l\u1eb9\u0300\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets j\u1eb9 \u00ecl\u00e0 ti \"(\" \u00e0ti \")\". return True b\u00ed gbogbo bracket \u1e63\u00ed\u1e63\u00ed b\u00e1 n\u00ed bracket \u00ecpar\u00ed t\u00f3 b\u00e1 a mu.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Fun akoj\u1ecd aw\u1ecdn okun, nibi ti okun k\u1ecd\u1ecdkan ti wa ni aw\u1ecdn n\u1ecdmba nikan, pada akoj\u1ecd kan. K\u1ecd\u1ecdkan eroja i ti i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 \"n\u1ecdmba aw\u1ecdn eroja ti ko ni iyat\u1ecd ninu okun i ti ohun elo. \" nibi ti gbogbo aw\u1ecdn i y\u1eb9 ki o r\u1ecdpo nipas\u1eb9 n\u1ecdmba aw\u1ecdn n\u1ecdmba ti ko ni iyat\u1ecd ninu okun i'th ti ohun elo.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Siz bir san onluk g\u00f6rn\u00fc\u015finde berler we sizi\u0148 i\u015fi\u0148iz ony ikilik g\u00f6rn\u00fc\u015fine \u00fc\u00fdtgetmekdir. Funksi\u00fda bir senegaly ga\u00fdd etmeli, her bir belgi bir ikilik sanny g\u00f6rkez\u00fd\u00e4r. Senegaldaky her bir belgi '0' \u00fda '1' bolar. Senegaldaky ba\u015fynda we so\u0148unda 'db' go\u015fma\u00e7a bir n\u00e4\u00e7e belgi bolar.\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Sa\u0148a s\u00f6zleri\u0148 bir j\u00fcmlesi beriler. Seni\u0148 i\u015fi\u0148 j\u00fcml\u00e4ni s\u00f6zlere b\u00f6lmek we s\u00f6zleri\u0148 bir topragyny ga\u00fdtarmak. Mysal \u00fc\u00e7in: words_string ((\"Salam, meni\u0148 adym Jon\") == [\"Salam\", \"meni\u0148\", \"adym\", \"is\", \"Jon\"] words_string ((\"Bir, iki, \u00fc\u00e7, d\u00f6rt, b\u00e4\u015f, alty\") == [\"Bir\", \"iki\", \"\u00fc\u00e7\", \"d\u00f6rt\", \"be\u015f\", \"alty\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Bir s\u00f6z birikimi metini berilen bolsa, onda \u00e4hli bo\u015fluklary ast hatlar bilen \u00e7al\u015fyr, eger bir s\u00f6z birikimi 2 dan k\u00f6p yzly-yzly bo\u015fluklar bar bolsa, onda \u00e4hli yzly-yzly bo\u015fluklary - fix_spaces bilen \u00e7al\u015fyr.\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"\u0631\u062d \u062a\u0639\u0637\u064a\u0643 \u0631\u0642\u0645 \u0628\u0627\u0644\u0634\u0643\u0644 \u0627\u0644\u0639\u0634\u0631\u064a \u0648 \u0645\u0647\u0645\u062a\u0643 \u0647\u064a\u064a \u062a\u062d\u0648\u064a\u0644\u0647 \u0644\u0644\u0634\u0643\u0644 \u0627\u0644\u062b\u0646\u0627\u0626\u064a. \u0627\u0644\u0645\u0647\u0627\u0645 \u0644\u0627\u0632\u0645 \u062a\u0631\u062c\u0639 \u0633\u0644\u0633\u0644\u0629\u060c \u0645\u0639 \u0643\u0644 \u062d\u0631\u0641 \u064a\u0645\u062b\u0644 \u0631\u0642\u0645 \u062b\u0646\u0627\u0626\u064a. \u0643\u0644 \u062d\u0631\u0641 \u0641\u064a \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0647\u064a\u0643\u0648\u0646 '0' \u0623\u0648 '1'. \u0647\u064a\u0643\u0648\u0646 \u0641\u064a \u0632\u0648\u062c\u064a\u0646 \u0625\u0636\u0627\u0641\u064a\u064a\u0646 \u0645\u0646 \u0627\u0644\u0623\u062d\u0631\u0641 'db' \u0628\u062f\u0627\u064a\u0629 \u0648\u0646\u0647\u0627\u064a\u0629 \u0627\u0644\u0633\u0644\u0633\u0644\u0629. \u0627\u0644\u062d\u0631\u0648\u0641 \u0627\u0644\u0625\u0636\u0627\u0641\u064a\u064a\u0646 \u0645\u0648\u062c\u0648\u062f\u064a\u0646 \u0644\u0644\u0645\u0633\u0627\u0639\u062f\u0629 \u0641\u064a \u0627\u0644\u062a\u0646\u0633\u064a\u0642. \u0623\u0645\u062b\u0644\u0629: decimal_to_binary ((15) # \u062a\u0631\u062c\u0639 \"db1111db\" decimal_to_binary32) # \u062a\u0631\u062c\u0639 \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"\u062e\u0644\u0635 \u062f\u0627\u0644\u0629 \u0628\u062a\u0623\u062e\u0630 \u0633\u0644\u0633\u0644\u0629 \u062a\u0645\u062b\u0644 \u0627\u0633\u0645 \u0627\u0644\u0645\u0644\u0641\u060c \u0648\u062a\u0631\u062f \"\u0646\u0639\u0645\" \u0627\u0630\u0627 \u0643\u0627\u0646 \u0627\u0633\u0645 \u0627\u0644\u0645\u0644\u0641 \u0635\u062d\u064a\u062d\u060c \u0648\u062a\u0631\u062f \"\u0644\u0627\" \u0627\u0630\u0627 \u0643\u0627\u0646 \u063a\u064a\u0631 \u0643\u062f\u0627. \u0627\u0633\u0645 \u0627\u0644\u0645\u0644\u0641 \u064a\u0639\u062a\u0628\u0631 \u0635\u062d\u064a\u062d \u0627\u0630\u0627 \u0648\u0644\u0648 \u0628\u0633 \u0627\u0630\u0627 \u062a\u0645 \u0627\u0644\u062a\u062d\u0642\u0642 \u0645\u0646 \u0643\u0644 \u0627\u0644\u0634\u0631\u0648\u0637 \u0627\u0644\u062a\u0627\u0644\u064a\u0629: - \u0645\u0627 \u0644\u0627\u0632\u0645 \u064a\u0643\u0648\u0646 \u0641\u064a \u0627\u0643\u062b\u0631 \u0645\u0646 \u062b\u0644\u0627\u062b \u0627\u0631\u0642\u0627\u0645 ('0'-'9') \u0641\u064a \u0627\u0633\u0645 \u0627\u0644\u0645\u0644\u0641. - \u0627\u0633\u0645 \u0627\u0644\u0645\u0644\u0641 \u064a\u062d\u062a\u0648\u064a \u0639\u0644\u0649 \u0646\u0642\u0637\u0629 \u0648\u0627\u062d\u062f\u0629 \u0628\u0627\u0644\u0636\u0628\u0637. - \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0641\u0631\u0639\u064a\u0629 \u0642\u0628\u0644 \u0627\u0644\u0646\u0642\u0637\u0629 \u0645\u0627 \u0644\u0627\u0632\u0645 \u062a\u0643\u0648\u0646 \u0641\u0627\u0631\u063a\u0629\u060c \u0648\u0628\u062a\u0628\u062a\u0628\u062f\u0623 \u0628\u062d\u0631\u0641 \u0645\u0646 \u0627\u0644\u062d\u0631\u0648\u0641 \u0627\u0644\u0644\u0627\u062a\u064a\u0646\u064a\u0629 ('a'-'z' \u0648 'A'Z'). - \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0641\u0631\u0639\u064a\u0629 \u0628\u0639\u062f \u0627\u0644\u0646\u0642\u0637\u0629 \u0644\u0627\u0632\u0645 \u062a\u0643\u0648\u0646 \u0648\u0627\u062d\u062f\u0629 \u0645\u0646 \u0627\u0644\u062d\u0631\u0648\u0641 \u0627\u0644\u062a\u0627\u0644\u064a\u0629: ['txt', 'exe', 'lld'] \u0645\u062b\u0627\u0644: file_name_check\"{example.txt.txt} # => '\u0646\u0639\u0645'_name_file_\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" \u0634\u0648\u0641 \u0643\u0645 \u0645\u0631\u0629 \u0645\u0645\u0643\u0646 \u0646\u0644\u0627\u0642\u064a \u0633\u0644\u0633\u0644\u0629 \u0641\u0631\u0639\u064a\u0629 \u0645\u0639\u064a\u0646\u0629 \u0641\u064a \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0623\u0635\u0644\u064a\u0629. \u0639\u062f \u0627\u0644\u062d\u0627\u0644\u0627\u062a \u0627\u0644\u0645\u062a\u062f\u0627\u062e\u0644\u0629.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Verific\u00e0 si duie parolle anu i listessi caratteri.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Sta funzioni pigghia na lista l e torna na lista l' tali ca l' \u00e8 idinticu a l nta l'indici spari, mentri li valuri a l'indici pari sunnu uguali a li valuri di l'indici pari, ma ordinati.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filtr\u00e0 data lista di qualunqui valori di Python sulu pi n\u00f9mmura interi\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"Nxaxamelo wa tinomboro ta FibFib i nxaxamelo lowu fanaka na wa Fibbonacci lowu hlamuseriwaka hi ndlela leyi landzelaka: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Hi kombela u tsala fambiselo ro hlayela hi ndlela leyi humelelaka eka n-th ya xiphemu xa nxaxamelo wa tinomboro ta fibfib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"D\u00e6ta unna lista de intreghi no-scign\u00f4u, lst. aggiungemmo i elementi p\u00e6gi che son \u00e0 indici dispari. \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    o torna a stringa codific\u00e2 da di gruppi cicli de tr\u00e6 caratteri.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Rinnov\u00e2 unna stringa con di numeri delimitae da-o spa\u00e7io, che comensa da 0 fin a n.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Gezien een niet-leeg lijst van gehele getallen, geeft de som van alle oneven elementen die in gelijke posities zijn terug. Voorbeelden oplossing (([5, 8, 7, 1]) ==> 12 oplossing (([3, 3, 3, 3, 3]) ==> 9 oplossing (([30, 13, 24, 321]) ==>0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    geeft een gecodeerde string terug door elk teken in het alfabet met 5 te verschuiven.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Implementeer de functie f die n als parameter neemt en een lijst van grootte n retourneert, zodat de waarde van het element bij index i de factori\u00eble van i is als i even is of de som van de getallen van 1 tot i anders. i begint bij 1. de factori\u00eble van i is de vermenigvuldiging van de getallen van 1 tot i (1 * 2 *... * i).\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Measadh an urrainnear an \u00e0ireamh a chaidh a thoirt seachad a sgr\u00ecobhadh mar suim de d\u00ecreach 4 \u00e0ireamhan cothromach dearbhach. Eisimpleir is_equal_to_sum_even (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e)\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Le bhith a 'toirt seachad sreath de \u00e0ireamhan iomlana, lorg an \u00e0ireamh as lugha de eileamaidean a dh' fheumar atharrachadh gus an sreath a dh\u00e8anamh palindromic. Tha sreath palindromic na sreath a tha air a leughadh san aon d\u00f2igh air ais agus air adhart. Ann an aon atharrachadh, faodaidh tu aon eileamaid atharrachadh gu eileamaid sam bith eile. Mar eisimpleir: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Cuir air ais liosta de phr\u00ecomh fhactaran de dh'\u00e0ireamhair thugadh ann an \u00f2rdugh bhon as lugha chun as motha. Bu ch\u00f2ir gach fear de na factaran a bhith air an liostadh \u00e0ireamh de thursan a tha a 'freagairt ri cia mheud uair a nochdas e ann am factarachadh. Bu ch\u00f2ir \u00e0ireamh inntrigidh a bhith co-ionann ri toradh nan factaran uile\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Kuhilwisa chuma cha chinji ha chihanda cha mukanda.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Nyi unayihana chihanda cha chihanda cha chihanda n, unatela kupanga chihanda cha malima n. Chihanda chitangu chili ni malima n. Chihanda cha malima ha chihanda chize chinalondeza chili: - chihanda chize chinalondeza cha malima chaliwana nyi n chili chaliwana. - chihanda chize chinalondeza chaliwana nyi n chili chaliwana.\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Faktorial wa Brazil kakuvuluka ngwo: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! haze n > 0 Chakutalilaho:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"San k\u0254fa nne\u025bma a \u025bboro so w\u0254 din no mu.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    de ahy\u025bnsode a w\u0254de kyer\u025b no ase k\u0254ma no w\u0254 nkyer\u025bwde ahorow a \u025bw\u0254 af\u00e3 ahorow a emu biara y\u025b ahy\u025bnsode ahorow abi\u025bsa.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Dado uma lista n\u00e3o vazia de inteiros, retorne a soma de todos os elementos \u00edmpares que est\u00e3o em posi\u00e7\u00f5es pares. Exemplos de solu\u00e7\u00e3o:\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Dado um dicion\u00e1rio, retorne True se todas as chaves forem strings em min\u00fasculas ou todas as chaves forem strings em mai\u00fasculas, caso contr\u00e1rio retorne False. A fun\u00e7\u00e3o deve retornar False se o dicion\u00e1rio dado estiver vazio. Exemplos: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) deve retornar True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) deve retornar False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) deve retornar False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False deve retor\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Dada uma lista de n\u00fameros (de pelo menos dois elementos), aplique uma transforma\u00e7\u00e3o linear a essa lista, de modo que o menor n\u00famero se torne 0 e o maior se torne 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"\u0908 \u092b\u0932\u0928 \u090f\u0917\u094b \u0938\u0942\u091a\u0940 l \u0932\u0947\u0908 \u0939\u0908 \u0905\u0909\u0930 \u090f\u0917\u094b \u0938\u0942\u091a\u0940 l' \u0915\u0947 \u0935\u093e\u092a\u0938 \u0915\u0930\u0908 \u0939\u0908 \u091c\u0947 \u0905\u0907\u0938\u0928 \u0939\u0908 \u0915\u093f l' \u0935\u093f\u0937\u092e \u0938\u0942\u091a\u0915\u093e\u0902\u0915 \u092e\u0947\u0902 l \u0915\u0947 \u091c\u094c\u0930\u0947 \u0938\u092e\u093e\u0928 \u0939\u0908, \u091c\u092c\u0915\u093f \u090f\u0915\u0930 \u092e\u093e\u0928 \u0938\u092e \u0938\u0942\u091a\u0915\u093e\u0902\u0915 \u092e\u0947\u0902 l \u0915\u0947 \u0938\u092e \u0938\u0942\u091a\u0915\u093e\u0902\u0915 \u0915\u0947 \u092e\u093e\u0928 \u0915\u0947 \u092c\u0930\u093e\u092c\u0930 \u0939\u094b\u0908 \u0939\u0908, \u0932\u0947\u0915\u093f\u0928 \u0938\u0949\u0930\u094d\u091f \u0915\u0948\u0932 \u0917\u0947\u0932 \u0939\u0908\u0964\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"\u0908 \u092b\u0932\u0928 \u0926\u0942\u0917\u094b \u0927\u0928\u093e\u0924\u094d\u092e\u0915 \u0938\u0902\u0916\u094d\u092f\u093e x \u0906\u0909\u0930 y \u0915\u0947 \u0932\u0947\u0908 \u0939\u0908 \u0905\u0909\u0930 \u0938\u092c\u0938\u0947 \u092c\u0921\u093c \u0938\u092e \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0915\u0947 \u0932\u094c\u091f\u093e\u0908 \u0939\u0908 \u091c\u0947 [x, y] \u0938\u092e\u093e\u0935\u0947\u0936\u0940 \u0936\u094d\u0930\u0947\u0923\u0940 \u092e\u0947\u0902 \u0939\u0908\u0964 \u0905\u0917\u0930 \u0910\u0938\u0928 \u0915\u094b\u0928\u094b \u0938\u0902\u0916\u094d\u092f\u093e \u0928\u093e \u0939\u0908, \u0924 \u092b\u0932\u0928 \u0915\u0947 -1 \u0932\u094c\u091f\u093e\u092c\u0947 \u0915\u0947 \u091a\u093e\u0939\u093f\u0964 \u0909\u0926\u093e\u0939\u0930\u0923 \u0915\u0947 \u0932\u0947\u0932\u0903 choose_num(12, 15) = 14 choose_num(13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u090f\u0917\u094b \u0927\u0928\u093e\u0924\u094d\u092e\u0915 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 n \u0926\u0947\u0932\u093e \u092a\u0930, \u090f\u0917\u094b \u091f\u094d\u092f\u0942\u092a\u0932 \u0932\u094c\u091f\u093e\u0908 \u091c\u0947\u0915\u0930\u093e \u092e\u0947\u0902 \u0938\u092e \u0906\u0909\u0930 \u0935\u093f\u0937\u092e \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u092a\u093e\u0932\u093f\u0902\u0921\u094d\u0930\u094b\u092e \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0939\u094b\u0908 \u0939\u0908 \u091c\u0947 \u0936\u094d\u0930\u0947\u0923\u0940 \u092e\u0947\u0902 \u0939\u094b\u0908 \u0939\u0908\u0964 \u0909\u0926\u093e\u0939\u0930\u0923 1: \u0907\u0928\u092a\u0941\u091f\u0903 3 \u0906\u0909\u091f\u092a\u0941\u091f\u0903 (1, 2) \u0938\u094d\u092a\u0937\u094d\u091f\u0940\u0915\u0930\u0923\u0903 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u092a\u093e\u0932\u093f\u0902\u0921\u094d\u0930\u094b\u092e 1, 2, 3 \u0939\u0908, \u091c\u0947\u0915\u0930\u093e \u092e\u0947\u0902 \u0938\u0947 \u090f\u0917\u094b \u0938\u092e \u0939\u0908, \u0905\u0909\u0930 \u0926\u0942\u0917\u094b \u0935\u093f\u0937\u092e \u0939\u0908\u0964 \u0909\u0926\u093e\u0939\u0930\u0923 2: \u0907\u0928\u092a\u0941\u091f\u0903 12 \u0906\u0909\u091f\u092a\u0941\u091f\u0903 (4, 6) \u0938\u094d\u092a\u0937\u094d\u091f\u0940\u0915\u0930\u0923\u0903 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u092a\u093e\u0932\u093f\u0902\u0921\u094d\u0930\u094b\u092e 1, 2, 3, 4, 5, 6, 7, 8, 9, 11 \u0939\u0908\u0964 \u0913\u0915\u0930\u093e \u092e\u0947\u0902 \u0938\u0947 \u091a\u093e\u0930 \u0938\u092e \u0939\u0908, \u0905\u0909\u0930 6 \u0935\u093f\u0937\u092e \u0939\u0908\u0964 \u0928\u094b\u091f\u0903 1. 1 <= n <= 10 ^ 3 2. \u091f\u094d\u092f\u0942\u092a\u0932 \u0915\u094d\u0930\u092e\u0936\u0903 \u0938\u092e \u0906\u0909\u0930 \u0935\u093f\u0937\u092e \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u092a\u093e\u0932\u093f\u0902\u0921\u094d\u0930\u094b\u092e \u0915\u0947 \u0938\u0902\u0916\u094d\u092f\u093e \u0932\u094c\u091f\u093e\u0908 \u0939\u0908\u0964\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"\u1005\u102c\u101b\u1004\u103a\u1038\u1011\u1032\u1000 \u101b\u103d\u1031\u1038\u1011\u102c\u1038\u1010\u1032\u1037 \u1011\u1030\u1038\u1001\u103c\u102c\u1038\u1010\u1032\u1037 \u1021\u1000\u1039\u1001\u101b\u102c\u1010\u103d\u1031\u1000\u102d\u102f \u1015\u103c\u1014\u103a\u1015\u1031\u1038\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \u1015\u1031\u1038\u1011\u102c\u1038\u1010\u1032\u1037 \u1000\u102d\u1014\u103a\u1038\u1015\u103c\u100a\u1037\u103a\u1005\u102c\u101b\u1004\u103a\u1038\u1000\u1014\u1031 \u1021\u1005\u1009\u103a\u1011\u1032\u1000 \u1015\u1031\u1038\u1011\u102c\u1038\u1010\u1032\u1037 \u1000\u102c\u101c\u1021\u1011\u102d \u1010\u103d\u1031\u1037\u101b\u1010\u1032\u1037 \u1000\u103b\u1031\u102c\u1037\u1000\u103d\u1004\u103a\u1038 \u1021\u1019\u103b\u102c\u1038\u1006\u102f\u1036\u1038 \u1012\u103c\u1015\u103a\u1005\u1004\u103a\u1005\u102c\u101b\u1004\u103a\u1038\u1000\u102d\u102f \u1011\u102f\u1010\u103a\u1015\u1031\u1038\u1010\u101a\u103a\u104b\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \u1024\u101c\u102f\u1015\u103a\u1006\u1031\u102c\u1004\u103a\u1001\u103b\u1000\u103a\u104f \u1021\u101d\u1004\u103a\u1019\u103e\u102c \u1000\u103d\u1004\u103a\u1038\u1006\u1000\u103a\u1021\u101d\u102d\u102f\u1004\u103a\u1038\u1019\u103b\u102c\u1038\u1015\u102b\u101d\u1004\u103a\u101e\u1031\u102c \u1021\u102f\u1015\u103a\u1005\u102f\u1015\u1031\u102b\u1004\u103a\u1038\u1019\u103b\u102c\u1038\u1005\u103d\u102c\u1015\u102b\u101d\u1004\u103a\u101e\u1031\u102c string \u1010\u1005\u103a\u1001\u102f\u1016\u103c\u1005\u103a\u101e\u100a\u103a\u104b \u101e\u1004\u1037\u103a\u101b\u100a\u103a\u101b\u103d\u101a\u103a\u1001\u103b\u1000\u103a\u1019\u103e\u102c \u1011\u102d\u102f\u1021\u102f\u1015\u103a\u1005\u102f\u1019\u103b\u102c\u1038\u1000\u102d\u102f \u101e\u102e\u1038\u1001\u103c\u102c\u1038 string \u1019\u103b\u102c\u1038\u1021\u1016\u103c\u1005\u103a\u1001\u103d\u1032\u1001\u103c\u102c\u1038\u1015\u103c\u102e\u1038 \u1011\u102d\u102f\u1005\u102c\u101b\u1004\u103a\u1038\u1000\u102d\u102f\u1015\u103c\u1014\u103a\u1015\u102d\u102f\u1037\u101b\u1014\u103a\u1016\u103c\u1005\u103a\u101e\u100a\u103a\u104b \u101e\u102e\u1038\u1001\u103c\u102c\u1038\u1021\u102f\u1015\u103a\u1005\u102f\u1019\u103b\u102c\u1038\u101e\u100a\u103a \u101f\u1014\u103a\u1001\u103b\u1000\u103a\u100a\u102e (\u1016\u103d\u1004\u1037\u103a\u1011\u102c\u1038\u101e\u1031\u102c brace \u1010\u1005\u103a\u1001\u102f\u1005\u102e\u1000\u102d\u102f \u1019\u103e\u1014\u103a\u1000\u1014\u103a\u1005\u103d\u102c\u1015\u102d\u1010\u103a\u1011\u102c\u1038\u101e\u100a\u103a) \u1014\u103e\u1004\u1037\u103a\u1021\u1001\u103b\u1004\u103a\u1038\u1001\u103b\u1004\u103a\u1038\u1010\u103d\u1004\u103a \u1000\u103d\u1004\u103a\u1038\u1006\u1000\u103a\u1019\u101c\u102f\u1015\u103a\u1015\u102b\u104b \u1021\u101d\u1004\u103a string \u1010\u103d\u1004\u103a\u1021\u1000\u103d\u1000\u103a\u1019\u103b\u102c\u1038\u1000\u102d\u102f \u101c\u103b\u1005\u103a\u101c\u103b\u1030\u101b\u103e\u102f\u1015\u102b\u104b \u1025\u1015\u1019\u102c:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Hierdie funksie neem twee positiewe getalle x en y en gee die grootste paar heelgetal wat in die reeks [x, y] insluitend. As daar nie so 'n getal is nie, dan moet die funksie -1 teruggee. Byvoorbeeld: kies_getal 12 = 14 kies_getal 13 = 12\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is 'n funksie wat string neem en string sonder vokale teruggee.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Jy moet 'n funksie skryf wat 'n gegewe datum string valideer en True terugkeer as die datum geldig is andersins Fals. Die datum is geldig as al die volgende re\u00ebls voldoen: 1. Die datum string is nie leeg nie. 2. Die aantal dae is nie minder as 1 of ho\u00ebr as 31 dae vir maande 1,3,5,7,8,10,12. En die aantal dae is nie minder as 1 of ho\u00ebr as 30 dae vir maande 4,6,9,11. En die aantal dae is nie minder as 1 of ho\u00ebr as 29 vir die maand 2. 3. Die maande moet nie minder as 1 of ho\u00ebr as 12. 4. Die datum moet in die formaat wees: mm-dd-yyyy byvoorbeeld: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-040') => False_valid_date (('06-04-2020') => True\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"\u0641\u06c1\u0631\u0633\u062a \u0645\u06cc\u06ba \u0639\u0646\u0627\u0635\u0631 \u06a9\u06cc \u0648\u0627\u067e\u0633\u06cc \u0645\u06cc\u0688\u06cc\u0646\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    \u0639\u062f\u062f\u06cc \u0635\u0641 \u0627\u0648\u0631 \u0645\u062b\u0628\u062a \u0639\u062f\u062f\u06cc \u0635\u0641 \u06a9\u0648 \u062f\u06cc\u06a9\u06be\u062a\u06d2 \u06c1\u0648\u0626\u06d2 \u060c \u0622\u0631 \u0622\u0631 \u0645\u06cc\u06ba \u0632\u06cc\u0627\u062f\u06c1 \u0633\u06d2 \u0632\u06cc\u0627\u062f\u06c1 \u06a9\u06d2 \u0646\u0645\u0628\u0631\u0648\u06ba \u06a9\u06d2 \u0633\u0627\u062a\u06be \u0644\u0645\u0628\u0627\u0626\u06cc \u06a9\u06d2 \u062a\u0631\u062a\u06cc\u0628 \u0634\u062f\u06c1 \u0641\u06c1\u0631\u0633\u062a \u06a9\u0648 \u0644\u0648\u0679\u0627\u0626\u06cc\u06ba\u06d4 \u0645\u062b\u0627\u06441: \u0627\u0646 \u067e\u0679: \u0622\u0631 \u0622\u0631 = [-3 \u060c -4 \u060c 5] \u060c \u06a9\u06d2 = 3 \u0622\u0624\u0679 \u067e\u0679: [-4 \u060c -3 \u060c 5] \u0645\u062b\u0627\u06442: \u0627\u0646 \u067e\u0679: \u0622\u0631 \u0622\u0631 = [4 \u060c -4 \u060c 4] \u060c \u06a9\u06d2 = 2 \u0622\u0624\u0679 \u067e\u0679: [4 \u060c 4] \u0645\u062b\u0627\u06443: \u0627\u0646 \u067e\u0679: \u0622\u0631 \u0622\u0631 = [-3 \u060c 2 \u060c 1 \u060c 2 \u060c -1 \u060c -2 \u060c 1] \u060c \u06a9\u06d2 = 1 \u0622\u0624\u0679 \u067e\u0679: [2] \u0646\u0648\u0679: 1. \u0635\u0641 \u06a9\u06cc \u0644\u0645\u0628\u0627\u0626\u06cc [1 \u060c 1000] \u06a9\u06cc \u062d\u062f \u0645\u06cc\u06ba \u06c1\u0648\u06af\u06cc\u06d4 2. \u0635\u0641 \u0645\u06cc\u06ba \u0639\u0646\u0627\u0635\u0631 [-1000 \u060c 1000] \u06a9\u06cc \u062d\u062f \u0645\u06cc\u06ba \u06c1\u0648\u06ba \u06af\u06d2\u06d4 3. 0 <= k <= len ((arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    \u0627\u06cc\u06a9 \u0644\u063a\u062a \u062f\u06cc \u06af\u0626\u06cc \u06c1\u06d2 \u060c \u0627\u06af\u0631 \u062a\u0645\u0627\u0645 \u0686\u0627\u0628\u06cc\u0627\u06ba \u0686\u06be\u0648\u0679\u06d2 \u062d\u0631\u0648\u0641 \u0645\u06cc\u06ba \u062a\u0627\u0631 \u06c1\u06cc\u06ba \u06cc\u0627 \u062a\u0645\u0627\u0645 \u0686\u0627\u0628\u06cc\u0627\u06ba \u0628\u0691\u06d2 \u062d\u0631\u0648\u0641 \u0645\u06cc\u06ba \u062a\u0627\u0631 \u06c1\u06cc\u06ba \u062a\u0648 \u060c \u067e\u06be\u0631 \u063a\u0644\u0637 \u0648\u0627\u067e\u0633 \u06a9\u0631\u06cc\u06ba\u06d4 \u0641\u0646\u06a9\u0634\u0646 \u06a9\u0648 \u063a\u0644\u0637 \u0648\u0627\u067e\u0633 \u06a9\u0631\u0646\u0627 \u0686\u0627\u06c1\u0626\u06d2 \u062f\u06cc \u06af\u0626\u06cc \u0644\u063a\u062a \u062e\u0627\u0644\u06cc \u06c1\u06d2\u06d4 \u0645\u062b\u0627\u0644: \u0686\u06cc\u06a9_\u0688\u06a9\u0679_\u06a9\u06cc\u0633 ((({\"a\":\" \u0633\u06cc\u0628 \u060c\" \"b\":\" \u06a9\u06cc\u0644\u06d2 \"}) \u06a9\u0648 \u062f\u0631\u0633\u062a \u0648\u0627\u067e\u0633 \u06a9\u0631\u0646\u0627 \u0686\u0627\u06c1\u0626\u06d2\u06d4 \u0686\u06cc\u06a9_\u0688\u06a9\u0679_\u06a9\u06cc\u0633 ((({\"a\":\" \u0633\u06cc\u0628 \u060c\" A\":\" \u06a9\u06cc\u0644\u06d2 \u060c\" B\":\" \u06a9\u06cc\u0644\u06d2 \"}) \u06a9\u0648 \u063a\u0644\u0637 \u0648\u0627\u067e\u0633 \u06a9\u0631\u0646\u0627 \u0686\u0627\u06c1\u0626\u06d2\u06d4 \u0686\u06cc\u06a9_\u0688\u06a9\u0679_\u06a9\u06cc\u0633 {\"a\":\" \u0633\u06cc\u0628 \u060c\" 8:\" \u06a9\u06cc\u0644\u06d2 \u060c\" a\":\" \u0633\u06cc\u0628 \"}) \u06a9\u0648 \u063a\u0644\u0637 \u0648\u0627\u067e\u0633 \u06a9\u0631\u0646\u0627 \u0686\u0627\u06c1\u0626\u06d2\u06d4 \u0686\u06cc\u06a9_\u0688\u06a9\u0679_\u06a9\u06cc\u0633 {\"a\":\" \u0633\u06cc\u0628 \u060c\" 8:\" \u06a9\u06cc\u0644\u06d2 \u060c\" a\":\" \u0633\u06cc\u0628 \"}) \u06a9\u0648 \u063a\u0644\u0637 \u0648\u0627\u067e\u0633 \u06a9\u0631\u0646\u0627 \u0686\u0627\u06c1\u0626\u06d2\u06d4 \u0686\u06cc\u06a9_\u0688\u06a9\u0679_\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"\u090f\u0915\u091f\u093e \u092b\u0902\u0915\u094d\u0936\u0928 \u092c\u0928\u093e\u0909 \u091c\u0947 \u090f\u0915\u091f\u093e \u092b\u093e\u0907\u0932\u0915 \u0928\u093e\u092e \u0915\u0947\u0901 \u092a\u094d\u0930\u0924\u093f\u0928\u093f\u0927\u093f\u0924\u094d\u0935 \u0915\u0930\u0948\u0924 \u090f\u0915\u091f\u093e \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0932\u0948\u0924 \u0905\u091b\u093f, \u0906 \u091c\u0901 \u092b\u093e\u0907\u0932\u0915 \u0928\u093e\u092e \u0935\u0948\u0927 \u0905\u091b\u093f \u0924\u0901 'Yes' \u0932\u094c\u091f\u093e \u0926\u0948\u0924 \u0905\u091b\u093f, \u0906 \u0905\u0928\u094d\u092f\u0925\u093e 'No' \u0932\u094c\u091f\u093e \u0926\u0948\u0924 \u0905\u091b\u093f. \u090f\u0915\u091f\u093e \u092b\u093e\u0907\u0932\u0915 \u0928\u093e\u092e \u0935\u0948\u0927 \u092e\u093e\u0928\u0932 \u091c\u093e\u0907\u0924 \u0905\u091b\u093f \u091c\u0901 \u0906 \u092e\u093e\u0924\u094d\u0930 \u0924\u0916\u0928\u0947 \u091c\u0901 \u0928\u093f\u092e\u094d\u0928\u0932\u093f\u0916\u093f\u0924 \u0938\u092d \u0936\u0930\u094d\u0924 \u092a\u0942\u0930\u093e \u0939\u094b\u0907\u0924 \u0905\u091b\u093f: - \u092b\u093e\u0907\u0932\u0915 \u0928\u093e\u092e \u092e\u0947 \u0924\u0940\u0928 \u0938\u0901 \u092c\u0947\u0938\u0940 \u0905\u0902\u0915 ('0'-'9') \u0928\u0939\u093f \u0939\u094b\u090f\u0924 \u0905\u091b\u093f. - \u092b\u093e\u0907\u0932\u0915 \u0928\u093e\u092e\u092e\u0947 \u0920\u0940\u0915 \u090f\u0915 \u0921\u0949\u091f '.' - \u0921\u0949\u091f \u0938\u0901 \u092a\u0939\u093f\u0928\u0947 \u0938\u092c\u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0916\u093e\u0932\u0940 \u0928\u0939\u093f \u0939\u094b\u090f\u0924 \u0905\u091b\u093f, \u0906 \u0908 \u0932\u093e\u0924\u093f\u0928 \u0905\u0932\u094d\u092b\u093e\u092a\u0947\u091f \u0938\u0901 \u0936\u0941\u0930\u0942 \u0939\u094b\u090f\u0924 \u0905\u091b\u093f ('a'-'z' \u0906 'A'Z'). - \u0921\u0949\u091f\u0915 \u092c\u093e\u0926 \u0938\u092c\u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u090f\u0939\u093f\u092e\u0947 \u0938\u0901 \u090f\u0915\u091f\u093e \u0939\u094b\u090f\u0924 \u0905\u091b\u093f: ['txt', 'exe', 'lld'] \u0909\u0926\u093e\u0939\u0930\u0923\u0903 file_name_check\"{example.txt.txt} # => 'Yes' file_name_check\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"\u090f\u0915\u091f\u093e \u0938\u093e\u0927\u093e\u0930\u0923 \u0915\u093e\u0930\u094d\u092f\u0915\u094d\u0930\u092e \u091c\u0947 x \u0915 \u092e\u093e\u0928 \u0935\u093e\u092a\u0938 \u0915\u0930\u090f\u0924 \u092f\u0926\u093f n \u090f\u0915\u091f\u093e \u0905\u092d\u093e\u091c\u094d\u092f \u0938\u0902\u0916\u094d\u092f\u093e \u0905\u091b\u093f \u0906 y \u0915 \u092e\u093e\u0928 \u0935\u093e\u092a\u0938 \u0915\u0930\u090f\u0924 \u0905\u0928\u094d\u092f\u0925\u093e \u0909\u0926\u093e\u0939\u0930\u0923\u0903 x_or_y{7, 34, 12) == 34 x_or_y{15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    \u0905\u0939\u093e\u0901\u0915\u0947\u0901 \u090f\u0915 \u0968 \u0906\u092f\u093e\u092e\u0940 \u0921\u093e\u091f\u093e \u0926\u0947\u0932 \u0917\u0947\u0932 \u0905\u091b\u093f, \u091c\u0947\u0928\u093e \u0915\u093f \u0928\u0947\u0938\u094d\u091f\u0947\u0921 \u0938\u0942\u091a\u0940, \u091c\u0947 \u092e\u0948\u091f\u094d\u0930\u093f\u0915\u094d\u0938\u0915 \u0938\u092e\u093e\u0928 \u0905\u091b\u093f, \u092e\u0941\u0926\u093e, \u092e\u0948\u091f\u094d\u0930\u093f\u0915\u094d\u0938\u0915 \u0935\u093f\u092a\u0930\u0940\u0924, \u092a\u094d\u0930\u0924\u094d\u092f\u0947\u0915 \u092a\u0902\u0915\u094d\u0924\u093f\u092e\u0947 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0938\u0902\u0916\u094d\u092f\u093e\u092e\u0947 \u0938\u094d\u0924\u092e\u094d\u092d\u0938\u092d \u0930\u0939\u0932 \u0939\u094b\u090f\u0924 \u0905\u091b\u093f\u0964 lst, \u0906 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 x \u0926\u0947\u0932 \u0917\u0947\u0932 \u0905\u091b\u093f, \u0938\u0942\u091a\u0940\u092e\u0947 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 x \u0916\u094b\u091c\u0942, \u0906 \u091f\u094d\u092f\u0942\u092a\u0932\u0938\u092d\u0915 \u0938\u0942\u091a\u0940 \u0932\u094c\u091f\u093e\u0909, [(x1, y1), (x2, y2)...] \u091c\u0915\u0930 \u092a\u094d\u0930\u0924\u094d\u092f\u0947\u0915 \u091f\u094d\u092f\u0942\u092a\u0932 \u090f\u0915 \u0928\u093f\u0930\u094d\u0926\u0947\u0936\u093e\u0902\u0915 \u0905\u091b\u093f - (\u092a\u0902\u0915\u094d\u0924\u093f, \u0938\u094d\u0924\u092e\u094d\u092d\u0938\u092d), \u091c\u0947 \u0966 \u0938\u0901 \u0936\u0941\u0930\u0942 \u0939\u094b\u0907\u0924 \u0905\u091b\u093f\u0964 \u0928\u093f\u0930\u094d\u0926\u0947\u0936\u093e\u0902\u0915\u0938\u092d\u0915\u0947\u0901 \u0915\u094d\u0930\u092e\u092c\u0926\u094d\u0927 \u0915\u0930\u0942 \u0906\u0930\u092e\u094d\u092d\u092e\u0947 \u092a\u0902\u0915\u094d\u0924\u093f\u0938\u092d\u0915 \u0915\u094d\u0930\u092e\u092e\u0947 \u0906\u0930\u094b\u0939\u0940 \u0915\u094d\u0930\u092e\u092e\u0947\u0964 \u090f\u0915\u0930 \u0905\u0932\u093e\u0935\u093e, \u092a\u0902\u0915\u094d\u0924\u093f\u0938\u092d\u0915 \u0928\u093f\u0930\u094d\u0926\u0947\u0936\u093e\u0902\u0915\u0938\u092d\u0915 \u0915\u094d\u0930\u092e\u092c\u0926\u094d\u0927 \u0915\u0930\u0942 \u0938\u094d\u0924\u092e\u094d\u092d\u0938\u092d\u0915 \u0915\u094d\u0930\u092e\u092e\u0947 \u0905\u0935\u0930\u094b\u0939\u0940 \u0915\u094d\u0930\u092e\u092e\u0947\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0903 get_row[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input \u0627\u062f\u0627\u0644\u0647 \u062f\u0648\u0627 \u0633\u0648\u0631\u062a a \u062f\u0627\u0646 b \u064a\u06a0 \u062a\u064a\u06a0\u06ac\u0644 \u062f\u0631\u064a 1 \u062f\u0627\u0646 0. \u06a4\u0631\u0644\u0648 \u06a4\u0631\u0646\u0647 \u0645\u0646\u0648\u0644\u064a\u0633 XOR \u0628\u0627\u064a\u0646\u0631\u064a \u062f\u0627\u0644\u0645 \u0627\u064a\u0646\u06a4\u0648\u062a \u06a0\u0646 \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u0631\u064a\u0633\u0644\u062a\u0627 \u0633\u064a\u0648\u0628\u0627\u06ac\u0627\u064a \u0633\u0648\u0631\u062a.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    \u062f\u06a4\u0627\u0648\u06ac\u064a\u062a \u0633\u062a\u0631\u064a\u0646 s\u060c \u0645\u0646\u0648\u0645\u0628\u06a0\u0643\u0646 \u06a4\u06a0\u06ac\u064a\u0627\u062a \u06a4\u0648\u0643\u0644 \u0627\u0648\u062a\u0627\u0631\u0627 \u062f\u0627\u0644\u0645 \u0627\u064a\u0646\u062f\u064a\u0643\u0633 \u062c\u0627\u0648\u062a. \u0686\u0648\u0646\u062a\u0648\u0647\u06bd: count_upper (('aBCdEf') \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 1 count_upper (('abcdefg') \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 0 count_upper (('dBBE') \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u062f\u0628\u0631\u064a\u0643\u0646 \u0627\u064a\u0646\u062a\u06ac\u0631 \u06a4\u0648\u0633\u064a\u062a\u064a\u0641 n\u060c \u0645\u0631\u0648\u06a4\u0627\u0643\u0646 \u0633\u0627\u062a\u0648 \u062a\u0648\u06a4\u0644 \u064a\u06a0 \u0646\u0627 \u06a4\u0627\u0644\u064a\u0646\u062f\u0631\u0648\u0645 \u0627\u064a\u0646\u062a\u06ac\u0631 \u06a4\u0631\u0646\u0647 \u062f\u0627\u0646 \u06a4\u0631\u0646\u0647 \u064a\u06a0 \u062a\u0631\u0644\u064a\u0628\u062a \u062f\u0627\u0644\u0645 \u0631\u064a\u0646\u062c ((1\u060c n) \u060c \u062a\u0631\u0645\u0627\u0633\u0648\u0642. \u0686\u0648\u0646\u062a\u0648\u06471: \u06a4\u06a0\u0644\u0648\u0627\u0631\u0646: 3 \u06a4\u06a0\u0644\u0648\u0627\u0631\u0646: (1, 2) \u06a4\u06a0\u062a\u0627\u0647\u0648\u0627\u0646: \u0627\u064a\u0646\u062a\u06ac\u0631 \u06a4\u0627\u0644\u064a\u0646\u062f\u0631\u0648\u0645 \u0627\u062f\u0627\u0644\u0647 1, 2, 3. \u0633\u0627\u0644\u0647 \u0633\u0627\u062a\u0648 \u062f\u0631\u064a\u06bd \u0627\u062f\u0627\u0644\u0647 \u06a4\u0631\u0646\u0647\u060c \u062f\u0627\u0646 \u062f\u0648\u0627 \u062f\u0631\u064a\u06bd \u0627\u062f\u0627\u0644\u0647 \u06a4\u0631\u0646\u0647. \u0686\u0648\u0646\u062a\u0648\u06472: \u06a4\u06a0\u0644\u0648\u0627\u0631\u0646: (4, 6) \u06a4\u06a0\u062a\u0627\u0647\u0648\u0627\u0646: \u0627\u064a\u0646\u062a\u06ac\u0631 \u06a4\u0627\u0644\u064a\u0646\u062f\u0631\u0648\u0645 \u0627\u062f\u0627\u0644\u0647 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u06a4\u0631\u062a\u0648\u0645\u06a4\u0648\u0647\u06bd \u0627\u062f\u0627\u0644\u0647 \u06a4\u0631\u0646\u0647\u060c \u062f\u0627\u0646 6 \u062f\u0631\u064a\u06bd \u0627\u062f\u0627\u0644\u0647 \u06a4\u0631\u0646\u0647. \u0646\u0648\u062a\u0627: 1. 1 <= n <= 10^3 2. \u062a\u0648\u06a4\u0644 \u0645\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Don wani da aka ba kirtani, juyawa \u0199ananan haruffa zuwa babban haruffa da babban haruffa zuwa \u0199ananan haruffa.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    An ba da jerin lambobi marasa kyau, dawo da kwafin jerin da aka ba da bayan rarrabuwa, za ku rarraba jerin da aka ba da su a cikin tsari mai tasowa idan adadin ((darajar \u0199ididdigar farko, \u0199imar \u0199ididdigar \u0199arshe) ba daidai ba ne, ko kuma ku rarraba shi a cikin tsari mai saukowa idan adadin ((darajar \u0199ididdigar farko, \u0199imar \u0199ididdigar \u0199arshe) ma. Lura: * kar ku canza jerin da aka ba. Misalai: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Shigarwa zuwa wannan aiki ne a kirtani wakiltar music bayanin kula a cikin wani musamman ASCII format. Your aiki ne don nazarin wannan kirtani da kuma dawo da jerin integers daidai da yadda mutane da yawa beats kowane ba ya wuce. Ga wani labari: 'o' - dukan bayanin kula, yana daukan hudu beats 'o\" - rabin bayanin kula, yana daukan biyu beats '. \"o\" - quater bayanin kula, yana daukan daya buga\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \u0d0f\u0d24\u0d46\u0d19\u0d4d\u0d15\u0d3f\u0d32\u0d41\u0d02 \u0d2a\u0d48\u0d24\u0d4d\u0d24\u0d7a \u0d2e\u0d42\u0d32\u0d4d\u0d2f\u0d19\u0d4d\u0d19\u0d33\u0d41\u0d1f\u0d46 \u0d32\u0d3f\u0d38\u0d4d\u0d31\u0d4d\u0d31\u0d4d \u0d2b\u0d3f\u0d7d\u0d1f\u0d4d\u0d1f\u0d7c \u0d1a\u0d46\u0d2f\u0d4d\u0d24\u0d3e\u0d7d \u0d2a\u0d42\u0d7c\u0d23\u0d4d\u0d23\u0d38\u0d02\u0d16\u0d4d\u0d2f\u0d15\u0d7e \u0d2e\u0d3e\u0d24\u0d4d\u0d30\u0d02\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"\u0d32\u0d3f\u0d38\u0d4d\u0d31\u0d4d\u0d31\u0d3f\u0d32\u0d46 \u0d0e\u0d32\u0d4d\u0d32\u0d3e \u0d28\u0d2e\u0d4d\u0d2a\u0d31\u0d41\u0d15\u0d33\u0d41\u0d02 t \u0d0e\u0d28\u0d4d\u0d28 \u0d2a\u0d30\u0d3f\u0d27\u0d3f\u0d15\u0d4d\u0d15\u0d41 \u0d24\u0d3e\u0d34\u0d46\u0d2f\u0d3e\u0d23\u0d46\u0d19\u0d4d\u0d15\u0d3f\u0d7d True \u0d0e\u0d28\u0d4d\u0d28\u0d4d \u0d31\u0d3f\u0d1f\u0d4d\u0d1f\u0d47\u0d7a \u0d1a\u0d46\u0d2f\u0d4d\u0d2f\u0d41\u0d15.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    \u0d28\u0d3f\u0d19\u0d4d\u0d19\u0d7e\u0d15\u0d4d\u0d15\u0d4d \u0d12\u0d30\u0d41 \u0d2a\u0d4b\u0d38\u0d3f\u0d31\u0d4d\u0d31\u0d40\u0d35\u0d4d \u0d2a\u0d42\u0d7c\u0d23\u0d4d\u0d23\u0d38\u0d02\u0d16\u0d4d\u0d2f n \u0d28\u0d7d\u0d15\u0d3f\u0d2f\u0d3f\u0d30\u0d3f\u0d15\u0d4d\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d41. \u0d28\u0d40\u0d33\u0d02 n \u0d09\u0d33\u0d4d\u0d33 \u0d12\u0d30\u0d41 \u0d2a\u0d42\u0d7c\u0d23\u0d4d\u0d23\u0d38\u0d02\u0d16\u0d4d\u0d2f \u0d05\u0d31\u0d47 \u0d38\u0d43\u0d37\u0d4d\u0d1f\u0d3f\u0d15\u0d4d\u0d15\u0d23\u0d02. \u0d13\u0d30\u0d4b i (1 \u2030\u00a4 i \u2030\u00a4 n) \u0d28\u0d41\u0d02, a[i] = i * i - i + 1 \u0d28\u0d4d\u0d31\u0d46 \u0d2e\u0d42\u0d32\u0d4d\u0d2f\u0d02. a \u0d28\u0d4d\u0d31\u0d46 \u0d1f\u0d4d\u0d30\u0d3f\u0d2a\u0d4d\u0d2a\u0d3f\u0d7e\u0d38\u0d4d (a[i], a[j], a[k]) \u0d0e\u0d23\u0d4d\u0d23\u0d02 \u0d24\u0d3f\u0d30\u0d3f\u0d15\u0d46 \u0d28\u0d7d\u0d15\u0d41\u0d15, \u0d05\u0d35\u0d3f\u0d1f\u0d46 i < j < k, a[i] + a[j] + a[k] \u0d0e\u0d28\u0d4d\u0d28\u0d24\u0d4d 3 \u0d28\u0d4d\u0d31\u0d46 \u0d17\u0d41\u0d23\u0d3f\u0d24\u0d2e\u0d3e\u0d23\u0d4d. \u0d09\u0d26\u0d3e\u0d39\u0d30\u0d23\u0d02\u0d03 \u0d07\u0d7b\u0d2a\u0d41\u0d1f\u0d4d\u0d1f\u0d4d: n = 5 \u0d14\u0d1f\u0d4d\u0d1f\u0d4d\u0d2a\u0d41\u0d1f\u0d4d\u0d1f\u0d4d\u0d03 1 \u0d35\u0d3f\u0d36\u0d26\u0d40\u0d15\u0d30\u0d23\u0d02\u0d03 a = [1, 3, 7, 13, 21] \u0d38\u0d3e\u0d27\u0d41\u0d35\u0d3e\u0d2f \u0d1f\u0d4d\u0d30\u0d3f\u0d2a\u0d4d\u0d2a\u0d3f\u0d7e \u0d2e\u0d3e\u0d24\u0d4d\u0d30\u0d2e\u0d3e\u0d23\u0d4d (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Dee \u1ecdr\u1ee5 nke na-ewe ozi, ma tinye ya n'\u1ee5z\u1ecd ga-eme ka \u1ecd gbanwee mkp\u1ee5r\u1ee5edemede niile, dochie vowels niile na ozi ah\u1ee5 na mkp\u1ee5r\u1ee5edemede nke p\u1ee5tara 2 ebe n'ihu vowel ah\u1ee5 na mkp\u1ee5r\u1ee5edemede Bekee. Were naan\u1ecb mkp\u1ee5r\u1ee5edemede. Ihe at\u1ee5:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets b\u1ee5 eriri nke \"(\" na \"\". laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na bracket \u1ecd b\u1ee5la nwere bracket mmechi.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Ojehech\u00e1ramo pete\u0129 matriz arr entero ha pete\u0129 entero positivo k, emyengovi\u00e1kena pete\u0129 lista ordenada ipukukue k umi papapy k m\u00e1ximo arr-pe. Techapyr\u00e31: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Techapyr\u00e32: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Techapyr\u00e33: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Nota: 1.\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Ojehech\u00e1ramo mok\u00f5i papapy entero positivo a ha b, emyengovi\u00e1kena umi d\u00edgito par o\u0129va a ha b mbyt\u00e9pe, orden ascendente-pe. Techapyr\u00e3: generate_integers(2, 8) => [2, 4, 6, 8] generate_integers(8, 2) => [2, 4, 6, 8] generate_integers(10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Embohasa papapy Fibonacci n-ha.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"\u0628\u0631\u0646\u0627\u0645\u062c \u0628\u0633\u064a\u0637 \u0627\u0644\u0630\u064a \u064a\u062c\u0628 \u0627\u0646 \u064a\u0639\u064a\u062f \u0642\u064a\u0645\u0629 x \u0627\u0630\u0627 n \u0647\u0648 \u0639\u062f\u062f \u0623\u0648\u0644\u064a \u0648\u064a\u062c\u0628 \u0627\u0646 \u064a\u0639\u064a\u062f \u0642\u064a\u0645\u0629 y \u063a\u064a\u0631 \u0630\u0644\u0643. \u0645\u062b\u0627\u0644: \u0644\u0640 x_or_y(7, 34, 12) == 34 \u0644\u0640 x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" \u0637\u0648\u0644 \u0627\u0644\u0639\u0648\u062f\u0629 \u0644\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0645\u0639\u0637\u0627\u0629\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \u0647\u0648 \u0633\u0644\u0633\u0644\u0629 \u0645\u0646 \"(\" \u0648 \"\". return True \u0627\u0630\u0627 \u0643\u0644 \u0642\u0648\u0633 \u0627\u0641\u062a\u062a\u0627\u062d\u064a \u0644\u0647 \u0642\u0648\u0633 \u0627\u063a\u0644\u0627\u0642 \u0645\u062a\u0648\u0627\u0641\u0642.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \u179c\u17b7\u179b\u178f\u17d2\u179a\u17a1\u1794\u17cb\u1791\u17c5\u1798\u1792\u17d2\u1799\u1798\u1797\u17b6\u1782\u179a\u17bd\u1798\u178a\u17cf\u1792\u17c6\u1794\u17c6\u1795\u17bb\u178f\u1793\u17c3\u1785\u17c6\u1793\u17bd\u1793\u1782\u178f\u17cb a \u1793\u17b7\u1784 b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"\u178a\u17c4\u1799\u1794\u17b6\u1793\u1795\u17d2\u178f\u179b\u17cb\u1793\u17bc\u179c\u1781\u17d2\u179f\u17c2 s \u1793\u17b7\u1784\u1785\u17c6\u1793\u17bd\u1793\u1792\u1798\u17d2\u1798\u1787\u17b6\u178f\u17b7 n, \u17a2\u17d2\u1793\u1780\u178f\u17d2\u179a\u17bc\u179c\u1794\u17b6\u1793\u1782\u17c1\u1794\u1789\u17d2\u1787\u17b6\u17b1\u17d2\u1799\u17a2\u1793\u17bb\u179c\u178f\u17d2\u178f\u1798\u17bb\u1781\u1784\u17b6\u179a\u1798\u17bd\u1799\u178a\u17c2\u179b\u178f\u17d2\u179a\u17a1\u1794\u17cb\u1798\u1780\u179c\u17b7\u1789\u1793\u17bc\u179c\u1794\u1789\u17d2\u1787\u17b8\u1793\u17c3\u1796\u17b6\u1780\u17d2\u1799\u1791\u17b6\u17c6\u1784\u17a2\u179f\u17cb\u1796\u17b8\u1781\u17d2\u179f\u17c2 s \u178a\u17c2\u179b\u1798\u17b6\u1793\u179f\u1798\u17d2\u179b\u17c1\u1784\u179f\u17bb\u1791\u17d2\u1792\u178f\u17c2 n \u178a\u17be\u1798\u17d2\u1794\u17b8\u17b1\u17d2\u1799\u1796\u17b6\u1780\u17d2\u1799\u1791\u17b6\u17c6\u1784\u1793\u17c1\u17c7\u179b\u17c1\u1785\u17a1\u17be\u1784\u1793\u17c5\u1780\u17d2\u1793\u17bb\u1784\u1781\u17d2\u179f\u17c2 s. \u1794\u17d2\u179a\u179f\u17b7\u1793\u1794\u17be\u1781\u17d2\u179f\u17c2 s \u1782\u17ba\u1782\u17d2\u1798\u17b6\u1793\u17a2\u17d2\u179c\u17b8\u1791\u17c1\u1793\u17c4\u17c7\u1798\u17bb\u1781\u1784\u17b6\u179a\u1793\u17c1\u17c7\u1782\u17bd\u179a\u178f\u17c2\u178f\u17d2\u179a\u17a1\u1794\u17cb\u1798\u1780\u179c\u17b7\u1789\u1793\u17bc\u179c\u1794\u1789\u17d2\u1787\u17b8\u1782\u17d2\u1798\u17b6\u1793\u17a2\u17d2\u179c\u17b8\u1791\u17c1\u17d4 \u179f\u17bc\u1798\u1794\u1789\u17d2\u1787\u17b6\u1780\u17cb\u1790\u17b6\u17a2\u17d2\u1793\u1780\u17a2\u17b6\u1785\u1782\u17b7\u178f\u1790\u17b6\u1781\u17d2\u179f\u17c2\u1794\u1789\u17d2\u1785\u17bc\u179b\u1798\u17b6\u1793\u178f\u17c2\u17a2\u1780\u17d2\u179f\u179a\u1793\u17b7\u1784\u17a2\u1782\u17b6\u179a\u1782\u17c6\u179a\u17bc: select_words \"Mary had a little lamb\", 4) ==> [\"little\"] select_words \"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words \"simple white space\", 2) ==> [] select_words \"Hello world\", 4) ==> [\"world\"] select_words \"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Tsenya tiri\u0161o ya go t\u0161ea palomoka yeo e sego ya go se be le bosodi gomme e bu\u0161et\u0161a mothaladi wa palomoka ya mathomo ya n yeo e lego ya mathomo le ya ka tlase ga n. mohlala: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Hlahloba ge e ba mant\u0161u a mabedi a na le ditlhaka t\u0161e di swanago.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"\u0eab\u0e99\u0ec9\u0eb2 \u0e97\u0eb5\u0ec8\u0e99\u0eb5\u0ec9\u0ec0\u0ead\u0ebb\u0eb2\u0e9a\u0eb1\u0e99\u0e8a\u0eb5\u0ea5\u0eb2\u0e8d\u0e8a\u0eb7\u0ec8 l \u0ec1\u0ea5\u0eb0\u0eaa\u0ebb\u0ec8\u0e87\u0e84\u0eb7\u0e99\u0e9a\u0eb1\u0e99\u0e8a\u0eb5\u0ea5\u0eb2\u0e8d\u0e8a\u0eb7\u0ec8 l' \u0ec0\u0e8a\u0eb1\u0ec8\u0e99\u0ea7\u0ec8\u0eb2 l' \u0ec1\u0ea1\u0ec8\u0e99\u0e84\u0eb7\u0e81\u0eb1\u0e99\u0e81\u0eb1\u0e9a l \u0ec3\u0e99\u0e95\u0ebb\u0ea7\u0e8a\u0eb5\u0ec9\u0ea7\u0eb1\u0e94\u0e97\u0eb5\u0ec8\u0e9a\u0ecd\u0ec8\u0eaa\u0eb2\u0ea1\u0eb2\u0e94\u0ec1\u0e9a\u0ec8\u0e87\u0ead\u0ead\u0e81\u0ec4\u0e94\u0ec9\u0ec2\u0e94\u0e8d\u0eaa\u0eb2\u0ea1, \u0ec3\u0e99\u0e82\u0eb0\u0e99\u0eb0\u0e97\u0eb5\u0ec8\u0e84\u0ec8\u0eb2\u0e82\u0ead\u0e87\u0ea1\u0eb1\u0e99\u0ea2\u0eb9\u0ec8\u0e95\u0ebb\u0ea7\u0e8a\u0eb5\u0ec9\u0ea7\u0eb1\u0e94\u0e97\u0eb5\u0ec8\u0eaa\u0eb2\u0ea1\u0eb2\u0e94\u0ec1\u0e9a\u0ec8\u0e87\u0ead\u0ead\u0e81\u0ec4\u0e94\u0ec9\u0ec2\u0e94\u0e8d\u0eaa\u0eb2\u0ea1\u0ec1\u0ea1\u0ec8\u0e99\u0ec0\u0e97\u0ebb\u0ec8\u0eb2\u0e81\u0eb1\u0e9a\u0e84\u0ec8\u0eb2\u0e82\u0ead\u0e87\u0e95\u0ebb\u0ea7\u0e8a\u0eb5\u0ec9\u0ea7\u0eb1\u0e94\u0e97\u0eb5\u0ec8\u0eaa\u0ead\u0e94\u0e84\u0ec8\u0ead\u0e87\u0e82\u0ead\u0e87 l, \u0ec1\u0e95\u0ec8\u0e88\u0eb1\u0e94\u0ea5\u0ebd\u0e87.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \u0e81\u0eb2\u0e99\u0e9b\u0ec9\u0ead\u0e99\u0ec0\u0e82\u0ebb\u0ec9\u0eb2\u0ec3\u0e99\u0e9f\u0eb1\u0e87\u0e8a\u0eb1\u0e99\u0e99\u0eb5\u0ec9\u0ec1\u0ea1\u0ec8\u0e99\u0eaa\u0eb2\u0e8d\u0e97\u0eb5\u0ec8\u0ea1\u0eb5\u0eab\u0ea5\u0eb2\u0e8d\u0e81\u0eb8\u0ec8\u0ea1\u0e82\u0ead\u0e87\u0ec1\u0e96\u0ea7\u0ec1\u0e96\u0ea7\u0e97\u0eb5\u0ec8\u0e96\u0eb7\u0e81\u0e81\u0ea7\u0ea1\u0ec0\u0ead\u0ebb\u0eb2. \u0ec0\u0e9b\u0ebb\u0ec9\u0eb2\u0eab\u0ea1\u0eb2\u0e8d\u0e82\u0ead\u0e87\u0e97\u0ec8\u0eb2\u0e99\u0ec1\u0ea1\u0ec8\u0e99\u0ec0\u0e9e\u0eb7\u0ec8\u0ead\u0ec1\u0e8d\u0e81\u0e81\u0eb8\u0ec8\u0ea1\u0ec0\u0eab\u0ea5\u0ebb\u0ec8\u0eb2\u0e99\u0eb1\u0ec9\u0e99\u0ead\u0ead\u0e81\u0ec0\u0e9b\u0eb1\u0e99\u0eaa\u0eb2\u0e8d\u0ec1\u0e8d\u0e81\u0e95\u0ec8\u0eb2\u0e87\u0eab\u0eb2\u0e81\u0ec1\u0ea5\u0eb0\u0eaa\u0ebb\u0ec8\u0e87\u0e84\u0eb7\u0e99\u0ea5\u0eb2\u0e8d\u0e8a\u0eb7\u0ec8\u0e82\u0ead\u0e87\u0e9e\u0ea7\u0e81\u0e99\u0eb1\u0ec9\u0e99. \u0e81\u0eb8\u0ec8\u0ea1\u0ec1\u0e8d\u0e81\u0e95\u0ec8\u0eb2\u0e87\u0eab\u0eb2\u0e81\u0ec1\u0ea1\u0ec8\u0e99\u0ea1\u0eb5\u0e84\u0ea7\u0eb2\u0ea1\u0eaa\u0ebb\u0ea1\u0e94\u0eb8\u0e99 (\u0ec1\u0e95\u0ec8\u0ea5\u0eb0\u0ec1\u0e96\u0ea7\u0ec0\u0e9b\u0eb5\u0e94\u0e96\u0eb7\u0e81\u0e9b\u0eb4\u0e94\u0ea2\u0ec8\u0eb2\u0e87\u0e96\u0eb7\u0e81\u0e95\u0ec9\u0ead\u0e87) \u0ec1\u0ea5\u0eb0\u0e9a\u0ecd\u0ec8\u0ec4\u0e94\u0ec9\u0e81\u0ea7\u0ea1\u0ec3\u0eaa\u0ec8\u0e81\u0eb1\u0e99\u0ec3\u0e99\u0ec1\u0e95\u0ec8\u0ea5\u0eb0\u0ead\u0eb1\u0e99. \u0e8d\u0ebb\u0e81\u0ec0\u0ea7\u0eb1\u0ec9\u0e99\u0e8a\u0ec8\u0ead\u0e87\u0eab\u0ea7\u0ec8\u0eb2\u0e87\u0ec3\u0e94\u0ec6\u0ec3\u0e99\u0eaa\u0eb2\u0e8d\u0e81\u0eb2\u0e99\u0e9b\u0ec9\u0ead\u0e99\u0ec0\u0e82\u0ebb\u0ec9\u0eb2. \u0e95\u0ebb\u0ea7\u0ea2\u0ec8\u0eb2\u0e87:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Isa nhamba \"delimeter\" pakati pezvinyorwa zviviri zvinotevera zve input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Uma uniketwe luhla lwetinombolo (lokungenani letimbili), sebentisa indlela yekuhumusha lencane kuleluhla, lencane kakhulu ibe ngu-0 bese lenkhulu ibe ngu-1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Kulomsebenti, utawuniketwa inombolo yemilayeto lemele linani lema-apula nema orintji lahlukaniswe ngekhatsi kwenkhwama yetitselo lenkhwama inema-apula, ema-orintji kanye netitselo tamangoza. Uma kuniketwe inombolo yemilayeto lemele linani leliphelele lema-apula nema-apula kanye nenombolo lephelele lemele linani leliphelele letitselo letikulenkhaba buyisela linani letitselo tamangoza kulenkhaba. sibonelo: fruit_distribution\"5(ema-apula nema-orintji lasitfupha\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 ema-apula nema-orintji lasitfupha\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 ema-apula nema-orintji lasitfupha\", 100) -> 100 - 2 - 3 = 95 fruit_\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" Lomsebenti utawutsatsa luhlu lwema integers. Kuwo onkhe emarekhodi aloluhlu, lomsebenti utawuphindza ngekuphindza ngekuphindza inombolo lephelele uma inombolo yayo iyinombolo lephindvwe nga 3 bese uyayifaka ngekuphindza ngekuphindza ngekuphindza ngekuphindza ngekuphindza nga 4 hhayi ngekuphindza nga 3. Lomsebenti angeke ugucule emarekhodi aloluhlu lanemarekhodi langasiwo ema-multiples nga 3 nobe 4. Lomsebenti utawuphindze ubuyise linani lalawo marekhodi.\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Sapos yu gat wanpela string teks, senisim olgeta hap insait long en long ol underscores, na sapos wanpela string i gat moa long 2 hap insait long en, orait senisim olgeta hap insait long en long - fix_spaces ((\"Example\") == \"Example\" fix_spaces ((\"Example1\") == \"Example_1\" fix_spaces ((\"Example2\") == \"_Example_2\" fix_spaces ((\"Example 3\") == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Sapos yu givim wanpela namba N, yu mas givim namba bilong olgeta digit bilong en long bineri. Eksampel: Sapos N = 1000, namba bilong digit bai 1 na output bai \"1\". Sapos N = 150, namba bilong digit bai 6 na output bai \"110\". Sapos N = 147, namba bilong digit bai 12 na output bai \"1100\". Variabel: @N integer Constraints: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. Output: string bilong bineri namba\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Sapos yu givim string s na natural namba n, yu kisim wok long kamapim wanpela wok we i save givim lista bilong olgeta tok long string s we i gat stret n konsonan, na bai ol dispela tok i ken kamap long string s. Sapos string s i no gat wanpela tok, orait wok i mas givim lista i no gat wanpela tok. Tingim: yu ken ting string i gat ol leta na spes tasol. Eksampel: select_words (((\"Meri i gat liklik pikinini sipsip\", 4) ==> [\"liklik\"] select_words (((\"Meri i gat liklik pikinini sipsip\", 3) ==> [\"Meri\", \"lamb\"] select_words\" (((simple white space\", 2) ==> [] select_words (((\"Hello world\", 4) ==> [\"world\"] select_words (((\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Ri laleng akkaleng, akkaleng e ro nalai seddi paseng, na kodei sibawa cara na nasellei kasus pole ri sininna hurupu', nasellei sininna vowel ri paseng e sibawa hurupu' na iya mompo 2 onrong ri yolo na vowel ri alfabet Inggris.\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Riw\u00e9r\u00e9ng daftar bilangang makkalepu iya de'e kosong lst. tambai elemen genap iya engka ri indeks ganjil.. contona: tambai (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Engka seddi daftar nomoro. parellu mubali'i sumpanna nomoro' kuadrat ri laleng daftar iya riwereng, na-deppung tungke' elemen ri laleng daftar lao ri int kaminang tanre'e. contona: untu' lst = [1,2,3] output'e waji'i mancaji 14 untu' lst = [1,4,9] output'e waji'i mancaji 98 untu' lst = [1,3,5,7] output'e waji'i mancaji 84 untu' lst = [1.4,4.2,0] output'e waji'i mancaji 29 untu' lst = [-2.4,1,1] output'e waji'i mancaji 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"\u5217\u51fa\u4e00\u500b\u5b57\u7b26\u4e32,\u6bcf\u500b\u5b57\u7b26\u4e32\u53ea\u5305\u542b\u6578\u5b57,\u8fd4\u56de\u4e00\u500b\u5217\u8868.\u8f38\u51fa\u5605\u6bcf\u500b\u5143\u7d20i \u90fd\u61c9\u8a72\u4fc2\"\u8f38\u5165\u5b57\u7b26\u4e32i \u4e2d\u5605\u5947\u6578\u5143\u7d20\u5605\u6578\u91cf\".\u6240\u6709i \u90fd\u61c9\u8a72\u88ab\u8f38\u5165\u5b57\u7b26\u4e32i\u4e2d\u5605\u5947\u6578\u5b57\u6578\u91cf\u53d6\u4ee3.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \u5f9e\u4e00\u500b\u5df2\u77e5\u5605\u6574\u6578\u6e05\u55ae,\u751f\u6210\u4e00\u500b\u5217\u8868,\u5176\u4e2d\u5305\u542b\u5230\u67d0\u4e00\u7279\u5b9a\u6642\u523b,\u6578\u5217\u4e2d\u767c\u73fe\u5605\u6700\u5927\u5143\u7d20.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"\u0412\u0438 \u043e\u0442\u0440\u0438\u043c\u0430\u0454\u0442\u0435 \u0441\u043b\u043e\u0432\u043e. \u0412\u0430\u0448\u0438\u043c \u0437\u0430\u0432\u0434\u0430\u043d\u043d\u044f\u043c \u0454 \u0437\u043d\u0430\u0439\u0442\u0438 \u043d\u0430\u0439\u0431\u043b\u0438\u0436\u0447\u0443 \u0433\u043e\u043b\u043e\u0441\u043d\u0443, \u044f\u043a\u0430 \u0437\u043d\u0430\u0445\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u043c\u0456\u0436 \u0434\u0432\u043e\u043c\u0430 \u0441\u0443\u043c\u043e\u0432\u043d\u0438\u043a\u0430\u043c\u0438 \u0437 \u043f\u0440\u0430\u0432\u043e\u0457 \u0441\u0442\u043e\u0440\u043e\u043d\u0438 \u0441\u043b\u043e\u0432\u0430 (\u0437\u0430\u043b\u0435\u0436\u043d\u043e \u0432\u0456\u0434 \u0432\u0435\u043b\u0438\u043a\u043e\u0457 \u0442\u0430 \u043c\u0430\u043b\u043e\u0457 \u0431\u0443\u043a\u0432\u0438). \u0413\u043e\u043b\u043e\u0441\u043d\u0456 \u043d\u0430 \u043f\u043e\u0447\u0430\u0442\u043a\u0443 \u0456 \u043a\u0456\u043d\u0446\u0456 \u043d\u0435 \u0432\u0440\u0430\u0445\u043e\u0432\u0443\u044e\u0442\u044c\u0441\u044f. \u041f\u043e\u0432\u0435\u0440\u043d\u0456\u0442\u044c \u043f\u043e\u0440\u043e\u0436\u043d\u044e \u0441\u0442\u0440\u0443\u043d\u0443, \u044f\u043a\u0449\u043e \u0432\u0438 \u043d\u0435 \u0437\u043d\u0430\u0439\u0448\u043b\u0438 \u0436\u043e\u0434\u043d\u043e\u0457 \u0433\u043e\u043b\u043e\u0441\u043d\u043e\u0457, \u0449\u043e \u0432\u0456\u0434\u043f\u043e\u0432\u0456\u0434\u0430\u0454 \u0432\u0438\u0449\u0435\u0432\u043a\u0430\u0437\u0430\u043d\u0456\u0439 \u0443\u043c\u043e\u0432\u0456. \u0412\u0438 \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u0440\u0438\u043f\u0443\u0441\u0442\u0438\u0442\u0438, \u0449\u043e \u0434\u0430\u043d\u0430 \u0441\u0442\u0440\u0443\u043d\u0430 \u043c\u0456\u0441\u0442\u0438\u0442\u044c \u0442\u0456\u043b\u044c\u043a\u0438 \u0430\u043d\u0433\u043b\u0456\u0439\u0441\u044c\u043a\u0443 \u0431\u0443\u043a\u0432\u0443. \u041f\u0440\u0438\u043a\u043b\u0430\u0434: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"UULL\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    \u0412\u0440\u0430\u0445\u043e\u0432\u0443\u044e\u0447\u0438 \u043c\u0430\u0441\u0438\u0432 \u0446\u0456\u043b\u0438\u0445 \u0447\u0438\u0441\u0435\u043b n, \u0437\u043d\u0430\u0439\u0434\u0456\u0442\u044c \u043c\u0456\u043d\u0456\u043c\u0430\u043b\u044c\u043d\u0443 \u0441\u0443\u043c\u0443 \u0431\u0443\u0434\u044c-\u044f\u043a\u043e\u0433\u043e \u043d\u0435\u043f\u043e\u0440\u043e\u0436\u043d\u044c\u043e\u0433\u043e \u043f\u0456\u0434\u043c\u0430\u0441\u0438\u0432\u0443 \u0447\u0438\u0441\u0435\u043b. \u041f\u0440\u0438\u043a\u043b\u0430\u0434 minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels - \u0446\u0435 \u0444\u0443\u043d\u043a\u0446\u0456\u044f, \u044f\u043a\u0430 \u043f\u0440\u0438\u0439\u043c\u0430\u0454 \u0440\u044f\u0434 \u0456 \u043f\u043e\u0432\u0435\u0440\u0442\u0430\u0454 \u0440\u044f\u0434 \u0431\u0435\u0437 \u0441\u0430\u043c\u043e\u0433\u043e\u043b\u043e\u0441\u0456\u0432.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    \u0e04\u0e38\u0e13\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e40\u0e23\u0e35\u0e22\u0e07\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02\u0e40\u0e15\u0e47\u0e21 arr \u0e41\u0e25\u0e30\u0e04\u0e38\u0e13\u0e15\u0e49\u0e2d\u0e07\u0e04\u0e37\u0e19\u0e1c\u0e25\u0e23\u0e27\u0e21\u0e02\u0e2d\u0e07\u0e02\u0e19\u0e32\u0e14\u0e02\u0e2d\u0e07\u0e08\u0e4d\u0e32\u0e19\u0e27\u0e19\u0e40\u0e15\u0e47\u0e21\u0e04\u0e39\u0e13\u0e01\u0e31\u0e1a\u0e1c\u0e25\u0e1c\u0e25\u0e04\u0e39\u0e13\u0e02\u0e2d\u0e07\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e2b\u0e21\u0e32\u0e22\u0e17\u0e31\u0e49\u0e07\u0e2b\u0e21\u0e14\u0e02\u0e2d\u0e07\u0e41\u0e15\u0e48\u0e25\u0e30\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02\u0e43\u0e19\u0e40\u0e23\u0e35\u0e22\u0e07\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02 \u0e0b\u0e36\u0e48\u0e07\u0e41\u0e2a\u0e14\u0e07\u0e40\u0e1b\u0e47\u0e19 1, -1 \u0e2b\u0e23\u0e37\u0e2d 0 \u0e2b\u0e21\u0e32\u0e22\u0e40\u0e2b\u0e15\u0e38:\u0e04\u0e37\u0e19\u0e04\u0e48\u0e32 None \u0e2a\u0e4d\u0e32\u0e2b\u0e23\u0e31\u0e1a arr \u0e17\u0e35\u0e48\u0e27\u0e48\u0e32\u0e07\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e07\u0e48\u0e32\u0e22\u0e46\u0e17\u0e35\u0e48\u0e04\u0e27\u0e23\u0e04\u0e37\u0e19\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 x \u0e2b\u0e32\u0e01 n \u0e40\u0e1b\u0e47\u0e19\u0e08\u0e4d\u0e32\u0e19\u0e27\u0e19\u0e2b\u0e25\u0e31\u0e01 \u0e41\u0e25\u0e30\u0e04\u0e27\u0e23\u0e04\u0e37\u0e19\u0e04\u0e48\u0e32\u0e02\u0e2d\u0e07 y \u0e2b\u0e32\u0e01\u0e44\u0e21\u0e48\u0e40\u0e0a\u0e48\u0e19\u0e19\u0e31\u0e49\u0e19 \u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07: \u0e2a\u0e4d\u0e32\u0e2b\u0e23\u0e31\u0e1a x_or_y ((7, 34, 12) == 34 \u0e2a\u0e4d\u0e32\u0e2b\u0e23\u0e31\u0e1a x_or_y ((15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"\u0e40\u0e23\u0e32\u0e21\u0e35\u0e40\u0e23\u0e35\u0e22\u0e07 'arr' \u0e02\u0e2d\u0e07\u0e08\u0e4d\u0e32\u0e19\u0e27\u0e19\u0e40\u0e15\u0e47\u0e21 N arr[1], arr[2],..., arr[N] \u0e15\u0e31\u0e27\u0e40\u0e25\u0e02\u0e43\u0e19\u0e40\u0e23\u0e35\u0e22\u0e07\u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e23\u0e35\u0e22\u0e07\u0e15\u0e32\u0e21\u0e2a\u0e38\u0e48\u0e21 \u0e2b\u0e19\u0e49\u0e32\u0e17\u0e35\u0e48\u0e02\u0e2d\u0e07\u0e04\u0e38\u0e13\u0e04\u0e37\u0e2d\u0e01\u0e32\u0e23\u0e01\u0e4d\u0e32\u0e2b\u0e19\u0e14\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19\u0e44\u0e1b\u0e44\u0e14\u0e49\u0e2b\u0e23\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e17\u0e35\u0e48\u0e08\u0e30\u0e08\u0e31\u0e14\u0e40\u0e23\u0e35\u0e22\u0e07\u0e40\u0e23\u0e35\u0e22\u0e07\u0e43\u0e19\u0e25\u0e4d\u0e32\u0e14\u0e31\u0e1a\u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e25\u0e14\u0e25\u0e07\u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e14\u0e4d\u0e32\u0e40\u0e19\u0e34\u0e19\u0e01\u0e32\u0e23\u0e1b\u0e0f\u0e34\u0e1a\u0e31\u0e15\u0e34\u0e01\u0e32\u0e23\u0e15\u0e48\u0e2d\u0e44\u0e1b\u0e19\u0e35\u0e49\u0e1a\u0e19\u0e40\u0e23\u0e35\u0e22\u0e07\u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a: \u0e04\u0e38\u0e13\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15\u0e43\u0e2b\u0e49\u0e14\u0e4d\u0e32\u0e40\u0e19\u0e34\u0e19\u0e01\u0e32\u0e23\u0e02\u0e27\u0e32\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e27\u0e32\u0e07\u0e02\u0e49 \u0e2d\u0e21\u0e39\u0e25 0th \u0e16\u0e49\u0e32\u0e40\u0e1b\u0e47\u0e19\u0e44\u0e1b\u0e44\u0e14\u0e49\u0e17\u0e35\u0e48\u0e08\u0e30\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a\u0e40\u0e23\u0e35\u0e22\u0e07\u0e40\u0e23\u0e35\u0e22\u0e07\u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e14\u0e4d\u0e32\u0e40\u0e19\u0e34\u0e19\u0e01\u0e32\u0e23\u0e14\u0e49\u0e32\u0e19\u0e1a\u0e19\u0e41\u0e25\u0e49\u0e27\u0e01\u0e25\u0e31\u0e1a True \u0e2b\u0e23\u0e37\u0e2d\u0e01\u0e25\u0e31\u0e1a False\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"\u062a\u0648\u06c1\u06cc\u06c1 \u0622\u06cc\u06c1 \u06a9\u0644\u0627\u0633\u06a9 \u0646\u0627\u0648 (\u0627\u06a9\u06be \u0633\u0679\u0631\u0646\u06af) \u062a\u06c1\u0655 \u062a\u0648\u0633\u06cc\u0639\u06a9 \u0627\u06a9\u06be \u0641\u06c1\u0631\u0633\u062a \u062f\u0646\u06c1\u0655\u06d4 \u062a\u0648\u0633\u06cc\u0639\u06c1\u0655 \u0622\u06cc\u06c1\u0655 \u06a9\u0644\u0627\u0633\u0633 \u0645\u0646\u065b\u0632 \u0627\u0636\u0672\u0641\u06cc \u06a9\u0644\u0627\u0633\u06c1\u0655 \u0644\u0648\u0688 \u06a9\u0631\u0646\u06c1\u0655 \u062e\u0627\u0637\u0631\u0655 \u0627\u0633\u062a\u0639\u0645\u0627\u0644 \u06a9\u0631\u0646\u06c1\u0655\u06d4 \u062a\u0648\u0633\u06cc\u0639\u0686 \u0637\u0627\u0642\u062a \u0686\u0650\u06be \u06cc\u062a\u06be\u06c1\u0655: CAP \u06cc\u06cc\u06c1\u0655 \u062a\u0648\u0633\u06cc\u0639 \u06a9\u0633 \u0646\u0627\u0648\u0633 \u0645\u0646\u065b\u0632 \u0628\u0691\u06d2 \u062d\u0631\u0641\u0646 \u06c1\u0646\u065b\u062f \u062a\u0639\u062f\u0627\u062f\u060c \u062a\u06c1\u0655 SM \u06cc\u06cc\u06c1\u0655 \u062a\u0648\u0633\u06cc\u0639 \u06a9\u0633 \u0646\u0627\u0648\u0633 \u0645\u0646\u065b\u0632 \u0644\u0648\u06a9\u0627\u0633\u0679\u0631\u0633 \u06c1\u0646\u065b\u062f \u062a\u0639\u062f\u0627\u062f\u060c \u0637\u0627\u0642\u062a \u0686\u0650\u06be \u06a9\u0633\u0631 CAP - SM \u0633\u06ed\u062a\u06cd \u062f\u0646\u06c1\u0655 \u0622\u0645\u0698\u06d4 \u062a\u0648\u06c1\u06cc\u06c1 \u06af\u0698\u06be \u0645\u0636\u0628\u0648\u0637 \u062a\u0631\u06cc\u0646 \u062a\u0648\u0633\u06cc\u0639 \u062a\u0644\u0627\u0634 \u06a9\u0631\u062a\u06be \u062a\u06c1\u0655 \u0627\u0645\u06c1\u0655 \u0634\u06a9\u0644\u06c1\u0655 \u0645\u0646\u065b\u0632 \u0633\u0679\u0631\u0646\u06af \u0648\u0627\u067e\u0633 \u06cc\u06cc\u06c1\u0655 \u062f\u0646\u06c1\u0655: ClassName.StrongestExtensionName\u06d4 \u0627\u06af\u0631 \u0627\u06a9\u0633\u06cc \u0637\u0627\u0642\u062a\u06a9 \u0632\u0655 \u06cc\u0627 \u0632\u06cc\u0627\u062f\u0655 \u062a\u0648\u0633\u06cc\u0639\u06c1\u0655 \u0686\u0650\u06be\u060c \u062a\u0648\u06c1\u06cc\u06c1 \u06af\u0698\u06be \u0641\u06c1\u0631\u0633\u062a\u0633 \u0645\u0646\u065b\u0632 \u06af\u06c4\u0688\u0646\u0686 \u06af\u0698\u06be\u0646 \u0648\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero \u0686\u064f\u06be \u0627\u0646 \u067e\u0679 \u06a9\u0650\u0633 \u0637\u0648\u0631\u0633 \u067e\u06cc\u0679\u06be \u0639\u062f\u062f\u0655\u0686 \u0627\u06a9\u06be \u0641\u06c1\u0631\u0633\u062a \u0646\u0648\u0627\u0646\u06d4 \u06cc\u06c1\u0655 \u0686\u064f\u06be True \u0648\u0627\u067e\u0633 \u06a9\u0631\u0627\u0646 \u0627\u06af\u0631 \u0641\u06c1\u0631\u0633\u062a\u0633 \u0645\u0646\u0632 \u0686\u0650\u06be \u062a\u0631\u06cc\u06c1 \u0627\u0644\u06af \u0627\u0644\u06af \u0639\u0646\u0627\u0635\u0631 \u06cc\u0645 \u0635\u0641\u0631\u0655\u0686 \u0631\u0642\u0645 \u0686\u0650\u06be\u060c \u062a\u06c1\u0655 \u0628\u06cc\u06cc\u06c1\u0655 False\u06d4\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    \u0647\u06aa \u0627\u0633\u067d\u0631\u0646\u06af \u0645\u062a\u0646 \u068f\u0646\u0648\u060c \u0627\u0646 \u06fe \u0633\u0680\u0646\u064a \u062c\u06b3\u0647\u0646 \u06a9\u064a underscores \u0633\u0627\u0646 \u062a\u0628\u062f\u064a\u0644 \u06aa\u0631\u064a\u0648\u060c \u06fd \u062c\u064a\u06aa\u068f\u0647\u0646 \u0647\u06aa \u0627\u0633\u067d\u0631\u0646\u06af \u06fe 2 \u06a9\u0627\u0646 \u0648\u068c\u064a\u06aa \u0644\u06b3\u0627\u062a\u0627\u0631 \u062c\u06b3\u0647\u0646 \u0622\u0647\u0646\u060c \u067e\u0648\u0621 \u0633\u0680\u0646\u064a \u0644\u06b3\u0627\u062a\u0627\u0631 \u062c\u06b3\u0647\u0646 \u06a9\u064a \u062a\u0628\u062f\u064a\u0644 \u06aa\u0631\u064a\u0648 - fix_spaces (((\"\u0645\u062b\u0627\u0644\") == \"\u0645\u062b\u0627\u0644\" fix_spaces (((\"\u0645\u062b\u0627\u06441\") == \"\u0645\u062b\u0627\u06441\" fix_spaces (((\"\u0645\u062b\u0627\u06442\") == \"_\u0645\u062b\u0627\u0644_2\" fix_spaces (((\"\u0645\u062b\u0627\u0644 3\") == \"_\u0645\u062b\u0627\u0644-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"\u0647\u06aa \u0645\u062b\u0628\u062a \u0627\u0646\u067d\u064a\u06af\u0631 N \u068f\u0646\u0648 \u0648\u064a\u0648 \u0622\u0647\u064a\u060c \u0627\u0646 \u062c\u064a \u0627\u0646\u06af\u0646 \u062c\u0648 \u0645\u062c\u0645\u0648\u0639\u0648 \u0628\u0627\u0626\u0646\u0631\u064a \u06fe \u0645\u0648\u067d\u0627\u064a\u0648. \u0645\u062b\u0627\u0644 \u0637\u0648\u0631 N = 1000 \u0644\u0627\u0621\u0650 \u060c \u0627\u0646\u06af\u0646 \u062c\u0648 \u0645\u062c\u0645\u0648\u0639\u0648 1 \u0647\u0648\u0646\u062f\u0648 \u0627\u0646\u067d\u0631\u0648\u064a\u0648 \"1\" \u0647\u062c\u06bb \u06af\u0647\u0631\u062c\u064a. N = 150 \u0644\u0627\u0621\u0650 \u060c \u0627\u0646\u06af\u0646 \u062c\u0648 \u0645\u062c\u0645\u0648\u0639\u0648 6 \u0647\u0648\u0646\u062f\u0648 \u0627\u0646\u067d\u0631\u0648\u064a\u0648 \"110\" \u0647\u062c\u06bb \u06af\u0647\u0631\u062c\u064a. N = 147 \u0644\u0627\u0621\u0650 \u060c \u0627\u0646\u06af\u0646 \u062c\u0648 \u0645\u062c\u0645\u0648\u0639\u0648 12 \u0647\u0648\u0646\u062f\u0648 \u0627\u0646\u067d\u0631\u0648\u064a\u0648 \"1100\" \u0647\u062c\u06bb \u06af\u0647\u0631\u062c\u064a. \u0645\u062a\u063a\u064a\u0631: @N \u0627\u0646\u067d\u064a\u06af\u0631 \u067e\u0627\u0628\u0646\u062f\u064a\u0648\u0646: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. \u067b\u0627\u06be\u0631: \u0628\u0627\u0626\u0646\u0631\u064a \u0646\u0645\u0628\u0631 \u062c\u064a \u06be\u06aa\u0699\u064a \u062a\u0627\u0631\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"\u062a\u0648\u0647\u0627\u0646 \u06a9\u064a \u0647\u06aa \u06aa\u0644\u0627\u0633 \u062c\u0648 \u0646\u0627\u0644\u0648 (\u0647\u06aa \u0627\u0633\u067d\u0631\u0646\u06af) \u06fd \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u062c\u064a \u0647\u06aa \u0644\u0633\u067d \u068f\u0646\u064a \u0648\u064a\u0646\u062f\u064a. \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u06a9\u064a \u06aa\u0644\u0627\u0633 \u06fe \u0627\u0636\u0627\u0641\u064a \u06aa\u0644\u0627\u0633 \u0644\u0648\u068a \u06aa\u0631\u06bb \u0644\u0627\u0621\u0650 \u0627\u0633\u062a\u0639\u0645\u0627\u0644 \u06aa\u064a\u0648 \u0648\u064a\u0646\u062f\u0648. \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u062c\u064a \u0637\u0627\u0642\u062a \u0647\u0646 \u0631\u064a\u062a \u0622\u0647\u064a: CAP \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u062c\u064a \u0646\u0627\u0644\u064a \u06fe \u0648\u068f\u0646 \u0627\u06a9\u0631\u0646 \u062c\u0648 \u062a\u0639\u062f\u0627\u062f \u0647\u062c\u064a\u060c \u06fd SM \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u062c\u064a \u0646\u0627\u0644\u064a \u06fe \u0646\u0646\u068d\u0646 \u0627\u06a9\u0631\u0646 \u062c\u0648 \u062a\u0639\u062f\u0627\u062f \u0647\u062c\u064a\u060c \u0637\u0627\u0642\u062a CAP - SM \u0680\u0627\u06b1\u064a \u0633\u0627\u0646 \u068f\u0646\u064a \u0648\u064a\u0646\u062f\u064a \u0622\u0647\u064a. \u062a\u0648\u0647\u0627\u0646 \u06a9\u064a \u0645\u0636\u0628\u0648\u0637 \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u06b3\u0648\u0644\u06bb \u06af\u0647\u0631\u062c\u064a \u06fd \u0647\u0646 \u0641\u0627\u0631\u0645\u064a\u067d \u06fe \u0647\u06aa \u0627\u0633\u067d\u0631\u0646\u06af \u0648\u0627\u067e\u0633 \u06aa\u0631\u06bb \u06af\u0647\u0631\u062c\u064a: ClassName.StrongestExtensionName. \u062c\u064a\u06aa\u068f\u0647\u0646 \u067b\u0647 \u064a\u0627 \u0648\u068c\u064a\u06aa \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u0647\u06aa \u0626\u064a \u0637\u0627\u0642\u062a \u0633\u0627\u0646 \u0622\u0647\u0646\u060c \u062a\u0648\u0647\u0627\u0646 \u06a9\u064a \u0627\u0647\u0648 \u0686\u0648\u0646\u068a\u06bb \u06af\u0647\u0631\u062c\u064a \u062c\u064a\u06aa\u0648 \u0641\u0647\u0631\u0633\u062a \u06fe \u067e\u0647\u0631\u064a\u0648\u0646 \u0627\u0686\u064a. \u0645\u062b\u0627\u0644 \u0637\u0648\u0631\u060c \u062c\u064a\u06aa\u068f\u0647\u0646 \u062a\u0648\u0647\u0627\u0646 \u06a9\u064a \"\u0633\u0644\u0627\u0626\u0633\" \u06aa\u0644\u0627\u0633 \u06fd \u0627\u064a\u06aa\u0633\u067d\u064a\u0646\u0634\u0646 \u062c\u064a \u0644\u0633\u067d \u0637\u0648\u0631 \u068f\u0646\u064a \u0648\u0626\u064a \u0622\u0647\u064a: [\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Sa palagay ko lahat tayo ay natatandaan ang pakiramdam na iyon kapag ang resulta ng ilang matagal nang hinintay na kaganapan ay sa wakas ay kilala. Ang mga damdamin at mga saloobin na mayroon ka sa sandaling iyon ay tiyak na nagkakahalaga ng pag-anot at paghahambing. Ang iyong gawain ay upang matukoy kung ang isang tao ay tama ang mga resulta ng isang bilang ng mga tugma. Binigyan ka ng dalawang array ng mga marka at mga hula ng pantay na haba, kung saan ang bawat index ay nagpapakita ng isang tugma. Bumalik ang isang array ng parehong haba na nagpapahiwatig kung gaano kalayuan ang bawat hula. Kung tama ang kanilang hula, ang halaga ay 0, at kung hindi, ang halaga ay ang ganap na pagkakaiba sa pagitan ng hula at ang iskor. halimbawa: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare (([\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero ay tumatagal ng isang listahan ng mga integer bilang isang input. ito ay bumalik True kung may tatlong magkakaibang mga elemento sa listahan na suma sa zero, at False kung hindi man.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Lumikha ng isang function encrypt na tumatagal ng isang string bilang isang argumento at nagbabalik ng isang string encrypted na may alpabeto na binalik. Ang alpabeto ay dapat na binalik sa isang paraan na ang mga titik shift pababa sa pamamagitan ng dalawang pinagmultiply sa dalawang lugar. Halimbawa: encrypt('hi') nagbabalik 'lm' encrypt('asdfghjkl') nagbabalik 'ewhjklnop' encrypt('gf') nagbabalik 'kj' encrypt('et') nagbabalik 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    A then khat a tam a, a then khat a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a tam a\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"A then chu a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then a then\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"A bul leh a tawp lam awl leh awl te hi chhiar a ni lo. A bul leh a tawp lam awl te hi chhiar a ni lo. A chunga a awl awm zawng zawng i hmuh loh chuan a chhah lo a rawn thawn leh ang che. A string-ah hian English letter chauh a awm i ti mai thei. Example: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\"get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib ibuyisa inani le-nth eliyinombolo yeFibonacci kwaye ikwangumbhalo wokuqala.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Buyisela eyona nto iphambili eyahlula amanani amabini a kunye no-b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Bhala umsebenzi owamkela uluhlu lwentambo njengeparameter, ucime intambo ezinobude obungafaniyo kuyo, kwaye ubuyisele uluhlu olwenziwe ngolungelelwaniso oluhleliweyo, Uluhlu luhlala luluhlu lwentambo kwaye alusoze lube ngumqolo wamanani, kwaye lunokuqulatha ukuphindaphinda. Ulungelelwaniso loluhlu kufuneka lube luyanda ngobude begama ngalinye, kwaye kufuneka ubuyisele uluhlu oluhleliweyo ngalo mthetho. Ukuba amagama amabini anobude obufanayo, hlengisa uluhlu ngokwealfabhethi. Umsebenzi kufuneka ubuyisele uluhlu lwentambo ngolungelelwaniso oluhleliweyo. Unokucinga ukuba onke amagama aya kuba nobude obufanayo. Umzekelo: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Operasi aljabar dasar: Penjumlahan (+) Pengurangan (-)) Perkalian (-)) Pembagian lantai (-)) Eksponensi (**) Contoh: operator['+', '*', '-'] array = [2, 3, 4, 5] hasil = 2 + 3 * 4 - 5 => hasil = 9 Catatan: Panjang daftar operator sama dengan panjang daftar operand dikurangi satu. Operand adalah daftar bilangan bulat non-negatif. Operator memiliki setidaknya satu daftar operator, dan daftar operand memiliki setidaknya dua operand.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Berikan array arr bilangan bulat, carilah jumlah minimum elemen yang perlu diubah untuk membuat array palindromik. Array palindromik adalah array yang dibaca sama ke belakang dan ke depan. Dalam satu perubahan, Anda dapat mengubah satu elemen ke elemen lain. Misalnya: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Pindah bulat digit dari bilangan bulat x, pindahkan digit ke kanan dengan pergeseran dan mengembalikan hasilnya sebagai string. Jika pergeseran > jumlah digit, kembalikan digit terbalik.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Ye \u014bw\u025bna nimas\u0269 k\u0269tat\u0269\u014ba y\u0254, kpa\u0263 s\u0269-h\u0269la n\u025b \u014bl\u025b\u0263z\u0269na-s\u0269 n\u025b \u014byele n\u025b s\u0269-h\u0269la k\u0269tat\u0269\u014ba. Ye nimas\u0269 nz\u0269 s\u0269-h\u0269la \u0269f\u025by\u0269 y\u0254, \u014bl\u025b\u0263z\u0269na-s\u0269 n\u025b \u014byele n\u025b s\u0269-h\u0269la \u0269w\u025b\u025b n\u025b \u014bl\u025b\u0263z\u0269na-s\u0269 n\u025b \u014byele n\u025b s\u0269-h\u0269la \u0269w\u025b\u025b n\u025b \u014bl\u025b\u0263z\u0269na-s\u0269 n\u025b \u014byele n\u025b s\u0269-h\u0269la \u0269w\u025b\u025b n\u025b \u014bl\u025b\u0263z\u0269na-s\u0269 n\u025b s\u0269-h\u0269la.\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    \u014ak\u025b kp\u0269n\u025b n\u0256\u0269 \u0256\u0269w\u025bn\u0269 \u00f1\u0254\u0254s\u0269 y\u0254, \u014bt\u025bm t\u0254\u0254\u028b kaarooti sak\u0269y\u025b, \u025bl\u025b l\u025b\u025bl\u025b\u025by\u0254 l\u025b, p\u0269p\u0254z\u028b\u028b se \u014bt\u0254\u0254 kaarooti sak\u0269y\u025b n\u025b p\u0269sa n\u025b \u014bt\u025bz\u0269 t\u0254\u0254na\u0263 t\u0254\u0254\u028b k\u0269yak\u028b \u014bg\u028b. P\u0269w\u025b\u025b se \u014byele n\u025b [kaarooti sak\u0269y\u025b nz\u0269 \u014bt\u0254\u0254 t\u0254\u0254na\u0263 way\u0269 y\u0254, s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269-t\u0269\u014ba s\u0269\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    P\u0269t\u025b l\u025b, \u014bt\u025bz\u0269\u0263na-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025bz\u0269\u0263-\u0269 n\u025b \u014bt\u025b\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Whakauruhia he tau \"tohu\" i waenga i nga waahanga e rua o te raarangi whakauru \"numbers\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Ka hoki True ko ng\u0101 hu\u0101nga r\u0101rangi e piki haere ana, e heke haere ana r\u0101nei.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Ka hoki mai te tau Fibonacci n-th.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Contoh: is_happy (a) => False is_happy (a) => False is_happy (a) => True is_happy (a) => False is_happy (b) => False is_happy (c) => False is_happy (d) => False is_happy (e) => False is_happy (f) => False is_happy (g) => False is_happy (h) => False is_happy (x) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"\" 'Cicocococok_cek_ \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en_cycpattern_check}} \" '{{lang-en\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"List re\u1e6de strings nena, jena leko string digits re chemda, list re\u1e6de return kar.\n    Output re\u1e6de element i \"the number of odd elements in the string i of the input.\"\n    ke\u1e6de hena, jena i's sab hena replace kar te number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input rekan a\u1e31a\u1e31 ceda a\u1e31 b\u1e31 ha\u1e31 \u1e31a\u1e31 1\u1e31 \u1e31a\u1e31 0\u1e31.\n    Ceda binary XOR \u1e31ena rekan ar return \u1e31ena result ceda string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"x ko y ko rekhena\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"\u0a8f\u0a95 \u0a9d\u0abe\u0aa1\u0aa8\u0ac0 \u0ab6\u0abe\u0a96\u0abe\u0aa8\u0ac1\u0a82 \u0aaa\u0acd\u0ab0\u0aa4\u0abf\u0aa8\u0abf\u0aa7\u0abf\u0aa4\u0acd\u0ab5 \u0a95\u0ab0\u0aa4\u0ac0 \u0a8f\u0ab0\u0ac7 \u0a86\u0aaa\u0ab5\u0abe\u0aae\u0abe\u0a82 \u0a86\u0ab5\u0ac7 \u0a9b\u0ac7 \u0a9c\u0ac7\u0aae\u0abe\u0a82 \u0aac\u0abf\u0aa8-\u0aa8\u0a95\u0abe\u0ab0\u0abe\u0aa4\u0acd\u0aae\u0a95 \u0aaa\u0ac2\u0ab0\u0acd\u0aa3\u0abe\u0a82\u0a95 \u0a97\u0abe\u0a82\u0aa0\u0acb \u0ab9\u0acb\u0aaf \u0a9b\u0ac7 \u0aa4\u0aae\u0abe\u0ab0\u0ac1\u0a82 \u0a95\u0abe\u0ab0\u0acd\u0aaf \u0a8f \u0a9b\u0ac7 \u0a95\u0ac7 \u0a97\u0abe\u0a82\u0aa0\u0acb\u0aae\u0abe\u0a82\u0aa5\u0ac0 \u0a8f\u0a95\u0aa8\u0ac7 \u0aaa\u0ab8\u0a82\u0aa6 \u0a95\u0ab0\u0acb \u0a85\u0aa8\u0ac7 \u0aa4\u0ac7\u0aa8\u0ac7 \u0aaa\u0ab0\u0aa4 \u0a95\u0ab0\u0acb. \u0aaa\u0ab8\u0a82\u0aa6 \u0a95\u0ab0\u0ac7\u0ab2 \u0a97\u0abe\u0a82\u0aa0 \u0ab8\u0acc\u0aa5\u0ac0 \u0aa8\u0abe\u0aa8\u0abe \u0aaa\u0aa3 \u0aae\u0ac2\u0ab2\u0acd\u0aaf \u0ab8\u0abe\u0aa5\u0ac7\u0aa8\u0acb \u0a97\u0abe\u0a82\u0aa0 \u0ab9\u0acb\u0ab5\u0acb \u0a9c\u0acb\u0a88\u0a8f. \u0a9c\u0acb \u0ab8\u0aae\u0abe\u0aa8 \u0ab8\u0acc\u0aa5\u0ac0 \u0aa8\u0abe\u0aa8\u0abe \u0aaa\u0aa3 \u0aae\u0ac2\u0ab2\u0acd\u0aaf\u0ab5\u0abe\u0ab3\u0abe \u0aac\u0ab9\u0ac1\u0ab5\u0abf\u0aa7 \u0a97\u0abe\u0a82\u0aa0\u0acb \u0aae\u0ab3\u0ac7 \u0aa4\u0acb \u0ab8\u0acc\u0aa5\u0ac0 \u0aa8\u0abe\u0aa8\u0acb \u0a85\u0aa8\u0ac1\u0a95\u0acd\u0ab0\u0aae\u0aa3\u0abf\u0a95\u0abe \u0aa7\u0ab0\u0abe\u0ab5\u0aa4\u0acb \u0a97\u0abe\u0a82\u0aa0 \u0aaa\u0ab0\u0aa4 \u0a95\u0ab0\u0acb. \u0aaa\u0ab8\u0a82\u0aa6 \u0a95\u0ab0\u0ac7\u0ab2 \u0a97\u0abe\u0a82\u0aa0\u0aa8\u0ac7 \u0ab8\u0ac2\u0a9a\u0abf\u0aae\u0abe\u0a82 \u0aaa\u0ab0\u0aa4 \u0a95\u0ab0\u0ab5\u0acb \u0a9c\u0acb\u0a88\u0a8f, [smallest_value, \u0aa4\u0ac7\u0aa8\u0abe \u0a85\u0aa8\u0ac1\u0a95\u0acd\u0ab0\u0aae\u0aa3\u0abf\u0a95\u0abe ], \u0a9c\u0acb \u0aa4\u0acd\u0aaf\u0abe\u0a82 \u0a95\u0acb\u0a88 \u0aaa\u0aa3 \u0aae\u0ac2\u0ab2\u0acd\u0aaf\u0acb \u0aa8\u0aa5\u0ac0 \u0a85\u0aa5\u0ab5\u0abe \u0a86\u0aaa\u0ac7\u0ab2 \u0a8f\u0ab0\u0ac7 \u0a96\u0abe\u0ab2\u0ac0 \u0a9b\u0ac7, \u0aa4\u0acb \u0aaa\u0abe\u0a9b\u0abe \u0a86\u0ab5\u0acb []. \u0a89\u0aa6\u0abe\u0ab9\u0ab0\u0aa3 1: \u0a87\u0aa8\u0aaa\u0ac1\u0a9f\u0a83 [4,2,3] \u0a86\u0a89\u0a9f\u0aaa\u0ac1\u0a9f\u0a83 [2, 1] \u0ab8\u0aae\u0a9c\u0ac2\u0aa4\u0ac0\u0a83 2 \u0ab8\u0acc\u0aa5\u0ac0 \u0aa8\u0abe\u0aa8\u0ac1\u0a82 \u0aaa\u0aa3 \u0aae\u0ac2\u0ab2\u0acd\u0aaf \u0aa7\u0ab0\u0abe\u0ab5\u0ac7 \u0a9b\u0ac7, \u0a85\u0aa8\u0ac7 2 \u0ab8\u0acc\u0aa5\u0ac0 \u0aa8\u0abe\u0aa8\u0ac1\u0a82 \u0a85\u0aa8\u0ac1\u0a95\u0acd\u0ab0\u0aae\u0aa3\u0abf\u0a95\u0abe \u0aa7\u0ab0\u0abe\u0ab5\u0ac7 \u0a9b\u0ac7. \u0a89\u0aa6\u0abe\u0ab9\u0ab0\u0aa3 2: \u0a87\u0aa8\u0aaa\u0ac1\u0a9f\u0a83\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    \u0aa4\u0acd\u0ab0\u0aa3 \u0a85\u0a95\u0acd\u0ab7\u0ab0\u0acb\u0aa8\u0abe \u0a9a\u0a95\u0acd\u0ab0 \u0a9c\u0ac2\u0aa5\u0acb \u0aa6\u0acd\u0ab5\u0abe\u0ab0\u0abe \u0a8f\u0aa8\u0acd\u0a95\u0acb\u0aa1\u0ac7\u0aa1 \u0ab6\u0aac\u0acd\u0aa6\u0aae\u0abe\u0ab3\u0abe \u0a86\u0aaa\u0ac7 \u0a9b\u0ac7.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \u0a8f \"<\" \u0a85\u0aa8\u0ac7 \">\" \u0aa8\u0ac0 \u0ab8\u0acd\u0a9f\u0acd\u0ab0\u0abf\u0a82\u0a97 \u0a9b\u0ac7. \u0a9c\u0acb \u0aa6\u0ab0\u0ac7\u0a95 \u0a93\u0aaa\u0aa8\u0abf\u0a82\u0a97 \u0a95\u0acc\u0a82\u0ab8\u0aae\u0abe\u0a82 \u0a85\u0aa8\u0ac1\u0ab0\u0ac2\u0aaa \u0aac\u0a82\u0aa7 \u0a95\u0acc\u0a82\u0ab8 \u0ab9\u0acb\u0aaf \u0aa4\u0acb \u0ab8\u0abe\u0a9a\u0ac1\u0a82 \u0aaa\u0ab0\u0aa4 \u0a95\u0ab0\u0acb.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u0425 \u043d\u043e\u043a\u0442\u0430\u0441\u044b\u043d\u0434\u0430 xs \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u043b\u044b \u043a\u04af\u043f\u0441\u0430\u043d\u043b\u044b \u0441\u0430\u043d\u043d\u044b \u0431\u04d9\u044f\u043b\u0438. xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n \u043a\u0430\u0439\u0442\u0430\u0440\u044b\u0433\u044b\u0437\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u0421\u0435\u0437\u0433\u04d9 \u0431\u04e9\u0442\u0435\u043d \u0441\u0430\u043d\u043d\u0430\u0440 \u0438\u0441\u0435\u043c\u043b\u0435\u0433\u0435 \u0431\u0438\u0440\u0435\u043b\u04d9. \u0438\u0441\u0435\u043c\u043b\u0435\u043a\u043d\u0435\u04a3 2 \u043d\u0447\u0435 \u0438\u04a3 \u043a\u0435\u0447\u043a\u0435\u043d\u04d9 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b\u043d \u043a\u0438\u0440\u0435 \u043a\u0430\u0439\u0442\u0430\u0440\u0430 \u0442\u043e\u0440\u0433\u0430\u043d next_smallest () \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u0441\u0435\u043d \u044f\u0437\u044b\u0433\u044b\u0437. \u0410\u043d\u0434\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0431\u0443\u043b\u043c\u0430\u0441\u0430, None () \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u0441\u0435\u043d \u043a\u0438\u0440\u0435 \u043a\u0430\u0439\u0442\u0430\u0440\u044b\u0433\u044b\u0437. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == None next_smallest () [1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" \u0411\u0438\u0440\u0435\u043b\u0433\u04d9\u043d \u0431\u04e9\u0442\u0435\u043d \u0441\u0430\u043d\u043d\u044b\u04a3 \u0431\u0435\u0440\u0435\u043d\u0447\u0435 \u0442\u0430\u043f\u043a\u044b\u0440\u043b\u0430\u0443\u0447\u044b\u043b\u0430\u0440 \u0438\u0441\u0435\u043c\u043b\u0435\u0433\u0435\u043d \u043a\u0435\u0447\u0435\u0434\u04d9\u043d \u0437\u0443\u0440\u0433\u0430 \u043a\u0430\u0434\u04d9\u0440 \u0442\u04d9\u0440\u0442\u0438\u043f\u0442\u04d9 \u043a\u0430\u0439\u0442\u0430\u0440\u044b\u0433\u044b\u0437. \u04ba\u04d9\u0440\u0431\u0435\u0440 \u0444\u0430\u043a\u0442\u043e\u0440\u043d\u044b\u04a3 \u0442\u0430\u043f\u043a\u044b\u0440\u043b\u0430\u0443 \u0441\u0430\u043d\u044b \u0430\u043d\u044b\u04a3 \u0442\u0430\u043f\u043a\u044b\u0440\u043b\u0430\u0443\u0434\u0430 \u043d\u0438\u0447\u04d9 \u0442\u0430\u043f\u043a\u044b\u0440 \u0431\u0430\u0440\u043b\u044b\u043a\u043a\u0430 \u043a\u0438\u043b\u04af\u0435\u043d\u04d9 \u0442\u0443\u0440\u044b \u043a\u0438\u043b\u0435\u0440\u0433\u04d9 \u0442\u0438\u0435\u0448. \u041a\u0435\u0440\u04af \u0441\u0430\u043d\u044b \u0431\u0430\u0440\u043b\u044b\u043a \u0444\u0430\u043a\u0442\u043e\u0440\u043b\u0430\u0440\u043d\u044b\u04a3 \u0442\u0430\u043f\u043a\u044b\u0440\u043b\u0430\u043d\u0443\u044b\u043d\u0430 \u0442\u0438\u0433\u0435\u0437 \u0431\u0443\u043b\u044b\u0440\u0433\u0430 \u0442\u0438\u0435\u0448\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Lies van alle prefixe van kortste nao langste vaan de inputstring\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Gegaeve 'n positief floatendje punt getal, kan 't weer aafgebroke weure in en integerdeil (groetste integer kleiner es 't gegegeerde getal) en decimalen (overgebleve deil altied kleiner es 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"az\u0254\u0300 \u00e9l\u0254\u0301 n\u0254\u0301 y\u00ed n\u00f9xwl\u00e9 l bo n\u0254\u0301 l\u025b\u0301 y\u00ed n\u00f9xwl\u00e9 l' b\u0254\u0300 \u00e9 c\u00ed l' \u0256\u00f2 n\u00f9xwl\u00e9 l' l\u025b\u0301\u025b m\u025b\u0300, c\u00f3 n\u00f9xwl\u00e9 l' l\u025b\u0301\u025b \u0256\u00f2 n\u00f9xwl\u00e9 l' l\u025b\u0301\u025b m\u025b\u0300 \u0254\u0301, n\u00f9xwl\u00e9 l' l\u025b\u0301\u025b t\u0254n n\u0254\u0301 c\u00ed n\u00f9xwl\u00e9 l' l\u025b\u0301\u025b t\u0254n l\u025b\u0301\u025b \u0256\u0254hun, c\u00f3 \u00e8 n\u0254 \u0256\u00e8 ye \u0256\u00f3 al\u0254kpa m\u025b\u0300.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    \u00d0\u00e0\u00e7\u00f0\u00e0\u00e1\u00ee\u00f2\u00e0\u00ed\u00ed\u00fb\u00e9 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0 \u00f1 N \u00f0\u00ff\u00e4\u00e0\u00ec\u00e8 \u00e8 N \u00ea\u00ee\u00ef\u00e5\u00ff\u00ec\u00e8 (N >= 2) \u00e8 \u00ef\u00ee\u00eb\u00ee\u00e6\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee\u00e9 \u00ef\u00ee\u00eb\u00ee\u00e2\u00e8\u00ed\u00ee\u00e9 k, \u00ea\u00e0\u00e6\u00e4\u00e0\u00ff \u00ea\u00eb\u00e0\u00ef\u00e0\u00ed\u00e0 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e0 \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e8\u00f2 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5. \u00ca\u00e0\u00e6\u00e4\u00fb\u00e9 \u00ef\u00ee\u00eb\u00ee\u00e2\u00e8\u00ed\u00e0 \u00e2 \u00f0\u00e0\u00e9\u00ee\u00ed\u00e5 [1, N * N] \u00e2\u00ea\u00eb\u00fe\u00f7\u00e0\u00e5\u00f2\u00f1\u00ff \u00e8\u00ec\u00e5\u00ed\u00ed\u00ee \u00f0\u00e0\u00e7 \u00ed\u00e0 \u00ea\u00eb\u00e0\u00ef\u00e0\u00ed\u00e0\u00f5 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e0. \u00c2\u00e0\u00ec \u00ed\u00f3\u00e6\u00ed\u00ee \u00ed\u00e0\u00e9\u00f2\u00e8 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00ef\u00f3\u00f2\u00fc \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e0 k \u00e2 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e5. \u00c2\u00e0\u00ec \u00ed\u00f3\u00e6\u00ed\u00ee \u00ed\u00e0\u00f7\u00e0\u00f2\u00fc \u00e8\u00e7 \u00eb\u00fe\u00e1\u00ee\u00e9 \u00ea\u00eb\u00e0\u00ef\u00e0\u00ed\u00e0, \u00e8 \u00ed\u00e0 \u00ea\u00e0\u00e6\u00e4\u00ee\u00ec \u00fd\u00f2\u00ee\u00ec \u00fd\u00f2\u00e0\u00ef\u00e5 \u00e2\u00fb \u00ec\u00ee\u00e6\u00e5\u00f2\u00e5 \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00f2\u00fc \u00ea \u00ea\u00eb\u00e0\u00ef\u00e0\u00ed\u00e0\u00ec, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e5 \u00e8\u00ec\u00e5\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Z\u0254\u0301n n\u01d4 e \u0256\u00f2 n\u00f9jl\u025b\u0301jl\u025b\u0301 \u0254\u0301 m\u025b \u00e9 b\u01d0.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Vi ste gladni zec, i ve\u0107 ste pojeli odre\u0111eni broj mrkve, ali sada morate da pojedete vi\u0161e mrkve da biste zavr\u0161ili dnevni obrok. treba da vratite niz [ukupni broj pojedenih mrvica nakon obroka, broj mrvica koje su preostale nakon obroka] ako nema dovoljno preostalih mrvica, pojeste sve preostale mrkve, ali \u0107ete i dalje biti gladni. Primjer: * jesti ((5, 6, 10) -> [11, 4] * jesti ((4, 8, 9) -> [12, 1] * jesti ((1, 10, 10) -> [11, 0] * jesti ((2, 11, 5) -> [7, 0] Promjenjivi: @broj: cijelni broj mrvica koje ste pojeli. @potreba: cijelni broj mrvica koje morate da pojedete. @ preostali: cijelni broj preostalih mrvica koje postoje u zalih: * ograni\u010denje: * 0\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Napisati funkciju koja uzima niz i vra\u0107a Istinita ako je du\u017eina niza prvi broj ili La\u017ena u suprotnom Primjeri prime_length{'Hello') == Istinita prva_du\u017eina{'abcdcba') == Istinita prva_du\u017eina{'kittens') == Istinita prva_du\u017eina{'orange') == La\u017ena\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \u0639\u0646\u062f \u0625\u0639\u0637\u0627\u0621 \u0642\u0627\u0626\u0645\u0629 \u0645\u0646 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 (\u0645\u0646 \u0639\u0646\u0635\u0631\u064a\u0646 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644) \u060c \u0642\u0645 \u0628\u062a\u062d\u0648\u064a\u0644\u0647\u0627 \u062e\u0637\u064a\u060c \u0628\u062d\u064a\u062b \u064a\u0635\u0628\u062d \u0623\u0635\u063a\u0631 \u0631\u0642\u0645 0 \u0648\u0623\u0643\u0628\u0631 \u0648\u0627\u062d\u062f\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    \u0639\u0646\u062f \u0625\u0639\u0637\u0627\u0621 \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0625\u064a\u062c\u0627\u0628\u064a\u060c \u0627\u062d\u0635\u0644 \u0639\u0644\u0649 \u0645\u0627 \u064a\u0639\u0627\u062f\u0644\u0647 \u0645\u0646 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0627\u0644\u0631\u0648\u0645\u0627\u0646\u064a\u0629 \u0643\u0633\u0644\u0633\u0644\u0629\u060c \u0648 \u0627\u0631\u062c\u0639\u0647 \u0628\u062d\u0631\u0641 \u0635\u063a\u064a\u0631. \u0627\u0644\u0642\u064a\u0648\u062f: 1 <= num <= 1000.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Berilgan satrning qaytarish uzunligi\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Sizga raqamlar ro'yxati berilgan. Siz berilgan ro'yxatdagi kvadratdagi raqamlar yig'indisini qaytarishingiz kerak, ro'yxatdagi har bir elementni birinchi navbatda yuqoriga aylantiring. Misollar: lst = [1,2,3] uchun chiqish 14 bo'lishi kerak lst = [1,4,9] uchun chiqish 98 bo'lishi kerak lst = [1,3,5,7] uchun chiqish 84 bo'lishi kerak lst = [1.4,4.2,0] uchun chiqish 29 bo'lishi kerak lst = [-2.4,1,1] uchun chiqish 6 bo'lishi kerak\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Vazifa Qatlamni kirish sifatida qabul qiladigan va faqat yuqori belgilar yig'indisini ASCII kodlari sifatida qaytaradigan funksiya yozish. Misol: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    N \u0c35\u0c30\u0c41\u0c38\u0c32\u0c41 \u0c2e\u0c30\u0c3f\u0c2f\u0c41 N \u0c28\u0c3f\u0c32\u0c41\u0c35\u0c41 \u0c35\u0c30\u0c41\u0c38\u0c32\u0c41 (N >= 2) \u0c2e\u0c30\u0c3f\u0c2f\u0c41 \u0c38\u0c3e\u0c28\u0c41\u0c15\u0c42\u0c32 \u0c2a\u0c42\u0c30\u0c4d\u0c23\u0c3e\u0c02\u0c15\u0c02 k \u0c09\u0c28\u0c4d\u0c28 \u0c17\u0c4d\u0c30\u0c3f\u0c21\u0c4d\u0c32\u0c4b, \u0c17\u0c4d\u0c30\u0c3f\u0c21\u0c4d \u0c2f\u0c4a\u0c15\u0c4d\u0c15 \u0c2a\u0c4d\u0c30\u0c24\u0c3f \u0c38\u0c46\u0c32\u0c4d \u0c12\u0c15 \u0c35\u0c3f\u0c32\u0c41\u0c35\u0c28\u0c41 \u0c15\u0c32\u0c3f\u0c17\u0c3f \u0c09\u0c02\u0c1f\u0c41\u0c02\u0c26\u0c3f. [1, N * N] \u0c2a\u0c30\u0c3f\u0c27\u0c3f\u0c32\u0c4b\u0c28\u0c3f \u0c2a\u0c4d\u0c30\u0c24\u0c3f \u0c2a\u0c42\u0c30\u0c4d\u0c23\u0c3e\u0c02\u0c15\u0c02 \u0c17\u0c4d\u0c30\u0c3f\u0c21\u0c4d \u0c2f\u0c4a\u0c15\u0c4d\u0c15 \u0c15\u0c23\u0c3e\u0c32\u0c32\u0c4b \u0c38\u0c30\u0c3f\u0c17\u0c4d\u0c17\u0c3e \u0c12\u0c15\u0c38\u0c3e\u0c30\u0c3f \u0c15\u0c28\u0c3f\u0c2a\u0c3f\u0c38\u0c4d\u0c24\u0c41\u0c02\u0c26\u0c3f. \u0c2e\u0c40\u0c30\u0c41 \u0c17\u0c4d\u0c30\u0c3f\u0c21\u0c4d\u0c32\u0c4b \u0c2a\u0c4a\u0c21\u0c35\u0c41 k \u0c2f\u0c4a\u0c15\u0c4d\u0c15 \u0c15\u0c28\u0c40\u0c38 \u0c2e\u0c3e\u0c30\u0c4d\u0c17\u0c3e\u0c28\u0c4d\u0c28\u0c3f \u0c15\u0c28\u0c41\u0c17\u0c4a\u0c28\u0c3e\u0c32\u0c3f. \u0c2e\u0c40\u0c30\u0c41 \u0c0f\u0c26\u0c48\u0c28\u0c3e \u0c38\u0c46\u0c32\u0c4d \u0c28\u0c41\u0c02\u0c21\u0c3f \u0c2a\u0c4d\u0c30\u0c3e\u0c30\u0c02\u0c2d\u0c3f\u0c02\u0c1a\u0c35\u0c1a\u0c4d\u0c1a\u0c41 \u0c2e\u0c30\u0c3f\u0c2f\u0c41 \u0c2a\u0c4d\u0c30\u0c24\u0c3f \u0c26\u0c36\u0c32\u0c4b \u0c2e\u0c40\u0c30\u0c41 \u0c2a\u0c4a\u0c30\u0c41\u0c17\u0c41 \u0c15\u0c23\u0c3e\u0c32\u0c32\u0c4b \u0c26\u0c47\u0c28\u0c3f\u0c28\u0c48\u0c28\u0c3e \u0c24\u0c30\u0c32\u0c3f\u0c02\u0c1a\u0c35\u0c1a\u0c4d\u0c1a\u0c41, \u0c2e\u0c30\u0c4b \u0c2e\u0c3e\u0c1f\u0c32\u0c4b \u0c1a\u0c46\u0c2a\u0c4d\u0c2a\u0c3e\u0c32\u0c02\u0c1f\u0c47, \u0c2e\u0c40\u0c30\u0c41 \u0c2a\u0c4d\u0c30\u0c38\u0c4d\u0c24\u0c41\u0c24 \u0c38\u0c46\u0c32\u0c4d\u0c24\u0c4b \u0c05\u0c02\u0c1a\u0c41\u0c28\u0c41 \u0c2a\u0c02\u0c1a\u0c41\u0c15\u0c41\u0c28\u0c47 \u0c15\u0c23\u0c3e\u0c32\u0c15\u0c41 \u0c35\u0c46\u0c33\u0c4d\u0c33\u0c35\u0c1a\u0c4d\u0c1a\u0c41. \u0c26\u0c2f\u0c1a\u0c47\u0c38\u0c3f k \u0c2a\u0c4a\u0c21\u0c35\u0c41 \u0c2f\u0c4a\u0c15\u0c4d\u0c15 \u0c2e\u0c3e\u0c30\u0c4d\u0c17\u0c02 \u0c05\u0c02\u0c1f\u0c47 k \u0c15\u0c23\u0c3e\u0c32\u0c28\u0c41 (\u0c24\u0c2a\u0c4d\u0c2a\u0c28\u0c3f\u0c38\u0c30\u0c3f\u0c17\u0c3e \u0c2d\u0c3f\u0c28\u0c4d\u0c28\u0c02\u0c17\u0c3e \u0c09\u0c02\u0c21\u0c15\u0c42\u0c21\u0c26\u0c41) \u0c38\u0c02\u0c26\u0c30\u0c4d\u0c36\u0c3f\u0c02\u0c1a\u0c21\u0c02 \u0c05\u0c28\u0c3f \u0c17\u0c2e\u0c28\u0c3f\u0c02\u0c1a\u0c02\u0c21\u0c3f. \u0c2e\u0c40\u0c30\u0c41 \u0c17\u0c4d\u0c30\u0c3f\u0c21\u0c4d \u0c28\u0c41\u0c02\u0c21\u0c3f \u0c2c\u0c2f\u0c1f\u0c2a\u0c21\u0c32\u0c47\u0c30\u0c41. A \u0c2e\u0c3e\u0c30\u0c4d\u0c17\u0c02 (\u0c2a\u0c4a\u0c21\u0c35\u0c41 k) A \u0c2e\u0c30\u0c3f\u0c2f\u0c41 B \u0c26\u0c4d\u0c35\u0c3e\u0c30\u0c3e \u0c35\u0c46\u0c33\u0c4d\u0c33\u0c47 \u0c15\u0c23\u0c3e\u0c32 \u0c35\u0c3f\u0c32\u0c41\u0c35\u0c32 \u0c15\u0c4d\u0c30\u0c2e\u0c3e\u0c28\u0c41\u0c32 \u0c1c\u0c3e\u0c2c\u0c3f\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 \u0c38\u0c02\u0c16\u0c4d\u0c2f\u0c32 \u0c15\u0c4d\u0c30\u0c2e\u0c02 \u0c05\u0c28\u0c47\u0c26\u0c3f \u0c2b\u0c3f\u0c2c\u0c4a\u0c28\u0c3e\u0c1a\u0c3f \u0c15\u0c4d\u0c30\u0c2e\u0c02 \u0c2e\u0c3e\u0c26\u0c3f\u0c30\u0c3f\u0c17\u0c3e\u0c28\u0c47 \u0c09\u0c02\u0c1f\u0c41\u0c02\u0c26\u0c3f, \u0c07\u0c26\u0c3f \u0c08 \u0c15\u0c4d\u0c30\u0c3f\u0c02\u0c26\u0c3f \u0c35\u0c3f\u0c27\u0c02\u0c17\u0c3e \u0c28\u0c3f\u0c30\u0c4d\u0c35\u0c1a\u0c3f\u0c02\u0c1a\u0c2c\u0c21\u0c3f\u0c02\u0c26\u0c3f\u0c03 fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \u0c26\u0c2f\u0c1a\u0c47\u0c38\u0c3f fib4 \u0c38\u0c02\u0c16\u0c4d\u0c2f\u0c32 \u0c15\u0c4d\u0c30\u0c2e\u0c02 \u0c2f\u0c4a\u0c15\u0c4d\u0c15 n-\u0c35 \u0c2e\u0c42\u0c32\u0c15\u0c3e\u0c28\u0c4d\u0c28\u0c3f \u0c38\u0c2e\u0c30\u0c4d\u0c25\u0c35\u0c02\u0c24\u0c02\u0c17\u0c3e \u0c32\u0c46\u0c15\u0c4d\u0c15\u0c3f\u0c02\u0c1a\u0c21\u0c3e\u0c28\u0c3f\u0c15\u0c3f \u0c12\u0c15 \u0c2b\u0c02\u0c15\u0c4d\u0c37\u0c28\u0c4d\u0c28\u0c41 \u0c35\u0c4d\u0c30\u0c3e\u0c2f\u0c02\u0c21\u0c3f. \u0c2a\u0c41\u0c28\u0c30\u0c3e\u0c35\u0c43\u0c24 \u0c09\u0c2a\u0c2f\u0c4b\u0c17\u0c3f\u0c02\u0c1a\u0c35\u0c26\u0c4d\u0c26\u0c41.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \u0645\u062f\u062e\u0644 \u0644\u0647\u0630\u0647 \u0627\u0644\u0648\u0638\u064a\u0641\u0629 \u0647\u0648 \u0633\u0644\u0633\u0644\u0629 \u062a\u0645\u062b\u0644 \u0627\u0644\u0645\u0644\u0627\u062d\u0638\u0627\u062a \u0627\u0644\u0645\u0648\u0633\u064a\u0642\u064a\u0629 \u0641\u064a \u0634\u0643\u0644 ASCII \u062e\u0627\u0635. \u0645\u0647\u0645\u062a\u0643 \u0647\u064a \u062a\u062d\u0644\u064a\u0644 \u0647\u0630\u0647 \u0627\u0644\u0633\u0644\u0633\u0644\u0629 \u0648\u0625\u0631\u062c\u0627\u0639 \u0642\u0627\u0626\u0645\u0629 \u0628\u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629 \u0627\u0644\u0645\u0642\u0627\u0628\u0644\u0629 \u0644\u0639\u062f\u062f \u0627\u0644\u0636\u0631\u0628\u0627\u062a \u0627\u0644\u062a\u064a \u0644\u0627 \u062a\u0633\u062a\u0645\u0631 \u0643\u0644 \u0648\u0627\u062d\u062f\u0629. \u0647\u0627 \u0647\u064a \u0623\u0633\u0637\u0648\u0631\u0629: 'o' - \u0645\u0644\u0627\u062d\u0638\u0629 \u0643\u0627\u0645\u0644\u0629\u060c \u062a\u0633\u062a\u0645\u0631 \u0623\u0631\u0628\u0639 \u0636\u0631\u0628\u0627\u062a 'o\" - \u0646\u0635\u0641 \u0645\u0644\u0627\u062d\u0638\u0629\u060c \u062a\u0633\u062a\u0645\u0631 \u0636\u0631\u0628\u062a\u064a\u0646 '. \" \" - \u0645\u0644\u0627\u062d\u0638\u0629 \u0631\u0628\u0627\u0639\u064a\u0629\u060c \u062a\u0633\u062a\u0645\u0631 \u0636\u0631\u0628\u0629 \u0648\u0627\u062d\u062f\u0629\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"\u0628\u064a\u0639\u0637\u064a\u0643 \u0641\u062a\u0631\u062a\u064a\u0646\u060c \u062d\u064a\u062b \u0643\u0644 \u0641\u062a\u0631\u0629 \u0632\u0648\u062c \u0645\u0646 \u0627\u0644\u0623\u0639\u062f\u0627\u062f \u0627\u0644\u0635\u062d\u064a\u062d\u0629. \u0639\u0644\u0649 \u0633\u0628\u064a\u0644 \u0627\u0644\u0645\u062b\u0627\u0644\u060c \u0641\u062a\u0631\u0629 = (\u0628\u062f\u0627\u064a\u0629\u060c \u0646\u0647\u0627\u064a\u0629) = (1, 2). \u0641\u062a\u0631\u0627\u062a \u0645\u0639\u0637\u0627\u0629 \u0645\u063a\u0644\u0642\u0629\u060c \u0645\u0645\u0627 \u064a\u0639\u0646\u064a \u0623\u0646 \u0627\u0644\u0641\u0627\u0635\u0644 (\u0628\u062f\u0627\u064a\u0629\u060c \u0646\u0647\u0627\u064a\u0629) \u064a\u0634\u0645\u0644 \u0643\u0644 \u0645\u0646 \u0628\u062f\u0627\u064a\u0629 \u0648\u0646\u0647\u0627\u064a\u0629. \u0644\u0643\u0644 \u0641\u062a\u0631\u0629 \u0645\u0639\u0637\u0627\u0629\u060c \u064a\u0641\u062a\u0631\u0636 \u0623\u0646 \u0628\u062f\u0627\u064a\u062a\u0647\u0627 \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u062a\u0633\u0627\u0648\u064a \u0646\u0647\u0627\u064a\u062a\u0647\u0627. \u0645\u0647\u0645\u062a\u0643 \u0647\u064a \u062a\u062d\u062f\u064a\u062f \u0645\u0627 \u0625\u0630\u0627 \u0643\u0627\u0646 \u0637\u0648\u0644 \u062a\u0642\u0627\u0637\u0639 \u0647\u0630\u0647 \u0627\u0644\u0641\u062a\u0631\u062a\u064a\u0646 \u0647\u0648 \u0631\u0642\u0645 \u0623\u0648\u0644\u064a. \u0645\u062b\u0644\u0627\u060c \u062a\u0642\u0627\u0637\u0639 \u0627\u0644\u0641\u062a\u0631\u0627\u062a (1, 3), (2, 4) \u0647\u0648 (2, 3) \u0627\u0644\u0630\u064a \u0637\u0648\u0644\u0647 \u0647\u0648 1\u060c \u0648\u0627\u0644\u0630\u064a \u0644\u064a\u0633 \u0631\u0642\u0645 \u0623\u0648\u0644\u064a. \u0625\u0630\u0627 \u0643\u0627\u0646 \u0637\u0648\u0644 \u0627\u0644\u062a\u0642\u0627\u0637\u0639 \u0647\u0648 \u0631\u0642\u0645 \u0623\u0648\u0644\u064a\u060c \u0623\u0639\u064a\u062f \"\u0646\u0639\u0645\"\u060c \u0648\u0625\u0644\u0627 \u0623\u0639\u064a\u062f \"\u0644\u0627\". \u0625\u0630\u0627 \u0643\u0627\u0646\u062a \u0627\u0644\u0641\u062a\u0631\u062a\u064a\u0646 \u0644\u0627 \u062a\u062a\u0642\u0627\u0637\u0639\u060c \u0623\u0639\u064a\u062f \"\u0644\u0627\". [input\/output] \u0639\u064a\u0646\u0627\u062a: \u062a\u0642\u0627\u0637\u0639 (((1\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Nang hpe n hte m ngu ai positive integer lahkawng jaw da ai, nang galaw ra ai gaw n kaw nna m (n hte m lawm ai) du hkra na integer ni a average hpe sawn yu na matu re. mahtai hpe n-tsa na integer hte grup ya nna binary de gale la u. n gaw m hta grau kaba ai nga yang, -1. hpe bai jaw u. Ga shadawn: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" 0 kaw na n du hkra, space-delimited number ni lawm ai string hpe bai jaw dat ai.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Dai hta, shawng na ga si ni lawm ai ga si ni hpe bai jaw ra ai. Ga si ni a hkringdat gaw shawng na ga si hte maren rai ra ai. Ga shadawn1: Input: ga si = \"This is a test\" Output: \"is\" Ga shadawn2: Input: ga si = \"let go for swimming\" Output: \"go for\" Constraints: * 1 <= len(sentence) <= 100 * ga si hta laika sha lawm ai\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Na przik\u0142\u014fd: count_upper{\\displaystyle \\mathbb {a} }\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Wyk\u014fzuje, eli dany wiersz je palindr\u014dm\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Stworz funkcyjo, co zwr\u014dci nojwiynkszy indeks elymentu, co niy je srogszy ani r\u014dwny elymentowi, co je bezpostrzednio przed nim. Je\u017ali taki elymynt niy istniyje, zwr\u014d\u0107 -1. Dano maszyna niy bydzie zawiyra\u0107 duplikowanych wert\u014dw. Przik\u0142ady: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    Mae pairs_sum_to_zero yn cymryd rhestr o integers fel mewnbwn. mae'n dychwelyd True os oes dau elfen wahanol yn y rhestr sy'n cyfanswm i sero, ac False fel arall.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Mae'r ffurflen hon yn dangos y swyddogaeth a fydd yn cael ei ddefnyddio i adfer y swyddogaeth.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    Mae triples_sum_to_zero yn cymryd rhestr o integers fel mewnbwn. mae'n dychwelyd True os oes tair elfen wahanol yn y rhestr sy'n cyfanswm i sero, ac False fel arall.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" El provizita listo de nombroj (de longo almena\u016d du) elektu kaj redonu du, kiuj estas la plej proksimaj unu al la alia kaj redonu ilin en ordo (pli malgranda nombro, pli granda nombro).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Skribu funkcion kiu prenas aron da nombroj kiel eniga\u0135on kaj redonas la nombron da elementoj en la aro, kiuj estas pli grandaj ol 10 kaj amba\u016d unua kaj lastaj ciferoj de nombro estas neparaj (1, 3, 5, 7, 9). Ekzemple: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Redonu 2^n modulo p (konsilas pri numerikoj).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"\u12a3\u1265 \u12dd\u122d\u12dd\u122d \u12dd\u1270\u1218\u12f0\u1261 \u134d\u1209\u12eb\u1275 \u1263\u12a5\u1273\u1273\u1275 \u12ed\u1218\u120d\u1235\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u12ab\u1265 1 \u12ad\u1233\u1265 n \u12d8\u120e \u1241\u133d\u122a\u1273\u1275 \u12dd\u12a5\u12ad\u1265 \u1270\u130d\u1263\u122d \u12a5\u12e9\u1362\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \u1295\u1293\u12ed \u1352\u1276\u1295 \u12cb\u130b\u1273\u1275 \u12dd\u1270\u12cb\u1205\u1260 \u12dd\u122d\u12dd\u122d \u1295\u1293\u12ed \u121d\u1209\u12a5 \u1241\u133d\u122a \u1325\u122b\u12ed \u134d\u120a\u1270\u122d \u130d\u1260\u122d\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0915\u0947 \u090f\u0915 \u0926\u093f\u090f \u0917\u090f \u0938\u0942\u091a\u0940 \u092c\u0930, \u090f\u0915 \u0938\u0942\u091a\u0940 \u092e\u0947\u0902 \u091c\u092e\u094d\u092e\u094b \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0915\u0947 \u092f\u094b\u0917 \u0905\u0909 \u0909\u0924\u094d\u092a\u093e\u0926 \u0932\u0947 \u092f\u0941\u0915\u094d\u0924 \u090f\u0915 \u091f\u094d\u092f\u0942\u092a\u0932 \u0932\u094c\u091f\u093e\u090f\u0902\u0964 \u0916\u093e\u0932\u0940 \u092f\u094b\u0917 0 \u0915\u0947 \u092c\u0930\u093e\u092c\u0930 \u0939\u094b\u0928\u093e \u091a\u093e\u0939\u093f \u0905\u0909 \u0916\u093e\u0932\u0940 \u0909\u0924\u094d\u092a\u093e\u0926 1 \u0915\u0947 \u092c\u0930\u093e\u092c\u0930 \u0939\u094b\u0928\u093e \u091a\u093e\u0939\u093f\u0964\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u0926\u094b \u0938\u0902\u0916\u094d\u092f\u093e\u0913\u0902 \u0915\u0947 \u091c\u094b\u0921\u093c\u0947\u0902, \u090f\u0915\u094d\u0938 \u0905\u0909 \u0935\u093e\u0908\u0964\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Ampidiro ny isa \"delimeter\" eo anelanelan'ny singa roa misesy amin'ny lisitry ny fidirana \u2200numbers\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Na c\u00ef nimirai c\u00ef g\u00e4m nimirai ye c\u0254la positive floating point, ka l\u00ebu b\u00ef ya t\u025b\u0308\u025b\u0308k yiic ku b\u00ef ya nimirai ab\u025b\u0308n (n\u00efn d\u00eft d\u00eft ye nimirai kor t\u00ebn\u00eb nimirai c\u00ef g\u00e4m) ku j\u0254l ya nimirai ke decimal (n\u00efn c\u00ef d\u00f6\u014b aye nimirai kor t\u00ebn\u00eb 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Y\u00efn ac\u00ef w\u00ebl kaa 2 g\u00e4m. Y\u00efn adhil ba w\u025b\u0308t c\u0254l True dhuk t\u025b\u0308 le w\u025b\u0308t d\u025b\u0308t ye rou wala w\u025b\u0308t d\u025b\u0308t ye rot waar th\u00efn ye substring n\u00eb w\u025b\u0308t tue\u014b cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"\u062f \u0641\u0628\u0648\u0646\u0627\u06a9\u064a \u0633\u0644\u0633\u0644\u0647 \u0647\u0631 \u0685\u0648\u06a9 \u067e\u06d0\u0698\u0646\u064a\u060c \u067e\u0647 \u062a\u06d0\u0631\u0648 \u0685\u0648 \u067e\u06d0\u0693\u064a\u0648 \u06a9\u06d0 \u062f \u0631\u064a\u0627\u0636\u064a \u067e\u0648\u0647\u0627\u0646\u0648 \u0644\u0647 \u062e\u0648\u0627 \u067e\u0647 \u0698\u0648\u0631\u0647 \u062a\u0648\u06ab\u0647 \u0645\u0637\u0627\u0644\u0639\u0647 \u0634\u0648\u06d0 \u062f\u0647. \u062e\u0648 \u0647\u063a\u0647 \u0685\u0647 \u0686\u06d0 \u062e\u0644\u06a9 \u0646\u0647 \u067e\u0648\u0647\u06d0\u0696\u064a \u062f \u067c\u0631\u0628\u0648\u0646\u0627\u06a9\u064a \u0633\u0644\u0633\u0644\u0647 \u062f\u0647. \u062f \u067c\u0631\u0628\u0648\u0646\u0627\u06a9\u064a \u0633\u0644\u0633\u0644\u0647 \u062f \u062a\u06a9\u0631\u0627\u0631 \u0644\u0647 \u0645\u062e\u06d0 \u062a\u0639\u0631\u06cc\u0641 \u0634\u0648\u06d0 \u062f\u0647: tri(1) = 3 tri(n) = 1 + n \/ 2\u060c \u06a9\u0647 n \u062c\u0648\u0693\u0647 \u0648\u064a. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) \u060c \u06a9\u0647 n \u0639\u062c\u06cc\u0628 \u0648\u064a. \u062f \u0628\u06d0\u0644\u06ab\u06d0 \u067e\u0647 \u062a\u0648\u06ab\u0647: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 \u062a\u0627\u0633\u0648 \u062a\u0647 \u06cc\u0648 \u063a\u06cc\u0631 \u0645\u0646\u0641\u064a \u0639\u062f\u062f \u062f\u0631\u06a9\u0693\u0644 \u0634\u0648\u06cc \u062f\u06cc\u060c \u062a\u0627\u0633\u0648 \u0628\u0627\u06cc\u062f \u062f \u067c\u0631\u0628\u0648\u0646\u0627\u06a9\u064a \u0633\u0644\u0633\u0644\u0647 \u062f \u0644\u0648\u0645\u0693\u064a n + 1 \u0634\u0645\u06cc\u0631\u0648\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"\u062f n \u062a\u0631 \u067c\u0648\u0644\u0648 \u0644\u0648\u06cc \u0644\u0648\u0645\u0693\u0646\u06cc \u0641\u0627\u06a9\u062a\u0648\u0631 \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0648\u0626. \u0641\u0631\u0636 \u06a9\u0693\u0626 n > 1 \u0627\u0648 \u0644\u0648\u0645\u0693\u0646\u06cc \u0646\u0647 \u062f\u06cc.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"\u062a\u0627\u0633\u0648 \u062a\u0647 \u062f\u0648\u0647 \u0645\u062b\u0628\u062a \u0639\u062f\u062f\u0648\u0646\u0647 n \u0627\u0648 m \u062f\u0631\u06a9\u0648\u0644 \u0634\u0648\u064a \u062f\u064a\u060c \u0627\u0648 \u0633\u062a\u0627\u0633\u0648 \u062f\u0646\u062f\u0647 \u062f\u0627 \u062f\u0647 \u0686\u06d0 \u062f n \u0685\u062e\u0647 \u062a\u0631 m \u067e\u0648\u0631\u06d0 \u062f \u0639\u062f\u062f\u0648\u0646\u0648 \u0645\u0646\u0681\u0646\u06cd \u0634\u0645\u06d0\u0631\u0647 \u0645\u062d\u0627\u0633\u0628\u0647 \u06a9\u0693\u0626 (\u067e\u0647 \u0634\u0645\u0648\u0644 \u062f n \u0627\u0648 m). \u0681\u0648\u0627\u0628 \u062a\u0647 \u0646\u0696\u062f\u06d0 \u0628\u0634\u067e\u0693 \u0639\u062f\u062f \u062a\u0647 \u0631\u0627\u067c\u0648\u0644 \u06a9\u0693\u0626 \u0627\u0648 \u062f\u0627 \u062f\u0648\u0647 \u06ab\u0648\u0646\u06cc \u062a\u0647 \u0648\u0627\u0693\u0648\u0626. \u06a9\u0647 n \u0644\u0647 m \u0685\u062e\u0647 \u0644\u0648\u06cc \u0648\u064a\u060c \u0628\u06cc\u0631\u062a\u0647 \u0631\u0627\u06ab\u0631\u0681\u0626 -1. \u0645\u062b\u0627\u0644: rounded_avg (((1, 5) => \"0b11\" rounded_avg (((7, 5) => -1 rounded_avg (((10, 20) => \"0b1111\" rounded_avg (((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Gushiraho imikorere igarura indangagaciro nini ya element itari nini cyangwa ingana nigitekerezo kibanziriza. Niba nta kintu nkiki kibaho noneho gusubiza -1. Urutonde rutanga ntiruzagira indangagaciro zikwiranye. Ingero: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Ufite urutonde rw'imibare yose arr n'umubare wose k, subiza umubare w'ibiranga bifite imibare ibiri y'ibanze k y'ibiranga arr. Urugero: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # hamwe na 21 + 3 Impaka: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Gutanga umubare wuzuye N, kugarura umubare w'imibare yose mu mibare ibiri. Urugero Kuri N = 1000, umubare w'imibare uzaba ari 1 umusaruro ugomba kuba \"1\". Kuri N = 150, umubare w'imibare uzaba ari 6 umusaruro ugomba kuba \"110\". Kuri N = 147, umubare w'imibare uzaba ari 12 umusaruro ugomba kuba \"1100\". Ibihinduka: @N integer Imirongo: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. Umusaruro: urutonde rw'imibare ibiri\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Verifica se la stringa data l'\u00e8 un palindrom\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    A l'\u00e8 na ipotesi matematega che la riguarda na sequenza definida in manera seguenta: cuminci\u00e0 con on quai intrega pusitiva n. Alura ogni t\u00e8rm l'\u00e8 ciappaa del t\u00e8rm precedent in manera seguenta: se el t\u00e8rm precedent l'\u00e8 pari, el t\u00e8rm proscimo l'\u00e8 la met\u00e0 del t\u00e8rm precedent. Se el t\u00e8rm precedent l'\u00e8 dispari, el t\u00e8rm proscimo l'\u00e8 3 volt el t\u00e8rm precedent plus 1.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Per un dato n\u00f9mer n, trova el n\u00f9mer pi\u00f6 gr\u00e0n che divid n in manera ugualit\u00e0la, pi\u00f6 pic\u00ecn de n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Lamba count_numsbe ruwoz\u0259na lamba hayyabe shidonyi lamba samiyed\u0259 0 lan. Lamba la'ar ba, daji shi lamba buro salakbe shiro lamba ruwot\u0259be gultinmad\u0259 shima lamba wofilabe wofila: misallo -123be lamba ruwot\u0259be -1, 2, kuru 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Awowa gade-gade loktuwa indi ro yikkolt\u01ddg\u01ddnad\u01ddga walt\u01ddg\u01dd.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Lambawa lambabe gojin kuru lamba 10 lan koz\u0259nama kuru lamba burobe-a darebe-a lamba ganama (1, 3, 5, 7, 9). Misallo: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib gr\u0105\u017eina n-\u0105j\u012f skai\u010di\u0173, kuris yra Fibona\u010di skai\u010dius ir jis taip pat yra pirminis.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Jums duoti 2 \u017eod\u017eiai. Jums reikia gr\u0105\u017einti True, jei antrasis \u017eodis arba bet kuris jo sukimas yra pirmojo \u017eod\u017eio substring cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Gr\u0105\u017eina tam tikro sveiko skai\u010diaus pirmini\u0173 veiksni\u0173 s\u0105ra\u0161\u0105 nuo ma\u017eiausio iki did\u017eiausio. Kiekvienas veiksnys turi b\u016bti i\u0161vardytas tiek kart\u0173, kiek jis yra skai\u010diuojamas. \u012evesties skai\u010dius turi b\u016bti lygus vis\u0173 veiksni\u0173 gabaliui.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Dicaliak dari grid jo N baris jo N kolom (N >= 2) dan sabuah bilangan bulat positif k, satiok sel dalam grid ko manganduang suatu nilai. Satiok bilangan bulat dalam range [1, N * N] tamasuak ado ciek nilai nan tampak di sel-sel dalam grid. Sanak harus mancari jalan minimal panjang k dalam grid. Sanak dapek mamulai dari sel apo pun, jo di satiok langkah Sanak dapek pindah ka sel-sel tatangga, jo kato lain Sanak dapek manuju sel-sel nan samo pinggir jo sel Sanak. Sanak paralu maingek baso jalan panjang k artinyo manunjuak persis k sel (indak paralu jaleh). Sanak BANTUA maingek dari grid. Satiok jalan A (panjang k) dianggap labiah ketek dari jalan B (panjang k) jikok sasudah mambuek daftar nilai nan diurutkan pado sel-sel nan A jo B (biar\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Dibari suatu bilangan bulat positif n, baliakkan sabuah tuple nan mamiliki jumlah palindrom bilangan bulat ganjil jo genap nan tagolong dalam rentang ((1, n), tamasuak. Contoh1: Input: 3 Output: (1, 2) Penjelasan: Palindrom bilangan bulat adolah 1, 2, 3. salah satu daripadonyo ganjil, dan duo di antaronyo ganjil. Contoh2: Input: 12 Output: (4, 6) Penjelasan: Palindrom bilangan bulat adolah 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. ampek di antaronyo ganjil, dan 6 di antaronyo ganjil. Catatan: 1. 1 <= n <= 10^3 2. tuple baliakkan jumlah palindrom bilangan bulat ganjil jo genap.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Diaratian suatu bilangan bulat positif n, baliakkan jumlah bilangan bulat positif n-angka nan dimulai atau diakhiri jo 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Nda tu kuete olonduko vivali via velapo, tu sukila oku soneha olonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolonduko vi soka lolond\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Nda tua sanga etendelo limue ka li kuete atendelo osi, tu sukila oku pitulula etendelo liolo atendelo osi a sangiwa ketendelo liatete.\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"\u0905\u0917\u0930 \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u0938\u0902\u0916\u094d\u092f\u093e \u0905\u092d\u093e\u091c\u094d\u092f \u092c\u093e \u0924 \u0938\u0939\u0940 \u0932\u094c\u091f\u093e\u0908 \u0906\u0909\u0930 \u0905\u0917\u0930 \u0928\u093e \u0924 \u0917\u0932\u0924.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero \u0907\u0928\u092a\u0941\u091f \u0915\u0947 \u0930\u0942\u092a \u092e\u0947\u0902 \u092a\u0942\u0930\u094d\u0923\u093e\u0902\u0915 \u0915\u0947 \u090f\u0917\u094b \u0938\u0942\u091a\u0940 \u0932\u0947\u0932\u093e. \u0905\u0917\u0930 \u0938\u0942\u091a\u0940 \u092e\u0947\u0902 \u0926\u0942 \u0917\u094b \u0905\u0932\u0917-\u0905\u0932\u0917 \u0924\u0924\u094d\u0935 \u092c\u093e \u091c\u0947 \u0915\u0947 \u092f\u094b\u0917 \u0936\u0942\u0928\u094d\u092f \u092c\u093e \u0924 \u0907 \u0938\u0939\u0940 \u0932\u094c\u091f\u093e\u0935\u0947\u0932\u093e, \u0906\u0909\u0930 \u0905\u0917\u0930 \u0928\u093e\u0939\u0940\u0902 \u0924 \u0917\u0932\u0924.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"\u0906\u092a \u0915\u0947 2 \u0936\u092c\u094d\u0926 \u0926\u093f\u0939\u0932 \u0917\u0907\u0932 \u092c\u093e. \u0906\u092a \u0915\u0947 \u0938\u0939\u0940 \u0932\u094c\u091f\u093e\u0935\u0947 \u0915\u0947 \u092c\u093e \u0905\u0917\u0930 \u0926\u0942\u0938\u0930\u093e \u0936\u092c\u094d\u0926 \u092f\u093e \u090f\u0915\u0930 \u0915\u094c\u0928\u094b \u092d\u0940 \u0918\u0942\u0930\u094d\u0923\u0928 \u092a\u0939\u093f\u0932\u093e \u0936\u092c\u094d\u0926 \u092e\u0947\u0902 \u090f\u0917\u094b \u0938\u092c\u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u092c\u093e cycpattern_check(\"abcd\",\"abd\") => \u0917\u0932\u0924 cycpattern_check(\"hello\",\"ell\") => \u0938\u0939\u0940 cycpattern_check(\"whassup\",\"psus\") => \u0917\u0932\u0924 cycpattern_check\"abab\",\"baa\") => \u0938\u0939\u0940 cycpattern_check\"(\"efef\",\"eeff\") => \u0917\u0932\u0924 cycpattern_check\"(hims\",\"simen\") => \u0938\u0939\u0940\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Je v\u00e1m d\u00e1n seznam \u010d\u00edsel. Mus\u00edte vr\u00e1tit sou\u010det \u010d\u00edsel na druhou v dan\u00e9m seznamu, zaokrouhlit ka\u017ed\u00fd prvek v seznamu na horn\u00ed int (Celkov\u00fd po\u010det) nejprve. P\u0159\u00edklady: Pro lst = [1,2,3] v\u00fdstup by m\u011bl b\u00fdt 14 Pro lst = [1,4,9] v\u00fdstup by m\u011bl b\u00fdt 98 Pro lst = [1,3,5,7] v\u00fdstup by m\u011bl b\u00fdt 84 Pro lst = [1.4,4.2,0] v\u00fdstup by m\u011bl b\u00fdt 29 Pro lst = [-2.4,1,1] v\u00fdstup by m\u011bl b\u00fdt 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Vstupn\u00ed je prostorov\u011b omezen\u00fd \u0159et\u011bzec \u010d\u00edslic od \"nula\" do \"dev\u00edti\". Platn\u00e9 volby jsou \"nula\", \"jeden\", \"dva\", \"t\u0159i\", \"\u010dty\u0159i\", \"p\u011bt\", \"\u0161est\", \"sedm\", \"osm\" a \"dev\u00edti\". Vr\u00e1t\u00ed \u0159et\u011bzec s \u010d\u00edsly zortrou od nejmen\u0161\u00edho po nejv\u011bt\u0161\u00ed\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Pokud je dan\u00fd slovn\u00edk, vr\u00e1t\u00ed True, pokud jsou v\u0161echny kl\u00ed\u010de \u0159et\u011bzce mal\u00fdch p\u00edsmen nebo v\u0161echny kl\u00ed\u010de velk\u00fdch p\u00edsmen, jinak vr\u00e1t\u00ed False. Funkce by m\u011bla vr\u00e1tit False, je-li dan\u00fd slovn\u00edk pr\u00e1zdn\u00fd. P\u0159\u00edklady: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) by m\u011bla vr\u00e1tit True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) by m\u011bla vr\u00e1tit False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) by m\u011bla vr\u00e1tit False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False by m\u011bla vr\u00e1tit check.dict_\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter gjev liste over alle Python verdiar berre for heiltal\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Alle kjenner til Fibonacci-sekvensen, den er blitt studert grundig av matematikarar i dei siste hundre\u00e5ra. Men det folk ikkje kjenner er Tribonacci-sekvensen. Tribonacci-sekvensen er definert av rekurrensa: tri(1) = 3 tri(n) = 1 + n \/ 2, om n er eit partall. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), om n er eit uparallall. Til d\u00f8mes: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Du f\u00e5r eit ikkje-negativt heiltal n, du m\u00e5 returnere ei liste over dei f\u00f8rste n + 1 tala i Tribonacci-sekvensen.\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Returnerer 2^n modulo p (ver klar over tallinmer).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Ke tala kana mutambu ya bo me pesa kele palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    ke vutulaka ntalu ya bisono na kusoba konso kisono na 5 na alfabete.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Na kati ya ngiufula yai, nge ta sadila fongi yina ke baka lisiti ya ntalu zole, mpi ta sosa kuzaba kana yo kele mbote na kusoba ntalu ya ntalu yina kele na kati na yo sambu na kusala lisiti ya ntalu zole mpamba. Kana yo kele mbote na kusoba ntalu ya ntalu yina kele na kati ya lisiti ya ntalu zole, vutula \"EE\". Kana ve vutula \"NE\". Mu mbandu: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"EE\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NE\" Beto ke yindula nde lisiti ya ntalu yina kele na kati ya lisiti ya ntalu zole kele ve ya mpamba.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Cho danh s\u00e1ch c\u00e1c s\u1ed1 (\u00edt nh\u1ea5t hai y\u1ebfu t\u1ed1), \u00e1p d\u1ee5ng m\u1ed9t chuy\u1ec3n \u0111\u1ed5i tuy\u1ebfn t\u00ednh cho danh s\u00e1ch \u0111\u00f3, nh\u01b0 v\u1eady s\u1ed1 nh\u1ecf nh\u1ea5t s\u1ebd tr\u1edf th\u00e0nh 0 v\u00e0 s\u1ed1 l\u1edbn nh\u1ea5t s\u1ebd tr\u1edf th\u00e0nh 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p t\u00ean c\u1ee7a m\u1ed9t l\u1edbp (m\u1ed9t chu\u1ed7i) v\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng. C\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 t\u1ea3i c\u00e1c l\u1edbp b\u1ed5 sung v\u00e0o l\u1edbp. \u0110\u1ed9 m\u1ea1nh c\u1ee7a ph\u1ea7n m\u1edf r\u1ed9ng l\u00e0 nh\u01b0 sau: H\u00e3y \u0111\u1ec3 CAP l\u00e0 s\u1ed1 ch\u1eef c\u00e1i l\u1edbn trong t\u00ean ph\u1ea7n m\u1edf r\u1ed9ng, v\u00e0 h\u00e3y \u0111\u1ec3 SM l\u00e0 s\u1ed1 ch\u1eef c\u00e1i nh\u1ecf trong t\u00ean ph\u1ea7n m\u1edf r\u1ed9ng, \u0111\u1ed9 m\u1ea1nh \u0111\u01b0\u1ee3c cung c\u1ea5p b\u1edfi ph\u00e2n s\u1ed1 CAP - SM. B\u1ea1n n\u00ean t\u00ecm ph\u1ea7n m\u1edf r\u1ed9ng m\u1ea1nh nh\u1ea5t v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i trong \u0111\u1ecbnh d\u1ea1ng n\u00e0y: ClassName.StrongestExtensionName. N\u1ebfu c\u00f3 hai ho\u1eb7c nhi\u1ec1u ph\u1ea7n m\u1edf r\u1ed9ng c\u00f3 c\u00f9ng \u0111\u1ed9 m\u1ea1nh, b\u1ea1n n\u00ean ch\u1ecdn m\u1ed9t trong nh\u1eefng th\u1ee9 xu\u1ea5t hi\u1ec7n \u0111\u1ea7u ti\u00ean trong danh s\u00e1ch. V\u00ed d\u1ee5, n\u1ebfu b\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p \"Slices\" nh\u01b0 l\u00e0 l\u1edbp v\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] sau \u0111\u00f3 b\u1ea1n n\u00ean tr\u1ea3\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng, l\u1ea5y s\u1ed1 La M\u00e3 t\u01b0\u01a1ng \u0111\u01b0\u01a1ng c\u1ee7a n\u00f3 d\u01b0\u1edbi d\u1ea1ng m\u1ed9t chu\u1ed7i, v\u00e0 tr\u1ea3 v\u1ec1 n\u00f3 b\u1eb1ng ch\u1eef c\u00e1i nh\u1ecf.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polinomial karo koefisien xs ing titik x. bali xs[0] + xs[1] * x + xs[1] * x ^ 2 +.... xs[n] * x ^ n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits. Return 0 if all digits are even. Tuladhane: digit (n) == 1 digit (n) == 0 digit (n) == 235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Zingazinga, balongoli ba chiffres ya nombre entier x, balongoli ba chiffres na loboko ya mobali na balongoli mpe bazongisi r\u00e9sultat lokola string. Soki balongoli > motango ya ba chiffres, bazongisi ba chiffres na ndenge ya mabe.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Soki 'text' ezali string ya pamba, bozongisa None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Soki ozwi motango ya positif ya floating point, ekoki ko d\u00e9composer na et\u00e1ngo mobimba (motuya ya monene ya moke koleka motango oyo epesami) mpe na ba d\u00e9cimaux (motuya ya moke koleka 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Go tsenya mo tirong e ke mogala o o emetseng ditlhopha tse dintsi tsa dikgofa tse di kgaogantsweng ke dikgala. Mo setlhopheng sengwe le sengwe, ntsha maemo a a kwa teng a go tsenya dikgofa. Sekao, (() (()) e na le maemo a a kwa godimo a mabedi a go tsenya fa ((())) e na le a le mararo.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Go tsenya mo tirong e ke mogala o o emelang dinoto tsa mmino ka mokgwa o o kgethegileng wa ASCII. Tiro ya gago ke go sekaseka mogala ono le go busetsa lenaane la dipalo tse di feletseng tse di tsamaelanang le palo ya dinoto tse nngwe le nngwe ya tsone e sa tsamayeng.\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" \u062f\u0645\u0627\u0633\u0627\u0762\u064a\u0643\u0646 \u0633\u0648\u0627\u062a\u0648 'delimeter' \u0627\u0646\u062a\u0627\u0631\u0627 \u0633\u062a\u064a\u06a0\u06ac\u0647 \u062f\u0648 \u0627\u0648\u0646\u0633\u0648\u0631 \u0628\u066e\u066e\u064a\u0633\u0646 \u0645\u0627\u0633\u0648\u0643\u0643\u0646 `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"\u0631\u062c\u0648\u0639\u0627\u0646\u0643\u0627 \u0641\u064a\u0628\u0648\u0646\u0627\u062a\u0634\u064a \u0643 \u0646.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    \u0645\u0623\u0631\u064a\u0643\u0627\u0646 \u0625\u0646\u062a\u062c\u0631 \u0646 \u0623\u0646\u060c \u0628\u0627\u0644\u064a\u0643\u0627\u0646 \u062f\u0627\u0641\u062a\u0627\u0631\u0627\u0646 \u064a\u0627\u0646\u063a \u062a\u0644\u0647 \u062f\u064a\u0623\u0648\u0631\u0648\u062a\u0643\u0627\u0646 \u064a\u0627\u0646\u063a \u0645\u0646\u064a\u0627\u0643\u0648\u0628\u0643\u0627\u0646 \u0623\u0646\u0643\u0627-\u0623\u0646\u0643\u0627 \u063a\u0627\u0646\u062c\u0627\u0644 \u062f\u062f\u0644\u0627\u0645 \u0633\u0643\u0648\u064a\u0646\u0633 \u0643\u0648\u0644\u0627\u062a\u0632.\n\n    \u0643\u0648\u0644\u0627\u062a\u0632 \u0643\u0648\u0646\u062c\u0643\u062a\u0631 \u0623\u062f\u0627\u0644\u0647 \u0633\u0648\u0627\u062a\u0648 \u0643\u0648\u0646\u062c\u0643\u062a\u0631 \u062f\u0627\u0644\u0645 \u0645\u0627\u062a\u064a\u0645\u0627\u062a\u0643 \u064a\u0627\u0646\u063a \u0628\u0631\u0643\u0646\u0627\u0639\u0646 \u062f\u0646\u0627\u0646 \u0633\u0643\u0648\u064a\u0646\u0633 \u064a\u0627\u0646\u063a \u062f\u064a\u0641\u064a\u0646\u064a\u0633\u064a\u0643\u0627\u0646\n    \u0633\u0628\u0627\u06af\u064a \u0628\u0631\u0643\u062a: \u0645\u0648\u0644\u0627\u064a \u062f\u0627\u0631\u064a \u0633\u062a\u064a\u0627\u0628 \u0625\u0646\u062a\u062c\u0631 \u0628\u0648\u0633\u064a\u062a\u0641 \u0646. \u0633\u062a\u064a\u0627\u0628 \u062a\u064a\u0631\u0645 \u062f\u064a\u0628\u0631\u0648\u0644\u0647 \u062f\u0627\u0631\u064a \u062a\u064a\u0631\u0645 \u0633\u0628\u0644\u0648\u0645\u0646\u064a \u0633\u0628\u0627\u06af\u064a \u0628\u0631\u0643\u062a:\n    \u062c\u0643\u0627 \u062a\u064a\u0631\u0645 \u0633\u0628\u0644\u0648\u0645\u0646\u064a \u062c\u0646\u0627\u0628\u060c \u062a\u064a\u0631\u0645 \u0628\u0631\u0643\u0648\u062a\u0646\u064a \u0627\u062f\u0627\u0644\u0647 \u0633\u062a\u064a\u0627\u0646\u063a\u0627\u0647 \u062f\u0627\u0631\u064a \u062a\u064a\u0631\u0645 \u0633\u0628\u0644\u0648\u0645\u0646\u064a. \u062c\u0643\u0627 \u062a\u064a\u0631\u0645 \u0633\u0628\u0644\u0648\u0645\u0646\u064a \u063a\u0627\u0646\u062c\u0627\u0644\u060c \u062a\u064a\u0631\u0645\n    \u0628\u0631\u0643\u0648\u062a\u0646\u064a \u0627\u062f\u0627\u0644\u0647 3 \u0643\u0627\u0644\u064a \u062a\u064a\u0631\u0645 \u0633\u0628\u0644\u0648\u0645\u0646\u064a \u062a\u0627\u0645\u0628\u0627 1. \u0643\u0648\u0646\u062c\u0643\u062a\u0631\u0646\u064a \u0623\u062f\u0627\u0644\u0647 \u0628\u0627\u0647\u0648\u0627 \u062a\u064a\u062f\u0627\u0643 \u0645\u0645\u064a\u0643\u064a\u064a\u0631\u0643\u0627\u0646 \u0628\u0631\u0627\u0628\u0627 \u0628\u064a\u0633\u0627\u0631 \u0646\u060c \u0633\u0643\u0648\u064a\u0646\u0633\u0646\u064a\n    \u0623\u0643\u0627\u0646 \u0633\u0644\u0627\u0644\u0648 \u0645\u0646\u062c\u0627\u062f\u064a 1.\n\n    \u0643\u064a\u062a\u0631\u0627\u06a0\u0646:\n        1. \u0643\u0648\u0644\u0627\u062a\u0632 \u0623\u062f\u0627\u0644\u0647 [1].\n        2. \u062f\u0627\u06a4\u062a\u0627\u0631\u0627\u0646 \u064a\u0627\u0646\u063a \u062f\u064a\u0628\u0627\u0644\u0643\u064a\u0646 \u062a\u0644\u0647 \u062f\u064a\u0623\u0648\u0631\u0648\u062a \u062f\u0627\u0644\u0645 \u0623\u0648\u0631\u0648\u062a\u0646 \u0645\u0646\u064a\u0646\u063a\u0643\u062a.\n\n    \u0643\u0648\u0646\u062a\u0648\u0631:\n    get_odd_collatz \u0645\u0646\u062c\u0627\u062f\u064a [1, 5] # \u0643\u0648\u0644\u0627\u062a\u0632 \u0633\u0643\u0648\u064a\u0646\u0633 \u0627\u0646\u062a\u0648\u0643 5 \u0623\u062f\u0627\u0644\u0647 [5, 16, 8, 4, 2, 1], \u062c\u0627\u062f\u064a \u0623\u0646\u0643\u0627-\u0623\u0646\u0643\u0627 \u063a\u0627\u0646\u062c\u0627\u0644 \u0647\u0627\u0646\u064a\u0627 1\u060c \u062f\u0627\u0646 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0442\u0435\u0433\u0438 \u0430\u0440 \u0431\u0438\u0440 \u0442\u0430\u043c\u0433\u0430\u043d\u044b 5\u043a\u0435 \u0436\u044b\u043b\u0434\u044b\u0440\u0443\u0443 \u043c\u0435\u043d\u0435\u043d \u043a\u043e\u0434\u0434\u043e\u043b\u0433\u043e\u043d \u0441\u0430\u043f\u0442\u044b \u043a\u0430\u0439\u0442\u0430\u0440\u0430\u0442.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u0411\u0438\u0440 \u0441\u0430\u043f\u0442\u0430\u043d \u0430\u043b\u044b\u043f, \u0430\u043d\u044b\u043d \u0442\u0430\u0440\u0442\u0438\u043f\u0442\u0435\u0433\u0438 \u0432\u0435\u0440\u0441\u0438\u044f\u0441\u044b\u043d \u043a\u0430\u0439\u0442\u0430\u0440\u044b\u043f \u0431\u0435\u0440\u04af\u04af\u0447\u04af \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0436\u0430\u0437\u044b\u04a3\u044b\u0437. \u0421\u0442\u0440\u043e\u0433\u0434\u0443\u043d \u0442\u0430\u0440\u0442\u0438\u043f\u0442\u0435\u0433\u0438 \u0432\u0435\u0440\u0441\u0438\u044f\u0441\u044b, \u0431\u0430\u0440\u0434\u044b\u043a \u0441\u04e9\u0437\u0434\u04e9\u0440 (\u043a\u043e\u0441\u043c\u043e\u0441 \u043c\u0435\u043d\u0435\u043d \u0431\u04e9\u043b\u04af\u043d\u0433\u04e9\u043d) \u0436\u0430\u04a3\u044b \u0441\u04e9\u0437\u0433\u04e9 \u0430\u043b\u043c\u0430\u0448\u0442\u044b\u0440\u044b\u043b\u0433\u0430\u043d, \u0430\u043d\u0434\u0430 \u0431\u0430\u0440\u0434\u044b\u043a \u0431\u0435\u043b\u0433\u0438\u043b\u0435\u0440 ASCII \u043c\u0430\u0430\u043d\u0438\u0441\u0438\u043d\u0435 \u043d\u0435\u0433\u0438\u0437\u0434\u0435\u043b\u0433\u0435\u043d \u0436\u043e\u0433\u043e\u0440\u0443\u043b\u0430\u0442\u0443\u0443 \u0442\u0430\u0440\u0442\u0438\u0431\u0438\u043d\u0434\u0435 \u0436\u0430\u0439\u0433\u0430\u0448\u0442\u044b\u0440\u044b\u043b\u0433\u0430\u043d. \u042d\u0441\u043a\u0435\u0440\u0442\u04af\u04af: \u0421\u0438\u0437 \u0441\u04af\u0439\u043b\u04e9\u043c\u0434\u04e9\u0433\u04af \u0441\u04e9\u0437\u0434\u04e9\u0440\u0434\u04af\u043d \u0436\u0430\u043d\u0430 \u0431\u043e\u0448 \u043e\u0440\u0443\u043d\u0434\u0430\u0440\u0434\u044b\u043d \u0442\u0430\u0440\u0442\u0438\u0431\u0438\u043d \u0441\u0430\u043a\u0442\u0430\u0448\u044b\u04a3\u044b\u0437 \u043a\u0435\u0440\u0435\u043a. \u041c\u0438\u0441\u0430\u043b\u044b: anti_shuffle ((('Hi') \u043a\u0430\u0439\u0442\u0430\u0440\u0430\u0442 'Hi' anti_shuffle ((('hello') \u043a\u0430\u0439\u0442\u0430\u0440\u0430\u0442 'ehllo' anti_shuffle (('Hello World!!!') \u043a\u0430\u0439\u0442\u0430\u0440\u0430\u0442 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \u0422\u0435\u043a\u0441\u0442\u0442\u0435\u0440\u0434\u0438\u043d \u0442\u0438\u0437\u043c\u0435\u0441\u0438\u043d \u0442\u0435\u043a \u0433\u0430\u043d\u0430 \u0441\u0443\u0431\u0442\u0435\u043a\u0441\u0442\u0442\u0435\u0440\u0434\u0438\u043d \u0442\u0438\u0437\u043c\u0435\u0441\u0438 \u043c\u0435\u043d\u0435\u043d \u0447\u044b\u043f\u043a\u0430\u043b\u043e\u043e\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Jums ir sniegts vienkopus skait\u013cu saraksts. Sakiet funkciju next_smallest(), kas atdod 2. maz\u0101ko elementu sarakst\u0101. Atdod NULL, ja t\u0101ds elements nav. next_smallest([1, 2, 3, 4, 5]) == 2 next_smallest([5, 1, 4, 3, 2]) == 2 next_smallest([]) == NULL next_smallest([1, 1]) == NULL\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Jums tiek sniegts bankas konta noguld\u012bjumu un iz\u0146em\u0161anas oper\u0101ciju saraksts, kas s\u0101kas ar nulles bilanci. J\u016bsu uzdevums ir atkl\u0101t, vai jebkur\u0101 br\u012bd\u012b konta bilances l\u012bmenis ir zem nulles, un \u0161aj\u0101 br\u012bd\u012b funkcijai vajadz\u0113tu atgriezties ar True.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Izveidojiet funkciju, kas \u0146em virkni, kas p\u0101rst\u0101v faila nosaukumu, un atgrie\u017e \"Yes\", ja faila nosaukums ir der\u012bgs, un atgrie\u017e \"No\", ja nav. Faila nosaukums tiek uzskat\u012bts par der\u012bgu, ja un tikai tad, ja ir izpild\u012bti visi \u0161\u0101di nosac\u012bjumi: - Faila nosaukum\u0101 nedr\u012bkst b\u016bt vair\u0101k k\u0101 tr\u012bs cipari ('0'-'9'). - Faila nosaukum\u0101 ir tie\u0161i viens punkts '.' - Apak\u0161vir\u017ea pirms punkta nedr\u012bkst b\u016bt tuk\u0161a, un t\u0101 s\u0101kas ar burtu no lat\u012b\u0146u alfab\u0113ta ('a'-'z' un 'A'Z'). - Apak\u0161vir\u017ea p\u0113c punkta ir viena no \u0161\u012bm: ['txt', 'exe', 'lld'] Pirkumi: file_name_check\"{\"example.txt.t\") # => 'Yes' file_name_check\"{\"example.dll1\") => 'No\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Funkcja ta bierze list\u0119 l i zwraca list\u0119 l' tak, \u017ce l' jest identyczna z l w nieparzystych indeksach, podczas gdy jej warto\u015bci w parzystych indeksach s\u0105 r\u00f3wne warto\u015bciom parzystych indeksach l, ale sortowane.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Przyk\u0142ad: even_odd_count ((-12) ==> (1, 1) even_odd_count ((123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels to funkcja, kt\u00f3ra przyjmuje strun\u0119 i zwraca strun\u0119 bez samog\u0142osek.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u049a\u043e\u0441\u044b\u043c\u0448\u0430 n \u0441\u0430\u043d\u0434\u044b \u043a\u0435\u043b\u0442\u0456\u0440\u0441\u0435\u043a, \u043e\u043d\u044b\u04a3 \u0456\u0448\u0456\u043d\u0434\u0435 ((1, n) \u0430\u0440\u0430\u043b\u044b\u0493\u044b\u043d\u0434\u0430 \u043a\u0435\u043b\u0435\u0442\u0456\u043d \u0436\u04b1\u043f \u0436\u04d9\u043d\u0435 \u0442\u0430\u049b \u0431\u04af\u0442\u0456\u043d \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0434\u0430\u0440 \u0441\u0430\u043d\u044b \u0431\u0430\u0440 \u0442\u043e\u043f\u0442\u0430\u043c\u0430\u043d\u044b \u049b\u0430\u0439\u0442\u0430\u0440\u0430\u043c\u044b\u0437. \u041c\u044b\u0441\u0430\u043b1: \u041a\u0456\u0440\u0456\u0441: 3 \u0428\u044b\u0493\u044b\u0441: (1, 2) \u0422\u04af\u0441\u0456\u043d\u0456\u043a\u0442\u0435\u043c\u0435: \u0431\u04af\u0442\u0456\u043d \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0434\u0430\u0440 1, 2, 3. \u043e\u043b\u0430\u0440\u0434\u044b\u04a3 \u0431\u0456\u0440\u0456 \u0436\u04b1\u043f, \u0435\u043a\u0435\u0443\u0456 \u0442\u0430\u049b. \u041c\u044b\u0441\u0430\u043b2: \u041a\u0456\u0440\u0456\u0441: 12 \u0428\u044b\u0493\u044b\u0441: (4, 6) \u0422\u04af\u0441\u0456\u043d\u0456\u043a\u0442\u0435\u043c\u0435: \u0431\u04af\u0442\u0456\u043d \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0434\u0430\u0440 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u043e\u043b\u0430\u0440\u0434\u044b\u04a3 \u0442\u04e9\u0440\u0442\u0435\u0443\u0456 \u0436\u04b1\u043f, \u0430\u043b 6-\u044b \u0442\u0430\u049b. \u0415\u0441\u043a\u0435\u0440\u0442\u0443: 1. 1 <= n <= 10^3 2. \u0442\u043e\u043f\u0442\u0430\u043c\u0430\u0434\u0430 \u0436\u04b1\u043f \u0436\u04d9\u043d\u0435 \u0442\u0430\u049b \u0431\u04af\u0442\u0456\u043d \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u0434\u0430\u0440 \u0441\u0430\u043d\u044b \u049b\u0430\u0439\u0442\u0430\u0440\u044b\u043b\u0434\u044b.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \u041a\u0456\u0440\u0456\u0441\u0442\u0456\u0440\u0443 - \"\u043d\u04e9\u043b\u0434\u0435\u043d\" \"\u0442\u043e\u0493\u044b\u0437\u0493\u0430\" \u0434\u0435\u0439\u0456\u043d\u0433\u0456 \u0441\u0430\u043d\u0434\u0430\u0440 \u0441\u0430\u043d\u0434\u0430\u0440 \u0442\u0456\u0437\u0431\u0435\u043a\u0442\u0435\u0440\u0456. \u0414\u04b1\u0440\u044b\u0441 \u0442\u0430\u04a3\u0434\u0430\u0443\u043b\u0430\u0440: \"\u043d\u04e9\u043b\", \"\u0431\u0456\u0440\", \"\u0435\u043a\u0456\", \"\u04af\u0448\", \"\u0442\u04e9\u0440\u0442\", \"\u0431\u0435\u0441\", \"\u0430\u043b\u0442\u044b\", \"\u0436\u0435\u0442\u0456\", \"\u0441\u0435\u0433\u0456\u0437\" \u0436\u04d9\u043d\u0435 \"\u0442\u043e\u0493\u044b\u0437\". \u0421\u0430\u043d\u0434\u0430\u0440 \u0442\u0456\u0437\u0431\u0435\u043a\u0442\u0435\u0440\u0456\u043d \u043a\u0456\u0448\u0456\u0434\u0435\u043d \u04af\u043b\u043a\u0435\u043d\u0433\u0435 \u049b\u0430\u0440\u0430\u0439 \u0441\u04b1\u0440\u044b\u043f\u0442\u0430\u043f \u049b\u0430\u0439\u0442\u0430\u0440\u0430\u0434\u044b\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"\u0422\u0430\u049b\u044b\u0440\u044b\u043f\u0442\u0430\u0440 \u0442\u0456\u0437\u0456\u043c\u0456\u043d\u0435 \u043a\u0456\u0440\u0435\u0442\u0456\u043d \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0436\u0430\u0437\u0443. \u0422\u0456\u0437\u0456\u043c\u0434\u0435 \u04d9\u0440\u0442\u04af\u0440\u043b\u0456 \u0441\u04e9\u0437\u0434\u0435\u0440 \u0431\u0430\u0440. \u0411\u0456\u0440\u0435\u0433\u0435\u0439 \u0442\u0430\u04a3\u0431\u0430\u043b\u0430\u0440\u0434\u044b\u04a3 \u0435\u04a3 \u043a\u04e9\u043f \u0441\u0430\u043d\u044b \u0431\u0430\u0440 \u0441\u04e9\u0437\u0434\u0456 \u049b\u0430\u0439\u0442\u0430\u0440\u0430\u043c\u044b\u0437. \u0415\u0433\u0435\u0440 \u0431\u0456\u0440\u043d\u0435\u0448\u0435 \u0442\u0430\u049b\u044b\u0440\u044b\u043f\u0442\u0430\u0440 \u0431\u0456\u0440\u0435\u0433\u0435\u0439 \u0442\u0430\u04a3\u0431\u0430\u043b\u0430\u0440\u0434\u044b\u04a3 \u0435\u04a3 \u043a\u04e9\u043f \u0441\u0430\u043d\u044b \u0431\u043e\u043b\u0441\u0430, \u043b\u0435\u043a\u0441\u0438\u043a\u043e\u0433\u0440\u0430\u0444\u0438\u044f\u043b\u044b\u049b \u0440\u0435\u0442\u0456\u043c\u0435\u043d \u0431\u0456\u0440\u0456\u043d\u0448\u0456 \u043a\u0435\u043b\u0435\u0442\u0456\u043d\u0456\u043d \u049b\u0430\u0439\u0442\u0430\u0440\u0430\u043c\u044b\u0437. find_max ((([\"\u0430\u0442\u044b\", \"of\", \"string\"]) == \"string\" find_max (([\"\u0430\u0442\u044b\", \"enam\", \"\u043e\u0439\u044b\u043d\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\", \"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Crea una funci\u00f3 encrypt que pren una cadena com a argument i retorna una cadena encriptada amb l'alfabet rotat. L'alfabet s'ha de rotar de manera que les lletres es desplacin per dos multiplicades per dos llocs. Per exemple: encrypt('hi') retorna 'lm' encrypt('asdfghjkl') retorna 'ewhjklnop' encrypt('gf') retorna 'kj' encrypt('et') retorna 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels \u00e9s una funci\u00f3 que pren cadena i retorna cadena sense vocals.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    Gibt eine codierte Zeichenfolge zur\u00fcck, indem jedes Zeichen im Alphabet um 5 verschoben wird.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"In diesem Problem werden Sie eine Funktion implementieren, die zwei Listen von Zahlen nimmt und bestimmt, ob es m\u00f6glich ist, einen Austausch von Elementen zwischen ihnen durchzuf\u00fchren, um lst1 zu einer Liste nur von geraden Zahlen zu machen. Es gibt keine Begrenzung f\u00fcr die Anzahl der ausgetauschten Elemente zwischen lst1 und lst2. Wenn es m\u00f6glich ist, Elemente zwischen lst1 und lst2 auszutauschen, um alle Elemente von lst1 zu gleichen Zahlen zu machen, geben Sie \"JA\" zur\u00fcck. Andernfalls geben Sie \"NEIN\" zur\u00fcck. Zum Beispiel: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NEIN\" Es wird angenommen, dass die Eingabelisten nicht leer sind.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Geben Sie die Anzahl der n-stelligen positiven Ganzzahlen zur\u00fcck, die mit 1 beginnen oder enden.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"\u041d\u0430\u043f\u0438\u0448\u0435\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0458\u0430 \u043a\u043e\u0458\u0430 \u043f\u0440\u0438\u0444\u0430\u045c\u0430 \u043b\u0438\u0441\u0442\u0430 \u043d\u0430 \u043d\u0438\u0437\u0438. \u041b\u0438\u0441\u0442\u0430\u0442\u0430 \u0441\u043e\u0434\u0440\u0436\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u0438 \u0437\u0431\u043e\u0440\u043e\u0432\u0438. \u0412\u0440\u0430\u045c\u0430 \u0437\u0431\u043e\u0440 \u0441\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u0435\u043d \u0431\u0440\u043e\u0458 \u043d\u0430 \u0443\u043d\u0438\u043a\u0430\u0442\u043d\u0438 \u043a\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438. \u0410\u043a\u043e \u043f\u043e\u0432\u0435\u045c\u0435 \u043d\u0438\u0437\u0438 \u0438\u043c\u0430\u0430\u0442 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u0435\u043d \u0431\u0440\u043e\u0458 \u043d\u0430 \u0443\u043d\u0438\u043a\u0430\u0442\u043d\u0438 \u043a\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438, \u0432\u0440\u0430\u0442\u0435\u0442\u0435 \u0433\u043e \u043e\u043d\u043e\u0458 \u043a\u043e\u0458 \u0434\u043e\u0430\u0453\u0430 \u043f\u0440\u0432 \u0432\u043e \u043b\u0435\u043a\u0441\u0438\u043a\u043e\u0433\u0440\u0430\u0444\u0441\u043a\u0438 \u0440\u0435\u0434\u043e\u0441\u043b\u0435\u0434.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"\u041d\u0430\u043f\u0438\u0448\u0435\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0458\u0430 \u043a\u043e\u0458\u0430 \u0437\u0435\u043c\u0430 \u043d\u0438\u0437\u0430 \u0438 \u0432\u0440\u0430\u045c\u0430 \u0412\u0438\u0441\u0442\u0438\u043d\u0430 \u0430\u043a\u043e \u0434\u043e\u043b\u0436\u0438\u043d\u0430\u0442\u0430 \u043d\u0430 \u043d\u0438\u0437\u0430\u0442\u0430 \u0435 \u043f\u0440\u0435\u043c\u0438\u0443\u043c \u0438\u043b\u0438 \u041b\u0430\u0436\u043d\u0430 \u0432\u043e \u0441\u043f\u0440\u043e\u0442\u0438\u0432\u043d\u043e \u041f\u0440\u0438\u043c\u0435\u0440\u0438 prime_length (('Hello') == \u0412\u0438\u0441\u0442\u0438\u043d\u0441\u043a\u0430 \u043f\u0440\u0435\u043c\u0438\u0443\u043c_\u0434\u043e\u043b\u0436\u0438\u043d\u0430 (('abcdcba') == \u0412\u0438\u0441\u0442\u0438\u043d\u0441\u043a\u0430 \u043f\u0440\u0435\u043c\u0438\u0443\u043c_\u0434\u043e\u043b\u0436\u0438\u043d\u0430 (('kittens') == \u0412\u0438\u0441\u0442\u0438\u043d\u0441\u043a\u0430 \u043f\u0440\u0435\u043c\u0438\u0443\u043c_\u0434\u043e\u043b\u0436\u0438\u043d\u0430 (('orange') == \u041b\u0430\u0436\u043d\u0430\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero \u0437\u0435\u043c\u0430 \u043b\u0438\u0441\u0442\u0430 \u043d\u0430 \u0446\u0435\u043b\u0438 \u0431\u0440\u043e\u0435\u0432\u0438 \u043a\u0430\u043a\u043e \u0432\u043b\u0435\u0437. \u0412\u0440\u0430\u045c\u0430 True \u0430\u043a\u043e \u0438\u043c\u0430 \u0442\u0440\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u0438 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0438 \u0432\u043e \u043b\u0438\u0441\u0442\u0430\u0442\u0430 \u043a\u043e\u0438 \u0441\u0435 \u0432\u043a\u0443\u043f\u043d\u043e \u043d\u0443\u043b\u0430, \u0438 False \u0432\u043e \u0441\u043f\u0440\u043e\u0442\u0438\u0432\u043d\u043e.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Array of integer kan isiniif kennamee fi summaa magnitude integer kan baay'ina product of all signs of each number in the array, bakka bu'ee 1, -1 or 0 ta'e deebisuu qabdu. Note: return None for empty arr. Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Lakkoofsa 'delimeter' (daangaa) tokko bakka lamatti walitti aansee argamuu malan keessaa galchicha galchuu \u2200numbers\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Selle funktsiooni sisendiks on rea, mis esindab ruumidega eraldatud pakendatud parenteside mitut r\u00fchma. Iga r\u00fchma puhul v\u00e4ljastatakse parenteside k\u00f5ige s\u00fcgavam pakendatud tase. N\u00e4iteks (() (()) on maksimaalselt kaks pakendatud taset, samas kui ((())) on kolm.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Kirjuta funktsioon, mis v\u00f5tab s\u00f5numi ja kodeerib nii, et see vahetab k\u00f5igi t\u00e4htede suur- ja v\u00e4ikealuseid, asendab s\u00f5numi k\u00f5ik vokaalid kirjaga, mis ilmub inglise t\u00e4hestikes 2 kohta selle vokaali ees.\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Kui on antud string s ja naturaalne number n, on teil \u00fclesanne rakendada funktsiooni, mis tagastab nimekirja k\u00f5ik s\u00f5nadest string s, mis sisaldavad t\u00e4pselt n konsonanti, et need s\u00f5nad ilmuksid string s. Kui string s on t\u00fchi, siis funktsioon peaks tagastama t\u00fchja nimekirja. M\u00e4rkus: v\u00f5ite eeldada, et sisendjoon sisaldab ainult t\u00e4hte ja vahekaarte. N\u00e4iteks: select_words \"Mary had a little lamb\", 4) ==> [\"little\"] select_words \"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words \"simple white space\", 2) ==> [] select_words \"Hello world\", 4) ==> [\"world\"] select_words \"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"\u10d3\u10d0\u10d0\u10d1\u10e0\u10e3\u10dc\u10d4\u10d7 n-\u10d4 \u10e4\u10d8\u10d1\u10dd\u10dc\u10d0\u10e9\u10d8\u10e1 \u10e0\u10d8\u10ea\u10ee\u10d5\u10d8.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    \u10db\u10dd\u10ea\u10d4\u10db\u10e3\u10da\u10d8 \u10e5\u10e1\u10d4\u10da\u10d8 N \u10e0\u10d8\u10d2\u10d4\u10d1\u10d8\u10d7 \u10d3\u10d0 N \u10e1\u10d5\u10d4\u10e2\u10d4\u10d1\u10d8\u10d7 (N > = 2) \u10d3\u10d0 \u10d3\u10d0\u10d3\u10d4\u10d1\u10d8\u10d7\u10d8 \u10db\u10d7\u10da\u10d8\u10d0\u10dc\u10d8 k, \u10e5\u10e1\u10d4\u10da\u10d8\u10e1 \u10d7\u10d8\u10d7\u10dd\u10d4\u10e3\u10da\u10d8 \u10e3\u10ef\u10e0\u10d4\u10d3\u10d8 \u10e8\u10d4\u10d8\u10ea\u10d0\u10d5\u10e1 \u10db\u10dc\u10d8\u10e8\u10d5\u10dc\u10d4\u10da\u10dd\u10d1\u10d0\u10e1. [1, N * N] \u10e9\u10d0\u10d7\u10d5\u10da\u10d8\u10d7, \u10e7\u10d5\u10d4\u10da\u10d0 \u10db\u10d7\u10da\u10d8\u10d0\u10dc\u10d8 \u10e0\u10d8\u10ea\u10ee\u10d5\u10d8 \u10d6\u10e3\u10e1\u10e2\u10d0\u10d3 \u10d4\u10e0\u10d7\u10ee\u10d4\u10da \u10e9\u10dc\u10d3\u10d4\u10d1\u10d0 \u10e5\u10e1\u10d4\u10da\u10d8\u10e1 \u10e3\u10ef\u10e0\u10d4\u10d3\u10d4\u10d1\u10d6\u10d4. \u10d7\u10e5\u10d5\u10d4\u10dc \u10e3\u10dc\u10d3\u10d0 \u10d8\u10de\u10dd\u10d5\u10dd\u10d7 \u10e1\u10d8\u10d2\u10e0\u10eb\u10d8\u10e1 k \u10db\u10d8\u10dc\u10d8\u10db\u10d0\u10da\u10e3\u10e0\u10d8 \u10d2\u10d6\u10d0 \u10e5\u10e1\u10d4\u10da\u10e8\u10d8. \u10d7\u10e5\u10d5\u10d4\u10dc \u10e8\u10d4\u10d2\u10d8\u10eb\u10da\u10d8\u10d0\u10d7 \u10d3\u10d0\u10d8\u10ec\u10e7\u10dd\u10d7 \u10dc\u10d4\u10d1\u10d8\u10e1\u10db\u10d8\u10d4\u10e0\u10d8 \u10e3\u10ef\u10e0\u10d8\u10d3\u10d0\u10dc \u10d3\u10d0 \u10d7\u10d8\u10d7\u10dd\u10d4\u10e3\u10da \u10dc\u10d0\u10d1\u10d8\u10ef\u10e8\u10d8 \u10e8\u10d4\u10d2\u10d8\u10eb\u10da\u10d8\u10d0\u10d7 \u10d2\u10d0\u10d3\u10d0\u10ee\u10d5\u10d8\u10d3\u10d4\u10d7 \u10dc\u10d4\u10d1\u10d8\u10e1\u10db\u10d8\u10d4\u10e0 \u10db\u10d4\u10d6\u10dd\u10d1\u10d4\u10da \u10e3\u10ef\u10e0\u10d4\u10d3\u10d6\u10d4, \u10e1\u10ee\u10d5\u10d0 \u10e1\u10d8\u10e2\u10e7\u10d5\u10d4\u10d1\u10d8\u10d7, \u10e8\u10d4\u10d2\u10d8\u10eb\u10da\u10d8\u10d0\u10d7 \u10d2\u10d0\u10d3\u10d0\u10ee\u10d5\u10d8\u10d3\u10d4\u10d7 \u10e3\u10ef\u10e0\u10d4\u10d3\u10d4\u10d1\u10d6\u10d4, \u10e0\u10dd\u10db\u10da\u10d4\u10d1\u10d8\u10ea \u10d8\u10d6\u10d8\u10d0\u10e0\u10d4\u10d1\u10d4\u10dc \u10d9\u10d8\u10d3\u10d4\u10e1 \u10d7\u10e5\u10d5\u10d4\u10dc\u10e1 \u10db\u10d8\u10db\u10d3\u10d8\u10dc\u10d0\u10e0\u10d4 \u10e3\u10ef\u10e0\u10d4\u10d3\u10d7\u10d0\u10dc. \u10d2\u10d7\u10ee\u10dd\u10d5\u10d7 \u10d2\u10d0\u10d8\u10d7\u10d5\u10d0\u10da\u10d8\u10e1\u10ec\u10d8\u10dc\u10dd\u10d7, \u10e0\u10dd\u10db k \u10e1\u10d8\u10d2\u10e0\u10eb\u10d8\u10e1 \u10d2\u10d6\u10d0 \u10dc\u10d8\u10e8\u10dc\u10d0\u10d5\u10e1 \u10d6\u10e3\u10e1\u10e2\u10d0\u10d3 k \u10e3\u10ef\u10e0\u10d4\u10d3\u10d8\u10e1 \u10db\u10dd\u10dc\u10d0\u10ee\u10e3\u10da\u10d4\u10d1\u10d0\u10e1 (\u10d0\u10e0 \u10d0\u10e0\u10d8\u10e1 \u10d0\u10e3\u10ea\u10d8\u10da\u10d4\u10d1\u10da\u10d0\u10d3 \u10d2\u10d0\u10dc\u10e1\u10ee\u10d5\u10d0\u10d5\u10d4\u10d1\u10e3\u10da\u10d8). \u10d7\u10e5\u10d5\u10d4\u10dc \u10d0\u10e0 \u10e8\u10d4\u10d2\u10d8\u10eb\u10da\u10d8\u10d0\u10d7 \u10ec\u10d0\u10e1\u10d5\u10da\u10d0 \u10e5\u10e1\u10d4\u10da\u10d8\u10d3\u10d0\u10dc. A \u10d2\u10d6\u10d0 (k \u10e1\u10d8\u10d2\u10e0\u10eb\u10d8\u10e1\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1015\u107c\u103a\u101d\u1086\u1089\u107c\u107c\u103a\u1089 \u1015\u1035\u107c\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1010\u1035\u1019\u103a \u1022\u107c\u103a\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088 n \u101a\u101d\u103a\u1089\u104b \u1010\u1031\u101c\u1086\u1088\u1081\u1035\u1010\u103a\u1038 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088 \u1022\u107c\u103a\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088 a \u1022\u107c\u103a\u1019\u102e\u1038\u1010\u1062\u1004\u103a\u1038\u101a\u1062\u101d\u103a\u1038 n \u107c\u107c\u103a\u1089\u101a\u1030\u1087\u101a\u101d\u103a\u1089\u104b \u1010\u103d\u107c\u103a\u1088\u1010\u1083\u1087 i (1 \u2030\u00a4 i \u2030\u00a4 n) \u1075\u1030\u1088\u1022\u107c\u103a\u107c\u107c\u103a\u1089 \u1075\u1083\u1088\u1076\u107c\u103a a[i] = i * i - i + 1 \u107c\u107c\u103a\u1089 \u1076\u102d\u102f\u107c\u103a\u1038\u1015\u107c\u103a \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1015\u1035\u107c\u103a \u101e\u1062\u1019\u103a\u1022\u107c\u103a (a[i], a[j], a[k]) \u1076\u103d\u1004\u103a a \u1010\u102e\u1088\u1022\u107c\u103a i < j < k \u101c\u1084\u1088 a[i] + a[j] + a[k] \u107c\u1086\u1089\u1015\u1035\u107c\u103a \u1010\u1030\u101d\u103a\u107c\u1019\u103a\u1076\u103d\u1004\u103a 3 \u107c\u107c\u103a\u1089\u101a\u1030\u1087\u101a\u101d\u103a\u1089\u104b \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u1087: Input: n = 5 Output: 1 \u1076\u1031\u1083\u1088\u101e\u1015\u103a\u1038\u101c\u1085\u1004\u103a\u1038: a = [1, 3, 7, 13, 21] \u1022\u107c\u103a\u1010\u1035\u1019\u103a\u1011\u1030\u107c\u103a\u1088\u1022\u107c\u103a\u101c\u1035\u101d\u103a\u107c\u1086\u1089 \u1015\u1035\u107c\u103a (1, 7, 13) \u107c\u107c\u103a\u1089\u101a\u101d\u103a\u1089\u104b\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"\u1015\u1031\u1083\u1038\u101d\u1083\u1088\u1081\u101d\u103a\u1038\u1015\u107c\u103a\u101d\u1086\u1089 \u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1015\u1083\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u101c\u1035\u101d\u103a\u107c\u107c\u103a\u1089\u107c\u1086 \u1081\u101d\u103a\u1038\u1010\u1031\u101c\u1086\u1088\u1076\u102d\u102f\u107c\u103a\u1038\u101e\u1035\u107c\u103a\u1088\u1019\u1062\u1086\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u101c\u1035\u101d\u103a\u1075\u107c\u103a\u107c\u107c\u103a\u1089\u101a\u1030\u1087\u101a\u101d\u103a\u1089\u104b \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u1083\u1038\u107c\u107c\u103a\u1089 \u1010\u1031\u101c\u1086\u1088\u1015\u1035\u107c\u103a \"\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1019\u102d\u1030\u107c\u103a\u1075\u107c\u103a \u107c\u1082\u103a\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u1083\u1038\"\u104b \u1010\u102e\u1088 i \u107c\u1086\u1089 \u1010\u1031\u101c\u1086\u1088\u1022\u101d\u103a\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u1019\u103a\u1087\u1019\u102d\u1030\u107c\u103a\u1075\u107c\u103a \u107c\u1082\u103a\u1038\u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089\u1022\u107c\u103a\u1022\u103d\u1075\u103a\u1087\u1019\u1083\u1038\u107c\u107c\u103a\u1089 \u101c\u1062\u1086\u1088\u1015\u1035\u107c\u103a i \u107c\u107c\u103a\u1089\u101a\u101d\u103a\u1089\u104b\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u10871: Input: 3 Output: (1, 2) Explanation: Integer palindromes are 1, 2, 3. \u1022\u107c\u103a\u107c\u102d\u1030\u1004\u103a\u1088\u1015\u1035\u107c\u103a even \u101c\u1084\u1088 \u1022\u107c\u103a\u107c\u102d\u1030\u1004\u103a\u1088\u1015\u1035\u107c\u103a odd\u104b \u1010\u1030\u101d\u103a\u101a\u1062\u1004\u103a\u10872: Input: 12 Output: (4, 6) Explanation: Integer palindromes are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u1022\u107c\u103a\u107c\u102d\u1030\u1004\u103a\u1088\u1015\u1035\u107c\u103a even \u101c\u1084\u1088 \u1022\u107c\u103a\u107c\u102d\u1030\u1004\u103a\u1088\u1015\u1035\u107c\u103a odd\u104b \u1076\u1031\u1083\u1088\u1010\u103d\u1004\u103a\u1038: 1. 1 <= n <= 10^3 2. tuple \u1022\u107c\u103a\u101c\u1086\u1088\u1076\u102d\u102f\u107c\u103a\u1038 \u1010\u1030\u101d\u103a\u107c\u1015\u103a\u1089 palindromes \u1022\u107c\u103a\u107c\u102d\u1030\u1004\u103a\u1088\u1015\u1035\u107c\u103a even \u101c\u1084\u1088 \u1022\u107c\u103a\u107c\u102d\u1030\u1004\u103a\u1088\u1015\u1035\u107c\u103a odd\u104b\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Ets\u0254 ame\u0192omevi siwo wots\u0254 w\u0254 numekuku la \u0192e xexl\u1ebddzesi tso suet\u0254 dzi va se \u0256e g\u00e3t\u0254 dzi. Ehi\u00e3 be woa\u014bl\u0254 nu\u0192omevi \u0256esia\u0256e \u0192e xexl\u1ebddzesi si s\u0254 kple zi nenie w\u00f2adze le nu\u0192omevi me. Ehi\u00e3 be xexl\u1ebddzesi si woade la nas\u0254 kple nu\u0192omevi siwo kat\u00e3 wots\u0254 w\u0254 numekuku la \u0192e xexl\u1ebddzesi\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Le xexl\u1ebddzesi n a\u0256e \u014bu la, di xexl\u1ebddzesi si lolo wu si mam\u00e3 n s\u0254s\u0254e, si le sue wu n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter input list of strings only for ones that contain given substring (Kpl\u0254 nya siwo le \u014b\u0254\u014bl\u0254dzesi me la \u0256o na esiwo me nya a\u0256e le)\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" Aka phuqachirixa m\u00e4 lista de enteros enteros. Taqinitaki lista ukanxa, phuqachirixa cuadrat'ayaniwa entero entero ukaxa, uka index ukax 3 ukana waljawa, ukatxa cubrat'ayaniwa entero entero ukaxa, uka index ukax 4 ukana waljawa, janiw 3 ukana waljaxa. Funci\u00f3n ukax janiw mayjt'aykaniti enteros en la lista ukanxa, uka index ukanakax janiw 3 ukana waljaxa. Funci\u00f3n ukax kutt'ayaniwa enteros ukan suma. Ejemplos: Para lst = [1,2,3] la salida debe ser 6 Para lst = [] la salida debe ser 0 Para lst = [-1,-5,2,-1,-5] la salida debe ser -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"M\u00e4 funci\u00f3n qillqa\u00f1a, uka listanx m\u00e4 par\u00e1metro ukjamarakiw m\u00e4 lista de cadenas ukanakaxa, ukatx jan mayja jallukipki ukanaka chhaqtayasa, ukatx m\u00e4 orden ordenado uka listar kut'ayasa. Uka listax m\u00e4 lista de cadenas ukjamarakwa, janiw m\u00e4 array de n\u00fameros ukhamakaspati, ukatx inas p\u00e4 arur u\u00f1tasit utjchispa. Uka ordenanx sapa arur jayst'asaw u\u00f1staya\u00f1a, ukat uka kamachimpix uka listax u\u00f1stayatarakispawa. P\u00e4 arux m\u00e4 pachpak\u00efchi ukhax aka listarux alfabeticamente u\u00f1staya\u00f1a. Uka funci\u00f3nx m\u00e4 lista de cadenas ordenadas ukjam u\u00f1staya\u00f1apawa. Akham amuyt'a\u00f1\u00e4ni: list_sort[\"aa\", \"a\", \"aaa\"]) => list_sort[\"ab\", \"a\", \"aaa\", \"c\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"M\u00e4 funci\u00f3n qillqa\u00f1awa, ukax m\u00e4 cadena de fecha uksan chiqapapapuni ukjamarus chiqapuni ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari ukjamarus k'ari uk\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"\u30d6\u30e9\u30b8\u30eb\u306e\u56e0\u6570\u5206\u89e3\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3055\u308c\u308b: brazilian_factorial (n) = n! * (n-1)! * (n-2)! *... * 1! n > 0 \u306e\u5834\u5408 \u4f8b\u3048\u3070:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"\u6570\u5b57\u306e\u914d\u5217\u3092\u5165\u529b\u3068\u3057\u3066\u53d6\u308a,\u914d\u5217\u306e\u8981\u7d20\u306e\u6570\u304c10\u4ee5\u4e0a\u3067,\u6570\u5024\u306e\u6700\u521d\u306e\u6841\u3068\u6700\u5f8c\u306e\u6841\u304c\u5947\u6570 (1, 3, 5, 7, 9) \u3067\u3042\u308b\u3053\u3068\u3092\u8fd4\u3057\u305f\u95a2\u6570\u3092\u66f8\u304d\u307e\u3059.\u4f8b\u3048\u3070: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Te vien data na stringa s. se s[i] xe na letera, invertise la so cassa da bassa a alta o viceversa, se no la tien come che la xe. Se la stringa no la contien letere, invertise la stringa. La funsion la dovaria restituir la stringa risultante. Esempi solvi{\"1234\") = \"4321\" solvi{\"ab\") = \"AB\" solvi{\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Provare se \u0142a stringa data \u0142a xe un palindromo \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs raprexenta coeficienti de un polinomio. xs[0] + xs[1] * x + xs[2] * x^2 +.... Ritorna \u0142a derivada de sto polinomio inte \u0142a stesa forma.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Tudi ne mulongo wa 'arr' wa bungi bua bungi bua N arr[1], arr[2],..., arr[N].Bungi bua bungi budi mu mulongo budi ne bua kulondangana ku mpukapuka. Mudimu webe ngua kumanya bikalabi mua kuenzeka bua kupeta mulongo mu bulongame budi kabuyi buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda buenda\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n mmuenzeji udi usangisha bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Udi ne bua kupeta bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi bua bungi\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Jatiden 7 b\u025b s\u0254r\u0254 si\u0272\u025b hak\u025b min na nimero dafalen la min ka d\u0254g\u0254 ni n ye min tilennen don 11 walima 13 ye.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"S\u025bb\u025bn k\u025bli min b\u025b s\u025br\u025bd\u0254n ta ka s\u025bb\u025b s\u0254r\u0254 ni s\u025br\u025bd\u0254n janya ye jatiden f\u0254l\u0254 ye walima galontig\u025bla n'o t\u025b Misaliw prime_length{\"hello\") == True prime_length{\"abcdcba\") == True prime_length{\"kittens\") == True prime_length{\"orange\") == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Ibalik ang gidaghanon sa mga panahon nga ang digit 7 makita sa integers nga mas gamay kay sa n nga mao ang bahin sa 11 o 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs nagrepresentar sa coefficients sa usa ka polynomial. xs[0] + xs[1] * x + xs[2] * x ^ 2 +.... Ibalik derivative sa polynomial sa mao usab nga porma.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Gikan sa gihatag nga listahan sa mga numero (nga ang gitas-on labing menos duha) pilia ug ibalik ang duha nga labing suod sa usag usa ug ibalik sila sa pagkasunodsunod (mas gamay nga numero, mas dako nga numero).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Ma yella-d yiwen n usebter n im\u1e0danen imeggura n, af-d agraw amec\u1e6du\u1e25 n kra n usebter n im\u1e0danen ur nelli d ilem. Amedya minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Asekles n Brazilan yettwassen s: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! anda n > 0 Amedya:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Ttwafent-akent snat n tzel\u0263iwin n umgerrad n u m, d cc\u0263el-nkent ad tesse\u1e25seb tajumma n umgerrad n umgerrad n u m (am n d m). Sqemlet tiririt ar u\u1e6d\u1e6dun ameqqran i d-yusan u beddlet-tt \u0263er tin n tbinar. Ma n meqqer \u0263ef m, rnut -1. Amedya: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b11\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    \u0c8e\u0cb0\u0ca1\u0cc1 \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0c97\u0cb3\u0cc1 \u0c86\u0caa\u0cb0\u0cc7\u0c9f\u0cb0\u0ccd \u0cae\u0ca4\u0ccd\u0ca4\u0cc1 \u0c86\u0caa\u0cb0\u0cc7\u0c82\u0ca1\u0ca8\u0ccd\u0ca8\u0cc1 \u0ca8\u0cc0\u0ca1\u0cb2\u0cbe\u0c97\u0cbf\u0ca6\u0cc6. \u0cae\u0cca\u0ca6\u0cb2 \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0caf\u0cb2\u0ccd\u0cb2\u0cbf \u0cae\u0cc2\u0cb2\u0cad\u0cc2\u0ca4 \u0cac\u0cc0\u0c9c\u0c97\u0ca3\u0cbf\u0ca4\u0ca6 \u0c95\u0cbe\u0cb0\u0ccd\u0caf\u0cbe\u0c9a\u0cb0\u0ca3\u0cc6\u0c97\u0cb3\u0cc1 \u0c87\u0cb5\u0cc6, \u0cae\u0ca4\u0ccd\u0ca4\u0cc1 \u0c8e\u0cb0\u0ca1\u0ca8\u0cc7 \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0caf\u0cc1 \u0caa\u0cc2\u0cb0\u0ccd\u0ca3\u0cbe\u0c82\u0c95\u0c97\u0cb3 \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0caf\u0cbe\u0c97\u0cbf\u0ca6\u0cc6. \u0cac\u0cc0\u0c9c\u0c97\u0ca3\u0cbf\u0ca4\u0ca6 \u0c85\u0cad\u0cbf\u0cb5\u0ccd\u0caf\u0c95\u0ccd\u0ca4\u0cbf\u0caf\u0ca8\u0ccd\u0ca8\u0cc1 \u0ca8\u0cbf\u0cb0\u0ccd\u0cae\u0cbf\u0cb8\u0cb2\u0cc1 \u0cae\u0ca4\u0ccd\u0ca4\u0cc1 \u0c88 \u0c85\u0cad\u0cbf\u0cb5\u0ccd\u0caf\u0c95\u0ccd\u0ca4\u0cbf\u0caf \u0cae\u0ccc\u0cb2\u0ccd\u0caf\u0cae\u0cbe\u0caa\u0ca8\u0cb5\u0ca8\u0ccd\u0ca8\u0cc1 \u0cb9\u0cbf\u0c82\u0ca4\u0cbf\u0cb0\u0cc1\u0c97\u0cbf\u0cb8\u0cb2\u0cc1 \u0c8e\u0cb0\u0ca1\u0cc1 \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0c97\u0cb3\u0ca8\u0ccd\u0ca8\u0cc1 \u0cac\u0cb3\u0cb8\u0cbf. \u0cae\u0cc2\u0cb2\u0cad\u0cc2\u0ca4 \u0cac\u0cc0\u0c9c\u0c97\u0ca3\u0cbf\u0ca4\u0ca6 \u0c95\u0cbe\u0cb0\u0ccd\u0caf\u0cbe\u0c9a\u0cb0\u0ca3\u0cc6\u0c97\u0cb3\u0cc1\u0c83 \u0cb8\u0cc7\u0cb0\u0ccd\u0caa\u0ca1\u0cc6 (+) \u0cb5\u0ccd\u0caf\u0cb5\u0c95\u0cb2\u0ca8 (-)) \u0c97\u0cc1\u0ca3\u0cbe\u0c95\u0cbe\u0cb0 ( *) \u0ca8\u0cc6\u0cb2\u0ca6 \u0cb5\u0cbf\u0cad\u0cbe\u0c97 ( \/\/ ) \u0c98\u0cbe\u0ca4\u0cc0\u0c95\u0cb0\u0ca3 ( ** \u0c89\u0ca6\u0cbe\u0cb9\u0cb0\u0ca3\u0cc6): \u0c86\u0caa\u0cb0\u0cc7\u0c9f\u0cb0\u0ccd['+', '*', '-'] \u0cb0\u0c9a\u0ca8\u0cc6 = [2, 3, 4, 5] \u0cab\u0cb2\u0cbf\u0ca4\u0cbe\u0c82\u0cb6 = 2 + 3 * 4 - 5 => \u0cab\u0cb2\u0cbf\u0ca4\u0cbe\u0c82\u0cb6 = 9 \u0c97\u0cae\u0ca8\u0cbf\u0cb8\u0cbf: \u0c86\u0caa\u0cb0\u0cc7\u0c9f\u0cb0\u0ccd \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0caf \u0c89\u0ca6\u0ccd\u0ca6\u0cb5\u0cc1 \u0c86\u0caa\u0cb0\u0cc7\u0c82\u0ca1 \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0caf \u0c89\u0ca6\u0ccd\u0ca6\u0c95\u0ccd\u0c95\u0cc6 \u0cb8\u0cae\u0cbe\u0ca8\u0cb5\u0cbe\u0c97\u0cbf\u0cb0\u0cc1\u0ca4\u0ccd\u0ca4\u0ca6\u0cc6. \u0c86\u0caa\u0cb0\u0cc7\u0c82\u0ca1\u0cc1 \u0c92\u0c82\u0ca6\u0cc1 \u0c85\u0cb2\u0ccd\u0cb2\u0ca6 \u0c8b\u0ca3\u0cbe\u0ca4\u0ccd\u0cae\u0c95 \u0caa\u0cc2\u0cb0\u0ccd\u0ca3\u0cbe\u0c82\u0c95\u0c97\u0cb3 \u0caa\u0c9f\u0ccd\u0c9f\u0cbf\u0caf\u0cbe\u0c97\u0cbf\u0ca6\u0cc6.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    \u0c92\u0c82\u0ca6\u0cc1 \u0cb8\u0ccd\u0c9f\u0ccd\u0cb0\u0cbf\u0c82\u0c97\u0ccd s \u0ca8\u0cc0\u0ca1\u0cbf\u0ca6\u0cb0\u0cc6, \u0cb8\u0cae \u0cb8\u0cc2\u0c9a\u0ccd\u0caf\u0c82\u0c95\u0c97\u0cb3\u0cb2\u0ccd\u0cb2\u0cbf \u0ca6\u0cca\u0ca1\u0ccd\u0ca1\u0c95\u0ccd\u0cb7\u0cb0 \u0cb8\u0ccd\u0cb5\u0cb0\u0c97\u0cb3 \u0cb8\u0c82\u0c96\u0ccd\u0caf\u0cc6\u0caf\u0ca8\u0ccd\u0ca8\u0cc1 \u0c8e\u0ca3\u0cbf\u0cb8\u0cbf. \u0c89\u0ca6\u0cbe\u0cb9\u0cb0\u0ca3\u0cc6\u0c97\u0cc6\u0c83 count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 \u0c85\u0ca8\u0ccd\u0ca8\u0cc1 \u0cb9\u0cbf\u0c82\u0ca6\u0cbf\u0cb0\u0cc1\u0c97\u0cbf\u0cb8\u0cc1\u0ca4\u0ccd\u0ca4\u0ca6\u0cc6\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"\u0393\u03c1\u03ac\u03c8\u03c4\u03b5 \u03bc\u03b9\u03b1 \u03c3\u03c5\u03bd\u03ac\u03c1\u03c4\u03b7\u03c3\u03b7 \u03c0\u03bf\u03c5 \u03b4\u03ad\u03c7\u03b5\u03c4\u03b1\u03b9 \u03bc\u03b9\u03b1 \u03bb\u03af\u03c3\u03c4\u03b1 \u03bc\u03b5 \u03c3\u03c5\u03bc\u03b2\u03bf\u03bb\u03bf\u03c3\u03b5\u03b9\u03c1\u03ad\u03c2 \u03c9\u03c2 \u03c0\u03b1\u03c1\u03ac\u03bc\u03b5\u03c4\u03c1\u03bf, \u03b4\u03b9\u03b1\u03b3\u03c1\u03ac\u03c6\u03b5\u03b9 \u03c4\u03b9\u03c2 \u03c3\u03c5\u03bc\u03b2\u03bf\u03bb\u03bf\u03c3\u03b5\u03b9\u03c1\u03ad\u03c2 \u03c0\u03bf\u03c5 \u03ad\u03c7\u03bf\u03c5\u03bd \u03b1\u03ba\u03b1\u03bd\u03cc\u03bd\u03b9\u03c3\u03c4\u03bf \u03bc\u03ae\u03ba\u03bf\u03c2 \u03b1\u03c0\u03cc \u03b1\u03c5\u03c4\u03ae\u03bd, \u03ba\u03b1\u03b9 \u03b5\u03c0\u03b9\u03c3\u03c4\u03c1\u03ad\u03c6\u03b5\u03b9 \u03c4\u03b7\u03bd \u03c0\u03c1\u03bf\u03ba\u03cd\u03c0\u03c4\u03bf\u03c5\u03c3\u03b1 \u03bb\u03af\u03c3\u03c4\u03b1 \u03bc\u03b5 \u03bc\u03b9\u03b1 \u03c4\u03b1\u03be\u03b9\u03bd\u03bf\u03bc\u03b7\u03bc\u03ad\u03bd\u03b7 \u03c3\u03b5\u03b9\u03c1\u03ac. \u0397 \u03bb\u03af\u03c3\u03c4\u03b1 \u03b5\u03af\u03bd\u03b1\u03b9 \u03c0\u03ac\u03bd\u03c4\u03b1 \u03bc\u03b9\u03b1 \u03bb\u03af\u03c3\u03c4\u03b1 \u03bc\u03b5 \u03c3\u03c5\u03bc\u03b2\u03bf\u03bb\u03bf\u03c3\u03b5\u03b9\u03c1\u03ad\u03c2 \u03ba\u03b1\u03b9 \u03c0\u03bf\u03c4\u03ad \u03bc\u03b9\u03b1 \u03c3\u03b5\u03b9\u03c1\u03ac \u03b1\u03c1\u03b9\u03b8\u03bc\u03ce\u03bd, \u03ba\u03b1\u03b9 \u03bc\u03c0\u03bf\u03c1\u03b5\u03af \u03bd\u03b1 \u03c0\u03b5\u03c1\u03b9\u03ad\u03c7\u03b5\u03b9 \u03b4\u03b9\u03c0\u03bb\u03cc\u03c4\u03c5\u03c0\u03b1. \u0397 \u03c3\u03b5\u03b9\u03c1\u03ac \u03c4\u03b7\u03c2 \u03bb\u03af\u03c3\u03c4\u03b1\u03c2 \u03b8\u03b1 \u03c0\u03c1\u03ad\u03c0\u03b5\u03b9 \u03bd\u03b1 \u03b5\u03af\u03bd\u03b1\u03b9 \u03b1\u03bd\u03bf\u03b4\u03b9\u03ba\u03ae \u03ba\u03b1\u03c4\u03ac \u03bc\u03ae\u03ba\u03bf\u03c2 \u03ba\u03ac\u03b8\u03b5 \u03bb\u03ad\u03be\u03b7\u03c2, \u03ba\u03b1\u03b9 \u03b8\u03b1 \u03c0\u03c1\u03ad\u03c0\u03b5\u03b9 \u03bd\u03b1 \u03b5\u03c0\u03b9\u03c3\u03c4\u03c1\u03ad\u03c8\u03b5\u03c4\u03b5 \u03c4\u03b7 \u03bb\u03af\u03c3\u03c4\u03b1 \u03c4\u03b1\u03be\u03b9\u03bd\u03bf\u03bc\u03b7\u03bc\u03ad\u03bd\u03b7 \u03bc\u03b5 \u03b1\u03c5\u03c4\u03cc\u03bd \u03c4\u03bf\u03bd \u03ba\u03b1\u03bd\u03cc\u03bd\u03b1. \u0391\u03bd \u03b4\u03cd\u03bf \u03bb\u03ad\u03be\u03b5\u03b9\u03c2 \u03ad\u03c7\u03bf\u03c5\u03bd \u03c4\u03bf \u03af\u03b4\u03b9\u03bf \u03bc\u03ae\u03ba\u03bf\u03c2, \u03c4\u03b1\u03be\u03b9\u03bd\u03bf\u03bc\u03ae\u03c3\u03c4\u03b5 \u03c4\u03b7 \u03bb\u03af\u03c3\u03c4\u03b1 \u03b1\u03bb\u03c6\u03b1\u03b2\u03b7\u03c4\u03b9\u03ba\u03ac. \u0397 \u03c3\u03c5\u03bd\u03ac\u03c1\u03c4\u03b7\u03c3\u03b7 \u03b8\u03b1 \u03c0\u03c1\u03ad\u03c0\u03b5\u03b9 \u03bd\u03b1 \u03b5\u03c0\u03b9\u03c3\u03c4\u03c1\u03ad\u03c8\u03b5\u03b9 \u03bc\u03b9\u03b1 \u03bb\u03af\u03c3\u03c4\u03b1 \u03bc\u03b5 \u03c3\u03c5\u03bc\u03b2\u03bf\u03bb\u03bf\u03c3\u03b5\u03b9\u03c1\u03ad\u03c2 \u03c3\u03b5 \u03c4\u03b1\u03be\u03b9\u03bd\u03bf\u03bc\u03b7\u03bc\u03ad\u03bd\u03b7 \u03c3\u03b5\u03b9\u03c1\u03ac. \u039c\u03c0\u03bf\u03c1\u03b5\u03af\u03c4\u03b5 \u03bd\u03b1 \u03c5\u03c0\u03bf\u03b8\u03ad\u03c3\u03b5\u03c4\u03b5 \u03cc\u03c4\u03b9 \u03cc\u03bb\u03b5\u03c2 \u03bf\u03b9 \u03bb\u03ad\u03be\u03b5\u03b9\u03c2 \u03b8\u03b1\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"\u0395\u03c0\u03b9\u03c3\u03c4\u03c1\u03ad\u03c6\u03b5\u03b9 \u03c4\u03bf\u03bd \u03b1\u03c1\u03b9\u03b8\u03bc\u03cc Fibonacci n-\u03bf\u03c5.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"\u0395\u03ac\u03bd \u03b7 \u03c3\u03c5\u03bc\u03b2\u03bf\u03bb\u03bf\u03c3\u03b5\u03b9\u03c1\u03ac s \u03b5\u03af\u03bd\u03b1\u03b9 \u03ba\u03b5\u03bd\u03ae, \u03c4\u03cc\u03c4\u03b5 \u03b7 \u03c3\u03c5\u03bd\u03ac\u03c1\u03c4\u03b7\u03c3\u03b7 \u03b8\u03b1 \u03c0\u03c1\u03ad\u03c0\u03b5\u03b9 \u03bd\u03b1 \u03b5\u03c0\u03b9\u03c3\u03c4\u03c1\u03ad\u03c8\u03b5\u03b9 \u03bc\u03b9\u03b1 \u03ba\u03b5\u03bd\u03ae \u03bb\u03af\u03c3\u03c4\u03b1. \u03a3\u03b7\u03bc\u03b5\u03af\u03c9\u03c3\u03b7: \u039c\u03c0\u03bf\u03c1\u03b5\u03af\u03c4\u03b5 \u03bd\u03b1 \u03c5\u03c0\u03bf\u03b8\u03ad\u03c3\u03b5\u03c4\u03b5 \u03cc\u03c4\u03b9 \u03b7 \u03b5\u03b9\u03c3\u03b5\u03c1\u03c7\u03cc\u03bc\u03b5\u03bd\u03b7 \u03c3\u03c5\u03bc\u03b2\u03bf\u03bb\u03bf\u03c3\u03b5\u03b9\u03c1\u03ac \u03c0\u03b5\u03c1\u03b9\u03ad\u03c7\u03b5\u03b9 \u03bc\u03cc\u03bd\u03bf \u03b3\u03c1\u03ac\u03bc\u03bc\u03b1\u03c4\u03b1 \u03ba\u03b1\u03b9 \u03b4\u03b9\u03b1\u03c3\u03c4\u03ae\u03bc\u03b1\u03c4\u03b1. \u03a0\u03b1\u03c1\u03b1\u03b4\u03b5\u03af\u03b3\u03bc\u03b1\u03c4\u03b1: select_words (\"\u039c\u03b1\u03af\u03c1\u03b7 \u03b5\u03af\u03c7\u03b5 \u03ad\u03bd\u03b1 \u03bc\u03b9\u03ba\u03c1\u03cc \u03b1\u03c1\u03bd\u03af\", 4) ==> [\"\u03bc\u03b9\u03ba\u03c1\u03cc\"] select_words (\"\u039c\u03b1\u03af\u03c1\u03b7 \u03b5\u03af\u03c7\u03b5 \u03ad\u03bd\u03b1 \u03bc\u03b9\u03ba\u03c1\u03cc \u03b1\u03c1\u03bd\u03af\", 3) ==> [\"\u039c\u03b1\u03af\u03c1\u03b7\", \"\u03b1\u03c1\u03c3\u03af\u03b4\u03b9\"] select_words \"\u03b1\u03c0\u03bb\u03cc \u03bb\u03b5\u03c5\u03ba\u03cc \u03b4\u03b9\u03ac\u03c3\u03c4\u03b7\u03bc\u03b1\", 2) ==> [] select_words (\"\u0393\u03b5\u03b9\u03b1 \u03c3\u03bf\u03c5, \u03ba\u03cc\u03c3\u03bc\u03bf\", 4) ==> [\"\u03ba\u03cc\u03c3\u03bc\u03bf\u03c2\"] select_words (\"\u0386\u03bd\u03b8\u03c1\u03c9\u03c0\u03bf\u03c2 sam\", 3) ==> [\"\u0386\u03bd\u03b8\u03c1\u03c9\u03c0\u03bf\u03c2\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    \u12e8\u1313\u12f5\u1313\u12f5 \u1218\u1228\u1265 \u12e8\u1270\u1230\u1320\u12ce\u1275 \u12a0\u122b\u1275 \u121b\u12d5\u12d8\u1295 \u1245\u122d\u1345 \u12eb\u1208\u12cd \u1290\u12cd:: \u12a5\u12eb\u1295\u12f3\u1295\u12f1 \u1228\u12f5\u134d \u12a0\u1295\u12f5\u1295 \u1309\u12f5\u1313\u12f5 \u12ed\u12c8\u12ad\u120b\u120d\u1363 \u12a5\u1293 \u12a5\u12eb\u1295\u12f3\u1295\u12f1 1 \u1260\u12a0\u1295\u12f5 \u1228\u12f5\u134d \u12cd\u1235\u1325 \u12a0\u1295\u12f5\u1295 \u12e8\u12cd\u1203 \u12a0\u1203\u12f5 \u12ed\u12c8\u12ad\u120b\u120d:: \u12a5\u12eb\u1295\u12f3\u1295\u12f1 \u1309\u12f5\u1313\u12f5 \u12cd\u1203\u12cd\u1295 \u1208\u121b\u12cd\u1323\u1275 \u12e8\u121a\u12eb\u1308\u1208\u130d\u120d \u1270\u12db\u121b\u1305 \u1263\u120d\u12f2 \u12a0\u1208\u12cd\u1363 \u12a5\u1293 \u1201\u1209\u121d \u1263\u120d\u12f2\u12ce\u127d \u1270\u1218\u1233\u1233\u12ed \u12a0\u1245\u121d \u12a0\u120b\u1278\u12cd:: \u12e8\u12a5\u122d\u1235\u12ce \u1270\u130d\u1263\u122d \u1263\u120d\u12f2\u12ce\u1279\u1295 \u1260\u1218\u1320\u1240\u121d \u1309\u12f5\u1313\u12f6\u1279\u1295 \u1208\u121b\u12cd\u1323\u1275 \u1290\u12cd:: \u1263\u120d\u12f2\u12ce\u1279\u1295 \u1208\u121b\u12cd\u1228\u12f5 \u12e8\u121a\u12eb\u1235\u1348\u120d\u1309\u12ce\u1275\u1295 \u130a\u12dc\u12ce\u127d \u12eb\u1235\u1308\u1261:: \u121d\u1233\u120c 1: \u130d\u1265\u12d3\u1275: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 \u12cd\u1345\u12d3\u1275: 6 \u121d\u1233\u120c 2: \u130d\u1265\u12d3\u1275: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 \u12cd\u1345\u12d3\u1275: 5 \u121d\u1233\u120c 3: \u130d\u1265\u12d3\u1275: [[:\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"\u1241\u1325\u122d 7 \u1241\u1325\u122d 11 \u12c8\u12ed\u121d 13 \u1260 \u12e8\u121a\u12a8\u134b\u1348\u1209 n \u12eb\u1290\u1230 \u12cd\u1235\u1325 \u12ed\u1273\u12eb\u120d \u130a\u12dc \u1241\u1325\u122d \u12ed\u1218\u120d\u1231.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"\u064a\u0631\u062c\u0639 \u0635\u062d \u0625\u0630\u0627 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0645\u0639\u0637\u0649 \u0647\u0648 \u0623\u0648\u0644\u064a\u060c \u0648\u0641\u0634\u0644\u0629 \u062e\u0644\u0627\u0641 \u0643\u062f\u0647.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" \u0637\u0648\u0644 \u0627\u0644\u0639\u0648\u062f\u0629 \u0644\u0644\u0633\u0644\u0633\u0644\u0629 \u0627\u0644\u0645\u0639\u0637\u0627\u0629\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"\u0628\u06cc\u0631 \u0633\u06cc\u0631\u0627 \u0633\u0627\u06cc\u06cc\u0644\u0627\u0631 \u0648\u0626\u0631\u06cc\u0644\u06cc\u0631.\u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627 \u0633\u06cc\u0631\u0627\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"\u0628\u06cc\u0631 \u0641\u0627\u06a9\u062a\u0626\u0631 \u062a\u0637\u0628\u06cc\u0642 \u0627\u0626\u062f\u06cc\u0631 \u06a9\u06cc\u060c \u0645\u0646\u0641\u06cc \u0627\u0648\u0644\u0645\u0627\u06cc\u0627\u0646 \u0628\u06cc\u0631 \u0633\u0627\u06cc\u06cc \u0622\u0644\u06cc\u0631 \u0648 \u0646\u062f\u0646 \u06a9\u0626\u0686\u0645\u06cc\u0634 \u0627\u0648\u0644 \u0633\u0627\u06cc\u06cc\u0644\u0627\u0631\u06cc\u0646 \u0628\u06cc\u0631 \u0622\u0631\u0627\u06cc\u0647 \u0633\u06cc\u0646\u06cc \u0642\u0627\u06cc\u062a\u0627\u0631\u06cc\u0631. \u0645\u062b\u0644\u0627\u064b: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    \u0628\u06cc\u0631 \u062c\u0645\u0644\u0647 \u0646\u06cc \u062a\u0645\u062b\u06cc\u0644 \u0627\u0626\u062f\u0646 \u0628\u06cc\u0631 \u0633\u06cc\u0631\u0627 \u0633\u06cc \u062f\u06cc\u0644\u062f\u0647 \u0648\u0627\u0631\u060c \u062c\u0645\u0644\u0647 \u062f\u0647 \u0628\u06cc\u0631 \u0646\u0626\u0686\u0647 \u06a9\u0644\u0645\u0647 \u06cc \u0628\u06cc\u0631 \u0628\u0648\u0634\u0644\u0648\u0642\u0644\u0627 \u0622\u06cc\u0631\u06cc\u0644\u06cc\u0628\u060c \u0648 \u0627\u06cc\u0646\u062f\u06cc \u0628\u06cc\u0631 \u0633\u06cc\u0631\u0627 \u0633\u06cc \u062f\u06cc\u0644\u062f\u0647 \u0648\u0627\u0631 \u06a9\u06cc\u060c \u0627\u0648\u0651\u0644\u06a9\u06cc \u062c\u0645\u0644\u0647 \u062f\u0646 \u0633\u0624\u0632\u062c\u0648\u06a9\u0644\u0631 \u0648\u0627\u0631\u062f\u06cc\u0631\u060c \u0627\u0648\u0652\u0646\u0648\u0646 \u0627\u0648\u0632\u0648\u0646\u0644\u0648\u063a\u0648 \u0627\u06cc\u0644\u06a9 \u0633\u0627\u06cc\u06cc\u0644\u0627\u0631 \u062f\u06cc\u0631\u060c \u06cc\u0626\u0646\u06cc \u0633\u06cc\u0631\u0627 \u06a9\u0644\u0645\u0647 \u0644\u0631\u06cc \u0646\u06cc\u0646 \u062a\u0631\u062a\u06cc\u0628\u0633\u06cc \u0627\u0648\u0651\u0644\u06a9\u06cc \u062c\u0645\u0644\u0647 \u062f\u0647 \u06a9\u06cc \u06a9\u06cc \u06a9\u06cc\u0645\u06cc \u0627\u0648\u0644\u0645\u0627\u0644\u06cc\u062f\u06cc\u0631. \u0645\u062b\u0627\u06441: \u0627\u06cc\u0646\u067e\u0648\u062a: \u062c\u0645\u0644\u0647 = \"\u0628\u0648 \u0628\u06cc\u0631 \u062a\u0633\u062a \u062f\u06cc\u0631\" \u062e\u0627\u0631\u06cc\u062c\u06cc: \"\u062f\u06cc\u0631\" \u0645\u062b\u0627\u06442: \u0627\u06cc\u0646\u067e\u0648\u062a: \u062c\u0645\u0644\u0647 = \"\u0633\u0648\u06cc\u0648\u0646\u0645\u0627\u063a\u0627 \u06af\u0626\u062f\u06a9\" \u062e\u0627\u0631\u06cc\u062c\u06cc: \"go for\" \u0645\u062d\u062f\u0648\u062f\u06cc\u062a\u0644\u0631: * 1 <= len(sentence) <= 100 * \u062c\u0645\u0644\u0647 \u062f\u0647 \u062a\u06a9\u062c\u0647 \u062d\u0631\u0641\u0644\u0631 \u0648\u0627\u0631\u062f\u06cc\u0631\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \u0168nd\u0169 \u0169la wa vata n\u0129 k\u0169manya kana \"o\" n\u0129 namba \u0129te maana, na kwoou no nginya m\u0169somi eth\u0129we es\u0129 kana \"o\" n\u0129 namba ya m\u0169singi, na kana \"o\" n\u0129 namba ya \u0129siwa, na kana \"o\" n\u0129 namba ya m\u0169onza nth\u0129n\u0129 wa k\u0129la m\u0169soa.\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"\u0168asa wa \u0129via y\u0129la y\u0129ku\u0129te m\u0169sumaa na k\u0129sio k\u0129la k\u0129thy\u0169l\u0169l\u0169k\u0129te m\u0169sumaa \u0169su.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets n\u0129 ndeto yonanasya k\u0129lungu k\u0129 na kyongo \"<\" na \">\".\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Qor shaqo qaata string oo soo celisa True haddii dhererka string uu yahay tiro asal ah ama False haddii kale tusaalooyin prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Marka la eego tiro dhan. soo celi tuple oo leh tiro ka mid ah xitaa iyo xitaa tirooyinka. Tusaale: xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_xitaa_\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Na peko ti so a mu na mo mbeni nzoni wungo, wara oko wungo ti lo na lege ti a-roman tongana mbeni molongo ti atondo, na kiri na ni na kete kete mbeti.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Sara mbeni kua so ayeke yeda na molongo ti molongo ti atambela tongana mbeni param\u00e8tre, a yeke zi atambela so ayo ayo na lege ti ndoni pepe na y\u00e2 ni, na a yeke kiri na molongo so a wara na lege ti molongo so a leke ni. Lisoro ni ayeke lakue molongo ti atambela me a yeke mbeni molongo ti wungo l\u00e2 oko pepe, na a lingbi ti wara ambeni molongo so a leke ni na lege ti molongo ni so. A lingbi molongo ti molongo ni ague na nduzu na lege ti yongo ti t\u00ebn\u00eb oko oko, na a lingbi mo kiri na molongo so a leke ni na lege ti ndia so. Tongana at\u00ebn\u00eb use ayeke na yongo oko, zia molongo ni na lege ti alphab\u00e9tique. A lingbi kua ni akiri na molongo ti atambela na lege ti molongo so a leke ni. Mo lingbi ti tene so at\u00ebn\u00eb kue ayeke na yongo oko.\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Mo yeke wara na l\u00ea ti mbeti ni so a sara t\u00ebn\u00eb ti aye so ayeke na y\u00e2 ti molongo ti aye ni so.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u0428\u0443\u043c\u043e \u0440\u04ef\u0439\u0445\u0430\u0442\u0438 \u0430\u0434\u0430\u0434\u04b3\u043e\u0438 \u043a\u0443\u043b\u043b\u04e3 \u0434\u043e\u0434\u0430\u0435\u0434. \u0424\u0443\u043d\u043a\u0441\u0438\u044f\u0438 next_smallest \u043d\u0430\u0432\u0438\u0441\u0435\u0434, \u043a\u0438 \u0443\u043d\u0441\u0443\u0440\u0438 2-\u0438 \u0445\u0443\u0440\u0434\u0442\u0430\u0440\u0438\u043d\u0438 \u0440\u04ef\u0439\u0445\u0430\u0442\u0440\u043e \u0431\u0430\u0440\u043c\u0435\u0433\u0430\u0440\u0434\u043e\u043d\u0430\u0434. \u0410\u0433\u0430\u0440 \u0447\u0443\u043d\u0438\u043d \u0443\u043d\u0441\u0443\u0440 \u0432\u0443\u04b7\u0443\u0434 \u043d\u0430\u0434\u043e\u0448\u0442\u0430 \u0431\u043e\u0448\u0430\u0434, \u04b3\u0435\u04b7 \u0447\u0438\u0437\u0440\u043e \u0431\u0430\u0440\u043d\u0430\u0433\u0430\u0440\u0434\u043e\u043d\u0430\u0434. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == \u04b2\u0435\u04b7 \u0447\u0438\u0437 next_smallest (([1, 1]) == \u04b2\u0435\u04b7 \u0447\u0438\u0437\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"\u0428\u0443\u043c\u043e \u044f\u043a \u0440\u0430\u049b\u0430\u043c\u0438 \u0434\u0430\u04b3\u04e3 \u0434\u043e\u0434\u0430 \u043c\u0435\u0448\u0430\u0432\u0435\u0434 \u0432\u0430 \u0432\u0430\u0437\u0438\u0444\u0430\u0438 \u0448\u0443\u043c\u043e \u0438\u043d \u0430\u0441\u0442, \u043a\u0438 \u043e\u043d\u0440\u043e \u0431\u0430 \u0444\u043e\u0440\u043c\u0430\u0442\u0438 \u0434\u0443\u04e3 \u0442\u0430\u0431\u0434\u0438\u043b \u0434\u0438\u04b3\u0435\u0434. \u0424\u0443\u043d\u043a\u0441\u0438\u044f \u0431\u043e\u044f\u0434 \u0441\u0430\u0442\u0440\u0440\u043e \u0431\u0430\u0440\u0433\u0430\u0440\u0434\u043e\u043d\u0430\u0434, \u043a\u0438 \u04b3\u0430\u0440 \u044f\u043a \u0430\u043b\u043e\u043c\u0430\u0442 \u0440\u0430\u049b\u0430\u043c\u0438 \u0434\u0443\u04e3 \u043c\u0435\u0431\u043e\u0448\u0430\u0434. \u04b2\u0430\u0440 \u044f\u043a \u0430\u043b\u043e\u043c\u0430\u0442\u0438 \u0441\u0430\u0442\u0440 '0' \u0451 '1' \u0445\u043e\u04b3\u0430\u0434 \u0431\u0443\u0434. \u0414\u0430\u0440 \u0438\u0431\u0442\u0438\u0434\u043e \u0432\u0430 \u043e\u0445\u0438\u0440\u0438 \u0441\u0430\u0442\u0440 \u044f\u043a \u04b7\u0443\u0444\u0442\u0438 \u0430\u043b\u043e\u043c\u0430\u0442\u04b3\u043e\u0438 \u0438\u043b\u043e\u0432\u0430\u0433\u04e3 'db' \u0445\u043e\u04b3\u0430\u0434 \u0431\u0443\u0434. \u0410\u043b\u043e\u043c\u0430\u0442\u04b3\u043e\u0438 \u0438\u043b\u043e\u0432\u0430\u0433\u04e3 \u0431\u0430\u0440\u043e\u0438 \u043a\u04ef\u043c\u0430\u043a \u0431\u0430 \u0444\u043e\u0440\u043c\u0430\u0442 \u043c\u0430\u0432\u04b7\u0443\u0434\u0430\u043d\u0434. \u041c\u0438\u0441\u043e\u043b\u04b3\u043e: decimal_to_binary(15) # \"db1111db\" -\u0440\u043e \u0431\u0430\u0440\u0433\u0430\u0440\u0434\u043e\u043d\u0430\u0434 decimal_to_binary32) # \"db100000db\" -\u0440\u043e \u0431\u0430\u0440\u0433\u0430\u0440\u0434\u043e\u043d\u0430\u0434\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" \u0411\u043e \u043d\u0430\u0437\u0430\u0440\u0434\u043e\u0448\u0442\u0438 \u0440\u0430\u049b\u0430\u043c\u0438 \u043c\u0443\u0441\u0431\u0430\u0442\u0438 \u043d\u0443\u049b\u0442\u0430\u0438 \u0448\u0438\u043d\u043e\u043a\u0443\u043d\u0430\u043d\u0434\u0430, \u043e\u043d \u043c\u0435\u0442\u0430\u0432\u043e\u043d\u0430\u0434 \u0431\u0430 \u049b\u0438\u0441\u043c\u0438 \u0430\u0434\u0430\u0434 \u0432\u0430 \u049b\u0438\u0441\u043c\u0438 \u0430\u0434\u0430\u0434 (\u0431\u0443\u0437\u0443\u0440\u0433\u0442\u0430\u0440\u0438\u043d \u0430\u0434\u0430\u0434 \u0430\u0437 \u0430\u0434\u0430\u0434\u0438 \u0434\u043e\u0434\u0430\u0448\u0443\u0434\u0430 \u0445\u0443\u0440\u0434\u0442\u0430\u0440) \u0432\u0430 \u0434\u0430\u04b3\u04b3\u043e (\u049b\u0438\u0441\u043c\u0438 \u0431\u043e\u049b\u0438\u043c\u043e\u043d\u0434\u0430 \u04b3\u0430\u043c\u0435\u0448\u0430 \u0430\u0437 1 \u0445\u0443\u0440\u0434\u0442\u0430\u0440) \u04b7\u0443\u0434\u043e \u043a\u0430\u0440\u0434\u0430 \u0448\u0430\u0432\u0430\u0434. \u049a\u0438\u0441\u043c\u0438 \u0434\u0430\u04b3\u04b3\u043e\u04e3 \u0430\u0437 \u0430\u0434\u0430\u0434\u0440\u043e \u0431\u0430\u0440\u0433\u0430\u0440\u0434\u043e\u043d\u0435\u0434. \u041c\u0438\u0441\u043e\u043b:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Donat un enti\u00e8r positiu n, tornatz lo produch dels chifres impaires. Tornatz 0 se totes los chifres son par. Per exemple: chifres\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Per un nombre donat n, trobar lo mai grand nombre que divisa n egalament, mai pichon que n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Donat un array arr de enti\u00e8rs e un enti\u00e8r positiu k, tornatz una lista ordenada de longor k amb lo maxim k de nombres en arr. Exemple1: Intrada: arr = [-3, -4, 5], k = 3 Sortida: [-4, -3, 5] Exemple2: Intrada: arr = [4, -4, 4], k = 2 Sortida: [4, 4] Exemple3: Intrada: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Sortida: [2] N\u00f2ta: 1. la longor de l'arr ser\u00e0 dins la gama de [1, 1000]. 2. los elements dins l'arr ser\u00e0 dins la gama de [-1000, 1000]. 3. 0 <= k <= len (arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" La funci\u00f3n de retiru ye una funci\u00f3n de cuenta abierta que se va executar al travi\u00e9s d'un sistema de retiru abiertu.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"La funci\u00f3n de la matriz ye la siguiente: can_arrange{1,2,4,3,5]) = 3 can_arrange{1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"La secuence dai numars Fib4 e je une secuence simil a ch\u00ea di Fibbonacci che e je definide cuss\u00ec: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Dant une schirie che e rapresente un rama\u00e7 di un arbul che al \u00e0 nodis int\u00eers no negat\u00eefs il to compit al \u00e8 di cjoli un dai nodis e torn\u00e2lu. Il nod cjoli al var\u00e8s di jessi il nod cul val\u00f4r pari plui pi\u00e7ul. Se a son cjat\u00e2ts plui nodis cul stes val\u00f4r pari plui pi\u00e7ul, torne il nod che al \u00e0 il indi\u00e7 plui pi\u00e7ul. Il nod cjoli al var\u00e8s di jessi torn\u00e2t intune liste, [smallest_value, il so indi\u00e7], Se no son val\u00f4rs pari o la schirie dade e je vueide, torne []. Esempli 1: Input: [4,2,3] Output: [2, 1] Splicazion: 2 al \u00e0 il val\u00f4r pari plui pi\u00e7ul e 2 al \u00e0 l'indi\u00e7 plui pi\u00e7ul. Esempli 2: Input: [1,2,\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Liste di tornade cun elements increment\u00e2ts di 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Duke pasur parasysh gjat\u00ebsin\u00eb e nj\u00eb an\u00ebs dhe zon\u00ebn e kthimit t\u00eb lart\u00eb p\u00ebr nj\u00eb trek\u00ebnd\u00ebsh.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb varg 'tekst', kthehet vargu i tij ekuivalent md5 hash. N\u00ebse 'tekst' \u00ebsht\u00eb nj\u00eb varg i zbraz\u00ebt, kthehet Asnj\u00eb.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero merr nj\u00eb list\u00eb t\u00eb integers si nj\u00eb input. Ai kthen True n\u00ebse ka dy elemente t\u00eb dallueshme n\u00eb list\u00eb q\u00eb shuma n\u00eb zero, dhe False p\u00ebrndryshe.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    \u06cc\u06a9 \u062a\u0627\u0628\u0639 count_nums \u0628\u0646\u0648\u06cc\u0633\u06cc\u062f \u06a9\u0647 \u06cc\u06a9 \u0622\u0631\u0627\u06cc\u0647 \u0627\u0632 \u0627\u0639\u062f\u0627\u062f \u0635\u062d\u06cc\u062d \u0631\u0627 \u0645\u06cc \u06af\u06cc\u0631\u062f \u0648 \u062a\u0639\u062f\u0627\u062f \u0639\u0646\u0627\u0635\u0631\u06cc \u0631\u0627 \u06a9\u0647 \u0645\u062c\u0645\u0648\u0639 \u0631\u0642\u0645 \u0647\u0627\u06cc \u0622\u0646 > 0 \u0627\u0633\u062a \u0631\u0627 \u0628\u0627\u0632 \u0645\u06cc \u06af\u0631\u062f\u0627\u0646\u062f. \u0627\u06af\u0631 \u06cc\u06a9 \u0639\u062f\u062f \u0645\u0646\u0641\u06cc \u0628\u0627\u0634\u062f\u060c \u0627\u0648\u0644\u06cc\u0646 \u0631\u0642\u0645 \u0627\u0645\u0636\u0627 \u0634\u062f\u0647 \u0622\u0646 \u0645\u0646\u0641\u06cc \u062e\u0648\u0627\u0647\u062f \u0628\u0648\u062f: \u0628\u0647 \u0639\u0646\u0648\u0627\u0646 \u0645\u062b\u0627\u0644 -123 \u062f\u0627\u0631\u0627\u06cc \u0631\u0642\u0645 \u0647\u0627\u06cc \u0627\u0645\u0636\u0627 \u0634\u062f\u0647 -1\u060c 2 \u0648 3 \u0627\u0633\u062a.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u0639\u0646\u0627\u0635\u0631 \u0645\u0634\u062a\u0631\u06a9 \u0645\u0646\u062d\u0635\u0631 \u0628\u0647 \u0641\u0631\u062f \u0645\u0631\u062a\u0628 \u0634\u062f\u0647 \u0631\u0627 \u0628\u0631\u0627\u06cc \u062f\u0648 \u0644\u06cc\u0633\u062a \u0628\u0627\u0632 \u0645\u06cc \u06af\u0631\u062f\u0627\u0646\u062f.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    \u0628\u0627 \u062a\u0648\u062c\u0647 \u0628\u0647 \u062f\u0648 \u0639\u062f\u062f \u0635\u062d\u06cc\u062d \u0645\u062b\u0628\u062a a \u0648 b\u060c \u0627\u0639\u062f\u0627\u062f \u062c\u0641\u062a \u0628\u06cc\u0646 a \u0648 b \u0631\u0627 \u0628\u0647 \u062a\u0631\u062a\u06cc\u0628 \u0631\u0648 \u0628\u0647 \u0627\u0641\u0632\u0627\u06cc\u0634 \u0628\u0631\u06af\u0631\u062f\u0627\u0646\u06cc\u062f. \u0628\u0647 \u0639\u0646\u0648\u0627\u0646 \u0645\u062b\u0627\u0644: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"An ka x ni y jatiden fila fara \u0272\u0254g\u0254n kan\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero be jatidenw ta ka k\u025b a ka jatiden ye. A be true (ti\u0272\u025bn) di n'a s\u0254r\u0254 a ka jatiden saba be \u0272\u0254g\u0254n na, n'a sumani ye zero ye, n'a ma se a ma, a be false (hak\u025b).\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    A be baara k\u025b ni algebra ye ka algebra ka miiriya d\u0254 lab\u025bn ani ka a ka miiriya d\u0254 f\u0254. A be baara k\u025b ni algebra ka miiriya fila ye: a be farali k\u025b (+) ka d\u0254 b\u0254 (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-), ka d\u0254 fara (-),\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Pa namba n, sanga inambala iikalamba iyaba pa n iyacepa ukucila pali n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Mufwile ukulemba ifilundwa ifinga sambilila inshiku nga shalifikapo, elyo no kubwesesha true nga inshiku shalifikapo, nga tafilifikapo, ninshi false. Inshiku shifikapo nga ca kuti fyonse ifyalakonkapo fyafikilishiwa: 1. inshiku shalifikapo tafyali fyabula. 2. inshiku shalifikapo tafyacilamo 1 nangu ukucilapo pa nshiku 31 mu myeshi 1,3,5,7,8,10,12. Imiku ya nshiku tailipo yacilamo 1 nangu ukucilamo pa nshiku 30 mu myeshi 4,6,9,11. Imiku tailipo yacilamo 1 nangu ukucilamo pa nshiku 29 mu mweshi 2. Imyeshi tailingile ukuba yacilamo 1 nangu ukucilamo pa 12. Imiku ifwile ukuba mu cipasho ca: mm-dd-yyyy, pamo nga: valid_date (('03-11-2000') => true\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Moneni nga ca kuti inambala iilepeelwa n kuti yalembwa nge cipo ca namba 4 ishili ishili ishikali. Icakumwenako is_equal_to_sum_even ((4) == Bufi is_equal_to_sum_even ((6) == Bufi is_equal_to_sum_even ((8) == Cishinka\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list of length k with the maximum k numbers in arr. Example1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Example2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Example3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Note: 1.\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"T\u00fa hevur tvey intervall, har hv\u00f8rt intervall er eitt pari av heilum t\u00f8lum. T.d. intervall = (start, end) = (1, 2). T\u00e6r givnu intervallini eru stongd, sum merkir, at intervall (start, end) inniheldur b\u00e6\u00f0i start og end. Fyri hv\u00f8rt givi\u00f0 intervall ver\u00f0ur rokna\u00f0 vi\u00f0, at starturin er minni enn ella l\u00edka vi\u00f0 endin. T\u00edn uppg\u00e1va er at finna \u00fat av, um longdin \u00e1 skerjingini av hesum b\u00e1\u00f0um intervallum er eitt primtal. D\u00f8mi: Skeringin av intervallunum (1, 3), (2, 4) er (2, 3) sum hevur longdina 1, sum ikki er eitt primtal. Um longdin \u00e1 skerjingini er eitt primtal, sendur t\u00fa \"JA\", annars sendur t\u00fa \"NEI\". Um teir b\u00e1\u00f0ir intervallini ikki skerjast, sendir t\u00fa \"NEI\". [input\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Vi\u00f0 einum talvi av heilum t\u00f8lum, ra\u00f0fest \u00f8ll t\u00f8lini, sum eru millum 1 og 9, vend t\u00ed \u00farslitinum og skift s\u00ed\u00f0ani hv\u00f8rt talv \u00fat vi\u00f0 s\u00edtt samsvarandi navn fr\u00e1 \"Ein\", \"Tveir\", \"Tr\u00ed\", \"Fyri\", \"Fyri\", \"Seks\", \"Sjey\", \"Eitt\", \"N\u00edn\". T.d.: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ra\u00f0fest arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"Eitt\", \"Fyri\", \"Tveir\", \"Tveir\", \"Tveir\", \"Eitt\", \"Eitt\"] Um talvi er t\u00f3m, send eitt talv aftur: arr = [] return [] Um talvi hevur naka\u00f0 fremmant tal, ignorera ta\u00f0: arr =\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"n \u0915\u093e \u0938\u092c\u0938\u0947 \u092c\u0921\u093c\u093e \u0905\u092d\u093e\u091c\u094d\u092f \u0917\u0941\u0923\u0928\u0916\u0902\u0921 \u0932\u094c\u091f\u093e\u0908. \u092e\u093e\u0928 \u0932\u0947\u0902 \u0915\u093f n > 1 \u0939\u0948 \u0914\u0930 \u0905\u092d\u093e\u091c\u094d\u092f \u0938\u0902\u0916\u094d\u092f\u093e \u0928\u0939\u0940\u0902 \u0939\u0948.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u090f\u0915 \u092b\u093c\u0902\u0915\u094d\u0936\u0928 \u0939\u0948 \u091c\u094b 1 \u0938\u0947 n \u0924\u0915 \u0915\u0940 \u0938\u0902\u0916\u094d\u092f\u093e\u0913\u0902 \u0915\u093e \u092f\u094b\u0917 \u0932\u0917\u093e\u0924\u093e \u0939\u0948.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"\u05e9\u05d0\u05b7\u05e4\u05bf\u05df \u05d0\u05b7 \u05e4\u05d5\u05e0\u05e7\u05e6\u05d9\u05e2 \u05d5\u05d5\u05d0\u05b8\u05e1 \u05e0\u05e2\u05de\u05d8 \u05d0\u05b7 \u05e9\u05d8\u05e8\u05d9\u05e7\u05dc \u05d5\u05d5\u05d0\u05b8\u05e1 \u05e8\u05e2\u05e4\u05bc\u05e8\u05d9\u05d6\u05e2\u05e0\u05e5 \u05d0\u05b7 \u05d8\u05e2\u05e7\u05e2 \u05e1 \u05e0\u05d0\u05b8\u05de\u05e2\u05df, \u05d0\u05d5\u05df \u05e8\u05d9\u05d8\u05d5\u05e8\u05e0\u05e1 '\u05d9\u05d0' \u05d0\u05d5\u05d9\u05d1 \u05d3\u05d9 \u05d8\u05e2\u05e7\u05e2 \u05e1 \u05e0\u05d0\u05b8\u05de\u05e2\u05df \u05d0\u05d9\u05d6 \u05d2\u05d9\u05dc\u05d8\u05d9\u05e7, \u05d0\u05d5\u05df \u05e8\u05d9\u05d8\u05d5\u05e8\u05e0\u05e1 '\u05e0\u05d9\u05d9\u05df' \u05d0\u05b7\u05e0\u05d3\u05e2\u05e8\u05e9. \u05d0\u05b7 \u05d8\u05e2\u05e7\u05e2 \u05e1 \u05e0\u05d0\u05b8\u05de\u05e2\u05df \u05d0\u05d9\u05d6 \u05d2\u05e2\u05d4\u05d0\u05dc\u05d8\u05df \u05e6\u05d5 \u05d6\u05d9\u05d9\u05df \u05d2\u05d9\u05dc\u05d8\u05d9\u05e7 \u05d0\u05d5\u05d9\u05d1 \u05d0\u05d5\u05df \u05d1\u05dc\u05d5\u05d9\u05d6 \u05d0\u05d5\u05d9\u05d1 \u05d0\u05b7\u05dc\u05e2 \u05d3\u05d9 \u05e4\u05d0\u05dc\u05d2\u05e2\u05e0\u05d3\u05e2 \u05d1\u05d0\u05d3\u05d9\u05e0\u05d2\u05d5\u05e0\u05d2\u05e2\u05df \u05d6\u05e2\u05e0\u05e2\u05df \u05d1\u05d0\u05d2\u05e2\u05d2\u05e0\u05d8: - \u05e2\u05e1 \u05d6\u05d0\u05b8\u05dc \u05e0\u05d9\u05d8 \u05d6\u05d9\u05d9\u05df \u05de\u05e2\u05e8 \u05d5\u05d5\u05d9 \u05d3\u05e8\u05d9\u05d9\u05b7 \u05d3\u05d9\u05d3\u05d6\u05e9\u05d9\u05e5 ('0'-'9') \u05d0\u05d9\u05df \u05d3\u05d9 \u05d8\u05e2\u05e7\u05e2 \u05e1 \u05e0\u05d0\u05b8\u05de\u05e2\u05df. - \u05d3\u05d9 \u05d8\u05e2\u05e7\u05e2 \u05e1 \u05e0\u05d0\u05b8\u05de\u05e2\u05df \u05db\u05bc\u05d5\u05dc\u05dc \u05e4\u05bc\u05d5\u05e0\u05e7\u05d8 \u05d0\u05d9\u05d9\u05df \u05e4\u05bc\u05d5\u05e0\u05e7\u05d8 '.' - \u05d3\u05d9 \u05e1\u05d0\u05b7\u05d1\u05e1\u05d8\u05e8\u05d0\u05b7\u05e0\u05d2 \u05d0\u05d9\u05d9\u05d3\u05e2\u05e8 \u05d3\u05d9 \u05e4\u05bc\u05d5\u05e0\u05e7\u05d8 \u05d6\u05d0\u05b8\u05dc \u05e0\u05d9\u05e9\u05d8 \u05d6\u05d9\u05d9\u05df \u05dc\u05d9\u05d9\u05d3\u05d9\u05e7, \u05d0\u05d5\u05df \u05e2\u05e1 \u05d4\u05d9\u05d9\u05d1\u05d8 \u05de\u05d9\u05d8 \u05d0\u05b7 \u05d1\u05e8\u05d9\u05d5\u05d5 \u05e4\u05d5\u05df \u05d3\u05d9 \u05dc\u05d0\u05b7\u05d8\u05d9\u05d9\u05b7\u05df \u05d0\u05b7\u05dc\u05e4\u05d0\u05b7\u05e4\u05e2 ('\u05d0\u05b7'-'\u05d6' \u05d0\u05d5\u05df '\u05d0\u05b7'-\u05d6'). - \u05d3\u05d9 \u05e1\u05d0\u05b7\u05d1\u05e1\u05d8\u05e8\u05d0\u05b7\u05e0\u05d2 \u05e0\u05d0\u05b8\u05da \u05d3\u05d9 \u05e4\u05bc\u05d5\u05e0\u05e7\u05d8 \u05d6\u05d0\u05b8\u05dc \u05d6\u05d9\u05d9\u05df \u05d0\u05d9\u05d9\u05e0\u05e2\u05e8 \u05e4\u05d5\u05df \u05d3\u05d9 \u05e4\u05d0\u05dc\u05d2\u05e2\u05e0\u05d3\u05e2: ['\u05d8\u05e7\u05e1\u05d8',\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" \u05d0\u05d9\u05df \u05d3\u05e2\u05dd \u05e4\u05d5\u05e0\u05e7\u05e6\u05d9\u05e2 \u05d0\u05d9\u05d6 \u05d0 \u05e1\u05d8\u05e8\u05d9\u05e0\u05d2 \u05d5\u05d5\u05d0\u05e1 \u05e8\u05e2\u05e4\u05e8\u05e2\u05d6\u05e2\u05e0\u05d8\u05d9\u05e8\u05d8 \u05de\u05e2\u05e8\u05e2\u05e8\u05e2 \u05d2\u05e8\u05d5\u05e4\u05e2\u05e1 \u05e4\u05d0\u05e8 \u05e0\u05e2\u05e1\u05d8\u05e2\u05d3 \u05e7\u05e8\u05e2\u05e0\u05d8\u05e2\u05d6\u05e2\u05e1 \u05d0\u05e4\u05d2\u05e2\u05e9\u05d9\u05d9\u05d3\u05d8 \u05d3\u05d5\u05e8\u05da \u05e1\u05e4\u05e2\u05d9\u05e1\u05e2\u05e1. \u05e4\u05d0\u05e8 \u05d9\u05e2\u05d3\u05e2 \u05e4\u05d5\u05df \u05d3\u05d9 \u05d2\u05e8\u05d5\u05e4\u05e2\u05e1, \u05dc\u05d9\u05d9\u05d2\u05d8 \u05de\u05e2\u05df \u05d0\u05e8\u05d5\u05d9\u05e1 \u05d3\u05d9 \u05d8\u05d9\u05e4\u05e2\u05e1\u05d8\u05e2 \u05e0\u05d9\u05d5\u05d5\u05e2\u05dc \u05e4\u05d5\u05df \u05e0\u05e2\u05e1\u05d8\u05e2\u05d3 \u05e7\u05e8\u05e2\u05e0\u05d8\u05e2\u05d6\u05e2\u05e1. \u05dc\u05de\u05e9\u05dc (() (()) \u05d4\u05d0\u05d8 \u05de\u05d0\u05e7\u05e1\u05d9\u05de\u05d5\u05dd \u05e6\u05d5\u05d5\u05d9\u05d9 \u05e0\u05d9\u05d5\u05d5\u05e2\u05dc\u05e1 \u05e4\u05d5\u05df \u05e0\u05e2\u05e1\u05d8\u05e2\u05d3 \u05e7\u05e8\u05e2\u05e0\u05d8\u05e2\u05d6\u05e2\u05e1 \u05d1\u05e9\u05e2\u05ea ((())) \u05d4\u05d0\u05d8 \u05d3\u05e8\u05d9\u05d9.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u05e9\u05e8\u05f2\u05b7\u05d1\u05df \u05d0\u05b7 \u05e4\u05bf\u05d5\u05e0\u05e7\u05e6\u05d9\u05e2 \u05d5\u05d5\u05d0\u05b8\u05e1 \u05e0\u05e2\u05de\u05d8 \u05d0\u05b7 \u05e9\u05d8\u05e8\u05d9\u05e7\u05dc \u05d0\u05d5\u05df \u05d2\u05d9\u05d8 \u05e6\u05d5\u05e8\u05d9\u05e7 \u05d0\u05b7 \u05d0\u05b8\u05e8\u05d3\u05e2\u05e8\u05d3 \u05d5\u05d5\u05e2\u05e8\u05e1\u05d9\u05e2 \u05e4\u05d5\u05df \u05d0\u05d9\u05dd. \u05d0\u05b8\u05e8\u05d3\u05e2\u05e8\u05d3 \u05d5\u05d5\u05e2\u05e8\u05e1\u05d9\u05e2 \u05e4\u05d5\u05df \u05e9\u05d8\u05e8\u05d9\u05e7\u05dc, \u05d0\u05d9\u05d6 \u05d0\u05b7 \u05e9\u05d8\u05e8\u05d9\u05e7\u05dc \u05d5\u05d5\u05d5\u05bc \u05d0\u05b7\u05dc\u05e2 \u05d5\u05d5\u05e2\u05e8\u05d8\u05e2\u05e8 (\u05e1\u05e4\u05bc\u05d0\u05b7\u05e8\u05e2\u05e1\u05d8 \u05d3\u05d5\u05e8\u05da \u05e4\u05bc\u05dc\u05d0\u05b7\u05e5) \u05d6\u05e2\u05e0\u05e2\u05df \u05e8\u05d9\u05e4\u05bc\u05dc\u05d9\u05d9\u05e1\u05d8 \u05d3\u05d5\u05e8\u05da \u05d0\u05b7 \u05e0\u05d9\u05d9\u05b7 \u05d5\u05d5\u05d0\u05b8\u05e8\u05d8 \u05d5\u05d5\u05d5\u05bc \u05d0\u05b7\u05dc\u05e2 \u05d3\u05d9 \u05d0\u05d5\u05ea\u05d9\u05d5\u05ea \u05d6\u05e2\u05e0\u05e2\u05df \u05e2\u05e8\u05d9\u05d9\u05e0\u05d3\u05d6\u05e9\u05d3 \u05d0\u05d9\u05df \u05d0\u05b7\u05e1\u05d9\u05e0\u05d3\u05e2\u05e0\u05d3\u05d9\u05e0\u05d2 \u05e1\u05d3\u05e8 \u05d1\u05d0\u05d6\u05d9\u05e8\u05d8 \u05d0\u05d5\u05d9\u05e3 \u05d0\u05b7\u05e1\u05e7\u05d9 \u05d5\u05d5\u05e2\u05e8\u05d8. \u05d1\u05d0\u05b7\u05de\u05e2\u05e8\u05e7\u05d5\u05e0\u05d2: \u05d0\u05d9\u05e8 \u05d6\u05d0\u05b8\u05dc \u05d4\u05d0\u05b7\u05dc\u05d8\u05df \u05d3\u05d9 \u05e1\u05d3\u05e8 \u05e4\u05d5\u05df \u05d5\u05d5\u05e2\u05e8\u05d8\u05e2\u05e8 \u05d0\u05d5\u05df \u05dc\u05d9\u05d9\u05d3\u05d9\u05e7 \u05e1\u05e4\u05bc\u05d9\u05d9\u05e1\u05d0\u05b7\u05d6 \u05d0\u05d9\u05df \u05d3\u05d9 \u05d6\u05d0\u05b7\u05e5. \u05dc\u05de\u05e9\u05dc: anti_shuffle ((('Hi') \u05d2\u05d9\u05d8 \u05e6\u05d5\u05e8\u05d9\u05e7 'Hi' anti_shuffle ((('hello') \u05d2\u05d9\u05d8 \u05e6\u05d5\u05e8\u05d9\u05e7 'ehllo' anti_shuffle (('Hello World!!!') \u05d2\u05d9\u05d8 \u05e6\u05d5\u05e8\u05d9\u05e7 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \u0907\u0928\u092a\u0941\u091f \u091b\u0942 \u0938\u094d\u092a\u0947\u0938-\u0921\u093f\u0932\u0940\u092e\u093f\u091f\u0947\u0921 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u0928\u0941\u092e\u093e\u0930\u093f\u0915\u093e\u0932\u0938 \u0938\u0947\u0924 '\u091c\u093c\u0940\u0930\u094b' \u092a\u0947\u0920 '\u0928\u094c'. \u0935\u0948\u0932\u093f\u0921 \u091a\u0949\u0907\u0938 \u091b\u0942 '\u091c\u093c\u0940\u0930\u094b', '\u0935\u0928', '\u091f\u0942', '\u0925\u094d\u0930\u0940', '\u092b\u094b\u0930', '\u092b\u093e\u0907\u0935', '\u0936\u093f\u0915\u094d\u0938', '\u0938\u0947\u0935\u0947\u0928', '\u0906\u0920' \u0924\u0947 '\u0928\u094c'. \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u091b\u0942 \u0928\u0902\u092c\u0930 \u0938\u0947\u0924 \u0932\u0915\u0941\u091f \u092a\u0947\u0920 \u092c\u0941\u0921 \u0924\u093e\u092e \u0938\u0949\u0930\u094d\u091f \u0915\u0930\u0928\u0947 \u0905\u092e\u0943\u0924.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    \u0905\u0917\u0930 \u0905\u0938 \u0928\u0947\u0917\u0947\u091f\u093f\u0935 \u0907\u0902\u091f\u0947\u091c\u0930\u0938 \u0928\u0949\u0928 -\u092e\u0948\u0930\u093f\u091c,\u0924\u0947\u092e \u091b\u0940 \u0915\u093e\u0930\u0928 \u0935\u093e\u092a\u0938 \u0915\u0949\u092a\u0940,\u0905\u0924\u0903 \u092a\u0920 \u091b\u0940 \u0905\u0938 \u0915\u093e\u0930\u0928 \u0938\u0949\u0930\u094d\u091f \u0905\u0917\u0930 \u0905\u0938\u0941\u092e (\u0917\u094b\u0921\u094d\u0928\u0941\u0907\u0915 \u0907\u0902\u0921\u0947\u0915\u094d\u0938 \u0935\u0948\u0932\u094d\u092f\u0942,\u0932\u0938\u094d\u091f \u0907\u0902\u0921\u0947\u0915\u094d\u0938 \u0935\u0948\u0932\u094d\u092f\u0942) \u091b\u0940 \u0947\u092a\u0949\u0930,\u092f\u093e \u091b\u0940 \u0905\u0938 \u0915\u093e\u0930\u0928 \u0938\u0949\u0930\u094d\u091f \u0905\u0917\u0930 \u0905\u0938\u0941\u092e (\u0917\u094b\u0921\u094d\u0928\u0941\u0907\u0915 \u0907\u0902\u0921\u0947\u0915\u094d\u0938 \u0935\u0948\u0932\u094d\u092f\u0942,\u0932\u0938\u094d\u091f \u0907\u0902\u0921\u0947\u0915\u094d\u0938 \u0935\u0948\u0932\u094d\u092f\u0942) \u091b\u0940 \u091c\u094b\u0921\u093c\u0947 \u0928\u094b\u091f: * \u092e\u0924 \u091a\u0947\u0902\u091c \u0915\u0930\u094b \u0926\u093f\u091a\u0924 \u092e\u0948\u0930\u093f\u091c \u092e\u093f\u0938\u093e\u0932: * sort_array [ ] => [] * sort_array [ ] => [5] * sort_array [2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array [2, 4, 3, 0, 1, 5, 6]) [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \u0907\u0928\u092a\u0941\u091f \u0915\u0930\u0928\u0947 \u0916\u093e\u0924\u0930 \u092f\u0947 \u092b\u0902\u0915\u094d\u0936\u0928 \u091b\u0940 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917 \u092f\u0941\u0938 \u0939\u0935\u0928 \u091b\u0940 \u092e\u094d\u092f\u0942\u091c\u093f\u0915\u0932 \u0928\u094b\u091f\u094d\u0938 \u0938\u094d\u092a\u0947\u0936\u0932 ASCII \u092b\u0949\u0930\u094d\u092e\u0947\u091f \u092e\u0902\u091c\u093c.\u0905\u0938 \u091b\u0940 \u0906\u0938\u093e\u0928 \u0924\u0941\u0939\u094d\u092e\u0940\u0902 \u0915\u093e\u092e \u0915\u0940 \u0924\u0930\u093e\u091c\u093c \u0915\u0930\u094b \u0905\u0925 \u0938\u094d\u091f\u094d\u0930\u093f\u0902\u0917\u094d\u0938 \u092c\u0947 \u0930\u093f\u091f\u0930\u094d\u0928 \u0915\u0930\u094b \u0907\u0902\u091f\u093f\u091c\u0930 \u0932\u093f\u0938\u094d\u091f \u092f\u0941\u0938 \u091b\u0940 \u0915\u093e\u0930\u0928 \u091c\u0935\u093e\u092c \u0915\u0940\u0925 \u092a\u093e\u0920 \u091b\u0940 \u092c\u0940\u091f\u094d\u0938 \u0939\u0930 \u0906\u0916\u0903 \u091b\u093e\u0928 \u0915\u093e\u0930\u0928.\u092f\u0947 \u091b\u0940 \u0932\u0947\u091c\u0947\u0902\u0921: 'o' -\u0938\u0932\u0940\u092e \u0928\u094b\u091f,\u092f\u0947 \u091b\u0940 \u0915\u093e\u0930\u0928 4 \u092c\u0940\u091f\u094d\u0938 'o\" -\u0939\u093e\u092b \u0928\u094b\u091f,\u092f\u0947 \u091b\u0940 \u0915\u093e\u0930\u0928 2 \u092c\u0940\u091f\u094d\u0938 '\" -\u0915\u094d\u0935\u093e\u091f\u0930 \u0928\u094b\u091f,\u092f\u0947 \u091b\u0940 \u0915\u093e\u0930\u0928 1 \u092c\u0940\u091f\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Ilzam ad ikteb alxidmat ta tikna am\u0161\u01ddkki n data tolas ad t id isammuti tiditt a fal am\u0161\u01ddkki wen eqqal am\u0161\u01ddkki n data fal war eqqel am\u0161\u01ddkki n data eqqalan am\u0161\u01ddkki n data a fal fal ilzam achare\u0263a tan win fuk: 1. am\u0161\u01ddkki wan data war eqqel ebas 2. iddikud n awtay war ifnaz fal 1 me\u0263 ojjar 31 n awtay i awtay wan 1,3,5,7,8,10,12 d iddikud n awtay war ifnaz fal 1 me\u0263 ojjar 30 n awtay i awtay wan 4,6,9,11 d iddikud n awtay war ifnaz fal 1 me\u0263 ojjar 29 i awtay wan 2 3. awtay war addobat ad ifnaz fal 1 me\u0263 ojjar 12 4. am\u0161\u01ddkki wan data ilzam ad eqqil da\u0263 dumu: mm-dd-\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    \"Aqalan ayknan fal \"\"t\"\" \u0259n magrad \u0259d \u0259\u0161i\u0263il iness eqal asikin \u0259n ma\u0257in \u0259n t\u0259muqunen. \"T\u0259muqunen aqalnat t\u0259muqunen as \"\"I\"\"\". \"\u018f\u0161i\u0263ilan aqalnen ayknan fal \"\"\", \"\"?\" me\u0263 \"\"!\"\".\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Ye t\u0259zunt \u0259n t\u0259zunt, alil \u0259n \u0259ma\u0257inan madroynen d\u01ce\u0263 \u0259ma\u0257inan maqornen \u0259d maqornen d\u01ce\u0263 \u0259ma\u0257inan madroynen.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"S\u025b wode \u0254fra a, ma no nsensan a \u025bmu nsensan ne nsensan a \u025bmu nsensan.\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Wode wo ho ato integers ho. Twer\u025b next_smallest () a \u025bde no b\u025bsan ak\u0254ma no s\u025b no y\u025b no mu no mu no mu no mu no mu no mu no mu no mu no mu no mu no mu no mu no mu no mu no mu no.\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    S\u025b w'anya text string bi a, fa nsesae\u025b nyinaa hy\u025b ase, na s\u025b string no w\u0254 nsesae\u025b a \u025bboro 2 a, fa nsesae\u025b a \u025btoa so no nyinaa hy\u025b - fix_spaces ((\"Example\") == \"Example\" fix_spaces ((\"Example1\") == \"Example_1\" fix_spaces (((\"Example2\") == \"_Example_2\" fix_spaces ((\"Example 3\") == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero \u0dba\u0db1\u0dd4 \u0db4\u0dd6\u0dbb\u0dca\u0dab \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0d9a\u0dca \u0d86\u0daf\u0dcf\u0db1\u0dba\u0d9a\u0dca \u0dbd\u0dd9\u0dc3 \u0d9c\u0db1\u0dd3. \u0d91\u0dba True \u0db1\u0dd0\u0dc0\u0dad \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1\u0dda \u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0dda \u0dc0\u0dd9\u0db1\u0db8 \u0d85\u0d82\u0d9c \u0daf\u0dd9\u0d9a\u0d9a\u0dca \u0dad\u0dd2\u0db6\u0dda \u0db1\u0db8\u0dca \u0d91\u0db8 \u0dc3\u0d82\u0d9b\u0dca \u0dba\u0dcf\u0dc0 \u0dc1\u0dd4\u0db1\u0dca \u0dba \u0dc0\u0db1 \u0d85\u0dad\u0dbb False \u0dc0\u0dd9\u0db1\u0dad\u0dca \u0d86\u0d9a\u0dcf\u0dbb\u0dba\u0d9a\u0dd2\u0db1\u0dca.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"\u0dbd\u0dd0\u0dba\u0dd2\u0dc3\u0dca\u0dad\u0dd4\u0dc0\u0dda \u0d87\u0dad\u0dd2 \u0dc3\u0dd2\u0dba\u0dbd\u0dd4\u0db8 \u0d85\u0d82\u0d9a\u0dba\u0db1\u0dca t \u0d85\u0d9c\u0dba \u0dba\u0da7\u0dad\u0dda \u0dad\u0dd2\u0db6\u0dda \u0db1\u0db8\u0dca True \u0dbd\u0dd9\u0dc3 \u0dbd\u0db6\u0dcf \u0daf\u0dd9\u0db1\u0dca\u0db1.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Urutonde rw'indome, rwerekana indome zitandukanijwe n'izindi (utarinze kuraba inyuguti nini canke ntoya)\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Uhabwa amakuru yo muburyo bubiri, nk'urutonde rw'ibisigi, bisa n'umurongo, ariko, bitandukanye n'imirongo, buri murongo ushobora kuba urimwo igitigiri c'inkingi zitandukanye. Dufatiye kuri lst, na integero x, shaka integero x murutonde, hanyuma ugaruke urutonde rw'ibisigi, [(x1, y1), (x2, y2)...] kuburyo buri tuple ari coordonate - (umurongo, inkingi), itangurira kuri 0. Gena ibiharuro vy'inkingi mu buryo bw'inyongera. Ikindi, dutondeke ibiharuro vy'umurongo mu nkingi mu buryo bw'inyongera. Ingero: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 0, 1, 4], 0 (2, 5), (2, 0\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Aliyense amadziwa Fibonacci ndondomeko, izo anaphunzira kwambiri ndi masamu mu awiri otsiriza zaka. Komabe, chimene anthu sadziwa ndi Tribonacci ndondomeko. Tribonacci ndondomeko chimatanthauzidwa ndi kubwereza: tri(1) = 3 tri(n) = 1 + n \/ 2, ngati n ndi ngakhale. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ngati n ndi wosamvetseka. Mwachitsanzo: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Inu anapatsidwa sanali zoipa integer number n, inu ndi kubwerera mndandanda wa woyamba n + 1 manambala a Tribonacci ndondomeko. Zitsanzo: tri(3) = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Popeza ndi zabwino variable mfundo chiwerengero, izo zikhoza kugawidwa mu ndi integer gawo (lalikulu integer ang'onoang'ono kuposa anapatsidwa chiwerengero) ndi decimals (kumanzere gawo nthawi zonse ang'onoang'ono kuposa 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Ngati s[i] ndi kalata, sinthani m'munsi mwake kuchokera pansi kupita pamwamba kapena vice versa, apo ayi sungani momwe ziliri. Ngati chingwecho chilibe zilembo, sinthani chingwecho. Ntchitoyi iyenera kubweza chingwe chotsatira. Zitsanzo kuthetsa ((\"1234\") = \"4321\" kuthetsa ((\"ab\") = \"AB\" kuthetsa ((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib nagbalik hin n-th nga numero nga usa nga Fibonacci nga numero ngan primo liwat.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Ibalik an totoo kon an ginhatag nga numero primo, ngan sayop kon diri.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"An median han mga elemento ha lista nga l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Dado un entero positivo n, devuelve el recuento de los n\u00fameros de los enteros positivos de n d\u00edgitos que comienzan o terminan con 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" \u0546\u0565\u0580\u0564\u0580\u0565\u0584 \"\u0574\u0565\u0580\u0571\u0561\u056f\u0561\u0575\u0578\u0572\" \u0569\u056b\u057e\u0568 \u0574\u0578\u0582\u057f\u0584\u0561\u0563\u0580\u0574\u0561\u0576 \u0581\u0578\u0582\u0581\u0561\u056f\u056b \u0575\u0578\u0582\u0580\u0561\u0584\u0561\u0576\u0579\u0575\u0578\u0582\u0580 \u0565\u0580\u056f\u0578\u0582 \u0570\u0561\u057b\u0578\u0580\u0564\u0561\u056f\u0561\u0576 \u057f\u0561\u0580\u0580\u0565\u0580\u056b \u0574\u056b\u057b\u0565\u0582'`numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    \u054f\u057e\u0561\u056e \u0561\u0574\u0562\u0578\u0572\u057b \u0569\u057e\u0565\u0580\u056b \u0565\u0582 k \u0564\u0580\u0561\u056f\u0561\u0576 \u0561\u0574\u0562\u0578\u0572\u057b \u0569\u057e\u0565\u0580\u056b \u0577\u0561\u0580\u0584\u0568, \u057e\u0565\u0580\u0561\u0564\u0561\u0580\u0571\u0565\u0584 k \u0565\u0580\u056f\u0561\u0580\u0578\u0582\u0569\u0575\u0561\u0576 \u0564\u0561\u057d\u0561\u057e\u0578\u0580\u057e\u0561\u056e \u0581\u0578\u0582\u0581\u0561\u056f\u0568 arr- \u056b \u0561\u057c\u0561\u057e\u0565\u056c\u0561\u0563\u0578\u0582\u0575\u0576 k \u0569\u057e\u0565\u0580\u0578\u057e: \u0555\u0580\u056b\u0576\u0561\u056f1: \u0544\u0578\u0582\u057f\u0584: arr = [-3, -4, 5], k = 3 \u0531\u0580\u057f\u0561\u0564\u0580\u0561\u0576\u0584: [-4, -3, 5] \u0555\u0580\u056b\u0576\u0561\u056f2: \u0544\u0578\u0582\u057f\u0584: arr = [4, -4, 4], k = 2 \u0531\u0580\u057f\u0561\u0564\u0580\u0561\u0576\u0584: [4, 4] \u0555\u0580\u056b\u0576\u0561\u056f3: \u0544\u0578\u0582\u057f\u0584: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 \u0531\u0580\u057f\u0561\u0564\u0580\u0561\u0576\u0584: [2] \u0546\u0577\u0578\u0582\u0574. 1. \u0531\u0580\u056b \u0565\u0580\u056f\u0561\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0568 \u056f\u056c\u056b\u0576\u056b [1, 1000] \u0574\u056b\u057b\u0561\u056f\u0561\u0575\u0584\u0578\u0582\u0574: 2. \u0531\u0580\u056b \u057f\u0561\u0580\u0580\u0565\u0580\u0568 \u056f\u056c\u056b\u0576\u0565\u0576 [-1000, 1000] \u0574\u056b\u057b\u0561\u056f\u0561\u0575\u0584\u0578\u0582\u0574: 3. 0 <= k <= len ((arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Naited kenka ti listaan dagiti numero. Masapul nga isublim ti dagup dagiti kuadrado a numero iti naited a listaan, pagkurosem ti tunggal elemento iti listaan iti akinngato a int ((Ceiling) nga umuna. Dagiti pagarigan: Para iti lst = [1,2,3] ti output ket masapul a 14 Para iti lst = [1,4,9] ti output ket masapul a 98 Para iti lst = [1,3,5,7] ti output ket masapul a 84 Para iti lst = [1.4,4.2,0] ti output ket masapul a 29 Para iti lst = [-2.4,1,1] ti output ket masapul a 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Maited kenka ti maysa a string ti balikas, ken ti trabahom ket bilangen ti bilang dagiti na-bored. Ti na-bored ket maysa a sentensia a mangrugi iti sao nga \"I\". Dagiti sentensia ket na-delimitaran babaen ti '.', '?' wenno '!'. Kas pagarigan:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Naited kenka ti listaan dagiti entero. Isurat ti maysa a pagannurotan ti sumaruno_kabassitan() a mangited ti maikadua a kabassitan nga elemento iti listaan. Agsubli ti Awan no awan ti kasta nga elemento. sumaruno_kabassitan([1, 2, 3, 4, 5]) == 2 sumaruno_kabassitan([5, 1, 4, 3, 2]) == 2 sumaruno_kabassitan([]) == Awan ti sumaruno_kabassitan([1, 1]) == Awan\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Qhichwa simipi: \" '30 \"'nisqaqa huk [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi.\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs nisqaqa huk polinomiopa coeficientesninmi. xs[0] + xs[1] * x + xs[2] * x^2 +....\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Kaypi qillqasqa: \" 'Hello \"'nisqaqa huk [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kastilla simi]]pi]] [[kastilla simi]]pi [[kasti\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Pou yon nimewo n bay, jwenn pi gwo nimewo ki divize n menm jan, pi piti pase n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filtre yon lis opinyon de strings s\u00e8lman pou moun ki k\u00f2manse ak yon prefiks bay yo.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Oweebwa olunyiriri olukiikirira olunyiriri, olunyiriri lulimu ebigambo ebyawuddwamu akabonero, era olina okuzza olunyiriri oluliko ebigambo okuva mu lunyiriri olubaddewo, obuwanvu bwabyo nga bubeera nnamba entuufu, enkola y'ebigambo mu lunyiriri oluggya erina okuba nga y'emu ng'olunyiriri olubaddewo. Ekyokulabirako1: Okuyingira: olunyiriri = \"Kino kigezo\" Okufuluma: \"kyali\" Ekyokulabirako2: Okuyingira: olunyiriri = \"tugende okuwuga\" Okufuluma: \"genda\" Obumu: * 1 <= len(olunyiriri) <= 100 * Olunyiriri lulimu ennukuta zokka\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Oweebwa ekiwandiiko ekifaanana nga ekiwandiiko ekifaanana nga matrix, naye obutafaanana matrix, buli layini eyinza okubaamu ennamba ya layini ez'enjawulo. Nga waliwo lst, n'omuwendo ogujjuvu x, funa ennamba entuufu x mu liiso, era ozzeemu olukalala lw'ebibinja, [(x1, y1), (x2, y2)...] ng'ebitundu byonna bibeera n'obukiiko - (mulongo, ebikumi), nga butandika ne 0. Ssaako ebikumi mu layini mu ngeri ey'okweyongerayo. Ate era, ssaako ebikumi mu layini mu bikumi mu ngeri ey'okuddirira. Ebyokulabirako: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Ojja kuweebwa olunyiriri lw'ebigambo eby'okwawulwa n'ebikomo oba ebikalu. Omulimu gwo kwe kwawula olunyiriri mu bigambo n'okuddamu olunyiriri lw'ebigambo. Okugeza: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string (((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test eger string day\u00een palindrome ye \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input ji bo v\u00ea fonksiyon\u00ea a string ku t\u00ea de kom\u00ean multiple ji parenteses nested e. armanca te ew e ku ji wan kom\u00ean nav string cuda cuda \u00fb vegera l\u00eesteya wan. kom\u00ean cuda bi hevseng (her brace vekir\u00ee bi awayek\u00ee rast girt\u00ee ye) \u00fb ne nested di nav hevdu de ne.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nHing\u00ea b\u00fbyer\u00ean test\u00ea z\u00eade bikin.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u098f\u099f\u09be \u09ac\u09b9\u09c1\u09aa\u09a6\u09c0\u09af\u09bc\u09f0 \u09b8\u09b9\u0997\u09ac\u09cb\u09f0\u0995 \u09aa\u09cd\u09f0\u09a4\u09bf\u09a8\u09bf\u09a7\u09bf\u09a4\u09cd\u09ac \u0995\u09f0\u09c7\u0964 xs[0] + xs[1] * x + xs[2] * x^2 +.... \u098f\u0987 \u09ac\u09b9\u09c1\u09aa\u09a6\u09c0\u09af\u09bc\u09f0 derivative\u099f\u09cb \u098f\u0995\u09c7 \u09f0\u09c2\u09aa\u09a4\u09c7 \u0998\u09c2\u09f0\u09be\u0987 \u0986\u09a8\u09c7\u0964\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u09a6\u09c1\u099f\u09be \u09b6\u09ac\u09cd\u09a6\u09f0 \u098f\u0995\u09c7 \u09a7\u09f0\u09a3\u09f0 \u09ac\u09f0\u09cd\u09a3 \u0986\u099b\u09c7 \u09a8\u09c7 \u09a8\u09be\u0987 \u09aa\u09f0\u09c0\u0995\u09cd\u09b7\u09be \u0995\u09f0\u0995\u0964\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"\u09a4\u09be\u09b2\u09bf\u0995\u09be\u09f0 \u09b8\u09f0\u09cd\u09ac\u09be\u09a7\u09bf\u0995 \u0989\u09aa\u09be\u09a6\u09be\u09a8 \u0998\u09c2\u09f0\u09be\u0987 \u0986\u09a8\u09c7.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Dina \u00f1u jox la turug ab klase (k\u00ebr) ak benn lim bu ay yokkukaay. Y\u00eby yi da\u00f1u leen di j\u00ebfandikoo ngir dugal yeneen klase ci klase bi. K\u00e0ttanug yokkukaay bi mooy: B\u00e0yyi CAP ngir wone limub bataaxal yu mag yi ci turu yokkukaay bi, te SM ngir wone limub bataaxal yu ndaw yi ci ci turu yokkukaay bi, k\u00e0ttan gi dafay j\u00f3ge ci fraction bi CAP - SM. Danga war a seet yokkukaay bi g\u00ebn a d\u00ebg\u00ebr te delloo ab k\u00ebr ci format bii: ClassName.StrongestExtensionName. Su amee \u00f1aari yokkukaay yu yem ci k\u00e0ttan, war nga t\u00e0nn ki j\u00ebkk ci li ci nekk. Ci misaal, bu \u00f1u jox la \"Slices\" ngir nekk klase bi ak benn lim bu yokkukaay yi: ['\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs di taxawaay yu polinome. xs[0] + xs[1] * x + xs[2] * x^2 +.... delloo deriwatee bu polinome bii ci melokaan.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"R\u0169thiomi rwa g\u0169cokia indo na ciongererekete na 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    G\u0169thondeka m\u0169taratara \u0169kuoya namba cia ma, floats, kana ngiri iria ir\u0169gam\u0129r\u0129ire namba cia ma, na \u0169gacoka na m\u0169taratara \u0169r\u0129a m\u0169nene wa m\u0169taratara \u0169r\u0129a \u0169hean\u0129two. G\u0169thi\u0129 na None ang\u0129korwo m\u0129taratara \u0129yo n\u0129 \u0129haanaine. K\u0129rore: Ang\u0129korwo m\u0169taratara wa ma \u0169r\u0169gam\u0129r\u0129ire ta ngiri, m\u0169taratara wa floating point no \u0169kor\u0169o \u0169haana ta. kana, compare_one{1, 2.5) \u00e2 -> 2.5 compare_one{1, \"2,3\") \u00e2 -> \"2,3\" compare_one{5,1\", \"6\") \u00e2 -> \"6\" compare_one{1\", 1) \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" K\u0169h\u0169th\u0129ra gaturwa f kar\u0129a kah\u0169thag\u0129ra n ta kar\u0129a ka m\u0169taratara, na kar\u0129 na m\u0169taratara wa \u0169raihu wa n, ta \u0169r\u0129a k\u0129ene k\u0129a k\u0129eny\u0169 i k\u0129r\u0129 index i n\u0129 factor ya i ang\u0129korwo i n\u0129 \u0129tar\u0129 na m\u0169taratara kana m\u0169taratara wa namba kuuma 1 nginya i ang\u0129korwo ti \u0169guo. i \u0129amb\u0129r\u0129ria kuuma 1. factor ya i n\u0129 k\u0169ing\u0129hia namba kuuma 1 nginya i (1 * 2 *... * i). Ngerekano: f (((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Lista ta'ritorn tal- prefissuri kollha mill- iqsar sal- itwal tal- stringa ta'input\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Jekk inti ma tkunx taf kif tag\u0127mel dan, inti tista 'tag\u0127mel dan billi tu\u017ca l-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-kodi\u010bi tal-\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Jekk l-ewwel numru huwa l-valur primarju l-akbar, allura l-g\u0127add ta' \u010bifri g\u0127andu jkun l-ammont primarju l-akbar. Jekk l-ewwel numru huwa l-valur primarju l-akbar, allura l-g\u0127add primarju l-akbar g\u0127andu jkun l-ammont primarju l-akbar.\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    \u0bae\u0bc7\u0b9f\u0bcd\u0bb0\u0bbf\u0b95\u0bcd\u0bb8\u0bc8\u0baa\u0bcd \u0baa\u0bcb\u0bb2\u0bb5\u0bc7, \u0b92\u0bb0\u0bc1 2 \u0baa\u0bb0\u0bbf\u0bae\u0bbe\u0ba3 \u0ba4\u0bb0\u0bb5\u0bc1, \u0b92\u0bb0\u0bc1 \u0b89\u0bb3\u0bcd\u0bb3\u0bae\u0bc8\u0b95\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0b9f\u0bcd\u0b9f \u0baa\u0b9f\u0bcd\u0b9f\u0bbf\u0baf\u0bb2\u0bbe\u0b95 \u0b89\u0b99\u0bcd\u0b95\u0bb3\u0bc1\u0b95\u0bcd\u0b95\u0bc1 \u0bb5\u0bb4\u0b99\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0b9f\u0bc1\u0b95\u0bbf\u0bb1\u0ba4\u0bc1, \u0b87\u0bb0\u0bc1\u0baa\u0bcd\u0baa\u0bbf\u0ba9\u0bc1\u0bae\u0bcd, \u0bae\u0bc7\u0b9f\u0bcd\u0bb0\u0bbf\u0b95\u0bcd\u0bb8\u0bc8\u0baa\u0bcd \u0baa\u0bcb\u0bb2\u0bb2\u0bcd\u0bb2\u0bbe\u0bae\u0bb2\u0bcd, \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0bb0\u0bc1 \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bbf\u0bb2\u0bc1\u0bae\u0bcd \u0bb5\u0bc6\u0bb5\u0bcd\u0bb5\u0bc7\u0bb1\u0bc1 \u0b8e\u0ba3\u0bcd\u0ba3\u0bbf\u0b95\u0bcd\u0b95\u0bc8\u0baf\u0bbf\u0bb2\u0bbe\u0ba9 \u0ba8\u0bc6\u0b9f\u0bc1\u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0b95\u0bb3\u0bcd \u0b87\u0bb0\u0bc1\u0b95\u0bcd\u0b95\u0bb2\u0bbe\u0bae\u0bcd. lst, \u0bae\u0bb1\u0bcd\u0bb1\u0bc1\u0bae\u0bcd \u0bae\u0bc1\u0bb4\u0bc1 \u0b8e\u0ba3\u0bcd x \u0b95\u0bca\u0b9f\u0bc1\u0b95\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0b9f\u0bcd\u0b9f\u0bbe\u0bb2\u0bcd, \u0baa\u0b9f\u0bcd\u0b9f\u0bbf\u0baf\u0bb2\u0bbf\u0bb2\u0bcd \u0bae\u0bc1\u0bb4\u0bc1 \u0b8e\u0ba3\u0bcd\u0b95\u0bb3\u0bcd x \u0b90\u0b95\u0bcd \u0b95\u0ba3\u0bcd\u0b9f\u0bc1\u0baa\u0bbf\u0b9f\u0bbf\u0ba4\u0bcd\u0ba4\u0bc1, \u0b9f\u0baa\u0bcd\u0baa\u0bb2\u0bcd\u0b95\u0bb3\u0bbf\u0ba9\u0bcd \u0baa\u0b9f\u0bcd\u0b9f\u0bbf\u0baf\u0bb2\u0bc8\u0ba4\u0bcd \u0ba4\u0bbf\u0bb0\u0bc1\u0bae\u0bcd\u0baa\u0bc1\u0b95, [(x1, y1), (x2, y2)...] \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0bb0\u0bc1 \u0b9f\u0baa\u0bcd\u0baa\u0bb2\u0bc1\u0bae\u0bcd \u0b92\u0bb0\u0bc1 \u0b92\u0bb0\u0bc1\u0b99\u0bcd\u0b95\u0bbf\u0ba3\u0bc8\u0baa\u0bcd\u0baa\u0bc1 - (\u0bb5\u0bb0\u0bbf\u0b9a\u0bc8, \u0ba8\u0bc6\u0b9f\u0bc1\u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0b95\u0bb3\u0bcd), 0 \u0b89\u0b9f\u0ba9\u0bcd \u0ba4\u0bca\u0b9f\u0b99\u0bcd\u0b95\u0bc1\u0b95\u0bbf\u0bb1\u0ba4\u0bc1. \u0bae\u0bc1\u0ba4\u0bb2\u0bbf\u0bb2\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0b95\u0bb3\u0bbf\u0ba9\u0bcd \u0b92\u0bb0\u0bc1\u0b99\u0bcd\u0b95\u0bbf\u0ba3\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0b8f\u0bb1\u0bc1\u0bae\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bbf\u0bb2\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baa\u0bcd\u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1\u0b99\u0bcd\u0b95\u0bb3\u0bcd. \u0bae\u0bc7\u0bb2\u0bc1\u0bae\u0bcd, \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bbf\u0ba9\u0bcd \u0b92\u0bb0\u0bc1\u0b99\u0bcd\u0b95\u0bbf\u0ba3\u0bc8\u0baa\u0bcd\u0baa\u0bc1\u0b95\u0bb3\u0bc8 \u0ba8\u0bc6\u0b9f\u0bc1\u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0b95\u0bb3\u0bbf\u0ba9\u0bcd \u0b95\u0bc0\u0bb4\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bbf\u0bb2\u0bcd \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baa\u0bcd\u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1\u0b99\u0bcd\u0b95\u0bb3\u0bcd. \u0b8e\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1\u0b95\u0bcd\u0b95\u0bbe\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd\u0b83 get_row [1,2,3,4,5,6], [1,2,3,4,\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u0b87\u0bb0\u0ba3\u0bcd\u0b9f\u0bc1 \u0b9a\u0bca\u0bb1\u0bcd\u0b95\u0bb3\u0bbf\u0bb2\u0bcd \u0b92\u0bb0\u0bc7 \u0b8e\u0bb4\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1\u0b95\u0bcd\u0b95\u0bb3\u0bcd \u0b89\u0bb3\u0bcd\u0bb3\u0ba4\u0bbe \u0b8e\u0ba9 \u0b9a\u0bb0\u0bbf\u0baa\u0bbe\u0bb0\u0bcd\u0b95\u0bcd\u0b95\u0bb5\u0bc1\u0bae\u0bcd.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    \u0b89\u0b99\u0bcd\u0b95\u0bb3\u0bc1\u0b95\u0bcd\u0b95\u0bc1 \u0b95\u0bbf\u0ba3\u0bb1\u0bc1\u0b95\u0bb3\u0bbf\u0ba9\u0bcd \u0b9a\u0bc6\u0bb5\u0bcd\u0bb5\u0b95 \u0b95\u0b9f\u0bcd\u0b9f\u0bae\u0bcd \u0b95\u0bca\u0b9f\u0bc1\u0b95\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0b9f\u0bcd\u0b9f\u0bc1\u0bb3\u0bcd\u0bb3\u0ba4\u0bc1. \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0bb0\u0bc1 \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bc1\u0bae\u0bcd \u0b92\u0bb0\u0bc1 \u0b95\u0bbf\u0ba3\u0bb1\u0bcd\u0bb1\u0bc8 \u0b95\u0bc1\u0bb1\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb1\u0ba4\u0bc1, \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0bb0\u0bc1 \u0bb5\u0bb0\u0bbf\u0b9a\u0bc8\u0baf\u0bbf\u0bb2\u0bc1\u0bae\u0bcd 1 \u0b92\u0bb0\u0bc1 \u0ba8\u0bc0\u0bb0\u0bcd \u0b85\u0bb2\u0b95\u0bc1 \u0b95\u0bc1\u0bb1\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb1\u0ba4\u0bc1. \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0bb0\u0bc1 \u0b95\u0bbf\u0ba3\u0bb1\u0bcd\u0bb1\u0bbf\u0bb2\u0bc1\u0bae\u0bcd \u0b85\u0ba4\u0bbf\u0bb2\u0bbf\u0bb0\u0bc1\u0ba8\u0bcd\u0ba4\u0bc1 \u0ba4\u0ba3\u0bcd\u0ba3\u0bc0\u0bb0\u0bc8\u0baa\u0bcd \u0baa\u0bbf\u0bb0\u0bbf\u0ba4\u0bcd\u0ba4\u0bc6\u0b9f\u0bc1\u0b95\u0bcd\u0b95\u0baa\u0bcd \u0baa\u0baf\u0ba9\u0bcd\u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4\u0b95\u0bcd\u0b95\u0bc2\u0b9f\u0bbf\u0baf \u0b92\u0bb0\u0bc1 \u0baa\u0bc8\u0baf\u0bc8\u0b95\u0bcd \u0b95\u0bca\u0ba3\u0bcd\u0b9f\u0bc1\u0bb3\u0bcd\u0bb3\u0ba4\u0bc1, \u0bae\u0bc7\u0bb2\u0bc1\u0bae\u0bcd \u0b85\u0ba9\u0bc8\u0ba4\u0bcd\u0ba4\u0bc1 \u0baa\u0b95\u0bcd\u0b95\u0bc1\u0b95\u0bb3\u0bc1\u0bae\u0bcd \u0b92\u0bb0\u0bc7 \u0ba4\u0bbf\u0bb1\u0ba9\u0bcd \u0b95\u0bca\u0ba3\u0bcd\u0b9f\u0bb5\u0bc8. \u0b89\u0b99\u0bcd\u0b95\u0bb3\u0bcd \u0baa\u0ba3\u0bbf \u0b95\u0bbf\u0ba3\u0bb1\u0bc1\u0b95\u0bb3\u0bc8 \u0b95\u0bbe\u0bb2\u0bbf \u0b9a\u0bc6\u0baf\u0bcd\u0baf \u0baa\u0bc8\u0baf\u0bc8\u0b95\u0bb3\u0bc8\u0baa\u0bcd \u0baa\u0baf\u0ba9\u0bcd\u0baa\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1\u0bb5\u0ba4\u0bbe\u0b95\u0bc1\u0bae\u0bcd. \u0ba8\u0bc0\u0b99\u0bcd\u0b95\u0bb3\u0bcd \u0baa\u0b95\u0bcd\u0b95\u0bc1\u0b95\u0bb3\u0bc8 \u0b87\u0bb1\u0b95\u0bcd\u0b95 \u0bb5\u0bc7\u0ba3\u0bcd\u0b9f\u0bbf\u0baf \u0bae\u0bc1\u0bb1\u0bc8\u0b95\u0bb3\u0bbf\u0ba9\u0bcd \u0b8e\u0ba3\u0bcd\u0ba3\u0bbf\u0b95\u0bcd\u0b95\u0bc8\u0baf\u0bc8 \u0bb5\u0bc6\u0bb3\u0bbf\u0baf\u0bbf\u0b9f\u0bc1\u0b99\u0bcd\u0b95\u0bb3\u0bcd. \u0b8e\u0b9f\u0bc1\u0ba4\u0bcd\u0ba4\u0bc1\u0b95\u0bcd\u0b95\u0bbe\u0b9f\u0bcd\u0b9f\u0bc1 1: \u0b89\u0bb3\u0bcd\u0bb3\u0bc0\u0b9f\u0bc1\u0b83 \u0b95\u0b9f\u0bcd\u0b9f\u0bae\u0bcd: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 \u0bb5\u0bc6\u0bb3\u0bbf\u0baf\u0bc0\u0b9f\u0bc1\u0b83 62: \u0b89\u0bb3\u0bcd\u0bb3\u0bc0\u0b9f\u0bc1\u0b83 \u0b95\u0b9f\u0bcd\u0b9f\u0bae\u0bcd: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 \u0bb5\u0bc6\u0bb3\u0bbf\u0baf\u0bc0\u0b9f\u0bc1\u0b83 53: \u0b89\u0bb3\u0bcd\u0bb3\u0bc0\u0b9f\u0bc1\u0b83 [[:0,0,0\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"\u064a\u062a\u0645 \u0625\u0639\u0637\u0627\u0626\u0643 \u0642\u0627\u0626\u0645\u0629 \u0628\u0627\u0644\u0623\u0631\u0642\u0627\u0645. \u062a\u062d\u062a\u0627\u062c \u0625\u0644\u0649 \u0625\u0631\u062c\u0627\u0639 \u0645\u062c\u0645\u0648\u0639 \u0627\u0644\u0623\u0631\u0642\u0627\u0645 \u0627\u0644\u0645\u0631\u0628\u0639\u0629 \u0641\u064a \u0627\u0644\u0642\u0627\u0626\u0645\u0629 \u0627\u0644\u0645\u0642\u062f\u0645\u0629\u060c \u062b\u0645 \u062a\u0642\u0631\u064a\u0628 \u0643\u0644 \u0639\u0646\u0635\u0631 \u0641\u064a \u0627\u0644\u0642\u0627\u0626\u0645\u0629 \u0625\u0644\u0649 \u0627\u0644\u0639\u062f\u062f \u0627\u0644\u0639\u0644\u0648\u064a (\u0627\u0644\u062d\u062f \u0627\u0644\u0623\u0642\u0635\u0649) \u0623\u0648\u0644\u0627\u064b. \u0623\u0645\u062b\u0644\u0629: \u0644\u0640 lst = [1,2,3] \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \u0627\u0644\u0625\u062e\u0631\u0627\u062c 14 \u0644\u0640 lst = [1,4,9] \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \u0627\u0644\u0625\u062e\u0631\u0627\u062c 98 \u0644\u0640 lst = [1,3,5,7] \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \u0627\u0644\u0625\u062e\u0631\u0627\u062c 84 \u0644\u0640 lst = [1.4,4.2,0] \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \u0627\u0644\u0625\u062e\u0631\u0627\u062c 29 \u0644\u0640 lst = [-2.4,1,1] \u064a\u062c\u0628 \u0623\u0646 \u064a\u0643\u0648\u0646 \u0627\u0644\u0625\u062e\u0631\u0627\u062c 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"\u0645\u0647\u0645\u062a\u0643 \u0647\u064a \u062a\u0646\u0641\u064a\u0630 \u0648\u0638\u064a\u0641\u0629 \u0645\u0646 \u0634\u0623\u0646\u0647\u0627 \u062a\u0628\u0633\u064a\u0637 \u0627\u0644\u062a\u0639\u0628\u064a\u0631 x * n. \u0648\u062a\u0639\u0648\u062f \u0627\u0644\u0648\u0638\u064a\u0641\u0629 \u0635\u062d\u064a\u062d \u0625\u0630\u0627 x * n \u062a\u0642\u064a\u0645 \u0625\u0644\u0649 \u0639\u062f\u062f \u0635\u062d\u064a\u062d \u0648 \u0643\u0627\u0630\u0628 \u062e\u0644\u0627\u0641 \u0630\u0644\u0643. \u0643\u0644 \u0645\u0646 x \u0648 n \u060c \u0647\u064a \u062a\u0645\u062b\u064a\u0644 \u0633\u0644\u0633\u0644\u0629 \u0645\u0646 \u0627\u0644\u0643\u0633\u0631 \u060c \u0648\u0644\u062f\u064a\u0647\u0627 \u0627\u0644\u0634\u0643\u0644 \u0627\u0644\u062a\u0627\u0644\u064a \u060c <\u0627\u0644\u0645\u0642\u0627\u0645> \/ <\u0627\u0644\u0645\u0642\u0627\u0645> \u062d\u064a\u062b \u0643\u0644 \u0645\u0646 \u0627\u0644\u0645\u0642\u0627\u0645 \u0648\u0627\u0644\u0645\u0642\u0627\u0645 \u0647\u064a \u0623\u0631\u0642\u0627\u0645 \u0635\u062d\u064a\u062d\u0629. \u064a\u0645\u0643\u0646\u0643 \u0627\u0641\u062a\u0631\u0627\u0636 \u0623\u0646 x \u0648 n \u0647\u064a \u0643\u0633\u0648\u0631 \u0635\u0627\u0644\u062d\u0629 \u060c \u0648\u0644\u064a\u0633 \u0644\u0647\u0627 \u0635\u0641\u0631 \u0643\u0645\u0642\u0627\u0645. \u062a\u0628\u0633\u064a\u0637 (((\"1\/5\" \u060c \"5\/1\") = \u0635\u062d\u064a\u062d \u062a\u0628\u0633\u064a\u0637 (((\"1\/6\" \u060c \"2\/1\") = \u0643\u0627\u0630\u0628 \u062a\u0628\u0633\u064a\u0637 (((\"7\/10\" \u060c \"10\/2\") = \u0643\u0627\u0630\u0628\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    }
]