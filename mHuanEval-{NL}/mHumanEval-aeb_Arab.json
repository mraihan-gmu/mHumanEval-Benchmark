[
    {
        "task_id": "HumanEval/0",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"إشوف إذا في القائمة المحددة من الأرقام، أي رقمين قريبين من بعضهم أكثر من الحد المحدد. مثال: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) غلط >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) صحيح \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"إدخال هذا الوظيفه هو سلسلة تحتوي على مجموعات متعددة من القوسين المترابطين. هدفك هو فصل المجموعات هذه في سلسلات منفصلة وإرجاع قائمة منها. المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) ولا ترابطوا داخل بعضهم. إهمل أي فراغ في سلسلة الإدخال. مثال: >>> separate_paren_groups'(( ) (() (()))))) ['() ', '(()) ', '((()) ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"إعطاء عدد متغير إيجابي، يمكن تحل فيه جزء كامل (أكبر عدد صحيح أصغر من الرقم المعطى) وعشريات (الجزء المتبقي دائما أصغر من 1). إرجع الجزء العشري من الرقم. مثال: >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"ويتم إعطائك قائمة من عمليات الإيداع والسحب في حساب بنكي يبدأ ب صفر. مهمتك هي إكتشاف إذا في أي وقت رصيد الحساب يقل عن صفر، وفي هذه المرحلة، الوظيفة يجب أن ترجع صحيح. وإلا، يجب أن ترجع غلط. مثال: >>> below_zero([1, 2, 3]) غلط >>> below_zero([1, 2, -4, 5]) صحيح \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"لليست المعطى من الأرقام المدخلة، احسب متوسط الانحراف المطلق حول متوسط مجموعة البيانات هذه. متوسط الانحراف المطلق هو متوسط الفرق المطلق بين كل عنصر ونقطة وسط (الوسط في الحالة هذه: MAD = متوسط ∙ x - x_mean ∙ مثال: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"ادخل رقم \"محدد\" بين كل عنصرين متتاليين من قائمة الإدخال `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"في الوظيفة هاذي، نجم نكتب سلسلة من المجموعات الكثيرة للكلمات القريبة المختلفة. و لكل مجموعة، نخرج أعمق مستوى من الكلمات القريبة. على سبيل المثال (() (()) عندها مستويين كحد أقصى من الكلمات القريبة المختلفة و ((())) عندها ثلاثة.\"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"فلتر للاستراتيجية متاع السلاسل للي فيها سلاسل فرعية >>> فلتر_ب_سلاسل فرعية (([]، 'a') [] >>> فلتر_ب_سلاسل فرعية ((['abc'، 'bacd'، 'cde'، 'array']، 'a') ['abc'، 'bacd'، 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"لليست معين من الأعداد الصحيحة، نرجع توبل يتكون من مجموع ومضاعف من كل الأعداد الصحيحة في القائمة. المجموع الفارغ يجب أن يكون يساوي 0 والمضاعف الفارغ يجب أن يكون يساوي 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"من قائمة معينة من الأعداد الصحيحة، نجمو نجمو نجمو لحد أقصى للي تلقاه حتى لحظة معينة في التسلسل. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"لحد ما نجمو نلقى أوج باليندروم يبدأ في الحبل. الفكرة في الخوارزمية هي بسيطة: لحد ما نلقى أوج بوستفيكس في الحبل و هو باليندروم. لحد ما نلقى في نهاية الحبل عكس البريفكس اللي يجي قبل اللحبل باليندروم. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"اختبار إذا سلسلة معطية هي باليندروم.\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"إدخال هو زوز سلاسل a و b اللي فيهم 1 و 0. عمل XOR ثنائي على الإدخالات هاذي و يرجع النتيجة كسلسلة.\"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"لعدد من السلاسل، نرجع الأطول. نرجع الأوّل في حالة وجود سلاسل متعددة بنفس الطول. نرجع لا شيء في حالة القائمة الفارغة. >>> أطول (([]) >>> أطول ((['a'، 'b'، 'c']) 'a' >>> أطول ((['a'، 'bb'، 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"رجع أكبر مقسم مشترك لعددين كاملين a و b >>> أكبر_مشترك_مقسوم ((3, 5) 1 >>> أكبر_مشترك_مقسوم ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"يرد ليكست كل البريفيكس من أقصر ل أطول في سلسلة الإدخال >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"يرجع سلسلة فيها أرقام محددة بالفراغ تبدا من 0 حتى n. >>> سلسلة_سلسلة{0} '0' >>> سلسلة_سلسلة{5} '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"إعطينا سلسلة، نلقى العدد متفرق من الحروف (بلا إعتبار الحالة) إلي فيها >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"إدخلوا لحالة هذا هو سلسلة تمثل الملاحظات الموسيقية في شكل خاص ASCII. مهمتكم هي تحليل قائمة سلسلة من الأعداد الكاملة المقابلة لعدة ضربات. هاذي أسطورة: 'o' - نوت، آخر ضربات أربعة 'o' - نوت نص، آخر ضربتين 'o' - نوت رباعي، آخر ضربة واحدة >>> parse_music. 'o' . o' . o' . o' . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"نجمو نلقاوو في الحي الاصلي. نجمو نعدوا الحالات المتداخلة. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"إدخل سلسلة من الأرقام من \"صفر\" ل \"تسعة\". الإختيارات الصحيحة هي \"صفر\"، \"واحد\"، \"ثنين\"، \"ثلاثة\"، \"أربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\" و \"تسعة\". إرجع السلسلة مع الأرقام المرتبة من أصغر لأكبر >>> sort_numbers ((('ثلاثة واحد خمسة') 'واحد ثلاثة خمسة' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"من قائمة أعداد (من طولها ما لا يقلش عن اثنين) اختر و ارجع اثنين من اقربهم لبعضهم و ارجعهم بالترتيب (عدد أصغر، عدد اكبر). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"لسته من ارقام (من اثنين على الاقل عناصر) ، نطبق تحويل خطي لليسته، بحيث أصغر عدد يصير 0 وأكبر عدد يصير 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"فلتر قائمة معطية من أي قيمة بايثون لعدد كامل فقط >>> فلتر_كامل ((['a'، 3.14, 5]) [5] >>> فلتر_كامل (([1, 2, 3, 'abc'، {}، []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"عود طول السلسلة المحددة >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"لعدد معين n، لاقي اكبر عدد يقسم n بالتساوي، أصغر من n >>> أكبر_قاسم ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"عودة للاعدادات الأساسية للعدد الكامل المحدد من أصغر لأكبر. كل عامل يلزم يكتب عدد مرات تتوافق مع عدد المرات الي يظهر فيها في العامل. العدد المدخل يلزم يساوي ضرب كل العوامل >>> عامل ((8) [2, 2, 2] >>> عامل ((25) [5, 5] >>> عامل ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"مِالقوائمة متاع العددين الصحيحين، نجمو نطيحوا كل العناصر الي تظهر أكثر من مرة. نجمو نحتفظ بالترتيب الي تخلوا فيه. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"لسلسلة معينة، نقلب الحروف الصغيرة للكبرى و الكبرى للكبرى. >>> flip_case ((('Hello') 'hELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"لسلسلة متسلسلة في سلسلة واحدة >>> متسلسلة (([]) '' >>> متسلسلة ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"فلتر للاستراتيجية اللي تبدا ب بضبط. >>> فلتر_بضبط_بضبط (([]، 'a') [] >>> فلتر_بضبط_بضبط ((['abc'، 'bcd'، 'cde'، 'array']، 'a') ['abc'، 'array']\"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"يرجع أرقام إيجابية في القائمة. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"يرجع صحيح إذا عدد معين هو بريم، و غلط غير ذلك. >>> هو_بريم ((6) غلط >>> هو_بريم ((101) صحيح >>> هو_بريم ((11) صحيح >>> هو_بريم ((13441) صحيح >>> هو_بريم ((61) صحيح >>> هو_بريم ((4) غلط >>> هو_بريم ((1) غلط \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs هي معاملات لعدد متعدد. find_zero find x such that poly(x) = 0. find_zero return only only zero point, even if there are many. علاوة على ذلك، find_zero يقلق فقط على القائمة xs مع عدد متساوي من المعاملات وأكبر معامل غير صفر لأنه يضمن الحل. >>> round ((find_zero[(1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"يقيّم كثري الحدود مع معامل xs في نقطة x. يرجع xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"الوظيفة هاذي تأخذ القائمة l و ترجع القائمة l' و هي ليتطابق مع l في الحصص اللي ما تقتسمش على ثلاثة، و قيمتها في الحصص اللي تقتسم على ثلاثة تساوي قيمة الحصص اللي تقتسم على l، و لكنها مرتبة. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"يرجع العناصر المفرطة المفرطة في القائمة >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"يرجع الحد الأقصى للكليات في القائمة. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"يرجع عدد المرات الي ظهرت فيها الرقم 7 في عدد صحيح أقل من n و يقتسم على 11 أو 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"الوظيفة هاذي تأخذ قائمة l و ترجع قائمة l' بحيث تكون l' متطابقة مع l في المؤشرات الغير متوازية، بينما قيمتها في المؤشرات الزوجية متساوية لقيم المؤشرات الزوجية ل l، ولكن مرتبة. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"ياخذ كسلسلة مدخولة مع الوظيفة encode_cyclic. يعيد سلاسلة مفكورة.\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"يرد سلاسل مشفرة من قبل مجموعات دورية من ثلاثة أحرف.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib يعيد الرقم n-th وهو رقم فيبوناتشي وهو برضو بريم. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero ياخذ لسته من العددين الصحيحين كمدخل. يرد صحيح اذا كان هناك ثلاثة عناصر متميزين في القائمه يجمعوا لصفر، و غلط غير ذلك. >>> triples_sum_to_zero (([1, 3, 5, 0]) غلط >>> triples_sum_to_zero (([1, 3, -2, 1]) صحيح >>> triples_sum_to_zero (([1, 2, 3, 7]) غلط >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) صحيح >>> triples_sum_to_zero [1]) غلط\"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"تخيل طريق طوله طوله طوله. ن سيارات تسير من اليسار لليمين في نفس الوقت مجموعة مختلفة من ن سيارات تسير من اليمين لليسار. مجموعتين من السيارات تبداو بعيدين جدا عن بعضهم البعض. كل السيارات تسير بنفس السرعة. يقال إن سيارتين يتصادموا وقتلي سيارة تتحرك من اليسار لليمين تتصادم مع سيارة تتحرك من اليمين لليسار. أما السيارات قوية و قوية بلا حدود، و نتيجة لذلك، تواصلوا يتحركوا في مسارهم وكأنما ما تصدموش. الوظيفة هاذي تخرج عدد التصادمات.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"ترجع للاستور مع العناصر المزايدة ب 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero ياخذ لسته من العددين الصحيحين كمدخل. يرد صحيح اذا كان هناك عنصرين متميزين في القائمه يجمعوا لصفر، و غلط غير ذلك. >>> pairs_sum_to_zero (([1, 3, 5, 0]) غلط >>> pairs_sum_to_zero (([1, 3, -2, 1]) غلط >>> pairs_sum_to_zero (([1, 2, 3, 7]) غلط >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) صحيح >>> pairs_sum_to_zero (([1]) غلط \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"بدل القاعدة العددية لعدد إدخال x ل قاعدة. عود تمثيل سلسلة بعد التحويل. أرقام القاعدة أقل من 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"وبالطول من الجانب وبالساحة العالية للثلاثي. >>> triangle_area ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"السلاسلة Fib4 هي سلاسلة شبيهة لسلاسلة فيبوناتشي و هي: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). إكتب دالة لتحسب العنصر ال n من السلاسلة. ما تستخدمش التكرار. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"العودة متوسطة العناصر في القائمة l. >>> متوسطة (([3, 1, 2, 4, 5]) 3 >>> متوسطة (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"يثبت إنو السلسلة اللي اعطيتو هي باليندروم >>> is_palindrome (('') صحيح >>> is_palindrome (('aba') صحيح >>> is_palindrome (('aaaaa') صحيح >>> is_palindrome (('zbcd') غلط \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"رجع 2^n مودولو p (كيف ما نجم نرى الرقم). >>> مودب ((3، 5) 3 >>> مودب ((1101، 101) 2 >>> مودب ((0، 101) 1 >>> مودب ((3، 11) 8 >>> مودب ((100، 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"ياخذ كسلسلة مدخلة مشفرة مع وظيفة encode_shift. يعيد سلاسلة مشفرة.\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"يعيد سلاسل مشفرة عن طريق نقل كل حرف ب5 في الحروف الافبية.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels هو وظيفة تأخذ سلسلة وترد سلسلة من غير حروف علة. >>> remove_vowels ((('') '' >>> remove_vowels (((\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels (('abcdef') 'bcdf' >>> remove_vowels (('aaaaa') ' ' >>> remove_vowels (('aaBAA') 'B' >>> remove_vowels (('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"يرجع صحيح إذا كل أرقام في القائمة l أقل من الحد الوصلي. >>> below_threshold (([1, 2, 4, 10], 100) صحيح >>> below_threshold (([1, 20, 4, 10], 5) غلط \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"نجمع زوز أرقام x و y >>> نجمع ((2, 3) 5 >>> نجمع ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"شاف إذا كان الكلمتين عندهم نفس الحروف. >>> same_chars (('eabcdzzzz', 'dddzzzzzzzddeddabc') صحيح >>> same_chars (('abcd', 'dddddddabc') صحيح >>> same_chars (('dddddddabc', 'abcd') صحيح >>> same_chars (('eabcd', 'dddddddddabc') غلط >>> same_chars ((('abcd', 'dddddddabddce') غلط >>> same_chars (((abcdzzzz', 'dddzzzzzzzddabc') غلط \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"رجع عدد فيبوناتشي n. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets هو سلسلة من \"<\" و \">\". return صحيح إذا كل قوس فتح لديه قوس إغلاق متوافق. >>> correct_bracketing(\"<\") False >>> correct_bracketing(\"<>\") صحيح >>> correct_bracketing(\"<><>\") صحيح >>> correct_bracketing(\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing. >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"يرجع العناصر المشتركة المفرطة المفرطة لليستين. >>> مشتركة (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> مشتركة (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"رجع أكبر عامل أولي ل n. نفترض إن n > 1 و ما يعدش عامل أولي. >>> أكبر_عامل_أولي ((13195) 29 >>> أكبر_عامل_أولي ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n هي وظيفة تجمع أعداد من 1 ل n. sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets is a string of \"(\" and \")\". return true if every opening bracket has a corresponding closing bracket. >>> correct_bracketing (((\"(\") false >>> correct_bracketing ((() \") true >>> correct_bracketing (((())) true >>> correct_bracketing (((()) false \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs يمثلون معاملات لعدد متعدد. xs[0] + xs[1] * x + xs[2] * x^2 + .... يرجع المشتقة من الحد متعدد هذا في نفس الشكل. >>> المشتقة (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> المشتقة (([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"السلاسلة اللي فيها عدد فيبوبوناتشي هي سلاسلة شبيهة لسلاسلة فيبوبوناتشي و هي: فيبوبوناتشي 0=0 فيبوبوناتشي 1=0 فيبوبوناتشي 2=1 فيبوبوناتشي n=1 فيبوبوناتشي n+2 فيبوبوناتشي n-3 فيبوبوناتشي\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"إكتب وظيفة vowels_count واللي تتلقى سلسلة من الكلمات و ترجع عددها. في الحالة هاذي، الحروف الاصطلاحية هي 'a' و 'e' و 'i' و 'o' و 'u'. هنا، 'y' هو أيضا حروف الاصطلاحية، لكن فقط في نهاية الكلمة. مثال: >>> vowels_count (((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"إضيفو كيسات اختبار.\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"إزايد أرقام العدد الكامل x، إزايد أرقام ليمين و إرجع النتيجة كسلسلة. إزايد > أرقام، إرجع أرقام عكس. >>> circular_shift{12}، 1) \"21\" >>> circular_shift{12}، 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"عمل إكتب وظيفة تأخذ سلسلة كمدخل وترد مجموع الحروف العليا فقط كرموز أسكي. مثال: رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم رقم\"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"في المهامة هاذي، نجم نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو\"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"إذَا كَانْ وَاحِدْ مِنْ المُتَابِعْ يْوَلِّي فِي لُوحة مِالشَّجْرَة وْهِيَ مَعْرُوفة بِالعَدَد الكَامِلْ، يِلْزِمْكْ تْخُصْ وِتْرَجَّعْ. الْعَدْدْ الِّي تْخُصْ يَلْزِمْ يْكُونْ الْعَدْ الِّي يْكُونْ عَنْدُو قِيمَة صَغْرَة وْكِي تْكُونْ عَنْدُو قِيمَة صَغْرَة وْكِي تْكُونْ عَنْدُو قِيمَة صَغْرَة، يِلْزِمْ تْرَجَّعْ الْعَدْ الِّي يْكُوزْ يْكُونْ فِي فِي لُوحَة، وِنْ الْ الْ وَا صَادْ وِينْ.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''إعطيتليلي قائمة من الأعداد الصحيحة الإيجابية. إرجع أكبر عدد صحيح أكبر من الصفر، و ليه تردد أكبر من أو يساوي قيمة الرقم الصحيح نفسه. تردد الرقم الصحيح هو عدد المرات الي يظهر فيها في القائمة. إذا ما كانش موجودة قيمة، إرجع -1.'''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''إعطيتليليست من الأعداد الصحيحة، ترجعليليست في ترتيب غريب. ترتيب غريب، هو وقت تبدا مع القيمة الأدنى، ثم أقصى عدد من الأعداد الصحيحة المتبقية، ثم أدنى و إلخ. أمثلة: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''إعطاء طول الجوانب الثلاثة للمثلث. إرجع مساحة المثلث معطرة لثنين نقاط عشرية إذا الجوانب الثلاثة تشكل مثلث صحيح. وإلا، إرجع -1 ثلاثة أطراف تشكل مثلث صحيح إذا مجموع أي جانبين اكبر من الجانب الثالث. مثال: مثلث_مساحة{3، 4، 5} == 6.00 مثلث_مساحة{1، 2، 10} == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''إكتب دالة ترجع صحة إذا الكائن q يطير، و غلطة إذا لم يكن. الكائن q يطير إذا كان متوازن (هذه قائمة باليندروم) ومجموع عناصرها أقل من أو يساوي أقصى وزن ممكن w. مثال: will_it_fly (([1, 2], 5) â -> False # 1+2 أقل من أقصى وزن ممكن، ولكن غير متوازن. will_it_fly (([3, 2, 3], 1) â -> False # متوازن، ولكن 3+2+3 أكثر من أقصى وزن ممكن. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 أقل من أقصى وزن ممكن، وهو متوازن. will_it_fly ((([3], â 5) -> True # 3 أقل من أقصى وزن ممكن، وهو متوازن.'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"وبالعكس، فما عدد قليل من العناصر للي يلزم تغييرهم ليتحول المصفوفة لصفوفة بالندروم. صفوفة بالندروم هي صفوفة يقرأها نفسها للوراء والامام. في تغيير واحد، تنجم تغير عنصر واحد لشي عنصر اخر. مثل: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''إكتب دالة تقبل لثنين من القوائم و ترجع القائمة اللى فيها عدد الحروف في القوائم الاخرى أقل من القائمة الاخرى. إذا القوائم عندها نفس عدد الحروف، ترجع القائمة الاولى. مثال total_match (([، []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi]) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'', '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"إكتب دالة تُرجع صحيح إذا العدد المُعطى هو ضرب 3 أرقام أوليين و غلط غير ذلك. مع العلم أن (أ) أقل من 100.\"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"مهمتك هي تكتب دالة ترجع صحيح إذا عدد x هو قوة بسيطة من n و غلط في الحالات الأخرى. x هو قوة بسيطة من n إذا n**int=x. مثلًا: is_simple_power{1, 4} => true is_simple_power{2, 2} => true is_simple_power{8, 2} => true is_simple_power{3, 2} => false is_simple_power{3, 1} => false is_simple_power{5, 3} => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''إكتب دالة تأخذ عدد صحيح و ترجع صحيح إذا كان هذا إنجير مكعب لعدد صحيح. ملاحظة: يمكن أن تتصور إن الدخل صحيح دائما. مثال: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"إمبالي تكتب دالة تتلقى رقم عشري عشري كسلسلة وتحسب عدد الأرقام عشري عشري اللي هي أرقام أولية (عدد أولي، أو أرقام أولية، هو عدد طبيعي اكبر من واحد ما يخلقش ضرب من عددين أصغر). الأرقام عشري عشري هي ٠، ١، ٢، ٣، ٤، ٥، ٦، ٧، ٨، ٩، أ، ب، ج، ج، د، إي، ف. الأرقام الأولية هي ٢، ٣، ٥، ٧، ١١، ١٣، ١٧، ...، إيه لازم تحدد عدد من الأرقام التالية: ٢، ٣، ٥، ٧، ب (= عشري ١١) ، د (= عشري ١٣). ملاحظة: يمكن تفترض ان الإدخال صحيح أو فارغ، والرموز A،B،C،D،E،F دائماً بحروف كبيرة. أمثلة: لnum = AB، الإخراج يجب أن يكون 1. لnum = 1077E، الإخراج يجب أن يكون 2. لnum = \"AB33\" يجب أن يكون 4.BC = 1.67D، لnum = 6.012345، لخراج يجب أن يكون 2.02020\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"ويتم إعطاءك رقم في شكل عشري و مهمتك هي تحويله لبرمجة ثنائية. الميزة لازم ترجع سلسلة، مع كل حرف يمثل رقم ثنائي. كل حرف في السلسلة يكون '0' أو '1'. ويتم إضافة زوز حروف إضافية 'db' في البداية والنهاية من السلسلة. الحروف الإضافية موجودة لتساعدك في التنسيق. مثال: decimal_to_binary ((15) # ترجع \"db1111db\" decimal_to_binary32) # ترجع \"db100000db\"\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"ويقولولولك إنو الحرفين الي يلفوا في الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع الحرفين متاع\"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"و هذا اخر اسبوع من الفصل الدراسي و المعلم لازم يعطي الدرجات للطلاب. المعلم عمل خوارزمية خاصة به لدرجات. المشكلة الوحيدة هي انه فقد الكود الي استخدمته لدرجات. اعطاك قائمة من معدل الدرجات لبعض الطلاب و لازم تكتب وظيفة تخرج قائمة من درجات الحروف باستخدام الجدول الي يلي: معدل الدرجات. درجة الحروف 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: مثال المساواة: grade_([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"إكتب وظيفة تخرج سلاسل و ترجع صحيح إذا طول السلاسل هو عدد أولي أو غلط وإلا، مثال prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"أعطينا عدد صحيح موجب n، نرجع عدد الأعداد الصحيحة الإيجابية من رقم n واللي تبدا أو تنتهي ب 1.\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"إعطاء عدد صحيح إيجابي N، إرجع مجموع أرقامه في النموذج الثنائي. مثال ل N = 1000، مجموع أرقامو يكون 1، المخرجات تكون \"1\". ل N = 150, مجموع أرقامو يكون 6، المخرجات تكون \"110\". ل N = 147, مجموع أرقامو يكون 12، المخرجات تكون \"1100\". متغيرات: @N عدد صحيح قيود: 0 â‰¤ N â‰¤ 10000. المخرجات: سلسلة من الأرقام الثنائية \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"إعطينا قائمة غير فارغة من الأعداد الصحيحة، إضيف العناصر الزوجة اللى عندها مؤشرات فريدة.\"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"إكتب وظيفة تخلق سلسلة و ترجع نسخة مرتبة منها. نسخة مرتبة من سلسلة، هي سلسلة حيث كل الكلمات (مفصولة بالفراغ) تتم استبدالها بكلمة جديدة حيث كل الحروف مرتبة بالترتيب الصاعد على أساس قيمة ascii. ملاحظة: يلزمك تحافظ على ترتيب الكلمات والفراغات الفارغة في الجملة. مثل: anti_shuffle ((('Hi') يرجع 'Hi' anti_shuffle ((('hello') يرجع 'ehllo' anti_shuffle (('Hello World!!!') يرجع 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"ويقول: \"تعطيك بيانات ثنائية الأبعاد، كقوائم متداخلة، واللي تشبه الماتركس، أما على عكس الماتركس، كل صف ممكن يحتوي على عدد مختلف من الأعمدة. إعطاء lst، والعدد الكلي x، يلقوا أعداد صحيحة x في القائمة، و يرجعوا قائمة من التوبلات، [(x1, y1), (x2, y2) ...] بحيث كل توبل هو إحداثيات - (الصف، الأعمدة) ، تبدا ب 0. ترتيب الإحداثيات في البداية حسب الصفوف بالترتيب الصاعد. إضافة إلى ترتيب الإحداثيات في الصفوف بالترتيب الهابط. مثال: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (1, 0), (2, 5), (2, 0) get_((1), [] ==[_[[row [1], [1, 3], 2]]، 2] [2, 3]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"إعطيتلي صف من الأعداد الصحيحة غير السالبة، ارجعلي نسخة من المصف بعد الترتيب، و انتم ستفرزوه في الترتيب الصاعد إذا كانت المجموعة ((القيمة الأولى، القيمة الأخيرة)) فريدة، أو ستفرزوه في الترتيب الهابط إذا كانت المجموعة ((القيمة الأولى، القيمة الأخيرة)) زوجية. ملاحظة: * ما تغيرش المصف. مثالات: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"إعمل وظيفة إنيكريبت بتأخذ سلسلة كحرف وترد سلسلة مشفرة مع تدوير الحروف الألفبية. الحروف الألفبية لازم تدويرها بطريقة تتحرك الحروف للأسفل بثنين مضروبة لثنين أماكن. مثل: إنيكريبت ((('hi') يرجع إنيكريبت 'lm' ((('asdfghjkl') يرجع إنيكريبت 'ewhjklnop' ((('gf') يرجع إنيكريبت 'kj' ((('et') يرجع إنيكريبت 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"إعطيتليليكم قائمة من الأعداد الصحيحة. إكتبوا وظيفة next_smallest (() الي تسترجع ثاني أصغر عنصر في القائمة. إسترجع None إذا ما كان ما فما عنصر. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"وْتِتْعْطَالْكْلاَمْ وْتِحْسِبْ عْلَى قَدَّاشْ يْكُونْ مْتَاعْ الكْلاَمْ الِّي يْكُونْ مْتَاعْكْ. وْكْلاَمْ الِّي يْكُونْ مْتَاعْكْ يْكُونْ عْلَى قَدَّاشْ يْكُونْ مْتَاعْكْ. وْكْلاَمْ الِّي يْكُونْ مْتَاعْكْ يْكُونْ عْلَى قَدَّاشْ يْكُونْ مْتَاعْكْ.\"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''إخلق دالة تأخذ 3 أرقام. ترجع صحيح إذا واحد من الأرقام يساوي مجموع الأرقام التانية، والعدد كله عدداً صحيح. ترجع غلط في الحالات الأخرى. أمثلة أي_إنت (5, 2, 7) --> صحيح أي_إنت (3, 2, 2) --> غلط أي_إنت (3, -2, 1) --> صحيح أي_إنت (3, 6, -2.2, 2) --> غلط '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"إكتب وظيفة تتلقى رسالة، وتقوم بالترميز بطريقة تغير الحروف الكبيرة، وتستبدل الحروف الصوتية في الرسالة بحرف يظهر 2 أماكن قبل الحرف الصوتي في الألفبية الإنجليزية. إفترض الحروف فقط. أمثلة: >>> ترميز ((('test') 'TGST' >>> ترميز ((('هذه رسالة') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"ويعطيكم لسته من الأعداد الصحيحة. يلزمك تلقوا أكبر قيمة أولي وتردوا مجموع أرقامها. مثال: ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"إعطاء قاموس، يرجع صحيح إذا كل المفاتيح هي سلاسل في الحروف الصغيرة أو كل المفاتيح هي سلاسل في الحروف الكبيرة، وإلا يرجع غلط. الميزان يلزم يرجع غلط إذا قاموس ما فاضي. مثال: check_dict_case{\"a\":\"apple\"، \"b\":\"banana\"}) يلزم يرجع صحيح. check_dict_case{\"a\":\"apple\"، \"A\":\"banana\"، \"B\":\"banana\"}) يلزم يرجع غلط. check_dict_case{\"a\":\"apple\"، 8:\"banana\"، \"a\":\"apple\"}) يلزم يرجع غلط. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) يلزم يرجع غلط. check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"}) يلزم يرجع صحيح.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"ننجم نعملو فانكشن يخذ عدد صحيح غير سلبي و يرجع المصفوفة من أول عدد صحيح n و هو عدد أولي و أقل من n. مثلًا: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"إكمل الدالة الي تأخذ عددان كاملين و ترجع ضرب أرقام الوحدة. إفترض إن الدخل صحيح دائما. مثال: ضرب 148, 412) يلزم ترجع 16. ضرب 19، 28 يلزم ترجع 72. ضرب 2020، 1851 يلزم ترجع 0. ضرب 14، 15 يلزم ترجع 20.\"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"اعطينا سلسلة s، احصوا عدد الحروف العلوية الكبيرة في الحروف الزوجية. مثلا: count_upper (('aBCdEf') يرجع 1 count_upper (('abcdefg') يرجع 0 count_upper (('dBBE') يرجع 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''إعمل دالة بتأخذ قيمة (سلسلة) تمثل عدد وترد أقرب عدد صحيح له. إذا العدد هو متباعد على عددين صحيحين، اقربوه من الصفر. مثالات >>> أقرب_عدد صحيح (((\"10\") 10 >>> أقرب_عدد صحيح (((\"15.3\") 15 ملاحظة: القرب من الصفر يعنى إذا العدد المعطى متباعد على عددين صحيحين، اللي يلزمك ترجع هو اللي أبعد من الصفر. لمثال اقرب_عدد صحيح (((14.5\") يلزم ترجع 15 و اقرب_عدد صحيح (((-14.5\") يلزم ترجع -15.'''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"إعطاء عدد صحيح إيجابي n، يلزمك تخلق كومة من مستويات n من الحجارة. المستوى الاول فيه n حجر. عدد الحجارة في المستوى التالي هو: - العدد الزويد التالي إذا كان n غير زويد. - العدد الزويد التالي إذا كان n زويد. إرجع عدد الحجارة في كل مستوى في قائمة، حيث العنصر في المؤشر i يمثل عدد الحجارة في المستوى (i+1). أمثلة: >>> make_a_pile(3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"وْتِتْعْطَى لِيكْ سِلاَلْ مْتَاعْ الكْلاَمْ مْفَارْقِينْ بِالكُومَا وِلاَّ بِالفُرْقَة. وْتِتْحَطْ سِلاَلْ مْتَاعْ الكْلاَمْ فِي الكْلاَمْ وِتْرَجَّعْ مَتْعَة مْتَاعْ الكْلاَمْ. مْثَالْ: words_string ((\"سَمِّي يُوحَنَّا\") == [\"سَمِّي يُوحَنَّا\"، \"سَمِّي\"، \"إِسْمِي\"، \"إِسْمِي\"، \"يُوحَنَّا\"] words_string ((\"وَاحِدْ، ثْنِينْ، ثْلاَثْ، رْبْعَة، خَمْسْ، سِتَّة\")\"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"الوظيفة هاذي تأخذ عددين إيجابيين x و y و ترجع أكبر عدد صحيح متساوي في النطاق [x، y] شامل. إذا ما كانش فيه رقم، فعندها الوظيفة لازم ترجع -1. مثلا: choose_num(12, 15) = 14 choose_num(13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"واكتسبو عددين كاملين إيجابيين n و m، و مهمتك هي حساب متوسط العددين الكاملين من n ل m (بضمنهم n و m). ونجم نلقوا الجواب ل أقرب عدد صحيح و نحولوه لثنائي. إذا n أكبر من m، نرجع -1.\"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"إعطينا قائمة من الأعداد الصحيحة الإيجابية x. نرجع قائمة مرتبة من كل العناصر اللي ما عندهاش رقما زوجي. ملاحظة: القائمة المرجعة لازم ترجع بالترتيب المتزايد. مثل: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"وبالعكس، الارقام الكاملة اللى فما بين 1 و 9، وبدلا من كلهم، وبدلا من كل رقم باسمو المقابل من \"واحد\"، \"ثنين\"، \"ثلاثة\"، \"اربعة\"، \"خمسة\"، \"ستة\"، \"سبعة\"، \"ثمانية\"، \"تسعة\". مثلا: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الارقام الار\"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم ننجم\"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"إعطاء عدد صحيح إيجابي n، نعيد توبل فيه عدد من الباليندرومات الصحيحة والغير الصحيحة اللي تقع في النطاق ((1، n) ، متضمنة. مثال1: المدخل: 3 الخارجي: (1, 2) تفسير: الباليندرومات الصحيحة هي 1, 2, 3. واحد منها زوجي، و اثنين منها غير زوجي. مثال2: المدخل: 12 الخارجي: (4, 6) تفسير: الباليندرومات الصحيحة هي 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. أربعة منها زوجي، و 6 منها غير زوجي. ملاحظة: 1. 1 <= n <= 10^3 2. توبل أعاد عدد الباليندرومات الصحيحة والغير الصحيحة على التوالي.\"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"إكتب وظيفة count_nums واللي تأخذ مجموعة من الأعداد الصحيحة وترد عدد العناصر اللي فيها مجموع الأرقام > 0. إذا كان الرقم سلبي، الرقم الأول اللي فيه سلبي: على سبيل المثال -123 ليه الأرقام المسجلة -1, 2، و 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"نجمو نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا نجموا\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"في المشكلة هاذي، باش ننجم نطبق وظيفة تخلق لثنين من القوائم من الأرقام، و تثبت إما كان ممكن نستبدل العناصر بينهم حتى نجمو نجمو نستبدل lst1 و lst2، و ما فماش حد على عدد العناصر المتبادلة بين lst1 و lst2. إذا كان ممكن نستبدل العناصر بين lst1 و lst2 حتى نستبدل كل العناصر في lst1، نعيد \"نعم\". أما لا، نعيد \"لا\". مثلا: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"نعم\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"لا\" يفترض إن القوائم المدخلة ما هيش فارغة.\"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"إعطيت سلسلة تمثل حروف صغيرة منفصلة ب ب بلايص، إرجع القاموس للكتابة مع أكثر تكرار و تحتوي على العد المقابل. إذا كان عدة حروف لها نفس الحدوث، إرجعهم الكل. مثال: هستوگرام ((('a b c') == {'a': 1, 'b': 1, 'c': 1} هستوگرام ((('a b b a') == {'a': 2, 'b': 2} هستوگرام ((('a b c a b') == {'a': 2, 'b': 2} هستوگرام ((('b b a') == {'b 4}: هستوگرام (((')) == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"عمل نحصل على سلاسلين s و c، لازمك تحذف كل الحروف في s واللي مساوين لأي حرف في c و بعد تتفقد إذا كان السلاسل الناتج هو باليندروم. السلاسل يسمى باليندروم إذا كان يقرأ نفس الشي للخلف والسابق. يلزمك ترجع توبل يحتوي على السلاسل الناتج و صحيح/كاذب للتفقد. مثال ل s = \"abcde\"، c = \"ae\"، النتيجة لازم تكون ('bcd'، False) ل s = \"abcdef\"، c = \"b\" النتيجة لازم تكون ('acdef'، False) ل s = \"abcdedcba\"، c = \"abcdedcba\"، النتيجة لازم تكون ('cdedc'، True)\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"وكل عنصر i في الخارجة يجب ان يكون \"عدد العناصر الغير عادية في السلسلة i من المدخلات\". حيث يجب ان تكون جميع i's بديلة بعدد العناصر الغير عادية في السلسلة i من المدخلات. >>> odd_count['1234567']) [\"عدد العناصر الغير عادية 4n str4ng 4 من 4nput.\"] >>> odd_count['3',\"111111\"]) [\"عدد العناصر الغير عادية 1n str1ng 1 من 1nput.\"، \"عدد العناصر الغير عادية 8n str8ng 8 من 8nput.\"] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"اعطينا صف من عددين صحيحين، نلقى الحد الأدنى من مجموع أي صف فرعي من العدد.\"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"وكل صف يمثل واحد من البئر، وكل واحد في الصف يمثل وحدة واحدة من المياه. كل بئر فيها دلو ليتم استخدامه لجمع المياه، وكل دلو ليه نفس القابلية. مهمتك هي استخدام الدلو لتفريغ البئر. إخرج عدد المرات اللى تحتاجها لتخفيض الدلو. مثال 1: إدخال: شبكة: [[0,0,1,0]، [0,1,0,0]، [1,1,1,1]] سعة البئر: 1 إخراج: 62: إدخال: شبكة: [[0,0,1,1]، [0,0,0,0]، [1,1,1]، [0,1,1]] سعة البير: 2 إخراج: 53: إدخال: [[0,0,0]، [0,0,0]] سعة البير: 5 إخراج: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"في الكاتا هذا، لازمك تنظم صفوف من الأعداد الصحيحة غير السالبة حسب عدد واحد في التمثيل الثنائي في ترتيب تصاعدي. لعدد واحد متماثل، تنظم على أساس القيمة العشرية. لازم تنفيذها على هذا النحو: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"إعطينا سلاسل s و عدد طبيعي n، تم تكليفك لتعمل وظيفة ترجع قائمة من كل الكلمات من سلاسل s التي تحتوي على بالضبط n حروف ضمنية، حتى تظهر الكلمات هذه في سلاسل s. إذا سلاسل s فارغة، فعندها الوظيفة يجب أن ترجع قائمة فارغة. ملاحظة: يمكن أن تفترض أن السلاسل المدخلة تحتوي على حروف و فراغ فقط. أمثلة: select_words (((\"ماري كان لديها خروف صغير\"، 4) ==> [\"little\"] select_words (((\"ماري كان لديها خروف صغير\"، 3) ==> [\"ماري\"، \"خروف\"] select_words\" (((فراغ بسيط\"، 2) ==> [] select_words (((\"سلام العالم\"، 4) ==> [\"العالم\"] select_words (((\"عم سام\"، 3) ==> [\"عم\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"ويقولولولك كلمة. مهمتك هي ان تجد أقرب حروف صوتية موجودة بين حروف صوتيين من الجانب اليمين من الكلمة (حساسة للكيس). الحروف الصوتية في البداية والنهاية ما تُحسبش. ارجع الحبل الفارغ إذا ما لاقيتش حروف صوتية تلبي الشروط المذكورة أعلاه. يمكن أن تفترض إن الحبل المحدد يحوي حروف إنجليزية فقط. مثال: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" ((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''ويكو فما سلاسلين، كلتا سلاسل فيها قوسين مفتوحين '(' أو قوسين مغلقين ') '. مهمتك هي تتحقق إما كان ممكن تتصل السلاسلين في ترتيب معين، و القارعة الناشئة تكون جيدة. سلاسل S يعتبر جيد إذا و فقط إذا كانت القوسين في S متوازنة. على سبيل المثال: سلاسلة '((()) 'جيدة، أما السلاسلة '()) 'مستحيل. إرجع 'إيه' إذا كان ثمة طريقة لتصنع سلاسلة جيدة، وإرجع 'لا' إلا. مثال: match_parens[('() ', ') ']) == 'إيه' match_parens[(') ', ') ']) == 'لا' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"إعطينا صف arr من الأعداد الصحيحة و k من الأعداد الصحيحة الإيجابية، نعيد قائمة مرتبة بطول k مع أقصى عدد k في صف. مثال1: المدخلات: arr = [-3, -4, 5], k = 3 الناتج: [-4, -3, 5] مثال2: المدخلات: arr = [4, -4, 4], k = 2 الناتج: [4, 4] مثال3: المدخلات: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 الناتج: [2] ملاحظة: 1. طول المصف سيكون في حدود [1, 1000]. 2. العناصر في المصف سيكون في حدود [-1000, 1000]. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"إعطينا قائمة من الأعداد الصحيحة، نعيد مجموع كل العناصر الغير عادية في مواقع متساوية.\"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"اعطينا صف غير فارغ من العددين الصحيحين arr و عدد صحي k، نعيد مجموع العناصر مع رقمين على الأكثر من أول k عناصر من arr. مثال: المدخلات: arr = [111,21,3,4000,5,6,7,8,9], k = 4 الناتج: 24 # مجموع 21 + 3 القيود: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"إعطاء عدد صحيح إيجابي n، إرجع قائمة مرتبة فيها الأرقام الغريبة في تسلسل كولاتز. تخمين كولاتز هو تخمين في الرياضيات يخص تسلسل محدد على النحو التالي: ابدأ بأي عدد صحيح إيجابي n. ثم كل عبارة تتوصل من العبارة السابقة على النحو التالي: إذا العبارة السابقة زاد، العبارة التالية هي نصف العبارة السابقة. إذا العبارة السابقة فريدة، العبارة التالية هي 3 مرات العبارة السابقة زائد 1. التخمين هو أنه مهما كانت القيمة ل n، التسلسل يصل دائماً ل 1. ملاحظة: 1. كولاتز (((1) هو [1]. 2. القائمة المرجعة في ترتيب متزايد. مثلًا: get_odd_collatz ((5) يرد [1, 5] # تسلسل كولاتز ل 5 هو [5, 8, 16, 4, 2, 1], إما الأرقام الغريبة هي 1 و 5 \"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"لازمك تكتب وظيفة تثبت صحة سلسلة تاريخ معين وترد صحة إذا كان التاريخ صحيح وإلا غلط. التاريخ صحيح إذا كل القواعد التالية تلبية: 1. سلسلة التاريخ ليست فارغة. 2. عدد الأيام ما يقلش عن 1 ولا يزيد على 31 يوم لشهر 1,3,5,7,8,10,12. وعدد الأيام ما يقلش عن 1 ولا يزيد على 30 يوم لشهر 4,6,9,11. وعدد الأيام ما يقلش عن 1 ولا يزيد على 29 يوم للشهر 2. 3. الشهور ما يقلش عن 1 ولا يزيد على 12. 4. التاريخ لازم يكون في شكل: mm-dd-yyyy مثل: valid_date ((('03-11-2000') => valid_date (((15-01-2012') => false valid_date ((('04-02040') => false_date ((((((06-04-2020') => true_date (((((06/04/2020')\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''إعطاء سلسلة من الكلمات، إرجع قائمة من الكلمات مقسمة على الفراغ، إذا ما كان لا يوجد فراغ في النص، يتعين عليك تقسيمها على الفواصل، إذا ما كان لا يوجد فواصل، يتعين عليك إرجع عدد الحروف الصغيرة مع ترتيب غريب في الأبجدية، ord ((('a') = 0، ord ((('b') = 1، ... ord ((('z') = 25 مثالات تقسيم_الكلمات (((\"مرحبا عالم!\")'''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''إعطيتلي قائمة من الأرقام، عود إليها سواء كانت مرتبة بالترتيب الصاعد. إذا القائمة فيها أكثر من واحد من نفس الرقم، عود False. إفترضلي ما فما أرقام سلبية و أرقام كاملة. مثالات is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 2, 3, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"ويقولوا انو فترتين، كل فترتين هو زوج من الأعداد الصحيحة. على سبيل المثال، فترة = (بداية، نهار) = (1, 2). فترات معطية مغلقة، يعني انو فترة (بداية، نهار) فيها بداية ونهار. فكل فترة معطية، يقول انو بدايتها أقل من نهارها. مهمتك هي تحديد ما إذا طول تقاطع الفترتين هو رقم أولي. مثل تقاطع الفترات (1, 3), (2, 4) هو (2, 3) و طوله هو 1، و هو ليس رقم أولي. إذا طول التقاطع هو رقم أولي، رد \"نعم\"، وإلا، رد \"لا\". إذا فترتين ما تقاطعوش، رد \"لا\". [input/output] نموذج: تقاطع (((1، 2) ، (2، 3) ==> \"تقاطع (-1، 4) \"، ((1) ==> \"، (NO) ==> 5، ((1، 5، ((3) \"، (YES)\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"و لازمك ترجع مجموع القيمات من الأعداد الصحيحة مضروبة في ضرب كل علامات من كل رقم في المصفوفة، و تمثلها ب 1، -1 أو 0. ملاحظة: ترجع لا شيء لترتيب فارغ. مثال: >>> prod_signs (([1، 2، 2، -4]) == -9 >>> prod_signs (([0، 1]) == 0 >>> prod_signs (([]) == لا شيء\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"وكل خلية في المجال [1, N * N] شاملة تحتوي على قيمة مرة واحدة بالضبط في الخلايا في المجال. لازمك تلقف الحد الأدنى من المسار لحد k في المجال. تنجم تبدأ من أي خلية، وفي كل خطوة يمكنك الانتقال إلى أي خلية مجاورة، بمعنى آخر، يمكنك الانتقال إلى الخلايا التي تتشارك الحافة مع خلية الحالية. يرجى ملاحظة إن المسار لحد k يعني زيارة بالضبط k خلية (ليس بالضرورة متميزة). ما تقدرش تخرج من المجال. المسار A (طول k) يعتبر أقل من المسار B (طول k) إذا بعد ما تعمل القوائم المرتبة للقيمات على الخلايا التي تمر من خلال A و B (لنجم نسميها l_st و l_A_st) ، l_stA_s هو أقل من المسار المكتبي، بمعنى آخر، في أي خلية، يمكن أن تخرج من أي خلية. مثال: [A، k، k=1، k=4, k=8, j_j=1، j=7, j=8, j=9, j=9, j=9, l_j=1، k=9]، و ليكملتواف في أي مسار مخرج من المجال، ويتوجود في المجال: [A، k=1، j=1، j=1، j=8، j=9، k=1، j=1، j=1، j=6، j=1، j=1، j=] [A، [A، j=1، j=8، j=9]\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"الكل يعرف تسلسل فيبوناتشي، و قد درسوه بعمق من قبل علماء الرياضيات في القرنين الماضين. أما ما الناس ما يعرفوهش هو تسلسل تريبوناتشي. تسلسل تريبوناتشي يعرف بالتكاثر: تريبوناتشي = 1 + n / 2، إذا n هو زوج. تريبوناتشي = 1 + 2 + 1 + 2 + 3 + 1، إذا n هو فرد. مثلًا: تريبوناتشي = 1 + 2 / 2 = 3 تريبوناتشي = 3 تريبوناتشي = 2 + 3 + 3 = 8\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"اعطينا عدد صحيح موجب n، نعيد ضرب الأرقام الغير متفرقة. نعيد 0 إذا الأرقام كلها زاد. مثلًا: الأرقام ((1) == 1 أرقام ((4) == 0 أرقام ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''إخلق دالة تأخذ كمدخلة سلسلة من الأقواس المربعة. الميزة لازم ترجع صحيح إذا كان هناك سلسلة متبعة من الأقواس صالحة فيها أقرب من قوس واحد. is_nested (('[[]]') â -> True is_nested (('[]]]]]]] [[[[[[[]') â -> False is_nested (('[][]') â -> False is_nested (('[]') â -> False is_nested (('[]') â -> False is_nested (('[[][]]') â -> True is_nested (('[[]]') â -> True'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"و نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجمو نجم\"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''إخلق وظيفة تُرجع صحيح إذا آخر حرف في سلسلة معينة هو حرف أبجدي ولا هو جزء من كلمة، وإلا غلط. ملاحظة: \"كلمة\" هي مجموعة من الأحرف المفصولة بالفراغ. مثالات: check_if_last_char_is_a_letter (((\"كعكة التفاحة\") â -> false check_if_last_char_is_a_letter (((\"تفاحة pi e\") â -> true check_if_last_char_is_a_letter (((\"تفاحة pi e\") â -> false check_if_last_char_is_a_letter\" (((\") â -> false check_if_last_char_is_a_letter\"'''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"إعمل دالة ترجع أكبر مؤشر لعنصر ما يزيدش عن أو يساوي لعنصر اللي قبل منه مباشرة. إذا ما كانش موجود عنصر كذا إرجع -1. المصفوفة ما تتوفرش قيم متكررة. مثال: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''إعمل دالة ترجع لـ (a، b) و فيها (a) أكبر عدد صحيح سالب و (b) أصغر عدد صحيح إيجابي في القائمة. إذا ما فما عدد صحيح سالب أو إيجابي، إرجعهم على شكل لا. مثال: أكبر_صغير_عدد صحيح[2, 4, 1, 3, 5, 7]) == (لا، 1) أكبر_صغير_عدد صحيح (([]) == (لا، لا) أكبر_صغير_عدد صحيح (([0]) == (لا، لا)'''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"إعمل دالة تأخذ أعداد صحيحة، أو تعويمات، أو سلاسل تمثل أعداد حقيقية، وترد المتغير الأكبر في نوع متغيرها المحدد. إرجع لا شيء إذا القيم متساوية. ملاحظة: إذا تمثل عدد حقيقي كسلسلة، النقطة العائمة يمكن تكون . أو، compare_one{1, 2.5) â -> 2.5 compare_one{1, \"2,3\") â -> \"2,3\" compare_one{5,1\"، \"6\") â -> \"6\" compare_one{1\"، 1) â -> لا شيء \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"تقييم إما إن كان الرقم n ليكتب كجمع أربعة أرقام زوايج بالضبط. مثال هو_مستوي_ل_المجموع_المتساوي (٤) == غلط هو_مستوي_ل_المجموع_المتساوي (٦) == غلط هو_مستوي_ل_المجموع_المتساوي (٨) == صحيح \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"العامل البرازيلي يعرف على شكل: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! حيث n > 0 مثلا: >>> special_factorial ((4) 288 الوظيفة بتستلم عدد صحيح كمدخل وتسترد العامل الخاص لهاد الرقم الصحيح.\"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_مثال-3ل كل المساحات فيه بالخطوط السفلية، وإذا كان السلسلة فيها أكثر من 2 مساحات متتالية، بدل كل المساحات المتتالية ب - fix_spaces (((\"مثال\") == \"مثال\" fix_spaces (((\"مثال1\") == \"مثال1\" fix_spaces (((\"مثال2\") == \"_مثال_2\" fix_spaces (((\"مثال 3\") == \"_مثال-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"إعمل دالة تستعمل سلسلة تمثل اسم الملف وترد \"نعم\" إذا اسم الملف صحيح وترد \"لا\" إذا لم يكن صحيح. اسم الملف صحيح إذا و فقط إذا الشروط التالية تمت: - لا يجوز أن يكون فيه أكثر من ثلاثة أرقام ('0'-'9') في اسم الملف. - اسم الملف يحتوي على نقطة واحدة بالضبط. - لا يجوز أن يكون السلاسلة الفرعية قبل النقطة فارغة، وتبدأ بحرف من الحروف الفا لاتينية ('a'-'z' و 'A'Z'). - السلاسلة الفرعية بعد النقطة يجب أن تكون واحدة من الحروف التالية: ['txt'، 'exe'، 'lld'] مثال: file_name_check\"{example.txt.} # => 'نعم'_name_file_check\"{example.dll1} # => 'لا' (اسم الملف يجب أن يبدأ بحرف الفا لاتينية)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\"الشغل هذا يخلص من قائمة من الأعداد الصحيحة. لجميع الإدخالات في القائمة، الشغل يربع الإدخال الصحيح إذا كان مؤشرها مضروب لثلاثة، و يثني الإدخال الصحيح إذا كان مؤشرها مضروب لربعة و ليس مضروب لثلاثة. الشغل ما يغيرش الإدخالات في القائمة التي مؤشراتها ليست مضروب لثلاثة أو أربعة. الشغل بعد ذلك يرد مجموع الإدخالات. مثال: ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل ل\"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"ويقول: \"كلاكو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكللو، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويكل، ويك\"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"عملك هو تطبيق وظيفة لتبسيط التعبير x * n. وظيفتك تعيد صحيح إذا x * n تبيّن على عدد كامل و غلط غير ذلك. كل x و n، هي تمثيل سلسلة من الكسور، ولها الشكل التالي، <عدد>/<اسم> حيث كل عدد ومقام هي أرقام كاملة موجبة. يمكن أن تفترض أن x و n كسور صالحة، ولا يكون فيها الصفر كمقام. تبسيط (((\"1/5\"، \"5/1\") = صحيح تبسيط (((\"1/6\"، \"2/1\") = غلط تبسيط (((\"7/10\"، \"10/2\") = غلط \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"إكتب وظيفة تفرز القائمة المقدمة من الأعداد الصحيحة بالترتيب الصاعد حسب مجموع أرقامها. إشارت: إذا كان ثمة بضعة عناصر مع مجموع أرقامهم المماثل، فرزهم حسب مؤشرهم في القائمة الأصلية. مثلًا: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"إكتب وظيفة تخلق صف من الأرقام و ترجع عددا من العناصر في المصف أكبر من 10 و كل واحد من الأرقام الأول و الأخير من الرقم هو غير فردي (1, 3, 5, 7, 9). مثل: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"و نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم نجم ن\"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''ثمانية كواكب في نظامنا الشمسي: الأقرب للكوكب هو عطارد، التالي هو الزهرة، ثم الأرض، المريخ، المشتري، زحل، أورانوس، نبتون. إكتب دالة تأخذ اسمي كواكب كواكب 1 و كوكب 2. المادة المطلوبة هي إرجاع دالة فارغة إذا الكوكب 1 و الكوكب 2 ما هومش أسماء صحيحة. مثالات: bf \"(المشتري\"، \"نبتون\") ==> (\"زحل\"، \"أورانوس\") bf (((الأرض\"، \"الزحل\") ==> (\"الزهرة\") bf (((الزحل\"، \"أورانوس\") ==> (\"الزهرة\"، \"الأرض\"، \"المشتري\"، \"الزحل\"، \"الزهرة\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"إكتب وظيفة تقبل لسته من السلاسل كمعلمة، وتحذف السلاسل اللي طولها غير متساوي، وتعيد القائمة الناتجة مع ترتيب مرتب، القائمة دايما قائمة من السلاسل ومش قط صفيفة من الأرقام، ويمكن أن تحتوي على تكرارات. ترتيب القائمة لازم يكون تصاعدي حسب طول كل كلمة، ويتم إرجع القائمة مرتبة حسب القاعدة. إذا كلمتين طولهم نفس، رتب القائمة بالترتيب الأبجدي. وظيفة يجب إرجع قائمة من السلاسل بترتيب مرتب. يمكن أن تتصور أن كل الكلمات يكون طولها نفس. مثل: assert list_sort[\"aa\"\"، \"a\"\"، \"aaa\"]) => assert list_sort[\"ab\"\"، \"a\"\"، \"aaa\" => \"cd\" => \"cd\" (ab))\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"برنامج بسيط يرد قيمة x اذا n هو عدد أولي و يرد قيمة y غير ذلك. مثال: ل x_or_y ((7, 34, 12) == 34 ل x_or_y ((15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''إعطيتلي قائمة من الأرقام، إرجع مجموع مربعات الأرقام في القائمة اللي فريدة. إهمل الأرقام اللي سلبية أو غير صحيحة. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 إذا القائمة ما دخلتش، إرجع 0. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"نعتقد اننا الكل نتذكر هذا الشعور وقت ما نتجت الحدث الي ننتظروه طويلا. المشاعر والافكار الي عندكم في اللحظة ديروها تستحق التسجيل والمقارنة. مهمتك هي تحديد اذا كان الشخص تخمين النتائج الصحيحة لعدد من المباراة. تعطيك صفيفين من النتائج والخميسات من طول متساو، حيث كل مؤشر يظهر تطابق. ارجع صفيف من طول متساو يوضح مدى الخميس كان. اذا كان تخمين صحيح، القيمة هي 0، وإلا القيمة هي الفرق المطلق بين الخميس والنتيجة. مثال: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,0,4],[4,1,0,-2]) -> [4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"ويقولولولك اسم الفئة (سلسلة) و قائمة من الإضافات. الإضافات هي لتحميل فئات إضافية للفئة. القوة من الإضافة هي: خلي CAP يكون عدد الحروف الكبيرة في اسم الإضافة، و خلي SM يكون عدد الحروف الصغيرة في اسم الإضافة، القوة تعطى من خلال كسر CAP - SM. يلزمك تلقف أقوى إضافة و ترجع سلسلة في هذا التنسيق: ClassName.StrongestExtensionName. إذا كان ثنين أو أكثر من الإضافات للكفاءة نفسها، يلزمك تختار واحد يجي أولا في القائمة. على سبيل المثال، إذا ما تعطيت \"Slices\" كالفئة وقائمة من الإضافات: ['SEviRNGCliES'، 'Cheese'، 'StuFfed'] ثم يلزمك ترجع 'Slices.SEviRNGCliES'، 'SEviRNGCliES'، 'mySviRNGCliES' (قوة: القوة القوة القوية، مثال: 'AA_Beast'، '_Class'= Strongest_Class'\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"إعطيتلك كلمتين. لازمك ترجع صحيح إذا الكلمة الثانية أو أي من تدويراتها هي سلسلة فرعية في الكلمة الأولى cycpattern_check{\"abcd\",\"abd\") => false cycpattern_check{\"hello\",\"ell\") => true cycpattern_check{\"whassup\",\"psus\") => false cycpattern_check{\"abab\",\"baa\") => true cycpattern_check{\"efef\",\"eeff\") => false cycpattern_check{\"hims\",\"simen\") => true \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"أعطيت عدد صحيح. نعيد توبل فيه عدد الأرقام الزوجة والفريدة على التوالي. مثال: حتى_عدد_الفرد ((-12) ==> (1, 1) حتى_عدد_الفرد ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"أعطينا عدد صحيح إيجابي، نحصل على ما يعادله من الأرقام الرومانية كسلسلة، ونرجعها بحرف صغير. القيود: 1 <= num <= 1000 الأمثلة: >>> int_to_mini_roman{19} == 'xix' >>> int_to_mini_roman{152} == 'clii' >>> int_to_mini_roman{426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''إعطاء طول الجوانب الثلاثة للمثلث. إرجع صحيح إذا الجوانب الثلاثة تشكل مثلث مستقيم، وإلا غلط. مثلث مستقيم هو مثلث فيه زاوية واحدة هي زاوية مستقيمة أو 90 درجة. مثال: right_angle_triangle ((3، 4، 5) == True right_angle_triangle ((1، 2، 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"إكتب دالة تقبل لسته من سلاسل. القائمه فيها كلمات مختلفة. إرجع الكلمة مع الحد الأقصى لعدد الحروف المميزة. إذا كان سلاسل متعددة عندهم الحد الأقصى لعدد الحروف المميزة، إرجع الواحد اللي بيجي أولا في الترتيب المفصلي. find_max (([\"اسم\"، \"من\"، \"سلسلة\"]) == \"سلة\" find_max (([\"اسم\"، \"enam\"، \"لعبة\"]) == \"enam\" find_max (([\"aaaaaaa\"، \"bb\" ، \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إما إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ إ\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة وحدة و و و و\"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"ولو كان الحرف s هو حرف، فما عليك ان تغير الحرف من الاصلي للاخر، ولو كان لا، فما عليك ان تبقيه على حاله. اذا الحرف ما فيهش حروف، فما عليك ان ترجع الحرف. ولو كان هذا الحرف موجود، فما عليك ان ترجع الحرف الي تخرج منه.\"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"\"كلايك\" يردو \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\" متوافق مع \"كلايك\"\"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "aeb_Arab",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"اعطينا عددين صحيحين ايجابيين a و b، نرجع العدد الزوج بين a و b، في ترتيب متصاعد. مثلًا: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]