[
    {
        "task_id": "HumanEval/0",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Verilmiş nömrə siyahısında hər hansı iki nömrənin bir-birinə verilən həddə nisbətən daha yaxın olub olmadığını yoxlayın.Məsələn: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Bu funksiyanın girişində bir çox qrup yuva qapağı olan bir simdir. Məqsədiniz bu qrupları ayrı simlərə ayırmaq və onların siyahısını qaytarmaqdır. Ayrı qruplar balanslaşdırılmışdır (hər bir açıq qapaq düzgün bağlanmışdır) və bir-birinin içərisində yuva qurulmamışdır. Giriş simindəki hər hansı bir boşluğa məhəl qoymayın. Məlum: >>> separate_paren_groups' ((( ) (() (( ) ) ) ) ) [' (()) ', '(()) ', '(()) ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"Müsbət bir üzən nöqtə nömrəsi verildikdə, tam ədəd hissəsinə (əldə olunan saydan kiçik olan ən böyük tam ədəd) və onluqlara (qalan hissə həmişə 1-dən kiçikdir) parçalana bilər.\"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Sizə sıfır balansla başlayan bank hesabında depozit və pul çəkmə əməliyyatlarının siyahısı verilir. Sizin vəzifəniz hesabın balansının hər hansı bir nöqtədə sıfırdan aşağı düşdüyünü aşkar etməkdir və bu nöqtədə funksiya True qaytarmalıdır. Əks təqdirdə False qaytarmalıdır. Misal: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Verilən giriş nömrələri siyahısı üçün, bu məlumat dəstinin ortalaması ətrafında Orta Mütləq Çöküşü hesablayın. Orta Mütləq Çöküş hər element və bir mərkəz nöqtəsi arasındakı orta mütləq fərqdir (bu vəziyyətdə ortalama): MAD = ortalama. x - x_mean. Misal: >>> orta_mütləq_çöküşü ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Giriş siyahısının hər iki ardıcıl elementi arasında bir \"delimiter\" nömrəsi daxil edin `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Bu funksiyanın girişində boşluqlarla ayrılmış yuva qapağı üçün çoxsaylı qrupları təmsil edən bir simdir. Hər bir qrup üçün qapağın yuvalarının ən dərin səviyyəsini çıxartın. Məsələn (() (()) yuvaların maksimum iki səviyyəsi var, ((())) isə üçü var. >>> parse_nested_parens (('((()) ((())) (((()) (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Yalnız verilən alt simli olan simlilərin giriş siyahısını filtrləyin >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Verilmiş tamsaylı siyahı üçün, bir siyahıdakı bütün tamsaylıların bir məbləğindən və bir məhsulundan ibarət bir tuple qaytarın. Boş məbləğ 0-a bərabər olmalıdır və boş məhsul 1-ə bərabər olmalıdır. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"Verilmiş tamsaylı siyahıdan, ardıcıllıqdakı müəyyən bir anadək tapılan yuvarlanan maksimum elementin siyahısını yaradın. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"Tərkibi sadədir: - Tərkibi sadə olan ən uzun postfiksi tapın. - Stringün sonuna palindromik sufiksdən əvvəl gələn bir string prefiksinin əksini əlavə edin. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"Verilmiş simli palindrom olub olmadığını yoxlayın .\"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Giriş yalnız 1 və 0-dan ibarət olan a və b iki simlidir. Bu girişlərdə ikili XOR yerinə yetirin və nəticəni bir simli olaraq qaytarın. >>> string_xor (('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Siyahıdakı simlərdən ən uzununu qaytarın. Eyni uzunluqda bir neçə sim varsa, ilkini qaytarın. Giriş siyahısı boşdursa, Heç birini qaytarın. >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"İki tamsayının ən böyük ortaq bölməsini qaytarın a və b >>> ən böyük_ortak_bölməçi ((3, 5) 1 >>> ən böyük_ortak_bölməçi ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Giriş simli >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"0-dan n-a qədər olan boşluqla məhdudlaşdırılmış nömrələrdən ibarət bir simli qaytarır. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Bir simli verilmiş, neçə fərqli simli (kifəsindən asılı olmayaraq) tapın: >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Bu funksiyanın giriş xüsusi ASCII formatında musiqi notları təmsil bir simli simli siyahısı parse etməkdir. Sizin vəzifəsi bir çox zərbə uyğun integer simli siyahısı parse edir: 'o' not, sonuncu zərbələr 'o' var - yarım not, sonuncu iki zərbələr 'o' var - quater not, sonuncu bir zərbə >>> parse_music 'o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var . o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' var o' o' var o' o' var o' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u' u'\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Müəyyən bir alt simli orijinal simlidə neçə dəfə tapmaq olar. Üst-üstə düşən halları sayın. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Giriş 'sıfırdan' 'doqquza' qədər olan rəqəmlərin boşluqla məhdudlaşdırılmış bir sətiridir. Həqiqi seçimlər 'sıfır', 'bir', 'iki', 'üç', 'dörd', 'beş', 'altı', 'yeddi', 'səkkiz' və 'doqquzdur'. Ən kiçikdən ən böyükə sıralanmış nömrələrlə sətir qaytarır >>> sort_numbers (('üç bir beş') 'bir üç beş' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"Təqdim olunan nömrə siyahısından (ən azı iki uzunluğunda) bir-birinə ən yaxın olan iki nömrəni seçin və qaytarın və onları sırayla qaytarın (daha kiçik sayı, daha böyük sayı). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Nömrələr siyahısı verilmişdir (ən azı iki elementdən), ən kiçik nömrə 0, ən böyüyü isə 1 olacaq şəkildə bu siyahıya xətti transformasiya tətbiq edin >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Filter yalnız tam ədədlər üçün hər hansı bir python dəyərlərinin verilən siyahısını filtrləyin >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"Verilmiş stringin qaytarma uzunluğu >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Verilmiş n n sayında n-dən kiçik olan ən böyük n sayını tapın >>> ən böyük_qismən ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Verilmiş tamsayının ilkin faktorlarının siyahısını ən kiçikdən ən böyükə qədər sırayla qaytarın. Hər bir faktorun faktorlaşdırmada neçə dəfə meydana gəlməsinə uyğun bir sayda sayda sayda sayda qeyd edilməlidir. Giriş nömrəsi bütün faktorların məhsuluna bərabər olmalıdır >>> faktorizə edin ((8) [2, 2, 2] >>> faktorizə edin ((25) [5, 5] >>> faktorizə edin ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Tam ədədlər siyahısından birdən çox dəfə meydana gələn bütün elementləri çıxarın. Elanın sırasını girişdəki kimi saxlayın. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"Verilmiş bir simli üçün kiçik hərfləri böyük hərflərə və böyük hərfləri kiçik hərflərə çevirin. >>> flip_case ((('Hello') 'HELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Bir simli birləşdirmək üçün simli silsilələrin siyahısı >>> concatenate (([]) '' >>> concatenate ((['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Yalnız verilən prefikslə başlayanlar üçün giriş simli siyahısını süzün. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Siyahıda yalnız müsbət ədədləri qaytarın. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"Verilmiş bir nömrə birinci, əks halda isə yalan olarsa doğru qaytarın. >>> birinci (ə) (6 False) >>> birinci (ə) (101) True >>> birinci (ə) (11) True >>> birinci (ə) (13441) True >>> birinci (ə) (61) True >>> birinci (ə) (4) False >>> birinci (ə) (1) False \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs bir polinomin koeffisientləridir. find_zero x belə bir poly ((x) = 0. find_zero yalnız çox olsa da, yalnız sıfır nöqtəsini qaytarır. Bundan əlavə, find_zero yalnız həllini təmin etdiyi üçün hətta əmsalların sayı və ən böyük sıfırdan fərqli əmsalı olan xs siyahısını alır. >>> round (((find_zero[1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"X nöqtəsində xs əmsalları olan çoxhüceyrəni qiymətləndirir. xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"Bu funksiya l siyahısını alır və l' ilə üçlə bölünməyən indekslərdə l ilə eyni olduğu kimi bir l' siyahısını qaytarır, üçlə bölünən indekslərdəki dəyərləri isə l-in müvafiq indekslərinin dəyərlərinə bərabərdir, lakin sıralanmışdır. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"Bir siyahıda sıralanmış unikal elementləri qaytarır >>> unikal (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Siyahıdakı ən çox elementi qaytarır. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"7 rəqəminin 11 və ya 13 ilə bölünən n-dən kiçik tam ədədlərdə göründüyü dəfə sayını qaytarın. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"Bu funksiya bir siyahı alır l və l' ilə eyni olan bir siyahı qaytarır l' cüt indekslərdə, cüt indekslərdəki dəyərləri isə l-in cüt indekslərinin dəyərlərinə bərabərdir, lakin sıralanmışdır. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"daxilolma kimi encode_cyclic funksiyası ilə kodlanmış bir simli alır. Dekodlanmış bir simli qaytarır. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"Üç simvoldan ibarət dövrə qrupları ilə kodlaşdırılmış simli qaytarır.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib n-ci sayını qaytarır ki, bu da bir Fibonaççi nömrəsidir və eyni zamanda birincidir. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero tam ədədlərin siyahısını giriş kimi qəbul edir. siyahıda sıfıra qədər olan üç fərqli element varsa True, əks halda False qaytarır. >>> triples_sum_to_zero (([1, 3, 5, 0]) False >>> triples_sum_to_zero (([1, 3, -2, 1]) True >>> triples_sum_to_zero (([1, 2, 3, 7]) False >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero [1]) False \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"Tam düz, sonsuz uzun bir xətt olan bir yol təsəvvür edin. n avtomobil soldan sağa hərəkət edir; eyni zamanda, n fərqli avtomobilin bir dəsti sağdan sola hərəkət edir. İki avtomobil dəsti bir-birindən çox uzaqdan başlayır. Bütün avtomobillər eyni sürətlə hərəkət edir. Soldan sağa hərəkət edən bir avtomobil sağdan sola hərəkət edən bir avtomobilə çırpıldıqda iki avtomobilin toqquşduğunu söyləyirlər. Bununla birlikdə, avtomobillər sonsuz dərəcədə möhkəm və güclüdür; nəticədə, toqquşmadıqları kimi öz trajektorisində hərəkət etməyə davam edirlər. Bu funksiya bu cür toqquşmaların sayını çıxardır.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] ilə artımlı elementlərlə siyahı qaytarın.\"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero bir tam ədəd siyahısını giriş kimi alır. siyahıda sıfıra qədər olan iki fərqli element varsa True və əks halda False qaytarır. >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero (([1]) False \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Giriş nömrəsi x-in rəqəm bazasını bazaya dəyişdirin. Dönüşümdən sonra simli simli təmsil edin. Baz nömrələri 10-dan azdır. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Üçbucaq üçün bir yanın uzunluğu və yüksək geri dönüş sahəsi verilmişdir. >>> üçbucaq_sahəsi ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Fib4 say sıraları Fibbonacci ardıcıllığına bənzər ardıcıllıqdır və aşağıdakı kimi müəyyən edilir: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Fib4 say sıralarının n-ci elementini səmərəli hesablamaq üçün bir funksiya yazın. Rekursiyanı istifadə etməyin. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"Listin elementlərinin geri qaytarma medianı l. >>> median (([3, 1, 2, 4, 5]) 3 >>> median (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"Verilmiş simli bir palindrom olub olmadığını yoxlayır >>> is_palindrom (('') True >>> is_palindrom (('aba') True >>> is_palindrom (('aaaaa') True >>> is_palindrom (('zbcd') False \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2 ^ n modulo p (nömrələrin fərqində olun) qaytarın. >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"daxilolma kimi encode_shift funksiyası ilə kodlanmış bir simli alır. Dekodlanmış bir simli qaytarır. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"hər bir simvolu əlifbada 5 ilə dəyişdirərək kodlaşdırılmış simli qaytarır.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels - silinmələri götürən və səssiz sətir qaytaran funksiya. >>> remove_vowels (('') ' ' >>> remove_vowels ((\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels (('abcdef') 'bcdf' >>> remove_vowels (('aaaaa') ' ' >>> remove_vowels (('aaBAA') 'B' >>> remove_vowels (('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Əgər l siyahısındakı bütün nömrələr həddən aşağıdırsa, True qaytarır. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"İki nömrəni x və y əlavə edin >>> əlavə edin ((2, 3) 5 >>> əlavə edin ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"İki sözün eyni simvolları olub olmadığını yoxlayın. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') True >>> same_chars (('abcd', 'dddddddabc') True >>> same_chars (('dddddddabc', 'abcd') True >>> same_chars (('eabcd', 'dddddddddabc') False >>> same_chars ((('abcd', 'dddddddabddce') False >>> same_chars (('eabcdzzzz', 'dddzzzzzzdddabc') False \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"n-ci Fibonaççi nömrəsini qaytarın. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets \"<\" və \">\" simlidir. return True hər açılış qapağının müvafiq bir bağlama qapağı varsa. >>> correct_bracketing ((\"<\") False >>> correct_bracketing ((\"<>\") True >>> correct_bracketing ((\"<><>>\") True >>> correct_bracketing ((\"><<>\") False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Geri qaytarın True siyahı elementləri monoton şəkildə artır və ya azalır. >>> monoton (([1, 2, 4, 20]) True >>> monoton (([1, 20, 4, 10]) False >>> monoton (([4, 1, 0, -10]) True \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"İki siyahı üçün sıralanmış unikal ortaq elementləri qaytarın. >>> ümumi (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> ümumi (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"n-in ən böyük birinci faktorunu qaytarın. n > 1 olduğunu və birinci olmadığını düşünün. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 1 -dən n -ə qədər olan ədədləri toplayan funksiyadır. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets \"(\" və \"\") bir sıra. return True if every opening bracket has a corresponding closing bracket. >>> correct_bracketing (((\"(\") False >>> correct_bracketing ((() \") True >>> correct_bracketing (((())) True >>> correct_bracketing (((\") ((()) False \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs bir çoxlüyün əmsallarını təmsil edir. xs[0] + xs[1] * x + xs[2] * x^2 + .... Bu çoxlüyün törəməsini eyni formada qaytarın. >>> törəmə (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> törəmə (([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"FibFib nömrə ardıcıllığı Fibbonacci ardıcıllığına bənzər bir ardıcıllıqdır ki, aşağıdakı kimi müəyyən edilir: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). Zəhmət olmasa fibfib nömrə ardıcıllığının n-ci elementini səmərəli hesablamaq üçün bir funksiya yazın. >>> fibfib ((1) 0 >>> fib ((5) 4 >>> fibfib ((8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"Bir sözü ifadə edən bir simli giriş kimi qəbul edən və simlidəki vokalların sayını qaytaran bir vokal_say funksiyası yazın. Bu vəziyyətdə vokallar 'a', 'e', 'i', 'o', 'u'dur. Burada 'y' də bir vokaldır, ancaq yalnız verilən sözün sonunda olduqda. Məlum: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"Daha çox test hadisəsi əlavə edin.\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Dairə x tamsayının rəqəmlərini dəyişdirin, rəqəmləri dəyişdirərək sağa dəyişdirin və nəticəni bir simli olaraq qaytarın. Əgər dəyişiklik > rəqəmlərin sayı, rəqəmləri geri qaytarın. >>> circular_shift ((12, 1) \"21\" >>> circular_shift ((12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"Tapşırıq Bir simli giriş kimi qəbul edən və yalnız yuxarı simli ASCII kodlarının cəmi qaytaran bir funksiya yazın. Nümunələr: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"Bu tapşırıqda sizə bir sətir veriləcək ki, bu sətirdə alma, portağal və manqo meyvələri olan bir meyvə səbətində paylanan alma və portağalların sayını təmsil edir. Portakalların və almaların ümumi sayını təmsil edən sətir və səbətdəki meyvələrin ümumi sayını təmsil edən tam ədəd verildikdə, səbətdəki manqo meyvələrinin sayını qaytarın. məsələn: fruit_distribution \"5 ((alma və 6 portağal\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 alma və 1 portağal\", 3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 alma və 3 portağal\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\" 100 alma və 120) \", 1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"Negativ olmayan tamsaylı düyünləri olan bir ağacın bir filialını təmsil edən bir sıra verildiyi təqdirdə, vəzifəniz düyünlərdən birini seçib qaytarmaqdır. Seçilmiş qovşaq ən kiçik cüt dəyəri olan qovşaq olmalıdır. Birdən çox ən kiçik cüt dəyəri olan qovşaq tapılsa, ən kiçik indeksi olan qovşaq qaytarın. Seçilmiş qovşaq bir siyahıda qaytarılmalıdır, [small_value, onun indeksi ], Cüt dəyəri yoxdursa və ya verilən sıra boşdursa, qaytarın [].Məsələn: 1: Giriş: [4,2,3] Çıxış: [2, 1] Açıqlama: 2 ən kiçik cüt dəyəri var və 2 ən kiçik indeksi var. Məsələn: Giriş: [1,2,3] Çıxış: [2, 1] Açıqlama: 2 ən kiçik dəyəri var və 2 ən kiçik indeksi var. Məsələn: Giriş: [] Çıxış: [4] Giriş: [5, 3, 4, 2] Çıxış: 1 [0, 0] Çıxış: ən kiçik qovşaq ən kiçik indeksi olan qovşaq qaytarılmalıdır. * Nümdə ən kiçik qiymət yoxdursa, ilk qovşaq: [0, 1] Açıqlama: 2 ən kiçik cüt dəyəri var, lakin indeksi var.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''Sizə müsbət tamsayılar siyahısı verilir. Sıfırdan böyük və tamsayının dəyərindən böyük və ya bərabər olan ən böyük tamsayı qaytarın. Tamsayının tezliyi siyahıda göründüyü dəfələrin sayıdır. Əgər belə bir dəyər yoxdursa, -1 qaytarın. Nümunələr: axtarış ([4, 1, 2, 2, 3, 1]) == 2 axtarış ([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3 axtarış ([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''Bütün ədədlərin siyahısı verildikdə, siyahını qəribə qaydada qaytarın. Qəribə sıralama, minimum dəyərdən başlayaraq, sonra qalan bütün ədədlərin maksimumundan sonra minimum və s. Nümunələr: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''Üçbucağın üç tərəfinin uzunluqları verilmişdir. Üç tərəfi etibarlı üçbucaq təşkil edərsə, üçbucağın sahəsini 2 onluq nöqtəyə yuvarlaqlaşdırın. Əks təqdirdə -1 qaytarın Hər iki tərəfin cəmi üçüncü tərəfə nisbətən daha böyük olduqda üç tərəfi etibarlı üçbucaq təşkil edir. Misal: üçbucaq_sahəsi ((3, 4, 5) == 6.00 üçbucaq_sahəsi ((1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''Əgər q obyekt uçacaqsa, True, əks halda False funksiyasını yazın. Q obyekt balanslıdırsa (palindrom siyahıdır) və elementlərinin cəmi maksimum mümkün çəkiyə bərabərdirsə və ya azdırsa, True qaytarır. Misal: will_it_fly (([1, 2], 5) â -> False # 1+2 maksimum mümkün çəkiyə bərabərdir, lakin balanssızdır. will_it_fly (([3, 2, 3], 1) â -> False # balanslıdır, lakin 3+2+3 maksimum mümkün çəkiyə bərabərdir. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 maksimum mümkün çəkiyə bərabərdir və balanslıdır. will_it_fly ((([3], â 5) -> True # 3 maksimum mümkün çəkiyə bərabərdir və balanslıdır.'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"Bir sıra bütün ədədlər verilmişdirsə, sıra palindromik olmaq üçün dəyişdirilməli olan minimum element sayını tapın. Palindromik sıra, geri və irəli eyni oxunan bir sıradır. Bir dəyişiklikdə bir elementi hər hansı bir digər elementə dəyişdirə bilərsiniz. Məsələn: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''İki simli siyahı qəbul edən və siyahının bütün simli siyahılarında ümumi simli sayı digər siyahıdan az olan siyahını qaytaran bir funksiya yazın. əgər iki siyahıda simli sayı eyni olsa, ilk siyahını qaytarın. Məlumdur total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Verilmiş ədəd 3 ədəd ədədin çarpanı və başqa halda yalan olan doğru qaytaracaq bir funksiya yazın. (a) -nin 100 -dən az olduğunu bilmək.Məsələn: is_multiply_prime ((30) == True 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"X, n-in sadə bir qüvvəsi olduqda sadə bir qüvvədir. x, n-in sadə bir qüvvəsidir. Məsələn: is_simple_power (n_1, 4) => true is_simple_power (n_2, 2) => true is_simple_power (n_8, 2) => true is_simple_power (n_3, 2) => false is_simple_power (n_3, 1) => false is_simple_power (n_5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''Bir tamsayı a götürən və True qaytaran bir funksiya yazın. Bu ingeger bir tamsayı nömrənin kubudursa. Qeyd: giriş həmişə etibarlı olduğunu düşünə bilərsiniz. Nümunələr: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"Sizdən onaltı ədədli ədədi simvol kimi qəbul edən və onaltı ədədli rəqəmlərin sayını hesablayan bir funksiya yazmaq tapşırılıb. Onaltı ədədli rəqəmlər 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Onaltı ədədli rəqəmlər 2, 3, 5, 7, 11, 13, 17,... Beləliklə, aşağıdakı rəqəmlərin sayını təyin etməlisiniz: 2, 3, 5, 7, B (= onaltı ədədli 11), D (= onaltı ədədli 13) Qeyd: giriş həmişə düzgün və ya boş olduğunu düşünə bilərsiniz və simvollar A,B,C,D,E,F həmişə böyük hərflərlə yazılır. Nümunələr: \"AB\" üçün çıxış nömrəsi 1. olmalıdır \"AB\" üçün çıxış nömrəsi 1. olmalıdır \"1077E\" üçün çıxış nömrəsi 2. olmalıdır \"AB\" üçün nömrəsi 1. olmalıdır \"AB\" üçün nömrəsi 4. olmalıdır \"AB\" üçün nömrəsi 6.0 olmalıdır \"AB\" üçün nömrəsi 6.0 olmalıdır \"A\" üçün çıxış nömrəsi 2. olmalıdır \"2020DEF\" üçün\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Siz onluq şəklində bir nömrə veriləcək və sizin vəzifəsi ikili formatda çevirməkdir. funksiyası bir simli qaytarmalıdır, hər simli ikili nömrəni təmsil edir. simli hər simli '0' və ya '1' olacaq. simli başlanğıcında və sonunda əlavə bir neçə simli 'db' olacaq. əlavə simvollar formatda kömək etmək üçün var. Misallar: decimal_to_binary ((15) # \"db1111db\" onluq_to_binary32) # \"db100000db\" qaytarır\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"Sizə bir simli verilir. Sizin vəzifəniz simlin xoşbəxt olub olmadığını yoxlamaqdır. Bir simli xoşbəxtdirsə, onun uzunluğu ən azı 3 və hər 3 ardıcıl hərf fərqlidir. Məsələn: is_happy (a) => False is_happy (a) => False is_happy (b) => True is_happy (a) => False is_happy (b) => False is_happy (c) => False is_happy (d) => False is_happy (e) => True is_happy (x) => False \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Bu semestr son həftəsidir və müəllim şagirdlərə qiymətlər verməlidir. Müəllim qiymətləndirmə üçün öz alqoritmini hazırlayır. Yeganə problem, qiymətləndirmə üçün istifadə etdiyi kodu itirməsidir. O, sizə bəzi şagirdlər üçün GPA siyahısını vermişdir və aşağıdakı cədvəldən istifadə edərək hərf qiymətlərinin siyahısını çıxara bilən bir funksiya yazmalısınız: GPA. Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"Bir simli götürən və simli uzunluğu bir ədəd olsa True və ya False qaytaran bir funksiya yazın. Misal prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"Bir müsbət tam n verilmiş, 1 ilə başlayan və ya bitən n rəqəmli müsbət tam saylarının sayını qaytarın. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"müsbət tam nömrə verilmişsə, ikili nömrələrin ümumi cəmi qaytarın. N = 1000 üçün nömrələrin cəmi 1 olacaq, çıxışı \"1\" olmalıdır. N = 150 üçün nömrələrin cəmi 6 olacaq, çıxışı \"110\" olmalıdır. N = 147 üçün nömrələrin cəmi 12 olacaq, çıxışı \"1100\" olmalıdır. Dəyişənlər: @N tam nömrə məhdudiyyətləri: 0 â‰¤ N â‰¤ 10000. Çıxış: ikili sayın bir sətir \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"Boş olmayan tam ədədlər siyahısı verildikdə lst. Qeyri-bərabər indekslərdə olan cüt elementləri əlavə edin..Məsələn: əlavə edin (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"Bir simli götürən və onun nizamlı versiyasını qaytaran bir funksiya yazın. Simlin nizamlı versiyası, bütün sözlərin (boşluqla ayrılmış) ascii dəyərinə əsasən yüksələn sırada yerləşdirilmiş bütün simlərin yerləşdirildiyi yeni bir sözlə əvəz olunan bir simlidir. Qeyd: Sözlərin və boşluqların sırasını cümlədə saxlamalısınız. Məsələn: anti_shuffle ((('Hi') 'Hi' anti_shuffle (('hello') qaytarır 'ehllo' anti_shuffle (('Hello World!!!') qaytarır 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"Sizə matrisə bənzər, lakin matrislərdən fərqli olaraq, hər satırda fərqli sayda sütun ola biləcək bir yuvalanmış siyahı kimi 2 ölçülü bir məlumat verilir. lst və tam ədəd x verildikdə, siyahıda tam ədədlər x tapın və tuples siyahısını qaytarın, [(x1, y1), (x2, y2) ...] belə ki, hər tuple bir koordinatdır - (satır, sütunlar), 0 ilə başlayaraq. Koordinatları əvvəlcə sıralar üzrə yüksələn sırada sıralayın. Həmçinin, sıra koordinatlarını sütunlar üzrə enən sırada sıralayın. Nümunələr: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0, 0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(], 1) [] == [_ (satır, 1, 2, 3, 2) [] == [2, 2]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"Qeyri-mənfi ədədlər dizini verildikdə, sıralama işindən sonra verilən dizinin bir nüsxəsini qaytarın, əgər cəmi ((birinci indeks dəyəri, son indeks dəyəri) cütsə, verilən dizini yüksələn sırada sıralayacaqsınız və ya əgər cəmi ((birinci indeks dəyəri, son indeks dəyəri) cütsə, onu aşağı sırada sıralayacaqsınız. Qeyd: * verilən dizini dəyişdirməyin. Nümunələr: * sort_array[(]) => [] * sort_array[]] => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"Bir simli bir arqument olaraq götürən və əlifbanın döndürülməsi ilə şifrələnmiş bir simli geri qaytaran bir funksiyanı şifrələyin. Əlifba hərflərin iki yerə iki dəfə endirilməsi üçün aşağı doğru hərəkət etməsi lazım olan bir şəkildə döndürülməlidir. Məsələn: encrypt (('hi') 'lm' encrypt (('asdfghjkl') 'ewhjklnop' encrypt (('gf') 'kj' encrypt (('et') 'ix' qaytarır.\"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"Sizə tam ədədlər siyahısı verilir. siyahının 2-ci ən kiçik elementini qaytaran next_smallest () funksiyası yazın. Belə bir element yoxdursa, None qaytarın. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == None next_smallest () [1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"Sizə bir sıra sözlər veriləcək və sizin vəzifəniz darıxmaların sayını saymaqdır. Darıxma \"Mən\" sözü ilə başlayan bir cümlədir. Cümlələr '.', '?' və ya '! ' ilə məhdudlaşdırılır. Məsələn: >>> darıxmışam (bir çox) \"Xoşbəxt dünya\") 0 >>> darıxmışam (bir çox) \"Göy mavi. Günəş parlayır. Bu havaya çox bəyənirəm\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''3 ədəd qəbul edən bir funksiya yaradın. Ədədlərdən biri digər ikisinin cəmi ilə bərabərsə və bütün ədədlər tamsaylıdırsa, doğru qaytarır. Digər hallarda yanlış qaytarır. Misallar any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"Bir mesaj alan və bütün hərflərin kazasını dəyişdirən, mesajdakı bütün vokalları ingilis əlifbasında bu vokaldan 2 yer qabaqdakı hərflə əvəz edən bir funksiya yazın. Yalnız hərfləri qəbul edin. Nümunələr: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Sizə tam ədədlərin siyahısı verilir. Ən böyük birinci dəyərini tapmalı və rəqəmlərinin cəminin cəminin qaytarılmasını tələb edir. Məlum olduğu kimi: lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] üçün çıxış 10 olmalıdır lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] üçün çıxış 25 olmalıdır lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] üçün çıxış 13 olmalıdır lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] üçün çıxış 11 olmalıdır lst = [0,81,12,3,21,1] üçün çıxış 3 olmalıdır lst = [0,1,8,2,1,7] üçün çıxış 7 olmalıdır\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"Bir lüğət verilmişsə, bütün düymələr kiçik hərflərlə və ya bütün düymələr böyük hərflərlə silsilələrdirsə True qaytarın, əks halda False qaytarın. Funksiya False qaytarmalıdır. Verilən lüğət boşdur. Nümunələr: check_dict_case ((({\"a\":\"apple\", \"b\":\"banana\"}) True qaytarmalıdır. check_dict_case ((({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) False qaytarmalıdır. check_dict_case ((({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) False qaytarmalıdır. check_dict_case ((({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False qaytarmalıdır. check_dict_case {\"NC:\"STATE\", \"ZIP:\"12345\") True qaytarmalıdır.\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"Mənfi olmayan tam ədəd götürən və n-dən kiçik olan ilk n tam ədəddən ibarət bir sıra qaytaran bir funksiya tətbiq edin. Məsələn: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"İki tam ədədi götürən və onların vahid rəqəmlərinin məhsulunu qaytaran funksiyanı tamamlayın. Girişin həmişə etibarlı olduğunu düşünün. Nümunələr: multiply ((148, 412) 16 qaytarmalıdır multiply ((19, 28) 72. multiply ((2020, 1851) 0 qaytarmalıdır multiply ((14,-15) 20 qaytarmalıdır.\"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"S sətirini verərkən, hətta indekslərdəki böyük hərfli vokalların sayını sayın. Məsələn: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 verir \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''Bir sayı təmsil edən bir dəyər (string) götürən və ona ən yaxın tam ədədi geri qaytaran bir funksiya yaradın. Əgər ədəd iki tam ədəddən bərabər məsafədədirsə, onu sıfırdan uzaqlaşdırın. Nümunələr >>> ən yaxın_tam ədəd ((\"10\") 10 >>> ən yaxın_tam ədəd ((\"15.3\") 15 Qeyd: Sıfırdan uzaqlaşdırmaq, verilən ədədin iki tam ədəddən bərabər məsafədə olması, sıfırdan ən uzaq olanını qaytarmaq deməkdir. Misal üçün ən yaxın_tam ədəd \" ((14.5\") 15 və ən yaxın_tam ədəd \" ((-14.5\") qaytarmalıdır.'''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"Bir müsbət tam n verilmiş, n səviyyəli daşlardan ibarət bir yığın hazırlamalısınız. Birinci səviyyədə n daş var. Növbəti səviyyədəki daşların sayı: - n nərdifdirsə, növbəti cüt saydır. - n cütdürsə, növbəti cüt saydır. Hər səviyyədəki daşların sayını bir siyahıda qaytarın, burada indeksdəki element i səviyyədəki daşların sayını təmsil edir (i + 1). Nümunələr: >>> make_a_pile (i + 1) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"Sizə virgül və ya boşluqlarla ayrılmış sözlər verilir. Sizin vəzifəniz bu sətirləri sözlərə bölmək və sözlərin bir sıralarını qaytarmaqdır. Məsələn: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"Bu funksiya iki müsbət ədəd x və y alır və ən böyük cüt tam ədədi qaytarır [x, y] daxil olmaqla. Belə bir ədəd yoxdursa, onda funksiya -1 qaytarmalıdır. Məsələn: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Sizə n və m ədədləri verilir və sizin vəzifəniz n-dən m-ə qədər olan ədədlərin orta hesabını hesablamaqdır. Cavabı ən yaxın tam ədədə yuvarlayın və ikili ədədlərə çevirin. Əgər n m-dən böyükdürsə, -1-i qaytarın. Məsələn: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"müsbət tam ədədlərin siyahısı verilmişdir x. heç bir cüt rəqəm olmayan bütün elementlərin sıralanmış siyahısını qaytarın. Qeyd: Geri qaytarılan siyahı artan qaydada sıralanmalıdır. Məsələn: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"Bir tam ədədlər dizisi verildikdə, 1 ilə 9 arasında olan tam ədədləri sıralayın, nəticə dizisini tərs edin, sonra hər rəqəmi \"Bir\", \"İki\", \"Üç\", \"Dörd\", \"Beş\", \"Altı\", \"Yeddi\", \"Səkkiz\", \"Doqquz\" dan müvafiq adı ilə əvəz edin. Məsələn: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sıra arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> əks arr -> [8, 5, 4, 3, 2, 2, 1, 1] qaytarın [\"Səkkiz\", \"Dörd\", \"Üç\", \"İki\", \"İki\", \"Bir\", \"Bir\"] Əgər sıra boşdursa, boş bir sıra qaytarın: arr = [] array [] arrayda hər hansı bir qəribə rəqəm varsa, onu görmədən keçin: arr = [1, 1 , 1 , 1 ] -> arr 55 -> arr 55 -> [1, 1 , 1 ] -> ar ar ar ar ar [5, 1 ] - return ['One' 1 ] \"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"F funksiyalarını tətbiq edin ki, n-i parametr kimi qəbul edir və n ölçülü bir siyahı qaytarır, belə ki, indeksdəki elementin dəyəri i cütdürsə i-nin faktorilinin və ya 1 ilə i arasındakı ədədlərin cəmi. i 1-dən başlayır. i-nin faktorili 1 ilə i arasındakı ədədlərin çarpanıdır (1 * 2 * ... * i). Məlum: f ((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"müsbət n tam ədəd verildikdə, daxil olmaqla aralıqdakı cüt və cüt tam ədəd palindromlarının sayına malik bir tuple qaytarın. Məlumat: Giriş: 3 Çıxış: (1, 2) Açıqlama: Tam ədəd palindromları bunlardan 1, 2, 3. bunlardan biri cüt, ikisi isə cütdür. Məlumat: Giriş: 12 Çıxış: (4, 6) Açıqlama: Tam ədəd palindromlar 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. bunlardan dördü cüt, onlardan 6-sı isə cütdür. Qeyd: 1. 1 <= n <= 10 ^ 3 2. tuple sırasıyla cüt və cüt tam ədəd palindromlarının sayını qaytarmışdır. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"Bir say mənfi olarsa, ilk imzalanmış rəqəm mənfi olacaq: məsələn, -123 -in imzalanmış rəqəmləri -1, 2 və 3 olacaqdır.\"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"N tam ədəddən ibarət bir sıra 'arr' var arr[1], arr[2], ..., arr[N].Arraydakı ədədlər təsadüfi qaydada sıralanır. Sizin vəzifəniz verilən sıra üzərində aşağıdakı əməliyyatı yerinə yetirməklə sıralamayı azalma sırasına salmaq mümkün olub olmadığını müəyyən etməkdir: Sizə hər hansı bir sayda sağ tərəfə hərəkət etmək icazəsi verilir. Bir sağ tərəfə hərəkət əməliyyatı, sıra bütün elementlərinin sağ istiqamətdə bir mövqedə hərəkət etməsi deməkdir. Arrayın son elementi sıralamada başlanğıc mövqeyə, yəni 0-cı indeksiyə köçürüləcək. Yuxarıdakı əməliyyatı yerinə yetirməklə sıralanmış sıra əldə etmək mümkündürsə, onda True qaytarın, başqa False qaytarın. Verilən sıra boşdursa, False qaytarın. Qeyd: Verilən siyahıda unikal elementlərin olması təmin edilir. Məsələn: move_one_(ball[3, 4, 5, 2]====================================================================================================================================================================================================================================================================================================\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Bu problemdə, iki nömrə siyahısı alan və lst1 siyahısını yalnız cüt nömrələrdən ibarət etmək üçün onların arasında elementlərin mübadiləsi aparılmasının mümkün olub olmadığını təyin edən bir funksiya tətbiq edəcəksiniz. lst1 və lst2 arasında mübadilə edilən elementlərin sayına məhdudiyyət yoxdur. lst1 və lst2 arasında bütün elementlərin cüt olması üçün elementlərin mübadiləsi mümkündürsə, \"BƏ\" qaytarın. Əks təqdirdə, \"Yox\" qaytarın. Məsələn: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"BƏ\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"Yox\" Giriş siyahılarının boş olmayacağı güman edilir. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"Bir sıra boşluqlarla ayrılmış kiçik hərfləri təmsil edən bir simli verildikdə, ən çox təkrarlanan və müvafiq sayını ehtiva edən hərfin bir lüğətini qaytarın. Bir neçə hərfin eyni olması halında, hamısını qaytarın. Məlum: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4}: histogram ' (((') == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Görev S və c iki simli verilir, s-dəki hər hansı bir simaya bərabər olan bütün simləri silməlisiniz, sonra nəticə simli palindrom olub olmadığını yoxlayın. Bir simli, irəli və geriyə oxuduğu təqdirdə palindrom adlanır. Nəticə simli və True / False olan bir tuple qaytarmalısınız. Məsələn, s = \"abcde\", c = \"ae\" üçün nəticə ('bcd', False) olmalıdır. S = \"abcdef\", c = \"b\" üçün nəticə ('acdef', False) olmalıdır. S = \"abcdedcba\", c = \"ab\", nəticə ('cdedc', True) olmalıdır.\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"Hər bir simli yalnız rəqəmlərdən ibarət olan simli siyahısı verildikdə, bir siyahı qaytarın. Çıxışın hər i elementi \"i giriş simli i-dəki cüt elementlərin sayı\" olmalıdır. burada bütün i-lər giriş simli i-ci cüt rəqəmlərin sayı ilə əvəz edilməlidir. >>> odd_count ['1234567']) [\"4n str4ng 4 4n input.\"] >>> odd_count ['3', \"11111111\"]) [\"1n str1ng 1 1n input. \", \"8n str8ng 8 8n input. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"Tam ədədlərin n-dən ibarət bir sıra verilmişdir, boş olmayan n-in hər hansı bir alt sıralarının minimum cəminin tapılmasını təyin edin. Misal minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"Sizə quyudan ibarət düzbucaqlı bir şəbəkə verilir. Hər bir sıra bir quyunu təmsil edir və hər bir sıra 1 vahid su vahidini təmsil edir. Hər quyunun ondan su çıxarmaq üçün istifadə edilə bilən müvafiq bir kovası var və bütün kovların eyni tutumu var. Sizin vəzifəniz kovları boşaltmaq üçün kovadan istifadə etməkdir. Kovaları aşağı salmaq üçün lazım olan sayı çıxarın. Məlum: Giriş: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Çıxış: 6 Çıxış: Input: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Çıxış: 5 Çıxış: [[0,0,0], [0,0,0]] bucket_capacity: 5 Çıxış: 0 * 1 Çıxış: 1 * 1 Çıxış: 1 * 1 Çıxış: 1 * 1 Çıxış: 1 * 1 Çıxış: 1 * 1 Çıxış: 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * * 2 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"Bu Kata, mənfi olmayan tam sayların dizisini ikili nümayişindəki birlərin sayına görə yüksələn sırada sıralamalısınız. Oxşar bir nömrə üçün onluq dəyərinə əsaslanaraq sıralayın. Bu, belə həyata keçirilməlidir: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"Bir string s və təbii n sayını nəzərə alaraq, bu sözlərin string s-də görünməsi üçün tam n hərfdən ibarət olan string s-dən bütün sözlərin siyahısını qaytaran bir funksiya tətbiq etmək tapşırılıb. Əgər string s boşdursa, onda funksiya boş bir siyahı qaytarmalıdır. Qeyd: giriş simli yalnız hərflər və boşluqlar ehtiva edir. Nümunələr: select_words ((\"Mary had a little lamb\", 4) ==> [\"little\"] select_words ((\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words\"simple white space\", 2) ==> [] select_words ((\"Hello world\", 4) ==> [\"world\"] select_words ((\"Uncle sam\", 3) ==> [\"Uncle\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"Sizə bir söz verilir. Sizin vəzifəniz sözün sağ tərəfindəki iki hərf arasında duran ən yaxın səslənən səsi tapmaqdır (qeyri-həssas). Başlanğıc və sonuncu səslənən səsi saymır. Yuxarıdakı şərti yerinə yetirən hər hansı bir səslənən səsi tapmadığınız təqdirdə boş sətir qaytarın. Verilən sətirin yalnız ingilis hərfi olduğunu düşünə bilərsiniz. Məsələn: get_closest_vowel ((\"yogurt\") ==> \"u\" get_closest_vowel ((\"F\") ==> \"U\" get_closest_vowel ((\"quick\") ==> \"\" get_closest_vowel\" ((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''Sizə iki simli siyahı verilir, hər iki simli yalnız açıq qapaqlardan '(' və ya bağlanan qapaqlardan ') ' ibarətdir. İşiniz iki simli müəyyən bir qaydada birləşdirmək mümkün olub olmadığını yoxlamaqdır, nəticədə yaranan simli yaxşı olacaq. S simli yalnız və yalnız S-dəki bütün qapaqlar balanslı olduqda yaxşı hesab olunur. Məsələn: '((()) ' simli yaxşıdır, '()) ' simli isə deyil. Yaxşı bir simli etmək üçün bir yol varsa 'Bəli' qaytarın, əks halda isə 'Yox' qaytarın. Nümunələr: match_parens [('() ', ') ']) == 'Bəli' match_parens [(') ', ') ']) == 'Yox' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"Bir sıra bütün ədədlər və müsbət tam ədəd k verilmişdir, uzunluğu k olan, maksimum k ədədləri olan sıralanmış bir siyahı qaytarın.Məsələn1: Giriş: arr = [-3, -4, 5], k = 3 Çıxış: [-4, -3, 5]Məsələn2: Giriş: arr = [4, -4, 4], k = 2 Çıxış: [4, 4]Məsələn3: Giriş: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Çıxış: [2] Qeyd: 1. Arrayın uzunluğu [1, 1000] aralığında olacaq. 2. Arraydakı elementlər [-1000, 1000] aralığında olacaq. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"Boş olmayan tam ədədlər siyahısı verildikdə, cüt mövqelərdə olan bütün cüt elementlərin cəminin cəminini qaytarın.\"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"Boş olmayan arr tam ədədləri və k tam ədədləri olan bir sıra verilmişdir, arrın ilk k elementlərindən ən çox iki rəqəm olan elementlərin cəminin cəminini qaytarın. Məlum: Giriş: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Çıxış: 24 # 21 + 3 cəmi Məhdlər: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"Bir müsbət tam n verilmiş, sıralanmış siyahını qaytarın ki, onda cüt ədədlər var. Collatz fərziyyəsi aşağıdakı kimi müəyyən edilmiş ardıcıllıqla əlaqəli riyazi bir fərziyyədir: hər hansı bir müsbət tam n ilə başlayın. Sonra hər bir müddət əvvəlki müddətdən aşağıdakı kimi alınır: əgər əvvəlki müddət cütdirsə, növbəti müddət əvvəlki müddətin yarısıdır. Əgər əvvəlki müddət cütdirsə, növbəti müddət əvvəlki müddətin 3 qatıdır artı 1. Fərziyyə budur ki, n-in hansı dəyəri olursa olsun, ardıcıllıq həmişə 1-ə çatacaq. Qeyd: 1. Collatz ((1) [1] 2. Geri qaytarılan siyahı artan qaydada sıralanır. Məsələn: get_odd_collatz ((5) [1, 5] qaytarır. 5 üçün Collatz ardıcıllığı [5, 8, 16, 4, 2, 1], buna görə də cüt ədədlər yalnız 1 və 5-dir.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"Bir tarix silsiləsini təsdiqləyən və tarix etibarlısa True, əks halda False funksiyasını yazmalısınız. Tarix aşağıdakı qaydaların hamısı yerinə yetirilmişsə etibarlıdır: 1. Tarix silsilesi boş deyil. 2. Günlərin sayı aylar üçün 1 və ya daha çox 31 gündən az deyil. 4.6,9,11 aylar üçün günlərin sayı 1 və ya daha çox 30 gündən az deyil. Aylar 1 və ya daha çox 29 ay üçün 2 və ya daha az olmamalıdır. Aylar 1 və ya daha çox olmamalıdır. 4. Tarix formatında olmalıdır: mm-dd-yyyy məsələn: valid_date (('03-11-2000') => valid_date (('15-01-2012') => False valid_date (('04-040') => False_date (('06-04-2020') => True_date (('06/04/2020') => False\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''Bir söz silsilesi verildikdə, boşluqla bölünmüş sözlərin siyahısını qaytarın, əgər mətndə boşluq yoxdursa, onda virgüllərlə bölünməlisiniz ',' əgər virgül yoxdursa, əlifbada cüt sırada kiçik hərflərin sayını qaytarmalısınız, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 Nümunələr split_words ((\"Hello world!\") â -> [\"Hello\", \"world!\"] split_words ((\"Hello,world!\") â -> [\"Hello\", \"world!\" split_words ((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''Bir siyahı verilmiş sayları, yüksələn sırada sıralanmış və ya sıralanmamışdır. Siyahıda eyni sayın 1 -dən çox nüsxəsi varsa, False qaytarın. Mənfi ədədlər və yalnız tam ədədlər varsayın. Misallar is_sorted ([1, 2, 3, 4, 5]) â -> True is_sorted ([1, 2, 3, 4, 5, 6]) â -> True is_sorted ([1, 2, 3, 4, 5, 6]) â -> True is_sorted ([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted ([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted ([1, 3, 2, 4, 5, 6, 7]) -> False is_sorted ([1, 2, 2, 3, 3, 4]) â -> True is_sorted ([1, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Sizə hər bir intervalın bir cüt tam ədəd olduğu iki interval verilir. Məsələn, interval = (baş, son) = (1, 2). Verilən intervallar qapalıdır, yəni interval (baş, son) həm başlanğıc, həm də sonun daxil olduğu deməkdir. Hər bir interval üçün başlanğıcının sonuna az və ya bərabər olduğu fərz edilir. Sizin vəzifəniz bu iki intervalın kəsişməsinin uzunluğunun bir ədəd olub olmadığını müəyyən etməkdir. Məsələn, intervalların kəsişməsinin uzunluğu 1, hansı ki, ədəd sayı deyil. Əgər kəsişmə uzunluğu ədəd sayıdırsa, \"BƏ\" qaytarın, əks halda \"YƏ\" qaytarın. Əgər iki interval kəsişmirsə, \"YƏ\" qaytarın. [input/output] nümunələri: kəsişmə (((1, 2), (2, 3) ==> \"kəsişmə-1, ((1), 4) ==> \"kəsişmə\", (0, \"NO\", 5), ((1, ==> \"YƏ\", - ((5, -))\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"Sizə tam ədədlər dizisi verilir və tam ədədlərin böyüklüyünün cəmi, dizidəki hər bir rəqəmin bütün əlamətlərinin məhsulu ilə çarpılmışdır, 1, -1 və ya 0 ilə təmsil olunur. Qeyd: boş arr üçün heç bir şey qaytarmayın. Məsələn: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == Heç bir şey\"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"N sıra və N sütun (N > = 2) və müsbət k tam ədədli bir şəbəkə verildikdə, şəbəkənin hər hüceyrəsi bir dəyər ehtiva edir. [1, N * N] daxil olmaqla aralıqdakı hər tam ədəd şəbəkənin hüceyrələrində tam bir dəfə görünür. K uzunluğunda minimum yolu tapmalısınız. Hər hansı bir hüceyrədən başlaya bilərsiniz və hər addımda qonşu hüceyrələrdən hər hansı birinə keçə bilərsiniz, başqa sözlə, sizinlə bir kənar paylaşan hüceyrələrə gedə bilərsiniz. Lütfən qeyd edin ki, k uzunluğunda bir yol tam k hüceyrəni ziyarət etmək deməkdir (mümkün deyil ki, fərqli). Şəbəkədən çıxa bilməzsiniz. A yolu (k uzunluğu) A və B hüceyrələrindəki dəyərlərin sifarişli siyahılarını düzəldikdən sonra B (k uzunluğu) yolundan daha az hesab olunur (onları lA_st və lA_st adlandırırıq), lA_st lexik olaraq lA_st-dan azdır, lA_st hüceyrələrdəki, başqa sözlə, hər hansı bir hüceyrənin kənarını bölüşən hüceyrələrə keçə bilərsiniz. [A=1, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, lA, l] hüce, lA, l[i, l] hüceyrı, l[i, l] hüceyrı, l[i, l[i, l] hüceyrə, l[i, l[i, l] hüceyrə, l[i, l[i, l] hər hansı bir hüceyrə, l[i, l] hər hansısa, l[i, l[i, l[i, l] hər hansı bir hüce, l[i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,i,\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"Hər kəs Fibonaççi ardıcıllığını bilir, son iki əsrdə riyaziyyatçılar tərəfindən dərindən öyrənilmişdir. Bununla birlikdə, insanların bilmədikləri Tribonacci ardıcıllığıdır. Tribonacci ardıcıllığı təkrarlanma ilə müəyyən edilir: tri(1) = 3 tri(n) = 1 + n / 2, əgər n cütdirsə. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), əgər n cütdürsə. Məsələn: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sizə mənfi olmayan tam nömrə verilir, Tribonacci ardıcıllığının ilk n + 1 nömrələrinin siyahısını qaytarmalısınız. Nümunələr: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"Bir müsbət tam n verilmişsə, tək rəqəmlərin məhsulunu qaytarın. Bütün rəqəmlər cütdürsə 0 qaytarın. Məsələn: rəqəmlər ((1) == 1 rəqəm ((4) == 0 rəqəm ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''Yalnız kvadrat qapaqları olan bir simli giriş olaraq qəbul edən bir funksiya yaradaq. Funksiya yalnız qapaqların ən az bir qapağın yuvalaşdırıldığı etibarlı bir alt ardıcıllığı varsa və yalnız varsa True qaytarmalıdır. is_nested '[[]]') â -> True is_nested '[[]]]]]]][[[[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]]') â -> True is_nested '[[]]]]]]]] â -> True'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Sizə nömrələr siyahısı verilir. Verilən siyahıdakı nömrələrin kvadratının cəminin qaytarılması, siyahıdakı hər bir elementi ilk növbədə yuxarı int (yuxarı) ilə yuvarlamaq lazımdır. Nümunələr: lst = [1,2,3] üçün çıxış 14 olmalıdır lst = [1,4,9] üçün çıxış 98 olmalıdır lst = [1,3,5,7] üçün çıxış 84 olmalıdır lst = [1.4,4.2,0] üçün çıxış 29 olmalıdır lst = [-2.4,1,1] üçün çıxış 6 olmalıdır \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''Verilmiş simli son simli əlifba simli və bir sözün bir hissəsi deyilsə və əks halda False qaytaran bir funksiya yaradır. Qeyd: \"söz\" boşluqla ayrılmış simvollar qrupudur. Nümunələr: check_if_last_char_is_a_letter ((\"elmalı pasta\") â -> False check_if_last_char_is_a_letter ((\"elmalı pi e\") â -> True check_if_last_char_is_a_letter ((\"elmalı pi e\") â -> False check_if_last_char_is_a_letter\" (((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"Bir elementin ən böyük indeksini geri qaytaran bir funksiya yaradın. Bu elementin dərhal əvvəlki elementdən böyük və ya bərabər olmadığı halda geri qaytarın -1. Verilən sıra təkrarlanan dəyərləri ehtiva etməyəcəkdir. Nümunələr: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''Bir tuple (a, b) qaytaracaq bir funksiya yaradın, burada 'a' mənfi tam sayların ən böyüyüdür və 'b' bir siyahıdakı müsbət tam sayların ən kiçikidir. Əgər mənfi və ya müsbət tam saylar yoxdursa, onları None olaraq qaytarın. Nümunələr: ən böyük_ən kiçik_tam saylar[2, 4, 1, 3, 5, 7]) == (Heç bir, 1) ən böyük_ən kiçik_tam saylar (([]) == (Heç bir, Heç bir) ən böyük_ən kiçik_tam saylar (([0]) == (Heç bir, Heç bir) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"Real ədədləri təmsil edən tam ədədləri, üzən ədədləri və ya simli ədədləri qəbul edən və verilən dəyişən növündə daha böyük dəyişənləri geri qaytaran bir funksiya yaradın. Dəyərlər bərabərdirsə, Heç bir şey qaytarın. Qeyd: Əgər real ədəd simli kimi təmsil olunursa, üzən nöqtə ola bilər . və ya , compare_one ((1, 2.5) â -> 2.5 compare_one ((1, \"2,3\") â -> \"2,3\" compare_one ((5,1\", \"6\") â -> \"6\" compare_one ((1\", 1) â -> Heç bir şey \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Verilmiş n sayının tam olaraq 4 müsbət cüt sayın cəmi olaraq yazıla biləcəyini qiymətləndirin. Misal: cüt sayın cəmi ilə bərabərdir.\"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"Braziliya faktoriali belə təyin olunur: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! harada ki, n > 0 Məsələn: >>> special_factorial ((4) 288 Funksiya giriş kimi tam ədəd alacaq və bu tam ədədin xüsusi faktorilini qaytarmalıdır. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_Nümunə-3rilirsə, bütün boşluqları alt işarələrlə əvəz edin və bir simlin ardıcıl 2 boşluqdan çoxdursa, sonra bütün ardıcıl boşluqları - fix_spaces ((\"Məsəl\") ilə əvəz edin == \"Məsəl\" fix_spaces ((\"Məsəl1\") == \"Məsəl_1\" fix_spaces (((\"Məsəl2\") == \"_Məsəl_2\" fix_spaces ((\"Məsəl 3\") == \"_Məsəl-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Bir faylın adını təmsil edən bir simli götürən və faylın adı etibarlı olduqda 'Bəli' qaytaran və əks halda 'Xeyr' qaytaran bir funksiya yaradın. Bir faylın adı etibarlı sayılır və yalnız aşağıdakı şərtlərin hamısı yerinə yetirilmişsə: - Faylın adında üçdən çox rəqəm ('0'-'9') olmamalıdır. - Faylın adında tam olaraq bir nöqtə ' var. - Nöqtədən əvvəlki alt simli boş olmamalıdır və latın alfabetinin hərfi ilə başlamalıdır ('a'-'z' və 'A'Z'). - Nöqtədən sonra alt simli bunlardan biri olmalıdır: ['txt', 'exe', 'll'] Nümunələr: file_name_check\"(example.txt\") # => 'Bəli' file_name_check\"(example.dll1\") => 'Xeyr' (ad latın alfabetinin hərfi ilə başlamalıdır)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" Bu funksiya tam ədədlərin siyahısını götürəcək. Siyahıdakı bütün girişlər üçün, funksiyanın indeksi 3 qatı olsa tam ədəd girişini kvadratlaşdırmalıdır və indeksi 3 qatı olmasa 4 qatı olsa tam ədəd girişini kublaşdırır. Funksiya indeksi 3 və ya 4 qatı olmayan siyahıdakı girişləri dəyişdirməyəcək. Funksiya sonra bütün girişlərin cəminin nəticəsini qaytarmalıdır. Nümunələr: lst = [1,2,3] üçün çıxış 6 olmalıdır lst = [] üçün çıxış 0 olmalıdır lst = [-1,-5,2,-1,-5] üçün çıxış -126 olmalıdır \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"Bir cümləni təmsil edən bir simli verilir, cümlədə boşluqla ayrılmış bəzi sözlər var və uzunluğu ilkin cümlədən olan sözləri ehtiva edən bir simli qaytarmalısınız, yeni simlidəki sözlərin sırası orijinalınki ilə eyni olmalıdır.Məsələn1: Giriş: cümlə = \"Bu bir testdir\" Çıxış: \"dir\"Məsələn2: Giriş: cümlə = \"gəl üzməyə gedək\" Çıxış: \"get\" Məhdudlaşdırmalar: * 1 <= len(cümlə) <= 100 * cümlə yalnız hərfləri ehtiva edir \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"Sizin vəzifəniz x * n ifadəsini sadələşdirəcək bir funksiya tətbiq etməkdir. X * n tam bir ədəd qiymətləndirirsə və əks halda False funksiyası True qaytarır. Həm x, həm də n, bir hissənin simli təmsilidir və aşağıdakı formatı var, <sayıcı> / <nüminator> burada həm sayıcı, həm də təmsilçi müsbət tam ədədlərdir. x və n-in etibarlı qrupu olduğunu və sıfırın təmsilçisi olmadığını fərz edə bilərsiniz. sadələşdirmək (((\"1/5\", \"5/1\") = True sadələşdirmək (((\"1/6\", \"2/1\") = False sadələşdirmək (((\"7/10\", \"10/2\") = False \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"Verilən tamsaylıların siyahısını rəqəmlərinin cəminə görə yüksələn sırada sıralayan bir funksiya yazın. Qeyd: rəqəmlərinin oxşar cəmi olan bir neçə maddə varsa, onları orijinal siyahıdakı indekslərinə əsasən sıralayın. Məsələn: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"Bir sıra nömrələrdən ibarət bir sıra daxil edən və 10 -dan böyük olan sıra elementlərinin sayını qaytaran bir funksiya yazın və bir nömrənin həm ilk, həm də son rəqəmləri cütdür (1, 3, 5, 7, 9). Məsələn: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"Sizə müsbət tam n ədəd verilir. Siz uzunluğu n olan tam ədədlər dizisi yaratmalısınız. Hər i (1 ‰¤ i ‰¤ n) üçün a[i] = i * i - i + 1 dəyəri. a-nın üçlüyünün (a[i], a[j], a[k]) sayını qaytarın, burada i < j < k, və a[i] + a[j] + a[k] 3-ün qatıdır. Məlum: Giriş: n = 5 Çıxış: 1 Açıqlama: a = [1, 3, 7, 13, 21] Yeganə etibarlı üçlüyə (1, 7, 13) aiddir.\"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''Günəş sistemimizdə səkkiz planet var: Günəşə ən yaxın olan Merkuri, növbəti Venera, sonra Yer, Mars, Yupiter, Saturn, Uran, Neptun. İki planet adını planet1 və planet2 simvolları kimi götürən bir funksiya yazın. Funksiya, orbitləri planet1 və planet2 orbitləri arasında yerləşən bütün planetləri ehtiva edən, Günəşə yaxınlığı ilə sıralanmış bir tuple qaytarmalıdır. Funksiya, planet1 və ya planet2 planet adları düzgün deyilsə, boş bir tuple qaytarmalıdır. Misallar bf \"(Yupiter\", \"Neptun\") ==> (\"Saturn\", \"Uran\") bf (((\"Yer\", \"Mercury\") ==> (\"Venus\") bf (((\"Mercury\", \"Uran\") ==> (\"Venus\", \"Yer\", \"Mars\", \"Yupiter\", \"Sn\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Bir funksiya yazın ki, bu funksiya simli silinmələri qəbul edir. Bu funksiya simli silinmələri silər və nəticədə silinmələri sıralanmış qaydada qaytarır. Siyahı həmişə simli silinmələr siyahısıdır və heç vaxt nömrələr dizisi deyil. Bu funksiya hər bir sözün uzunluğuna görə yüksələn olmalıdır və siz bu qaydaya uyğun olaraq sıralanmış siyahını qaytarmalısınız. Əgər iki söz eyni uzunluğa malikdirsə, siyahını əlifba sırası ilə sıralandırın. Funksiya simli silinmələrin siyahısını sıralanmış qaydada qaytarmalıdır. Bütün sözlərin eyni uzunluğa sahib olacağını düşünə bilərsiniz. Məsələn: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => [\"ab\", \"cd\"]\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"n bir ədəd olsa x-in dəyərini qaytarmalı və əks halda y-in dəyərini qaytarmalı olan sadə bir proqram. Nümunələr: x_or_y ((7, 34, 12) üçün == 34 x_or_y ((15, 8, 5) üçün == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''Bir sıra verilmiş saylar siyahısında, siyahıdakı tək olan ədədlərin kvadratlarının cəmi qaytarılır. Mənfi və ya tam olmayan ədədləri görmədən. ikiqat_fark (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 ikiqat_fark (([-1, -2, 0]) == 0 ikiqat_fark (([9, -2]) == 81 ikiqat_fark (([0]) == 0 Giriş siyahısı boşdursa, 0 qaytarın. '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"Bu, bir çox insanın bir sıra uyğunluqların nəticələrini düzgün təxmin etdiyini müəyyən etməkdir. Sizə hər bir indeksin uyğunluğunu göstərdiyi eyni uzunluqda iki sıra bal və təxmin verilir. Hər bir təxminin nə qədər uzaq olduğunu göstərən eyni uzunluqda bir sıra qayıdır. Əgər düzgün təxmin etsələr, dəyər 0-dur, əgər yoxsa, dəyər təxmin və nəticə arasındakı mütləq fərqdir. misal: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4],[4,1,0,-2]) -> [4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Sizə bir sinif adı (bir simli) və uzantıların siyahısı veriləcək. Uzantılar sinifə əlavə siniflər yükləmək üçün istifadə ediləcəkdir. Uzantının gücü aşağıdakı kimidir: CAP uzantının adında böyük hərflərin sayı olsun, SM isə uzantının adında kiçik hərflərin sayı olsun, güc CAP - SM ədədi ilə verilir. Ən güclü uzantını tapmalı və bu formatda bir simli qaytarmalısınız: ClassName.StrongestExtensionName. Əgər eyni güclə iki və ya daha çox uzantı varsa, siyahıda ilk gələnini seçməlisiniz. Məsələn, sizə sinif və uzantıların siyahısı kimi \"Slices\" verilirsə: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] sonra 'Slices.SEviRNGSliCes' 'SviRNGSliCes' 'mySviRNGSliCes' 'mySviRNGSliCes' 'mySviRNGSliCes']) uzantısı güclü olduğundan 'Slices.Slices' qaytaracaqsınız.\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Sizə 2 söz verilir. İkinci söz və ya onun hər hansı bir dönməsinin birinci sözün alt simli olması halında True qaytarmalısınız cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"Bir tam ədəd verildiyi təqdirdə, müvafiq olaraq cüt və cüt rəqəmlərin sayına malik bir tuple qaytarın. Məlum: cüt_cüt_say ((-12) ==> (1, 1) cüt_cüt_say ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"müsbət tam ədəd verildikdə, onun roman rəqəm ekvivalentini bir simli olaraq əldə edin və kiçik hərflə qaytarın. Məhdudlaşdırmalar: 1 <= num <= 1000 Nümunələr: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''Üçbucağın üç tərəfinin uzunluqları verilmişdir. Üç tərəfi düzbucaqlı üçbucaq təşkil edərsə True qaytarın, əks halda False. Düzbucaqlı üçbucaq bir bucaqın düzbucaqlı və ya 90 dərəcə olduğu üçbucaqdır. Məsələn: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"Bir sıra simli qəbul edən bir funksiya yazın. Siyahı müxtəlif sözlər ehtiva edir. Ən çox unikal simli olan sözü qaytarın. Birdən çox simli ən çox unikal simli olan varsa, leksikografik sırada ilk gələnini qaytarın.\"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"Ac bir dovşansınız və artıq müəyyən sayda havuç yediniz, amma indi günün yeməklərini tamamlamaq üçün daha çox havuç yeməlisiniz. bir sıra qaytarmalısınız [ yeməkdən sonra yeyilən havuçların ümumi sayı, yeməkdən sonra qalan havuçların sayı ] kifayət qədər havuç qalmasa, qalan havuçları yeyəcəksiniz, amma yenə də ac olacaqsınız. Məlum: * yeyin ((5, 6, 10) -> [11, 4] * yeyin ((4, 8, 9) -> [12, 1] * yeyin ((1, 10, 10) -> [11, 0] * yeyin ((2, 11, 5) -> [7, 0] Dəyişənlər: @number: yediyiniz havuçların tam sayını. @need: yemə ehtiyacınız olan havuçların tam sayını. @remaining: ehtiyatda qalan havuçların tam sayını təyin edin: * 0 = <= 0 * 1000 * 0 = <= 1000 * 0 = <= 1000 = = 0 Qalan havuç:\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"Operator və operand iki siyahı verilir. Birinci siyahıda əsas cəbr əməliyyatları var, ikinci siyahı isə tamsaylıların siyahısıdır. Verilən iki siyahıdan istifadə edərək cəbr ifadəsi qurun və bu ifadəni qiymətləndirməsini qaytarın. Əsas cəbr əməliyyatları: Əlavə (+) Sığortalanma (-)) Multiplikasiya ( *) Döşəmə bölünməsi ( //) Eksponentiasiya ( **) Nümunə: operator['+', '*', '-'] array = [2, 3, 4, 5] nəticə = 2 + 3 * 4 - 5 => nəticə = 9 Qeyd: Operator siyahısının uzunluğu operand siyahısının uzunluğuna bərabərdir. Operand mənfi olmayan tamsaylıların siyahısıdır. Operator siyahısında ən azı bir operator, operand siyahısında isə ən azı iki operand var. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"S[i] hərfdirsə, aşağıdan yuxarıya və ya əksinə, əksinə olduğu kimi saxlayın. Əgər simli heç bir hərf yoxdursa, simli əksinə çevirin. Funksiya nəticə simlini qaytarmalıdır. Nümunələr həll etmək ((\"1234\") = \"4321\" həll etmək ((\"ab\") = \"AB\" həll etmək ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"Bir simli 'mətn' verilmişsə, onun md5 hash ekvivalent simlini qaytarın. Əgər 'mətn' boş simlidirsə, None qaytarın. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "azj_Latn",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"İki müsbət tam ədəd a və b verildikdə, a və b arasındakı cüt rəqəmləri yüksələn qaydada qaytarın. Məsələn: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]