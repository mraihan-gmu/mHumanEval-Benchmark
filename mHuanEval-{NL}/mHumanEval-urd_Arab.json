[
    {
        "task_id": "HumanEval/0",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"چیک کریں کہ آیا اعداد کی دی گئی فہرست میں ، کوئی دو نمبر ایک دوسرے سے دیئے گئے حد سے قریب ہیں۔ مثال: >>> has_close_elements (([1.0 ، 2.0 ، 3.0 ، 0.5) غلط >>> has_close_elements (([1.0 ، 2.8 ، 3.0 ، 4.0 ، 5.0 ، 2.0 ، 0.3) سچ \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"اس فنکشن میں ان پٹ ایک تار ہے جس میں گھوںسلا قوسین کے متعدد گروپس ہیں۔ آپ کا مقصد ان گروپوں کو الگ الگ تاروں میں الگ کرنا اور ان کی فہرست واپس کرنا ہے۔ الگ الگ گروپ متوازن ہیں (ہر کھلا قوسین مناسب طریقے سے بند ہے) اور ایک دوسرے کے اندر گھوںسلا نہیں ہے۔ ان پٹ تار میں کسی بھی جگہ کو نظرانداز کریں۔ مثال: >>> الگ_پارن_گروپس ' (() (() (())))) ' [' (() '، ' ((()) '، '(() '))\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"ایک مثبت فلوٹنگ پوائنٹ نمبر دیا گیا ہے ، اسے انٹیجر حصہ (دیئے گئے نمبر سے چھوٹا سب سے بڑا عدد) اور اعشاریہ (باقی حصہ ہمیشہ 1 سے چھوٹا) میں تقسیم کیا جاسکتا ہے۔ نمبر کا اعشاریہ حصہ لوٹائیں۔ مثال: >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"آپ کو ایک بینک اکاؤنٹ پر جمع اور واپسی کے آپریشن کی ایک فہرست دی گئی ہے جو صفر بیلنس سے شروع ہوتی ہے۔ آپ کا کام یہ معلوم کرنا ہے کہ اگر کسی بھی وقت اکاؤنٹ کا بیلنس صفر سے نیچے آجاتا ہے تو ، اور اس وقت فنکشن کو درست واپس آنا چاہئے۔ بصورت دیگر اسے غلط واپس آنا چاہئے۔ مثال: >>> below_zero([1، 2، 3]) غلط >>> below_zero([1، 2، -4، 5]) سچ \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"ان پٹ نمبروں کی ایک دی گئی فہرست کے لئے ، اس ڈیٹا سیٹ کے اوسط کے ارد گرد اوسط مطلق انحراف کا حساب لگائیں۔ اوسط مطلق انحراف ہر عنصر اور ایک مرکز نقطہ کے مابین اوسط مطلق فرق ہے (اس معاملے میں اوسط): MAD = اوسط ۰ x - x_میئن ۰ مثال: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"ان پٹ لسٹ کے ہر دو مسلسل عناصر کے درمیان ایک نمبر 'ڈیلیمیٹر' داخل کریں `numbers' >>> intersperse([] ، 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"اس فنکشن میں ان پٹ ایک تار ہے جس میں گھوںسلا قوسین کے لئے متعدد گروپوں کی نمائندگی کی جاتی ہے جو خالی جگہوں سے الگ ہیں۔ ہر گروپ کے لئے ، قوسین کی گھوںسلا کی گہری سطح کو آؤٹ پٹ کریں۔ مثال کے طور پر (() (()) میں گھوںسلا کی زیادہ سے زیادہ دو سطحیں ہیں جبکہ ((())) میں تین ہیں۔ >>> parse_nested_parens('((()) ((())) () ((()) ((()))) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"صرف ان لوگوں کے لئے تاروں کی ایک ان پٹ فہرست کو فلٹر کریں جس میں دیئے گئے سبسٹرنگ >>> فلٹر_بائی_سبسٹرنگ (([] ، 'a') [] >>> فلٹر_بائی_سبسٹرنگ ((['abc' ، 'bacd' ، 'cde' ، 'array' ، 'a') ['abc' ، 'bacd' ، 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"عددی اعداد کی ایک دی گئی فہرست کے لئے ، ایک فہرست میں شامل تمام عددی اعداد کے مجموعہ اور ایک مصنوع پر مشتمل ایک ٹپل واپس کریں۔ خالی رقم 0 کے برابر ہونی چاہئے اور خالی مصنوع 1 کے برابر ہونی چاہئے۔ >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"عددی اعداد کی ایک دی گئی فہرست سے ، تسلسل میں دیئے گئے لمحے تک پائے جانے والے رولنگ میکس عنصر کی ایک فہرست تیار کریں۔ >>> رولنگ_میکس (([1، 2، 3، 2، 3، 4، 2]) [1، 2، 3، 3، 3، 4، 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"سب سے مختصر پالینڈوم تلاش کریں جو فراہم کردہ تار سے شروع ہوتا ہے۔ الگورتھم کا خیال آسان ہے: - فراہم کردہ تار کا سب سے طویل پوسٹ فکس تلاش کریں جو ایک پالینڈوم ہے۔ - تار کے اختتام پر اسٹرنگ پریفیکس کا الٹ جوڑیں جو پالینڈومک لاحقہ سے پہلے آتا ہے۔ >>> make_palindrome('') ' ' >>> make_palindrome('cat') 'catac' >>> make_palindrome('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"ٹیسٹ اگر دی گئی تار ایک palindrome ہے \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"ان پٹ دو تار ہیں a اور b صرف 1s اور 0s پر مشتمل ہے۔ ان ان پٹ پر بائنری XOR انجام دیں اور نتیجہ کو تار کے طور پر بھی لوٹائیں۔ >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"تاروں کی فہرست میں سے ، سب سے طویل کو واپس کریں۔ ایک ہی لمبائی کی متعدد تاروں کی صورت میں پہلا واپس کریں۔ ان پٹ لسٹ خالی ہونے کی صورت میں کوئی نہیں لوٹائیں۔ >>> longest([]) >>> longest(['a', 'b', 'c']) 'a' >>> longest(['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"دو عدد a اور b کے سب سے بڑے مشترک تقسیم کار کو لوٹاتا ہے >>> سب سے بڑا_عام_تقسیم کار ({3, 5) 1 >>> سب سے بڑا_عام_تقسیم کار ({25, 15) 5)\"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"ان پٹ سٹرنگ کے سب سے مختصر سے سب سے طویل تک تمام پیشگیوں کی فہرست واپس کریں >>> all_prefixes (('abc') ['a'، 'ab'، 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"ایک تار کو واپس کریں جس میں 0 سے شروع ہونے والے خلائی حد بند اعداد شامل ہوں۔ >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"ایک تار دی گئی ہے، یہ پتہ لگائیں کہ کتنے مختلف حروف (بغیر کسی صورت کے) پر مشتمل ہے >>> count_distinct_characters ((('xyzXYZ') 3 >>> count_distinct_characters ((('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"ان پٹ اس فنکشن میں ایک تار ہے جو موسیقی کے نوٹوں کی نمائندگی کرتا ہے ایک خصوصی ASCII فارمیٹ میں۔ آپ کا کام یہ ہے کہ انٹیگرز کی تار کی فہرست کو تجزیہ کیا جائے جو بہت سے دھڑک کے مطابق ہے۔ یہاں ایک لیجنڈ ہے: 'o' نوٹ ، آخری چار دھڑک 'o' بیکس '- نصف نوٹ ، آخری دو دھڑک '- کوارٹر نوٹ ، آخری ایک دھڑک >>> parse_music '.. o' .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"معلوم کریں کہ اصل تار میں کتنی بار ایک دی گئی سبسٹرنگ مل سکتی ہے۔ اوورلیپنگ کیسز گنیں۔ >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"ان پٹ 'صفر' سے 'نو' تک عددیوں کی جگہ سے منسلک تار ہے۔ درست انتخاب 'صفر' ، 'ایک' ، 'دو' ، 'تین' ، 'چار' ، 'پانچ' ، 'چھ' ، 'سات' ، 'آٹھ' اور 'نو' ہیں۔ چھوٹے سے بڑے تک ترتیب دیئے گئے نمبروں کے ساتھ تار کو لوٹائیں >>> sort_numbers (('تین ایک پانچ') 'ایک تین پانچ' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"اعداد کی فراہم کردہ فہرست (کم از کم دو کی لمبائی) سے دو کا انتخاب کریں اور واپس کریں جو ایک دوسرے کے قریب ہیں اور انہیں ترتیب سے واپس کریں (چھوٹی تعداد ، بڑی تعداد) ۔ >>> find_closest_elements (([1.0 ، 2.0 ، 3.0 ، 4.0 ، 5.0 ، 2.2)) (2.0 ، 2.2) >>> find_closest_elements (([1.0 ، 2.0 ، 3.0 ، 4.0 ، 5.0 ، 2.0]) (2.0 ، 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"اعداد کی فہرست دی گئی (کم از کم دو عناصر کی) ، اس فہرست میں ایک لکیری تبدیلی کا اطلاق کریں ، تاکہ سب سے چھوٹی تعداد 0 ہوجائے اور سب سے بڑی تعداد 1 ہوجائے >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"فلٹر کسی بھی پائیتھون اقدار کی دی گئی فہرست صرف انٹیجرز کے لئے >>> فلٹر_انٹیجرز ((['a'، 3.14, 5]) [5] >>> فلٹر_انٹیجرز (([1, 2, 3, 'abc'، {}، []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"دی گئی تار کی واپسی کی لمبائی >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"ایک دی گئی تعداد n کے لئے، سب سے بڑی تعداد تلاش کریں جو n کو یکساں طور پر تقسیم کرتی ہے، n سے چھوٹی >>> سب سے بڑی_ تقسیم کنندہ ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"دیئے گئے انٹیجر کے پرائم فیکٹرز کی فہرست کو سب سے چھوٹی سے سب سے بڑی ترتیب میں لوٹائیں۔ ہر ایک فیکٹر کو اس تعداد کے مطابق درج کیا جانا چاہئے کہ وہ فیکٹرائزیشن میں کتنی بار ظاہر ہوتا ہے۔ ان پٹ نمبر تمام عوامل کے مصنوع کے برابر ہونا چاہئے >>> فیکٹرز ((8) [2، 2، 2] >>> فیکٹرز ((25) [5، 5] >>> فیکٹرز ((70) [2، 5، 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"انٹیجرز کی فہرست سے ، تمام عناصر کو ہٹا دیں جو ایک سے زیادہ بار پیش ہوں۔ عناصر کی ترتیب کو ان پٹ کی طرح ہی چھوڑ دیں۔ >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"ایک دیئے گئے تار کے لئے، چھوٹے حروف کو بڑے حروف اور بڑے حروف کو چھوٹے حروف میں تبدیل کریں۔ >>> flip_case ((('ہیلو') 'ہیلو' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"ایک ہی تار میں سٹرنگز کی فہرست کو جوڑیں >>> concatenate([]) '' >>> concatenate(['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"صرف ان لوگوں کے لئے تاروں کی ایک ان پٹ فہرست کو فلٹر کریں جو کسی دیئے گئے پیش لفظ سے شروع ہوتے ہیں۔ >>> filter_by_prefix([] ، 'a') [] >>> filter_by_prefix(['abc' ، 'bcd' ، 'cde' ، 'array' ، 'a') ['abc' ، 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"فہرست میں صرف مثبت نمبر واپس کریں۔ >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"اگر کوئی دی گئی تعداد پرائم ہے تو درست ہے ، اور دوسری صورت میں غلط ہے۔ >>> is_prime(6) غلط >>> is_prime(101) سچ >>> is_prime(11) سچ >>> is_prime(13441) سچ >>> is_prime(61) سچ >>> is_prime(4) غلط >>> is_prime(1) غلط \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs ایک کثیرالاضلاع کے ضارب ہیں۔ find_zero find x such that poly(x) = 0. find_zero صرف صفر پوائنٹ لوٹاتا ہے ، یہاں تک کہ اگر بہت سارے ہوں۔ مزید برآں ، find_zero صرف فہرست xs لیتا ہے جس میں کوفیشنٹ کی بھی تعداد اور سب سے بڑا غیر صفر کوفیشنٹ ہوتا ہے کیونکہ یہ حل کی ضمانت دیتا ہے۔ >>> round ((find_zero[(1, 2]) ، 2) # f(x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]) ، 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6 ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"نقطہ x پر کوفیشنٹس xs کے ساتھ کثیرالاضلاع کا جائزہ لیتا ہے۔ واپسی xs[0] + xs [1] * x + xs [1] * x ^ 2 + .... xs [n] * x ^ n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"یہ فنکشن ایک فہرست لیتا ہے اور ایک فہرست لوٹاتا ہے l' اس طرح کہ l' انڈیکس میں l کے ساتھ مماثل ہے جو تین سے تقسیم نہیں ہوتے ہیں ، جبکہ انڈیکس میں اس کی اقدار جو تین سے تقسیم ہوتی ہیں وہ l کے متعلقہ انڈیکس کی اقدار کے برابر ہیں ، لیکن ترتیب دی گئی ہیں۔ >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"ایک فہرست میں ترتیب دیا منفرد عناصر واپس کریں >>> منفرد (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"فہرست میں زیادہ سے زیادہ عنصر واپس کریں۔ >>> max_element([1، 2، 3]) 3 >>> max_element([5، 3، -5، 2، -3، 3، 9، 0، 123، 1، -10]) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"اعداد 7 کی تعداد کو واپس کریں جو 11 یا 13 سے تقسیم ہونے والے انٹیجرز میں n سے کم ہوتے ہیں۔ >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"یہ فنکشن ایک فہرست لیتا ہے اور ایک فہرست لوٹاتا ہے l' اس طرح کہ l' عجیب اشاریہ جات میں l کے ساتھ مماثل ہے ، جبکہ اس کی قدریں یہاں تک کہ اشاریہ جات میں بھی l کے یہاں تک کہ اشاریہ جات کی اقدار کے برابر ہیں ، لیکن ترتیب دی گئی ہیں۔ >>> sort_even (([1، 2، 3]) [1، 2، 3] >>> sort_even (([5، 6، 3، 4]) [3، 6، 5، 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"ان پٹ سٹرنگ کے طور پر لیتا ہے جس میں انکوڈ_سائیکلک فنکشن کے ساتھ انکوڈ کیا گیا ہے۔ ڈیکوڈڈ سٹرنگ لوٹاتا ہے۔\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"تین حروف کے سائیکلنگ گروپوں کی طرف سے کوڈت تار واپس کرتا ہے.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib لوٹاتا ہے n-ویں نمبر جو ایک فبونیکی نمبر ہے اور یہ بھی پرائم ہے۔ >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero ان پٹ کے طور پر انٹیجرز کی ایک فہرست لیتا ہے۔ یہ درست لوٹاتا ہے اگر فہرست میں تین الگ الگ عناصر ہیں جو صفر پر جمع کرتے ہیں ، اور غلط دوسری صورت میں۔ >>> triples_sum_to_zero([1، 3، 5، 0]) غلط >>> triples_sum_to_zero[1، 3، -2، 1]) سچ >>> triples_sum_to_zero([1، 2، 3، 7]) غلط >>> triples_sum_to_zero([2، 4، 5، 3، 9، 7]) سچ >>> triples_sum_to_zero[1]) غلط \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"ایک سڑک کا تصور کریں جو ایک بالکل سیدھی لامحدود لمبی لائن ہے۔ n کاریں بائیں سے دائیں جارہی ہیں۔ بیک وقت ، n کاروں کا ایک مختلف سیٹ دائیں سے بائیں جارہا ہے۔ کاروں کے دونوں سیٹ ایک دوسرے سے بہت دور ہونے سے شروع ہوتے ہیں۔ تمام کاریں ایک ہی رفتار سے حرکت کرتی ہیں۔ جب بائیں سے دائیں جانے والی کار دائیں سے بائیں جانے والی کار سے ٹکرا جاتی ہے تو دو کاروں کو ٹکرانے کا کہا جاتا ہے۔ تاہم ، کاریں لامحدود مضبوط اور مضبوط ہوتی ہیں۔ اس کے نتیجے میں ، وہ اپنے راستے پر چلتے رہتے ہیں گویا وہ ٹکرا نہیں رہے ہیں۔ یہ فنکشن اس طرح کے تصادم کی تعداد کو آؤٹ پٹ کرتا ہے۔ \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"1 کے ذریعہ اضافہ شدہ عناصر کے ساتھ واپسی کی فہرست۔ >>> incr_list (([1، 2، 3]) [2، 3، 4] >>> incr_list (([5، 3، 5، 2، 3، 3، 9، 0، 123]) [6، 4، 6، 3، 4، 10، 1، 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero ان پٹ کے طور پر انٹیجرز کی ایک فہرست لیتا ہے۔ یہ درست لوٹاتا ہے اگر فہرست میں دو الگ الگ عناصر ہیں جو صفر پر جمع کرتے ہیں ، اور غلط دوسری صورت میں۔ >>> pairs_sum_to_zero([1، 3، 5، 0]) غلط >>> pairs_sum_to_zero[(1، 3، -2، 1]) غلط >>> pairs_sum_to_zero([1، 2، 3، 7]) غلط >>> pairs_sum_to_zero([2، 4، 5، 3، 7]) سچ >>> pairs_sum_to_zero[1]) غلط \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"ان پٹ نمبر x کی عددی بنیاد کو بیس میں تبدیل کریں۔ تبادلوں کے بعد تار کی نمائندگی لوٹائیں۔ بیس نمبر 10 سے کم ہیں۔ >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"ایک مثلث کے لئے ایک طرف کی لمبائی اور اعلی واپسی کے علاقے کو دیا گیا ہے۔ >>> مثلث_عرض (، 5، 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Fib4 نمبر سیکینس فبونیکی سیکینس کی طرح ایک سیکینس ہے جو مندرجہ ذیل طور پر بیان کی گئی ہے: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). براہ کرم fib4 نمبر سیکینس کے n-ویں عنصر کو موثر انداز میں حساب کرنے کے لئے ایک فنکشن لکھیں۔ تکرار کا استعمال نہ کریں۔ >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"فہرست میں عناصر کا واپسی میڈین۔ >>> میڈین (([3, 1, 2, 4, 5]) 3 >>> میڈین (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"چیک کرتا ہے کہ آیا دی گئی تار ایک پالینڈوم ہے >>> is_palindrome (('') سچ >>> is_palindrome (('aba') سچ >>> is_palindrome (('aaaaa') سچ >>> is_palindrome (('zbcd') غلط \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2 ^ n ماڈیولو پی واپس کریں (عددیات سے آگاہ رہیں) ۔ >>> ماڈیول پی 3 ، 5) 3 >>> ماڈیول پی 110 ، 101) 2 >>> ماڈیول پی 0 ، 101) 1 >>> ماڈیول پی 3 ، 11) 8 >>> ماڈیول پی 100 ، 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"ان پٹ سٹرنگ کے طور پر لیتا ہے جس میں انکوڈ_شافٹ فنکشن کے ساتھ انکوڈ کیا گیا ہے۔ ڈیکوڈ سٹرنگ لوٹاتا ہے۔\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"حروف تہجی میں ہر کردار کو 5 کی طرف سے منتقل کر کے انکوڈنگ تار واپس کرتا ہے.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels ایک ایسا فنکشن ہے جو تار لیتا ہے اور بغیر حرف کے تار لوٹاتا ہے۔ >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"واپس سچ ہے اگر فہرست میں تمام نمبرز threshold سے نیچے ہیں. >>> below_threshold([1, 2, 4, 10], 100) سچ >>> below_threshold([1, 20, 4, 10], 5) غلط \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"دو نمبر x اور y جمع کریں >>> جمع کریں ((2، 3) 5 >>> جمع کریں ((5، 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"چیک کریں کہ آیا دو الفاظ میں ایک جیسے حروف ہیں۔ >>> same_chars('eabcdzzzz', 'dddzzzzzzdeddabc') درست >>> same_chars('abcd', 'dddddddabc') درست >>> same_chars('dddddddabc', 'abcd') درست >>> same_chars('eabcd', 'dddddddddabc') غلط >>> same_chars('abcd', 'dddddddabddce') غلط >>> same_chars'(abcdzzzz', 'dddzzzzzzdddabc') غلط \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"n-th فبونیکی نمبر لوٹاتا ہے۔ >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets \"<\" اور \">\" کی ایک تار ہے۔ اگر ہر افتتاحی بریکٹ میں ایک مماثل اختتامی بریکٹ ہوتا ہے تو یہ درست ہے۔ >>> correct_bracketing(\"<\") غلط >>> correct_bracketing(\"<>\") سچ >>> correct_bracketing(\"<><>>\") سچ >>> correct_bracketing(\"><<>\") غلط \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"واپسی درست ہے فہرست عناصر یکساں طور پر بڑھ رہے ہیں یا کم ہو رہے ہیں۔ >>> یکساں (([1، 2، 4، 20]) درست >>> یکساں (([1، 20، 4، 10]) غلط >>> یکساں (([4، 1، 0، -10)) درست \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"دو فہرستوں کے لئے ترتیب شدہ منفرد مشترکہ عناصر کو واپس کریں۔ >>> عام (([1، 4، 3، 34، 653، 2، 5]، [5، 7، 1، 5، 9، 653، 121]) [1، 5، 653] >>> عام (([5، 3، 2، 8]، [3، 2]) [2، 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"n کا سب سے بڑا پرائم فیکٹر واپس کریں۔ فرض کریں کہ n > 1 اور پرائم نہیں ہے۔ >>> سب سے بڑا_پرائم_فیکٹر ((13195) 29 >>> سب سے بڑا_پرائم_فیکٹر ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n ایک ایسا فنکشن ہے جو 1 سے n تک کے اعداد کا مجموعہ کرتا ہے۔ >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets \"(\" اور \"\") کی ایک تار ہے۔ اگر ہر اوپننگ بریکٹ میں ایک مماثل بند ہونے والا بریکٹ ہوتا ہے تو یہ درست ہے۔ >>> correct_bracketing (((\"(\") غلط >>> correct_bracketing (((\")) درست >>> correct_bracketing (((()) درست >>> correct_bracketing (((()) غلط \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs ایک کثیرالاضلاع کے ضارب کی نمائندگی کرتے ہیں۔ xs[0] + xs[1] * x + xs[2] * x ^ 2 + .... اسی شکل میں اس کثیرالاضلاع کا مشتق لوٹائیں۔ >>> مشتق ((([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> مشتق [(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"فیب فیب نمبر سیکینس فبوناکی سیکینیس کی طرح ایک سیکینس ہے جو مندرجہ ذیل طور پر بیان کی گئی ہے: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) براہ کرم ایک فنکشن لکھیں تاکہ fibfib نمبر سیکینس کے n-th عنصر کو مؤثر طریقے سے شمار کیا جاسکے۔ >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"ایک فنکشن لکھیں vowels_count جو ایک لفظ کی نمائندگی کرنے والی تار کو ان پٹ کے طور پر لیتا ہے اور اس تار میں موجود حرفوں کی تعداد واپس کرتا ہے۔ اس معاملے میں حرف 'a' ، 'e' ، 'i' ، 'o' ، 'u' ہیں۔ یہاں ، 'y' بھی ایک حرف ہے ، لیکن صرف اس وقت جب یہ دیئے گئے لفظ کے آخر میں ہو۔ مثال: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"مزید ٹیسٹ کیسز شامل کریں۔\"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"سرکلر انٹیجر ایکس کے ہندسوں کو منتقل کریں ، ہندسوں کو شفٹ کے ذریعہ دائیں طرف منتقل کریں اور نتیجہ کو ایک تار کے طور پر واپس کریں۔ اگر شفٹ > ہندسوں کی تعداد ، ہندسوں کو الٹ کر لوٹائیں۔ >>> سرکلر_ شفٹ 12 ، 1) \"21\" >>> سرکلر_ شفٹ 12 ، 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"ٹاسک ایک فنکشن لکھیں جو ان پٹ کے طور پر ایک تار لیتا ہے اور صرف اوپری حروف کا مجموعہ لوٹاتا ہے' ASCII کوڈز۔ مثال: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"اس ٹاسک میں آپ کو ایک سٹرنگ دی جائے گی جو ان سیبوں اور سنتریوں کی تعداد کی نمائندگی کرتی ہے جو پھلوں کی ٹوکری میں تقسیم کی جاتی ہیں اس ٹوکری میں سیب ، سنتری اور آم کے پھل ہوتے ہیں۔ اس سٹرنگ کو دیئے گئے جو سنتریوں اور سیب کی کل تعداد کی نمائندگی کرتا ہے اور ایک انٹیجر جو ٹوکری میں پھلوں کی کل تعداد کی نمائندگی کرتا ہے ٹوکری میں آم کے پھلوں کی تعداد واپس کرتا ہے۔ مثال کے طور پر: fruit_distribution\"5(سیب اور 6 سنتری\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 سیب اور 1 سنتری\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 سیب اور 3 سنتری\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 سیب اور 1 سنتری\",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"ایک صف کو دی گئی ہے جو ایک درخت کی شاخ کی نمائندگی کرتی ہے جس میں غیر منفی انٹیجر نوڈس ہیں آپ کا کام نوڈس میں سے ایک کو چننا اور اسے واپس کرنا ہے۔ چن لیا نوڈ سب سے چھوٹی جڑ قدر والا نوڈ ہونا چاہئے۔ اگر ایک ہی چھوٹی جڑ قدر والے متعدد نوڈس مل جاتے ہیں تو نوڈ کو واپس کریں جس میں سب سے چھوٹی انڈیکس ہے۔ چن لیا نوڈ کو ایک فہرست میں واپس کرنا چاہئے ، [smallest_value ، اس کا انڈیکس ]، اگر یہاں کوئی جڑ قدر نہیں ہے یا دی گئی صف خالی ہے تو ، واپس کریں []۔ مثال: 1: ان پٹ: [4,2,3] آؤٹ پٹ: [2, 1] وضاحت: 2 کی سب سے چھوٹی جڑ قدر ہے ، اور 2 کی سب سے چھوٹی انڈیکس ہے۔ مثال 2: ان پٹ: [1,2,3] آؤٹ پٹ: [2, 1] وضاحت: 2 کی سب سے چھوٹی قدر ہے ، اور 2 کی سب سے چھوٹی انڈیکس ہے۔ مثال 3: ان پٹ: [] آؤٹ پٹ: [] مثال: [4: 5، [3, 4] ان پٹ: 0، [0،] آؤٹ پٹ: 1 انڈ: 1 سب سے چھوٹی نوڈ ، جس میں سب سے چھوٹی انڈیکس ہے ، لیکن اس کی لمبائی صفر ہے مثال: 1 * 1، لیکن اس میں دو صفر ہیں ، لہذا ہم سب سے چھوٹا نوڈ منتخب کریں گے۔ مثال: 1 * لمبائی = صفر ، لیکن انڈیکس <= 10000 * صفر ہے\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''آپ کو مثبت انٹیجرز کی ایک غیر خالی فہرست دی گئی ہے۔ سب سے بڑا انٹیجر واپس کریں جو صفر سے زیادہ ہے ، اور اس کی تعدد انٹیجر کی قدر سے زیادہ یا اس کے برابر ہے۔ ایک انٹیجر کی تعدد اس فہرست میں ظاہر ہونے کی تعداد ہے۔ اگر ایسی کوئی قیمت موجود نہیں ہے تو ، -1 واپس کریں۔ مثال: تلاش کریں (([4, 1, 2, 2, 3, 1]) == 2 تلاش کریں [1, 2, 2, 3, 3, 3, 4, 4]) == 3 تلاش کریں [(5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''عددی اعداد کی فہرست دی گئی ہے ، عجیب ترتیب میں فہرست واپس کریں۔ عجیب ترتیب ، یہ ہے جب آپ کم سے کم قیمت سے شروع کرتے ہیں ، پھر باقی عددی اعداد کی زیادہ سے زیادہ ، پھر کم سے کم اور اسی طرح کی مثالیں: strange_sort_list (([1 ، 2 ، 3 ، 4]) == [1 ، 4 ، 2 ، 3] strange_sort_list (([5 ، 5 ، 5 ، 5]) == [5 ، 5 ، 5 ، 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''مثلث کے تین اطراف کی لمبائی دی گئی ہے۔ اگر تین اطراف ایک درست مثلث بناتے ہیں تو مثلث کا رقبہ 2 اعشاریہ پوائنٹس پر گول ہوجاتا ہے۔ بصورت دیگر -1 واپس کریں تین اطراف ایک درست مثلث بناتے ہیں جب کسی بھی دو اطراف کا مجموعہ تیسری طرف سے زیادہ ہو۔ مثال: مثلث_عرض (، ، ، ، ،) == 6.00 مثلث_عرض (، ، ، ، ، ، ، ،) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''ایک فنکشن لکھیں جو سچ واپس کرے گا اگر آبجیکٹ q اڑ جائے گا ، اور غلط دوسری صورت میں۔ آبجیکٹ q اڑ جائے گا اگر یہ متوازن ہے (یہ ایک پالینڈومک لسٹ ہے) اور اس کے عناصر کا مجموعہ زیادہ سے زیادہ ممکنہ وزن سے کم یا برابر ہے۔ مثال: will_it_fly (([1 ، 2 ، 5) â -> غلط # 1+2 زیادہ سے زیادہ ممکنہ وزن سے کم ہے ، لیکن یہ غیر متوازن ہے۔ will_it_fly (([3 ، 2 ، 3 ] ، 1) â -> غلط # یہ متوازن ہے ، لیکن 3+2+3 زیادہ سے زیادہ ممکنہ وزن ہے۔ will_it_fly ((([3 ، 2 ، 3 ] ، 9) â -> سچ # 3+23 زیادہ سے زیادہ ممکنہ وزن سے کم ہے ، اور یہ متوازن ہے۔ will_it_fly ((([3] ، â 5) -> سچ # 3 زیادہ سے زیادہ ممکنہ وزن سے کم ہے ، اور یہ متوازن ہے۔'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف صف\"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''ایک فنکشن لکھیں جو تاروں کی دو فہرستیں قبول کرے اور اس فہرست کو واپس کرے جس میں فہرست کی تمام تاروں میں دوسرے سے کم حروف کی کل تعداد ہو۔ اگر دونوں فہرستوں میں حروف کی ایک ہی تعداد ہے تو ، پہلی فہرست واپس کریں۔ مثال کے طور پر total_match (([] ، []) â -> [] total_match ((['hi' ، 'admin' ، ['hI' ، 'Hi']) â -> ['hI' ، 'Hi'] total_match ((['hi' ، 'admin' ] ، ['hi' ، 'admin' ، 'project']) â -> ['hi' ، 'admin'] total_match ((['hi' ، 'admin' ] ، ['hi' ، 'hi' ، 'hi']) â -> ['hi' ، 'admin'] total_match ((['hi' ، 'admin' ] ، ['I' ، 'hi' ، 'hi']) â -> ['hi'I' ، 'hi' ، 'hi'] total_match ((['4' ] ، ['1' 2' ، '3' ، '4' ، '5' -> [' 4])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"ایک فنکشن لکھیں جو صحیح ہے اگر دی گئی تعداد 3 پرائم نمبرز کا ضرب ہے اور دوسری صورت میں غلط ہے۔ یہ جان کر کہ (a) 100 سے کم ہے۔ مثال: is_multiply_prime(30) == سچ 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"آپ کا کام ایک فنکشن لکھنا ہے جو صحیح ہے اگر ایک نمبر x n کی ایک سادہ طاقت ہے اور دوسرے معاملات میں غلط ہے۔ x n کی ایک سادہ طاقت ہے اگر n**int=x مثال کے طور پر: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''ایک فنکشن لکھیں جو ایک انٹیجر a لیتا ہے اور ٹرو لوٹاتا ہے اگر یہ انجیگر کسی انٹیجر نمبر کا مکعب ہے۔ نوٹ: آپ یہ فرض کرسکتے ہیں کہ ان پٹ ہمیشہ درست ہے۔ مثال: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"آپ کو ایک فنکشن لکھنے کا کام سونپا گیا ہے جو ایک ہیکساڈسیمل نمبر کو تار کے طور پر وصول کرتا ہے اور ہیکساڈسیمل ہندسوں کی تعداد گنتا ہے جو پرائم ہیں (پرائم نمبر ، یا پرائم ، 1 سے زیادہ قدرتی تعداد ہے جو دو چھوٹے قدرتی نمبروں کا مصنوعہ نہیں ہے) ۔ ہیکساڈسیمل ہندسوں کی تعداد 0 ، 1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، A ، B ، C ، D ، E ، F ہے۔ پرائم نمبر 2 ، 3 ، 5 ، 7 ، 11 ، 13 ، 17 ، ... ہیں۔ لہذا آپ کو درج ذیل ہندسوں کی ایک تعداد کا تعین کرنا ہوگا: 2 ، 3 ، 5 ، 7 ، 7 ، B (= اعشاریہ 11) ، D (= اعشاریہ 13) ۔ نوٹ: آپ یہ فرض کرسکتے ہیں کہ ان پٹ ہمیشہ صحیح یا خالی تار ہے ، اور علامتیں A ، B ، C ، D ، E ، F ہمیشہ بڑے حروف میں ہیں۔ مثال: نمبر کے لئے \"AB\" آؤٹ پٹ نمبر ہونا چاہئے 1. نمبر کے لئے \"1077E\" آؤٹ پٹ ہونا چاہئے 2. نمبر کے لئے \"AB\" = 1 اے بی سی \"کے لئے نمبر ہونا چاہئے 4.33\" نمبر کے لئے \"ABC\" ہونا چاہئے 6.012894567D \"کے لئے آؤٹ پٹ پٹ نمبر ہونا چاہئے 2020 ′′\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"آپ کو اعشاریہ شکل میں ایک نمبر دیا جائے گا اور آپ کا کام اسے بائنری فارمیٹ میں تبدیل کرنا ہے۔ فنکشن کو ایک تار واپس کرنا چاہئے ، جس میں ہر کردار بائنری نمبر کی نمائندگی کرتا ہے۔ تار میں ہر کردار '0' یا '1' ہوگا۔ تار کے آغاز اور اختتام پر ایک اضافی جوڑے 'db' ہوں گے۔ اضافی حروف فارمیٹ میں مدد کے لئے موجود ہیں۔ مثال: اعشاریہ_تک_بائنری(15) # لوٹاتا ہے \"db1111db\" اعشاریہ_تک_بائنری32) # لوٹاتا ہے \"db100000db\"\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"آپ کو ایک تار s دیا گیا ہے۔ آپ کا کام یہ چیک کرنا ہے کہ تار خوش ہے یا نہیں۔ ایک تار خوش ہے اگر اس کی لمبائی کم از کم 3 ہے اور ہر 3 مسلسل حروف الگ الگ ہیں۔ مثال کے طور پر: is_happy (a) => غلط is_happy (a) => غلط is_happy (a) => غلط is_happy (b) => سچ is_happy (a) => غلط is_happy (a) => غلط is_happy (b) => غلط is_happy (ad) => سچ is_happy (ad) => سچ is_happy (x) => غلط \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"یہ سیمسٹر کا آخری ہفتہ ہے اور اساتذہ کو طلباء کو گریڈ دینا ہے۔ اساتذہ گریڈنگ کے لئے اپنا الگورتھم بنا رہی ہے۔ صرف ایک مسئلہ یہ ہے کہ ، وہ کوڈ کھو چکی ہے جس کا استعمال اس نے گریڈنگ کے لئے کیا تھا۔ اس نے آپ کو کچھ طلباء کے لئے جی پی اے کی فہرست دی ہے اور آپ کو ایک فنکشن لکھنا ہے جو درج ذیل ٹیبل کا استعمال کرتے ہوئے خط کی گریڈ کی فہرست تیار کرسکتی ہے۔ جی پی اے۔ خط کی گریڈ 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E مثال: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"ایک فنکشن لکھیں جو تار لیتا ہے اور واپس لوٹتا ہے اگر تار کی لمبائی ایک بنیادی نمبر ہے یا غلط ہے دوسری صورت میں مثال prime_length('ہیلو') == True prime_length('abcdcba') == True prime_length('kitten') == True prime_length('orange') == غلط \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"ایک مثبت عدد n دیا گیا ہے، 1 سے شروع ہونے یا ختم ہونے والے n ہندسوں والے مثبت عدد کی تعداد واپس کریں۔\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"ایک مثبت عدد N دی گئی ہے ، اس کے ہندسوں کا مجموعی مجموعہ بائنری میں لوٹاتا ہے۔ مثال کے طور پر N = 1000 کے لئے ، ہندسوں کا مجموعہ 1 ہوگا آؤٹ پٹ \"1\" ہونا چاہئے۔ N = 150 کے لئے ، ہندسوں کا مجموعہ 6 ہوگا آؤٹ پٹ \"110\" ہونا چاہئے۔ N = 147 کے لئے ، ہندسوں کا مجموعہ 12 ہوگا آؤٹ پٹ \"1100\" ہونا چاہئے۔ متغیرات: @N انٹیجر پابندیاں: 0 â‰¤ N â‰¤ 10000. آؤٹ پٹ: بائنری نمبر کی ایک تار \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"انٹیجرز کی ایک خالی فہرست دی گئی ہے۔ پہلے انٹیجرز کی جوڑی فہرست جو عجیب اشاریہ پر ہیں۔ مثال: شامل کریں (([4، 2، 6، 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"ایک ایسا فنکشن لکھیں جو ایک تار لے اور اس کا ایک ترتیب شدہ ورژن لوٹائے۔ تار کا ترتیب شدہ ورژن ، ایک تار ہے جہاں تمام الفاظ (اسپیس کے ذریعہ الگ) ایک نئے لفظ کے ذریعہ تبدیل کردیئے جاتے ہیں جہاں تمام حروف کو ASCII قدر کی بنیاد پر بڑھتے ہوئے ترتیب میں ترتیب دیا جاتا ہے۔ نوٹ: آپ کو جملے میں الفاظ اور خالی جگہوں کا حکم رکھنا چاہئے۔ مثال کے طور پر: anti_shuffle ((('Hi') لوٹاتا ہے 'Hi' anti_shuffle ((('hello') لوٹاتا ہے 'ehllo' anti_shuffle (('Hello World!!!') لوٹاتا ہے 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"آپ کو ایک دو جہتی ڈیٹا دیا گیا ہے ، جو ایک گھوںسلا فہرست کے طور پر ، جو میٹرکس کی طرح ہے ، تاہم ، میٹرکس کے برعکس ، ہر صف میں کالموں کی ایک مختلف تعداد ہوسکتی ہے۔ lst ، اور انٹیجر x دیئے گئے ، فہرست میں انٹیجرز x تلاش کریں ، اور ٹپلوں کی فہرست واپس کریں ، [(x1 ، y1 ، (x2 ، y2) ...) ، تاکہ ہر ٹپل ایک کوآرڈینیٹ - (صف ، کالم) ہو ، 0 سے شروع ہو۔ ابتدائی طور پر صفوں کے ذریعہ کوآرڈینیٹ ترتیب دیں۔ نیز ، صف کے کوآرڈینیٹ کو کالموں کے ذریعہ ترتیب دیں۔ مثال: get_row [1,2,3,4,5,6 ] ، [1,2,3,4,1,6 ] ، [1,2,3,4,5,1] ، 1) == [0,0, 0, 0, 1, 4 ] ، 0 ، 0 ، 2 ، 5 ، (2 ، 0) get_(] ، 1) [] == قطار [1, 2 ، 3 ، 2) [، 2]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"غیر منفی انٹیجرز کی ایک صف دی گئی ہے ، ترتیب دینے کے بعد دی گئی صف کی ایک کاپی واپس کریں ، اگر رقم ((پہلی انڈیکس ویلیو ، آخری انڈیکس ویلیو) عجیب ہے تو آپ دیئے گئے صف کو چڑھتے ہوئے ترتیب دیں گے ، یا اگر رقم ((پہلی انڈیکس ویلیو ، آخری انڈیکس ویلیو) برابر ہے تو اسے نزولی ترتیب میں ترتیب دیں گے۔ نوٹ: * دی گئی صف کو تبدیل نہ کریں۔ مثال: * sort_array[(]) => [] * sort_array([5]) => [5] * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"ایک فنکشن تخلیق کریں جس میں ایک تار کو دلیل کے طور پر لے جاتا ہے اور حروف تہجی کے ساتھ خفیہ کردہ تار واپس کرتا ہے۔ حروف تہجی کو اس طرح گھمایا جانا چاہئے کہ حروف دو سے ضرب دو مقامات پر نیچے جائیں۔ مثال کے طور پر: encrypt('hi') لوٹاتا ہے 'lm' encrypt('asdfghjkl') لوٹاتا ہے 'ewhjklnop' encrypt('gf') لوٹاتا ہے 'kj' encrypt('et') لوٹاتا ہے 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"آپ کو انٹیجرز کی ایک فہرست دی گئی ہے۔ ایک فنکشن لکھیں اگلے_سب سے چھوٹا ((() جو فہرست کا دوسرا سب سے چھوٹا عنصر لوٹاتا ہے۔ اگر ایسا عنصر نہیں ہے تو کوئی نہیں لوٹاتا ہے۔ اگلے_سب سے چھوٹا (([1، 2، 3، 4، 5]) == 2 اگلے_سب سے چھوٹا (([5، 1، 4، 3، 2]) == 2 اگلے_سب سے چھوٹا (([]) == کوئی نہیں اگلے_سب سے چھوٹا (([1، 1]) == کوئی نہیں \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"آپ کو الفاظ کی ایک تار دی جائے گی ، اور آپ کا کام بورڈ کی تعداد گننا ہے۔ بورڈ ایک جملہ ہے جو لفظ \"I\" سے شروع ہوتا ہے۔ جملوں کو ' '، '؟ یا '! ' کے ساتھ منسلک کیا جاتا ہے۔ مثال کے طور پر: >>> بورڈ ہے (((\"ہیلو ورلڈ\") 0 >>> بورڈ ہے ((\"آسمان نیلا ہے۔ سورج چمک رہا ہے۔ مجھے اس موسم سے پیار ہے\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''ایک فنکشن بنائیں جو 3 نمبر لے۔ صحیح لوٹاتا ہے اگر ایک نمبر دوسرے دو کے مجموعہ کے برابر ہے ، اور تمام نمبر انٹیجر ہیں۔ کسی بھی دوسرے معاملات میں غلط لوٹاتا ہے۔ مثال any_int ((5, 2, 7) â -> True any_int ((3, 2, 2) â -> False any_int ((3, -2, 1) â -> True any_int ((3.6, -2.2, 2) â -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"ایک فنکشن لکھیں جو پیغام لیتا ہے ، اور اس طرح کوڈ کرتا ہے کہ یہ تمام حروف کے کیس کو تبدیل کرتا ہے ، پیغام میں تمام حرفی کو اس حرف کے ساتھ تبدیل کرتا ہے جو انگریزی حروف تہجی میں اس حرف کے 2 مقامات پر ظاہر ہوتا ہے۔ صرف حروف فرض کریں۔ مثال: >>> انکوڈ ((('ٹیسٹ') 'TGST' >>> انکوڈ ((('یہ ایک پیغام ہے') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"آپ کو انٹیجرز کی ایک فہرست دی گئی ہے۔ آپ کو سب سے بڑی پرائم ویلیو تلاش کرنے اور اس کے ہندسوں کا مجموعہ واپس کرنے کی ضرورت ہے۔ مثال: lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,4,3] کے لئے آؤٹ پٹ 10 ہونا چاہئے lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] کے لئے آؤٹ پٹ 25 ہونا چاہئے lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] کے لئے آؤٹ پٹ 13 ہونا چاہئے lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] کے لئے آؤٹ پٹ 11 ہونا چاہئے lst = [0,81,12,3,21,1] کے لئے آؤٹ پٹ 3 ہونا چاہئے lst = [0,8,1,2,1,7] کے لئے آؤٹ پٹ 7 ہونا چاہئے\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"ایک لغت دی گئی ہے ، اگر تمام چابیاں چھوٹے حروف میں تار ہیں یا تمام چابیاں بڑے حروف میں تار ہیں تو ، پھر غلط واپس کریں۔ فنکشن کو غلط واپس کرنا چاہئے دی گئی لغت خالی ہے۔ مثال: چیک_ڈکٹ_کیس ((({\"a\":\" سیب ،\" \"b\":\" کیلے \"}) کو درست واپس کرنا چاہئے۔ چیک_ڈکٹ_کیس ((({\"a\":\" سیب ،\" A\":\" کیلے ،\" B\":\" کیلے \"}) کو غلط واپس کرنا چاہئے۔ چیک_ڈکٹ_کیس {\"a\":\" سیب ،\" 8:\" کیلے ،\" a\":\" سیب \"}) کو غلط واپس کرنا چاہئے۔ چیک_ڈکٹ_کیس {\"a\":\" سیب ،\" 8:\" کیلے ،\" a\":\" سیب \"}) کو غلط واپس کرنا چاہئے۔ چیک_ڈکٹ_کیس {\" نام \":\" جان \"،\" عمر \":\" 36،\" شہر \"، \"ہوسٹن\"}) کو غلط واپس کرنا چاہئے۔ چیک_ڈکٹ_کیس {\" NC:\" STATE \"،\" Z \":\" ZIP: 45 \") کو درست واپس کرنا چاہئے۔\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"ایک فنکشن لاگو کریں جو ایک غیر منفی انٹیجر لیتا ہے اور پہلے n انٹیجرز کی ایک صف کو لوٹاتا ہے جو بنیادی نمبر ہیں اور n سے کم ہیں۔ مثال کے طور پر: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"دو عدد لے کر ان کے یونٹ ہندسوں کے پیداوار کو واپس کرنے والے فنکشن کو مکمل کریں۔ فرض کریں کہ ان پٹ ہمیشہ درست ہے۔ مثال: ضرب ((148، 412) کو 16 واپس کرنا چاہئے۔ ضرب ((19، 28) کو 72 واپس کرنا چاہئے۔ ضرب ((2020، 1851) کو 0 واپس کرنا چاہئے۔ ضرب ((14، 15) کو 20 واپس کرنا چاہئے۔\"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"ایک تار s دی گئی ، یہاں تک کہ انڈیکس میں بڑے حرفی حرفوں کی تعداد گنیں۔ مثال کے طور پر: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 لوٹاتا ہے \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''ایک فنکشن بنائیں جو ایک نمبر کی نمائندگی کرنے والی ایک قدر (سلسلہ) لیتا ہے اور اس کے قریب ترین عددی عددی کو لوٹاتا ہے۔ اگر نمبر دو انٹیجرز سے مساوی فاصلے پر ہے تو اسے صفر سے دور کرو. مثال >>> قریب ترین انٹیجر (((\"10\") 10 >>> قریب ترین انٹیجر (((\"15.3\") 15 نوٹ: صفر سے دور کروانے کا مطلب یہ ہے کہ اگر دیا گیا نمبر دو انٹیجرز سے مساوی فاصلے پر ہے تو ، آپ کو واپس آنا چاہئے وہ جو صفر سے دور ہے۔ مثال کے طور پر قریب ترین انٹیجر \" ((14.5\") کو 15 واپس کرنا چاہئے اور قریب ترین انٹیجر \" ((-14.5\") کو -15. واپس کرنا چاہئے۔ '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"ایک مثبت عدد n دیا گیا ہے ، آپ کو پتھروں کی n سطحوں کا ڈھیر بنانا ہوگا۔ پہلی سطح میں n پتھر ہیں۔ اگلی سطح میں پتھروں کی تعداد یہ ہے: - اگلی عجیب تعداد اگر n عجیب ہے۔ - اگلی جڑواں تعداد اگر n ہے یہاں تک کہ ایک فہرست میں ہر سطح میں پتھروں کی تعداد واپس کریں ، جہاں انڈیکس i میں عنصر سطح (i + 1) میں پتھروں کی تعداد کی نمائندگی کرتا ہے۔ مثال: >>> make_a_pile(3) [3، 5، 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"آپ کو کما یا خالی جگہوں سے الگ الفاظ کی ایک تار دی جائے گی۔ آپ کا کام اس تار کو الفاظ میں تقسیم کرنا اور الفاظ کی ایک صف واپس کرنا ہے۔ مثال کے طور پر: words_string ((\"ہیلو ، میرا نام جان ہے\") == [\"ہیلو ،\" \"میرا ،\" \"نام ،\" \"ہے ،\" جان\"] words_string ((\"ایک ، دو ، تین ، چار ، پانچ ، چھ\") == [\"ایک ،\" \"دو ،\" \"تین ،\" \"چار ،\" \"پانچ ،\" چھ\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"یہ فنکشن دو مثبت نمبر x اور y لیتا ہے اور سب سے بڑی عددی عددی تعداد کو واپس کرتا ہے جو رینج میں ہے [x، y] شامل ہے۔ اگر ایسی کوئی تعداد نہیں ہے تو ، فنکشن کو -1 واپس کرنا چاہئے۔ مثال کے طور پر: منتخب کریں_نمبر 12 ، 15 = 14 منتخب کریں_نمبر 13 ، 12 = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"آپ کو دو مثبت انٹیجرز n اور m دیئے گئے ہیں ، اور آپ کا کام یہ ہے کہ n سے m تک (n اور m سمیت) انٹیجرز کی اوسط کا حساب لگائیں۔ جواب کو قریب ترین انٹیجر تک گول کریں اور اسے بائنری میں تبدیل کریں۔ اگر n سے زیادہ ہے تو ، -1 واپس کریں۔ مثال: rounded_avg ((1، 5) => \"0b11\" rounded_avg ((7، 5) => -1 rounded_avg ((10، 20) => \"0b1111\" rounded_avg ((20، 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"مثبت انٹیجرز کی ایک فہرست دی گئی x. تمام عناصر کی ایک ترتیب شدہ فہرست واپس کریں جس میں کوئی بھی ہندسہ نہیں ہے۔ نوٹ: لوٹایا گیا فہرست بڑھتی ہوئی ترتیب میں ترتیب دی جانی چاہئے۔ مثال کے طور پر: >>> منفرد_ ہندسوں (([15، 33، 1422، 1]) [1، 15، 33] >>> منفرد_ ہندسوں (([152، 323، 1422، 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"عددی صف دی گئی ہے ، انٹیجرز کو ترتیب دیں جو 1 اور 9 کے درمیان ہیں ، نتیجے میں صف کو الٹ دیں ، اور پھر ہر ہندسے کو اس کے مطابق نام سے تبدیل کریں \"ایک\" ، \"دو\" ، \"تین\" ، \"چار\" ، \"پانچ\" ، \"چھ\" ، \"سات\" ، \"آٹھ\" ، \"نائن\"۔ مثال کے طور پر: arr = [2 ، 1 ، 1 ، 4 ، 5 ، 8 ، 2 ، 3] -> ترتیب arr -> [1 ، 1 ، 2 ، 2 ، 3 ، 4 ، 5 ، 8] -> الٹ arr -> [8 ، 5 ، 4 ، 3 ، 2 ، 2 ، 1 ، 1] واپسی [\"آٹھ\" ، \"چار\" ، \"تین\" ، \"دو\" ، \"دو\" ، \"ایک\" ، \"ایک\"] اگر صف خالی ہے تو ، ایک واپسی: arr = [] array return [] اگر صف میں کوئی عجیب نمبر ہے تو اسے نظرانداز کریں: arr = [1 ، -1 ، 55] -> arr -> [1-، 1، 55] -> الٹ arr = [51] return - '1،' ]\"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"فنکشن f کو لاگو کریں جو n کو پیرامیٹر کے طور پر لیتا ہے ، اور سائز n کی ایک فہرست لوٹاتا ہے ، اس طرح کہ انڈیکس i میں عنصر کی قدر i کا فیکٹریل ہے اگر i بھی ہے یا 1 سے i تک کی تعداد کا مجموعہ ہے۔ i 1 سے شروع ہوتا ہے۔ i کا فیکٹریل 1 سے i تک کی تعداد کا ضرب ہے۔ (1 * 2 * ... * i) مثال: f ((5) == [1 ، 2 ، 6 ، 24 ، 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"ایک مثبت انٹیجر n دیئے جانے پر ، ایک ٹپل واپس کریں جس میں انٹیجر palindromes کی تعداد بھی اور عجیب ہے جو حد کے اندر اندر آتی ہے ((1 ، n) ، بشمول۔ مثال1: ان پٹ: 3 آؤٹ پٹ: (1, 2) وضاحت: انٹیجر palindrome ہیں 1 ، 2 ، 3. ان میں سے ایک جوڑا ہے ، اور ان میں سے دو عجیب ہیں۔ مثال2: ان پٹ: 12 آؤٹ پٹ: (4, 6) وضاحت: انٹیجر palindrome ہیں 1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، 11۔ ان میں سے چار برابر ہیں ، اور ان میں سے 6 عجیب ہیں۔ نوٹ: 1 <= n <= 10 ^ 3 2. ٹپل نے بالترتیب برابر اور عجیب انٹیجر palindromes کی تعداد واپس کردی ہے۔ \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"ایک فنکشن لکھیں count_nums جو انٹیجرز کی ایک صف لیتا ہے اور عناصر کی تعداد کو لوٹاتا ہے جس میں ہندسوں کا مجموعہ ہے > 0. اگر کوئی نمبر منفی ہے تو ، اس کا پہلا دستخط شدہ ہندسہ منفی ہوگا: مثال کے طور پر -123 نے ہندسوں پر دستخط کیے ہیں - 1 ، 2 ، اور 3. >>> count_nums (([]) == 0 >>> count_nums (([-1 ، 11 ، -11]) == 1 >>> count_nums[(1 ، 1 ، 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"ہمارے پاس N انٹیجرز کی ایک صف 'آر' ہے arr [1] ، arr [2] ، ..., arr [N]۔ صف میں موجود نمبروں کو تصادفی طور پر ترتیب دیا جائے گا۔ آپ کا کام یہ طے کرنا ہے کہ آیا کسی صف کو غیر کم ہونے والے ترتیب میں ترتیب دینا ممکن ہے یا نہیں۔ آپ کو دیئے گئے صف پر درج ذیل آپریشن انجام دے کر: آپ کو دائیں شفٹ آپریشن کی اجازت ہے جو آپ کو کئی بار انجام دینے کی اجازت ہے۔ ایک دائیں شفٹ آپریشن کا مطلب ہے کہ صف کے تمام عناصر کو دائیں سمت میں ایک پوزیشن میں منتقل کرنا۔ صف کا آخری عنصر صف میں ابتدائی پوزیشن پر منتقل کیا جائے گا یعنی 0th انڈیکس۔ اگر اوپر والے آپریشن کو انجام دے کر ترتیب شدہ صف حاصل کرنا ممکن ہے تو پھر واپسی درست ہے ورنہ غلط واپسی۔ اگر دی گئی صف خالی ہے تو واپسی درست ہے۔ نوٹ: دی گئی فہرست میں منفرد عناصر کی ضمانت دی گئی ہے۔ مثال کے طور پر: move_one_{} ball[ 3، 4، 5، 2]==> درست وضاحت: دائیں 2 آپریشنوں کے ذریعہ ، صف کے لئے غیر کم ہونے والے ترتیب کو حاصل کرنا ممکن ہے۔ [ 1، 3، 4، 5، 2] ==> غلط وضاحت: کسی بھی نمبر کی طرف سے دائیں شفٹ کی صف کے لئے غیر ترتیب کو منتقل کرنا ممکن نہیں ہے۔\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"اس مسئلے میں ، آپ ایک فنکشن نافذ کریں گے جو نمبروں کی دو فہرستیں لیتا ہے ، اور یہ طے کرتا ہے کہ آیا ان کے مابین عناصر کا تبادلہ کرنا ممکن ہے تاکہ lst1 کو صرف اعداد کی فہرست بنایا جاسکے۔ lst1 اور lst2 کے مابین تبادلہ شدہ عناصر کی تعداد پر کوئی حد نہیں ہے۔ اگر lst1 اور lst2 کے مابین عناصر کا تبادلہ کرنا ممکن ہے تاکہ lst1 کے تمام عناصر کو بھی برابر بنایا جاسکے تو ، \"YES\" واپس کریں۔ بصورت دیگر ، \"NO\" واپس کریں۔ مثال کے طور پر: تبادلہ [(1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" تبادلہ [(1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" یہ فرض کیا جاتا ہے کہ ان پٹ فہرستیں خالی نہیں ہوں گی۔ \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"ایک تار دی گئی جس میں ایک جگہ الگ الگ چھوٹے حروف کی نمائندگی کی گئی ہے ، اس حرف کی لغت واپس کریں جس میں سب سے زیادہ تکرار ہو اور اس میں متعلقہ گنتی ہو۔ اگر کئی حروف ایک ہی واقعے کی ہے تو ، ان سب کو واپس کریں۔ مثال: ہسٹوگرام (('a b c') == {'a': 1 ، 'b': 1 ، 'c': 1} ہسٹوگرام (('a b b a') == {'a': 2 ، 'b': 2} ہسٹوگرام (('a b c a b') == {'a': 2 ، 'b': 2} ہسٹوگرام (('b b a') == {'b 4}: ہسٹوگرام '(') == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"ٹاسک ہمیں دو سٹرنگس s اور c دی گئی ہیں ، آپ کو s میں موجود تمام حروف کو حذف کرنا ہوگا جو c میں کسی بھی حرف کے برابر ہیں پھر چیک کریں کہ آیا نتیجہ کی تار پالنڈروم ہے۔ ایک تار کو پالنڈروم کہا جاتا ہے اگر یہ پیچھے کی طرف آگے کی طرح پڑھتا ہے۔ آپ کو چیک کے ل a نتیجہ کی تار اور ٹرو / فالس پر مشتمل ایک ٹپل واپس کرنا چاہئے۔ مثال کے طور پر s = \"abcde\" ، c = \"ae\" ، نتیجہ ہونا چاہئے ('bcd' ، غلط) s = \"abcdef\" ، c = \"b\" نتیجہ ہونا چاہئے ('acdef' ، غلط) s = \"abcdedcba\" ، c = \"ab\" ، نتیجہ ہونا چاہئے ('cdedc' ،True)\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"تاروں کی ایک فہرست دی گئی ہے ، جہاں ہر تار صرف ہندسوں پر مشتمل ہے ، ایک فہرست واپس کریں۔ آؤٹ پٹ کا ہر عنصر i \"ان پٹ کی تار i میں عجیب عناصر کی تعداد\" ہونا چاہئے۔ جہاں تمام i کو ان پٹ کی i'th تار میں عجیب ہندسوں کی تعداد سے تبدیل کیا جانا چاہئے۔ >>> odd_count['1234567']) [\"4n str4ng 4 کی عجیب عناصر کی تعداد 4nput.\"] >>> odd_count['3'،\"111111\"]) [\"1n str1ng 1 کی عجیب عناصر کی تعداد 1nput.\"، \"8n str8ng 8 کی 8nput. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"عددی اعداد کی ایک صف دی گئی ہے ، اعداد کی کسی بھی خالی ذیلی صف کا کم سے کم مجموعہ تلاش کریں۔ مثال minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"آپ کو کنوؤں کی مستطیل گرڈ دی گئی ہے۔ ہر قطار ایک کنویں کی نمائندگی کرتی ہے ، اور ہر قطار میں 1 پانی کی ایک واحد اکائی کی نمائندگی کرتا ہے۔ ہر کنویں میں ایک اسی طرح کی بالٹی ہوتی ہے جس سے پانی نکالنے کے لئے استعمال کیا جاسکتا ہے ، اور تمام بالٹیوں کی ایک ہی گنجائش ہوتی ہے۔ آپ کا کام کنوؤں کو خالی کرنے کے لئے استعمال کرنا ہے۔ کنوؤں کو کم کرنے کے لئے آپ کو کتنی بار ضرورت ہے اس کی پیداوار۔ مثال: 1: ان پٹ: گرڈ: [[0,0,1,0] ، [0,1,0,0] ، [1,1,1,1]] bucket_capacity: 1 آؤٹ پٹ: 6 مثال: ان پٹ: گرڈ: [[0,0,1,1] ، [0,0,0,0] ، [1,1,1] ، [0,1,1]] bucket_capacity: 2 آؤٹ پٹ: 5 مثال: ان پٹ: [[0,0,0]] ، [0,0,0]] bucket_capacity: 5 آؤٹ پٹ: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"اس کٹا میں ، آپ کو منفی عددی اعداد کی ایک صف کو ان کی بائنری نمائندگی میں بڑھتی ہوئی ترتیب میں ان کی تعداد کے مطابق ترتیب دینا ہوگا۔ اسی طرح کی تعداد کے ل dec ، اعشاریہ قدر پر مبنی ترتیب دیں۔ اس کو اس طرح نافذ کیا جانا چاہئے: >>> sort_array (([1 ، 5 ، 2 ، 3 ، 4]) == [1 ، 2 ، 3 ، 4 ، 5] >>> sort_array (([-2 ، 3 ، 4 ، 5 ، 6)) == [-6 ، 5 ، 4 ، 3 ، 2 ] >>> sort_array (([1 ، 0 ، 2 ، 3 ، 4]) [0 ، 1 ، 2 ، 3 ، 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"ایک تار s اور ایک قدرتی نمبر n کو دیکھتے ہوئے ، آپ کو ایک فنکشن نافذ کرنے کا کام سونپا گیا ہے جو تار s کے تمام الفاظ کی فہرست واپس کرتا ہے جس میں بالکل n ضمیر ہوتے ہیں ، تاکہ یہ الفاظ تار s میں ظاہر ہوں۔ اگر تار s خالی ہے تو فنکشن کو خالی فہرست واپس کرنی چاہئے۔ نوٹ: آپ یہ فرض کرسکتے ہیں کہ ان پٹ تار میں صرف حروف اور خالی جگہیں ہیں۔ مثال: select_words \"مریم کے پاس ایک چھوٹا سا برہ تھا\" ، 4) ==> [\" چھوٹا\"] select_words \"مریم کے پاس ایک چھوٹا سا برہ تھا\" ، 3) ==> [\" مریم\" ، \" برہ\"] select_words \"سادہ سفید جگہ\" ، 2) ==> [] select_words \"ہیلو ورلڈ\" ، 4) ==> [\" دنیا\"] select_words \" چچا سیم\" ، 3) ==> [\" چچا\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"آپ کو ایک لفظ دیا گیا ہے۔ آپ کا کام یہ ہے کہ قریب ترین حرف صوتی تلاش کریں جو لفظ کے دائیں طرف سے دو حرف صوتی کے درمیان کھڑا ہو۔ شروع اور اختتام میں حرف صوتی شمار نہیں ہوتے ہیں۔ اگر آپ کو کوئی حرف صوتی نہیں ملا تو خالی تار واپس کریں۔ آپ یہ فرض کرسکتے ہیں کہ دیئے گئے تار میں صرف انگریزی حرف موجود ہے۔ مثال: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''آپ کو دو تاروں کی فہرست دی گئی ہے ، دونوں تاروں میں صرف کھلی قوسین '(' یا قریبی قوسین ') ' ہیں۔ آپ کا کام یہ جانچنا ہے کہ آیا یہ ممکن ہے کہ دونوں تاروں کو کسی ترتیب میں جوڑنا ، کہ نتیجہ کی تار اچھی ہوگی۔ ایک تار S کو اچھا سمجھا جاتا ہے اگر اور صرف اس صورت میں جب S میں تمام قوسین متوازن ہوں۔ مثال کے طور پر: تار '((()) 'اچھا ہے ، جبکہ تار '())' نہیں ہے۔ اگر اچھی تار بنانے کا کوئی طریقہ ہے تو 'ہاں' واپس کریں ، اور بصورت دیگر 'نہیں' واپس کریں۔ مثال: میچ_پارینس [('() ، ') ']) == 'ہاں' میچ_پارینس [(') ، ') ']) == 'نہیں' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"عددی صف اور مثبت عددی صف کو دیکھتے ہوئے ، آر آر میں زیادہ سے زیادہ کے اعداد کے ساتھ لمبائی کی ترتیب شدہ فہرست واپس کریں۔ مثال1: ان پٹ: آر آر = [-3 ، -4 ، 5] ، کے = 3 آؤٹ پٹ: [-4 ، -3 ، 5] مثال2: ان پٹ: آر آر = [4 ، -4 ، 4] ، کے = 2 آؤٹ پٹ: [4 ، 4] مثال3: ان پٹ: آر آر = [-3 ، 2 ، 1 ، 2 ، -1 ، -2 ، 1] ، کے = 1 آؤٹ پٹ: [2] نوٹ: 1. صف کی لمبائی [1 ، 1000] کی حد میں ہوگی۔ 2. صف میں عناصر [-1000 ، 1000] کی حد میں ہوں گے۔ 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"انٹیجرز کی ایک غیر خالی فہرست دی گئی ہے ، تمام عجیب عناصر کا مجموعہ واپس کریں جو یہاں تک کہ پوزیشنوں میں ہیں۔ مثال کے حل (([5 ، 8 ، 7 ، 1]) ==> 12 حل (([3 ، 3 ، 3 ، 3 ، 3]) ==> 9 حل (([30, 13, 24, 321]) ==> 0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"عددی صفوں کی ایک خالی صف اور ایک عددی صف k دی گئی ہے ، arr کے پہلے k عناصر سے زیادہ سے زیادہ دو ہندسوں کے ساتھ عناصر کا مجموعہ لوٹاتا ہے۔ مثال: ان پٹ: arr = [111,21,3,4000,5,6,7,8,9] ، k = 4 آؤٹ پٹ: 24 # 21 + 3 کی رقم پابندیاں: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"ایک مثبت عدد n دیا گیا ہے ، ایک ترتیب شدہ فہرست واپس کریں جس میں کولاٹز ترتیب میں عجیب نمبر ہیں۔ کولاٹز قیاس ریاضی میں ایک قیاس ہے جو اس ترتیب سے متعلق ہے جس کی تعریف مندرجہ ذیل ہے: کسی بھی مثبت عدد n سے شروع کریں۔ پھر ہر اصطلاح پچھلی اصطلاح سے اس طرح حاصل کی جاتی ہے: اگر پچھلی اصطلاح یکساں ہے تو ، اگلی اصطلاح پچھلی اصطلاح کا آدھا ہے۔ اگر پچھلی اصطلاح عجیب ہے تو ، اگلی اصطلاح پچھلی اصطلاح کے 3 گنا زیادہ ہے۔ قیاس یہ ہے کہ n کی کوئی بھی قدر نہیں ، ترتیب ہمیشہ 1 تک پہنچ جائے گی۔ نوٹ: 1. کولاٹز ((1) [1] ہے۔ 2. لوٹایا گیا فہرست بڑھتی ہوئی ترتیب میں ترتیب دی گئی ہے۔ مثال کے طور پر: get_odd_collatz ((5) لوٹاتا ہے [1, 5] 5 کے لئے کولاٹز ترتیب [5, 8, 16, 4, 2, 1] ہے ، لہذا عجیب نمبر صرف 1 اور 5 ہیں۔\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"آپ کو ایک ایسا فنکشن لکھنا ہے جو کسی دی گئی تاریخ کی تار کی توثیق کرے اور اگر تاریخ درست ہے تو درست لوٹائے۔ دوسری صورت میں غلط۔ تاریخ درست ہے اگر مندرجہ ذیل تمام قواعد پوری ہوں: 1. تاریخ کی تار خالی نہیں ہے۔ 2. مہینوں کے لئے دن کی تعداد 1 سے کم یا 31 دن سے زیادہ نہیں ہے۔ اور مہینوں کے لئے دن کی تعداد 1 سے کم یا 30 دن سے زیادہ نہیں ہے۔ 4.6.9.11۔ اور ، مہینوں کی تعداد 1 سے کم یا 29 سے زیادہ نہیں ہے۔ 2. 3. مہینوں سے کم یا 12 سے زیادہ نہیں ہونا چاہئے۔ 4. تاریخ کی شکل میں ہونا چاہئے: mm-dd-yyyy مثال کے طور پر: valid_date (('03-11-2000') => درست_date (('15-01-2012') => غلط_date (('04-01-2040') => غلط_date (('06-04-2020') => درست_date (('06/04/2020') => غلط\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''الفاظ کی ایک تار دی گئی ہے، خالی جگہ پر تقسیم الفاظ کی ایک فہرست واپس، کوئی خالی جگہ موجود نہیں ہے تو آپ کو قطرے پر تقسیم کرنا چاہئے متن '، کوئی قطرے موجود نہیں ہے تو آپ کو حروف تہجی میں عجیب ترتیب کے ساتھ چھوٹے حروف کی تعداد واپس کرنا چاہئے، ord (('a') = 0، ord (('b') = 1، ... ord (('z') = 25 مثالیں تقسیم_words ((\"ہیلو دنیا!\") â -> [\"ہیلو\"، \"دنیا!\"] split_words ((\"ہیلو، دنیا!\") â -> [\"ہیلو\"، \"دنیا!\" تقسیم_words ((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''اعداد کی ایک فہرست دی گئی ہے ، واپس کریں کہ آیا وہ بڑھتے ہوئے ترتیب میں ترتیب دیئے گئے ہیں یا نہیں۔ اگر فہرست میں ایک ہی نمبر کی 1 سے زیادہ نقلیں ہیں تو ، غلط واپس کریں۔ کوئی منفی نمبر اور صرف انٹیجرز فرض کریں۔ مثالیں is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 2, 3, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"آپ کو دو وقفے دیئے گئے ہیں ، جہاں ہر وقفہ عدد کا جوڑا ہے۔ مثال کے طور پر ، وقفہ = (شروع ، اختتام) = (1, 2) ۔ دیئے گئے وقفے بند ہیں جس کا مطلب ہے کہ وقفہ (شروع ، اختتام) میں آغاز اور اختتام دونوں شامل ہیں۔ ہر دیئے گئے وقفے کے ل it ، یہ فرض کیا جاتا ہے کہ اس کا آغاز اس کے اختتام سے کم یا برابر ہے۔ آپ کا کام یہ طے کرنا ہے کہ آیا ان دو وقفوں کے تقاطع کی لمبائی ایک بنیادی نمبر ہے۔ مثال کے طور پر ، وقفوں کا تقاطع (1, 3) ، (2 ، 4) (2 ، 3) ہے جس کی لمبائی 1 ہے ، جو ایک بنیادی نمبر نہیں ہے۔ اگر تقاطع کی لمبائی ایک بنیادی نمبر ہے تو ، \"YES\" واپس کریں ، بصورت دیگر ، \"NO\" واپس کریں۔ اگر دونوں وقفے کا تقاطع نہیں ہوتا ہے تو ، \"NO\" واپس کریں۔ [input/output] نمونے: تقاطع\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"آپ کو انٹیجرز کی ایک صف دی گئی ہے اور آپ کو صف میں ہر نمبر کے تمام نشانوں کے پروڈکٹ سے ضرب شدہ انٹیجرز کی مقدار کا مجموعہ واپس کرنے کی ضرورت ہے ، جس کی نمائندگی 1 ، -1 یا 0 سے کی جاتی ہے۔ نوٹ: خالی صف کے لئے کوئی نہیں لوٹاتا ہے۔ مثال: >>> prod_signs (([1 ، 2 ، 2 ، -4)) == -9 >>> prod_signs (([0 ، 1]) == 0 >>> prod_signs (([]) == None \"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"N قطار اور N کالم (N > = 2) اور ایک مثبت انٹیجر k کے ساتھ ایک گرڈ کو دیکھتے ہوئے ، گرڈ کے ہر سیل میں ایک قدر ہوتی ہے۔ [1، N * N] شامل رینج میں ہر انٹیجر گرڈ کے خلیوں پر بالکل ایک بار ظاہر ہوتا ہے۔ آپ کو گرڈ میں لمبائی k کا کم سے کم راستہ تلاش کرنا ہوگا۔ آپ کسی بھی سیل سے شروع کرسکتے ہیں ، اور ہر قدم میں آپ کسی بھی ہمسایہ خلیوں میں جاسکتے ہیں ، دوسرے الفاظ میں ، آپ کسی ایسے خلیوں میں جاسکتے ہیں جو آپ کے ساتھ ایک کنارے کا اشتراک کرتے ہیں۔ براہ کرم نوٹ کریں کہ لمبائی k کا راستہ بالکل k خلیوں (ضروری طور پر الگ نہیں) کا دورہ کرنے کا مطلب ہے۔ آپ گرڈ سے باہر نہیں جاسکتے ہیں۔ A راستہ A (لمبائی k) ایک راستہ B (لمبائی k) سے کم سمجھا جاتا ہے اگر A اور B پر اقدار کی ترتیب شدہ فہرست بنانے کے بعد (آئیے انہیں lA_st اور lA_st کہتے ہیں) ، lA_st لغوی طور پر lA_st سے کم ہوتا ہے ، دوسرے الفاظ میں ، ایک انٹیجر k میں ، آپ کسی بھی پڑوسی خلیے میں جاسکتے ہیں۔ براہ کرم نوٹ کریں کہ لمبائی k کا راستہ کا مطلب ہے بالکل k خلیوں (ضروری طور پر الگ نہیں) کا دورہ (ضروری طور پر الگ نہیں) ۔ آپ گرڈ کے کسی بھی راستے پر A (لمبڑے) سے باہر نہیں جاسکتے ہیں۔ اگر A (لمبائی k) A (لمبائی k) (لمبائی k) (لمبائی) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A (A) (A) (A (A) (A (A) (A) (A (A) (A (A) (A) (A (A) (A) (A (A) (A (A) (A) (A) (A (A) (A) (A (A) (A (A) (A) (A) (A (A) (A) (A (A) (A\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"فبونیکی ترتیب کو ہر کوئی جانتا ہے ، اس کا مطالعہ ریاضی دانوں نے گذشتہ دو صدیوں میں گہرائی سے کیا تھا۔ تاہم ، جو لوگ نہیں جانتے وہ ہے ٹریبونیکی ترتیب۔ ٹریبونیکی ترتیب کی تعریف تکرار سے کی جاتی ہے: tri(1) = 3 tri(n) = 1 + n / 2 ، اگر n جوڑا ہے۔ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، اگر n عجیب ہے۔ مثال کے طور پر: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 آپ کو ایک غیر منفی عدد عدد n دیا گیا ہے ، آپ کو ٹریبونیکی ترتیب کی پہلی n + 1 نمبروں کی فہرست واپس کرنی ہوگی۔ مثال: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"مثبت عددی n دی گئی ہے ، عجیب ہندسوں کا مصنوعہ لوٹائیں۔ 0 واپس کریں اگر تمام ہندسے بھی ہیں۔ مثال کے طور پر: ہندسے ((1) == 1 ہندسے ((4) == 0 ہندسے ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''ایک فنکشن بنائیں جو ان پٹ کے طور پر ایک تار لیتا ہے جس میں صرف مربع قوسین ہوتی ہے۔ فنکشن کو درست واپس کرنا چاہئے اگر اور صرف اس صورت میں اگر قوسین کی ایک درست ذیلی ترتیب موجود ہو جہاں کم از کم ایک قوسین میں گھوںسلا ہو۔ is_nested '[[]]') â -> True is_nested '[[]]]]]]]]][[[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"آپ کو اعداد کی ایک فہرست دی گئی ہے۔ آپ کو دی گئی فہرست میں مربع اعداد کا مجموعہ واپس کرنے کی ضرورت ہے ، فہرست میں ہر عنصر کو سب سے پہلے اوپری انٹ ((سقف) تک گول کریں۔ مثال: کے لئے lst = [1,2,3] آؤٹ پٹ 14 ہونا چاہئے lst = [1,4,9] آؤٹ پٹ 98 ہونا چاہئے lst = [1,3,5,7] آؤٹ پٹ 84 ہونا چاہئے lst = [1.4,4.2,0] آؤٹ پٹ 29 ہونا چاہئے lst = [-2.4,1,1] آؤٹ پٹ 6 ہونا چاہئے \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''ایک فنکشن بنائیں جو صحیح ہے اگر کسی دیئے گئے تار کا آخری کردار حروف تہجی کا کردار ہے اور کسی لفظ کا حصہ نہیں ہے ، اور دوسری صورت میں غلط ہے۔ نوٹ: \"لفظ\" حروف کا ایک گروپ ہے جو جگہ سے الگ ہے۔ مثال: چیک_ف_لاسٹ_چار_ایس_اے_لیٹر (((\"سیب پائی\") â -> غلط چیک_ف_لاسٹ_چار_ایس_اے_لیٹر (((سیب پائی ای\") â -> سچ چیک_ف_لاسٹ_چار_ایس_اے_لیٹر (((سیب پائی ای)) â -> غلط چیک_ف_لاسٹ_چار_ایس_اے_لیٹر ((((\") â -> غلط چیک_ف_لاسٹ_چار_ایس_اے_لیٹر'''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"ایک فنکشن بنائیں جو کسی عنصر کا سب سے بڑا انڈیکس لوٹائے جو اس سے پہلے والے عنصر سے زیادہ یا اس کے برابر نہ ہو۔ اگر ایسا کوئی عنصر موجود نہیں ہے تو پھر -1 واپس کریں۔ دی گئی صف میں نقل شدہ اقدار نہیں ہوں گی۔ مثال: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''ایک ایسا فنکشن بنائیں جو ایک ٹپل (a، b) لوٹائے ، جہاں 'a' منفی انٹیجرز میں سب سے بڑا ہے ، اور 'b' ایک فہرست میں مثبت انٹیجرز میں سب سے چھوٹا ہے۔ اگر کوئی منفی یا مثبت انٹیجرز نہیں ہیں تو ، انہیں None کے طور پر لوٹائیں۔ مثال: سب سے بڑا_سب سے چھوٹا_انٹیجرز[2, 4, 1, 3, 5, 7]) == (کوئی نہیں ، 1) سب سے بڑا_سب سے چھوٹا_انٹیجرز (([]) == (کوئی نہیں ، کوئی نہیں) سب سے بڑا_سب سے چھوٹا_انٹیجرز ((0]) == (کوئی نہیں ، کوئی نہیں) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"ایک فنکشن بنائیں جو انٹیجرز ، فلوٹس ، یا تاروں کو حقیقی تعداد کی نمائندگی کرتا ہے ، اور اس کی دی گئی متغیر کی قسم میں بڑا متغیر لوٹاتا ہے۔ اگر اقدار برابر ہیں تو کوئی نہیں لوٹاتا ہے۔ نوٹ: اگر کوئی حقیقی تعداد تار کے طور پر پیش کی جاتی ہے تو ، فلائنگ پوائنٹ ہوسکتا ہے . یا ، compare_one{1} ، 2.5) â -> 2.5 compare_one{1} ، \"2,3\") â -> \"2,3\" compare_one{1} ، \"5,1\"، \"6\") â -> \"6\" compare_one{1} ، 1) â -> کوئی نہیں \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"اس کی جانچ پڑتال کریں کہ آیا دی گئی نمبر n کو بالکل 4 مثبت اعداد کے مجموعے کے طور پر لکھا جاسکتا ہے مثال کے طور پر is_equal_to_sum_even (۴) == غلط is_equal_to_sum_even (۶) == غلط is_equal_to_sum_even (۸) == سچ \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"برازیلی فیکٹریئل کی تعریف اس طرح کی گئی ہے: برازیلی_فیکٹریئل ((n) = n! * (n-1)! * (n-2)! * ... * 1! جہاں n > 0 مثال کے طور پر: >>> خصوصی_فیکٹریئل ((4) 288 فنکشن کو ان پٹ کے طور پر ایک انٹیجر ملے گا اور اس انٹیجر کا خصوصی فیکٹریل واپس کرنا چاہئے۔ \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_مثال-3کھتے ہوئے ، اس میں موجود تمام خالی جگہوں کو زیر نشانوں سے تبدیل کریں ، اور اگر کسی تار میں لگاتار 2 سے زیادہ خالی جگہیں ہیں تو ، پھر تمام لگاتار خالی جگہوں کو - فکس_ اسپیسز کے ساتھ تبدیل کریں (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" فکس_ اسپیسز (مثال کے طور پر) == \"مثال\" مثال 3 (مثال کے طور پر) == \"مثال-3\"\"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"ایک فنکشن بنائیں جو فائل کے نام کی نمائندگی کرنے والی تار لیتا ہے ، اور اگر فائل کا نام درست ہے تو 'ہاں' لوٹاتا ہے ، اور بصورت دیگر 'نہیں' لوٹاتا ہے۔ فائل کا نام تو صرف اس صورت میں درست سمجھا جاتا ہے اگر اور صرف اس صورت میں کہ فائل کے نام میں درج ذیل تمام شرائط پوری ہوں: - فائل کے نام میں تین سے زیادہ ہندسے ('0'-'9') نہیں ہونے چاہئیں۔ - فائل کے نام میں بالکل ایک ڈاٹ '.' ہونا چاہئے۔ - ڈاٹ سے پہلے سبسٹرن خالی نہیں ہونا چاہئے ، اور یہ لاطینی الفا کے حرف سے شروع ہوتا ہے ('a'-'z' اور 'A'Z'). - ڈاٹ کے بعد سبسٹرن ان میں سے ایک ہونا چاہئے: ['txt' ، 'exe' ، 'll'] مثال: file_name_check\"(مثال txt.txt\") # => 'ہاں' فائل کا نام_check\"(مثال1d.ll\") # => 'نہیں' (نام ایک لاطینی حرف الفا سے شروع ہونا چاہئے)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" یہ فنکشن انٹیجرز کی ایک فہرست لے گا۔ فہرست میں تمام اندراجات کے لئے ، فنکشن انٹیجر اندراج کو مربع کرے گا اگر اس کا انڈیکس 3 کا ایک ضرب ہے اور انٹیجر اندراج کو مکعب کرے گا اگر اس کا انڈیکس 4 کا ایک ضرب ہے اور 3 کا ایک ضرب نہیں ہے۔ فنکشن فہرست میں ان اندراجات کو تبدیل نہیں کرے گا جن کے انڈیکس 3 یا 4 کا ضرب نہیں ہیں۔ اس کے بعد فنکشن تمام اندراجات کا مجموعہ واپس کرے گا۔ مثال: lst = [1,2,3] کے لئے آؤٹ پٹ 6 ہونا چاہئے lst = [] کے لئے آؤٹ پٹ 0 ہونا چاہئے lst = [-1،5-،2,-1,-5] کے لئے آؤٹ پٹ ہونا چاہئے -126 \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"آپ کو ایک جملے کی نمائندگی کرنے والی تار دی گئی ہے ، اس جملے میں کچھ الفاظ ہیں جو ایک جگہ سے الگ ہیں ، اور آپ کو ایک تار واپس کرنا ہے جس میں اصل جملے کے الفاظ شامل ہیں ، جن کی لمبائی بنیادی تعداد ہے ، نئی تار میں الفاظ کی ترتیب وہی ہونی چاہئے جو اصل میں ہے۔ مثال1: ان پٹ: جملہ = \"یہ ایک ٹیسٹ ہے\" آؤٹ پٹ: \"ہے\" مثال2: ان پٹ: جملہ = \"سومنگ کے لئے جانے دو\" آؤٹ پٹ: \"گو کے لئے\" پابندیاں: * 1 <= len(sentence) <= 100 * جملہ صرف خطوط پر مشتمل ہے \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"آپ کا کام ایک فنکشن کو نافذ کرنا ہے جو اظہار کو آسان بنائے گا x * n فنکشن صحیح لوٹاتا ہے اگر x * n ایک پوری تعداد میں تشخیص کرتا ہے اور دوسری صورت میں غلط ہے۔ دونوں x اور n ، ایک فریکشن کی تار کی نمائندگی ہیں ، اور مندرجہ ذیل شکل ہے ، <نومریٹر> / <مقام> جہاں دونوں عددی اور منسوب مثبت پورے نمبر ہیں۔ آپ یہ فرض کرسکتے ہیں کہ x ، اور n درست کسر ہیں ، اور منسوب کے طور پر صفر نہیں ہے۔ آسان بنائیں (((\"1/5\" ، \"5/1\") = سچ آسان کریں (((\"1/6\" ، \"2/1\") = غلط آسان کریں (((\"7/10\" ، \"10/2\") = غلط \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"ایک فنکشن لکھیں جو انٹیجرز کی دی گئی فہرست کو ان کے ہندسوں کے مجموعہ کے مطابق بڑھتے ہوئے ترتیب میں ترتیب دے۔ نوٹ: اگر ان کے ہندسوں کے اسی طرح کے مجموعہ کے ساتھ کئی آئٹمز ہیں تو ، انہیں اصل فہرست میں ان کے انڈیکس کی بنیاد پر ترتیب دیں۔ مثال کے طور پر: >>> order_by_points (([1، 11، -1، 11، 12)) == [-1، 11، 1، 12، 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"ایک فنکشن لکھیں جو اعداد کی ایک صف کو ان پٹ کے طور پر لیتا ہے اور صف میں عناصر کی تعداد کو لوٹاتا ہے جو 10 سے زیادہ ہے اور کسی نمبر کے پہلے اور آخری ہندسے دونوں عجیب ہیں (1, 3, 5, 7, 9). مثال کے طور پر: specialFilter (([15، -73، 14، -15]) => 1 specialFilter (([33، -2، -3، 45، 21، 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"آپ کو ایک مثبت عدد n دیا گیا ہے۔ آپ کو لمبائی n کی ایک عدد صف a بنانی ہوگی۔ ہر i (1 ‰¤ i ‰¤ n) کے لئے ، a [i] = i * i - i + 1 کی قدر۔ a کے ٹرپل (a [i] ، a [j] ، a [k]) کی تعداد واپس کریں جہاں i < j < k ، اور a [i] + a [j] + a [k] 3 کا ایک ضرب ہے۔ مثال: ان پٹ: n = 5 آؤٹ پٹ: 1 وضاحت: a = [1 ، 3 ، 7 ، 13 ، 21] واحد درست ٹرپل ہے (1, 7 ، 13) ۔\"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''ہمارے نظام شمسی میں آٹھ سیارے ہیں: سورج کے قریب ترین عطارد ہے ، اگلا ایک وینس ہے ، پھر زمین ، مریخ ، مشتری ، زحل ، یورینس ، نیپچون ہے۔ ایک فنکشن لکھیں جو دو سیارے کے ناموں کو تاروں کے طور پر لے لے۔ سیارہ 1 اور سیارہ 2۔ اس فنکشن کو ایک ٹپل واپس کرنا چاہئے جس میں تمام سیارے شامل ہیں جن کے مدار سیارے 1 کے مدار اور سیارے 2 کے مدار کے درمیان واقع ہیں۔ سورج کے قریب کی طرف ترتیب دیا گیا ہے۔ اگر سیارہ 1 یا سیارہ 2 صحیح سیارے کے نام نہیں ہیں تو فنکشن کو خالی ٹپل واپس کرنا چاہئے۔ مثال bf \"(جاپائٹر ،\" نیپچون \") ==> (\" زحل ، \" یورینس \") bf (((\" زمین ، \" عطارد \") ==> (\" وینس \") bf ((( \" عطارد ، \" یورینس \") ==> (\" وینس ، \" زمین ، \" مریخ ، \" مشتری ، \" \" سورج \") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"ایک فنکشن لکھیں جو تاروں کی فہرست کو پیرامیٹر کے طور پر قبول کرتا ہے ، اس سے ان تاروں کو حذف کرتا ہے جن کی عجیب لمبائی ہوتی ہے ، اور ترتیب شدہ ترتیب کے ساتھ نتیجہ کی فہرست واپس کرتا ہے۔ فہرست ہمیشہ تاروں کی فہرست ہوتی ہے اور کبھی بھی اعداد کی صف نہیں ہوتی ہے ، اور اس میں نقلیں شامل ہوسکتی ہیں۔ فہرست کا حکم ہر لفظ کی لمبائی کے لحاظ سے بڑھتا ہوا ہونا چاہئے ، اور آپ کو اس اصول کے مطابق ترتیب شدہ فہرست واپس کرنی چاہئے۔ اگر دو الفاظ کی لمبائی ایک جیسی ہے تو ، فہرست کو حروف تہجی کے لحاظ سے ترتیب دیں۔ فنکشن کو تاروں کی فہرست ترتیب میں واپس کرنی چاہئے۔ آپ یہ فرض کرسکتے ہیں کہ تمام الفاظ کی لمبائی ایک جیسی ہوگی۔ مثال کے طور پر: assert list_sort[\"aa\"\"، \"a\"\"، \"aaa\"]) => assert list_sort[\"ab\"\"، \"a\"\"، \"aaa\" => \"cdcd\" => \"cd ab\")\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"ایک سادہ پروگرام جس میں x کی قدر لوٹانی چاہئے اگر n ایک بنیادی نمبر ہے اور y کی قدر لوٹانی چاہئے۔ مثال: x_or_y(7، 34، 12) کے لئے == 34 کے لئے x_or_y(15، 8، 5) کے لئے == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''اعداد کی ایک فہرست دی گئی ہے ، فہرست میں ان اعداد کے مربعوں کا مجموعہ واپس کریں جو عجیب ہیں۔ منفی یا غیر انٹیجرز کو نظرانداز کریں۔ دوگنا_فرق (([1 ، 3 ، 2 ، 0]) == 1 + 9 + 0 + 0 = 10 دوگنا_فرق (([-1 ، -2 ، 0]) == 0 دوگنا_فرق (([9 ، -2)) == 81 دوگنا_فرق (([0]) == 0 اگر ان پٹ لسٹ خالی ہے تو ، 0 واپس کریں۔ '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"مجھے لگتا ہے کہ ہم سب کو یہ احساس یاد ہے جب کسی طویل انتظار کے نتیجے کا نتیجہ آخر کار معلوم ہوتا ہے۔ اس لمحے میں آپ کے احساسات اور خیالات کو یقینی طور پر نوٹ کرنے اور موازنہ کرنے کے قابل ہیں۔ آپ کا کام یہ طے کرنا ہے کہ آیا کسی شخص نے متعدد میچوں کے نتائج کا صحیح اندازہ لگایا ہے۔ آپ کو اسکور اور اندازوں کی دو صفیں دی جاتی ہیں جن کی لمبائی برابر ہوتی ہے ، جہاں ہر انڈیکس ایک میچ دکھاتا ہے۔ ایک ہی لمبائی کی ایک صف کو لوٹائیں جس سے یہ ظاہر ہوتا ہے کہ ہر اندازہ کتنا دور تھا۔ اگر انہوں نے صحیح اندازہ لگایا ہے تو ، قیمت 0 ہے ، اور اگر نہیں تو ، قیمت اندازہ اور اسکور کے مابین مطلق فرق ہے۔ مثال: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,1,0,4]) -> [4,0,1,0,6,0,1]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"آپ کو ایک کلاس کا نام (ایک سٹرنگ) اور ایکسٹینشنز کی فہرست دی جائے گی۔ ایکسٹینشنز کو کلاس میں اضافی کلاسز لوڈ کرنے کے لئے استعمال کیا جانا ہے۔ ایکسٹینشن کی طاقت مندرجہ ذیل ہے۔ CAP کو ایکسٹینشن کے نام میں بڑے حروف کی تعداد سمجھیں ، اور SM کو ایکسٹینشن کے نام میں چھوٹے حروف کی تعداد سمجھیں ، طاقت کو کسر CAP - SM کے ذریعہ دیا جاتا ہے۔ آپ کو مضبوط ترین توسیع تلاش کرنی چاہئے اور اس فارمیٹ میں ایک سٹرنگ واپس کرنی چاہئے: ClassName.StrongestExtensionName۔ اگر دو یا زیادہ توسیعیں ایک ہی طاقت کے ساتھ ہیں تو ، آپ کو فہرست میں پہلے آنے والی کا انتخاب کرنا چاہئے۔ مثال کے طور پر ، اگر آپ کو کلاس کے طور پر \"سلائسز\" اور توسیعوں کی فہرست دی گئی ہے: ['SEviRNGSliCes'، 'Cheese'، 'StuFed'] تو آپ کو 'Slices.SEviRNGSliCes' ، 'SviRNGSliCes' ، 'mySviRNGSliCes' (تعظیم ترین توسیع) کی تعداد واپس کرنی چاہئے۔ مثال کے لئے 'AA'_class'، 'AA' مضبوط ترین توسیعید' ہے۔\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"آپ کو 2 الفاظ دیئے گئے ہیں۔ آپ کو درست لوٹانے کی ضرورت ہے اگر دوسرا لفظ یا اس کی کسی بھی گردش میں پہلے لفظ میں سب اسٹرنگ ہے cycpattern_check(\"abcd\",\"abd\") => غلط cycpattern_check(\"hello\",\"ell\") => سچ cycpattern_check(\"whassup\",\"psus\") => غلط cycpattern_check\"abab\",\"baa\") => سچ cycpattern_check\"(\"efef\",\"eeff\") => غلط cycpattern_check\"(hims\",\"simen\") => سچ \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"ایک عدد دیا گیا ہے۔ ایک ٹپل واپس کریں جس میں بالترتیب برابر اور عجیب ہندسوں کی تعداد ہو۔ مثال: یہاں تک کہ_انڈ_کاؤنٹ ((-12) ==> (1, 1) یہاں تک کہ_انڈ_کاؤنٹ ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"ایک مثبت انٹیجر دیا گیا ہے ، اس کے رومن عددی مساوی کو ایک تار کے طور پر حاصل کریں ، اور اسے چھوٹے حروف میں لوٹائیں۔ پابندیاں: 1 <= num <= 1000 مثالیں: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''مثلث کے تین اطراف کی لمبائی دی گئی ہے۔ اگر تینوں اطراف ایک مستطیل مثلث بناتے ہیں تو درست لوٹائیں ، بصورت دیگر غلط۔ ایک مستطیل مثلث ایک مثلث ہے جس میں ایک زاویہ سیدھا زاویہ یا 90 ڈگری ہے۔ مثال: right_angle_triangle ((3، 4، 5) == True right_angle_triangle ((1، 2، 3) == غلط '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"ایک فنکشن لکھیں جو تاروں کی فہرست کو قبول کرے۔ اس فہرست میں مختلف الفاظ ہیں۔ زیادہ سے زیادہ منفرد حروف کے ساتھ لفظ واپس کریں۔ اگر متعدد تاروں میں زیادہ سے زیادہ منفرد حروف ہیں تو ، وہ ایک واپس کریں جو لغت کے لحاظ سے پہلے آتا ہے۔ find_max (([\"name\"، \"of\"، \"string\"]) == \"string\" find_max (([\"name\"، \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"آپ بھوکے خرگوش ہیں، اور آپ نے پہلے ہی گاجر کی ایک خاص تعداد کھائی ہے، لیکن اب آپ کو دن کے کھانے کو مکمل کرنے کے لئے مزید گاجر کھانے کی ضرورت ہے۔ آپ کو ایک صف واپس کرنی چاہئے [ کھانے کے بعد کھائے جانے والے گاجر کی کل تعداد، کھانے کے بعد باقی گاجر کی تعداد ] اگر کافی باقی گاجر نہیں ہیں تو ، آپ باقی تمام گاجر کھائیں گے ، لیکن پھر بھی بھوک لگے گی۔ مثال: * کھائیں ((5, 6, 10) -> [11, 4] * کھائیں ((4, 8, 9) -> [12, 1] * کھائیں ((1, 10, 10) -> [11, 0] * کھائیں ((2, 11, 5) -> [7, 0] متغیرات: @number: انٹیجر گاجر کی تعداد جو آپ نے کھائی ہے۔ @need: انٹیجر گاجر کی تعداد جو آپ کو کھانے کی ضرورت ہے۔ @remaining:: باقی گاجر کی باقی تعداد اسٹاک میں موجود ہے۔ Constrain: * 0 = <= 0 * 1000 = <= 1000 * 0 = <= 1000 باقی = <= 1000 = تفریح کریں:)\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"دو فہرستیں آپریٹر ، اور آپریڈنڈ دی گئیں۔ پہلی فہرست میں بنیادی الجبرا آپریشنز ہیں ، اور دوسری فہرست انٹیجرز کی فہرست ہے۔ الجبری اظہار کی تعمیر کے لئے دو دی گئی فہرستوں کا استعمال کریں اور اس اظہار کی تشخیص کو واپس کریں۔ بنیادی الجبرا آپریشنز: جمع (+) گھٹاؤ ( -) ضرب ( *) فرش تقسیم ( //) ایکسپوننٹیشن ( ** مثال) آپریٹر['+'، '*'، '-'] صف = [2، 3، 4، 5] نتیجہ = 2 + 3 * 4 - 5 => نتیجہ = 9 نوٹ: آپریٹر کی فہرست کی لمبائی آپریٹنڈ فہرست کی لمبائی کے برابر ہے۔ آپریٹنڈ غیر منفی انٹیجرز کی فہرست ہے۔ آپریٹر کی فہرست میں کم از کم ایک آپریٹنڈ ہے ، اور آپریٹنڈ فہرست میں کم از کم دو آپریٹنڈ ہیں۔ \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"آپ کو ایک تار s دیا گیا ہے۔ اگر s[i] ایک حرف ہے تو ، اس کے کیس کو نیچے سے اوپر یا اس کے برعکس تبدیل کریں ، بصورت دیگر اسے اسی طرح رکھیں۔ اگر اسٹرنگ میں کوئی حرف نہیں ہے تو ، اسٹرنگ کو الٹ دیں۔ فنکشن کو نتیجہ کی تار واپس کرنی چاہئے۔ مثال کے طور پر حل کریں ((\"1234\") = \"4321\" حل کریں ((\"ab\") = \"AB\" حل کریں ((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"ایک تار 'متن' دی گئی ہے، اس کے md5 ہیش مساوی تار واپس کریں۔ اگر 'متن' خالی تار ہے، تو کوئی نہیں لوٹائیں۔ >>> string_to_md5('ہیلو دنیا') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "urd_Arab",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"دو مثبت انٹیجرز a اور b دیئے گئے ، a اور b کے درمیان بھی ہندسوں کو بڑھتے ہوئے ترتیب میں لوٹائیں۔ مثال کے طور پر: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]