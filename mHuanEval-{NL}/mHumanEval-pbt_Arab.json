[
    {
        "task_id": "HumanEval/0",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"وګورئ چې د شمېرو په ورکړل شوي لیست کې ، کوم دوه شمیرې د ورکړل شوي حد څخه یو بل ته نږدې دي. مثال: >>> has_close_elements (([1.0 ، 2.0 ، 3.0 ، 0.5) غلط >>> has_close_elements (([1.0 ، 2.8 ، 3.0 ، 4.0 ، 5.0 ، 2.0 ، 0.3) ریښتینی \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"د دې فنکشن لپاره ان پټ یو تار دی چې د ګنډل شوي قوسونو ډیری ډلې لري. ستاسو هدف دا دی چې دا ګروپ په جلا تارونو کې جلا کړئ او د هغو لیست بیرته راګرځئ. جلا ګروپونه متوازن دي (هر خلاص قوس په سمه توګه تړل شوی) او په یو بل کې نه نیسټ شوي د ننوت تار کې کوم ځایونه له پامه غورځول. مثال: >>> جلا_پیرن_ګروپونه ' ((( ) (() (()))))) ' [' (()) '، ' ((()) '، ' ((()))) ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"د مثبت تعویضي ټکي شمیره ورکړل شوې ، دا په بشپړ برخه کې تحلیل کیدی شي (لوی عدد د ورکړل شوي شمیر څخه کوچنی) او اعشاریې (پاته برخه تل له 1 څخه کوچنۍ وي). د شمیر اعشاریه برخه بیرته راګرځئ. مثال: >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"تاسو ته د بانکي حساب د زیرمو او وتلو عملیاتو لیست درکول کیږي چې د صفر توازن سره پیل کیږي. ستاسو دنده دا ده چې کشف کړئ که په کوم وخت کې د حساب توازن د صفر څخه ښکته راشي ، او په دې وخت کې فنکشن باید ریښتینی بیرته راستون شي. که نه نو دا باید غلط بیرته راستون شي. مثال: >>> below_zero([1, 2, 3]) غلط >>> below_zero([1, 2, -4, 5]) ریښتینی \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"د ورکړل شوي لیست لپاره د ننوتلو شمیرې، د دې ډیټا سیټ د اوسط شاوخوا شاوخوا اوسط مطلق انحراف محاسبه کړئ. اوسط مطلق انحراف د هر عنصر او مرکزي نقطې ترمنځ اوسط مطلق توپیر دی (په دې حالت کې معنی): MAD = اوسط ۰ x - x_mean  مثال: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"د ننوتلو لیست د هر دوه پرله پسې عناصرو ترمنځ یو شمیر 'دلیمیټر' داخل کړئ `numbers' >>> intersperse (([] ، 4) [] >>> intersperse (([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"د دې فنکشن لپاره ان پټ د ځایونو لخوا جلا شوي قوسونو لپاره ډیری ډلو استازیتوب کوي. د هرې ډلې لپاره ، د قوسونو د نیسټینګ ترټولو ژوره کچه محصول کړئ. د مثال په توګه (() (()) د نیسټینګ اعظمي دوه کچې لري پداسې حال کې چې ((())) درې لري. >>> parse_nested_parens (('((()) ((())) (((()) (((()) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"د تارونو د ننوتلو لیست یوازې د هغو لپاره فلټر کړئ چې ورکړل شوي فرعي تار لري >>> filter_by_substring([] ، 'a') [] >>> filter_by_substring(['abc' ، 'bacd' ، 'cde' ، 'array'] ، 'a') ['abc' ، 'bacd' ، 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"د بشپړ شمیرونو د ورکړل شوي لیست لپاره ، یو ټپل بیرته راګرځئ چې د ټولې لیست کې د ټولو بشپړ شمیرونو مجموعه او محصول لري. خالي مجموعه باید 0 سره مساوي وي او خالي محصول باید 1 سره مساوي وي. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"د بشپړ شمیرونو له ورکړل شوي لیست څخه ، د ترتیب په ترتیب کې تر ورکړل شوي شیبې پورې موندل شوي د رولینګ اعظمي عنصر لیست رامینځته کړئ. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"تر ټولو لنډ پالینډروم ومومئ چې د ورکړل شوي تار سره پیل کیږي. د الګوریتم مفکوره ساده ده: - د ورکړل شوي تار ترټولو اوږد پوسټفیکس ومومئ چې پالینډروم وي. - د تار مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخکینۍ مخ مخ مخ مخکینۍ مخ مخ مخ مخ مخ مخ مخ مخ مخکینۍ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ مخکۍ\"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"ازموینه که ورکړل شوی تار یو پالینډروم وي \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"ننوتل دوه تارونه دي a او b چې یوازې د 1s او 0s څخه جوړ شوي دي. په دې ننوتلو باندې بائنري XOR ترسره کړئ او پایله یې د تار په توګه هم بیرته راګرځئ. >>> string_xor (('010'، '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"د تارونو له لیست څخه، تر ټولو اوږد یو بیرته راګرځوئ. د ورته اوږدوالي د څو تارونو په صورت کې لومړی یو بیرته راګرځوئ. د ننوتلو لیست خالي کیدو په صورت کې هیڅ نه بیرته راګرځئ. >>> تر ټولو اوږد ((([]) >>> تر ټولو اوږد ((['a','b','c']) 'a' >>> تر ټولو اوږد ((['a','bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"د دوو عددونو a او b تر ټولو لوی ګډ تقسیم کوونکی بیرته راګرځوئ >>> تر ټولو لوی_مشترکه_تقسیم کوونکی ((3, 5) 1 >>> تر ټولو لوی_مشترکه_تقسیم کوونکی ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"د ننوتل شوي تار له لنډ څخه تر اوږده پورې د ټولو پریفکسونو لیست بیرته راګرځئ >>> all_prefixes (('abc') ['a'، 'ab'، 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"یو تار بیرته راګرځوي چې د ځای له مخې محدود شمیرې لري چې له 0 څخه تر n پورې پیل کیږي. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"ورکړل شوې تار، ومومئ چې څومره جلا کرکټرونه (د قضیې په پام کې نیولو پرته) دا جوړوي >>> count_distinct_characters ((('xyzXYZ') 3 >>> count_distinct_characters ((('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"د دې فنکشن لپاره ان پټ په ځانګړي ASCII ب formatه کې د میوزیک نوټونو استازیتوب کولو تار دی. ستاسو دنده دا ده چې د بشپړ تارونو تار لیست تحلیل کړئ چې د ډیری بیټونو سره سمون لري. دلته یو لیګینډ دی: 'o' نوټ ، وروستی څلور بیټونه 'o' کوم - نیم نوټ ، وروستي دوه بیټونه 'o' - کوټر نوټ ، وروستی یو بیټ >>> parse_music 'o' کوم چې د دې لپاره کارول کیږي. دا دنده ده چې د بشپړ شمیرې بیرته راستنیدنه وکړي او هر یو یې څنګه نه کوي.\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"ومومئ چې په اصلي تار کې څومره ځله ورکړل شوی فرعي تار موندل کیدی شي. د سرپوشې قضیې شمیرل. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"د ننوتلو لپاره د 'صفر' څخه تر 'نه' پورې د شمېرو يو ځای-محدود تار دی. صحيح انتخابونه 'صفر'، 'یو'، 'دوه'، 'درې'، 'څلور'، 'پنځه'، 'شپږ'، 'اووه'، 'اووه' او 'نوه' دي. د شمېرو سره تار بیرته راګرځوي چې له کوچني څخه تر لوی پورې ترتیب شوي دي >>> sort_numbers ((('درې یو پنځه') 'یو درې پنځه' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"د شمېرو له چمتو شوي لیست څخه (لږترلږه دوه) دوه غوره کړئ او بیرته راګرځئ چې یو بل ته نږدې دي او په ترتیب سره یې بیرته راګرځئ (کوچنی شمیره ، لویه شمیره). >>> find_closest_elements (([1.0 ، 2.0 ، 3.0 ، 4.0 ، 5.0 ، 2.2]) (2.0 ، 2.2) >>> find_closest_elements (([1.0 ، 2.0 ، 3.0 ، 4.0 ، 5.0 ، 2.0]) (2.0 ، 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"د شمېرو لیست ورکړل شوی (لږترلږه دوه عناصرو څخه) ، دې لیست ته یو خطي بدلون پلي کړئ ، نو دا چې ترټولو کوچنۍ شمیره به 0 شي او ترټولو لوی به 1 شي >>> rescale_to_unit (([1.0 ، 2.0 ، 3.0 ، 4.0 ، 5.0]) [0.0 ، 0.25 ، 0.5 ، 0.75 ، 1.0] \"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"د هر ډول پیتون ارزښتونو لیست یوازې د بشپړ شمیرو لپاره فلټر کړئ >>> filter_integers ((['a'، 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc'، {}، []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"د ورکړل شوي تار >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"د ورکړل شوي عدد n لپاره، تر ټولو لوی عدد ومومئ چې n په مساوي ډول ويشي، له n څخه کوچنی >>> لوی_ډیویزر ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"د ورکړل شوي عدد د لومړنیو فاکتورونو لیست بیرته راګرځول د کوچني څخه تر لوی پورې په ترتیب کې. هر فاکتور باید د څو ځله سره سمون ولري چې په فاکتور کې څومره ځله څرګندیږي. د ننوتلو شمیره باید د ټولو فاکتورونو محصول سره مساوي وي >>> فاکتور کړئ ((8) [2، 2، 2] >>> فاکتور کړئ ((25) [5، 5] >>> فاکتور کړئ ((70) [2، 5، 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"د بشپړ شمیرونو له لیست څخه ، ټول عناصر لرې کړئ چې له یو ځل څخه ډیر پیښیږي. د عناصرو ترتیب ورته په ان پټ کې ورته وساتئ. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"د ورکړل شوي تار لپاره، کوچني حروف لوی او لوی حروف کوچني ته واړوئ. >>> flip_case ((('Hello') 'hELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"د تارونو لیست په یو واحد تار کې سره یوځای کړئ >>> concatenate (([]) '' >>> concatenate ((['a','b','c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"د تارونو د ننوتلو لیست یوازې د هغو لپاره فلټر کړئ چې د ورکړل شوي پریفیکس سره پیل کیږي. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"په لیست کې یوازې مثبت شمیرې بیرته راګرځوئ. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"ریښتیني بیرته راستون کړئ که ورکړل شوې شمیره لومړنۍ وي ، او که نه نو غلط. >>> is_prime ((6) غلط >>> is_prime ((101) ریښتیني >>> is_prime ((11) ریښتیني >>> is_prime ((13441) ریښتیني >>> is_prime ((61) ریښتیني >>> is_prime ((4) غلط >>> is_prime ((1) غلط \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"find_zero د xs د څو اړخیز ضریبونه دي. find_zero find x داسې چې poly (((x) = 0. find_zero یوازې یوازې صفر ټکی بیرته راولي، حتی که ډیری شتون ولري. سربیره پردې، find_zero یوازې د xs لیست لري چې حتی د ضریبونو شمیر او ترټولو لوی غیر صفر ضریب لري ځکه چې دا د حل تضمین کوي. >>> round ((find_zero[(1, 2]) ، 2) # f (((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"په x نقطه کې د کوفيفېسنټ xs سره پولینوم ارزوي. xs[0] + xs[1] * x + xs[1] * x ^ 2 + .... xs[n] * x ^ n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"دا فنکشن یو لیست l اخلي او یو لیست l' بیرته راولي چې l' د l سره ورته وي په شاخصونو کې چې په دریو ویشل کیدی نشي ، پداسې حال کې چې د دې ارزښتونه په شاخصونو کې چې په دریو ویشل کیدی شي د l د اړوندو شاخصونو ارزښتونو سره مساوي دي ، مګر ترتیب شوي. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"په لیست کې ترتیب شوي ځانګړي عناصر بیرته راګرځوي >>> ځانګړي (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"په لیست کې اعظمي عنصر بیرته راګرځوئ. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"د عدد 7 د عددونو په شمیر کې د n څخه کم چې د 11 یا 13 لخوا تقسیم کیږي راګرځول کیږي. >>> fizz_buzz ((50) 0 >>> fizz_buzz ((78) 2 >>> fizz_buzz ((79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"دا فنکشن یو لیست l اخلي او یو لیست l' بیرته راولي چې l' د l سره ورته وي په عجیب شاخصونو کې ، پداسې حال کې چې د دې ارزښتونه په حتی شاخصونو کې د l د حتی شاخصونو ارزښتونو سره مساوي دي ، مګر ترتیب شوي. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"د ان پټ تار په توګه اخلي چې د encode_cyclic فنکشن سره کوډ شوی وي. د کوډ شوي تار بیرته راستنوي. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"د درې کرکټرونو د دورې ګروپونو لخوا کوډ شوي تار بیرته راولي.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib د n-م شمېره بیرته راګرځوي چې د فیبوناچي شمېره ده او دا هم لومړنۍ ده. >>> prime_fib ((1) 2) >>> prime_fib ((2) 3) >>> prime_fib ((3) 5) >>> prime_fib ((4) 13) >>> prime_fib ((5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero د ان پټ په توګه د بشپړ شمیرو لیست اخلي. دا ریښتیا راستنوي که چیرې په لیست کې درې جلا عناصر شتون ولري چې صفر ته اضافه شي ، او غلط که نه. >>> triples_sum_to_zero (([1 ، 3 ، 5 ، 0]) غلط >>> triples_sum_to_zero (([1 ، 3 ، -2 ، 1]) ریښتیا >>> triples_sum_to_zero (([1 ، 2 ، 3 ، 7]) غلط >>> triples_sum_to_zero (([2 ، 4 ، -5 ، 3 ، 9 ، 7]) ریښتیا >>> triples_sum_to_zero [1]) غلط \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"د موټرونو دوه ډلې د یو بل څخه ډیر لرې پیل کیږي. ټول موټرونه په ورته سرعت کې حرکت کوي. دوه موټرونه ټکر کوي کله چې یو موټر چې کی left څخه ښیې ته ځي یو موټر ته ورسیږي چې ښیې ته کی left حرکت کوي. په هرصورت ، موټرونه په لامحدود ډول قوي او قوي دي؛ په پایله کې ، دوی په خپل مسیر کې حرکت ته دوام ورکوي لکه څنګه چې دوی ټکر نه وي کړی. دا فنکشن د ورته ټکرونو شمیر تولیدوي.\"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"د 1 لخوا د عنصرونو سره بیرته راستنیدونکی لیست. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero د ان پټ په توګه د بشپړ شمیرو لیست اخلي. دا ریښتیا راستنوي که چیرې په لیست کې دوه جلا عناصر شتون ولري چې صفر ته اضافه شي ، او غلط که نه. >>> pairs_sum_to_zero (([1، 3، 5، 0]) غلط >>> pairs_sum_to_zero (([1، 3، -2، 1]) غلط >>> pairs_sum_to_zero (([1، 2، 3، 7]) غلط >>> pairs_sum_to_zero (([2، 4، -5، 3، 5، 7]) ریښتیا >>> pairs_sum_to_zero (([1]) غلط \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"د ان پټ شمیرې x عددي اساس اساس ته بدل کړئ. د تبادلې وروسته د تار نمایندګي بیرته راګرځئ. د اساس شمیرې له 10 څخه کم دي. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"د مثلث لپاره د اړخ او لوړ بیرته راستنیدونکي ساحې اوږدوالی ورکړل شوی. >>> مثلث_عرض ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"د Fib4 شمیر لړۍ د فبونیکي لړۍ ته ورته لړۍ ده چې په لاندې ډول تعریف شوې: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). مهرباني وکړئ د fib4 شمیر لړۍ د n-th عنصر په اغیزمنه توګه محاسبه کولو لپاره یو فنکشن ولیکئ. تکرار مه کاروئ. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"د لیست د عناصرو منځنۍ برخه بیرته راګرځئ l. >>> منځنۍ (([3، 1، 2، 4، 5]) 3 >>> منځنۍ (([-10، 4، 6، 1000، 10، 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"دا چک کوي چې ورکړل شوې تار یو پالینډروم دی >>> is_palindrome (('') ریښتیا >>> is_palindrome (('aba') ریښتیا >>> is_palindrome (('aaaaa') ریښتیا >>> is_palindrome (('zbcd') غلط \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"د 2 ^ n ماډولو p بیرته راګرځئ (د شمیرې څخه خبر اوسئ). >>> modp (((3، 5) 3 >>> modp ((1101، 101) 2 >>> modp (((0, 101) 1 >>> modp (((3، 11) 8 >>> modp ((100، 101) 1 \"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"د انکوډ_شفت فنکشن سره کوډ شوی د ننوت تار په توګه اخلي. د کوډ شوي تار بیرته راستنوي. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"په الفبا کې د هر کرکټر د 5 په بدلولو سره کوډ شوی تار بیرته راولي.\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels یو فنکشن دی چې تار اخلي او پرته له حرفونو څخه تار بیرته راولي. >>> remove_vowels ((('') ' ' >>> remove_vowels (((\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels (('abcdef') 'bcdf' >>> remove_vowels (('aaaaa') ' ' >>> remove_vowels (('aaBAA') 'B' >>> remove_vowels (('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"ریښتیني بیرته راستون کړئ که چیرې په لیست کې ټولې شمیرې د حد څخه ښکته وي. >>> below_threshold (([1، 2، 4، 10]، 100) ریښتیني >>> below_threshold (([1، 20، 4، 10]، 5) غلط \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"دوه شمیرې x او y اضافه کړئ >>> اضافه کړئ (((2, 3) 5 >>> اضافه کړئ (((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"وګورئ چې دوه کلمې ورته کرکټرونه لري. >>> same_chars ((('eabcdzzzz', 'dddzzzzzzdeddabc') ریښتیا >>> same_chars ((('abcd', 'dddddddddabc') ریښتیا >>> same_chars ((('dddddddabc', 'abcd') ریښتیا >>> same_chars ((('eabcd', 'dddddddddabc') غلط >>> same_chars ((('abcd', 'dddddddabddce') غلط >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') غلط \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"د فبوناکسي n-م شمیره بیرته راګرځوئ. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets د \"<\" او \">\" یو تار دی. راستنیدنه ریښتیا ده که چیرې هر پرانیستل شوی بریکټ د تړلو بروکټ سره مطابقت ولري. >>> correct_bracketing (((\"<\") غلط >>> correct_bracketing (((\"<>\") ریښتیا >>> correct_bracketing (((\"<><>\") ریښتیا >>> correct_bracketing (((\"><<>\") غلط \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"راستنول ریښتیني دي د لیست عناصر په یو ډول زیاتیدونکي یا کمیدونکي دي. >>> monotonic (([1، 2، 4، 20]) ریښتیني >>> monotonic (([1، 20، 4، 10]) غلط >>> monotonic (([4، 1، 0، -10)) ریښتیني \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"د دوو لیستونو لپاره بېل شوي ځانګړي عام عناصر بیرته راګرځوي. >>> common (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> common (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"د n تر ټولو لوی لومړنی فاکتور بیرته راګرځوئ. فرض کړئ چې n > 1 او لومړنی نه دی. >>> ترټولو لوی_لومړی_فاکتور ((13195) 29 >>> ترټولو لوی_لومړی_فاکتور ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n هغه فنکشن دی چې له 1 څخه تر n پورې شمیرې جمع کوي. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets د \"(\" او \"\") يو تار دی. راستنول ریښتیا وي که هر پرانستونکي بریکټ د تړلو بروکټ سره سمون ولري. >>> correct_bracketing (((\"(\") غلط >>> correct_bracketing (((\")) ریښتیا >>> correct_bracketing (((()))) ریښتیا >>> correct_bracketing (((()))) غلط \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs د څو اړخیز ضریب استازیتوب کوي. xs[0] + xs[1] * x + xs[2] * x^2 + .... د دې څو اړخیز مشتق په ورته ب inه کې بیرته راګرځئ. >>> مشتق ((([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> مشتق ([1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"د فیب فیب شمیر لړۍ د فیبوناچي لړۍ ته ورته لړۍ ده چې په لاندې ډول تعریف شوې: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fib ((n-1) + fibfib ((n-2) + fibfib ((n-3). مهرباني وکړئ د فیب فیب شمیر لړۍ د n-th عنصر په اغیزمنه توګه محاسبه کولو لپاره یو فنکشن ولیکئ. >>> fibfib ((1) 0 >>> fib ((5) 4 >>> fib fib ((8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"د vowels_count فنکشن ولیکئ کوم چې د ننوتلو په توګه د کلمې استازیتوب کوي او د تار د vowels شمیر بیرته راولي. په دې حالت کې vowels 'a' ، 'e' ، 'i' ، 'o' ، 'u' دي. دلته ، 'y' هم یو حرف دی ، مګر یوازې کله چې دا د ورکړل شوي کلمې په پای کې وي. مثال: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"د ازموینې نورې قضیې اضافه کړئ. \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"دایره د x د عددونو ارقامو ته اړول، د ارقامو ښي خوا ته اړول او پایله یې د تار په توګه بیرته راګرځول. که چیرې د ارقامو شمیر > وي، نو ارقام بیرته راګرځول. >>> circular_shift ((12, 1) \"21\" >>> circular_shift ((12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"دنده دنده ولیکئ چې د ننوتلو په توګه یو تار اخلي او یوازې د پورتنیو کرکټرونو مجموعه بیرته راولي. د مثالونو په توګه: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"په دې کار کې، تاسو ته به يو تار چې د مڼو او نارنجونو چې د ميوو په يوه ټوکرۍ کې ویشل شوي دي د شمېر استازیتوب ورکړل شي دا ټوکرۍ مڼې، نارنج، او د مانګو ميوو لري. ورکړل د تار چې د نارنجونو او مڼو د ټول شمېر او د يو عدد چې په ټوکرۍ کې د ميوو د ټول شمېر استازیتوب کوي په ټوکرۍ کې د مانګو ميوو د شمېر بېرته. د مثال په توګه: fruit_distribution\"5(مڼې او 6 نارنجونه\"، 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 مڼې او 1 نارنجونه،\"3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 مڼې او 3 نارنجونه،\" 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 مڼې او 120) \"،1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"د یو صف په وړاندې چې د یو ونې څانګه استازیتوب کوي چې غیر منفي عدد نوډونه لري ستاسو دنده دا ده چې یو له نوډونو څخه راوباسي او بیرته یې راولي. راټول شوی نوډ باید د کوچني حتی ارزښت سره نوډ وي. که چیرې د ورته کوچني حتی ارزښت سره ډیری نوډونه وموندل شي نو نوډ بیرته راولي چې ترټولو کوچنی شاخص لري. راټول شوی نوډ باید په لیست کې بیرته راستون شي ، [smallest_value ، د دې شاخص ]، که چیرې حتی ارزښتونه شتون ونلري یا ورکړل شوی صف خالي وي ، بیرته راستون کړئ []. مثال: 1: ننوتنه: [4,2,3] محصول: [2, 1] توضیحات: 2 ترټولو کوچنی حتی ارزښت لري ، او 2 ترټولو کوچنی شاخص لري. مثال 2: ننوتنه: [1,2,3] محصول: [2, 1] توضیحات: 2 ترټولو کوچنی ارزښت لري ، او 2 ترټولو کوچنی حتی شاخص لري. مثال 3: ننوتنه: [] محصول: [] مثال: [4: 5، [3, 4] توضیحات: 0، [0, 2] محصول: 1، نو موږ به لومړی نوډ غوره کړو چې ترټولو کوچنی شاخص لري ، مګر دوه صفرونه شتون لري. مثال: 1 * صفر = صفر.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''تاسو ته د مثبتو بشپړ شمیرونو یو غیر خالي لیست درکول کیږي. ترټولو لوی عدد بیرته راګرځئ چې له صفر څخه لوی وي ، او د عدد ارزښت څخه لوی یا مساوي وي. د عدد فریکونسي هغه وخت دی چې دا په لیست کې څرګندیږي. که داسې ارزښت شتون ونلري ، بیرته راستون کړئ -1. مثالونه: لټون (([4, 1, 2, 2, 3, 1]) == 2 لټون (([1, 2, 2, 3, 3, 3, 4, 4]) == 3 لټون (([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''د بشپړ شمیرونو لیست ورکړل شوی ، په عجیب ترتیب کې لیست بیرته راګرځئ. عجیب ترتیب کول ، هغه وخت دی چې تاسو د لږترلږه ارزښت سره پیل کوئ ، بیا د پاتې بشپړ شمیر اعظمي ، بیا لږترلږه او داسې نور. مثالونه: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''د مثلث د دریو اړخونو اوږدوالی ورکړل شوی. د مثلث ساحه بیرته راګرځوئ 2 اعشاري نقطو ته که چیرې درې اړخونه یو معتبر مثلث رامینځته کړي. که نه نو -1 بیرته راګرځئ درې اړخونه یو معتبر مثلث رامینځته کوي کله چې د کوم دوه اړخونو مجموعه د دریم اړخ څخه لوړه وي. مثال: مثلث_عرض (((3، 4، 5) == 6.00 مثلث_عرض (((1، 2، 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''یو فنکشن ولیکئ چې ریښتیا بیرته راستونوي که چیرې q شی الوتنه وکړي ، او غلط که نه. q شی الوتنه وکړي که چیرې دا متوازن وي (دا یو پالینډروم لیست دی) او د دې عناصرو مجموعه د اعظمي ممکنه وزن څخه لږ یا مساوي وي. مثال: will_it_fly (([1، 2]، 5) â -> غلط # 1+2 د اعظمي ممکنه وزن څخه کم دی ، مګر دا غیر متوازن دی. will_it_fly (([3، 2، 3]، 1) â -> غلط # دا متوازن دی ، مګر 3+2+3 د اعظمي ممکنه وزن څخه ډیر دی. will_it_fly (([3، 2، 3]، 9) â -> ریښتیا # 3+23 د اعظمي ممکنه وزن څخه کم دی ، او دا متوازن دی. will_it_fly ((([3]، â 5) -> ریښتیا # 3 د اعظمي ممکنه وزن څخه کم دی ، او دا متوازن دی.'''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"د ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار ار\"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''د فنکشن لیکل چې د تارونو دوه لیستونه مني او هغه لیست بیرته راولي چې د لیست په ټولو تارونو کې د نورو څخه لږ شمیر لري. که دوه لیستونه د کرکونو ورته شمیر ولري ، لومړی لیست بیرته راولي. مثالونه total_match (([] ، []) â -> [] total_match ((['hi' ، 'admin' ، ['hI' ، 'Hi']) â -> ['hI' ، 'Hi'] total_match ((['hi' ، 'admin' ] ، ['hi' ، 'admin' ، 'project']) â -> ['hi' ، 'admin' ] total_match ((['hi' ، 'admin' ] ، ['hi' ، 'hi']) â -> ['hi' ، 'admin' ] total_match ((['hi' ، 'admin' ] ، ['I' ، 'hi' ، 'hi']) â -> ['I' ، 'hi' ، 'hi' ] total_match ((['4' ] ، ['1' 2' ، '3' ، '4' ، '5' ، [' 4]) -> [' 4' ]'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"یو فنکشن ولیکئ چې ریښتیا بیرته راشي که ورکړل شوې شمیره د 3 لومړني شمیرو ضرب وي او که نه نو غلط وي. په دې پوهیدل چې (a) له 100 څخه کم دی. مثال: is_multiply_prime ((30) == ریښتیا 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"ستاسو دنده دا ده چې یو فنکشن ولیکئ چې ریښتیا بیرته راشي که چیرې یو شمیر x د n ساده ځواک وي او په نورو قضیو کې غلط وي. x د n ساده ځواک دی که n **int = x د مثال په توګه: is_simple_power ((1، 4) => ریښتیا is_simple_power ((2، 2) => ریښتیا is_simple_power ((8، 2) => ریښتیا is_simple_power ((3، 2) => غلط is_simple_power ((3، 1) => غلط is_simple_power ((5، 3) => غلط \"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''یو داسې فنکشن ولیکئ چې یو عدد a اخلي او ریښتیا بیرته راولي که چیرې دا عدد د یو عدد مکعب وي. یادونه: تاسو کولی شئ دا فرض کړئ چې ننوتل تل معتبر وي. مثالونه: iscube ((1) ==> ریښتیا iscube ((2) ==> غلط iscube ((-1) ==> ریښتیا iscube ((64) ==> ریښتیا iscube ((0) ==> ریښتیا iscube ((180) ==> غلط '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"تاسو ته دنده درکول شوې چې د یو فنکشن لیکل چې د یو هکسادسیمال شمیر په توګه د تار په توګه ترلاسه کوي او د هکسادسیمال ډیجیټونو شمیر شمیرل کیږي چې لومړني دي (لومړی شمیر ، یا لومړنی ، یو طبیعي شمیر دی چې له 1 څخه لوی دی چې د دوه کوچني طبیعي شمیرو محصول نه دی). هکسادسیمال ډیجیټونه 0 ، 1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8 ، 9 ، A ، B ، C ، D ، E ، F دي. لومړني شمیرې 2 ، 3 ، 5 ، 7 ، 11 ، 13 ، 17 ، ... دي نو تاسو باید د لاندې ډیجیټونو شمیر وټاکئ: 2 ، 3 ، 5 ، 7 ، 7 ، B (= لسیزه 11) ، D (= لسیزه 13). یادونه: تاسو کولی شئ فرض کړئ چې ننوتنه تل سمه یا خالي تار وي ، او سمبولونه A ، B ، C ، D ، E ، F تل لوی لیکونه دي. مثالونه: د \"نم\" = AB لپاره ، محصول باید 1 وي. د \"نم\" = 1077E لپاره محصول باید 2 وي. د \"نم\" = 1077E وي. د \"د\" لپاره \"د\" باید 2 وي. د \"د\" د \"د\" لپاره \"د\" باید د \"د\" وي.\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"تاسو ته به د اعشاري شکل کې یو عدد درکړل شي او ستاسو دنده به دا وي چې دا په بائنري شکل بدل کړئ. دنده باید یو تار بیرته راشي، چې هر کرکټر یې د بائنري شمیرې استازیتوب کوي. په تار کې هر کرکټر به '0' یا '1' وي. د تار په پیل او پای کې به د 'db' اضافي کرکټرونه شتون ولري. اضافي کرکټرونه د بڼه سره مرسته کوي. مثالونه: decimal_to_binary ((15) # بیرته \"db1111db\" decimal_to_binary32) # بیرته \"db100000db\" \"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"تاسو ته يو تار (s) درکول شوی دی. ستاسو دنده دا ده چې وګورئ چې دا تار خوښ دی او که نه. يو تار خوښ دی که د دې اوږدوالی لږ تر لږه 3 وي او هر 3 پرله پسې لیکونه جلا وي د مثال په توګه: is_happy ((a) => غلط is_happy ((aa) => غلط is_happy ((abcd)) => ریښتیا is_happy ((aabb)) => غلط is_happy ((adb)) => ریښتیا is_happy ((xyy)) => غلط \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"دا د سمستر وروستۍ اونۍ ده او ښوونکي باید زده کوونکو ته درجې ورکړي. ښوونکي د درجې ورکولو لپاره خپل الګوریتم جوړ کړی دی. یوازینۍ ستونزه دا ده چې هغه د درجې ورکولو لپاره کارول شوی کوډ له لاسه ورکړی دی. هغې تاسو ته د ځینې زده کونکو لپاره د GPAs لیست درکړی او تاسو باید یو فنکشن ولیکئ چې کولی شي د لاندې جدول په کارولو سره د لیک درجې لیست تولید کړي: GPA. د لیک درجې 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 B + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E مثال: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"یو فنکشن ولیکئ چې یو تار اخلي او ریښتیا بیرته راستونوي که چیرې د تار اوږدوالی لومړنی شمیره وي یا غلط که نه مثالونه prime_length ((('سلام') == ریښتیني prime_length ((('abcdcba') == ریښتیني prime_length ((('کټینز') == ریښتیني prime_length ((('نارنج') == غلط \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"د مثبت عدد n په پام کې نیولو سره، د n-عددي مثبت عددونو شمیر بیرته راګرځوئ چې د 1 سره پیل یا پای ته رسي. \"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"د مثبت عدد N په پام کې نیولو سره، د دې د عددونو مجموعي مجموعې په بائنري ډول راګرځوئ. مثال د N = 1000 لپاره، د عددونو مجموعې به 1 وي، محصول باید \"1\" وي. د N = 150 لپاره، د عددونو مجموعې به 6 وي، محصول باید \"110\" وي. د N = 147 لپاره، د عددونو مجموعې به 12 وي، محصول باید \"1100\" وي. متغیرونه: @N عدد محدودیتونه: 0 â‰¤ N â‰¤ 10000. محصول: د بائنري شمیرې تار \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"د بشپړ شمیرونو غیر خالي لیست ورکړل شوی lst. حتی عناصر اضافه کړئ چې په عجیب شاخصونو کې دي. مثالونه: اضافه کړئ (([4، 2، 6، 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"د يو فنکشن ليکل چې يو تار اخلي او د هغه يو ترتيب شوی نسخه بيرته راولي. د تار يو ترتيب شوی نسخه، يو تار دی چې ټولې کلمې (د ځای په واسطه جلا شوي) د نوي کلمې په واسطه ځای په ځای شوي دي چې ټول کرکټرونه د ascii ارزښت پر بنسټ په پورته ترتیب ترتیب شوي دي. يادونه: تاسو باید په جمله کې د کلمو او خالي ځایونو ترتیب وساتئ. د مثال په توګه: anti_shuffle ((('Hi') 'Hi' anti_shuffle ((('hello') بیرته 'ehllo' anti_shuffle (('Hello World!!!') بیرته 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"تاسو ته د 2 اړخیز معلومات درکول کیږي، د نیسټ شوي لیستونو په توګه، کوم چې د میټریکس سره ورته دی، په هرصورت، د میټریکسونو برعکس، هر قطار کې ممکن د کالمونو مختلف شمیر ولري. د lst، او انټيجر x په پام کې نیولو سره، په لیست کې انټيجرونه x ومومئ، او د ټپلونو لیست بیرته راګرځئ، [(x1، y1، (x2، y2) ...) داسې چې هر ټپل یو همغږي دی - (صف، کالمونه) ، د 0 سره پیل کول. همغږي په پیل کې د صفونو په ترتیب سره ترتیب کړئ. همدارنګه، د قطار همغږي په کښته ترتیب سره ترتیب کړئ. مثالونه: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 1, 0], 4 (1, 0), (2, 5), (2, 0, 0] get_((1), [] == [[، صف 1، 2، 3]]، [، 2، 3]]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"د غیر منفي عددونو یو صف ورکړل شوی، د ترتیب کولو وروسته د ورکړل شوي صف یوه کاپي بیرته راګرځئ، تاسو به ورکړل شوی صف په پورته ترتیب ترتیب کړئ که چیرې مجموع ((لومړی شاخص ارزښت ، وروستی شاخص ارزښت) عجیب وي ، یا دا په ښکته ترتیب ترتیب کړئ که چیرې مجموع ((لومړی شاخص ارزښت ، وروستی شاخص ارزښت) حتی وي. یادونه: * ورکړل شوی صف مه بدلوئ. مثالونه: * sort_array[(]) => [] * sort_array[]] => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 6] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"د encrypt فنکشن جوړول چې د یو سټینګ د یو دلیل په توګه اخلي او د الفبا سره یو کوډ شوی تار بیرته راولي. الفبا باید په داسې ډول وګرځول شي چې لیکونه دوه ځله دوه ځایونو ته حرکت وکړي. د مثال په توګه: encrypt ((('hi') بیرته 'lm' encrypt ((('asdfghjkl') بیرته 'ewhjklnop' encrypt ((('gf') بیرته 'kj' encrypt ((('et') بیرته 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"تاسو ته د بشپړ شمیرونو لیست درکول شوی. یو فنکشن ولیکئ next_smallest ((() چې د لیست دوهم کوچنی عنصر بیرته راولي. هیڅ نه بیرته راګرځئ که چیرې داسې عنصر شتون ونلري. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == هیڅ نه next_smallest (([1, 1]) == هیڅ نه \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"تاسو ته به د کلمو یو سلسله درکړل شي، او ستاسو دنده به دا وي چې د ستړیا شمیر وشمیرئ. ستړیا یوه جمله ده چې د \"I\" کلمې سره پیل کیږي. جملې د '.', '؟ یا '! ' لخوا محدودې دي. د مثال په توګه: >>> is_bored ((\"سلام نړۍ\") 0 >>> is_bored ((\"آسمان نیلي دی. لمر روښانه دی. زه د دې هوا سره مینه لرم\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''د 3 شمیرې اخلي. ریښتیا راستنوي که چیرې یو شمیر د نورو دوه شمیرې سره مساوي وي ، او ټولې شمیرې بشپړ شمیرې وي. په نورو قضیو کې غلط راستنوي. مثالونه any_int ((5, 2, 7) â -> ریښتیا any_int ((3, 2, 2) â -> غلط any_int ((3, -2, 1) â -> ریښتیا any_int ((3.6, -2.2, 2) â -> غلط '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"داسې فنکشن ولیکئ چې پیغام واخلي، او په داسې ډول یې کوډ کړي چې د ټولو لیکونو قضیې بدلې کړي، په پیغام کې ټول حرفونه د هغه لیک سره ځای په ځای کړي چې د انګلیسي الفبا کې د هغه حرف څخه 2 ځایونه مخکې ښکاري. یوازې لیکونه فرض کړئ. مثالونه: >>> کوډ ((('ټیسټ') 'TGST' >>> کوډ ((('دا یو پیغام دی') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"تاسو ته د عددونو لیست درکول شوی دی. تاسو باید تر ټولو لوی لومړنی عدد ومومئ او د هغه د عددونو مجموع بیرته ورکړئ. مثالونه: د lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] لپاره، محصول باید 10 وي د lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] لپاره، محصول باید 25 وي د lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] لپاره، محصول باید 13 وي د lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] لپاره، محصول باید 11 وي د lst = [0,81,12,3,21,1] لپاره، محصول باید 3 وي د lst = [0,8,1,2,1,7] لپاره، محصول باید 7 وي\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"د يو قاموس په نظر کې نيولو سره، که ټولې ټکي په وړو تورو کې تارونه وي او يا ټولې ټکي په لوړو تورو کې تارونه وي، نو ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټرنټ ريټ ريټرنټ ريټرنټ ريټ ريټرنټ ريټريټ ريټريټ ريټ ريټريټريټ ريټ ريټريټريټ ريټريټ ريټريټ ريټريټريټ ريټريټ ريټريټريټ ريټريټريټريټريټريټ ريټريټريټريټ ريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټريټ\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"د یو فنکشن پلي کول چې یو غیر منفي عدد اخلي او د لومړنیو n عددونو یو صف بیرته راولي چې لومړني عددونه دي او له n څخه کم دي. د مثال په توګه: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې عددونو د ضربولو لپاره د دوې ضربولو لپاره د دوې ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د ضربو د \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"د s تار په پام کې نیولو سره ، په حتی شاخصونو کې د لوی حرفونو شمیر شمیرئ. د مثال په توګه: count_upper ((('aBCdEf') 1 count_upper ((('abcdefg') بیرته راګرځي 0 count_upper ((('dBBE') بیرته 0 \"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''د يو فنکشن جوړول چې د يو عدد (سترينګ) ارزښت اخلي او تر ټولو نږدې عدد يې بيرته راولي. که چېرې شمېر له دوو عددونو سره يو شان وي، نو له صفر څخه يې راټول کړئ. مثالونه >>> closest_integer (((\"10\") 10 >>> closest_integer ((\"15.3\") 15 يادونه: له صفر څخه راټولول په دې مانا چې که چېرې ورکړل شوې شمېر له دوو عددونو سره يو شان وي، نو هغه چې بايد بيرته راشي هغه شمېر دی چې تر ټولو لرې وي. د مثال په توګه closest_integer (((14.5\") بايد ۱۵ او closest_integer (((-14.5\") بايد ۱۵ بیرته راولي. '''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"د مثبت عدد n په پام کې نیولو سره، تاسو باید د n کچو ډبرو ډبرې جوړې کړئ. لومړۍ کچه د n ډبرو لري. په راتلونکې کچه کې د ډبرو شمیر دی: - راتلونکی عجیب شمیره که n عجیب وي. - راتلونکی حتی شمیره که n حتی وي. په هر کچه کې د ډبرو شمیر بیرته راګرځئ په لیست کې ، چیرې چې عنصر په شاخص کې i په کچه کې د ډبرو شمیر استازیتوب کوي (i + 1). مثالونه: >>> make_a_pile ((3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"تاسو ته به د کلمو یو تار ورکړل شي چې د کوما یا ځایونو لخوا جلا شوي وي. ستاسو دنده دا ده چې تار په کلمو وویشئ او د کلمو یو صف بیرته راګرځئ. د مثال په توګه: words_string ((\"سلام ، زما نوم جان دی\") == [\"سلام ،\" \"زما\" ، \"نوم ،\" \"ه ،\" جان\"] words_string ((\"یو ، دوه ، درې ، څلور ، پنځه ، شپږ\") == [\" یو ، \"دوه ،\" \"درې ،\" \"څلور ،\" پنځه ، \"شپږ\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"دا فنکشن دوه مثبت شمیرې x او y اخلي او تر ټولو لوی عدد چې په [x، y] کې دی بیرته راولي. که داسې شمیره شتون ونلري، نو فنکشن باید -1 بیرته راولي. د مثال په توګه: choose_num (((12, 15) = 14 choose_num (((13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"تاسو ته دوه مثبت عددونه n او m درکول شوي دي، او ستاسو دنده دا ده چې د n څخه تر m پورې د عددونو منځنۍ شمېره محاسبه کړئ (په شمول د n او m). ځواب ته نږدې بشپړ عدد ته راټول کړئ او دا دوه ګونی ته واړوئ. که n له m څخه لوی وي، بیرته راګرځئ -1. مثال: rounded_avg (((1, 5) => \"0b11\" rounded_avg (((7, 5) => -1 rounded_avg (((10, 20) => \"0b1111\" rounded_avg (((20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"د مثبتو عددونو لیست ورکړل شوی x. د ټولو عناصرو ترتیب شوی لیست بیرته راګرځوي چې حتی یو عدد هم نلري. یادونه: بیرته راستون شوی لیست باید په ډیریدونکي ترتیب ترتیب شي. د مثال په توګه: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"د بشپړ شمیرونو یو صف ورکړل شوی ، د 1 او 9 په شمول د بشپړ شمیرونو ترتیب کړئ ، پایله لرونکی صف بیرته واړوئ ، او بیا هر عدد د دې د ورته نوم سره ځای په ځای کړئ له \"یو\" ، \"دوه\" ، \"درې\" ، \"څلور\" ، \"پنځه\" ، \"شپږ\" ، \" اوه\" ، \"اویا\" ، \"نه\". د مثال په توګه: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> ترتیب arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> بیرته arr -> [8, 5, 4, 3, 2, 2, 1, 1] بیرته راستون کړئ [\" اته\" ، \"څلور\" ، \"درې\" ، \"دوه\" ، \"دوه\" ، \"یو\" ] که چیرې صف خالي وي ، بیرته راستون کړئ: arr = [] array [] که چیرې صف کوم عجیب شمیره ولري نو له پامه یې غورځوئ: arr = [1, 1 ، -1 ] -> arr 55 ، -> arr - 1 ، [1, 1 ، 55] -> reverse arr = [51] - return 'One' 1 ].\"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"د f دنده پلي کړئ چې n د پیرامیټر په توګه اخلي ، او د اندازې n لیست بیرته راولي ، نو د دې په څیر چې د شاخص i کې د عنصر ارزښت د i فاکتور دی که چیرې i حتی وي یا د 1 څخه تر i پورې د شمیرو مجموعه. i له 1 څخه پیل کیږي. د i فاکتور د 1 څخه تر i پورې د شمیرو ضرب دی (1 * 2 * ... * i) مثال: f (((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"د مثبت عدد n په پام کې نیولو سره، یو ټپل بیرته راګرځوئ چې د حتی او عجیب عدد پالینډرومونو شمیر لري چې په حد کې راځي ((۱، n) ، په شمول. مثال1: ان پټ: 3 محصول: (۱، ۲) توضیحي: د عدد پالینډرومونه دي، یو یې حتی دی، او دوه یې عجیب دي. مثال2: ان پټ: (۴، ۶) توضیحي: د عدد پالینډرومونه دي، ۱، ۲، ۳، ۴، ۵، ۶، ۷، ۸، ۹، ۱۱. څلور یې حتی دي، او ۶ یې عجیب دي. یادونه: ۱. <= n <= ۱۰^۳ 2. ټپل په ترتیب سره د حتی او عجیب عدد پالینډرومونو شمیر بیرته راوړی. \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"د count_nums فنکشن ولیکئ کوم چې د بشپړ شمیرونو صف اخلي او د عناصرو شمیر بیرته راولي چې د شمیرو مجموع لري > 0. که چیرې یو شمیر منفي وي ، نو د هغې لومړی لاسلیک شوی رقم به منفي وي: د مثال په توګه -123 د -1, 2 ، او 3 شمیرو لاسلیک کړی دی. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"موږ د N عددونو څخه جوړ array لرو arr[1], arr[2]، ..., arr[N].د array شمیرې به په تصادفي ډول ترتیب شي. ستاسو دنده دا ده چې معلومه کړئ چې آیا دا ممکنه ده چې array په غیر کمیدونکي ترتیب ترتیب کړئ په ورکړل شوي صف کې د لاندې عملیاتو ترسره کولو سره: تاسو ته اجازه درکول کیږي چې د ښي اړخ حرکت عملیات ترسره کړئ. یو ښی اړخ عملیات پدې معنی دي چې د صف ټول عناصر په یو موقعیت کې په سم لوري کې حرکت کوي. د صف وروستی عنصر به په صف کې د پیل موقعیت ته حرکت وکړي. د مثال په توګه 0th. که دا ممکنه وي چې د پورته عملیاتو ترسره کولو سره ترتیب شوي صف ترلاسه کړئ نو بیا ریښتیني بیرته راستون کړئ بل بیا غلط بیرته راستون کړئ. که ورکړل شوی صف خالي وي نو بیا ریښتیني بیرته راستون کړئ. یادونه: ورکړل شوی لیست تضمین شوی چې ځانګړي عناصر ولري. د مثال په توګه: move_one_(ball_[3, 4, 5, 2]===> ریښتینی توضیح: د 2_min_operations لخوا ، د غیر کمیدونکي ترتیب ترتیب ترتیب د صف لپاره ترلاسه کیدی شي. د ورکړل شوي صف د هر ډول ترتیب سره سم حرکت کول ممکن نه وي.\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"په دې ستونزه کې، تاسو به یو فنکشن پلي کړئ چې د شمیرو دوه لیستونه اخلي، او دا معلوموي چې آیا دا ممکنه ده چې د دوی ترمنځ د عناصرو تبادله ترسره کړي ترڅو lst1 یوازې د شمیرو لیست جوړ کړي. د lst1 او lst2 ترمنځ د تبادلې عناصرو شمیر محدود نه دی. که دا ممکنه وي چې د lst1 او lst2 ترمنځ عناصر بدل کړي ترڅو د lst1 ټول عناصر حتی وي، \"هو\" بیرته راګرځئ. که نه، \"نه\" بیرته راګرځئ. د مثال په توګه: تبادله [(1, 2, 3, 4], [1, 2, 3, 4]) => \"هو\" تبادله [(1, 2, 3, 4], [1, 5, 3, 4]) => \"نه\" دا فرض کیږي چې د ننوتلو لیستونه به خالي نه وي. \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"د يو تار په پام کې نيولو سره چې د يو ځای څخه جلا شوي کوچني حروف استازيتوب کوي، د هغه خط يو قاموس بيرته راولي چې تر ټولو زيات تکرار لري او د ورته شمېر په کې شامل وي. که څو حروف ورته پېښې ولري، ټول يې بيرته راولي. مثال: هسټوګرام ((('a b c') == {'a': 1, 'b': 1, 'c': 1} هسټوګرام ((('a b b a') == {'a': 2, 'b': 2} هسټوګرام ((('a b c a b') == {'a': 2, 'b': 2} هسټوګرام ((('b b a') == {'b 4}': هسټوګرام ((('') == {} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"دنده موږ ته دوه تارونه s او c ورکړل شوي دي، تاسو باید په s کې ټول هغه کرکټرونه حذف کړئ چې د c په کوم کرکټر سره مساوي وي بیا وګورئ چې ایا د پایله تار پالنډروم دی. یو تار پالنډروم بلل کیږي که چیرې دا د مخ په وړاندې ورته لوستل کیږي. تاسو باید د چک لپاره د پایلو تار او ریښتیني / غلطي لرونکی ټپل بیرته ورکړئ. د مثال په توګه د s = \"abcde\" ، c = \"ae\" لپاره ، پایله باید وي ('bcd' ، غلط) د s = \"abcdef\" ، c = \"b\" لپاره پایله باید وي ('acdef' ، غلط) د s = \"abcdedcba\" ، c = \"ab\" لپاره ، پایله باید وي ('cdedc' ، ریښتیني)\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"د تارونو لیست ورکړل شوی ، چیرې چې هر تار یوازې د شمیرو څخه جوړ شوی ، یو لیست بیرته راګرځوي. د محصول هر عنصر i باید \"د ننوتلو تار i کې د عجیب عناصرو شمیر وي\". چیرې چې ټول i باید د ننوتلو i'th تار کې د عجیب شمیرو شمیر سره ځای په ځای شي. >>> odd_count ((['1234567']) [\"د عجیب عناصرو شمیر 4n د 4n ان پټ str4ng 4\".] >>> odd_count ((['3'،\"111111\"]) [\"د عجیب عناصرو شمیر 1n د 1n ان پټ str1ng 1 ،\" \"د عجیب عناصرو شمیر 8n د 8n ان پټ str8ng 8\".] \"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"د عددونو د صفونو په ورکولو سره، د هرې عددونو د فرعي صفونو لږ تر لږه مجموعې ومومئ. مثال minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"تاسو ته د څاهونو مستطیل شبکه درکول کیږي. هر قطار یو واحد څاه استازیتوب کوي، او په یوه قطار کې هر 1 د اوبو واحد استازیتوب کوي. هر څاه یو مناسب بالټ لري چې له دې څخه د اوبو استخراج لپاره کارول کیدی شي، او ټول بالټونه ورته ظرفیت لري. ستاسو دنده د بالټونو څخه د څاهونو خالي کولو لپاره کارول دي. د هغه وخت شمیره وټاکئ چې تاسو ورته اړتیا لرئ د بالټونو ښکته کولو لپاره. مثال 1: ننوتل: شبکه: [[0,0,1,0] ، [0,1,0,0] ، [1,1,1,1]] bucket_capacity: 1 محصول: 6 مثال 2: ننوتل: شبکه: [[0,0,1,1] ، [0,0,0,0] ، [1,1,1] ، [0,1,1,1]] bucket_capacity: 2 محصول: 5 مثال 3: ننوتل: [[0,0,0]] ، [0,0,0]] bucket_capacity: 5 محصول: 0 * * * * * * * * * ټولې اوږدوالی: 1 * * * * * ټولې اوږدوالی: 1 * * * * * * * ټولې اوږدوالی: 10 * * * * * ټولې اوږدوالی: 1 * * ټولې * ټولې اوږدوالی: * ټولې * ټولې اوږدوالی * ټولې * ټولې * ټولې * ټولې * ټولې * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول * ټول\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"په دې کټا کې، تاسو باید د غیر منفي عددونو یو صف د دوی د دوه ګونی نمایندګۍ کې د یو شمیر په اساس ترتیب کړئ. د ورته شمیر لپاره، د لسیزې ارزښت پراساس ترتیب کړئ. دا باید په دې ډول پلي شي: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"د s او n د طبيعي شمېر په پام کې نيولو سره، تاسو ته دنده درکول شوې چې د s د تار څخه د ټولو کلمو لیست بیرته راولي چې په سمه توګه n غږونه لري، ترڅو دا کلمې په s تار کې راشي. که چیرې سټینګ خالي وي نو فنکشن باید خالي لیست بیرته راشي. یادونه: تاسو ممکن د ننوتلو تار یوازې لیکونه او ځایونه ولري. مثالونه: select_words (((\"مري یو کوچنی وری\"، 4) ==> [\"کوچنی\"] select_words (((\"مري یو کوچنی وری درلود\"، 3) ==> [\"مري\"، \"کوچنی\"] select_words\" ((ساده سپینه ځای\"، 2) ==> [] select_words (((\"سلام نړۍ\"، 4) ==> [\"نړۍ\"] select_words (((\"چا سم\"، 3) ==> [\"چا\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"تاسو ته یوه کلمه درکول کیږي. ستاسو دنده دا ده چې تر ټولو نږدې حرفي ومومئ چې د کلمې له ښي اړخ څخه د دوو حروفو تر منځ ولاړ وي (د قضیې حساس). په پیل او پای کې حرفي نه شمیرل کیږي. که تاسو کوم حرفي ونه موندل نو خالي تار بیرته راګرځئ چې پورته شرایط پوره کړي. تاسو کولی شئ فرض کړئ چې ورکړل شوې تار یوازې انګلیسي لیک لري. مثال: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''تاسو ته د دوو تارونو لیست درکول کیږي، دواړه تارونه یوازې د پرانیستې قوسونو '(' یا نږدې قوسونو ') ' څخه جوړ شوي دي. ستاسو دنده دا ده چې وګورئ چې ایا دا ممکنه ده چې دوه تارونه په یو ترتیب کې سره یوځای کړئ، چې پایله یې تار به ښه وي. یو تار S ښه ګڼل کیږي که چیرې او یوازې که په S کې ټول قوسونه متوازن وي. د مثال په توګه: تار '((())' ښه دی، پداسې حال کې چې تار '())' نه دی. 'هو' بیرته راګرځئ که چیرې د ښه تار جوړولو لپاره لاره شتون ولري، او 'نه' بیرته راګرځئ که نه. مثالونه: match_parens[('() '، ') ']) == 'هو' match_parens[(') '، ') ']) == 'نه' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"د ار ار او مثبت عدد k په لرلو سره، د آر آر په اوږدوالي کې د k شمیرې سره یو ترتیب شوی لیست بیرته راګرځوئ. مثال1: ان پټ: ار = [-3، -4، 5] ، k = 3 محصول: [-4، -3، 5] مثال2: ان پټ: ار = [4، -4، 4] ، k = 2 محصول: [4، 4] مثال3: ان پټ: ار = [-3، 2، 1، 2، 1، 2] ، k = 1 محصول: [2] یادونه: 1. د صف اوږدوالی به د [1، 1000] په حد کې وي. 2. د صف عناصر به د [-1000، 1000] په حد کې وي. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"د بشپړ شمیرونو غیر خالي لیست ورکړل شوی ، د ټولو عجیب عناصرو مجموعه بیرته راګرځئ چې په حتی موقعیتونو کې دي. د مثال حل (([5 ، 8 ، 7 ، 1]) ==> 12 حل (([3 ، 3 ، 3 ، 3 ، 3]) ==> 9 حل (([30 ، 13 ، 24 ، 321]) ==> 0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"د ار ار او k عددونو د يوې نه خالي صف په نظر کې نيولو سره، د ار ار د لومړيو k عناصرو څخه د دوه ګڼو څخه د زياتو عناصرو مجموعه راګرځوئ. مثال: ان پټ: arr = [111,21,3,4000,5,6,7,8,9], k = 4 محصول: 24 # د 21 + 3 مجموعې محدودیتونه: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"د مثبت عدد n په پام کې نیولو سره، یو ترتیب شوی لیست بیرته راولئ چې په کولاټز ترتیب کې عجیب شمیرې لري. د کولاټز قیاس په ریاضیاتو کې یو قیاس دی چې د لاندې په څیر تعریف شوي ترتیب پورې اړه لري: د هر مثبت عدد n سره پیل کړئ. بیا هر اصطلاح د مخکینۍ اصطلاح څخه په لاندې ډول ترلاسه کیږي: که مخکینۍ اصطلاح حتی وي ، نو راتلونکې اصطلاح د مخکینۍ اصطلاح یوه نیمه ده. که مخکینۍ اصطلاح عجیب وي ، نو راتلونکې اصطلاح د مخکینۍ اصطلاح 3 ځله اضافه ده. قیاس دا دی چې مهمه نده چې د n ارزښت څه وي ، ترتیب به تل 1 ته ورسیږي. یادونه: 1. کولټز (((1) [1] دی. 2. بیرته راستون شوی لیست په زیاتیدونکي ترتیب ترتیب ترتیب شوی. د مثال په توګه: get_odd_collatz ((5) بیرته راځي [1, 5] د 5 لپاره د کولاټز ترتیب [5, 8, 16, 4, 2, 1] دی ، نو عجیب شمیرې یوازې 1 او 5 دي. \"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"تاسو باید یو داسې فنکشن ولیکئ چې د نیټې د تار اعتبار تاییدوي او ریښتیا بیرته راستونوي که نیټه د اعتبار وړ وي که نه نو غلط. نیټه د اعتبار وړ ده که لاندې ټول قواعد پوره شي: 1. د نیټې تار خالي نه وي. 2. د ورځو شمیر د میاشتو لپاره 1 یا 31 ورځو څخه کم نه وي. او د ورځو شمیر د میاشتو لپاره 1 یا 30 ورځو څخه کم نه وي. او د میاشتو شمیر د میاشتې لپاره 1 یا 29 څخه کم نه وي. 3. میاشتې باید له 1 څخه کم نه وي یا له 12 څخه ډیر نه وي. 4. نیټه باید په فارمیټ کې وي: mm-dd-yyyy د مثال په توګه: valid_date ((('03-11-2000') => valid_date ((('15-01-2012') => false valid_date ((('04-02040') => false_date (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''د کلمو د تار په پام کې نیولو سره، د کلمو لیست بیرته راګرځوئ چې په سپین ځای کې ویشل شوي، که چیرې په متن کې هیڅ سپین ځای شتون ونلري نو تاسو باید په کوما کې ویشل شئ '، که چیرې کوما شتون ونلري نو تاسو باید په الفبا کې د غیر معمولي ترتیب سره د کوچني لیکونو شمیر بیرته راولیږئ، ord ((('a') = 0، ord (((b') = 1، ... ord ((('z') = 25 مثالونه ویشل_ کلمې ((\"سلام نړۍ!\") â -> [\"سلام، نړۍ!\"] split_ کلمې ((\"سلام، نړۍ!\") â -> [\"سلام، نړۍ!\"] split_ کلمې ((\"abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''د شمیرو لیست ورکړل شوی ، بیرته راګرځئ که چیرې دوی په پورته کیدو ترتیب کې ترتیب شوي وي. که لیست د ورته شمیر څخه ډیر 1 ډوپلیټ ولري ، غلط بیرته راګرځئ. هیڅ منفي شمیرې فرض نکړئ او یوازې بشپړ شمیرې. مثالونه is_sorted ((([5]) â -> ریښتیا is_sorted (([1, 2, 3, 4, 5]) â -> ریښتیا is_sorted (([1, 3, 2, 4, 5, 6]) â -> غلط is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> ریښتیا is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> ریښتیا is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> غلط is_sorted (([1, 2, 2, 3, 3, 4]) â -> ریښتیا is_sorted (([1, 2, 2, 2, 3, 4 -> غلط ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"تاسو ته دوه وقفه درکول کیږي، چې هره وقفه د عددونو جوړه ده. د مثال په توګه وقفه = (پیل، پای) = (1, 2). ورکړل شوې وقفه تړل شوې ده چې پدې معنی ده چې وقفه (پیل، پای) دواړه پیل او پای لري. د هرې ورکړل شوې وقفه لپاره، دا فرض کیږي چې د هغې پیل د هغې پای ته لږ یا مساوي دی. ستاسو دنده دا ده چې دا معلومه کړئ چې ایا د دې دوه وقفو د تقاطع اوږدوالی یو لومړنی شمیر دی. د مثال په توګه، د وقفو تقاطع (1, 3) ، (2، 4) (2، 3) دی چې د هغې اوږدوالی 1 دی، کوم چې لومړنی شمیر نه دی. که د تقاطع اوږدوالی لومړنی شمیر وي، \"هو\" بیرته راګرځئ، که نه، \"نه\" بیرته راګرځئ. که دوه وقفه سره نه ټکر کوي، \"نه\" بیرته راګرځئ. [input/output] نمونې: تقاطع ((((1، 2، 2، 3) ==> \"تقاطع ((1، 1) \") == ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"تاسو ته د بشپړ شمیرې صف ورکړل شوی او تاسو اړتیا لرئ د بشپړ شمیرې د اندازې مجموعه بیرته راوباسئ د صف کې د هرې شمیرې د ټولو نښو محصول سره ضرب کړئ ، چې د 1 ، -1 یا 0 لخوا استازیتوب کیږي. یادونه: بیرته راستنیدنه هیڅ نه د خالي ار لپاره. مثال: >>> prod_signs (([1 ، 2 ، 2 ، -4)) == -9 >>> prod_signs (([0 ، 1]) == 0 >>> prod_signs (([]) == هیڅ نه \"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"د N قطارونو او N کالمونو (N > = 2) سره د شبکې او مثبت بشپړ عدد k سره ، د شبکې هر حجره یو ارزښت لري. د [1، N * N] په حد کې هر عدد په شمول د شبکې په حجرو کې یوځل څرګندیږي. تاسو باید په شبکه کې د اوږدوالي k لږترلږه لاره ومومئ. تاسو کولی شئ له هرې حجرې څخه پیل وکړئ ، او په هر ګام کې تاسو کولی شئ کوم ګاونډیو حجرو ته لاړ شئ ، په بل عبارت ، تاسو کولی شئ هغه حجرو ته لاړ شئ چې ستاسو سره اوسني حجره لري. مهرباني وکړئ په یاد ولرئ چې د k اوږدوالي لاره پدې معنی ده چې دقیقا k حجرو ته مراجعه وکړئ (ضروري ندي جلا وي). تاسو نشئ کولی له شبکې څخه بهر لاړ شئ. د A (د اوږدوالي k) لاره د B (د اوږدوالي k) څخه لږ ګ consideredل کیږي که چیرې د A او B حجرو د ارزښتونو ترتیب شوي لیستونو جوړولو وروسته (دوی د lA او lA_st_st_B په نوم یادیږي) ، lA_st_B په لغوي ډول د l_st_B څخه لږترلږه لاره ده ، په بل عبارت ، په ګرد سیلونو کې د اوږدوالی k = 1 ، په بل عبارت ، د اوسني حجرو ته لاړتیا شاخص ته لاړ شئ. د نورو ټکو حجرو ته لاړ شئ ، په بل عبارتونو کې ، تاسو کولی شئ له کومې حجرو ته لاړ شئ. د اوسني حجرو ته لاړ شئ.\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"د فبوناکي سلسله هر څوک پېژني، په تېرو څو پېړيو کې د رياضي پوهانو له خوا په ژوره توګه مطالعه شوې ده. خو هغه څه چې خلک نه پوهېږي د ټربوناکي سلسله ده. د ټربوناکي سلسله د تکرار له مخې تعریف شوې ده: tri(1) = 3 tri(n) = 1 + n / 2، که n جوړه وي. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، که n عجیب وي. د بېلګې په توګه: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 تاسو ته یو غیر منفي عدد درکړل شوی دی، تاسو باید د ټربوناکي سلسله د لومړي n + 1 شمیرو لیست بیرته ورکړئ. مثالونه: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"د مثبت عدد n په پام کې نیولو سره، د غیر مساوي عددونو محصول بیرته راګرځوئ. 0 بیرته راګرځوئ که ټول عددونه حتی وي. د مثال په توګه: عددونه ((1) == 1 عدد ((4) == 0 عدد ((235) == 15 \"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''د فنکشن جوړول چې د ننوتلو په توګه د تار اخلي چې یوازې مربع قوسونه لري. د فنکشن باید ریښتیا بیرته راستانه شي که چیرې او یوازې که چیرې د قوسونو یو معتبر فرعي ترتیب شتون ولري چیرې چې لږترلږه په فرعي ترتیب کې یو قوس ځای په ځای شوی وي. is_nested (('[[]]') â -> ریښتیا is_nested (('[]]]]]]]]][[[[[[]]]]') â -> غلط is_nested (('[][]') â -> غلط is_nested (('[]') â -> غلط is_nested (('[]') â -> غلط is_nested (('[[]]') â -> ریښتیا is_nested (('[[]]') â -> ریښتیا'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"تاسو ته د شمېرو لیست درکول شوی دی. تاسو اړتیا لرئ چې په ورکړل شوي لیست کې د مربع شمېرو مجموعه بیرته راشئ ، لومړی په لیست کې د هر عنصر پورتنۍ انټ ته راټول کړئ. مثالونه: د lst = [1,2,3] لپاره محصول باید 14 وي د lst = [1,4,9] لپاره محصول باید 98 وي د lst = [1,3,5,7] لپاره محصول باید 84 وي د lst = [1.4,4.2,0] لپاره محصول باید 29 وي د lst = [-2.4,1,1] لپاره محصول باید 6 وي \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''د يو فنکشن جوړول چې ريښتيا راګرځي که د ورکړل شوي تار وروستی کرکټر د الفبا کرکټر وي او د يوې کلمې برخه نه وي، او که نه نو غلط. يادونه: \"کلمه\" د کرکټرونو ډله ده چې د ځای په واسطه جلا شوې ده. مثالونه: check_if_last_char_is_a_letter (((\"apple pie\") â -> False check_if_last_char_is_a_letter (((apple pi e\") â -> True check_if_last_char_is_a_letter (((apple pi e)) â -> False check_if_last_char_is_a_letter\" (((\") â -> False '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"د فنکشن جوړول چې د عنصر ترټولو لوی شاخص بیرته راولي چې د هغې څخه سمدستي مخکینی عنصر سره لوی یا مساوي نه وي. که داسې عنصر شتون ونلري نو بیرته راګرځئ -1. ورکړل شوی صف به دوه ګونی ارزښتونه ونه لري. مثالونه: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''د یو فنکشن جوړول چې یو ټپل (a، b) بیرته راولي، چیرې چې 'a' د منفي عددونو ترټولو لوی دی، او 'b' په لیست کې د مثبت عددونو ترټولو کوچنی دی. که منفي یا مثبت عددونه شتون ونلري، دوی یې بیرته راستانه کړئ هیڅ نه. مثالونه: لوی_کوچنۍ_کچیري عددونه[2, 4, 1, 3, 5, 7]) == (هیڅ نه، 1) لوی_کوچنۍ_کچیري عددونه (([]) == (هیڅ نه، هیڅ نه) لوی_کوچنۍ_کچیري عددونه (([0]) == (هیڅ نه، هیڅ نه) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"د يو داسې فنکشن جوړول چې د اصلي شمیرو، فلټونو، يا تارونو استازيتوب کوي او د ورکړل شوي متغیر په ډول لوی متغیر راولي. که ارزښتونه مساوي وي نو نهه راولي. يادونه: که يو اصلي شمېر د تار په توګه استازيتوب شي، نو د تعديل نقطه ښايي . يا ، compare_one ((1، 2.5) â -> 2.5 compare_one ((1، \"2,3\") â -> \"2,3\" compare_one ((\"5,1\"، \"6\") â -> \"6\" compare_one ((1\"، 1) â -> None \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"ارزونه وکړئ چې ایا ورکړل شوې شمیره n د 4 مثبتو حتی شمیرو مجموعې په توګه لیکل کیدی شي مثال is_equal_to_sum_even ((4) == غلط is_equal_to_sum_even ((6) == غلط is_equal_to_sum_even ((8) == ریښتینی \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"د برازیل فکتوریا په دې ډول تعریف شوی: برازیلی_فکتوریا ((n) = n! * (n-1)! * (n-2)! * ... * 1! چیرې چې n > 0 د مثال په توګه: >>> ځانګړی_فکتوریا ((4) 288 د فنکشن به د ننوتلو په توګه یو بشپړ شمیر ترلاسه کړي او باید د دې بشپړ شمیر ځانګړي فکتوریا بیرته راشي. \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_د مثال په توګه-3 په پام کې نیولو سره ، ټول ځایونه په کې د لاندې نښو سره ځای په ځای کړئ ، او که تار له 2 څخه ډیر پرله پسې ځایونه ولري ، نو ټول پرله پسې ځایونه یې په ځای کړئ - fix_spaces (((\"مثال\") == \"مثال\" fix_spaces (((\"مثال1\") == \"مثال1\" fix_spaces (((\"مثال2\") == \"_مثال_2\" fix_spaces (((\"مثال 3\") == \"_مثال-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"د دوتنې نوم د دوتنې نوم کې له دریو څخه زیاتې نښې نه وي. د دوتنې نوم باید په یو ټکی کې وي. د ټکي څخه مخکې فرعي تار باید خالي نه وي، او د لاتین الفا له لیک سره پیل شي. د ټکي وروسته فرعي تار باید له دې څخه یو وي: ['txt'، 'exe'، 'lld'] مثالونه: file_name_check\"(example.txt\") # => 'Yes'name_file_check\"(example.ll1\") # => 'نه' (د فایل نوم باید د لاتین الفا له لیک سره پیل شي)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" دا فنکشن به د بشپړ شمیرو لیست واخلي. د لیست د ټولو ننوتلو لپاره ، فنکشن باید د بشپړ شمیرو ننوتل مربع کړي که چیرې د دې شاخص د 3 ضرب وي او د بشپړ شمیرو ننوتل به مکعب کړي که چیرې د دې شاخص د 4 ضرب وي او نه د 3 ضرب. فنکشن به په لیست کې هغه ننوتل بدل نه کړي چې شاخصونه یې د 3 یا 4 ضرب نه وي. فنکشن باید بیا د ټولو ننوتلو مجموعه بیرته راولي. مثالونه: د lst = [1,2,3] لپاره محصول باید 6 وي د lst = [] لپاره محصول باید 0 وي د lst = [-1,-5,2,-1,-5] لپاره محصول باید -126 وي \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"تاسو ته د جملې استازیتوب کوونکی تار درکول کیږي، په جمله کې ځینې کلمې شتون لري چې د ځای سره جلا شوي دي، او تاسو باید یو تار بیرته راولیږئ چې د اصلي جملې څخه کلمې لري، چې اوږدوالی یې لومړني شمیرې دي، په نوې تار کې د کلمو ترتیب باید د اصلي په څیر ورته وي. مثال1: ننوتل: جمله = \"دا یوه ازموینه ده\" محصول: \"is\" مثال2: ننوتل: جمله = \"د لامبو لپاره ځي\" محصول: \"د\" لپاره ځي محدودیتونه: * 1 <= len(جملې) <= 100 * جمله یوازې لیکونه لري \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"ستاسو دنده دا ده چې د x * n افادې ساده کړئ. د دې فنکشن راستنیدنه ریښتیا ده که x * n بشپړ شمیر ته ارزښت ورکړي او که نه نو غلط. دواړه x او n ، د کسر تار استازیتوب دی ، او لاندې ب formatه لري ، <شمیرونکی> / <نومینټر> چیرې چې دواړه شمیرونکی او نومونکی مثبت بشپړ شمیرونه دي. تاسو کولی شئ فرض کړئ چې x ، او n معتبر کسرونه دي ، او د نومونکی په توګه صفر نلري. ساده کول (((\"1/5\" ، \"5/1\") = ریښتیا ساده کول (((\"1/6\" ، \"2/1\") = غلط ساده کول (((\"7/10\" ، \"10/2\") = غلط \"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"د بشپړ شمیرونو ورکړل شوی لیست د دوی د شمیرو د مجموعې سره سم په پورته کیدونکي ترتیب کې ترتیب کړئ. یادونه: که چیرې ډیری توکي شتون ولري چې د دوی د شمیرو ورته مجموعې سره ، دوی په اصلي لیست کې د دوی شاخص پراساس ترتیب کړئ. د مثال په توګه: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"د فنکشن لیکل چې د شمیرو صف د ان پټ په توګه اخلي او د صف د عناصرو شمیر بیرته راولي چې له 10 څخه لوی وي او د شمیر لومړۍ او وروستۍ دوه ګڼې یې عجیب دي (1, 3, 5, 7, 9). د مثال په توګه: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"تاسو ته یو مثبت عدد n درکول شوی دی. تاسو باید د اوږدوالي n یو عدد صف جوړ کړئ. د هر i (1 ‰¤ i ‰¤ n) لپاره ، د a[i] = i * i - i + 1 ارزښت. د a (a[i] ، a[j] ، a[k]) د درې ګونو شمیر بیرته راګرځئ چیرې چې i < j < k ، او a[i] + a[j] + a[k] د 3 ضرب دی. مثال: ننوتل: n = 5 محصول: 1 توضیح: a = [1, 3, 7, 13, 21] یوازینی معتبر درې ګونی دی (1, 7, 13). \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''زموږ په شمسي نظام کې اته سیارې شتون لري: لمر ته ترټولو نږدې سیارې عطارد دی ، بل یې زهره ده ، بیا ځمکه ، مریخ ، مشتری ، زحل ، یورانس ، نیپچون. یو فنکشن ولیکئ چې د سیارې نومونه د سیارې 1 او سیارې 2 په توګه اخلي. فنکشن باید یو ټپل بیرته راولي چې ټولې سیارې پکې شامل دي چې مدارونه یې د سیارې 1 مدار او د سیارې 2 مدار ترمینځ موقعیت لري ، د لمر سره نږدې والي له مخې ترتیب شوي. د فنکشن باید خالي ټپل بیرته راولي که چیرې سیارې 1 یا سیارې 2 د سیارې نومونه سم نه وي. مثالونه bf \"(جاپیر ،\" نیپچون \") ==> (\"زحل ،\" \"یورانس\") bf (((ځمکه ،\" عطارد \") ==> (\"زهره\") bf (((زهره ،\" اورانس)) ==> (\"زهره\"، \"ځمکه\"، \"مریخ\"، \"جاپیر\"، \"زحل\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"د يو فنکشن ليکل چې د تارونو يو لړلست د پارامتر په توګه ومني، هغه تارونه چې بې ځايه اوږدوالى لري له هغې څخه حذف کړي، او د يو ترتيب شوي ترتيب سره پايله لرونکی لړلست بيرته راولي، لړلست تل د تارونو يو لړلست دی او هيڅکله د شمیرو يو صف نه دی، او کېدای شي چې دوه ځلې ولري. د لړلست ترتيب بايد د هرې کلمې د اوږدوالي له مخې پورته شي، او تاسو بايد د دې قاعدې له مخې ترتيب شوی لړلست بيرته راولي. که دوه کلمې يو شان اوږدوالى ولري، نو لړلست په الفبايي ډول ترتیب کړئ. د فنکشن بايد د تارونو يو لړلست په ترتيب شوي ترتيب کې بيرته راولي. تاسو کولاى شئ فرض کړئ چې ټولې کلمې به يو شان اوږدوالى ولري. د بېلګې په توګه: assert list_sort[\"aa\"\"، \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\" => \"cdcd\" [\"ab\", \"cd\"]\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"یو ساده پروګرام چې باید د x ارزښت بیرته راولي که چیرې n یو لومړنی شمیر وي او باید د y ارزښت بیرته راولي که نه. مثالونه: د x_or_y ((7, 34, 12) == 34 د x_or_y ((15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''د شمیرو لیست ورکړل شوی ، په لیست کې د شمیرو مربعونو مجموعه بیرته راګرځئ کوم چې عجیب دي. هغه شمیرې له پامه غورځوئ چې منفي دي یا بشپړ نه دي. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference ((([0]) == 0 که چیرې د ننوتلو لیست خالي وي ، نو 0 بیرته راګرځئ '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"زه فکر کوم چې موږ ټول هغه احساس په یاد لرو کله چې د اوږدې مودې انتظار شوي پیښې پایله په پای کې پیژندل کیږي. هغه احساسات او افکار چې تاسو یې په هغه شیبه کې لرئ په حقیقت کې د یادولو او پرتله کولو ارزښت لري. ستاسو دنده دا ده چې معلومه کړئ چې ایا یو شخص د یو شمیر میچونو پایلې په سمه توګه اټکل کړې دي. تاسو ته د مساوي اوږدوالي دوه ارې د نمرو او اټکلونو ورکړل شوي دي ، چیرې چې هر شاخص یو میچ ښیې. د ورته اوږدوالي یو صف بیرته راګرځئ چې دا په ګوته کوي چې هر اټکل څومره لرې و. که دوی سم اټکل کړی وي ، ارزښت یې 0 دی ، او که نه ، ارزښت یې د اټکل او نمرې تر مینځ مطلق توپیر دی. مثال: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] ((([0,5,0,4],[0,4,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"تاسو ته به د يو ټولګي نوم (د يو تار) او د غزونې يو لړ ورکړل شي. غزونې دي چې د ټولګي د اضافي ټولګي د بارولو لپاره وکارول شي. د غزونې د قوت په لاندې ډول دی: پرېږدئ چې د CAP د غزونې په نوم کې د لویو تورو د شمېر وي، او پرېږدئ چې د SM د غزونې په نوم کې د کوچنيو تورو د شمېر وي، د قوت د وي د کسر CAP - SM. تاسو بايد د قوي غزونه پيدا او په دې بڼه يو تار بېرته: ClassName.StrongestExtensionName. که دوه يا زيات غزونه سره د همدې قوت، تاسو بايد هغه چې په لست کې لومړی راځي غوره کړي. د مثال په توګه، که تاسو ته د ټولګي او د غزونې يو لړ ورکړل شي: ['SEviviRNGLISCES'، 'Cheese'، 'StuF'] نو تاسو بايد 'SviRNGLISCES' بېرته ځکه چې د غزونې په نوم کې د لویو تورو د شمېر وي، او SM د غزونې په نوم کې د کوچنيو تورو تورو تورو د شمېر وي، د قوت د ده د CAP - SM. تاسو بايد د قوي غزونه تر ټولو قوي غزونه پيدا او په دې بڼه کې يو تار بېرته راستانه: ClassName.StrongExtensionName.StrongExtensionName.StrongExtensionName.StrongestExtensionName.StrongestExtensionName.StrongExtensionName.If دوه يا زيات غزونه دي، تاسو بايد د يو تار په دې بڼه کې د يو تار په توګه د يو تار په توګه د يو تار په توګه د يو تار په توګه د يو غزونه لري، چې د غزونه لري:\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"تاسو ته دوه کلمې درکول شوي دي. تاسو باید ریښتیني بیرته راستانه کړئ که چیرې دوهمه کلمه یا د هغې کومې گردش په لومړۍ کلمه کې فرعي تار وي cycpattern_check (((\"abcd\",\"abd\") => غلط cycpattern_check (((\"سلام\",\"ell\") => ریښتیني cycpattern_check (((\"whassup\",\"psus\") => غلط cycpattern_check (((\"abab\",\"baa\") => ریښتیني cycpattern_check (((\"efef\",\"eeff\") => غلط cycpattern_check (((hims\",\"simen\") => ریښتیني \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"د يوې بشپړ شمېرې په پام کې نيولو سره. يو ټپل چې په ترتیب سره د څو او څو ګوني عدد لري بيرته راولي. مثال: حتی_انډ_کاونټ ((-12) ==> (1, 1) حتی_انډ_کاونټ ((123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"د مثبت عدد په پام کې نیولو سره، د هغې رومن عدد مساوي د تار په توګه ترلاسه کړئ، او دا په کوچني لیک کې بیرته راګرځوئ. محدودیتونه: 1 <= num <= 1000 مثالونه: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''د مثلث د دریو اړخونو اوږدوالی ورکړل شوی. که درې اړخونه یو سم زاویه مثلث جوړ کړي ریښتینی بیرته راګرځئ ، که نه نو غلط. یو سم زاویه مثلث یو مثلث دی چې یو زاویه یې سم زاویه یا 90 درجې ده. مثال: right_angle_triangle ((3، 4، 5) == ریښتینی right_angle_triangle ((1، 2، 3) == غلط '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"یو داسې فنکشن ولیکئ چې د تارونو لیست ومني. لیست کې مختلف ټکي شامل دي. د ځانګړي کرکټرونو اعظمي شمیر سره کلمه بیرته راګرځوئ. که څو تارونه د ځانګړي کرکټرونو اعظمي شمیر ولري ، هغه یو بیرته راګرځوئ چې په لیکسيکوګرافیکي ترتیب کې لومړی راځي. find_max ((([\"نوم\"، \"د\"، \"ستر\"]) == \"ستر\" find_max (([\"نوم\"، \"enam\"، \"لوبې\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\" , \"cc\"]) == \"\"aaaaaaa\" \"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"تاسو یو وږی خرگوش یاست، او تاسو لا دمخه یو شمیر ګازرونه خوړلي دي، مګر اوس تاسو اړتیا لرئ چې د ورځې د خواړو بشپړولو لپاره نور ګازرونه وخورئ. تاسو باید یو صف بیرته راولیږئ [د خواړو وروسته د خوړل شوي ګازرو شمیر، ستاسو د خواړو وروسته پاتې ګازرو شمیر ] که چیرې کافي پاتې ګازرونه شتون ونلري، تاسو به ټول پاتې ګازرونه وخورئ، مګر لاهم به وږی وي. مثال: * وخورئ (((5, 6, 10) -> [11, 4] * وخورئ (((4, 8, 9) -> [12, 1] * وخورئ (((1, 10, 10) -> [11, 0] * وخورئ (((2, 11, 5) -> [7, 0] متغیرونه: @ شمیره: د ګازرو شمیر چې تاسو یې خوړئ. @ اړتیا: د ګازرو شمیر چې تاسو یې باید وخورئ. @ پاتې: د ګازرو شمیر چې په ذخیره کې پاتې دي: * شمیره: <= 0 * <= 1000 * <= 1000 * پاتې: <= 1000 <= 1000 <= 1000 = تفریح وکړئ  = = 1000 :)\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"د دوه لیستونو عملیاتو او عملیاتو په پام کې نیولو سره. لومړی لیست د الجبرا اساسي عملیات لري، او دوهم لیست د بشپړ شمیر لیست دی. د الجبری بیان جوړولو لپاره دوه ورکړل شوي لیستونه وکاروئ او د دې بیان ارزونه بیرته ورکړئ. د الجبرا اساسي عملیات: اضافه کول (+) تخفیف ( - ) ضرب ( * ) د فرش ویش ( // ) اعظمي کول ( ** مثال): عملیاتي ['+'، '*'، '-'] صف = [2, 3, 4, 5] پایله = 2 + 3 * 4 - 5 => پایله = 9 یادونه: د عملیاتي لیست اوږدوالی د عملیاتي لیست اوږدوالي سره مساوي دی. عملیاتي د غیر منفي بشپړ شمیرونو لیست دی. عملیاتي لږترلږه یو عملیاتي لیست لري، او عملیاتي لیست لږترلږه دوه عملیاتي لري. \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"تاسو ته يو تار s درکول شوی دی. که s[i] يو حرف وي، د هغې قضیې له ښکته څخه پورته ته او يا برعکس ته واړوي، که نه نو دا په خپل حال کې وساتئ. که چېرې تار کې کوم حرفونه نه وي، نو تار بېرته واړوي. د فنکشن بايد د پايلې تار بېرته راولي. مثالونه حل (((\"1234\") = \"4321\" حل (((\"ab\") = \"AB\" حل (((\"#a@C\") = \"#A@c\" \"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"د 'text' تار په پام کې نیولو سره، د دې md5 هش مساوي تار بیرته راګرځئ. که 'text' خالي تار وي، نو هیڅ نه بیرته راګرځئ. >>> string_to_md5 ((('سلام نړۍ') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "pbt_Arab",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"د دوه مثبتو بشپړ شمیرونو a او b په پام کې نیولو سره ، د a او b تر مینځ حتی ارقام بیرته راګرځئ ، په پورته کیدونکي ترتیب کې. د مثال په توګه: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]