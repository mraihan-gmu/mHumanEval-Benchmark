[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kontrolloni n\u00ebse n\u00eb list\u00ebn e numrave t\u00eb dh\u00ebn\u00eb, jan\u00eb ndonj\u00eb dy numra m\u00eb af\u00ebr nj\u00ebri-tjetrit se pragu i dh\u00ebn\u00eb.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input p\u00ebr k\u00ebt\u00eb funksion \u00ebsht\u00eb nj\u00eb varg q\u00eb p\u00ebrmban grupe t\u00eb shumta t\u00eb parentesh\u00ebve t\u00eb mb\u00ebshtjell\u00eb. Q\u00ebllimi juaj \u00ebsht\u00eb t\u00eb ndaj\u00eb ato grupe n\u00eb vargje t\u00eb ve\u00e7anta dhe t\u00eb kthej\u00eb list\u00ebn e atyre. Grupet e ve\u00e7anta jan\u00eb t\u00eb balancuara (\u00e7do kurriz i hapur \u00ebsht\u00eb i mbyllur si\u00e7 duhet) dhe nuk jan\u00eb t\u00eb mb\u00ebshtjell\u00eb brenda nj\u00ebri-tjetrit. Injoroni \u00e7do hap\u00ebsir\u00eb n\u00eb varg t\u00eb hyrjes. Shembull:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Duke pasur parasysh nj\u00eb num\u00ebr pozitiv me pik\u00eb lundruese, ai mund t\u00eb dekompozohet n\u00eb nj\u00eb pjes\u00eb t\u00eb t\u00ebr\u00eb (numri m\u00eb i madh i plot\u00eb m\u00eb i vog\u00ebl se numri i dh\u00ebn\u00eb) dhe n\u00eb decimal\u00eb (pjesa e mbetur gjithmon\u00eb m\u00eb e vog\u00ebl se 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ju jepet nj\u00eb list\u00eb e operacioneve t\u00eb depozitimit dhe t\u00ebrheqjes n\u00eb nj\u00eb llogari bankare q\u00eb fillon me bilanc zero. Detyra juaj \u00ebsht\u00eb t\u00eb zbuloni n\u00ebse n\u00eb ndonj\u00eb pik\u00eb bilanci i llogaris\u00eb bie n\u00ebn zero, dhe n\u00eb at\u00eb pik\u00eb funksioni duhet t\u00eb kthej\u00eb True. P\u00ebrndryshe duhet t\u00eb kthej\u00eb False. Shembull:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" P\u00ebr nj\u00eb list\u00eb t\u00eb dh\u00ebn\u00eb t\u00eb numrave t\u00eb hyrjes, llogaritet devijimi absolut mesatar rreth mesatares s\u00eb k\u00ebtij grupi t\u00eb t\u00eb dh\u00ebnave. Deviimi absolut mesatar \u00ebsht\u00eb diferenca mesatare absolute midis secilit element dhe nj\u00eb pike qendrore (mesatare n\u00eb k\u00ebt\u00eb rast): MAD = mesatarja. x - x_mesatare. Shembull:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Shkruani nj\u00eb num\u00ebr \"delimitor\" midis \u00e7do dy elementeve t\u00eb nj\u00ebpasnj\u00ebshme t\u00eb list\u00ebs s\u00eb input-ut \u2200numera\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input n\u00eb k\u00ebt\u00eb funksion \u00ebsht\u00eb nj\u00eb varg p\u00ebrfaq\u00ebsuar grupe t\u00eb shumta p\u00ebr paranteza t\u00eb mb\u00ebshtjellura t\u00eb ndara nga hap\u00ebsira. P\u00ebr secilin grup, prodhojeni nivelin m\u00eb t\u00eb thell\u00eb t\u00eb mb\u00ebshtjelljes s\u00eb parantezave. P\u00ebr shembull (() (()) ka maksimum dy nivele t\u00eb mb\u00ebshtjelljes nd\u00ebrsa ((())) ka tre.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filtrohet nj\u00eb list\u00eb e hyrjes s\u00eb vargjeve vet\u00ebm p\u00ebr ato q\u00eb p\u00ebrmbajn\u00eb varg t\u00eb caktuar\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" P\u00ebr nj\u00eb list\u00eb t\u00eb dh\u00ebn\u00eb t\u00eb integers, kthehet nj\u00eb tuple q\u00eb p\u00ebrb\u00ebhet nga nj\u00eb shuma dhe nj\u00eb produkt i t\u00eb gjith\u00eb integers n\u00eb nj\u00eb list\u00eb. shuma bosh duhet t\u00eb jet\u00eb e barabart\u00eb me 0 dhe produkti bosh duhet t\u00eb jet\u00eb e barabart\u00eb me 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Nga nj\u00eb list\u00eb e dh\u00ebn\u00eb e integers, gjeneroj\u00eb nj\u00eb list\u00eb t\u00eb elementit maksimal rrotullues gjetur deri n\u00eb momentin e dh\u00ebn\u00eb n\u00eb sekuenc\u00eb.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Testi n\u00ebse nj\u00eb varg i dh\u00ebn\u00eb \u00ebsht\u00eb palindrom \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input jan\u00eb dy vargjet a dhe b q\u00eb p\u00ebrb\u00ebhen vet\u00ebm nga 1s dhe 0s. Perform binary XOR n\u00eb k\u00ebto input dhe kthimi rezultat gjithashtu si nj\u00eb varg.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Nga lista e vargjeve, kthehet m\u00eb i gjati. Kthehet i pari n\u00eb rast se ka vargje t\u00eb shumta me t\u00eb nj\u00ebjt\u00ebn gjat\u00ebsi. Kthehet Asnj\u00eb n\u00eb rast se lista e hyrjes \u00ebsht\u00eb bosh.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Kthehet nj\u00eb ndar\u00ebsi m\u00eb i madh i p\u00ebrbashk\u00ebt i dy integers a dhe b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Lista e kthimit t\u00eb t\u00eb gjitha prefikseve nga m\u00eb e shkurta n\u00eb m\u00eb t\u00eb gjata t\u00eb vargjet e hyrjes\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Kthehet nj\u00eb varg q\u00eb p\u00ebrmban numra t\u00eb kufizuar me hap\u00ebsir\u00eb duke filluar nga 0 deri n p\u00ebrfshir\u00eb.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Duke pasur parasysh nj\u00eb varg, t\u00eb gjeni se sa karaktere t\u00eb ndryshme (pa marr\u00eb parasysh rastin) \u00ebsht\u00eb p\u00ebrb\u00ebr\u00eb nga\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input n\u00eb k\u00ebt\u00eb funksion \u00ebsht\u00eb nj\u00eb varg q\u00eb p\u00ebrfaq\u00ebson notat muzikore n\u00eb nj\u00eb format t\u00eb ve\u00e7ant\u00eb ASCII. Detyra juaj \u00ebsht\u00eb p\u00ebr t\u00eb analizuar k\u00ebt\u00eb varg dhe kthimin list\u00eb e integers korresponduese sa goditje nuk zgjat secili. K\u00ebtu \u00ebsht\u00eb nj\u00eb legjend\u00eb: 'o' - nota t\u00eb t\u00ebr\u00eb, zgjat kat\u00ebr goditje 'o\" - gjysm\u00eb not\u00eb, zgjat dy goditje '. \" - quater not\u00eb, zgjat nj\u00eb goditje\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Gjeni sa her\u00eb nj\u00eb n\u00ebnstring i dh\u00ebn\u00eb mund t\u00eb gjendet n\u00eb varg origjinal. Num\u00ebro rastet e mbivendosura.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input \u00ebsht\u00eb nj\u00eb varg i numrave t\u00eb kufizuar nga hap\u00ebsira nga 'zero' deri n\u00eb 'n\u00ebnt\u00eb'. Zgjedhjet e vlefshme jan\u00eb 'zero', 'nj\u00eb', 'dy', 'tre', 'kat\u00ebr', 'pes\u00eb', 'gjasht\u00eb', 'gjasht\u00eb', 'gjasht\u00eb', 'gjasht\u00eb' dhe 'n\u00ebnt\u00eb'. Kthehet vargu me numra t\u00eb renditur nga m\u00eb i vog\u00ebl n\u00eb m\u00eb i madh\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Nga nj\u00eb list\u00eb e numrave (t\u00eb pakt\u00ebn dy) zgjidhni dhe ktheni dy q\u00eb jan\u00eb m\u00eb af\u00ebr nj\u00ebri-tjetrit dhe ktheni ato n\u00eb rend (numri m\u00eb i vog\u00ebl, numri m\u00eb i madh).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Duke pasur parasysh list\u00ebn e numrave (t\u00eb pakt\u00ebn dy elementeve), aplikoni nj\u00eb transformim linear n\u00eb at\u00eb list\u00eb, n\u00eb m\u00ebnyr\u00eb q\u00eb numri m\u00eb i vog\u00ebl t\u00eb b\u00ebhet 0 dhe numri m\u00eb i madh t\u00eb b\u00ebhet 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filtrohet lista e dh\u00ebn\u00eb e \u00e7do vlere python vet\u00ebm p\u00ebr numrat e plot\u00eb\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Gjat\u00ebsia e kthimit t\u00eb nj\u00eb vargu t\u00eb dh\u00ebn\u00eb\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" P\u00ebr nj\u00eb num\u00ebr t\u00eb dh\u00ebn\u00eb n, gjeni numrin m\u00eb t\u00eb madh q\u00eb ndan n n\u00eb m\u00ebnyr\u00eb t\u00eb barabart\u00eb, m\u00eb t\u00eb vog\u00ebl se n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Kthehet lista e faktor\u00ebve par\u00ebsor t\u00eb nj\u00eb numri t\u00eb caktuar t\u00eb plot\u00eb n\u00eb rend nga m\u00eb i vog\u00ebl n\u00eb m\u00eb t\u00eb madh. Secili nga faktor\u00ebt duhet t\u00eb listohet numri i her\u00ebve q\u00eb korrespondon me sa her\u00eb shfaqet n\u00eb faktorizim. Numri i hyrjes duhet t\u00eb jet\u00eb i barabart\u00eb me prodhimin e t\u00eb gjith\u00eb faktor\u00ebve\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Nga nj\u00eb list\u00eb e integers, hiqni t\u00eb gjitha element\u00ebt q\u00eb ndodhin m\u00eb shum\u00eb se nj\u00eb her\u00eb. Mbani rendin e elementeve t\u00eb majta t\u00eb nj\u00ebjt\u00eb si n\u00eb hyrje.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" P\u00ebr nj\u00eb varg t\u00eb caktuar, kthe karakteret e vogla n\u00eb t\u00eb m\u00ebdha dhe t\u00eb m\u00ebdha n\u00eb t\u00eb vogla.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Konkatenate list\u00ebn e vargjeve n\u00eb nj\u00eb varg t\u00eb vet\u00ebm\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filtro nj\u00eb list\u00eb t\u00eb hyrjes s\u00eb vargjeve vet\u00ebm p\u00ebr ato q\u00eb fillojn\u00eb me nj\u00eb prefiks t\u00eb caktuar.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Kthehet vet\u00ebm numri pozitiv n\u00eb list\u00eb.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Kthehet e v\u00ebrtet\u00eb n\u00ebse nj\u00eb num\u00ebr i dh\u00ebn\u00eb \u00ebsht\u00eb prim, dhe e rreme ndryshe.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Vler\u00ebson polinom me koeficient\u00eb xs n\u00eb pik\u00ebn x. kthim xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Ky funksion merr nj\u00eb list\u00eb l dhe kthen nj\u00eb list\u00eb l 't\u00eb till\u00eb q\u00eb l' \u00ebsht\u00eb identike me l n\u00eb indekset q\u00eb nuk jan\u00eb t\u00eb ndashme me tre, nd\u00ebrsa vlerat e saj n\u00eb indekset q\u00eb jan\u00eb t\u00eb ndashme me tre jan\u00eb t\u00eb barabarta me vlerat e indekset p\u00ebrkat\u00ebse t\u00eb l, por t\u00eb renditura.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Kthehet elementet e renditura unike n\u00eb nj\u00eb list\u00eb\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Kthen elementin maksimal n\u00eb list\u00eb.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Kthehet numri i rasteve q\u00eb shifra 7 shfaqet n\u00eb numra t\u00eb plot\u00eb m\u00eb t\u00eb vegj\u00ebl se n q\u00eb jan\u00eb t\u00eb ndar\u00eb me 11 ose 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Ky funksion merr nj\u00eb list\u00eb l dhe kthen nj\u00eb list\u00eb l 'k\u00ebshtu q\u00eb l' \u00ebsht\u00eb identike me l n\u00eb indekset e \u00e7uditshme, nd\u00ebrsa vlerat e saj n\u00eb indekset e \u00e7uditshme jan\u00eb t\u00eb barabarta me vlerat e indekseve t\u00eb \u00e7uditshme t\u00eb l, por t\u00eb renditura.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    kthen nj\u00eb varg t\u00eb koduar nga grupe ciklike prej tre karaktereve.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib kthen numrin n-t\u00eb q\u00eb \u00ebsht\u00eb nj\u00eb num\u00ebr Fibonacci dhe \u00ebsht\u00eb gjithashtu num\u00ebr i par\u00eb.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero merr nj\u00eb list\u00eb t\u00eb integers si nj\u00eb input. Ai kthen True n\u00ebse ka tre elemente t\u00eb dallueshme n\u00eb list\u00eb q\u00eb shuma n\u00eb zero, dhe False p\u00ebrndryshe.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagjinoni nj\u00eb rrug\u00eb q\u00eb \u00ebsht\u00eb nj\u00eb vij\u00eb e gjat\u00eb pafund\u00ebsisht e drejt\u00eb. n makina po ecin majtas-djathtas; nj\u00ebkoh\u00ebsisht, nj\u00eb grup i ndrysh\u00ebm i n makinave po ecin nga e djathta-manga. Dy grupet e makinave fillojn\u00eb duke qen\u00eb shum\u00eb larg nj\u00ebri-tjetrit. T\u00eb gjitha makinat l\u00ebvizin me t\u00eb nj\u00ebjt\u00ebn shpejt\u00ebsi. Dy makina thuhet se p\u00ebrplasen kur nj\u00eb makin\u00eb q\u00eb l\u00ebviz nga e majta-djathtas godet nj\u00eb makin\u00eb q\u00eb l\u00ebviz nga e djathta-manga. Sidoqoft\u00eb, makinat jan\u00eb pafund\u00ebsisht t\u00eb q\u00ebndrueshme dhe t\u00eb forta; si rezultat, ato vazhdojn\u00eb t\u00eb l\u00ebvizin n\u00eb trajektoren e tyre sikur t\u00eb mos p\u00ebrplasen. Kjo funksion prodhon numrin e p\u00ebrplasjeve t\u00eb tilla.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Lista e kthimit me element\u00eb t\u00eb shtuar me 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero merr nj\u00eb list\u00eb t\u00eb integers si nj\u00eb input. Ai kthen True n\u00ebse ka dy elemente t\u00eb dallueshme n\u00eb list\u00eb q\u00eb shuma n\u00eb zero, dhe False p\u00ebrndryshe.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Ndryshoni baz\u00ebn num\u00ebrore t\u00eb numrit t\u00eb hyrjes x n\u00eb baz\u00eb. ktheni p\u00ebrfaq\u00ebsimin e vargut pas konvertimit. numrat e baz\u00ebs jan\u00eb m\u00eb pak se 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Duke pasur parasysh gjat\u00ebsin\u00eb e nj\u00eb an\u00ebs dhe zon\u00ebn e kthimit t\u00eb lart\u00eb p\u00ebr nj\u00eb trek\u00ebnd\u00ebsh.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Rresht\u00ebsia e numrave Fib4 \u00ebsht\u00eb nj\u00eb rresht\u00ebsi e ngjashme me rresht\u00ebsin\u00eb e Fibbona\u00e7it q\u00eb \u00ebsht\u00eb e p\u00ebrcaktuar si m\u00eb posht\u00eb: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Ju lutemi shkruani nj\u00eb funksion p\u00ebr t\u00eb llogaritur n\u00eb m\u00ebnyr\u00eb efikase elementin e n-t\u00eb t\u00eb rresht\u00ebsis\u00eb s\u00eb numrave fib4. Mos p\u00ebrdorni rikursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Kthimi i median\u00ebs s\u00eb elementeve n\u00eb list\u00ebn l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Kontrollohet n\u00ebse nj\u00eb varg i dh\u00ebn\u00eb \u00ebsht\u00eb palindrom\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Kthehet 2^n modulo p (t\u00eb jesh i vet\u00ebdijsh\u00ebm p\u00ebr numrat).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    kthen kodimin e nj\u00eb vargu duke zhvendosur \u00e7do karakter me 5 n\u00eb alfabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels \u00ebsht\u00eb nj\u00eb funksion q\u00eb merr string dhe kthen string pa vokal.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Kthehet True n\u00ebse t\u00eb gjitha numrat n\u00eb list\u00ebn l jan\u00eb n\u00ebn pragun t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Shtoj dy numra x dhe y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Kontrolloni n\u00ebse dy fjal\u00eb kan\u00eb karaktere t\u00eb nj\u00ebjta.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Kthehet numri i n-t\u00eb i Fibona\u00e7it.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" kurtet \u00ebsht\u00eb nj\u00eb varg i \"<\" dhe \">\". return True n\u00ebse \u00e7do kurt\u00eb hap\u00ebse ka nj\u00eb kurt\u00eb mbyll\u00ebse korresponduese.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True \u00ebsht\u00eb lista e elementeve q\u00eb rriten ose zvog\u00eblohen monotonisht.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Kthehet element i renditur unik i p\u00ebrbashk\u00ebt p\u00ebr dy lista.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Kthehet faktori kryesor m\u00eb i madh i n. Merr n > 1 dhe nuk \u00ebsht\u00eb nj\u00eb num\u00ebr i par\u00eb.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n \u00ebsht\u00eb nj\u00eb funksion q\u00eb shton numrat nga 1 deri n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" kurtet \u00ebsht\u00eb nj\u00eb varg i \"(\" dhe \"\". kthehet True n\u00ebse \u00e7do kurt\u00eb hapjeje ka nj\u00eb kurt\u00eb mbylljeje p\u00ebrkat\u00ebse.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs p\u00ebrfaq\u00ebsojn\u00eb koeficient\u00ebt e nj\u00eb polinomi. xs[0] + xs[1] * x + xs[2] * x^2 +.... Kthe derivati i k\u00ebtij polinomi n\u00eb t\u00eb nj\u00ebjt\u00ebn form\u00eb.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"Rresht\u00ebsia e numrave FibFib \u00ebsht\u00eb nj\u00eb rresht\u00ebsi e ngjashme me rresht\u00ebsin\u00eb e Fibbona\u00e7it q\u00eb \u00ebsht\u00eb e p\u00ebrcaktuar si m\u00eb posht\u00eb: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fib ((n-1) + fib ((n-2) + fib ((n-3). Ju lutemi shkruani nj\u00eb funksion p\u00ebr t\u00eb llogaritur n\u00eb m\u00ebnyr\u00eb efikase elementin e n-t\u00eb t\u00eb rresht\u00ebsis\u00eb s\u00eb numrave fibfib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nShto m\u00eb shum\u00eb raste testimi.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Rrethohet rrethikisht shifrat e numrit t\u00eb plot\u00eb x, l\u00ebvizni shifrat drejt me zhvendosje dhe ktheni rezultatin si nj\u00eb varg. N\u00ebse zhvendosja > numri i shifrave, ktheni shifrat e kund\u00ebrta.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Task Shkrimi i nj\u00eb funksioni q\u00eb merr nj\u00eb varg si input dhe kthen shum\u00ebn e karaktereve t\u00eb sip\u00ebrme vet\u00ebm 'kodet ASCII. Shembuj: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    N\u00eb k\u00ebt\u00eb detyr\u00eb, ju do t\u00eb jepet nj\u00eb varg q\u00eb p\u00ebrfaq\u00ebson nj\u00eb num\u00ebr t\u00eb moll\u00ebve dhe portokall\u00ebve q\u00eb jan\u00eb shp\u00ebrndar\u00eb n\u00eb nj\u00eb shport\u00eb me fruta ky shport\u00eb p\u00ebrmban moll\u00eb, portokall dhe fruta mango. Duke pasur parasysh varg q\u00eb p\u00ebrfaq\u00ebson numrin e p\u00ebrgjithsh\u00ebm t\u00eb portokall\u00ebve dhe moll\u00ebve dhe nj\u00eb num\u00ebr i plot\u00eb q\u00eb p\u00ebrfaq\u00ebson numrin e p\u00ebrgjithsh\u00ebm t\u00eb frutave n\u00eb shport\u00eb kthehet numri i frutave mango n\u00eb shport\u00eb. p\u00ebr shembull: fruit_distribution\"5( moll\u00eb dhe 6 portokall\", 19) -> 19 - 5 - 6 = 8 fruta_shp\u00ebrndarje\"0 moll\u00eb dhe 1 portokall\",3) -> 3 - 0 - 1 = 2 fruta_shp\u00ebrndarje\"2 moll\u00eb dhe 3 portokall\", 100) -> 100 - 2 - 3 = 95 fruta_shp\u00ebrndarje\"100 moll\u00eb dhe 1 portokall\") \",\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Duke pasur parasysh nj\u00eb rend q\u00eb p\u00ebrfaq\u00ebson nj\u00eb deg\u00eb t\u00eb nj\u00eb peme q\u00eb ka nyje t\u00eb entjerave jo-negative, detyra juaj \u00ebsht\u00eb t\u00eb zgjidhni nj\u00eb nga nyjet dhe ta ktheni at\u00eb. Nyja e zgjedhur duhet t\u00eb jet\u00eb nyja me vler\u00ebn m\u00eb t\u00eb vog\u00ebl t\u00eb \u00e7iftit. N\u00ebse gjenden shum\u00eb nyje me t\u00eb nj\u00ebjt\u00ebn vler\u00eb m\u00eb t\u00eb vog\u00ebl t\u00eb \u00e7iftit, kthejeni nyjen q\u00eb ka indeksin m\u00eb t\u00eb vog\u00ebl. Nyja e zgjedhur duhet t\u00eb kthehet n\u00eb nj\u00eb list\u00eb, [smallest_value, indeksin e saj], N\u00ebse nuk ka vlera t\u00eb \u00e7iftit ose rendja e dh\u00ebn\u00eb \u00ebsht\u00eb bosh, kthejeni []. Shembull 1: hyrje: [4,2,3] Dalje: [2, 1] Shpjegim: 2 ka vler\u00ebn m\u00eb t\u00eb vog\u00ebl t\u00eb \u00e7iftit dhe 2 ka indeksin m\u00eb t\u00eb vog\u00ebl. Shembull 2: hyrje: [1,2,3] Dalje: [2, 1\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb mas\u00eb arr e numrave t\u00eb plot\u00eb, gjeni numrin minimal t\u00eb elementeve q\u00eb duhet t\u00eb ndryshohen p\u00ebr ta b\u00ebr\u00eb mas\u00ebn palindromike. Nj\u00eb mas\u00eb palindromike \u00ebsht\u00eb nj\u00eb mas\u00eb q\u00eb lexohet nj\u00ebsoj prapa dhe p\u00ebrpara. N\u00eb nj\u00eb ndryshim, ju mund t\u00eb ndryshoni nj\u00eb element n\u00eb \u00e7do element tjet\u00ebr. P\u00ebr shembull: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Shkruaj nj\u00eb funksion q\u00eb kthehet i v\u00ebrtet\u00eb n\u00ebse numri i dh\u00ebn\u00eb \u00ebsht\u00eb shum\u00ebzimi i 3 numrave t\u00eb par\u00eb dhe i rrem\u00eb n\u00eb rastin tjet\u00ebr. Duke ditur se (a) \u00ebsht\u00eb m\u00eb pak se 100. Shembull: is_multiply_prime(30) == i v\u00ebrtet\u00eb 30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Detyra juaj \u00ebsht\u00eb t\u00eb shkruani nj\u00eb funksion q\u00eb kthehet i v\u00ebrtet\u00eb n\u00ebse nj\u00eb num\u00ebr x \u00ebsht\u00eb nj\u00eb fuqi e thjesht\u00eb e n dhe i rrem\u00eb n\u00eb raste t\u00eb tjera. x \u00ebsht\u00eb nj\u00eb fuqi e thjesht\u00eb e n n\u00ebse n**int=x P\u00ebr shembull: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Ju keni qen\u00eb t\u00eb ngarkuar p\u00ebr t\u00eb shkruar nj\u00eb funksion q\u00eb merr nj\u00eb num\u00ebr heksaxadecimal si nj\u00eb varg dhe num\u00ebron numrin e shifrave heksaxadecimale q\u00eb jan\u00eb prim\u00eb (numri i par\u00eb, ose nj\u00eb num\u00ebr i par\u00eb, \u00ebsht\u00eb nj\u00eb num\u00ebr natyror m\u00eb i madh se 1 q\u00eb nuk \u00ebsht\u00eb nj\u00eb produkt i dy numrave natyror m\u00eb t\u00eb vegj\u00ebl). Shifrat heksaxadecimale jan\u00eb 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Numrat e par\u00eb jan\u00eb 2, 3, 5, 7, 11, 13, 17,... K\u00ebshtu q\u00eb ju duhet t\u00eb p\u00ebrcaktoni nj\u00eb num\u00ebr t\u00eb shifrave t\u00eb m\u00ebposhtme: 2, 3, 5, 7, B (=dekimal 11), D (=dekimal 13). Sh\u00ebnim: ju mund t\u00eb supozojm\u00eb se hyrja \u00ebsht\u00eb gjithmon\u00eb e sakt\u00eb ose bosh, dhe simbolet A,B,C,D,E,F jan\u00eb gjithmon\u00eb\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Do t'ju jepet nj\u00eb num\u00ebr n\u00eb form\u00ebn dhjetore dhe detyra juaj \u00ebsht\u00eb ta konvertoni at\u00eb n\u00eb format binar. Funksioni duhet t\u00eb kthej\u00eb nj\u00eb varg, me secilin karakter q\u00eb p\u00ebrfaq\u00ebson nj\u00eb num\u00ebr binar. \u00c7do karakter n\u00eb varg do t\u00eb jet\u00eb '0' ose '1'. Do t\u00eb ket\u00eb nj\u00eb \u00e7ift shtes\u00eb karakteresh 'db' n\u00eb fillim dhe n\u00eb fund t\u00eb vargut. Karakter\u00ebt shtes\u00eb jan\u00eb atje p\u00ebr t\u00eb ndihmuar me formatin. Shembuj: decimal_to_binary ((15) # kthen \"db1111db\" decimal_to_binary32) # kthen \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Ju jepet nj\u00eb varg s. Detyra juaj \u00ebsht\u00eb t\u00eb kontrolloni n\u00ebse vargu \u00ebsht\u00eb i lumtur apo jo. Nj\u00eb varg \u00ebsht\u00eb i lumtur n\u00ebse gjat\u00ebsia e tij \u00ebsht\u00eb t\u00eb pakt\u00ebn 3 dhe \u00e7do 3 shkronja rresht jan\u00eb t\u00eb dallueshme P\u00ebr shembull: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u00cbsht\u00eb jav\u00ebn e fundit t\u00eb semestrit dhe m\u00ebsuesi duhet t'u jap\u00eb notat nx\u00ebn\u00ebsve. M\u00ebsuesi ka b\u00ebr\u00eb algoritmin e vet p\u00ebr vler\u00ebsimin. Problemi i vet\u00ebm \u00ebsht\u00eb se ajo ka humbur kodin q\u00eb p\u00ebrdori p\u00ebr vler\u00ebsimin. Ajo ju ka dh\u00ebn\u00eb nj\u00eb list\u00eb t\u00eb GPA p\u00ebr disa nx\u00ebn\u00ebs dhe ju duhet t\u00eb shkruani nj\u00eb funksion q\u00eb mund t\u00eb prodhoj\u00eb nj\u00eb list\u00eb t\u00eb notave t\u00eb letrave duke p\u00ebrdorur tabel\u00ebn e m\u00ebposhtme: GPA.\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Shkruaj nj\u00eb funksion q\u00eb merr nj\u00eb varg dhe kthen True n\u00ebse gjat\u00ebsia e vargut \u00ebsht\u00eb nj\u00eb num\u00ebr i par\u00eb ose False p\u00ebrndryshe Shembuj prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv n, kthehet numri i numrave t\u00eb integrave pozitiv\u00eb n-shifrore q\u00eb fillojn\u00eb ose p\u00ebrfundojn\u00eb me 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv N, kthe shtimin e p\u00ebrgjithsh\u00ebm t\u00eb shifrave t\u00eb tij n\u00eb binar. Shembull P\u00ebr N = 1000, shuma e shifrave do t\u00eb jet\u00eb 1 prodhimi duhet t\u00eb jet\u00eb \"1\". P\u00ebr N = 150, shuma e shifrave do t\u00eb jet\u00eb 6 prodhimi duhet t\u00eb jet\u00eb \"110\". P\u00ebr N = 147, shuma e shifrave do t\u00eb jet\u00eb 12 prodhimi duhet t\u00eb jet\u00eb \"1100\".\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Duke pasur parasysh nj\u00eb list\u00eb jo bosh t\u00eb integers lst. shtoj element\u00ebt e \u00e7ift q\u00eb jan\u00eb n\u00eb indekse t\u00eb \u00e7uditshme.. Shembuj: shtoj (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Shkruaj nj\u00eb funksion q\u00eb merr nj\u00eb varg dhe kthen nj\u00eb version t\u00eb renditur t\u00eb tij. Versioni i renditur i vargut, \u00ebsht\u00eb nj\u00eb varg ku t\u00eb gjitha fjal\u00ebt (t\u00eb ndara nga hap\u00ebsira) jan\u00eb z\u00ebvend\u00ebsuar nga nj\u00eb fjal\u00eb e re ku t\u00eb gjith\u00eb karaktereve t\u00eb renditura n\u00eb m\u00ebnyr\u00eb n\u00eb rritje bazuar n\u00eb vler\u00ebn ascii. Sh\u00ebnim: Ju duhet t\u00eb mbani rendin e fjal\u00ebve dhe hap\u00ebsirave t\u00eb zbraz\u00ebta n\u00eb fjali. P\u00ebr shembull: anti_shuffle ((('Hi') kthen 'Hi' anti_shuffle (('hello') kthen 'ehllo' anti_shuffle (('Hello World!!!') kthen 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Ju jepet nj\u00eb t\u00eb dh\u00ebn\u00eb 2-dimensionale, si nj\u00eb list\u00eb e fshikulluar, e cila \u00ebsht\u00eb e ngjashme me matric\u00ebn, megjithat\u00eb, ndryshe nga matricat, \u00e7do rresht mund t\u00eb p\u00ebrmbaj\u00eb nj\u00eb num\u00ebr t\u00eb ndrysh\u00ebm kolonave. Duke pasur parasysh lst, dhe numrin e plot\u00eb x, gjeni numrat e plot\u00eb x n\u00eb list\u00eb, dhe ktheni list\u00ebn e tuples, [(x1, y1), (x2, y2)...] n\u00eb m\u00ebnyr\u00eb q\u00eb \u00e7do tuple \u00ebsht\u00eb nj\u00eb koordinat\u00eb - (rresht, kolona), duke filluar me 0.\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb rend t\u00eb numrave t\u00eb plot\u00eb jo-negativ\u00eb, kthe nj\u00eb kopje t\u00eb rendit t\u00eb dh\u00ebn\u00eb pas renditjes, do t\u00eb renditeni rendin e dh\u00ebn\u00eb n\u00eb m\u00ebnyr\u00eb n\u00eb rritje n\u00ebse shuma ((vlera e par\u00eb e indeksit, vlera e fundit e indeksit) \u00ebsht\u00eb e \u00e7uditshme, ose do ta renditeni n\u00eb m\u00ebnyr\u00eb zbrit\u00ebse n\u00ebse shuma ((vlera e par\u00eb e indeksit, vlera e fundit e indeksit) \u00ebsht\u00eb e \u00e7uditshme. Sh\u00ebnim: * mos ndryshoni rendin e dh\u00ebn\u00eb. Shembuj: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Krijoni nj\u00eb funksion encrypt q\u00eb merr nj\u00eb varg si argument dhe kthen nj\u00eb varg t\u00eb koduar me alfabetin q\u00eb rrotullohet. alfabeti duhet t\u00eb rrotullohet n\u00eb nj\u00eb m\u00ebnyr\u00eb t\u00eb till\u00eb q\u00eb shkronjat t\u00eb zhvendosen posht\u00eb me dy t\u00eb shum\u00ebzuar n\u00eb dy vende. P\u00ebr shembull: encrypt('hi') kthen 'lm' encrypt('asdfghjkl') kthen 'ewhjklnop' encrypt('gf') kthen 'kj' encrypt('et') kthen 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Ju jepet nj\u00eb list\u00eb e numrave t\u00eb plot\u00eb. Shkruajeni nj\u00eb funksion next_smallest (() q\u00eb kthen elementin e dyt\u00eb m\u00eb t\u00eb vog\u00ebl t\u00eb list\u00ebs. Kthehet Asnj\u00eb n\u00ebse nuk ka nj\u00eb element t\u00eb till\u00eb. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Asnj\u00eb next_smallest (([1, 1]) == Asnj\u00eb\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Do t\u00eb t\u00eb jepet nj\u00eb varg fjal\u00ebsh, dhe detyra jote \u00ebsht\u00eb t\u00eb num\u00ebrosh numrin e m\u00ebrzitjeve. Nj\u00eb m\u00ebrzitje \u00ebsht\u00eb nj\u00eb fjali q\u00eb fillon me fjal\u00ebn \"I\". Fjal\u00ebt jan\u00eb t\u00eb kufizuara nga '.', '?' ose '!'. P\u00ebr shembull:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Shkruaj nj\u00eb funksion q\u00eb merr nj\u00eb mesazh, dhe kodon n\u00eb m\u00ebnyr\u00eb t\u00eb till\u00eb q\u00eb t\u00eb nd\u00ebrroj\u00eb rastin e t\u00eb gjitha shkronjave, z\u00ebvend\u00ebson t\u00eb gjitha vokal\u00ebt n\u00eb mesazh me letr\u00ebn q\u00eb shfaqet 2 vende para asaj vokali n\u00eb alfabetin anglez.\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Ju jepet nj\u00eb list\u00eb e numrave t\u00eb plot\u00eb. Ju duhet t\u00eb gjeni vler\u00ebn m\u00eb t\u00eb madhe t\u00eb par\u00eb dhe t\u00eb ktheni shum\u00ebn e shifrave t\u00eb saj. Shembuj: P\u00ebr lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] prodhimi duhet t\u00eb jet\u00eb 10 P\u00ebr lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] prodhimi duhet t\u00eb jet\u00eb 25 P\u00ebr lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] prodhimi duhet t\u00eb jet\u00eb 13 P\u00ebr lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] prodhimi duhet t\u00eb jet\u00eb 11 P\u00ebr lst = [0,81,12,31,21] prod\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb fjalor, kthehet True n\u00ebse t\u00eb gjitha \u00e7el\u00ebsat jan\u00eb vargje me shkronja t\u00eb vogla ose t\u00eb gjitha \u00e7el\u00ebsat jan\u00eb vargje me shkronja t\u00eb m\u00ebdha, p\u00ebrndryshe kthehet False. Funksioni duhet t\u00eb kthej\u00eb False n\u00ebse fjalori i dh\u00ebn\u00eb \u00ebsht\u00eb bosh. Shembuj: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) duhet t\u00eb kthej\u00eb True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) duhet t\u00eb kthej\u00eb False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) duhet t\u00eb kthej\u00eb False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Implementon nj\u00eb funksion q\u00eb merr nj\u00eb num\u00ebr t\u00eb plot\u00eb jo-negativ dhe kthen nj\u00eb mas\u00eb t\u00eb n numrave t\u00eb par\u00eb t\u00eb plot\u00eb q\u00eb jan\u00eb numra par\u00ebsor dhe m\u00eb pak se n. p\u00ebr shembull: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"P\u00ebrfundoni funksionin q\u00eb merr dy numra t\u00eb plot\u00eb dhe kthen prodhimin e shifrave t\u00eb tyre t\u00eb nj\u00ebsis\u00eb. supozojm\u00eb se hyrja \u00ebsht\u00eb gjithmon\u00eb e vlefshme. Shembuj: shum\u00ebzimi ((148, 412) duhet t\u00eb kthehet 16. shum\u00ebzimi ((19, 28) duhet t\u00eb kthehet 72. shum\u00ebzimi ((2020, 1851) duhet t\u00eb kthehet 0. shum\u00ebzimi ((14,-15) duhet t\u00eb kthehet 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb varg s, num\u00ebroni numrin e vokal\u00ebve t\u00eb m\u00ebdha n\u00eb indekse t\u00eb para. P\u00ebr shembull: count_upper (('aBCdEf') kthen 1 count_upper (('abcdefg') kthen 0 count_upper (('dBBE') kthen 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv n, ju duhet t\u00eb b\u00ebni nj\u00eb grumbull prej n niveleve t\u00eb gur\u00ebve. Niveli i par\u00eb ka n gur\u00eb. Numri i gur\u00ebve n\u00eb nivelin tjet\u00ebr \u00ebsht\u00eb: - numri i ardhsh\u00ebm i rast\u00ebsish\u00ebm n\u00ebse n \u00ebsht\u00eb i rast\u00ebsish\u00ebm. - numri i ardhsh\u00ebm i rast\u00ebsish\u00ebm n\u00ebse n \u00ebsht\u00eb i rast\u00ebsish\u00ebm. Kthej numrin e gur\u00ebve n\u00eb \u00e7do nivel n\u00eb nj\u00eb list\u00eb, ku elementi n\u00eb indeks i p\u00ebrfaq\u00ebson numrin e gur\u00ebve n\u00eb nivel (i + 1). Shembuj:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Do t\u00eb ju jepet nj\u00eb varg fjal\u00ebsh t\u00eb ndara nga komma ose hap\u00ebsira. Detyra juaj \u00ebsht\u00eb t\u00eb ndani varg n\u00eb fjal\u00eb dhe t\u00eb ktheni nj\u00eb mas\u00eb fjal\u00ebsh. P\u00ebr shembull: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Ky funksion merr dy numra pozitiv\u00eb x dhe y dhe kthen numrin e plot\u00eb m\u00eb t\u00eb madh \u00e7ift q\u00eb \u00ebsht\u00eb n\u00eb intervalin [x, y] p\u00ebrfshir\u00eb. N\u00ebse nuk ka nj\u00eb num\u00ebr t\u00eb till\u00eb, at\u00ebher\u00eb funksioni duhet t\u00eb kthej\u00eb -1. P\u00ebr shembull: choose_num(12, 15) = 14 choose_num(13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Ju jan\u00eb dh\u00ebn\u00eb dy integers pozitiv n dhe m, dhe detyra juaj \u00ebsht\u00eb p\u00ebr t\u00eb llogaritur mesataren e integers nga n deri m (duke p\u00ebrfshir\u00eb n dhe m). rrumbullakos p\u00ebrgjigjen n\u00eb num\u00ebr t\u00eb plot\u00eb m\u00eb t\u00eb af\u00ebrt dhe t\u00eb konvertoj\u00eb at\u00eb n\u00eb binar. N\u00ebse n \u00ebsht\u00eb m\u00eb i madh se m, kthimi -1. Shembull: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b11\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Duke pasur parasysh nj\u00eb list\u00eb t\u00eb integers pozitiv x. kthim nj\u00eb list\u00eb t\u00eb renditur t\u00eb t\u00eb gjitha elementeve q\u00eb nuk ka ndonj\u00eb shif\u00ebr edhe. Sh\u00ebnim: Lista e kthyer duhet t\u00eb renditet n\u00eb m\u00ebnyr\u00eb n\u00eb rritje. P\u00ebr shembull:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb s\u00ebr\u00eb numrash t\u00eb plot\u00eb, rendit numrat e plot\u00eb q\u00eb jan\u00eb midis 1 dhe 9 p\u00ebrfshir\u00eb, kthejn\u00eb s\u00ebr\u00eb rezultatin, dhe pastaj z\u00ebvend\u00ebsojn\u00eb \u00e7do shif\u00ebr me emrin e saj p\u00ebrkat\u00ebs nga \"Nj\u00eb\", \"Dy\", \"Tre\", \"Kalim\", \"Pes\u00eb\", \"Gjasht\u00eb\", \"Shtat\u00eb\", \"Vet\u00eb\", \"N\u00ebnt\u00eb\". P\u00ebr shembull: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> rendit arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> arr t\u00eb kund\u00ebrt -> [8, 5, 4, 3, 2, 2, 1, 1] kthimi [\"Vet\u00eb\", \"Kalim\", \"Dy\", \"Tre\", \"Dy\", \"Dy\", \"Nj\u00eb\", \"Nj\u00eb\"] N\u00ebse s\u00ebr\u00eb \u00ebsht\u00eb bosh, kthimi nj\u00eb s\u00ebr\u00eb: arr = [] kthimi [] N\u00ebse s\u00ebr\u00eb ka ndonj\u00eb num\u00ebr t\u00eb\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Implementoni funksionin f q\u00eb merr n si parameter, dhe kthen nj\u00eb list\u00eb me madh\u00ebsi n, n\u00eb m\u00ebnyr\u00eb q\u00eb vlera e elementit n\u00eb indeks i t\u00eb jet\u00eb faktori i n\u00ebse i \u00ebsht\u00eb i nj\u00ebjt\u00eb ose shuma e numrave nga 1 n\u00eb i ndryshe. i fillon nga 1. faktori i i \u00ebsht\u00eb shum\u00ebzimi i numrave nga 1 n\u00eb i (1 * 2 *... * i). Shembull: f (((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv n, kthehet nj\u00eb tuple q\u00eb ka numrin e palindromave t\u00eb barabarta dhe t\u00eb \u00e7odhe q\u00eb bien brenda intervalit ((1, n), p\u00ebrfshir\u00eb. Shembull1: Hyrje: 3 Dalje: (1, 2) Shpjegim: Palindroma e barabarta jan\u00eb 1, 2, 3. nj\u00ebra prej tyre \u00ebsht\u00eb e barabarte, dhe dy prej tyre jan\u00eb t\u00eb \u00e7odhe. Shembull2: Hyrje: 12 Dalje: (4, 6) Shpjegim: Palindroma e barabarta jan\u00eb 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. kat\u00ebr prej tyre jan\u00eb t\u00eb barabarta, dhe 6 prej tyre jan\u00eb t\u00eb \u00e7odhe. Sh\u00ebnim: 1. 1 <= n <= 10^3 2. tuple ka kthyer numrin e palindromave t\u00eb barabarta dhe t\u00eb \u00e7odhe respektivisht.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Shkruaj nj\u00eb funksion count_nums i cili merr nj\u00eb s\u00ebr\u00eb t\u00eb numrave t\u00eb plot\u00eb dhe kthen numrin e elementeve q\u00eb ka nj\u00eb shum\u00eb t\u00eb shifrave > 0. N\u00ebse nj\u00eb num\u00ebr \u00ebsht\u00eb negativ, at\u00ebher\u00eb shifra e tij e par\u00eb e n\u00ebnshkruar do t\u00eb jet\u00eb negative: p.sh. -123 ka shifra t\u00eb n\u00ebnshkruara -1, 2 dhe 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Ne kemi nj\u00eb mas\u00eb 'arr' prej N integers arr[1], arr[2],..., arr[N].Numrat n\u00eb mas\u00eb do t\u00eb renditen n\u00eb m\u00ebnyr\u00eb t\u00eb rast\u00ebsishme. Detyra juaj \u00ebsht\u00eb t\u00eb p\u00ebrcaktohet n\u00ebse \u00ebsht\u00eb e mundur t\u00eb renditeni nj\u00eb mas\u00eb n\u00eb m\u00ebnyr\u00eb jo-shkurt\u00ebse duke kryer operacionin e m\u00ebposht\u00ebm n\u00eb mas\u00eb t\u00eb dh\u00ebn\u00eb: Ju lejohet t\u00eb kryeni operacionin e zhvendosjes s\u00eb djatht\u00eb \u00e7do num\u00ebr her\u00eb. Nj\u00eb operacion zhvendosje t\u00eb djatht\u00eb do t\u00eb thot\u00eb zhvendosja e t\u00eb gjitha elementeve t\u00eb mas\u00ebs nga nj\u00eb pozicion n\u00eb drejtimin e duhur. Elementi i fundit i mas\u00ebs do t\u00eb zhvendoset n\u00eb pozicionin fillestar n\u00eb mas\u00eb d.m.th. Indeksi i 0th. N\u00ebse \u00ebsht\u00eb e mundur t\u00eb merrni mas\u00ebn e renditur duke kryer operacionin e m\u00ebsip\u00ebrm, at\u00ebher\u00eb kthimi i v\u00ebrtet\u00eb kthehet i\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"N\u00eb k\u00ebt\u00eb problem, ju do t\u00eb zbatoni nj\u00eb funksion q\u00eb merr dy lista me numra, dhe p\u00ebrcakton n\u00ebse \u00ebsht\u00eb e mundur t\u00eb kryhet nj\u00eb shk\u00ebmbim i elementeve midis tyre p\u00ebr t\u00eb b\u00ebr\u00eb lst1 nj\u00eb list\u00eb vet\u00ebm me numra t\u00eb \u00e7ifta. Nuk ka kufizim n\u00eb numrin e elementeve t\u00eb shk\u00ebmbyera midis lst1 dhe lst2. N\u00ebse \u00ebsht\u00eb e mundur t\u00eb shk\u00ebmbeni elemente midis lst1 dhe lst2 p\u00ebr t\u00eb b\u00ebr\u00eb q\u00eb t\u00eb gjith\u00eb element\u00ebt e lst1 t\u00eb jen\u00eb t\u00eb \u00e7ifta, kthe \"JA\". Ndryshe, kthe \"JO\". P\u00ebr shembull: shk\u00ebmbim [1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" shk\u00ebmbim [1, 2, 3, 4], [1, 5, 3, 4]) => \"JO\" Supozohet se listat e hyrjes do t\u00eb jen\u00eb jo bosh.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Duke pasur parasysh nj\u00eb varg q\u00eb p\u00ebrfaq\u00ebson nj\u00eb shkronj\u00eb t\u00eb vog\u00ebl t\u00eb ndar\u00eb nga hap\u00ebsira, kthehet nj\u00eb fjalor i shkronj\u00ebs me m\u00eb shum\u00eb p\u00ebrs\u00ebritje dhe q\u00eb p\u00ebrmban numrin p\u00ebrkat\u00ebs. N\u00ebse disa shkronja kan\u00eb t\u00eb nj\u00ebjt\u00ebn shfaqje, kthehen t\u00eb gjitha. Shembull: histogram (('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram (('a b b a') == {'a': 2, 'b': 2} histogram (('a b c a b') == {'a': 2, 'b': 2} histogram (('b b a') == {'b 4}: histogram (('a b') == {'b 4}) == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Detyra Na jan\u00eb dh\u00ebn\u00eb dy vargjet s dhe c, ju duhet t\u00eb fshini t\u00eb gjitha karaktere n\u00eb s q\u00eb jan\u00eb t\u00eb barabarta me \u00e7do karakter n\u00eb c pastaj kontrolloni n\u00ebse vargu i rezultatit \u00ebsht\u00eb palindrom. Nj\u00eb varg quhet palindrom n\u00ebse lexohet i nj\u00ebjti prapa si p\u00ebrpara. Ju duhet t\u00eb ktheni nj\u00eb tuple q\u00eb p\u00ebrmban varg rezultatit dhe t\u00eb V\u00ebrtet\u00eb\/T\u00eb gabuar p\u00ebr kontrollin. Shembull P\u00ebr s = \"abcde\", c = \"ae\", rezultati duhet t\u00eb jet\u00eb ('bcd', False) P\u00ebr s = \"abcdef\", c = \"b\" rezultati duhet t\u00eb jet\u00eb ('acdef', False) P\u00ebr s = \"abcdedcba\", c = \"ab\", rezultati duhet t\u00eb jet\u00eb ('cdedc',True)\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Duke pasur parasysh nj\u00eb list\u00eb e vargjeve, ku secili varg p\u00ebrb\u00ebhet vet\u00ebm nga shifra, kthehet nj\u00eb list\u00eb. \u00c7do element i i prodhimit duhet t\u00eb jet\u00eb \"numri i elementeve t\u00eb \u00e7uditshme n\u00eb varg i t\u00eb hyrjes. \" ku t\u00eb gjitha i duhet t\u00eb z\u00ebvend\u00ebsohen me numrin e shifrave t\u00eb \u00e7uditshme n\u00eb varg i t\u00eb hyrjes.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb s\u00ebr\u00eb numrash t\u00eb plot\u00eb, gjeni shum\u00ebn minimale t\u00eb \u00e7do n\u00ebn-s\u00ebr\u00eb numrash jo t\u00eb zbraz\u00ebt. Shembull minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Ju jepet nj\u00eb rrjet\u00eb drejtk\u00ebnd\u00ebshe e puset. Secili rresht p\u00ebrfaq\u00ebson nj\u00eb pus t\u00eb vet\u00ebm, dhe secili 1 n\u00eb nj\u00eb rresht p\u00ebrfaq\u00ebson nj\u00eb nj\u00ebsi t\u00eb vetme t\u00eb ujit. Secili pus ka nj\u00eb kov\u00eb p\u00ebrkat\u00ebse q\u00eb mund t\u00eb p\u00ebrdoret p\u00ebr t\u00eb nxjerr\u00eb uj\u00eb nga ajo, dhe t\u00eb gjitha kovat kan\u00eb t\u00eb nj\u00ebjt\u00ebn kapacitet. Detyra juaj \u00ebsht\u00eb t\u00eb p\u00ebrdorni kovat p\u00ebr t\u00eb zbrazur puset. Prodhojeni numrin e her\u00ebve q\u00eb ju nevojitet p\u00ebr t\u00eb ulur kovat. Shembull 1: Hyrje: rrjeti: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Hyrje: 62: Hyrje: rrjeti: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1,1]] bucket_capacity: 2 Hyrje: 5\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    N\u00eb k\u00ebt\u00eb Kata, ju duhet t\u00eb rendisni nj\u00eb s\u00ebr\u00eb t\u00eb integrave jo-negativ sipas numrit t\u00eb nj\u00ebsive n\u00eb p\u00ebrfaq\u00ebsimin e tyre binar n\u00eb rendin ngjit\u00ebs. P\u00ebr nj\u00eb num\u00ebr t\u00eb ngjash\u00ebm t\u00eb nj\u00ebsive, rendisni bazuar n\u00eb vler\u00ebn dhjetore. Ajo duhet t\u00eb zbatohet si kjo:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Duke pasur parasysh nj\u00eb varg s dhe nj\u00eb num\u00ebr natyral n, ju keni qen\u00eb t\u00eb ngarkuar p\u00ebr t\u00eb zbatuar nj\u00eb funksion q\u00eb kthen nj\u00eb list\u00eb t\u00eb t\u00eb gjitha fjal\u00ebve nga varg s q\u00eb p\u00ebrmbajn\u00eb sakt\u00ebsisht n konsonant\u00eb, n\u00eb m\u00ebnyr\u00eb q\u00eb k\u00ebto fjal\u00eb t\u00eb shfaqen n\u00eb varg s. N\u00ebse vargu s \u00ebsht\u00eb bosh at\u00ebher\u00eb funksioni duhet t\u00eb kthej\u00eb nj\u00eb list\u00eb bosh. Sh\u00ebnim: ju mund t\u00eb supozoj\u00eb varg hyrje p\u00ebrmban vet\u00ebm shkronja dhe hap\u00ebsira. Shembuj: select_words (((\"Mary kishte nj\u00eb qengj\u00eb t\u00eb vog\u00ebl\", 4) ==> [\"i vog\u00ebl\"] select_words (((\"Mary kishte nj\u00eb qengj\u00eb t\u00eb vog\u00ebl\", 3) ==> [\"Mary\", \"qengj\u00eb\"] select_words \"i thjesht\u00eb hap\u00ebsir\u00eb e bardh\u00eb\", 2) ==> [] select_words (((\"P\u00ebrsh\u00ebndetje bot\u00eb\", 4) ==> [\"bot\u00eb\"] select\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Ju jepet nj\u00eb fjal\u00eb. Detyra juaj \u00ebsht\u00eb t\u00eb gjeni vokalin m\u00eb t\u00eb af\u00ebrt q\u00eb q\u00ebndron midis dy konsonant\u00ebve nga ana e djatht\u00eb e fjal\u00ebs (duke u kujdesur p\u00ebr shkronjat e vogla). Vokalit n\u00eb fillim dhe n\u00eb fund nuk llogariten. Kthejeni nj\u00eb varg bosh n\u00ebse nuk keni gjetur asnj\u00eb vokal q\u00eb plot\u00ebson kushtet e m\u00ebsip\u00ebrme. Mund t\u00eb supozojm\u00eb se vargu i dh\u00ebn\u00eb p\u00ebrmban vet\u00ebm shkronja angleze. Shembull: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb mas\u00eb arr e integers dhe nj\u00eb num\u00ebr i plot\u00eb pozitiv k, kthehet nj\u00eb list\u00eb e renditur e gjat\u00ebsis\u00eb k me numrat maksimal k n\u00eb arr. Shembull1: Hyrje: arr = [-3, -4, 5], k = 3 Dalje: [-4, -3, 5] Shembull2: Hyrje: arr = [4, -4, 4], k = 2 Dalje: [4, 4] Shembull3: Hyrje: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Dalje: [2] Sh\u00ebnim: 1. gjat\u00ebsia e mas\u00ebs do t\u00eb jet\u00eb n\u00eb intervalin e [1, 1000]. 2. Element\u00ebt n\u00eb mas\u00eb do t\u00eb jen\u00eb n\u00eb intervalin e [-1000, 1000]. 3. 0 <= k <= len ((arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Duke pasur parasysh nj\u00eb list\u00eb jo bosh t\u00eb integers, kthehet shuma e t\u00eb gjitha elementeve t\u00eb \u00e7uditshme q\u00eb jan\u00eb n\u00eb pozicione t\u00eb barabarta. Shembuj zgjidhje (([5, 8, 7, 1]) ==> 12 zgjidhje (([3, 3, 3, 3, 3]) ==> 9 zgjidhje (([30, 13, 24, 321]) ==>0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb mas\u00eb jo t\u00eb zbraz\u00ebt t\u00eb numrave t\u00eb plot\u00eb arr dhe nj\u00eb num\u00ebr t\u00eb plot\u00eb k, kthejn\u00eb shum\u00ebn e elementeve me t\u00eb pakt\u00ebn dy shifra nga k element\u00ebt e par\u00eb t\u00eb arr. Shembull: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # shum\u00ebn e 21 + 3 Kufizime: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv n, kthehet nj\u00eb list\u00eb e renditur q\u00eb ka numrat e \u00e7uditsh\u00ebm n\u00eb sekuenc\u00ebn e Collatz. Gjyke e Collatz \u00ebsht\u00eb nj\u00eb supozim n\u00eb matematik\u00eb q\u00eb ka t\u00eb b\u00ebj\u00eb me nj\u00eb sekuenc\u00eb t\u00eb p\u00ebrcaktuar si m\u00eb posht\u00eb: filloni me \u00e7do num\u00ebr t\u00eb plot\u00eb pozitiv n. Pastaj \u00e7do term\u00eb merret nga termi i m\u00ebparsh\u00ebm si m\u00eb posht\u00eb: n\u00ebse termi i m\u00ebparsh\u00ebm \u00ebsht\u00eb i \u00e7ift, termi tjet\u00ebr \u00ebsht\u00eb gjysma e termi t\u00eb m\u00ebparsh\u00ebm. N\u00ebse termi i m\u00ebparsh\u00ebm \u00ebsht\u00eb i \u00e7uditsh\u00ebm, termi tjet\u00ebr \u00ebsht\u00eb 3 her\u00eb termi i m\u00ebparsh\u00ebm plus 1. Gjyka \u00ebsht\u00eb se pavar\u00ebsisht nga vlera e n, sekuenca gjithmon\u00eb do t\u00eb arrij\u00eb 1.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Ju duhet t\u00eb shkruani nj\u00eb funksion i cili validon nj\u00eb varg t\u00eb caktuar t\u00eb dat\u00ebs dhe kthen t\u00eb V\u00ebrtet\u00eb n\u00ebse data \u00ebsht\u00eb e vlefshme ndryshe False. Data \u00ebsht\u00eb e vlefshme n\u00ebse t\u00eb gjitha rregullat e m\u00ebposhtme jan\u00eb t\u00eb p\u00ebrmbushura: 1. Varga e dat\u00ebs nuk \u00ebsht\u00eb bosh. 2. Numri i dit\u00ebve nuk \u00ebsht\u00eb m\u00eb pak se 1 ose m\u00eb i lart\u00eb se 31 dit\u00eb p\u00ebr muajt 1,3,5,7,8,10,12. Dhe numri i dit\u00ebve nuk \u00ebsht\u00eb m\u00eb pak se 1 ose m\u00eb i lart\u00eb se 30 dit\u00eb p\u00ebr muajt 4,6,9,11. Dhe, numri i dit\u00ebve nuk \u00ebsht\u00eb m\u00eb pak se 1 ose m\u00eb i lart\u00eb se 29 p\u00ebr muajin 2. 3. Muajt nuk duhet t\u00eb jen\u00eb m\u00eb pak se 1 ose m\u00eb t\u00eb lart\u00eb se 12. 4. Data duhet t\u00eb jet\u00eb n\u00eb formatin: mm-dd-yyyy p\u00ebr shembull: valid_date('03-11-2000') => True_valid_date('\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Ju jan\u00eb dh\u00ebn\u00eb dy intervale, ku \u00e7do interval \u00ebsht\u00eb nj\u00eb pal\u00eb e integers. P\u00ebr shembull, interval = (fillimi, fundi) = (1, 2). Intervalet e dh\u00ebn\u00eb jan\u00eb t\u00eb mbyllura q\u00eb do t\u00eb thot\u00eb se interval (fillimi, fundi) p\u00ebrfshin t\u00eb dy fillimi dhe fundi. P\u00ebr \u00e7do interval t\u00eb dh\u00ebn\u00eb, supozohet se fillimi i saj \u00ebsht\u00eb m\u00eb pak ose i barabart\u00eb me fundin e saj. Detyra juaj \u00ebsht\u00eb p\u00ebr t\u00eb p\u00ebrcaktuar n\u00ebse gjat\u00ebsia e kryq\u00ebzimit t\u00eb k\u00ebtyre dy intervaleve \u00ebsht\u00eb nj\u00eb num\u00ebr i par\u00eb. Shembull, kryq\u00ebzimi i intervaleve (1, 3), (2, 4) \u00ebsht\u00eb (2, 3) e cila gjat\u00ebsia e saj \u00ebsht\u00eb 1, e cila nuk \u00ebsht\u00eb nj\u00eb num\u00ebr i par\u00eb. N\u00ebse gjat\u00ebsia e kryq\u00ebzimit \u00ebsht\u00eb nj\u00eb num\u00ebr i par\u00eb, kthehet \"Po\", p\u00ebrndryshe, kthehet \"Jo\". N\u00ebse dy interval\u00ebt nuk kryq\u00ebzohen, kthehet \"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Ju \u00ebsht\u00eb dh\u00ebn\u00eb nj\u00eb mas\u00eb arr e integers dhe ju duhet t\u00eb kthehet shuma e madh\u00ebsive e integers shum\u00ebzuar me produkt t\u00eb t\u00eb gjitha shenjave t\u00eb \u00e7do numri n\u00eb mas\u00eb, t\u00eb p\u00ebrfaq\u00ebsuara nga 1, -1 ose 0.\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb rrjet me N rreshta dhe N kolona (N >= 2) dhe nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv k, \u00e7do qeliz\u00eb e rrjetit p\u00ebrmban nj\u00eb vler\u00eb. \u00c7do num\u00ebr i plot\u00eb n\u00eb intervalin [1, N * N] p\u00ebrfshir\u00eb shfaqet sakt\u00ebsisht nj\u00eb her\u00eb n\u00eb qelizat e rrjetit. Ju duhet t\u00eb gjeni rrug\u00ebn minimale t\u00eb gjat\u00ebsis\u00eb k n\u00eb rrjet. Ju mund t\u00eb filloni nga \u00e7do qeliz\u00eb, dhe n\u00eb \u00e7do hap ju mund t\u00eb l\u00ebvizni n\u00eb \u00e7do qeliz\u00eb fqinje, me fjal\u00eb t\u00eb tjera, ju mund t\u00eb shkoni n\u00eb qelizat q\u00eb ndajn\u00eb nj\u00eb skaj me ju qeliza aktuale. Ju lutemi vini re se nj\u00eb rrug\u00eb e gjat\u00ebsis\u00eb k do t\u00eb thot\u00eb t\u00eb vizitoni sakt\u00ebsisht k qeliza (jo domosdoshm\u00ebrisht t\u00eb dallueshme). Ju nuk mund t\u00eb shkoni jasht\u00eb rrjetit. Nj\u00eb rrug\u00eb A (e gjat\u00ebsis\u00eb k) konsiderohet\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"T\u00eb gjith\u00eb e njohin sekuenc\u00ebn e Fibona\u00e7it, ajo \u00ebsht\u00eb studiuar thell\u00eb nga matematikan\u00ebt n\u00eb dy shekujt e fundit. Sidoqoft\u00eb, ajo q\u00eb njer\u00ebzit nuk e din\u00eb \u00ebsht\u00eb sekuenca e Tribona\u00e7it. Sekuenca e Tribona\u00e7it p\u00ebrcaktohet nga p\u00ebrs\u00ebritja: tri(1) = 3 tri(n) = 1 + n \/ 2, n\u00ebse n \u00ebsht\u00eb i \u00e7ift. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), n\u00ebse n \u00ebsht\u00eb i \u00e7uditsh\u00ebm. P\u00ebr shembull: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Ju u jepet nj\u00eb num\u00ebr i plot\u00eb jo-negativ n, ju duhet t\u00eb ktheni nj\u00eb list\u00eb t\u00eb numrave t\u00eb par\u00eb n + 1 t\u00eb sekuenc\u00ebs Tribona\u00e7it.\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv n, kthehet produkti i shifrave t\u00eb \u00e7uditshme. Kthehet 0 n\u00ebse t\u00eb gjitha shifrat jan\u00eb t\u00eb para. P\u00ebr shembull: shifrat ((1) == 1 shifrat ((4) == 0 shifrat ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Ju jepet nj\u00eb list\u00eb e numrave. Ju duhet t\u00eb ktheni shum\u00ebn e numrave n\u00eb katror n\u00eb list\u00ebn e dh\u00ebn\u00eb, rrumbullakosni \u00e7do element n\u00eb list\u00eb n\u00eb int m\u00eb t\u00eb lart\u00eb ((Tavan) s\u00eb pari. Shembuj: P\u00ebr lst = [1,2,3] prodhimi duhet t\u00eb jet\u00eb 14 P\u00ebr lst = [1,4,9] prodhimi duhet t\u00eb jet\u00eb 98 P\u00ebr lst = [1,3,5,7] prodhimi duhet t\u00eb jet\u00eb 84 P\u00ebr lst = [1.4,4.2,0] prodhimi duhet t\u00eb jet\u00eb 29 P\u00ebr lst = [-2.4,1,1] prodhimi duhet t\u00eb jet\u00eb 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Krijoni nj\u00eb funksion q\u00eb kthen indeksin m\u00eb t\u00eb madh t\u00eb nj\u00eb elementi q\u00eb nuk \u00ebsht\u00eb m\u00eb i madh se ose i barabart\u00eb me elementin menj\u00ebher\u00eb para tij. N\u00ebse nuk ekziston nj\u00eb element i till\u00eb at\u00ebher\u00eb kthen -1. Array i dh\u00ebn\u00eb nuk do t\u00eb p\u00ebrmbaj\u00eb vlera t\u00eb dyfishta. Shembuj: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Krijoni nj\u00eb funksion q\u00eb merr numra t\u00eb plot\u00eb, t\u00eb fluturuesh\u00ebm, ose varg q\u00eb p\u00ebrfaq\u00ebsojn\u00eb numrat real\u00eb, dhe kthen variablin m\u00eb t\u00eb madh n\u00eb llojin e tij t\u00eb caktuar t\u00eb variablit. Kthehet Asnj\u00eb n\u00ebse vlerat jan\u00eb t\u00eb barabarta. Sh\u00ebnim: N\u00ebse nj\u00eb num\u00ebr real p\u00ebrfaq\u00ebsohet si nj\u00eb varg, pika fluturuese mund t\u00eb jet\u00eb. ose, compare_one{1, 2.5) \u00e2 -> 2.5 compare_one{1, \"2,3\") \u00e2 -> \"2,3\" compare_one{5,1\", \"6\") \u00e2 -> \"6\" compare_one{1\", 1) \u00e2 -> Asnj\u00eb\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Vler\u00ebso n\u00ebse numri i dh\u00ebn\u00eb n mund t\u00eb shkruhet si shuma e sakt\u00ebsisht 4 numrave t\u00eb barabart\u00eb pozitiv Shembull \u00ebsht\u00eb_i barabart\u00eb_me_shum\u00ebn_e barabart\u00eb ((4) == False \u00ebsht\u00eb_i barabart\u00eb_me_shum\u00ebn_e barabart\u00eb ((6) == False \u00ebsht\u00eb_i barabart\u00eb_me_shum\u00ebn_e barabart\u00eb ((8) == True\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Faktoriali brazilian \u00ebsht\u00eb i p\u00ebrcaktuar si: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! ku n > 0 P\u00ebr shembull:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb tekst t\u00eb vargut, z\u00ebvend\u00ebso t\u00eb gjitha hap\u00ebsirat n\u00eb t\u00eb me n\u00ebnvizues, dhe n\u00ebse nj\u00eb varg ka m\u00eb shum\u00eb se 2 hap\u00ebsira t\u00eb nj\u00ebpasnj\u00ebshme, at\u00ebher\u00eb z\u00ebvend\u00ebso t\u00eb gjitha hap\u00ebsirat e nj\u00ebpasnj\u00ebshme me - fix_spaces ((\"Shembull\") == \"Shembull\" fix_spaces ((\"Shembull1\") == \"Shembull_1\" fix_spaces (((\"Shembull2\") == \"_Shembull_2\" fix_spaces ((\"Shembull 3\") == \"_Shembull-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Krijoni nj\u00eb funksion i cili merr nj\u00eb varg q\u00eb p\u00ebrfaq\u00ebson emrin e nj\u00eb skedari, dhe kthen 'Po' n\u00ebse emri i skedarit \u00ebsht\u00eb i vlefsh\u00ebm, dhe kthen 'Jo' n\u00eb rast t\u00eb kund\u00ebrt. Nj\u00eb em\u00ebr i skedarit konsiderohet i vlefsh\u00ebm n\u00ebse dhe vet\u00ebm n\u00ebse plot\u00ebsohen t\u00eb gjitha kushtet e m\u00ebposhtme: - Nuk duhet t\u00eb ket\u00eb m\u00eb shum\u00eb se tre shifra ('0'-'9') n\u00eb emrin e skedarit. - Emri i skedarit p\u00ebrmban sakt\u00ebsisht nj\u00eb pik\u00eb '.' - N\u00ebnvargja para pik\u00ebs nuk duhet t\u00eb jet\u00eb bosh, dhe fillon me nj\u00eb shkronj\u00eb nga alfabeti latin ('a'-'z' dhe 'A'Z'). - N\u00ebnvargja pas pik\u00ebs duhet t\u00eb jet\u00eb nj\u00eb nga k\u00ebto: ['txt', 'exe', 'lld'] Shembuj: file_name_check\"{example\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" Kjo funksion do t\u00eb marr\u00eb nj\u00eb list\u00eb t\u00eb numrave t\u00eb plot\u00eb. P\u00ebr t\u00eb gjitha hyrjet n\u00eb list\u00eb, funksioni do t\u00eb kat\u00ebrroj\u00eb hyrjen e numrit t\u00eb plot\u00eb n\u00ebse indeksi i tij \u00ebsht\u00eb nj\u00eb shum\u00ebfisht\u00eb i 3 dhe do t\u00eb kubis\u00eb hyrjen e numrit t\u00eb plot\u00eb n\u00ebse indeksi i tij \u00ebsht\u00eb nj\u00eb shum\u00ebfisht\u00eb i 4 dhe jo nj\u00eb shum\u00ebfisht\u00eb i 3. Funksioni nuk do t\u00eb ndryshoj\u00eb hyrjet n\u00eb list\u00eb t\u00eb cilat indekset nuk jan\u00eb nj\u00eb shum\u00ebfisht\u00eb t\u00eb 3 ose 4. Funksioni pastaj do t\u00eb kthej\u00eb shum\u00ebn e t\u00eb gjitha hyrjeve. Shembuj: P\u00ebr lst = [1,2,3] prodhimi duhet t\u00eb jet\u00eb 6 P\u00ebr lst = [] prodhimi duhet t\u00eb jet\u00eb 0 P\u00ebr lst = [-1,-5,2,-1,-5] prodhimi duhet t\u00eb jet\u00eb -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Ju jepet nj\u00eb varg q\u00eb p\u00ebrfaq\u00ebson nj\u00eb fjali, fjala p\u00ebrmban disa fjal\u00eb t\u00eb ndara me nj\u00eb hap\u00ebsir\u00eb, dhe ju duhet t\u00eb ktheni nj\u00eb varg q\u00eb p\u00ebrmban fjal\u00ebt nga fjala origjinale, gjat\u00ebsia e t\u00eb cil\u00ebve jan\u00eb numra par\u00ebsor, renditja e fjal\u00ebve n\u00eb varg t\u00eb ri duhet t\u00eb jet\u00eb i nj\u00ebjt\u00eb me at\u00eb origjinale. Shembull1: Hyrje: fjala = \"Kjo \u00ebsht\u00eb nj\u00eb prov\u00eb\" Dalje: \"\u00ebsht\u00eb\" Shembull2: Hyrje: fjala = \"le t\u00eb shkoj\u00eb p\u00ebr not\" Dalje: \"go for\" Kufizime: * 1 <= len(fjala) <= 100 * Fjala p\u00ebrmban vet\u00ebm shkronja\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Detyra juaj \u00ebsht\u00eb t\u00eb implementoni nj\u00eb funksion q\u00eb do t\u00eb thjeshtoj\u00eb shprehjen x * n. Funksioni kthehet True n\u00ebse x * n vler\u00ebsohet n\u00eb nj\u00eb num\u00ebr t\u00eb t\u00ebr\u00eb dhe False p\u00ebrndryshe. T\u00eb dy x dhe n, jan\u00eb p\u00ebrfaq\u00ebsim i nj\u00eb fije t\u00eb nj\u00eb fraksionit dhe kan\u00eb formatin e m\u00ebposht\u00ebm, <numerator>\/<denominator> ku num\u00ebruesi dhe em\u00ebruesi jan\u00eb numra t\u00eb t\u00ebr\u00eb pozitiv\u00eb. Ju mund t\u00eb supozoni se x dhe n jan\u00eb fraksione t\u00eb vlefshme dhe nuk kan\u00eb zero si em\u00ebrues. thjeshtojne \"1\/5\", \"5\/1\") = True thjeshtojne \"1\/6\", \"2\/1\") = False thjeshtojne \"7\/10\", \"10\/2\") = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Shkruaj nj\u00eb funksion i cili rendit list\u00ebn e dh\u00ebn\u00eb t\u00eb numrave t\u00eb plot\u00eb n\u00eb rendin ngjit\u00ebs sipas shum\u00ebs s\u00eb shifrave t\u00eb tyre. Sh\u00ebnim: n\u00ebse ka disa elemente me nj\u00eb shum\u00eb t\u00eb ngjashme t\u00eb shifrave t\u00eb tyre, renditeni ato bazuar n\u00eb indeksin e tyre n\u00eb list\u00ebn origjinale. P\u00ebr shembull:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Shkruaj nj\u00eb funksion q\u00eb merr nj\u00eb s\u00ebr\u00eb numrash si input dhe kthen numrin e elementeve n\u00eb s\u00ebr\u00eb q\u00eb jan\u00eb m\u00eb t\u00eb m\u00ebdha se 10 dhe si shifrat e par\u00eb dhe t\u00eb fundit t\u00eb nj\u00eb numri jan\u00eb t\u00eb \u00e7uditshme (1, 3, 5, 7, 9). P\u00ebr shembull: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Ju \u00ebsht\u00eb dh\u00ebn\u00eb nj\u00eb num\u00ebr i plot\u00eb pozitiv n. Ju duhet t\u00eb krijoni nj\u00eb num\u00ebr i plot\u00eb renditje a e gjat\u00ebsis\u00eb n. P\u00ebr \u00e7do i (1 \u2030\u00a4 i \u2030\u00a4 n), vlera e a[i] = i * i - i + 1. Kthehet numri i trefisht\u00eb (a[i], a[j], a[k]) e nj\u00eb ku i < j < k, dhe a[i] + a[j] + a[k] \u00ebsht\u00eb nj\u00eb shum\u00ebfish i 3. Shembull: Input: n = 5 Output: 1 Shpjegim: a = [1, 3, 7, 13, 21] Trefisht\u00ebja e vetme e vlefshme \u00ebsht\u00eb (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Shkruaj nj\u00eb funksion q\u00eb pranon nj\u00eb list\u00eb e vargjeve si parameter, fshihet vargjet q\u00eb kan\u00eb gjat\u00ebsi t\u00eb \u00e7uditshme nga ajo, dhe kthen list\u00ebn e rezultuar me nj\u00eb rend t\u00eb renditur, Lista \u00ebsht\u00eb gjithmon\u00eb nj\u00eb list\u00eb e vargjeve dhe kurr\u00eb nj\u00eb mas\u00eb e numrave, dhe mund t\u00eb p\u00ebrmbaj\u00eb kopje. Rendi i list\u00ebs duhet t\u00eb jet\u00eb n\u00eb rritje nga gjat\u00ebsia e \u00e7do fjale, dhe ju duhet t\u00eb ktheni list\u00ebn e renditur nga ajo rregull. N\u00ebse dy fjal\u00eb kan\u00eb t\u00eb nj\u00ebjt\u00ebn gjat\u00ebsi, renditeni list\u00ebn alfabetikisht. Funksioni duhet t\u00eb kthej\u00eb nj\u00eb list\u00eb e vargjeve n\u00eb rend t\u00eb renditur. Ju mund t\u00eb supozoj\u00eb se t\u00eb gjitha fjal\u00ebt do t\u00eb ken\u00eb t\u00eb nj\u00ebjt\u00ebn gjat\u00ebsi. P\u00ebr shembull: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Nj\u00eb program i thjesht\u00eb i cili duhet t\u00eb kthej\u00eb vler\u00ebn e x n\u00ebse n \u00ebsht\u00eb nj\u00eb num\u00ebr i par\u00eb dhe duhet t\u00eb kthej\u00eb vler\u00ebn e y p\u00ebrndryshe. Shembuj: p\u00ebr x_or_y(7, 34, 12) == 34 p\u00ebr x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Mendoj se t\u00eb gjith\u00eb e mbajm\u00eb mend at\u00eb ndjenj\u00eb kur p\u00ebrfundimisht dihet rezultati i ndonj\u00eb ngjarjeje t\u00eb pritur prej koh\u00ebsh. Ndjenjat dhe mendimet q\u00eb keni n\u00eb at\u00eb moment jan\u00eb patjet\u00ebr t\u00eb vlefshme p\u00ebr t'u sh\u00ebnuar dhe krahasuar. Detyra juaj \u00ebsht\u00eb t\u00eb p\u00ebrcaktohet n\u00ebse nj\u00eb person ka menduar sakt\u00eb rezultatet e nj\u00eb numri ndeshjesh. Ju u jepen dy renditje t\u00eb rezultateve dhe gjasimeve me gjat\u00ebsi t\u00eb barabart\u00eb, ku secili indeks tregon nj\u00eb ndeshje. Kthehet nj\u00eb renditje me t\u00eb nj\u00ebjt\u00ebn gjat\u00ebsi q\u00eb tregon se sa larg ishte \u00e7do gjasim. N\u00ebse ata kan\u00eb menduar sakt\u00eb, vlera \u00ebsht\u00eb 0, dhe n\u00ebse jo, vlera \u00ebsht\u00eb diferenca absolute midis gjasimit dhe rezultatit. shembull: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3][0], [0,0,4,4,1,0,\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Do t'ju jepet emri i nj\u00eb klase (nj\u00eb varg) dhe nj\u00eb list\u00eb e zgjatjeve. Zgjatjet do t\u00eb p\u00ebrdoren p\u00ebr t\u00eb ngarkuar klasa shtes\u00eb n\u00eb klas\u00eb. Forca e zgjatjes \u00ebsht\u00eb si m\u00eb posht\u00eb: Le t\u00eb jet\u00eb CAP numri i shkronjave t\u00eb m\u00ebdha n\u00eb emrin e zgjatjes, dhe le t\u00eb jet\u00eb SM numri i shkronjave t\u00eb vogla n\u00eb emrin e zgjatjes, forca \u00ebsht\u00eb dh\u00ebn\u00eb nga fraksioni CAP - SM. Ju duhet t\u00eb gjeni zgjatjen m\u00eb t\u00eb fort\u00eb dhe t\u00eb ktheni nj\u00eb varg n\u00eb k\u00ebt\u00eb format: ClassName.StrongestExtensionName. N\u00ebse ka dy ose m\u00eb shum\u00eb zgjatje me t\u00eb nj\u00ebjt\u00ebn forc\u00eb, ju duhet t\u00eb zgjidhni at\u00eb q\u00eb vjen e para n\u00eb list\u00eb. P\u00ebr shembull, n\u00ebse ju jepet \"Slices\" si klasa dhe nj\u00eb list\u00eb e zgjatjeve: ['SEviRNGSliCes',\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Ju jan\u00eb dh\u00ebn\u00eb 2 fjal\u00eb. Ju duhet t\u00eb kthehet True n\u00ebse fjala e dyt\u00eb ose ndonj\u00eb nga rrotullimet e saj \u00ebsht\u00eb nj\u00eb n\u00ebnstring n\u00eb fjal\u00ebn e par\u00eb cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb, kthehet nj\u00eb tuple q\u00eb ka numrin e shifrave t\u00eb \u00e7ifta dhe t\u00eb \u00e7ifta p\u00ebrkat\u00ebsisht. Shembull: edhe_\u00e7ifti_\u00e7ifti(-12) ==> (1, 1) edhe_\u00e7ifti_\u00e7ifti(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb num\u00ebr t\u00eb plot\u00eb pozitiv, merrni ekuivalentin e tij numerik romak si nj\u00eb varg dhe kthejeni at\u00eb n\u00eb shkronja t\u00eb vogla.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Shkruaj nj\u00eb funksion q\u00eb pranon nj\u00eb list\u00eb me vargje. Lista p\u00ebrmban fjal\u00eb t\u00eb ndryshme. Kthej fjal\u00ebn me numrin maksimal t\u00eb karaktereve unike. N\u00ebse vargjet e shumta kan\u00eb numrin maksimal t\u00eb karaktereve unike, kthe at\u00eb q\u00eb vjen i pari n\u00eb rendin leksikografik.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Ju jeni nj\u00eb lepur i uritur, dhe ju tashm\u00eb keni ngr\u00ebn\u00eb nj\u00eb num\u00ebr t\u00eb caktuar karrota, por tani ju duhet t\u00eb hani m\u00eb shum\u00eb karrota p\u00ebr t\u00eb p\u00ebrfunduar ushqimet e dit\u00ebs. ju duhet t\u00eb kthej\u00eb nj\u00eb mas\u00eb t\u00eb [numri total i karrotave t\u00eb ngr\u00ebn\u00eb pas vakteve tuaja, numri i karrotave t\u00eb mbetur pas vakteve tuaja ] n\u00ebse nuk ka mjaftuesh\u00ebm karrota t\u00eb mbetura, ju do t\u00eb hani t\u00eb gjitha karrota t\u00eb mbetura, por ende do t\u00eb jet\u00eb i uritur. Shembull: * hani(5, 6, 10) -> [11, 4] * hani(4, 8, 9) -> [12, 1] * hani(1, 10, 10) -> [11, 0] * hani(2, 11, 5) -> [7, 0] Variable: @number: num\u00ebr i plot\u00eb i numrit t\u00eb karrotave q\u00eb ju keni ngr\u00ebn\u00eb. @need: numri i plot\u00eb i karrotave q\u00eb ju duhet t\u00eb\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Operator dhe operand. Lista e par\u00eb ka operacione themelore algjebrike, dhe lista e dyt\u00eb \u00ebsht\u00eb nj\u00eb list\u00eb e integrave. P\u00ebrdorni dy listat e dh\u00ebna p\u00ebr t\u00eb nd\u00ebrtuar shprehjen algjebrike dhe p\u00ebr t\u00eb kthyer vler\u00ebsimin e k\u00ebtij shprehjeje. Operacionet themelore algjebrike: Shtimi ( +) Z\u00ebvler\u00ebsimi ( -) Shum\u00ebzimi ( *) Ndarja e katit ( \/\/) Eksponentimi ( ** Shembull) Operator['+', '*', '-'] Array = [2, 3, 4, 5] Rezultati = 2 + 3 * 4 - 5 => Rezultati = 9 Sh\u00ebnim: Gjat\u00ebsia e list\u00ebs s\u00eb operatorit \u00ebsht\u00eb e barabart\u00eb me gjat\u00ebsin\u00eb e list\u00ebs s\u00eb operandit minus nj\u00eb. Operand \u00ebsht\u00eb nj\u00eb list\u00eb e integrave jo-negativ\u00eb. Operatori ka t\u00eb pakt\u00ebn nj\u00eb list\u00eb operator\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"N\u00ebse s[i] \u00ebsht\u00eb nj\u00eb shkronj\u00eb, kthejeni rastin e saj nga m\u00eb posht\u00eb n\u00eb sip\u00ebr ose kund\u00ebrt, p\u00ebrndryshe e lini ashtu si\u00e7 \u00ebsht\u00eb. N\u00ebse shkronja nuk p\u00ebrmban shkronja, kthejeni shkronjen. Funksioni duhet t\u00eb kthej\u00eb shkronjen e rezultuar. Shembuj zgjidhje ((\"1234\") = \"4321\" zgjidhje ((\"ab\") = \"AB\" zgjidhje ((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Duke pasur parasysh nj\u00eb varg 'tekst', kthehet vargu i tij ekuivalent md5 hash. N\u00ebse 'tekst' \u00ebsht\u00eb nj\u00eb varg i zbraz\u00ebt, kthehet Asnj\u00eb.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Duke pasur parasysh dy numra t\u00eb plot\u00eb pozitiv\u00eb a dhe b, kthe numrat e \u00e7ift midis a dhe b, n\u00eb rendin ngjit\u00ebs. P\u00ebr shembull: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]