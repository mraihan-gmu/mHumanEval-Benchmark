task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,gla_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Thoir sùil a bheil ann an liosta nan àireamhan, dà àireamhan nas fhaisge air a chèile na an tràth-ìre a chaidh a thoirt seachad. Eisimpleir: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,gla_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Tha an gnìomh seo a 'toirt a-steach sreang a tha a' toirt a-steach grunn bhuidhnean de phràinteasan snàithleach. Is e an amas agad na buidhnean sin a sgaradh ann an sreangan fa leth agus an liosta sin a thilleadh. Tha buidhnean fa leth cothromach (tha gach brace fosgailte air a dhùnadh gu ceart) agus chan eil iad snàithleach a-staigh a chèile Gun a bhith a 'toirt aire do spàsan sam bith anns an sreang inntrigidh. Eisimpleir: >>> separate_paren_groups' ((()) (() ((()))) ' ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,gla_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Le àireamh adhartach le puing-cùil, faodar a bhriseadh sìos gu pàirt iomlaideach (an àireamh iomlaideach as motha nas lugha na an àireamh a chaidh a thoirt seachad) agus deicheamaidean (an pàirt a tha air fhàgail an-còmhnaidh nas lugha na 1).""""""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,gla_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Tha liosta de ghnìomhan tasgaidh agus tarraing air ais air cunntas banca a' tòiseachadh le cothromachadh àirinneach. 'S e an obair agad a bhith a' lorg ma tha cothromachadh a' chunntais a' tuiteam fo àirinneach aig àm sam bith, agus aig an àm sin bu chòir don fheart True a thilleadh.""""""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,gla_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Airson liosta de dh'àireamhan inntrigidh, dèan co-dhùnadh mu mheadhan an t-sliabh iomlan timcheall air meadhan an t-seata dàta seo. 'S e meadhan an t-sliabh iomlan an eadar-dhealachadh iomlan eadar gach eileamaid agus meadhan (meadhan sa chùis seo): MAD = meadhan. x - x_mean. Eisimpleir: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,gla_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Cuir a-steach àireamh 'delimeter' eadar gach dà eileamaid leantainneach de liosta inntrigidh `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,gla_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Tha an t-suidheachadh seo a 'toirt a-steach sreang a tha a' riochdachadh iomadh buidheann airson parentheses neadaichte air an sgaradh le spàsaichean. Airson gach buidheann, cuir a-mach an ìre as doimhne de neadachadh parentheses. Mar eisimpleir, tha dà ìre de neadachadh aig (() (()) agus tha trì aig ((()))""""""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,gla_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filter a-steach liosta de shreathan a-mhàin airson feadhainn a tha a 'toirt a-steach substring >>> filter_by_substring([], 'a') [] >>> filter_by_substring([' abc ', 'bacd', 'cde', 'array'], 'a') [' abc ', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,gla_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Airson liosta de dh'àireamhan iomlan, tilleadh tuple a tha a' gabhail a-steach suim agus toradh nan àireamhan iomlan ann an liosta. Bu chòir gum bi suim falamh co-ionann ri 0 agus bu chòir gum bi toradh falamh co-ionann ri 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,gla_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Bho liosta de dh'àireamhan iomlan, cruthaich liosta de na h-eileamaidean as motha a chaidh a lorg gu àm sònraichte san t-sreath. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,gla_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Lorg am palindrome as giorra a tha a' tòiseachadh le sreang air a thoirt seachad. Tha beachd an algorithm sìmplidh: - Lorg an postfix as fhaide de sreang air a thoirt seachad a tha na palindrome. - Cuir ri deireadh an sreang cùl-taobh de ro-chruaidh sreang a tha a 'tighinn ron fhilleadh palindromic. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('cata') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Deuchainn ma tha sreath a chaidh a thoirt seachad na palindrome """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,gla_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Tha an t-ionad a-steach dà shreath a agus b a tha a' gabhail a-steach 1s agus 0s a-mhàin. Dèan XOR dà-shreath air na h-ionadan sin agus tilleadh toradh cuideachd mar shreath. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,gla_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""A-mach à liosta nan sreathan, tilleadh an tè as fhaide. Tilleadh a 'chiad fhear ma tha grunn sreathan den aon fhad ann. Tilleadh None ma tha an liosta inntrigidh falamh. >>> as fhaide (([]) >>> as fhaide ((['a', 'b', 'c']) 'a' >>> as fhaide ((['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,gla_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Thoir air ais an roinntear as motha coitcheann de dhà àireamhan iomlan a agus b >>> greatest_common_divisor ((3, 5) 1 >>> greatest_common_divisor ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,gla_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Bidh liosta a' tilleadh de na ro-chruinneachain uile bhon as giorra chun as fhaide den shreang inntrigidh >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,gla_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Cuir a-steach sreath a tha a 'toirt a-steach àireamhan air an crìochnachadh le àite a' tòiseachadh bho 0 gu n a 'gabhail a-steach. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,gla_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Le bhith a 'toirt sreang, faigh a-mach cia mheud caractar eadar-dhealaichte (ge bith dè an t-suidheachadh) a tha ann >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,gla_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Tha an gnìomh seo a 'toirt a-steach sreang a tha a' riochdachadh notaichean ciùil ann an cruth sònraichte ASCII. Is e an obair agad liosta sreang de chòrdan iomlan a phàirceadh a tha a 'freagairt ri mòran bhuaidhean a tha a' dèanamh. Seo uirsgeul: 'o' nota, lasts beats 'oImana' ceithir - leth nota, lasts dà beats 'oImana' - cuater nota, lasts aon beat >>> parse_music. 'o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o. o""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,gla_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Faigh a-mach cia mheud uair a lorgar fo-shreang san t-sreang tùsail. Cunntadh nan cùisean a tha a' cur thairis. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,gla_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Tha an t-ionad-steach na shreang deimhinn air a chriochnachadh le àite bho 'zero' gu 'nine'. Tha roghainnean dligheach 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' agus 'nine'. Thoir air ais an t-sreang le àireamhan air an seòrsachadh bhon as lugha chun as motha >>> sort_numbers (('three one five') 'one three five' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,gla_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Bho liosta de àireamhan a chaidh a thoirt seachad (de dh'fhaid co-dhiù dhà) tagh agus tilg dà a tha as fhaisge air a chèile agus tilg iad ann an òrdugh (àireamhair nas lugha, àireamhair nas motha). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,gla_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Air liosta de àireamhan (de dhà eileamaid co-dhiù), cuir cruth-atharrachadh loidhneach ris an liosta sin, mar gum bi an àireamh as lugha a 'fàs 0 agus am fear as motha a' fàs 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,gla_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter given list of any python values only for integers >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,gla_Latn,python,"

def strlen(string: str) -> int:
    """"""Dàil air ais de shreang a chaidh a thoirt seachad >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,gla_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Airson àireamh n, lorg an àireamh as motha a tha a' roinn n gu cothromach, nas lugha na n >>> largest_divisor ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,gla_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Bidh an liosta a' tilleadh de phrìomh fhactaran de dh'àireamhair a chaidh a thoirt seachad ann an òrdugh bho as lugha gu as motha. Bu chòir gach aon de na factaran a bhith air an liostadh àireamh de thursan a tha a' co-fhreagairt ri cia mheud uair a tha e a' nochdadh ann am factarachadh. Bu chòir àireamh an ion-chuir a bhith co-ionann ri toradh nan factaran uile >>> factarachadh ((8) [2, 2, 2] >>> factarachadh ((25) [5, 5] >>> factarachadh ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,gla_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Bho liosta de dh'àireamhan iomlana, cuir às do na h-eileamaidean a tha a' tachairt barrachd air aon uair. Cùm òrdugh nan eileamaidean air an fhàgail mar a bha san inntrigidh. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,gla_Latn,python,"

def flip_case(string: str) -> str:
    """"""Airson sreath sònraichte, flip charactaran beaga gu mòr agus mòr gu beaga. >>> flip_case ((('Hello') 'HELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,gla_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Concatenate liosta de shreathan ann an aon shreang >>> concatenate([]) '' >>> concatenate(['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,gla_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filter a-steach liosta de shreathan a-mhàin airson feadhainn a tha a 'tòiseachadh le ro-shealladh a thoirt seachad. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,gla_Latn,python,"

def get_positive(l: list):
    """"""Cuir air ais na h-àireamhan adhartach a-mhàin san liosta. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,gla_Latn,python,"

def is_prime(n):
    """"""Thoir air ais fìor ma tha àireamh a chaidh a thoirt seachad prìomhach, agus meallta air dhòigh eile. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,gla_Latn,python,"import math


def poly(xs: list, x: float):
    """"""Tha xs nan co-mheasgairean de polynomial. find_zero lorg x mar sin gu bheil poly ((x) = 0. find_zero a 'tilleadh dìreach dìreach puing neoni, eadhon ged a tha mòran ann. A bharrachd air an sin, chan eil find_zero a' gabhail ach liosta xs aig a bheil àireamh eadhon de chom-mheasgairean agus an co-mheasgaire neo-neolar as motha oir tha e a 'gealltainn fuasgladh. >>> round ((find_zero[(1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Bidh e a' meudachadh polynomial le co-fhaireachdainnean xs aig puing x. tilleadh xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,gla_Latn,python,"

def sort_third(l: list):
    """"""Bidh an gnìomh seo a 'gabhail liosta l agus a' tilleadh liosta l 'a leithid gu bheil l 'co-ionann ri l anns na clàran-amais nach eil roinnte le trì, fhad' s a tha na luachan aige aig na clàran-amais a tha roinnte le trì co-ionann ri luachan nan clàran-amais co-fhreagarrach de l, ach air an seòrsachadh. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,gla_Latn,python,"

def unique(l: list):
    """"""A 'tilleadh eileamaidean sònraichte air an seòrsachadh ann an liosta >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,gla_Latn,python,"

def max_element(l: list):
    """"""Cuir air ais an eileamaid as motha san liosta. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,gla_Latn,python,"

def fizz_buzz(n: int):
    """"""Thoir air ais an àireamh de thursan a tha an àireamh 7 a 'nochdadh ann an àireamhan iomlan nas lugha na n a tha roinnte le 11 no 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,gla_Latn,python,"

def sort_even(l: list):
    """"""Tha an gnìomh seo a 'gabhail liosta l agus a' tilleadh liosta l 'a leithid gu bheil l 'co-ionann ri l anns na clàran neo-iomlan, fhad' s a tha na luachan aige aig na clàran eadhon co-ionann ri luachan nan clàran eadhon de l, ach air an seòrsachadh. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,gla_Latn,python,"

def encode_cyclic(s: str):
    """"""Bidh an t-atharrachadh a 'toirt air ais sreang air a dhealbhadh le gnìomh encode_cyclic.""""""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""Bidh e a' tilleadh sreath chòdaichte le buidhnean rothaireachd de thrì charactaran.""""""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,gla_Latn,python,"

def prime_fib(n: int):
    """"""Bidh prime_fib a 'tilleadh an n-mhòr àireamh a tha na àireamh Fibonacci agus tha e cuideachd prìomhach. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,gla_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""Bidh triples_sum_to_zero a 'gabhail liosta de dh' àireamhan iomlana mar inntrigidh. Bidh e a' tilleadh True ma tha trì eileamaidean eadar-dhealaichte san liosta a tha a 'cur gu neoni, agus False air an làimh eile. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,gla_Latn,python,"

def car_race_collision(n: int):
    """"""Smaoinich air rathad a tha gu tur dìreach loidhne neo-chrìochnach fada. n càraichean a 'draibheadh air an làimh chlì gu deas; aig an aon àm, seata eadar-dhealaichte de n càraichean a' draibheadh air an làimh dheis gu clì. Tha an dà sheata de chàraichean a 'tòiseachadh a bhith gu math fada bho chèile. Tha a h-uile càr a' gluasad anns an aon astar. Tha dà chàraichean air an ràdh a 'bualadh nuair a bhuaileas càr a tha a' gluasad air an làimh chlì gu deas càr a tha a' gluasad air an làimh dheis gu clì. Ach, tha na càraichean neo-chrìochnach làidir agus làidir; mar thoradh air an sin, bidh iad a 'leantainn air adhart anns an traighteireachd aca mar nach do bhuail iad. Tha an gnìomh seo a' toirt a-mach an àireamh de cho-bhuaidhean mar sin. """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,gla_Latn,python,"

def incr_list(l: list):
    """"""Bidh liosta air ais le eileamaidean air an àrdachadh le 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,gla_Latn,python,"

def pairs_sum_to_zero(l):
    """"""Bidh pairs_sum_to_zero a 'gabhail liosta de àireamhan iomlana mar inntrigidh. Bidh e a' tilleadh True ma tha dà eileamaid eadar-dhealaichte san liosta a tha a 'cur gu neoni, agus False air an làimh eile. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,gla_Latn,python,"

def change_base(x: int, base: int):
    """"""Atharraich bun-àireimh àireamh inntrigidh x gu bun-àireimh. cuir riochdachadh sreang air ais às deidh an tionndadh. tha àireamhan bunaiteach nas lugha na 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,gla_Latn,python,"

def triangle_area(a, h):
    """"""Air a thoirt seachad fad taobh agus àrd-chuairtean tilleadh airson triantanach. >>> triangle_area(5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,gla_Latn,python,"

def fib4(n: int):
    """"""Tha sreath àireamhachaidh Fib4 coltach ri sreath Fibbonacci a tha air a mhìneachadh mar a leanas: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Sgrìobh gnìomh gus an n-eileamaid de sreath àireamhachaidh Fib4 a cho-dhùnadh gu h-èifeachdach. Na cleachd ath-aithris. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,gla_Latn,python,"

def median(l: list):
    """"""Cuir air ais meadhan nan eileamaidean san liosta l. >>> meadhan (([3, 1, 2, 4, 5]) 3 >>> meadhan (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,gla_Latn,python,"

def is_palindrome(text: str):
    """"""Bidh e a' sgrùdadh a bheil sreath a chaidh a thoirt seachad na palindrome >>> is_palindrome (('') True >>> is_palindrome (('aba') True >>> is_palindrome (('aaaaa') True >>> is_palindrome (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,gla_Latn,python,"

def modp(n: int, p: int):
    """"""Thoir air ais 2 ^ n modulo p (a bhith mothachail air àireamhan). >>> modp (((3, 5) 3 >>> modp (((1101, 101) 2 >>> modp (((0, 101) 1 >>> modp (((3, 11) 8 >>> modp ((100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,gla_Latn,python,"

def encode_shift(s: str):
    """"""Bidh an t-atharrachadh a 'toirt air ais sreang air a dhealbhadh le gnìomh encode_shift. Bidh e a' tilleadh sreang air a dhealbhadh. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""Bidh e a' tilleadh sreath còdaichte le bhith a' gluasad gach caractar le 5 anns an aibideil.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,gla_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels is a function that takes string and returns string without vowels. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,gla_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Cuir air ais True ma tha na h-àireamhan uile san liosta l fo thasgadh t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,gla_Latn,python,"

def add(x: int, y: int):
    """"""Cuir dà àireamh x agus y ris >>> cuir ris ((2, 3) 5 >>> cuir ris ((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,gla_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Thoir sùil a bheil an aon charactar aig dà fhacal. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') Fìor >>> same_chars (('abcd', 'dddddddabc') Fìor >>> same_chars (('dddddddabc', 'abcd') Fìor >>> same_chars (('eabcd', 'dddddddabc') False >>> same_chars ((('abcd', 'dddddabddce') False >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') False """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,gla_Latn,python,"

def fib(n: int):
    """"""Cuir a-steach an n-mhòr àireamh Fibonacci. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,gla_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets is a string of ""<"" and "">"". return True if every opening bracket has a corresponding closing bracket. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,gla_Latn,python,"

def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing. >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,gla_Latn,python,"

def common(l1: list, l2: list):
    """"""Air ais air a sheòrsachadh eileamaidean coitcheann sònraichte airson dà liosta. >>> coitcheann (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> coitcheann (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,gla_Latn,python,"

def largest_prime_factor(n: int):
    """"""Thoir air ais am factar prìomha as motha de n. Gabh ris gu bheil n > 1 agus nach e prìomhach a th 'ann. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,gla_Latn,python,"

def sum_to_n(n: int):
    """"""Tha sum_to_n na dhreuchd a tha a 'cur àireamhan bho 1 gu n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,gla_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets is a string of ""("" and "")"". return True if every opening bracket has a corresponding closing bracket. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") True >>> correct_bracketing("") False """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,gla_Latn,python,"

def derivative(xs: list):
    """"""Tha xs a' riochdachadh co-mheasan polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Cuir air ais earrann a' pholinomial seo san aon fhoirm. >>> earrann (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> earrann (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,gla_Latn,python,"

def fibfib(n: int):
    """"""Tha sreath àireamhan FibFib na sreath coltach ri sreath Fibbonacci a tha air a mhìneachadh mar a leanas: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Sgrìobh gnìomh gus an n-mhìos eileamaid de sreath àireamhan fibfib a cho-dhùnadh gu h-èifeachdach. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,gla_Latn,python,"
FIX = """"""Sgrìobh gnìomh vowels_count a tha a' gabhail sreang a tha a' riochdachadh facal mar inntrigidh agus a' tilleadh an àireamh de bhòtaichean anns an sreang. 'S e 'a', 'e', 'i', 'o', 'u' na bhòtaichean anns a' chùis seo. An seo, 'y' cuideachd na bhòtaiche, ach a-mhàin nuair a tha e aig deireadh na briathra a chaidh a thoirt seachad. Eisimpleir: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Cuir barrachd chùisean deuchainn ris. """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,gla_Latn,python,"
def circular_shift(x, shift):
    """"""Cuir cearcall air na h-àireamhan den t-àireamhair x, cuir na h-àireamhan gu deas le gluasad agus tilleadh an toradh mar shreang. Ma tha gluasad > àireamh de dh'àireamhan, tilleadh àireamhan air ais. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,gla_Latn,python,"
def digitSum(s):
    """"""Dreuchd Cìobair a 'sgrìobhadh gnìomh a tha a' gabhail sreang mar inntrigidh agus a 'tilleadh suim nan caractaran àrd a-mhàin' còdan ASCII. Eisimpleirean: digitSum ((("""") => 0 digitSum (((""abAB"") => 131 digitSum (((""abcCd"") => 67 digitSum (((""helloE"") => 69 digitSum (((""woArBld"") => 131 digitSum (((""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,gla_Latn,python,"
def fruit_distribution(s,n):
    """"""Anns an obair seo, thèid sreath a thoirt dhut a tha a 'riochdachadh àireamh de dh' ubhal agus orannan a tha air an sgaoileadh ann am basgaid de thortan anns a bheil uighean, uighean agus mango. Le bhith a 'toirt seachad an sreath a tha a' riochdachadh àireamh iomlan nan uighean agus uighean agus àireamh iomlan a tha a 'riochdachadh àireamh iomlan nan toradh anns a 'bhasgaid tilleadh àireamh nan toradh mango anns a' bhasgaid. airson eisimpleir: fruit_distribution""5(uighean agus 6 uighean"", 19) -> 19 - 5 - 6 = 8 fruit_distribution""0 uighean agus 1 uighean"",3) -> 3 - 0 - 1 = 2 fruit_distribution""2 uighean agus 3 uighean"", 100) -> 100 - 2 - 3 = 95 fruit_distribution""100 uighean agus 1 uighean"",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,gla_Latn,python,"
def pluck(arr):
    """"""""Le bhith a' toirt seachad sreath a tha a' riochdachadh meur craoibhe aig a bheil nodan iom-fhillte neo-mheadhain, is e an obair agad aon de na nodan a thogail agus a thilleadh. Bu chòir don nod a chaidh a thogail a bhith na nod leis an luach eadhon as lugha. Ma lorgar grunn nodan leis an aon luach eadhon as lugha, tilg an nod aig a bheil an t-siostam as lugha. Bu chòir don nod a chaidh a thogail a thilleadh ann an liosta, [small_value, an t-siostam aige], Mura h-eil luachan eadhon ann no ma tha an sreath a chaidh a thoirt seachad falamh, tilg []. Eisimpleir 1: Input: [4,2,3] Output: [2, 1] Mìneachadh: 2 an luach eadhon as lugha, agus 2 an t-siostam as lugha. Eisimpleir 2: Input: [1,2,3] Output: [2, 1] Mìneachadh: 2 an luach eadhon as lugha, agus 2 an t-siostam as lugha. Eisimpleir 3: Input: [] Output: [4: [5, 3, 4, 2] Input: [0, 0] Output: 1 is e an nod as lugha, ach tha an t-siostam as lugha, mar sin tha an luach as lugha. * Tha dà shealladh ann, mar sin, bidh sinn a 'g a' taghadh an nod as lugha.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,gla_Latn,python,"
def search(lst):
    '''Tha liosta neo-folamh de dh'àireamhan iomlan adhartach air a thoirt dhut. Thoir air ais an àireamh iomlan as motha a tha nas motha na neoni, agus aig a bheil tricead nas motha na no co-ionann ri luach an àireimh fhèin. Is e tricead àireamh iomlan an àireamh de thursan a tha e a' nochdadh san liosta. Mura h-eil luach mar sin ann, tilg -1.'''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,gla_Latn,python,"
def strange_sort_list(lst):
    '''A 'toirt seachad liosta de dh' àireamhan, cuir air ais liosta ann an òrdugh neònach. Tha seòrsachadh neònach, nuair a thòisicheas tu leis an luach as lugha, an uairsin as motha de na h-àireamhan a tha air fhàgail, an uairsin as lugha agus mar sin air adhart. Eisimpleirean: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,gla_Latn,python,"
def triangle_area(a, b, c):
    '''Air a thoirt seachad fad nan trì taobhan de thri-cheàrnach. Thèid raon an tri-cheàrnach a thilleadh air a thionndadh gu 2 puing deicheach ma tha na trì taobhan a' dèanamh tri-cheàrnach dligheach. A-mach às sin, thèid -1 a thilleadh Tha trì taobhan a' dèanamh tri-cheàrnach dligheach nuair a tha suim nan dà thaobh nas motha na an treas taobh. Eisimpleir: triangle_area(3, 4, 5) == 6.00 triangle_area(1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,gla_Latn,python,"
def will_it_fly(q,w):
    '''Sgrìobh gnìomh a thilleas True ma bhios an nì q ag itealaich, agus False air an làimh eile. Bidh an nì q ag itealaich ma tha e cothromach (tha e na liosta palindromic) agus tha suim nan eileamaidean aige nas lugha na no co-ionann ris a 'char as motha a ghabhas a bhith a' cuideam w. Eisimpleir: will_it_fly (([1, 2], 5) â -> False # 1+2 is less than the maximum possible weight, but it's unbalanced. will_it_fly (([3, 2, 3], 1) â -> False # tha e cothromach, ach tha 3+2+3 nas motha na an cuideam as motha a ghabhas a bhith a 'cur. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 is less than the maximum possible weight, and it's balanced. will_it_fly ((([3], â 5) -> True # 3 is less than the maximum possible weight, and it's balanced. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,gla_Latn,python,"
def smallest_change(arr):
    """"""Le bhith a 'toirt seachad sreath de àireamhan iomlana, lorg an àireamh as lugha de eileamaidean a dh' fheumar atharrachadh gus an sreath a dhèanamh palindromic. Tha sreath palindromic na sreath a tha air a leughadh san aon dòigh air ais agus air adhart. Ann an aon atharrachadh, faodaidh tu aon eileamaid atharrachadh gu eileamaid sam bith eile. Mar eisimpleir: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,gla_Latn,python,"
def total_match(lst1, lst2):
    '''Sgrìobh gnìomh a ghabhas dà liosta de shreathan agus a thilleas an liosta aig a bheil àireamh iomlan de charactaran anns a h-uile sreathan den liosta nas lugha na an liosta eile. ma tha an aon àireamh de charactaran aig an dà liosta, tilg a 'chiad liosta. Eisimpleirean total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi]) â -> ['hI', 'hi'], 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,gla_Latn,python,"
def is_multiply_prime(a):
    """"""Sgrìobh gnìomh a thilleas fìor ma tha an àireamh a chaidh a thoirt seachad na iomadachadh de 3 àireamhan prìomhach agus ceàrr air dhòigh eile. A 'faighinn a-mach gu bheil (a) nas lugha na 100.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,gla_Latn,python,"
def is_simple_power(x, n):
    """"""Is e an obair agad gnìomh a sgrìobhadh a th 'ann a tha a' tilleadh fìor ma tha àireamh x na cumhachd sìmplidh de n agus meallta ann an cùisean eile. tha x na cumhachd sìmplidh de n ma tha n**int = x Mar eisimpleir: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,gla_Latn,python,"
def iscube(a):
    '''Sgrìobh gnìomh a bheir àireamh iomlan a agus a thilleas True ma tha an t-ionad seo na chuib de àireamh iomlan. Nota: faodaidh tu gabhail ris gu bheil an inntrigeadh daonnan dligheach. Eisimpleirean: iscube(1) ==> True iscube(2) ==> False iscube(-1) ==> True iscube(64) ==> True iscube(0) ==> True iscube(180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,gla_Latn,python,"
def hex_key(num):
    """"""Tha na h-àireamhan heideceimalach 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Tha na h-àireamhan prìomha 2, 3, 5, 7, 11, 13, 17,... Mar sin feumaidh tu àireamh de na h-àireamhan a leanas a dhearbhadh: 2, 3, 5, 7, B (= deimealach 11), D (= deimealach 13). Nota: faodaidh tu a bhith a 'gabhail ris gu bheil an t-suidheachadh an-còmhnaidh ceart no falamh, agus tha na samhlaidhean A, B, C, D, E, F, an-còmhnaidh mòr-litir.""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,gla_Latn,python,"
def decimal_to_binary(decimal):
    """"""Bidh an àireamh a tha air a thoirt dhut ann an cruth deicheal agus is e an obair agad a thionndadh gu cruth dà-mheadhanach. Bu chòir don fheart sreang a thilleadh, le gach caractar a 'riochdachadh àireamh dà-mheadhanach. Bidh gach caractar san sreang' 0 'no' 1 '. Bidh dà charactar a bharrachd' db 'ann an toiseach agus aig deireadh an sreang. Tha na caractaran a bharrachd ann gus cuideachadh leis a' chruth. Eisimpleirean: decimal_to_binary ((15) # a 'tilleadh ""db1111db"" decimal_to_binary32) # a' tilleadh ""db100000db"" """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,gla_Latn,python,"
def is_happy(s):
    """"""Tha sreang toilichte ma tha a dh'fhaid co-dhiù 3 agus gach 3 litrichean le chèile eadar-dhealaichte Mar eisimpleir: is_happy(a) => False is_happy(aa) => False is_happy(abcd) => True is_happy(aabb) => False is_happy(adb) => True is_happy(xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,gla_Latn,python,"
def numerical_letter_grade(grades):
    """"""Tha an t-seachdain mu dheireadh den t-seimeastar agus feumaidh an tidsear na h-ìrean a thoirt don oileanach. Tha an tidsear air a h-algorithm fhèin a dhèanamh airson a bhith a' toirt sgàile. Is e an aon dhuilgheadas, tha i air an còd a chleachd i airson a bhith a' toirt sgàile a chall. Tha i air liosta de GPAan a thoirt dhut airson cuid de dh'oileanaich agus feumaidh tu gnìomh a sgrìobhadh a dh'fhaodas liosta de sgàilean litrichean a thoirt a-mach a' cleachdadh a' chlàr a leanas: GPA. Litir ìre 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,gla_Latn,python,"
def prime_length(string):
    """"""Sgrìobh gnìomh a bheir sreang agus a thilleas True ma tha an fad sreang na àireamh phrìomh no False air an làimh eile Eisimpleirean prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,gla_Latn,python,"
def starts_one_ends(n):
    """"""Air a thoirt seachad àireamh iomlan adhartach n, tilleadh cunntadh nan àireamhan de àireamhan iomlan adhartach n-siubhail a tha a 'tòiseachadh no a' crìochnachadh le 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,gla_Latn,python,"
def solve(N):
    """"""Air a thoirt seachad àireamh iomlan adhartach N, tilleadh suim iomlan nan digit ann am binary. Eisimpleir Airson N = 1000, bidh suim nan digit 1 bu chòir an toradh a bhith ""1"". Airson N = 150, bidh suim nan digit 6 bu chòir an toradh a bhith ""110"". Airson N = 147, bidh suim nan digit 12 bu chòir an toradh a bhith ""1100"".""""""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,gla_Latn,python,"
def add(lst):
    """"""Air liosta neo-folamh de dh'àireamhan iomlana a thoirt seachad, cuir na h-eileamaidean eadhon a tha aig clàran neo-iomlan ris.""""""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,gla_Latn,python,"
def anti_shuffle(s):
    """"""Sgrìobh gnìomh a bheir sreang agus a thilleas dreach òrdaichte dheth. Tha dreach òrdaichte de sreang, na sreang far a bheil na faclan uile (air an sgaradh le àite) air an àite le facal ùr far a bheil na caractaran uile air an rèiteachadh ann an òrdugh ag èirigh stèidhichte air luach ascii. Nota: Bu chòir dhut òrdugh nam faclan agus na àiteachan falamh a chumail san abairt. Mar eisimpleir: anti_shuffle ((('Hi') a 'tilleadh' Hi 'anti_shuffle (('hello') a' tilleadh 'ehllo' anti_shuffle (('Hello World!!!') a 'tilleadh' Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,gla_Latn,python,"
def get_row(lst, x):
    """"""Tha dàta 2 dhìmeansail, mar liostaichean neadaichte, a tha coltach ri matrix, ge-tà, eu-coltach ri matris, faodaidh àireamh eadar-dhealaichte de cholbhan a bhith anns gach sreath. Le bhith a 'toirt seachad lst, agus àireamh iomlan x, lorg integers x san liosta, agus tilleadh liosta de tuples, [(x1, y1), (x2, y2) ...] mar sin gu bheil gach tuple na cho-òrdanachadh - (sreath, colbhan), a' tòiseachadh le 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,gla_Latn,python,"
def sort_array(array):
    """"""Le bhith a 'toirt seachad sreath de dh' àireamhan neo-mheadhain, tilg leth-bhreac den sreath a chaidh a thoirt seachad às deidh a bhith a' seòrsachadh, bidh thu a 'sòrdachadh an sreath a chaidh a thoirt seachad ann an òrdugh ag èirigh ma tha an suim ((an toiseach luach clàr-amais, luach clàr-amais mu dheireadh) neo-iomlan, no a' seòrsachadh ann an òrdugh a 'dol sìos ma tha an suim ((an toiseach luach clàr-amais, luach clàr-amais mu dheireadh) eadhon. Nota: * na bi ag atharrachadh an sreath a chaidh a thoirt seachad. Eisimpleirean: * sort_array[(]) => [] * sort_array([5]) => [5] * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,gla_Latn,python,"
def encrypt(s):
    """"""Cruthaich gnìomh encrypt a tha a 'gabhail sreang mar argamaid agus a' tilleadh sreang air a chrioptachadh leis an aibideil a tha air a thionndadh. Bu chòir an aibideil a thionndadh ann an dòigh gus am bi na litrichean a 'gluasad sìos le dhà air am iomadachadh gu dà àite. Mar eisimpleir: encrypt(' hi ') a' tilleadh 'lm' encrypt(' asdfghjkl ') a ' tilleadh 'ewhjklnop' encrypt(' gf ') a ' tilleadh 'kj' encrypt(' et ') a ' tilleadh 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,gla_Latn,python,"
def next_smallest(lst):
    """"""Tha liosta de àireamhan iomlan air a thoirt dhut. Sgrìobh gnìomh next_smallest (() a thilleas an dàrna eileamaid as lugha den liosta. Thilleas None mura h-eil eileamaid mar sin ann. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,gla_Latn,python,"
def is_bored(S):
    """"""Bidh sreath de fhaclan air a thoirt dhut, agus is e an obair agad an àireamh de bhrògan a chunntadh. 'S e bhròg abairt a tha a' tòiseachadh leis an fhacal ""I"". Tha abairtean air an crìochnachadh le '.', '?' no '!'. Mar eisimpleir: >>> is_bored ((""Hello world"") 0 >>> is_bored ((""Tha an speur gorm. Tha a' ghrian a' deàrrsadh. Is toil leam an aimsir seo"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,gla_Latn,python,"
def any_int(x, y, z):
    '''Cruthaich gnìomh a tha a' gabhail 3 àireamhan. Bidh e a' tilleadh fìor ma tha aon de na h-àireamhan co-ionann ri suim an dà eile, agus tha na h-àireamhan uile nan àireamhan. Bidh e a' tilleadh meallta ann an cùisean sam bith eile. Eisimpleirean any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,gla_Latn,python,"
def encode(message):
    """"""Sgrìobh gnìomh a tha a 'gabhail teachdaireachd, agus a' còdachadh ann an dòigh mar sin a tha e a 'dol an àite gach litir, a' cur an àite a h-uile vocal anns an teachdaireachd leis an litir a tha a 'nochdadh 2 àite air thoiseach air a' bhratach sin ann an aibideil na Beurla. Na h-eisimpleirean: >>> còdadh ((' test ') 'TGST' >>> còdadh ((' Is e teachdaireachd a tha seo ') ' tHKS KS C MGSSCGG ' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,gla_Latn,python,"

def skjkasdkd(lst):
    """"""Tha liosta de dh'àireamhan iomlan air a thoirt dhut. Feumaidh tu an luach prìomha as motha a lorg agus suim nan sioraman a thilleadh. Eisimpleirean: Airson lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] bu chòir don toradh a bhith 10 Airson lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] bu chòir don toradh a bhith 25 Airson lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] bu chòir don toradh a bhith 13 Airson lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] bu chòir don toradh a bhith 11 Airson lst = [0,81,12,31,21] bu chòir don toradh a bhith 3 Airson lst = [0,8,1,2,1,7] bu chòir don toradh a bhith 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,gla_Latn,python,"
def check_dict_case(dict):
    """"""Air a thoirt seachad leac-litir, tilleadh True ma tha na h-iuchraichean uile nan sreathan ann an litrichean beaga no na h-iuchraichean uile nan sreathan ann an litrichean mòra, air an làimh eile tilleadh False. Bu chòir don fheachd tilleadh False ma tha an fhaclair a chaidh a thoirt seachad falamh. Eisimpleirean: check_dict_case{""a"":""apple"", ""b"":""banana""}) bu chòir tilleadh True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) bu chòir tilleadh False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) bu chòir tilleadh False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) bu chòir tilleadh False. check_dict_case{""NC:""STATE"", ""Z"":""IP"":""45"") bu chòir tilleadh True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,gla_Latn,python,"
def count_up_to(n):
    """"""Cuir an gnìomh gnìomh a tha a 'gabhail àireamh-iomlan neo-mheallta agus a' tilleadh sreath de na ciad n àireamhan prìomhach agus nas lugha na n. mar eisimpleir: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,gla_Latn,python,"
def multiply(a, b):
    """"""Cuir crìoch air an gnìomh a tha a 'gabhail dà àireamh iomlan agus a' tilleadh toradh nan diogan aonad aca. Is dòcha gu bheil an toradh daonnan dligheach. Eisimpleirean: iomadachadh""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,gla_Latn,python,"
def count_upper(s):
    """"""Air a thoirt seachad sreath s, cunntadh an àireamh de bhòtaichean mòra ann an clàran eadhon. Mar eisimpleir: count_upper (('aBCdEf') a 'tilleadh 1 count_upper ((' abcdefg') a' tilleadh 0 count_upper ((' dBBE') a 'tilleadh 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,gla_Latn,python,"
def closest_integer(value):
    '''Cruthaich gnìomh a tha a' gabhail luach (string) a tha a' riochdachadh àireamh agus a' tilleadh an àireamh iomlan as fhaisge air. Ma tha an àireamh co-fharsainge bho dhà àireamh iomlan, cuir e air falbh bho neoni. Eisimpleirean >>> nearest_integer ((""10"") 10 >>> nearest_integer ((""15.3"") 15 Nota: Tha a bhith a' cruinnadh air falbh bho neoni a' ciallachadh ma tha an àireamh a chaidh a thoirt seachad co-fharsainge bho dhà àireamh iomlan, is e an tè a bu chòir dhut a thilleadh an tè as fhaisge air neoni. Airson eisimpleir bu chòir do nearest_integer "" ((14.5"") tilleadh 15 agus bu chòir do nearest_integer "" ((-14.5"") tilleadh -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,gla_Latn,python,"
def make_a_pile(n):
    """"""Air a thoirt seachad àireamh iomlan adhartach n, feumaidh tu cnuic de n ìre de chlochan a dhèanamh. Tha n chlochan anns a' chiad ìre. Is e an àireamh de chlochan anns an ath ìre: - an ath àireamh neo-iomchaidh ma tha n neo-iomchaidh. - an ath àireamh eadhon ma tha n eadhon. Thoir air ais an àireamh de chlochan anns gach ìre ann an liosta, far a bheil an eileamaid aig clàr-amais i a 'riochdachadh an àireamh de chlochan anns an ìre (i+1). Eisimpleirean: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,gla_Latn,python,"
def words_string(s):
    """"""Bidh sreath de fhaclan air an sgaradh le coma no le àitean. Is e an obair agad an sreath a sgaradh ann am faclan agus sreath de na faclan a thilleadh. Mar eisimpleir: words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,gla_Latn,python,"
def choose_num(x, y):
    """"""Tha an gnìomh seo a 'gabhail dà àireamh adhartach x agus y agus a' tilleadh an àireamh iomlan as motha a tha ann an raon [x, y] a 'gabhail a-steach. Mura h-eil an àireamh sin ann, an uairsin bu chòir don fheart -1 a thilleadh. Mar eisimpleir: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,gla_Latn,python,"
def rounded_avg(n, m):
    """"""Tha dà àireamh iomlan adhartach n agus m air an toirt dhut, agus is e an obair agad meadhan nan àireamhan iomlana bho n gu m a cho-dhùnadh (a' gabhail a-steach n agus m). Cuir timcheall an fhreagairt chun àireamh iomlan as fhaisge agus tionndadh gu dàimheach. Ma tha n nas motha na m, tilg -1. Eisimpleir: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b1111"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,gla_Latn,python,"
def unique_digits(x):
    """"""Air liosta de dh'àireamhan iomlan adhartach x a thoirt seachad, tilleadh liosta seòrsaichte de na h-eileamaidean uile nach eil sam bith eadhon. Nota: Bu chòir an liosta air ais a bhith air a sheòrsachadh ann an òrdugh a 'sìor fhàs. Mar eisimpleir: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,gla_Latn,python,"
def by_length(arr):
    """"""Mar eisimpleir: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""One"", ""One""] Ma tha an t-sreath falamh, cuir air ais sreath falamh: arr = [] return [] Ma tha àireamh neònach sam bith anns an t-sreath, thoir fa-near e: arr = [1, 1 , 55] -> arr -> [1, 1 , 55] -> reverse arr -> [55, 1] - return ['One'] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,gla_Latn,python,"
def f(n):
    """"""Cuir an gnìomh an gnìomh f a tha a 'gabhail n mar pharamadair, agus a' tilleadh liosta de mheud n, mar sin gu bheil luach an eileamaid aig clàr-amais i na factorial de i ma tha i eadhon no suim nan àireamhan bho 1 gu i air dhòigh eile. i a 'tòiseachadh bho 1. is e factorial i iomadachadh nan àireamhan bho 1 gu i (1 * 2 * ... * i). Eisimpleir: f(5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,gla_Latn,python,"
def even_odd_palindrome(n):
    """"""Air a thoirt seachad àireamh iomlan adhartach n, tilleadh tuple aig a bheil an àireamh de palindromes iom-fhillte agus neo-iom-fhillte a tha a 'tuiteam taobh a-staigh an raon ((1, n), a' gabhail a-steach. Eisimpleir1: Input: 3 toradh: (1, 2) mìneachadh: Tha palindromes iom-fhillte 1, 2, 3. tha aon dhiubh cothromach, agus tha dithis dhiubh neo-iomlan. Eisimpleir2: Input: 12 toradh: (4, 6) mìneachadh: Tha palindromes iom-fhillte 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. tha ceithir dhiubh cothromach, agus tha 6 dhiubh neo-iom-fhillte. Nota: 1. 1 <= n <= 10^3 2. tha tuple air an àireamh de palindromes iom-fhillte agus neo-iom-fhillte a thilleadh. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,gla_Latn,python,"
def count_nums(arr):
    """"""Sgrìobh gnìomh count_nums a tha a' gabhail sreath de dh'àireamhan iomlanach agus a' tilleadh an àireamh de eileamaidean aig a bheil suim de dhioghan > 0. Ma tha àireamh àicheil, an uairsin bidh a' chiad dhiogh ainm-sgrìobhte aige àicheil: m.e. -123 air a bhith a' comharrachadh dhioghan -1, 2, agus 3. >>> count_nums[]) == 0 >>> count_nums[-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,gla_Latn,python,"
def move_one_ball(arr):
    """"""Tha sreath againn 'arr' de N àireamhan slàn arr[1], arr[2], ..., arr[N].Bidh na h-àireamhan san sreath air an òrdugh gu h-aonta. Is e an obair agad a bhith a 'dearbhadh a bheil e comasach sreath a sheòrsachadh ann an òrdugh neo-lùghdail le bhith a' coileanadh an gnìomh a leanas air an sreath a chaidh a thoirt seachad: Tha cead agad obrachadh gluasad air an làimh dheis a dhèanamh àireamh de thursan. Aon obrachadh gluasad air an làimh dheis a 'ciallachadh a bhith a' gluasad a h-uile eileamaid den sreath le aon suidheachadh san t-slighe cheart. Thèid an eileamaid mu dheireadh den sreath a ghluasad chun àite tòiseachaidh san sreath ie 0th index. Ma tha e comasach an sreath a tha air a sheòrsachadh a thoirt seachad le bhith a 'coileanadh an gnìomh gu h-àrd an uairsin tilleadh True eile bidh e air ais False. Ma tha an sreath a chaidh a thoirt seachad falamh an uairsin tilleadh True. Nota: Tha an liosta a chaidh a thoirt seachad air a ghealltainn a bhith a' faighinn eileamaidean sònraichte. Mar eisimpleir: move_one_{{} ball[3, 4, 5, 2]]""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,gla_Latn,python,"
def exchange(lst1, lst2):
    """"""Anns an duilgheadas seo, bidh thu a 'cur an gnìomh gnìomh a tha a' gabhail dà liosta de àireamhan, agus a 'dearbhadh a bheil e comasach iomlaid eileamaidean eadar iad gus an dèan lst1 liosta de àireamhan eadhon a-mhàin. Chan eil crìoch air an àireamh de eileamaidean a chaidh iomlaid eadar lst1 agus lst2. Ma tha e comasach eileamaidean eadar an lst1 agus lst2 iomlaid gus a dhèanamh gu bheil na h-eileamaidean uile de lst1 eadhon, tilleadh ""YES"". San eileanas, tilleadh ""NO"". Mar eisimpleir: iomlaid [(1, 2, 3, 4], [1, 2, 3, 4]) => ""YES"" iomlaid [(1, 2, 3, 4], [1, 5, 3, 4]) => ""NO"" Tha e air a ghabhail a-steach nach bi na liostaichean inntrigidh falamh. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,gla_Latn,python,"
def histogram(test):
    """"""Mar eisimpleir: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4} histogram ((('a') == {'b 4}) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,gla_Latn,python,"
def reverse_delete(s,c):
    """"""Tha dà shreath s agus c air an toirt dhuinn, feumaidh tu na caractaran uile ann an s a dhubhadh às a tha co-ionann ri caractar sam bith ann an c an uairsin sgrùdadh a dhèanamh a bheil an sreath toradh palindrome. Canar sreath palindrome ma leughas e an aon rud air ais agus air adhart. Bu chòir dhut tuple a th 'ann a bhith a' toirt a-steach an sreath toradh agus True / False airson an sgrùdadh. Mar eisimpleir Airson s = ""abcde"", c = ""ae"", bu chòir don toradh a bhith ('bcd', False) Airson s = ""abcdef"", c = ""b"" bu chòir don toradh a bhith ('acdef', False) Airson s = ""abcdedcba"", c = ""ab"", bu chòir don toradh a bhith ('cdedc', True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,gla_Latn,python,"
def odd_count(lst):
    """"""Air liosta de shreathan, far nach eil gach sreang ach de dhiothan, tilleadh liosta. Bu chòir gach eileamaid i den toradh a bhith ""àireamhachadh nan eileamaidean neo-sheòrsach ann an sreang i den inntrigidh. "" far am bu chòir na h-i uile a bhith air an àite le àireamh nan diothan neo-sheòrsach anns an i'th sreang den inntrigidh. >>> odd_count['1234567']) [""an àireamh de eileamaidean neo-sheòrsach 4n an str4ng 4 den 4nput.""] >>> odd_count['3',""111111""]) [""an àireamh de eileamaidean neo-sheòrsach 1n an str1ng 1 den 1nput. "", ""an àireamh de eileamaidean neo-sheòrsach 8n an str8ng 8 den 8nput. ""] """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,gla_Latn,python,"
def minSubArraySum(nums):
    """"""Air a thoirt seachad sreath de àireamhan iomlanach, lorg an suim as lugha de sheòrsa-sreath sam bith de àireamhan nach eil falamh. Eisimpleir minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,gla_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Tha grid ceart-cheàrnach de thobhan-uisge air a thoirt dhut. Tha gach sreath a 'riochdachadh aon thobhan-uisge, agus gach 1 ann an sreath a' riochdachadh aon aonad uisge. Tha bucaid co-fhreagarrach aig gach tobar a ghabhas a chleachdadh gus uisge a thoirt a-mach às, agus tha an aon comas aig a h-uile bucaid. Is e an obair agad na bucaid a chleachdadh gus na tobhagan a shaoradh. Cuir a-mach an àireamh de thursan a dh 'fheumas tu na bucaid a thoirt sìos. Eisimpleir 1: Input: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Output: 62: Input: grid: [[0,0,1,1], [0,0,0,0,0], [1,1,1], [0,1,1,1]] bucket_capacity: 2 Output: 53: Input: [[:0,0,0], [0,0,0]] bucket_capacity well: 5 * 0 * * * * * * * * * 1 * * * * 1 * * * * 1 * * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 2 * 2 * 2 * 3 * 4 * * * * 2 * * * * * * * * * * * * 2 * 3 * 4 * 5 * 6 * * * 6 * * * * * * * * 6 * * * * * * 6 * 7 * * 7 * 8 * 9 * 9 * 10 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,gla_Latn,python,"
def sort_array(arr):
    """"""Anns an Kata seo, feumaidh tu sreath de dh'àireamhan neo-mheasgach a sheòrsachadh a rèir àireamh nan aonad anns an riochdachadh dà-mheadhanach aca ann an òrdugh a 'dol suas. Airson àireamh cho coltach de aonadan, seòrsachadh stèidhichte air luach deicheamach. Feumar a chuir an gnìomh mar seo: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,gla_Latn,python,"
def select_words(s, n):
    """"""Le bhith a 'toirt seachad sreang s agus àireamh nàdarra n, chaidh a chur an gnìomh dhut gnìomh a bheir air ais liosta de na faclan uile bho sreang s a tha a' toirt a-steach dìreach n consonants, gus am bi na faclan sin a 'nochdadh anns an sreang s. Ma tha an sreang s falamh, an uairsin bu chòir don ghnìomh liosta falamh a thilleadh. Nota: faodaidh tu a bhith a' gabhail ris nach eil anns an sreang inntrigidh ach litrichean agus àiteachan. Eisimpleirean: select_words ""Mary had a little lamb"", 4) ==> [""little""] select_words ""Mary had a little lamb"", 3) ==> [""Mary"", ""lamb""] select_words ""simple white space"", 2) ==> [] select_words ""Hello world"", 4) ==> [""world""] select_words ""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,gla_Latn,python,"
def get_closest_vowel(word):
    """"""Tha facal air a thoirt dhut. Is e an obair agad an t-uachdaran as fhaisge a lorg a tha eadar dà chòmhnard bhon taobh deas na facal (glèidhte ri cùis-litir). Chan eil na h-uachdaran aig toiseach agus aig deireadh air an cunntadh. Thoir air ais sreath falamh mura lorg thu aon ghuth a choinnich ris a 'cho-dhùnadh gu h-àrd. Is dòcha gun gabh thu a-mach gu bheil an sreath a chaidh a thoirt seachad a' toirt a-steach litir Beurla a-mhàin. Eisimpleir: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,gla_Latn,python,"
def match_parens(lst):
    '''Tha liosta de dhà shreang air a thoirt dhut, agus chan eil an dà shreang ach ann an parentheses fosgailte '(' no parentheses dùinte ') '. Is e an obair agad sgrùdadh a dhèanamh a bheil e comasach an dà shreang a cheangal ann an òrdugh, gum bi an t-sreang a thig às math. Tha sreang S air a mheas a bhith math ma tha agus a-mhàin ma tha a h-uile parentheses ann an S cothromach. Mar eisimpleir: tha an t-sreang '((()) ' math, fhad' s nach eil an t-sreang '()) '. Thèid 'Yes' a thilleadh ma tha dòigh ann sreang math a dhèanamh, agus thèid 'No' a thilleadh air ais air an làimh eile. Eisimpleirean: match_parens[('() ', ') ']) == 'Yes' match_parens[(') ', ') ']) == 'No' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,gla_Latn,python,"
def maximum(arr, k):
    """"""Le bhith a 'toirt seachad sreath de dh' àireamhan slàn agus àireamh slàn adhartach k, tilg liosta sreathach de dh' fhaid k leis na h-àireamhan k as motha ann an arr. Eisimpleir1: Input: arr = [-3, -4, 5], k = 3 Output: [-4, -3, 5] Eisimpleir2: Input: arr = [4, -4, 4], k = 2 Output: [4, 4] Eisimpleir3: Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Output: [2] Nota: 1. Bidh fad an sreath anns an raon de [1, 1000]. 2. Bidh na h-eileamaidean san sreath anns an raon de [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,gla_Latn,python,"
def solution(lst):
    """"""Air leth-liosta neo-folamh de dh'àireamhan iomlana, tilleadh suim nan eileamaidean neo-iomlan a tha ann an suidheachaidhean eadhon.""""""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,gla_Latn,python,"
def add_elements(arr, k):
    """"""Air a thoirt seachad sreath neo-folamh de àireamhan slàn arr agus àireamhan slàn k, tilleadh suim nan eileamaidean le dà dhiogal as motha bho na k eileamaidean as toiseach de arr. Eisimpleir: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr) """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,gla_Latn,python,"
def get_odd_collatz(n):
    """"""Le bhith a' toirt seachad àireamh iomlan adhartach n, tilleadh liosta air a sheòrsachadh anns a bheil na h-àireamhan neo-iomlan ann an sreath collatz. 'S e beachd-bheachd Collatz a th' ann am matamataigs a tha a' toirt a-steach sreath air a mhìneachadh mar a leanas: tòisich le àireamh iomlan adhartach n sam bith. An uairsin thèid gach teirm fhaighinn bhon teirm roimhe mar a leanas: ma tha an teirm roimhe cothromach, tha an ath teirm na leth den teirm roimhe. Ma tha an teirm roimhe neo-iomlan, tha an ath teirm 3 uairean na teirm roimhe a bharrachd 1. 'S e an beachd-bheachd gu bheil ge bith dè an luach de n, bidh an t-sreath an-còmhnaidh a' ruighinn 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,gla_Latn,python,"
def valid_date(date):
    """"""Feumaidh tu gnìomh a sgrìobhadh a bhaileas sreang ceann-latha sònraichte agus a thilleas True ma tha an ceann-latha dligheach air dhòigh eile False. Tha an ceann-latha dligheach ma tha na riaghailtean a leanas uile air an coinneachadh: 1. Chan eil an sreang ceann-latha falamh. 2. Chan eil an àireamh de làithean nas lugha na 1 no nas àirde na 31 latha airson mìosan 1,3,5,7,8,10,12. Agus chan eil an àireamh de làithean nas lugha na 1 no nas àirde na 30 latha airson mìosan 4,6,9,11. Agus, chan eil an àireamh de làithean nas lugha na 1 no nas àirde na 29 airson mìos 2. 3. Cha bu chòir na mìosan a bhith nas lugha na 1 no nas àirde na 12. 4. Bu chòir don cheann-latha a bhith san cruth: mm-dd-yyyy mar eisimpleir: valid_date (('03-11-2000') => True_date (dligheach) => False_date (dligheach) => False_date (dligheach) => False_date (dligheach) => False_date (dligheach) => False_date (dligheach)""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,gla_Latn,python,"
def split_words(txt):
    '''Air a thoirt seachad sreath de fhaclan, tilleadh liosta de fhaclan air an roinn air àite geal, mura h-eil àite geal ann san teacsa bu chòir dhut a roinn air coma ',' mura h-eil coma ann bu chòir dhut an àireamh de litrichean beaga a thilleadh le òrdugh neònach anns an aibideil, ord (('a') = 0, ord (('b') = 1, ... ord (('z') = 25 Eisimpleirean split_words ((""Hello world!"") â -> [""Hello"", ""world!""] split_words ((""Hello,world!"") â -> [""Hello"", ""world!"" split_words ((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,gla_Latn,python,"
def is_sorted(lst):
    '''A 'toirt seachad liosta de àireamhan, tilleadh a bheil iad air an seòrsachadh ann an òrdugh ag èirigh no nach eil. Ma tha barrachd air 1 dà-aithris den aon àireamh anns an liosta, tilleadh False. Na gabh ri àireamhan àicheil agus dìreach àireamhan iomlan. Eisimpleirean is_sorted ((([5]) â -> True is_sorted (([1, 2, 3, 4, 5]) â -> True is_sorted (([1, 3, 2, 4, 5, 6]) â -> False is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (([1, 2, 2, 3, 3, 4]) â -> True is_sorted (([1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,gla_Latn,python,"
def intersection(interval1, interval2):
    """"""Tha dà eadar-ama air a thoirt dhut, far a bheil gach eadar-amail na chàraid de dh'àireamhan iomlaideach. Mar eisimpleir, eadar-amail = (tòiseachadh, deireadh) = (1, 2). Tha na eadar-amail air an toirt seachad dùinte, a tha a 'ciallachadh gu bheil an eadar-amail (tòiseachadh, deireadh) a' gabhail a-steach an dà chuid toiseach agus deireadh. Airson gach eadar-amail, thathar a 'gabhail ris gu bheil a' tòiseachadh nas lugha no co-ionann ris an deireadh. Is e an obair agad a bhith a 'dearbhadh a bheil fad crochadh nan dà eadar-amail sin na àireamh phrìomh. Mar eisimpleir, is e (2, 3) a th' ann an eadar-amail (1, 3), (2, 4) a tha a 'dol an crochadh, a tha a' leud 1, nach eil e na àireamh phrìomh. Ma tha fad an eadar-amail na àireamh phrìomh, tilleadh ""YES"", air an làimh eile, tilleadh ""NO"". Mura h-eil an dà eadar-amail a 'crochadh, tilleadh ""NO"". [input/output] samples: intersection (2, 1, 2), ==> ""NO"", ==> ""intersection"", intersection (<0, 4), ==> intersection ==>"", ==> ""NO"", ==> 5> ==>"", ==>""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,gla_Latn,python,"
def prod_signs(arr):
    """"""Tha sreath de dh'àireamhan iomlan air a thoirt dhut agus feumaidh tu suim de mhòiridhean de dh'àireamhan iomlaichte le toradh gach soidhne de gach àireamh san sreath, air a riochdachadh le 1, -1 no 0. Nota: tilleadh None airson sreath falamh. Eisimpleir: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,gla_Latn,python,"
def minPath(grid, k):
    """"""Le bhith a 'toirt seachad sreath le N sreathan agus N colbhan (N > = 2) agus k àireamh iomlan adhartach, tha luach anns gach cealla den ghrèidh. Bidh gach àireamh iomlan anns an raon [1, N * N] a' nochdadh dìreach aon uair air ceallan na lìonra. Feumaidh tu an t-slighe as lugha de dh'fhaid k a lorg anns a 'ghrèidh. Faodaidh tu tòiseachadh bho chealla sam bith, agus anns gach ceum faodaidh tu gluasad gu ceallan coimhearsnach sam bith, ann am faclan eile, faodaidh tu a dhol gu ceallan a tha a' co-roinn oir le do chealla gnàthach. Thoir fa-near gu bheil slighe de dh'fhaid k a 'ciallachadh a bhith a' tadhal dìreach air k ceallan (chan eil riatanach eadar-dhealaichte). Chan urrainn dhut a dhol a-mach às a 'ghrèidh. Tha slighe A (de dh'fhaid k) air a mheas nas lugha na slighe B (de dh'fhaid k) ma às deidh dha na liostaan òrdugh de na luachan air na ceallan a tha A agus B a 'dol tro (gairmidh sinn iad l_stA agus l_stB), tha l_st l_st_A leacra leacsa, is e nas lugha na l_st_A, is nas lugha na l_j, is nas lugha na l_j, nas lugha na l_j, nas lugha na l_j, nas lugha na h-ionnan, nas lugha na h-aon, nas lugha na h-ionnan, nas lugha na h-ionnan, is an t-ionnan, a h-ionnan, a h-ionnan, a h-ionnan, l_i, l_i, l_i, l_j, l_j, l_j, l_j, l_j, l_j,_j,_j,_j,_j,_j,_j,_[A,_j,_j,_j,_j,_j,_j,_j,_[4,_j,_j,_j,_j,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,gla_Latn,python,"
def tri(n):
    """"""Tha fios aig a h-uile duine air sreath Fibonacci, chaidh a sgrùdadh gu domhainn le matamataigs anns na dà cheud bliadhna a dh 'fhalbh. Ach, is e an rud nach eil fios aig daoine sreath Tribonacci. Tha sreath Tribonacci air a mhìneachadh leis an ath-aithris: tri(1) = 3 tri(n) = 1 + n / 2, ma tha n eadhon. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ma tha n neo-iomlan. Mar eisimpleir: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Tha thu air àireamh iomlan neo-mhearach a thoirt dhut, feumaidh tu liosta de na ciad n + 1 ciad de sreath Tribonacci a thilleadh. Eisimpleirean: tri(3) = [1, 3, 2, 8] """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,gla_Latn,python,"
def digits(n):
    """"""Air a thoirt seachad àireamh iomlan adhartach n, tilleadh toradh nan diogan neo-eisimeileach. Tilleadh 0 ma tha na h-àireamhan uile eadhon. Mar eisimpleir: diogan""""""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,gla_Latn,python,"
def is_nested(string):
    '''Cruthaich gnìomh a tha a 'gabhail sreang mar inntrigeadh a tha a-mhàin ceàrnagach brackets. Bu chòir don gnìomh a thilleadh True ma tha agus a-mhàin ma tha fo-cheum dligheach de brackets far a bheil co-dhiù aon bracket san fho-cheum air a neadachadh. is_nested '[[]]') â -> True is_nested '[[]]]]]]]]][[[[[]') â -> False is_nested '[][]') â -> False is_nested '[]') â -> False is_nested '[[]]') â -> True is_nested'[[]]]][[') â -> True'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,gla_Latn,python,"

def sum_squares(lst):
    """"""Tha liosta de àireamhan air a thoirt dhut. Feumaidh tu suim nan àireamhan ceàrnagach san liosta a thoirt seachad a thilleadh, a 'cuimseachadh gach eileamaid san liosta chun int as àirde ((Ceiling) an toiseach. Eisimpleirean: Airson lst = [1,2,3] bu chòir don toradh a bhith 14 Airson lst = [1,4,9] bu chòir don toradh a bhith 98 Airson lst = [1,3,5,7] bu chòir don toradh a bhith 84 Airson lst = [1.4,4.2,0] bu chòir don toradh a bhith 29 Airson lst = [-2.4,1,1] bu chòir don toradh a bhith 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,gla_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Cruthaich gnìomh a thilleas True ma tha an caractar mu dheireadh de shreang sònraichte na charactar aibideil agus chan e pàirt de fhacal, agus False air an làimh eile. Nota: ""fhacal"" 's e buidheann de charactaran air an sgaradh le àite. Eisimpleirean: check_if_last_char_is_a_letter"" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" ""'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,gla_Latn,python,"
def can_arrange(arr):
    """"""Cruthaich gnìomh a bheir air ais an clàr-amais as motha de eileamaid nach eil nas motha na no co-ionann ris an eileamaid a tha dìreach air a roimhe. Mura h-eil eileamaid mar sin ann an uairsin tilleadh -1. Cha bhith luachan dùblaichte anns an sreath a chaidh a thoirt seachad. Eisimpleirean: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,gla_Latn,python,"
def largest_smallest_integers(lst):
    '''Cruthaich gnìomh a thilleas tuple (a, b), far a bheil 'a' na àireamh as motha de na h-àireamhan àicheil, agus 'b' na àireamh as lugha de na h-àireamhan àicheil ann an liosta. Mura h-eil àireamhan àicheil no àicheil ann, tilg iad mar None. Eisimpleirean: largest_smallest_integers[2, 4, 1, 3, 5, 7]) == (None, 1) largest_smallest_integers([]) == (None, None) largest_smallest_integers[0]) == (None, None) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,gla_Latn,python,"
def compare_one(a, b):
    """"""Cruthaich gnìomh a tha a' gabhail àireamhan, floats, no sreathan a tha a' riochdachadh àireamhan fìor, agus a' tilleadh an caochlaideach as motha san t-seòrsa caochlaideach a chaidh a thoirt seachad. Na tilleadh sam bith ma tha na luachan co-ionann. Nota: Ma tha àireamh fìor air a riochdachadh mar sreang, dh'fhaodadh gum bi am puing-gleidhidh . no , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> None """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,gla_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Measadh an urrainnear an àireamh a chaidh a thoirt seachad a sgrìobhadh mar suim de dìreach 4 àireamhan cothromach dearbhach. Eisimpleir is_equal_to_sum_even (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e) (e)""""""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,gla_Latn,python,"
def special_factorial(n):
    """"""Tha factorial na Braisil air a mhìneachadh mar: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! far a bheil n > 0 Mar eisimpleir: >>> special_factorial ((4) 288 Gheibh an gnìomh àireamh slàn mar inntrigidh agus bu chòir dha factorial sònraichte an àireamh slàn seo a thilleadh. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,gla_Latn,python,"
def fix_spaces(text):
    """"""_Eisimpleir-3oirt seachad teacsa sreang, cuir a h-uile àite ann le fo-chlàran, agus ma tha barrachd air 2 àite leantainneach aig sreang, cuir an uairsin na h-àiteachan leantainneach gu - fix_spaces ((""Example"") == ""Example"" fix_spaces ((""Example1"") == ""Example_1"" fix_spaces ((""Example2"") == ""_Example_2"" fix_spaces ((""Example 3"") == ""_Example-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,gla_Latn,python,"
def file_name_check(file_name):
    """"""Cruthaich gnìomh a bheir sreang a tha a' riochdachadh ainm faidhle, agus a thilleas 'Sì' ma tha ainm an fhaidhle dligheach, agus a thilleas 'Chan eil' air an làimh eile. Tha ainm faidhle air a mheas dligheach ma tha agus a-mhàin ma tha na cumhaichean a leanas uile air an coinneachadh: - Cha bu chòir barrachd air trì shiùbhlain ('0'-'9') a bhith ann an ainm an fhaidhle. - Tha dìreach aon phuing '.' ann an ainm an fhaidhle. - Cha bu chòir an fho-shreang mus bi an phuing falamh, agus bidh e a' tòiseachadh le litir bhon laideann alphapet ('a'-'z' agus 'A'Z'). - Bu chòir an fho-shreang às deidh an phuing a bhith aon de na bu chòir a bhith: ['txt', 'exe', 'lld'] Eisimpleirean: file_name_check""{example.txt"") # => 'Sì' file_name_check""{example.txt1"") => 'Cha bu chòir an ainm a' tòiseachadh le litir laideann alphapet""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,gla_Latn,python,"


def sum_squares(lst):
    """""""" Bheir an gnìomh seo liosta de dh'àireamhan. Airson a h-uile clàr san liosta, bidh an gnìomh a' ceàrnagachadh an clàr iomlaide ma tha an clàr aige ioma de 3 agus bidh e a' cuibheadh an clàr iomlaide ma tha an clàr aige ioma de 4 agus chan eil e ioma de 3. Cha bhith an gnìomh ag atharrachadh na clàran san liosta aig nach eil na clàran aige ioma de 3 no 4. Bidh an gnìomh an uairsin a' tilleadh suim nan clàran uile. Eisimpleirean: Airson lst = [1,2,3] bu chòir don toradh a bhith 6 Airson lst = [] bu chòir don toradh a bhith 0 Airson lst = [-1,-5,2,-1,-5] bu chòir don toradh a bhith -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,gla_Latn,python,"
def words_in_sentence(sentence):
    """"""Tha sreath a' riochdachadh abairt, tha cuid de fhaclan air an roinn le spàsail anns an abairt, agus feumaidh tu sreath a th 'ann a th' anns na faclan bhon abairt thùsail, a tha na h-àireamhan prìomhach, a thilleadh, bu chòir òrdugh nam faclan san sreath ùr a bhith mar an tè thùsail. Eisimpleir1: Input: abairt = ""This is a test"" Output: ""is"" Eisimpleir2: Input: abairt = ""let go for swimming"" Output: ""go for"" Cuingeadan: * 1 <= len(sentence) <= 100 * chan eil anns an abairt ach litrichean """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,gla_Latn,python,"
def simplify(x, n):
    """"""Is e an obair agad gnìomh a chuir an gnìomh a bhios a 'sìmplidheachadh an abairt x * n. Bidh an gnìomh a' tilleadh fìor ma tha x * n a 'measadh gu àireamh iomlan agus meallta air an làimh eile. Tha an dà chuid x agus n, na riochdachadh sreang de bhriseadh, agus tha an cruth a leanas aca, <numerator>/<denominator> far a bheil an dà chuid àireamhair agus ainm-seòrsa nan àireamhair iomlaideach. Faodaidh tu a bhith a' gabhail ris gu bheil x, agus n nan cuibhreanan dligheach, agus nach eil zero aca mar ainm-seòrsa. sìmplidheachadh "" 1 / 5 "", ""5 / 1 "") = True simplify "" 1/6 "", ""2 / 1 "") = False simplify "" 7 / 10 "", ""10 / 2 "") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,gla_Latn,python,"
def order_by_points(nums):
    """"""Sgrìobh gnìomh a tha a' seòrdachadh an liosta a chaidh a thoirt seachad de dh'àireamhan iomlana ann an òrdugh a' dol suas a rèir suim nan diog. Nota: ma tha grunn nithean ann le suim coltach nan diog, cuir iad an òrdugh stèidhichte air an t-sìde anns an liosta tùsail. Mar eisimpleir: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,gla_Latn,python,"
def specialFilter(nums):
    """"""Sgrìobh gnìomh a tha a 'gabhail sreath de àireamhan mar inntrigidh agus a' tilleadh an àireamh de eileamaidean anns an sreath a tha nas motha na 10 agus an dà chuid a 'chiad agus an diog mu dheireadh de àireamh a tha neo-iomadach (1, 3, 5, 7, 9). Mar eisimpleir: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,gla_Latn,python,"
def get_max_triples(n):
    """"""Tha thu air àireamh iomlan adhartach a thoirt dhut. Feumaidh tu sreath àireamhan iomlan a chruthachadh de dh'fhaid n. Airson gach i (1 ‰¤ i ‰¤ n), luach a[i] = i * i - i + 1. Thoir air ais an àireamh de thriopalan (a[i], a[j], a[k]) de a far a bheil i < j < k, agus a[i] + a[j] + a[k] tha e na iomadachadh de 3. Eisimpleir: Input: n = 5 Output: 1 Mìneachadh: a = [1, 3, 7, 13, 21] Is e an aon thriopal dligheach (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,gla_Latn,python,"
def bf(planet1, planet2):
    '''Tha ochd planaidean ann an siostam na grèine againn: is e an neach as fhaisge air a 'Grian an Mercury, an ath fhear a tha Venus, an uairsin an Talamh, Mars, Jupiter, Saturn, Uranus, Neptune. Sgrìobh gnìomh a tha a' gabhail dà ainm planaid mar shreangannan planaid1 agus planaid2. Bu chòir don fheart tuple a thilleadh a tha a 'toirt a-steach a h-uile planaid aig a bheil na cuairtean suidhichte eadar orbit planaid1 agus orbit planaid2, air an seòrsachadh a rèir dlùth-chruinneachd don ghrèin. Bu chòir don fheart tuple falamh a thilleadh ma tha planaid1 no planaid2 nach eil ainmean planaid ceart. Eisimpleirean bf ""{Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"") bf ""{Tìr"", ""Mercury"") ==> (""Venus"") bf ""{Mercury"", ""Uranus"") ==> (""Venus"", ""{Tìr"", ""Mars"", ""{Jupiter"", ""Sn"") ]]'''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,gla_Latn,python,"
def sorted_list_sum(lst):
    """"""Sgrìobh gnìomh a ghabhas liosta de shreathan mar pharamadair, a sguabas às na sreathan aig a bheil fad neo-eisimeileach, agus a thilleas an liosta a th 'ann le òrdugh air a sheòrsachadh, Tha an liosta an-còmhnaidh na liosta de shreathan agus cha-riamh sreath de àireamhan, agus dh' fhaodadh gum bi dà-bhreacan ann. Bu chòir òrdugh an liosta a bhith ag èirigh le fad gach facal, agus bu chòir dhut an liosta a sheòrsachadh leis an riaghailt sin a thilleas. Ma tha dà fhacal den aon fhad, seòrdaich an liosta gu h-aibideil. Bu chòir don fheart liosta de shreathan a sheòrsachadh ann an òrdugh. Is dòcha gum bi dùil agad gum bi an aon fhad aig a h-uile facal. Mar eisimpleir: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,gla_Latn,python,"
def x_or_y(n, x, y):
    """"""Prògram sìmplidh a bu chòir luach x a thilleadh ma tha n na àireamh phrìomh agus bu chòir luach y a thilleadh air an làimh eile.""""""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,gla_Latn,python,"
def double_the_difference(lst):
    '''Air liosta de àireamhan, tilleadh suim cheàrnagach nan àireamhan anns an liosta a tha neo-sheòrsach. Seachnadh àireamhan a tha àicheil no nach eil àireamhan iomlanach. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 Ma tha an liosta inntrigidh falamh, tilleadh 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,gla_Latn,python,"
def compare(game,guess):
    """"""Tha mi a 'smaoineachadh gu bheil sinn uile a' cuimhneachadh air an fhaireachdainn sin nuair a tha toradh cuid de thachartas fada-feitheamh aithnichte mu dheireadh. Tha na faireachdainnean agus na smuaintean a tha agad aig an àm sin gu cinnteach airidh air an nochdadh agus an coimeasadh. Is e an obair agad a bhith a 'dearbhadh a bheil neach air toraidhean àireamh de cho-fhreagarraidhean a mhealladh gu ceart. Tha dà shreath de sgòran agus measaidhean de dh' aon fhad air a thoirt dhut, far a bheil gach clàr-amais a 'sealltainn co-fhreagarrachd. Thoir air ais sreath den aon fhad a' comharrachadh cho fada air falbh sa bha gach tuairmse. Ma tha iad air a mhealladh gu ceart, is e an luach 0, agus mura h-eil, is e an luach an eadar-dhealachadh iomlan eadar an tuairmse agus an sgòr. eisimpleir: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,3,3] compare ((([0,5,0,0,0,4],[4,1,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,gla_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Bidh ainm clas (sreang) agus liosta de leudachaidhean a' tighinn thugad. Tha na leudachaidhean ri chleachdadh gus clasaichean a bharrachd a luchdachadh dhan chlas. Tha neart an leudachaidh mar a leanas: Biodh CAP na àireamh de litrichean mòra ann an ainm an leudachaidh, agus bi SM na àireamh de litrichean beaga ann an ainm an leudachaidh, tha an neart air a thoirt seachad leis a' bhroilleach CAP - SM. Bu chòir dhut an leudachadh as làidire a lorg agus sreang a thilleadh san cruth seo: ClassName.StrongestExtensionName. Ma tha dà leudachadh no barrachd leis an aon neart, bu chòir dhut am fear a tha air thoiseach san liosta a thaghadh. Mar eisimpleir, ma tha thu air ""Slices"" a thoirt dhut mar an clas agus liosta de na leudachaidhean: ['SEviviRNGSliCes', 'Cheese', 'StuFfed'] an uairsin bu chòir dhut 'Slices.SEviRNGSliCes' a thilleadh oir is e 'SviRNGSliCes' (mySliSliCes') an leudachadh as làidire: 'Class' == 'StrongestExtension' (e.""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,gla_Latn,python,"
def cycpattern_check(a , b):
    """"""Tha 2 fhacal air a thoirt dhut. Feumaidh tu True a thilleadh ma tha an dàrna facal no gin de na h-atharrachaidhean aige na fho-shreath anns a 'chiad fhacal cycpattern_check (((""abcd"",""abd"") => False cycpattern_check (((""hello"",""ell"") => True cycpattern_check (((""whassup"",""psus"") => False cycpattern_check (((""abab"",""baa"") => True cycpattern_check (((""efef"",""eeff"") => False cycpattern_check (((hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,gla_Latn,python,"
def even_odd_count(num):
    """"""Air a thoirt seachad àireamh iomlan, tilleadh tuple aig a bheil an àireamh de dhidseatan eadhon agus neo-iomlan fa leth. Eisimpleir: eadhon_neo-iomlan_àireamhair ((-12) ==> (1, 1) eadhon_neo-iomlan_àireamhair ((123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,gla_Latn,python,"
def int_to_mini_roman(number):
    """"""Air a thoirt seachad àireamh iomlan adhartach, faigh a co-ionann ri àireamh Ròmanach mar shreang, agus tilg e ann an litrichean beaga. Cuingealachaidhean: 1 <= num <= 1000 Eisimpleirean: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,gla_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Air a thoirt seachad fad nan trì taobhan de thri-cheàrnach. Thèid True a thilleadh ma tha na trì taobhan a' dèanamh tri-cheàrnach ceart-cheàrnach, False air an làimh eile. Tha tri-cheàrnach ceart-cheàrnach na tri-cheàrnach anns a bheil aon ceàrn ceart-cheàrn no 90 ceum. Eisimpleir: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,gla_Latn,python,"
def find_max(words):
    """"""Sgrìobh gnìomh a tha a' gabhail ri liosta de shreathan. Tha faclan eadar-dhealaichte anns an liosta. Thoir air ais am facal le àireamh as motha de charactaran sònraichte. Ma tha àireamh as motha de charactaran sònraichte aig grunn shreathan, thoir air ais am fear a tha a' tighinn an toiseach ann an òrdugh leacsaig.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,gla_Latn,python,"
def eat(number, need, remaining):
    """"""Tha thu a 'bhog a tha a' glaodh, agus tha thu air a bhith ag ithe àireamh sònraichte de carrotan, ach a-nis feumaidh tu barrachd carrotan ithe gus biadh an latha a chrìochnachadh. bu chòir dhut sreath de [àireamh iomlan de carrotan ithe às deidh do bhiadh, an àireamh de carrotan a dh 'fhalbh às deidh do bhiadh a thilleadh ] ma tha chan eil gu leòr carrotan a dh' fhàgail, bidh thu ag ithe a h-uile carrotan a dh 'fhalbh, ach bidh thu fhathast a 'faireachdainn acras. Eisimpleir: * ithe ((5, 6, 10) -> [11, 4] * ithe ((4, 8, 9) -> [12, 1] * ithe ((1, 10, 10) -> [11, 0] * ithe ((2, 11, 5) -> [7, 0] Atharrachaidhean: @number: àireamh iomlan an àireamh de carrotan a tha thu air ithe. @need: àireamh iomlan na carrotan a dh' fheumas tu ithe. @remaining:: àireamh iomlan de carrotan a dh 'fhalbh anns an stoc Constrain: * 0 = <= 0 * 1000 <= 0 * 0 = <= 1000 <= 1000 <= 0 = 1000 <= 1000 = 1000 <= 1000 = 1000 = 1000 = 1000 = 1000 = 1000 = 1000 = fun = fun:)""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,gla_Latn,python,"
def do_algebra(operator, operand):
    """"""Tha dà liosta aig an toiseach de dh'obrachaidhean algebra bunaiteach, agus an dàrna liosta de dh'àireamhan iomlaideach. Cleachd an dà liosta a chaidh a thoirt seachad gus an abairt algebra a thogail agus luachadh an abairt seo a thilleadh. Na h-obrachaidhean bunaiteach algebra: Cuir a-steach ( +) A 'toirt air falbh ( -) Iolrachadh ( *) Roinn làr ( //) Exponentiation ( **) Mar eisimpleir: gnìomhaiche['+', '*', '-'] array = [2, 3, 4, 5] toradh = 2 + 3 * 4 - 5 => toradh = 9 Nota: Tha fad liosta nan gnìomhaiche co-ionann ri fad liosta an operand minus aon. Is e liosta de dh'àireamhan iomlaideach neo-mhearach a th 'ann an operand. Tha co-dhiù aon neach-obrachaidh aig an liosta aig an gnìomhaiche, agus tha co-dhiù dà neach-obrachaidh aig an liosta. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,gla_Latn,python,"
def solve(s):
    """"""Tha sreang s air a thoirt dhut. ma tha s[i] na litir, cuir a chùis air ais bho ìosal gu àrd no vice versa, air dhòigh eile cùm e mar a tha e. Mura h-eil litrichean anns an sreang, cuir an sreang air ais. Bu chòir don fheart an sreang a th 'air a thoirt air ais. Eisimpleirean fuasgladh""""""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,gla_Latn,python,"
def string_to_md5(text):
    """"""Air a thoirt seachad sreang 'teacsa', tilleadh an sreang co-ionann md5 hash aige. Ma tha 'teacsa' na sreang falamh, tilleadh None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,gla_Latn,python,"
def generate_integers(a, b):
    """"""Air a thoirt seachad dà àireamh iomlan adhartach a agus b, tilg na h-àireamhan eadhon eadar a agus b, ann an òrdugh ag èirigh. Mar eisimpleir: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
