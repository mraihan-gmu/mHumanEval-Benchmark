[{"task_id":"HumanEval_0","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གནས་གོང་འདི་ བྱིན་ཡོདཔ་ཨིན།\/\/ཨང་གྲངས་ཀྱི་བེ་ཊར་ནང་ ཇི་ཨའི་ལས་ ཇི་ཨའི་དང་ ཇི་ཨའི་གཉིས་ ཇི་ཨའི་ལས་ ཇི་ཨའི་གཉིས་ ཇི་ཨའི་ལས་ ཇི་ཨའི་གཉིས་ ཇི་ཨའི་ལས་ ཇི་ཨའི་གཉིས་ ཇི་ཨའི་གཉིས་\/\/\/ >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/\/ true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n","canonical_solution":"fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"},{"task_id":"HumanEval_1","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ནང་བསྐྱོད་ཐིག་ནང་ བར་སྟོང་ཚུ་སྣང་མེད་སྦེ་བཞག་དགོ།\/\/\/ སྡེ་ཚན་སོ་སོ་འདི་ ཚད་ལྡན་ (སྒོ་ཕྱེ་ཡོད་པའི་རྒྱབ་ལག་རེ་རེ་འདི་ ལེགས་ཤོམ་སྦེ་བསྡམས་ཏེ་ཡོདཔ་) དང་ གཅིག་གིས་གཅིག་ལུ་ སྦྲེལ་མ་རྐྱབ་པར་ཡོདཔ་ཨིན།\/\/\/ འདི་ཚུ་ སྡེ་ཚན་སོ་སོར་སྦེ་དབྱེ་བ་ཕྱེ་ཞིནམ་ལས་ ཝེ་ཀཊར་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ འ་ནི་ལས་འགན་ནང་ ནང་ཐིག་འདི་ ནང་སྡུད་འབད་མི་ ལྡེ་མིག་གི་སྡེ་ཚན་ལེ་ཤ་ཡོད་པའི་ཐིག་ཁྲམ་ཨིན། ཁྱོད་ཀྱི་དམིགས་གཏད་འདི་ ཨིན།\/\/\/ >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n\/\/\/ vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n","canonical_solution":"fn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut current_group = String::new();\n    let mut open_count = 0;\n\n    for char in paren_string.chars() {\n        if char == '(' {\n            open_count += 1;\n            current_group.push(char);\n        } else if char == ')' {\n            open_count -= 1;\n            current_group.push(char);\n        }\n\n        if open_count == 0 && !current_group.is_empty() {\n            groups.push(current_group.clone());\n            current_group.clear();\n        }\n    }\n\n    groups\n}","tests":"}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n"},{"task_id":"HumanEval_2","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཨང་གྲངས་ཀྱི་བཅུ་ཆ་ཆ་འདི་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ (ལྷག་ལུས་ཆ་ཤས་འདི་ རྟག་བུ་རང་ ༡ ལས་ཆུང་བ་ཨིན།)\/\/ཨང་གྲངས་ཧྲིལ་བུམ་ (ཨང་གྲངས་སྦོམ་ཤོས་འདི་ བྱིན་ཡོད་པའི་ཨང་གྲངས་ལས་ཆུང་བ་) དང་ བཅུ་ཚག་ཨང་གྲངས་ཚུ་ཨིན།\/\/\/ ནུས་ལྡན་གྱི་ལྡོག་ཕྱོགས་ཨང་གྲངས་བྱིན་པ་ཅིན་ ནང་ལུ་ཁ་ཕྱེ་ཚུགས།\/\/\/ >>> truncate_number(3.5)\n\/\/\/ 0.5\nfn truncate_number(number: f64) -> f64 {\n","canonical_solution":"fn truncate_number(number: f64) -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    println!(\"{}\", truncate_number(3.5)); \/\/ 0.5\n}","tests":"}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"},{"task_id":"HumanEval_3","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དེ་བསྒང་ལས་ function གིས་ true སླར་ལོག་འབད་ནི་ཨིན་མེན་ན་ false སླར་ལོག་འབད་ནི་ཨིན།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ ཚོད་བལྟ་འབད་དགོ འདི་ཡང་ ཚོད་བལྟ་འབད་དགོ \/\/ཁྱོད་ཀྱིས་ དངུལ་ཁང་གི་རྩིས་ཁྲ་ནང་ལས་ དངུལ་བཏོན་དང་བཙུགས་ནིའི་ལཱ་གི་ ཚད་གཞི་ཐོབ་ཡོདཔ་ད་ འདི་ཚུ་ དང་གཅིག་ཁར་ འགོ་བཙུགས་འོང་།\/\/\/ >>> below_zero(vec![1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(vec![1, 2, -4, 5])\n\/\/\/ true\nfn below_zero(operations: Vec<isize>) -> bool {\n","canonical_solution":"fn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations {\n        balance += operation;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", below_zero(vec![1, 2, 3])); \/\/ false\n    println!(\"{}\", below_zero(vec![1, 2, -4, 5])); \/\/ true\n    println!(\"{}\", below_zero(vec![1, -1, -1, 2])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"},{"task_id":"HumanEval_4","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ MAD = average ཨིན། x - x_mean ཨིན།\/\/\/ ཆ་ཤས་དང་ལྟེ་བ་ (གནས་སྟངས་འདི་ནང་ལུ་ མནོ་བསམ་བཏང་སྟེ་) ཨིན།\/\/\/ Mean Absolute Deviation འདི་ སྦྲེལ་མཐུད་ཆ་མཉམ་གྱི་བར་ནའི་བར་ནའི་ཁྱད་པར་ཨིན།\/\/\/ འདི་ནང་ གནད་སྡུད་ཀྱི་ཚད་གཞི་འདི་ ཨིན།\/\/\/ ནང་བསྐྱོད་ཨང་གྲངས་ཀྱི་ ཝི་ཅཊ་ཅིག་བྱིན་པ་ཅིན་ Mean Absolute Deviation ཟེར་མི་དེ་རྩིས་སྟོནམ་ཨིན།\/\/\/ >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n","canonical_solution":"fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    let n = numbers.len() as f64;\n    if n == 0.0 {\n        return 0.0;\n    }\n\n    let mean: f64 = numbers.iter().sum::<f64>() \/ n;\n    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() \/ n;\n    \n    mad\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0];\n    println!(\"{}\", mean_absolute_deviation(numbers)); \/\/ Output: 1.0\n}","tests":"}\n\nfn main() {\n    let candidate = mean_absolute_deviation;\n    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);\n}\n"},{"task_id":"HumanEval_5","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ནང་བསྐྱོད་བེཀཊ་ཀྱི་རིམ་པ་གཉིས་ཆ་རའི་བར་ནའི་བར་ནའི་གྱངས་ཁ་ 'delimeter' ཅིག་བཙུགས་ `numbers' \/\/\/ >>> intersperse(vec![], 4)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> intersperse(vec![1, 2, 3], 4)\n\/\/\/ vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n","canonical_solution":"fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n    }\n    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n    for (i, &num) in numbers.iter().enumerate() {\n        result.push(num);\n        if i != numbers.len() - 1 {\n            result.push(delimiter);\n        }\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", intersperse(vec![], 4)); \/\/ Output: Vec::<isize>::new()\n    println!(\"{:?}\", intersperse(vec![1, 2, 3], 4)); \/\/ Output: vec![1, 4, 2, 4, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"},{"task_id":"HumanEval_6","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེར་ན་ (() (()) འདི་ནང་ལུ་ ཚང་བཟོ་ནིའི་གནས་ཚད་གཉིས་དེ་ཅིག་ཡོདཔ་དང་ ((())) འདི་ནང་ལུ་ ༣་དེ་ཅིག་ཡོདཔ་ཨིན།\/\/\/ སྡེ་ཚན་རེ་རེ་བཞིན་དུ་ལུ་ ནང་ཐིག་གི་ཧེ་མའི་གནས་ཚད་འདི་བཏོན་དགོ།\/\/\/ འ་ནི་ལས་འགན་ནང་ ཨང་གྲངས་ཐིག་ཁྲམ་འདི་ སྦྲེལ་ཡོད་པའི་སྒོ་སྒྲིག་གི་དོན་ལུ་ སྡེ་ཚན་ལེ་ཤ་ཅིག་ལུ་ ངོ་ཚབ་འབདཝ་ཨིན།\/\/\/ >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n\/\/\/ vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    paren_string.split_whitespace().map(|group| {\n        let mut max_depth = 0;\n        let mut current_depth = 0;\n        for char in group.chars() {\n            match char {\n                '(' => {\n                    current_depth += 1;\n                    if current_depth > max_depth {\n                        max_depth = current_depth;\n                    }\n                },\n                ')' => {\n                    current_depth -= 1;\n                },\n                _ => {}\n            }\n        }\n        max_depth\n    }).collect()\n}\n\nfn main() {\n    let result = parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"));\n    println!(\"{:?}\", result); \/\/ Output: [2, 3, 1, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n"},{"task_id":"HumanEval_7","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ནང་ཐིག་གི་བེ་ཀཊར་ཚུ་ ཚད་འཛིན་འབད་ནིའི་དོན་ལུ་ ནང་ཐིག་གི་བེ་ཀཊར་ཚུ་ ཚད་འཛིན་འབད་དགོཔ་ཨིན།\/\/\/ >>> filter_by_substring(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.into_iter().filter(|s| s.contains(&substring)).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\")), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"},{"task_id":"HumanEval_8","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ སྟོངམ་བསྡོམས་འདི་ ༠ དང་ སྟོངམ་ཐོན་སྐྱེད་འདི་ ༡ སྦེ་བཞག་དགོ།\/\/\/ ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊ་རེ་ལུ་ ཝི་ཅཊ་ནང་གི་ ཨང་གྲངས་ཧྲིལ་བུའི་བསྡོམས་དང་ འབྲས་བུ་ལས་གྲུབ་པའི་ ཝེ་ཊར་ཅིག་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> sum_product(vec![])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(vec![1, 2, 3, 4])\n\/\/\/ (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n","canonical_solution":"fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n}\n\nfn main() {\n    println!(\"{:?}\", sum_product(vec![])); \/\/ (0, 1)\n    println!(\"{:?}\", sum_product(vec![1, 2, 3, 4])); \/\/ (10, 24)\n}","tests":"}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"},{"task_id":"HumanEval_9","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཤུལ་ཐིག་ནང་ཨིན།\/\/\/ གནས་གོང་ཚུ་ བྱིན་ཡོད་པའི་ ཝི་ཅཊར་ནང་ལས་ ད་ཚུན་གྱི་བར་ན་ཐོབ་མི་ ཝེ་ཀཊར་ སྦོམ་ཤོས་ཅིག་ཐོན་ནུག\/\/\/ >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n\/\/\/ vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max = isize::MIN;\n    for &num in &numbers {\n        if num > current_max {\n            current_max = num;\n        }\n        result.push(current_max);\n    }\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"},{"task_id":"HumanEval_10","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ - ཚིག་ཡིག་གི་མཇུག་ཁར་ ཚིག་ཡིག་གི་སྔོན་ཚིག་འདི་བཙུགས་ ཇི་དེ་ palindromic suffix གི་ཧེ་མ་འོང་འོང་།\/\/\/ - གྲོས་འདེབས་འབད་མི་ཐིག་ཁྲམ་ནང་ལུ་ palindrome ཡོད་པའི་ཤུལ་མ་གི་ཡིག་འབྲུ་འདི་འཚོལ་དགོ།\/\/ཨེལ་གོར་ཇི་མིཊི་གི་བསམ་འཆར་འདི་འཇམ་ཏོང་ཏོ་ཨིན།\/\/\/ གྲུབ་འབྲས་འདི་ ཕྲང་ཡིག་གི་ཐིག་ཁྲམ་ནང་ལུ་ འགོ་བཙུགས་མི་ ཕྲང་ཡིག་གི་ཐིག་ཁྲམ་འདི་ ཕྲང་ཡིག་གི་ཐིག་ཁྲམ་ནང་ལུ་ སྟོན་དགོ།\/\/\/ >>> make_palindrome(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> make_palindrome(String::from(\"cat\"))\n\/\/\/ String::from(\"catac\")\n\/\/\/ >>> make_palindrome(String::from(\"cata\"))\n\/\/\/ String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n","canonical_solution":"fn make_palindrome(string: String) -> String {\n    fn is_palindrome(s: &str) -> bool {\n        s.chars().eq(s.chars().rev())\n    }\n\n    if string.is_empty() || is_palindrome(&string) {\n        return string;\n    }\n\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..]) {\n            let prefix = &string[..i];\n            let reversed_prefix: String = prefix.chars().rev().collect();\n            return string + &reversed_prefix;\n        }\n    }\n\n    string\n}\n\nfn main() {\n    println!(\"{:?}\", make_palindrome(String::from(\"\"))); \/\/ String::from(\"\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cat\"))); \/\/ String::from(\"catac\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cata\"))); \/\/ String::from(\"catac\")\n}","tests":"}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n}\n"},{"task_id":"HumanEval_11","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ འ་ནི་ནང་འདྲེན་ཚུ་ནང་ binary XOR འདི་འབད་ཞིནམ་ལས་ གྲུབ་འབྲས་འདི་ string སྦེ་ལོག་གཏང་།\/\/ནང་བསྐྱོད་འདི་ ༡ དང་ ༠ འབད་མི་ཐིག་ཁྲམ་གཉིས་ a དང་ b ཚུ་ཨིན།\/\/\/ >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n\/\/\/ String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n","canonical_solution":"fn string_xor(a: String, b: String) -> String {\n    a.chars()\n     .zip(b.chars())\n     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })\n     .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"},{"task_id":"HumanEval_12","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ strings of the same length སླར་ལོག་འབདཝ་ཨིན། ནང་བསྐྱོད་བེ་ཀཊར་འདི་ སྟོངམ་ཡོད་པ་ཅིན་ None སླར་ལོག་འབདཝ་ཨིན།\/\/string གི་བེ་ཊར་ནང་ལས་ ཚེ་རིང་ཤོས་དེ་སླར་ལོག་འབདཝ་ཨིན། ཚེ་རིང་ལེ་ཤ་ཡོད་པ་ཅིན་ དང་པ་འདི་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> longest(vec![])\n\/\/\/ None\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ Some(String::from(\"a\"))\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\/\/\/ Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n","canonical_solution":"fn longest(strings: Vec<String>) -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len())\n}","tests":"}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"},{"task_id":"HumanEval_13","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཨང་གྲངས་ཧྲིལ་པོ་ a དང་ b གཉིས་ཀྱི་སྤྱིར་བཏང་ཆ་བགོས་སྦོམ་ཤོས་ཅིག་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> greatest_common_divisor(3, 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(25, 15)\n\/\/\/ 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n","canonical_solution":"fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}","tests":"}\n\nfn main() {\n    let candidate = greatest_common_divisor;\n    assert_eq!(candidate(3, 7), 1);\n    assert_eq!(candidate(10, 15), 5);\n    assert_eq!(candidate(49, 14), 7);\n    assert_eq!(candidate(144, 60), 12);\n}\n"},{"task_id":"HumanEval_14","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ནང་བསྐྱོད་ཐིག་གི་ ཕྲ་རིང་ལས་ ཕྲ་རིང་ཚུན་གྱི་སྔོན་འཇུག་ཆ་མཉམ་ལོག་གཏང་ཐིག་ \/\/\/ >>> all_prefixes(String::from(\"abc\"))\n\/\/\/ vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n","canonical_solution":"fn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 1..=string.len() {\n        prefixes.push(string[..i].to_string());\n    }\n    prefixes\n}\n\n\/\/ Example usage\nfn main() {\n    let prefixes = all_prefixes(String::from(\"abc\"));\n    println!(\"{:?}\", prefixes);\n}","tests":"}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\")]);\n}\n"},{"task_id":"HumanEval_15","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གནས་ས་ནང་ལུ་ཐིག་ཁྲམ་ཡོད་པའི་ ཨང་གྲངས་ཚུ་ 0 ལས་ n ཚུན་ཚུད་དེ་ཡོད་མི་འདི་སླར་ལོག་འབདཝ་ཨིན། \/\/\/ >>> string_sequence(0)\n\/\/\/ String::from(\"0\")\n\/\/\/ >>> string_sequence(5)\n\/\/\/ String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n","canonical_solution":"fn string_sequence(n: isize) -> String {\n    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = string_sequence;\n    assert_eq!(candidate(0), String::from(\"0\"));\n    assert_eq!(candidate(3), String::from(\"0 1 2 3\"));\n    assert_eq!(candidate(10), String::from(\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"},{"task_id":"HumanEval_16","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ string ཅིག་བྱིན་པ་ཅིན་ ཇི་ཅིག་ལས་ཁྱད་པར་ཅན་གྱི་ཡིག་འབྲུ་ག་དེ་ཅིག་ཡོདཔ་ཨིན་ན་འཚོལ་ (ཡིག་འབྲུ་ཆེ་ཆུང་དང་ཆུང་བ་ག་དེ་ཅིག་ཨིན་རུང་) \/\/\/ >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(String::from(\"Jerry\"))\n\/\/\/ 4\nfn count_distinct_characters(string: String) -> isize {\n","canonical_solution":"use std::collections::HashSet;\n\nfn count_distinct_characters(string: String) -> isize {\n    let lowercase_string = string.to_lowercase();\n    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();\n    distinct_chars.len() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_distinct_characters;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abcde\")), 5);\n    assert_eq!(candidate(String::from(\"abcdecadeCADE\")), 5);\n    assert_eq!(candidate(String::from(\"aaaaAAAAaaaa\")), 1);\n    assert_eq!(candidate(String::from(\"Jerry jERRY JeRRRY\")), 5);\n}\n"},{"task_id":"HumanEval_17","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཀོ་ཝེཊ་ནང་ཡོད་མི་གློག་སྒྲ་འདི་ beat གཅིག་ལས་ལྷག་སྟེ་མི་འོང་།\/\/'oidiye' - ཟླཝ་ཕྱེད་ཀྱི་ནང་འཁོད་ལུ་ ཨང་གཉིས་སྦེ་རྐྱབ་ཨིན།\/\/\/'o' - སྒྲ་དབྱངས་ཀྱི་རྣམ་པ་ཚུ། སྒྲ་དབྱངས་ཀྱི་རྣམ་པ་བཞི་ནང་ཚུ།\/\/\/ འདི་ནང་ལུ་ལོ་རྒྱུས་གཅིག་ཡོདཔ་ཨིན།\/\/\/ མཇུག་མ་བསྡུ་བར་སྡོད་འོང་།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ string འདི་དབྱེ་ཞིབ་འབད་ཞིནམ་ལས་ ཇི་ཨའི་ཇི་གི་ ཝི་ཅཊར་འདི་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ འ་ནི་ལས་འགན་འདི་ནང་ལུ་ ཨེསི་སི་ཨི་ཨའི་ཡིག་གཟུགས་ནང་ལུ་ སྒྲ་དབྱངས་ཀྱི་ཨང་ཡིག་འདི་ ཚད་འཛིན་འབདཝ་ཨིན།\/\/\/ >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n\/\/\/ vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_music(music_string: String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let notes: Vec<&str> = music_string.split_whitespace().collect();\n\n    for note in notes {\n        match note {\n            \"o\" => result.push(4),\n            \"o|\" => result.push(2),\n            \".|\" => result.push(1),\n            _ => (),\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let music_string = String::from(\"o o| .| o| o| .| .| .| .| o o\");\n    let beats = parse_music(music_string);\n    println!(\"{:?}\", beats); \/\/ Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"},{"task_id":"HumanEval_18","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གཞི་རྟེན་ཐིག་ཁྲམ་ནང་ལུ་ ཚར་ག་དེ་ཅིག་རང་ ཚར་གྲངས་ཀྱི་ཐིག་ཁྲམ་འདི་ཐོབ་ཚུགས་ག་འཚོལ་ཞིབ་འབད་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་ གྱངས་ཁ་འདི་\/\/\/ >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n\/\/\/ 0\n\/\/\/ >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n\/\/\/ 3\n\/\/\/ >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n\/\/\/ 3\nfn how_many_times(string: String, substring: String) -> isize {\n","canonical_solution":"fn how_many_times(string: String, substring: String) -> isize {\n    if substring.is_empty() || string.is_empty() {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut position = 0;\n\n    while let Some(pos) = string[position..].find(&substring) {\n        count += 1;\n        position += pos + 1; \/\/ Move to the start of the next potential substring\n    }\n\n    count\n}\n\nfn main() {\n    println!(\"{}\", how_many_times(String::from(\"\"), String::from(\"a\"))); \/\/ 0\n    println!(\"{}\", how_many_times(String::from(\"aaa\"), String::from(\"a\"))); \/\/ 3\n    println!(\"{}\", how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))); \/\/ 3\n}","tests":"}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n"},{"task_id":"HumanEval_19","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཆུང་ཤོས་ལས་སྦོམ་ཤོས་ལུ་རིམ་སྒྲིག་འབད་མི་ ཨང་གྲངས་ཚུ་དང་གཅིག་ཁར་ string སླར་ལོག་འབདཝ་ཨིན།\/\/ལྡོག་ཕྱོགས་ཀྱི་དོན་ལུ་ ཕྲ་རིང་ཚུ་འདི་ ༠, ༡, ༢, ༣, ༤, ༥, ༦, ༧, ༨ དང་ ༩ ཨིན།\/\/ནང་བསྐྱོད་འདི་ ས་སྒོ་ནང་ཐིག་ཡིག་སྦེ་ཡོད་པའི་ ཨང་གྲངས་ཀྱི་ཐིག་ཁྲམ་འདི་ ' ༠' ལས་ ' ༩' ཚུན་ཨིན།\/\/\/ >>> sort_numbers(String::from(\"three one five\"))\n\/\/\/ String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n","canonical_solution":"fn sort_numbers(numbers: String) -> String {\n    let word_to_number = |word: &str| -> u32 {\n        match word {\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => panic!(\"Invalid input\"),\n        }\n    };\n\n    let words: Vec<&str> = numbers.split_whitespace().collect();\n    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();\n\n    number_words.sort_by_key(|&(_, number)| number);\n\n    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = sort_numbers;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"three\")), String::from(\"three\"));\n    assert_eq!(candidate(String::from(\"three five nine\")), String::from(\"three five nine\"));\n    assert_eq!(candidate(String::from(\"five zero four seven nine eight\")), String::from(\"zero four five seven eight nine\"));\n    assert_eq!(candidate(String::from(\"six five four three two one zero\")), String::from(\"zero one two three four five six\"));\n}\n"},{"task_id":"HumanEval_20","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གཞན་ཚུ་དང་ འདི་ཚུ་རིམ་པ་བཞིན་དུ་ལོག་གཏང་ (གྱངས་ཁ་ཉུང་ཤོས་དང་ མང་ཤོས་) །\/\/\/ ཨང་གྲངས་ཚུ་ (ཉུང་ཤོས་རང་ ༢ གི་རིང་ཚད་) ཡོད་མི་ལས་ ཨང་གྲངས་གཉིས་རེ་ལུ་ སྦོ་ལོགས་ཁར་ཡོད་མི་ཚུ་གདམ་ཁ་རྐྱབས་ཏེ་ལོག་གཏང་།\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n","canonical_solution":"fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::INFINITY;\n    let mut result = (0.0, 0.0);\n\n    for i in 0..(numbers.len() - 1) {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff {\n            min_diff = diff;\n            result = (numbers[i], numbers[i + 1]);\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    \/\/ Example usage\n    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];\n    let res1 = find_closest_elements(vec1);\n    println!(\"{:?}\", res1); \/\/ (2.0, 2.2)\n\n    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];\n    let res2 = find_closest_elements(vec2);\n    println!(\"{:?}\", res2); \/\/ (2.0, 2.0)\n}","tests":"}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"},{"task_id":"HumanEval_21","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཨང་གྲངས་ཆུང་ཤོས་འདི་ ༠ དང་སྦོམ་ཤོས་འདི་ ༡ སྦེ་འགྱུར་འོང་།\/\/\/ ཨང་གྲངས་ཀྱི་བེ་ཊར་འདི་བྱིན་ (ཉུང་ཤོས་རང་ ཨེཆ་ཨེལ་གཉིས་ལས་) འདི་བེ་ཊར་ལུ་ ཚད་ཐིག་འགྱུར་བཅོས་ཅིག་ལག་ལེན་འཐབ་།\/\/\/ >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n","canonical_solution":"fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\n    numbers.into_iter().map(|x| (x - min_value) \/ (max_value - min_value)).collect()\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let rescaled = rescale_to_unit(numbers);\n    println!(\"{:?}\", rescaled);\n}","tests":"}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"},{"task_id":"HumanEval_23","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གྲལ་ཐིག་ནང་ཐིག་གི་རིང་ཚད་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> strlen(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> strlen(String::from(\"abc\"))\n\/\/\/ 3\nfn strlen(string: String) -> isize {\n","canonical_solution":"fn strlen(string: String) -> isize {\n    string.chars().count() as isize\n}\n\nfn main() {\n    println!(\"{}\", strlen(String::from(\"\"))); \/\/ Output: 0\n    println!(\"{}\", strlen(String::from(\"abc\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = strlen;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"x\")), 1);\n    assert_eq!(candidate(String::from(\"asdasnakj\")), 9);\n}\n"},{"task_id":"HumanEval_24","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཨང་གྲངས་ n ཅིག་ལུ་ ཨང་གྲངས་སྦོམ་ཤོས་ཅིག་ n ལས་ཆུང་བ་ཅིག་སྦེ་ དབྱེ་བ་ཕྱེ་མི་ཅིག་འཚོལ་དགོ།\/\/\/ >>> largest_divisor(15)\n\/\/\/ 5\nfn largest_divisor(n: isize) -> isize {\n","canonical_solution":"fn largest_divisor(n: isize) -> isize {\n    for i in (1..n).rev() {\n        if n % i == 0 {\n            return i;\n        }\n    }\n    1 \/\/ If no other divisor is found, return 1\n}\n\nfn main() {\n    println!(\"{}\", largest_divisor(15)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3), 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n    assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n"},{"task_id":"HumanEval_25","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཨང་གྲངས་འདི་ ཨང་གྲངས་ཆ་མཉམ་གྱི་ཐོན་རིམ་དང་འདྲན་འདྲ་འབད་དགོཔ་ཨིན།\/\/\/ ཕྲ་གྱངས་རེ་རེ་ལུ་ ཕྲ་གྱངས་ཁ་བཀོད་སྒྲིག་ནང་ལུ་ ཚར་ག་དེ་ཅིག་འོང་ག་དང་བསྟུན་པའི་གྱངས་ཁ་བཀོད་སྒྲིག་འབད་དགོཔ་ཨིན།\/\/\/ ཆུང་ཤོས་ལས་སྦོམ་ཤོས་ཚུན་ཚོད་རིམ་པ་ནང་ལུ་ ཨང་གྲངས་ཧྲིལ་བུའི་གཞི་གྲངས་ཚུའི་ལོག་ཕྱོགས་ཨིན་ཨིན་ \/\/\/ >>> factorize(8)\n\/\/\/ vec![2, 2, 2]\n\/\/\/ >>> factorize(25)\n\/\/\/ vec![5, 5]\n\/\/\/ >>> factorize(70)\n\/\/\/ vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n","canonical_solution":"fn factorize(mut n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    while n >= divisor * divisor {\n        while n % divisor == 0 {\n            factors.push(divisor);\n            n \/= divisor;\n        }\n        divisor += 1;\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", factorize(8));  \/\/ Should print: [2, 2, 2]\n    println!(\"{:?}\", factorize(25)); \/\/ Should print: [5, 5]\n    println!(\"{:?}\", factorize(70)); \/\/ Should print: [2, 5, 7]\n}","tests":"}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"},{"task_id":"HumanEval_26","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ནང་བསྐྱོད་འབད་ཡོད་པའི་རིམ་ལུགས་དང་ཅིག་སྦེ་ རྒྱུན་རིམ་ཚུ་བཞག་དགོ།\/\/ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊར་ནང་ལས་ ཚར་གཅིག་ལས་ལྷག་པའི་ ཨེ་རེ་ཚུ་བཏོན་གཏང་།\/\/\/ >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n\/\/\/ vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut occurrences = HashMap::new();\n    \n    \/\/ Count occurrences of each number\n    for &number in &numbers {\n        *occurrences.entry(number).or_insert(0) += 1;\n    }\n\n    \/\/ Filter out numbers that occur more than once\n    numbers.into_iter()\n        .filter(|&number| occurrences[&number] == 1)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_duplicates;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);\n}\n"},{"task_id":"HumanEval_27","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཚིག་ཡིག་ཐིག་ཁྲམ་ཅིག་ལུ་ཡིག་འབྲུ་ཆུང་བ་ཚུ་ ཆེ་ཆུང་ལུ་དང་ ཆེ་ཆུང་ལུ་ ཆུང་བ་སྦེ་བསྒྱུར་གཏང་།\/\/\/ >>> flip_case(String::from(\"Hello\"))\n\/\/\/ String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n","canonical_solution":"fn flip_case(string: String) -> String {\n    string.chars().map(|c| {\n        if c.is_lowercase() {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")), String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"},{"task_id":"HumanEval_28","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ string གི་ ཝེ་ཀཊར་ཚུ་ string གཅིག་ནང་བསྡོམས་འབད།\/\/\/ >>> concatenate(vec![])\n\/\/\/ String::from(\"\")\n\/\/\/ >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n","canonical_solution":"fn concatenate(strings: Vec<String>) -> String {\n    strings.concat()\n}","tests":"}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n}\n"},{"task_id":"HumanEval_29","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ནང་བསྐྱོད་འབད་ཡོད་པའི་ཝེ་ཀཊར་ཚུ་ནང་ ཨང་གྲངས་ཀྱི་སྔོན་རྟགས་ཅིག་ལས་ འགོ་བཙུགས་མི་ ཝེ་ཀཊར་ཚུ་རྐྱངམ་ཅིག་སེལ་འཐུ་འབད།\/\/\/ >>> filter_by_prefix(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_prefix;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n}\n"},{"task_id":"HumanEval_30","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཝི་ཅཊར་ནང་ལུ་ ནུས་ཅན་ཨང་གྲངས་ཚུ་རྐྱངམ་གཅིག་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> get_positive(vec![-1, 2, -4, 5, 6])\n\/\/\/ vec![2, 5, 6]\n\/\/\/ >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().filter(|&x| x > 0).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = get_positive;\n    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);\n    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_31","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གནས་གོང་འདི་ཨང་གྲངས་ངོ་མ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> is_prime(6)\n\/\/\/ false\n\/\/\/ >>> is_prime(101)\n\/\/\/ true\n\/\/\/ >>> is_prime(11)\n\/\/\/ true\n\/\/\/ >>> is_prime(13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(61)\n\/\/\/ true\n\/\/\/ >>> is_prime(4)\n\/\/\/ false\n\/\/\/ >>> is_prime(1)\n\/\/\/ false\nfn is_prime(n: isize) -> bool {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n}\n"},{"task_id":"HumanEval_33","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཚད་གཞི་ཚུ་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་ ཨང་དང་བསྟུན་ཏེ་\/\/\/l' འདི་ ༣ ལུ་མི་བཏུབ་པའི་བརྡ་སྟོན་ནང་ l དང་མཚུངས་པ་ཨིནམ་དང་ འདི་ཡང་ ༣ ལུ་མི་བཏུབ་པའི་བརྡ་སྟོན་ནང་ གྱི་གནས་གོང་ཚུ་འདྲན་འདྲ་ཨིན།\/\/འ་ནི་ལས་འགན་འདི་གིས་ ཝེ་ཀཊར་ l ཅིག་ལེན་ཏེ་ ཝེ་ཀཊར་ l' འདི་བཟུམ་ཅིག་སྦེ་ལོག་བྱིན་འོང་།\/\/\/ >>> sort_third(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n\/\/\/ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()\n        .enumerate()\n        .filter(|&(i, _)| i % 3 == 0)\n        .map(|(i, &value)| (i, value))\n        .collect();\n\n    \/\/ Sort the values that are at indices divisible by 3\n    divisible_by_three.sort_by_key(|&(_, value)| value);\n\n    let mut result = l.clone();\n    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {\n        result[*original_index] = divisible_by_three[sorted_index].1;\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"},{"task_id":"HumanEval_34","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཝེ་ཀཊར་ནང་ལུ་ དབྱེ་བ་ཕྱེ་ཡོད་པའི་ཁྱད་ཆོས་ཅན་གྱི་ཆ་ཤས་ཚུ་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique(mut l: Vec<isize>) -> Vec<isize> {\n    l.sort_unstable();\n    l.dedup();\n    l\n}\n\nfn main() {\n    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);\n    println!(\"{:?}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = unique;\n    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);\n}\n"},{"task_id":"HumanEval_35","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཝི་ཅཊར་ནང་ལུ་ ཚད་ལྡན་གྱི་ཆ་ཤས་ལོག་གཏང་། \/\/\/ >>> max_element(vec![1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfn max_element(l: Vec<isize>) -> isize {\n","canonical_solution":"fn max_element(l: Vec<isize>) -> isize {\n    l.into_iter().max().unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = max_element;\n    assert_eq!(candidate(vec![1, 2, 3]), 3);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);\n}\n"},{"task_id":"HumanEval_36","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཨང་གྲངས་ 7 འདི་ ཨང་གྲངས་ n ལས་ཆུང་བ་ནང་ལུ་མཐོང་མི་ ཚར་གྲངས་ཚུ་སླར་ལོག་འབདཝ་ཨིན། འདི་ཚུ་ ༡༡ དང་ ༡༣ ལུ་ཆ་བགོས་འབད་ཚུགས།\/\/\/ >>> fizz_buzz(50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(79)\n\/\/\/ 3\nfn fizz_buzz(n: isize) -> isize {\n","canonical_solution":"fn fizz_buzz(n: isize) -> isize {\n    (0..n)\n        .filter(|&x| x % 11 == 0 || x % 13 == 0)\n        .flat_map(|x| x.to_string().chars())\n        .filter(|&c| c == '7')\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = fizz_buzz;\n    assert_eq!(candidate(50), 0);\n    assert_eq!(candidate(78), 2);\n    assert_eq!(candidate(79), 3);\n    assert_eq!(candidate(100), 3);\n    assert_eq!(candidate(200), 6);\n    assert_eq!(candidate(4000), 192);\n    assert_eq!(candidate(10000), 639);\n    assert_eq!(candidate(100000), 8026);\n}\n"},{"task_id":"HumanEval_37","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཚད་འཛིན་ཚུ་དང་ ཕྲང་སྒྲིག་འབད་ཡོད་པའི་ ཚད་འཛིན་ཚུ་དང་ འདྲན་འདྲ་ཨིན།\/\/ཚད་འཛིན་གྱི་ནང་ l དང་མཚུངས་པ་ཨིན། དེ་ལས་ ཚད་འཛིན་གྱི་ནང་ ཚད་འཛིན་གྱི་ནང་ འདྲ་མཉམ་ཨིན།\/\/འ་ནི་ལས་འགན་འདི་གིས་ ཝེ་ཀཊར་ l ཅིག་ལེན་ཏེ་ ཝེ་ཀཊར་ l' འདི་བཟུམ་ཅིག་སྦེ་ལོག་བྱིན་འོང་།\/\/\/ >>> sort_even(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_even(vec![5, 6, 3, 4])\n\/\/\/ vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    \/\/ Collect even indexed elements and sort them\n    let mut even_elements: Vec<isize> = l.iter().enumerate()\n        .filter(|&(i, _)| i % 2 == 0)\n        .map(|(_, &val)| val)\n        .collect();\n    even_elements.sort();\n\n    \/\/ Reconstruct the vector `l'`\n    let mut result = l.clone();\n    let mut even_index = 0;\n\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result[i] = even_elements[even_index];\n            even_index += 1;\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"},{"task_id":"HumanEval_39","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ prime_fib གིས་ ཨང་གྲངས་ n-th དེ་ ཕི་བེ་ནཅི་ཨང་གྲངས་ཨིནམ་དང་ དེ་ཡང་ ཨང་གྲངས་ཨང་གྲངས་ཨང་གྲངས་ངོ་མ་ཅིག་ཨིན།\/\/\/ >>> prime_fib(1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(5)\n\/\/\/ 89\nfn prime_fib(n: isize) -> isize {\n","canonical_solution":"fn prime_fib(n: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        if num <= 3 {\n            return true;\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    fn fibonacci() -> impl Iterator<Item = isize> {\n        let mut a: isize = 0;\n        let mut b: isize = 1;\n        std::iter::from_fn(move || {\n            let next = a + b;\n            a = b;\n            b = next;\n            Some(a)\n        })\n    }\n\n    let mut count = 0;\n    for fib_num in fibonacci() {\n        if is_prime(fib_num) {\n            count += 1;\n            if count == n {\n                return fib_num;\n            }\n        }\n    }\n    -1\n}","tests":"}\n\nfn main() {\n    let candidate = prime_fib;\n    assert_eq!(candidate(1), 2);\n    assert_eq!(candidate(2), 3);\n    assert_eq!(candidate(3), 5);\n    assert_eq!(candidate(4), 13);\n    assert_eq!(candidate(5), 89);\n    assert_eq!(candidate(6), 233);\n    assert_eq!(candidate(7), 1597);\n    assert_eq!(candidate(8), 28657);\n    assert_eq!(candidate(9), 514229);\n    assert_eq!(candidate(10), 433494437);\n}\n"},{"task_id":"HumanEval_40","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ༠ ལུ་བསྡོམས་ཏེ་ དེ་ལས་རྫུས་མ་ཨིན།\/\/\/ འདི་ true སླར་ལོག་འབདཝ་ཨིན། ཝི་ཅཊར་ནང་ལུ་ ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གསུམ་ཡོད་པ་ཅིན་\/\/\/ triples_sum_to_zero གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ ཝི་ཅཊ་ཅིག་ཨེབ་གཏང་འབད་སྦེ་ལེན་འབདཝ་ཨིན།\/\/\/ >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1])\n\/\/\/ false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    let n = l.len();\n    if n < 3 {\n        return false;\n    }\n\n    let mut sorted_l = l.clone();\n    sorted_l.sort();\n\n    for i in 0..n-2 {\n        let a = sorted_l[i];\n        let mut left = i + 1;\n        let mut right = n - 1;\n\n        while left < right {\n            let sum = a + sorted_l[left] + sorted_l[right];\n            if sum == 0 {\n                return true;\n            } else if sum < 0 {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n    }\n\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n}\n"},{"task_id":"HumanEval_41","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ འ་ནི་ལས་འགན་འདི་གིས་ དེ་བཟུམ་གྱི་འཐབ་རྒོལ་གྱི་གྱངས་ཁ་འདི་འཐོན་འོང་།\/\/བྱུང་རྐྱེན་འདི་ བྱུང་མ་མྱོང་བཟུམ་ཅིག་སྦེ་རང་ བྱུང་ནུག\/\/ཨིན་རུང་ སྣུམ་འཁོར་ཚུ་ གནམ་མེད་ས་མེད་སྒྲིང་སྒྲིང་དང་སྒྲིང་སྒྲིང་ཨིནམ་ལས་ ཁོང་གིས་ འཕྲོ་མཐུད་དེ་ར་ འགྲོ་འགྲུལ་འབད་དོ་ཡོདཔ་ཨིན་མས།\/\/གཡས་ལས་གཡོན་ཁ་ཐུག་ལུ་འགྱོ་མི་ སྣུམ་འཁོར་ཅིག་གིས་ གཡས་ལས་གཡོན་ཁ་ཐུག་ལུ་འགྱོ་མི་ སྣུམ་འཁོར་ཅིག་ལུ་ ཐུག་པའི་སྐབས་ཨིན།\/\/སྣུམ་འཁོར་ཆ་མཉམ་ འདི་ཚུ་མགྱོགས་ཚད་གཅིག་སྦེ་འགྱོ་དོ་ སྣུམ་འཁོར་གཉིས་ཅིག་ ཐུག་དོ་ཡོདཔ་སྦེ་སླབ་ཨིན།\/\/ཕྲང་ལམ་འདི་གཡོན་ཁ་ཐུག་འགྱོ་དོ་ཡོདཔ་དང་ སྣུམ་འཁོར་གཉིས་འདི་ ཕྲང་ལམ་འདི་ལས་ ཐག་རིང་ས་ཅིག་ཁར་འགྱོ་དོ་ཡོདཔ་དང་\/\/ཕྲ་རིང་འདི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་ ཕྲ་རིང་གི་མཐའ་མཚམས་ལུ་ཡོད་པའི་\/\/ཐད་ཀར་དུ་ཕྲང་ཡོད་པའི་ལམ་འདི་ མཐའ་མེད་པའི་རིང་ཚད་ཅིག་ཨིནམ་སྦེ་མནོ་བསམ་གཏང་དགོ།fn car_race_collision(n: isize) -> isize {\n","canonical_solution":"fn car_race_collision(n: isize) -> isize {\n    \/\/ Since every car moving left to right will collide exactly once\n    \/\/ with every car moving right to left, the number of collisions is n * n\n    n * n\n}\n\nfn main() {\n    let n = 5;\n    println!(\"Number of collisions: {}\", car_race_collision(n));\n}","tests":"}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"},{"task_id":"HumanEval_42","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ སླར་ལོག་འབད་ནིའི་ ཝེ་ཀཊར་འདི་ ཆ་ཤས་ཚུ་དང་བསྟུན་ཏེ་ ༡ ལུ་ཡར་སེང་འབདཝ་ཨིན།\/\/\/ >>> incr_list(vec![1, 2, 3])\n\/\/\/ vec![2, 3, 4]\n\/\/\/ >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|&x| x + 1).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = incr_list;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);\n    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n"},{"task_id":"HumanEval_43","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ༠ ལུ་བསྡོམས་ཏེ་ དེ་ལས་རྫུས་མ་ཨིན།\/\/\/ འདི་ true སླར་ལོག་འབདཝ་ཨིན། ཝི་ཅཊར་ནང་ལུ་ ཁྱད་པར་ཅན་གྱི་ཆ་ཤས་གཉིས་ཡོད་པ་ཅིན་\/\/\/ pairs_sum_to_zero གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ ཝི་ཅཊ་ཅིག་ཨེབ་གཏང་འབད་སྦེ་ལེན་འབདཝ་ཨིན།\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(vec![1])\n\/\/\/ false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    use std::collections::HashSet;\n    let mut seen = HashSet::new();\n    \n    for &num in &l {\n        if seen.contains(&-num) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, 5, 0])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, -2, 1])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 2, 3, 7])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); \/\/ true\n    println!(\"{}\", pairs_sum_to_zero(vec![1])); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"},{"task_id":"HumanEval_44","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གཞི་གྲངས་འདི་ ༡༠ ལས་ཉུང་ཡོདཔ་ཨིན།\/\/\/ གིས་ བསྒྱུར་བཅོས་འབད་བའི་ཤུལ་ལས་ string ངོ་ཚབ་ལོག་འབདཝ་ཨིན།\/\/ཨང་གྲངས་ x གི་ཨང་གྲངས་གཞི་རྟེན་གཞི་རྟེན་ལུ་ བསྒྱུར་བཅོས་འབད།\/\/\/ >>> change_base(8, 3)\n\/\/\/ String::from(\"22\")\n\/\/\/ >>> change_base(8, 2)\n\/\/\/ String::from(\"1000\")\n\/\/\/ >>> change_base(7, 2)\n\/\/\/ String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n","canonical_solution":"fn change_base(x: isize, base: isize) -> String {\n    if base < 2 || base > 9 {\n        panic!(\"Base must be between 2 and 9\");\n    }\n    \n    if x == 0 {\n        return String::from(\"0\");\n    }\n    \n    let mut result = String::new();\n    let mut number = x;\n    \n    while number > 0 {\n        let remainder = number % base;\n        result.push_str(&remainder.to_string());\n        number \/= base;\n    }\n    \n    result.chars().rev().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"},{"task_id":"HumanEval_45","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཟུར་ཐིག་གི་རིང་ཚད་དང་ ཚད་མཐོ་ཤོས་སླར་ལོག་འབད་སའི་ས་སྒོ་འདི་གསུམ་ཟུར་ཅིག་ལུ་བྱིན་ནུག\/\/\/ >>> triangle_area(5, 3)\n\/\/\/ 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, h: isize) -> f64 {\n    (a as f64 * h as f64) \/ 2.0\n}\n\nfn main() {\n    let area = triangle_area(5, 3);\n    println!(\"{}\", area);\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5, 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10, 8), 40.0);\n}\n"},{"task_id":"HumanEval_46","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ fib4 ཨང་རིམ་གྱི་ཆ་ཤས་ n པ་ངེས་འཛིན་འབད་ནིའི་དོན་ལུ་ ལས་འགན་ཅིག་འབྲི་གནང་། སླར་ལོག་འབད་ནི་མི་ལག་ལེན་འཐབ་།\/\/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) ཚུ་ཨིན།\/\/\/ fib4(3) -> ༠ ཟེར་\/\/\/ fib4(2) -> ༢ ཨིན།\/\/\/ fib4(1) -> ༠ \/\/\/ fib4(0) -> ༠ ཟེར་\/\/Fib4 ཨང་རིམ་འདི་ Fibbonacci གི་རིམ་པ་བཟུམ་ཅིག་ཨིནམ་དང་ འདི་ཡང་ ཤུལ་མའི་ནང་བཀོད་དེ་ཡོདཔ་ཨིན།\/\/\/ >>> fib4(5)\n\/\/\/ 4\n\/\/\/ >>> fib4(6)\n\/\/\/ 8\n\/\/\/ >>> fib4(7)\n\/\/\/ 14\nfn fib4(n: isize) -> isize {\n","canonical_solution":"fn fib4(n: isize) -> isize {\n    if n < 0 {\n        return 0; \/\/ Define behavior for negative input\n    }\n\n    let mut sequence = vec![0, 0, 2, 0];\n\n    if n < 4 {\n        return sequence[n as usize];\n    }\n\n    for i in 4..=n {\n        let next_value = sequence[(i - 1) as usize] \n                       + sequence[(i - 2) as usize] \n                       + sequence[(i - 3) as usize] \n                       + sequence[(i - 4) as usize];\n        sequence.push(next_value);\n    }\n\n    sequence[n as usize]\n}\n\nfn main() {\n    println!(\"{}\", fib4(5)); \/\/ 4\n    println!(\"{}\", fib4(6)); \/\/ 8\n    println!(\"{}\", fib4(7)); \/\/ 14\n}","tests":"}\n\nfn main() {\n    let candidate = fib4;\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 28);\n    assert_eq!(candidate(10), 104);\n    assert_eq!(candidate(12), 386);\n}\n"},{"task_id":"HumanEval_47","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཝེ་ཊར་ནང་ཡོད་པའི་ཆ་ཤས་ཚུ་གི་བར་མཚམས་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> median(vec![3, 1, 2, 4, 5])\n\/\/\/ 3.0\n\/\/\/ >>> median(vec![-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfn median(l: Vec<isize>) -> f64 {\n","canonical_solution":"fn median(l: Vec<isize>) -> f64 {\n    let mut l = l.clone();\n    l.sort();\n    let len = l.len();\n\n    if len % 2 == 0 {\n        let mid1 = len \/ 2;\n        let mid2 = mid1 - 1;\n        ((l[mid1] as f64) + (l[mid2] as f64)) \/ 2.0\n    } else {\n        l[len \/ 2] as f64\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6, 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"},{"task_id":"HumanEval_48","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གྲལ་ཐིག་འདི་ ཇི་ཇི་ཇི་སྦེ་ཡོད་མེད་བརྟག་དཔྱད་འབདཝ་ཨིན།\/\/\/ >>> is_palindrome(String::from(\"\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aba\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aaaaa\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"zbcd\"))\n\/\/\/ false\nfn is_palindrome(text: String) -> bool {\n","canonical_solution":"fn is_palindrome(text: String) -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in 0..len \/ 2 {\n        if chars[i] != chars[len - 1 - i] {\n            return false;\n        }\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"},{"task_id":"HumanEval_49","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ 2^n modulo p སླར་ལོག་འབདཝ་ཨིན། (ཨང་གྲངས་ཚུ་ཤེས་དགོ)\/\/\/ >>> modp(3, 5)\n\/\/\/ 3\n\/\/\/ >>> modp(1101, 101)\n\/\/\/ 2\n\/\/\/ >>> modp(0, 101)\n\/\/\/ 1\n\/\/\/ >>> modp(3, 11)\n\/\/\/ 8\n\/\/\/ >>> modp(100, 101)\n\/\/\/ 1\nfn modp(n: isize, p: isize) -> isize {\n","canonical_solution":"fn modp(n: isize, p: isize) -> isize {\n    if p == 1 {\n        return 0;\n    }\n    let mut result = 1;\n    let mut base = 2 % p;\n    let mut exponent = n;\n    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        exponent \/= 2;\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"},{"task_id":"HumanEval_51","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ remove_vowels འདི་ལས་རིམ་ཅིག་ཨིན་མི་འདི་ string དང་ vowels ཚུ་མེད་པར་ string སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> remove_vowels(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"abcdef\"))\n\/\/\/ String::from(\"bcdf\")\n\/\/\/ >>> remove_vowels(String::from(\"aaaaa\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"aaBAA\"))\n\/\/\/ String::from(\"B\")\n\/\/\/ >>> remove_vowels(String::from(\"zbcd\"))\n\/\/\/ String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n","canonical_solution":"fn remove_vowels(text: String) -> String {\n    text.chars()\n        .filter(|&c| !\"aeiouAEIOU\".contains(c))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_vowels;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"abcdef\nghijklm\")), String::from(\"bcdf\nghjklm\"));\n    assert_eq!(candidate(String::from(\"fedcba\")), String::from(\"fdcb\"));\n    assert_eq!(candidate(String::from(\"eeeee\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"acBAA\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"EcBOO\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"ybcd\")), String::from(\"ybcd\"));\n}\n"},{"task_id":"HumanEval_52","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ སླར་ལོག་འབདཝ་ཨིན། གལ་སྲིད་ ཝི་ཅཊར་ l ནང་གི་ཨང་གྲངས་ཆ་མཉམ་དེ་ གནས་གོང་ཐིག་ཁྲམ་ལས་མར་ཡོད་པ་ཅིན་ ཨིན་པུཊི་ true སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> below_threshold(vec![1, 2, 4, 10], 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(vec![1, 20, 4, 10], 5)\n\/\/\/ false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n","canonical_solution":"fn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().all(|&x| x < t)\n}\n\nfn main() {\n    println!(\"{}\", below_threshold(vec![1, 2, 4, 10], 100)); \/\/ true\n    println!(\"{}\", below_threshold(vec![1, 20, 4, 10], 5));  \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = below_threshold;\n    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);\n}\n"},{"task_id":"HumanEval_53","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/x དང་ y ཟེར་བའི་ཨང་གྲངས་གཉིས་བསྡོམས་འབད།\/\/\/ >>> add(2, 3)\n\/\/\/ 5\n\/\/\/ >>> add(5, 7)\n\/\/\/ 12\nfn add(x: isize, y: isize) -> isize {\n","canonical_solution":"fn add(x: isize, y: isize) -> isize {\n    x + y\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(0, 1), 1);\n    assert_eq!(candidate(1, 0), 1);\n    assert_eq!(candidate(2, 3), 5);\n    assert_eq!(candidate(5, 7), 12);\n    assert_eq!(candidate(7, 5), 12);\n}\n"},{"task_id":"HumanEval_54","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཚིག་གཉིས་ནང་ལུ་ ཡིག་འབྲུ་འདྲ་མཉམ་ཡོད་མེད་བལྟ་། \/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n\/\/\/ false\nfn same_chars(s0: String, s1: String) -> bool {\n","canonical_solution":"use std::collections::HashSet;\n\nfn same_chars(s0: String, s1: String) -> bool {\n    let set0: HashSet<char> = s0.chars().collect();\n    let set1: HashSet<char> = s1.chars().collect();\n    set0 == set1\n}\n\nfn main() {\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"aabb\"), String::from(\"aaccc\")), false);\n}\n"},{"task_id":"HumanEval_55","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ n-th གི་བི་བེ་ནོ་ཀི་ཨང་གྲངས་ལོག་གཏང་། \/\/\/ >>> fib(10)\n\/\/\/ 55\n\/\/\/ >>> fib(1)\n\/\/\/ 1\n\/\/\/ >>> fib(8)\n\/\/\/ 21\nfn fib(n: isize) -> isize {\n","canonical_solution":"fn fib(n: isize) -> isize {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }\n}\n\nfn main() {\n    println!(\"{}\", fib(10)); \/\/ 55\n    println!(\"{}\", fib(1));  \/\/ 1\n    println!(\"{}\", fib(8));  \/\/ 21\n}","tests":"}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10), 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n    assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"},{"task_id":"HumanEval_56","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གིས་ true སླར་ལོག་འབདཝ་ཨིན། གལ་སྲིད་སྒོ་སྒྲིག་རེ་ལུ་ འདྲ་མཉམ་གྱི་སྒོ་སྒྲིག་ཅིག་ཡོད་པ་ཅིན་ \/\/\/ brackets འདི་ \"<\" དང་ \">\" ཚུ་གི་ཐིག་ཁྲམ་ཨིན།\/\/\/ >>> correct_bracketing(String::from(\"<\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"<>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"<<><>>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"><<>\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n            balance += 1;\n        } else if bracket == '>' {\n            balance -= 1;\n            if balance < 0 {\n                return false;\n            }\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n}\n"},{"task_id":"HumanEval_57","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ སླར་ལོག་འབད་མི་དེ་བདེན་པ་ཨིན་པ་ཅིན་ ཝི་ཅཊ་ཆ་ཤས་ཚུ་ གཅིག་མཚུངས་སྦེ་ཡར་སེང་འགྱོ་དོ་ ཡང་ན་ མར་ཕབ་འགྱོ་དོ་ཡོདཔ་ཨིན།\/\/\/ >>> monotonic(vec![1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(vec![1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(vec![4, 1, 0, -10])\n\/\/\/ true\nfn monotonic(l: Vec<isize>) -> bool {\n","canonical_solution":"fn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n    \n    let mut increasing = true;\n    let mut decreasing = true;\n    \n    for i in 0..l.len() - 1 {\n        if l[i] < l[i + 1] {\n            decreasing = false;\n        }\n        if l[i] > l[i + 1] {\n            increasing = false;\n        }\n    }\n    \n    increasing || decreasing\n}\n\nfn main() {\n    println!(\"{}\", monotonic(vec![1, 2, 4, 20])); \/\/ true\n    println!(\"{}\", monotonic(vec![1, 20, 4, 10])); \/\/ false\n    println!(\"{}\", monotonic(vec![4, 1, 0, -10])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1, 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n    assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"},{"task_id":"HumanEval_58","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཝེ་ཀཊར་གཉིས་གི་དོན་ལུ་ དབྱེ་བ་ཕྱེ་མི་ ཁྱད་ཆོས་ཅན་གྱི་མཉམ་འབྲེལ་གྱི་ཆ་ཤས་ལོག་གཏང་།\/\/\/ >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n\/\/\/ vec![1, 5, 653]\n\/\/\/ >>> common(vec![5, 3, 2, 8], vec![3, 2])\n\/\/\/ vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashSet;\n\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    \/\/ Convert both vectors to hash sets to remove duplicates and allow set operations\n    let set1: HashSet<_> = l1.into_iter().collect();\n    let set2: HashSet<_> = l2.into_iter().collect();\n\n    \/\/ Find the intersection of both sets\n    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();\n\n    \/\/ Convert the intersection set to a sorted vector\n    let mut result: Vec<_> = intersection.into_iter().collect();\n    result.sort();\n\n    result\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); \/\/ Should print: [1, 5, 653]\n    println!(\"{:?}\", common(vec![5, 3, 2, 8], vec![3, 2])); \/\/ Should print: [2, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_59","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/nགི་ ཁྱབ་ཚད་སྦོམ་ཤོས་སླར་ལོག་འབདཝ་ཨིན། n > 1འདི་ ཁྱབ་ཚད་མེན་པ་ཅིན་ཨིན།\/\/\/ >>> largest_prime_factor(13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(2048)\n\/\/\/ 2\nfn largest_prime_factor(n: isize) -> isize {\n","canonical_solution":"fn largest_prime_factor(mut n: isize) -> isize {\n    let mut largest_factor = 1;\n\n    \/\/ Check for number of twos that divide n\n    while n % 2 == 0 {\n        largest_factor = 2;\n        n \/= 2;\n    }\n\n    \/\/ n must be odd at this point, so we can skip even numbers\n    let mut factor = 3;\n    while factor * factor <= n {\n        while n % factor == 0 {\n            largest_factor = factor;\n            n \/= factor;\n        }\n        factor += 2;\n    }\n\n    \/\/ If n becomes a prime number greater than 2\n    if n > 2 {\n        largest_factor = n;\n    }\n\n    largest_factor\n}\n\nfn main() {\n    println!(\"{}\", largest_prime_factor(13195));\n    println!(\"{}\", largest_prime_factor(2048));\n}","tests":"}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"},{"task_id":"HumanEval_60","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ sum_to_n འདི་ལས་ 1 ལས་ n ཚུན་གྱི་ཨང་གྲངས་ཚུ་བསྡོམས་འབདཝ་ཨིན།\/\/\/ >>> sum_to_n(30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(1)\n\/\/\/ 1\nfn sum_to_n(n: isize) -> isize {\n","canonical_solution":"fn sum_to_n(n: isize) -> isize {\n    n * (n + 1) \/ 2\n}","tests":"}\n\nfn main() {\n    let candidate = sum_to_n;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(6), 21);\n    assert_eq!(candidate(11), 66);\n    assert_eq!(candidate(30), 465);\n    assert_eq!(candidate(100), 5050);\n}\n"},{"task_id":"HumanEval_61","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གིས་ true སླར་ལོག་འབདཝ་ཨིན། གལ་སྲིད་སྒོ་སྒྲིག་རེ་ལུ་ འདྲ་མཉམ་གྱི་སྒོ་སྒྲིག་ཅིག་ཡོད་པ་ཅིན་ \/\/\/ brackets འདི་ \"(\" དང་ \"\") ཟེར་མི་ string ཅིག་ཨིན།\/\/\/ >>> correct_bracketing(String::from(\"(\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"()\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"(()())\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\")(()\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for c in brackets.chars() {\n        if c == '(' {\n            balance += 1;\n        } else if c == ')' {\n            balance -= 1;\n        }\n\n        if balance < 0 {\n            return false;\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n}\n"},{"task_id":"HumanEval_62","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ འ་ནི་ཨང་གྲངས་མང་པོའི་ དོ་འགྲན་འདི་ འདྲ་བཟོ་ནང་ལོག་གཏང་།\/\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/\/ xs འདི་ མང་གྲངས་ཀྱི་གནས་གོང་ཚུ་ཨིན།\/\/\/ >>> derivative(vec![3, 1, 2, 4, 5])\n\/\/\/ vec![1, 4, 12, 20]\n\/\/\/ >>> derivative(vec![1, 2, 3])\n\/\/\/ vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &coeff) in xs.iter().enumerate().skip(1) {\n        result.push(coeff * i as isize);\n    }\n    result\n}\n\nfn main() {\n    let poly1 = vec![3, 1, 2, 4, 5];\n    let poly2 = vec![1, 2, 3];\n    println!(\"{:?}\", derivative(poly1)); \/\/ Output: [1, 4, 12, 20]\n    println!(\"{:?}\", derivative(poly2)); \/\/ Output: [2, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_63","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ fib fib ཨང་གྲངས་རིམ་གྱི་ཆ་ཤས་ n པ་འདི་ ཤུགས་ལྡན་སྦེ་རྩིས་སྟོན་འབད་ནིའི་དོན་ལུ་ ལས་འགན་ཅིག་འབྲི་གནང་ \/\/\/ fib fib (n) == fib fib (n-1) + fib fib (n-2) + fib fib (n-3) ཨིན་པུཊི་གིས་འབད་ཡོདཔ་ཨིན།\/\/\/ fib fib(2) == ༡ \/\/\/ fib fib ((1)) == 0 \/\/\/ fib fib(0) == 0 \/\/\/FibFib ཨང་རིམ་འདི་ Fibbonacci sequence དང་འདྲ་བའི་རིམ་པ་ཅིག་ཨིནམ་དང་ འདི་ཚུ་ འོག་གི་བཟུམ་སྦེ་གསལ་བཀོད་འབདཝ་ཨིན།\/\/\/ >>> fibfib(1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(8)\n\/\/\/ 24\nfn fibfib(n: isize) -> isize {\n","canonical_solution":"fn fibfib(n: isize) -> isize {\n    if n < 0 {\n        \/\/ Optionally handle negative indices as an error or specific value\n        return -1; \/\/ Example error indicator\n    }\n    match n {\n        0 => 0,\n        1 => 0,\n        2 => 1,\n        _ => {\n            let mut a = 0;\n            let mut b = 0;\n            let mut c = 1;\n            let mut result = 0;\n            for _ in 3..=n {\n                result = a + b + c;\n                a = b;\n                b = c;\n                c = result;\n            }\n            result\n        }\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = fibfib;\n    assert_eq!(candidate(2), 1);\n    assert_eq!(candidate(1), 0);\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 24);\n    assert_eq!(candidate(10), 81);\n    assert_eq!(candidate(12), 274);\n    assert_eq!(candidate(14), 927);\n}\n"},{"task_id":"HumanEval_64","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/\/ ཁ་ཚིག་གི་མཇུག་ལུ་ཡོད་པའི་སྐད་ཡིག་ནང་ལུ་རང་ ཨིན།\/\/\/ འ་ནི་གནས་སྟངས་ནང་ལུ་ ཚིག་ཡིག་འདི་ 'a', 'e', 'i', 'o', 'u' ཨིན། འ་ནི་ནང་ལུ་ 'y' འདི་ཡང་ a ཨིན།\/\/\/ ཚིག་ཅིག་ཨེབ་གཏང་འབད་ཞིནམ་ལས་ string ནང་གི་ཕྲ་རིང་གི་གྱངས་ཁ་ལོག་བསྐྱལ་འོང་།\/\/\/ སྒྲུབ་རྟགས་ vowels_count དེ་ ནང་ལུ་ string ཅིག་བཙུགསཔ་ཨིན།\/\/\/ >>> vowels_count(String::from(\"abcde\"))\n\/\/\/ 2\n\/\/\/ >>> vowels_count(String::from(\"ACEDY\"))\n\/\/\/ 3\nfn vowels_count(s: String) -> isize {\n","canonical_solution":"fn vowels_count(s: String) -> isize {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let s = s.to_lowercase();\n    let mut count = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {\n            count += 1;\n        }\n    }\n    \n    count\n}\n\nfn main() {\n    println!(\"{}\", vowels_count(String::from(\"abcde\"))); \/\/ Output: 2\n    println!(\"{}\", vowels_count(String::from(\"ACEDY\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"},{"task_id":"HumanEval_65","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ག་དེམ་ཅིག་སྦེ་ ཨང་གྲངས་སེཕ་ > འབད་བ་ཅིན་ ཨང་གྲངས་ལོག་གཏང་།\/\/\/ དེ་ལས་ གྲུབ་འབྲས་འདི་ string སྦེ་ལོག་གཏང་འོང་།\/\/ཕྲང་སྒྲིག་ནང་ ཨང་གྲངས་ཧྲིལ་ཨང་ x གི་ཨང་གྲངས་ཚུ་སོར་གཏང་། ཨང་གྲངས་ཚུ་གཡས་ཁ་ཐུག་སོར་གཏང་།\/\/\/ >>> circular_shift(12, 1)\n\/\/\/ String::from(\"21\")\n\/\/\/ >>> circular_shift(12, 2)\n\/\/\/ String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n","canonical_solution":"fn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits: Vec<char> = x.abs().to_string().chars().collect();\n    let len = digits.len() as isize;\n    \n    if shift > len {\n        digits.reverse();\n    } else {\n        digits.rotate_right(shift as usize % len as usize);\n    }\n    \n    digits.into_iter().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100, 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12, 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"11\"));\n}\n"},{"task_id":"HumanEval_66","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/ASCII ཀོཌ་ཚུ་ཨིན།\/\/\/ ལས་འགན་ཅིག་འབྲི་བ་ཅིན་ ནང་ཐིག་སྦེ་ string དང་ སྟེང་གི་ཡིག་འབྲུ་ཚུ་བསྡོམས་ཏེ་ལོག་བྱིན་འོང་།' \/\/ལཱ་འགན་ \/\/\/ >>> digitSum(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> digitSum(String::from(\"abAB\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"abcCd\"))\n\/\/\/ 67\n\/\/\/ >>> digitSum(String::from(\"helloE\"))\n\/\/\/ 69\n\/\/\/ >>> digitSum(String::from(\"woArBld\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"aAaaaXa\"))\n\/\/\/ 153\nfn digitSum(s: String) -> isize {\n","canonical_solution":"fn digitSum(s: String) -> isize {\n    s.chars()\n     .filter(|c| c.is_uppercase())\n     .map(|c| c as isize)\n     .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = digitSum;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abAB\")), 131);\n    assert_eq!(candidate(String::from(\"abcCd\")), 67);\n    assert_eq!(candidate(String::from(\"helloE\")), 69);\n    assert_eq!(candidate(String::from(\"woArBld\")), 131);\n    assert_eq!(candidate(String::from(\"aAaaaXa\")), 153);\n    assert_eq!(candidate(String::from(\" How are yOu?\")), 151);\n    assert_eq!(candidate(String::from(\"You arE Very Smart\")), 327);\n}\n"},{"task_id":"HumanEval_67","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ གི་དོན་ལུ་ examble: \/\/\/ in the basket ནང་ལུ་ མེ་རླུང་རྒྱ་རྫི་གི་འབྲས་བུ་ཚུ་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ ཨ་ལཱན་ཅི་དང་ ཨེ་པཱལ་ དེ་ལས་ ཨང་གྲངས་ཧྲིལ་བུམ་འདི་ ཤིང་འབྲས་ཀྱི་ཨང་གྲངས་ཡོངས་བསྡོམས་འདི་ཨིན།\/\/ཨེཕ་ལོམ་དང་ ཨེཕ་ལོམ་ དེ་ལས་ མེན་གོ་གི་འབྲས་བུ་ཚུ་ ཨིནམ་ད་ ཨེཕ་ལོམ་དང་ ཨེཕ་ལོམ་ དེ་ལས་ མེན་གོ་གི་འབྲས་བུ་ཚུ་ ཨིནམ་སྦེ་རྩིས་སྟོནམ་ཨིན།\/\/\/ འདི་ཚུ་ཤིང་འབྲས་ཀྱི་ཙེལ་ཀ་ནང་ལུ་ བཀྲམ་སྤེལ་འབད་ཡོདཔ་ད་ ཙེལ་ཀ་འདི་ནང་ལུ་ ཤིང་འབྲས་ཚུ་ཡོདཔ་ཨིན།\/\/འ་ནི་ལཱ་འདི་ནང་ལུ་ ཁྱོད་ཀྱིས་ ཨེབ་གཏང་འབད་ཡོད་པའི་ ཨང་གྲངས་དང་ ཨེཕ་ལེཊི་ཚུ་ངོ་ཚབ་འབད་ཡོད་པའི་ ཀེར་ཐིག་ཅིག་ཐོབ་འོང་།\/\/\/ >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n\/\/\/ 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n","canonical_solution":"fn fruit_distribution(s: String, n: isize) -> isize {\n    let mut parts = s.split_whitespace();\n    let apples: isize = parts.next().unwrap().parse().unwrap();\n    parts.next(); \/\/ skip \"apples\"\n    parts.next(); \/\/ skip \"and\"\n    let oranges: isize = parts.next().unwrap().parse().unwrap();\n    \n    n - (apples + oranges)\n}\n\nfn main() {\n    assert_eq!(fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120), 19);\n    println!(\"All test cases passed!\");\n}","tests":"}\n\nfn main() {\n    let candidate = fruit_distribution;\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 21), 10);\n    assert_eq!(candidate(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"1 apples and 0 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 5), 0);\n    assert_eq!(candidate(String::from(\"1 apples and 100 oranges\"), 120), 19);\n}\n"},{"task_id":"HumanEval_68","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ ༡:\/\/\/ ག་དེམ་ཅིག་སྦེ་ གནས་གོང་ཆ་སྙོམ་མེད་པ་ཅིན་ ཡང་ན་ ཝི་ཅཊ་འདི་སྟོངམ་ཡོད་པ་ཅིན་ སླར་ལོག་འབདཝ་ཨིན།\/\/\/ བཏོན་ཡོད་པའི་ཨང་འདི་ ཝི་ཅཊར་ནང་ལུ་ལོག་གཏང་དགོ། [smallest_value, its index], \/\/\/ ཕྲང་སྒྲིག་ཕྲང་སྒྲིག་ཆུང་ཤོས་ཅིག་ཡོད་པའི་ཕྲང་སྒྲིག་ལེ་ཤ་ཅིག་ཐོབ་པ་ཅིན་ ཕྲང་སྒྲིག་ཆུང་ཤོས་ཡོད་པའི་ཕྲང་སྒྲིག་དེ་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ ཟུར་ཐིག་འདི་ ཆུང་ཤོས་རང་ ཕྲང་རྟགས་ཡོད་པའི་ ཟུར་ཐིག་འདི་འབད་དགོཔ་ཨིན།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ ཀེར་ཐིག་གཅིག་བཏོན་ཏེ་ ལོག་གཏང་ནི་དེ་ཨིན།\/\/\/ \"མི་-ཟད་ཅན་ཨང་གྲངས་ཨང་བཏགས་མི་ ཤིང་གི་ཡལ་ག་ངོ་ཚབ་འབད་མི་ ཝི་ཅཊ་ཅིག་བྱིན་ནུག\/\/\/ >>> pluck(vec![4, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(vec![1, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\/\/\/ vec![0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even: Option<(isize, usize)> = None;\n\n    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n            match smallest_even {\n                None => smallest_even = Some((value, index)),\n                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),\n                _ => {}\n            }\n        }\n    }\n\n    match smallest_even {\n        Some((value, index)) => vec![value, index as isize],\n        None => Vec::new(),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_69","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ དེ་བཟུམ་གྱི་གནས་གོང་མེད་པ་ཅིན་ -1 སླར་ལོག་འབདཝ་ཨིན།\/\/ཨང་གྲངས་ཧྲིལ་བུའི་འཕྲལ་འཕྲལ་འདི་ ཝེ་ཀཊར་ནང་ལུ་གྱངས་ཁ་ག་དེམ་ཅིག་འོང་དོ་ག་འདི་ཨིན།\/\/\/ ༠ དང་ རྒྱུན་ལྡན་འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་གནས་གོང་ལས་ སྦོམ་ ཡང་ན་ འདྲན་འདྲ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ནུས་ལྡན་ཨང་གྲངས་ཀྱི་ སྟོངམ་མེན་པའི་ ཝི་ཅཊ་ཐོབ་ཡོདཔ་ཨིན། དེ་ལས་སྦོམ་པའི་ཨང་གྲངས་སྦོམ་ཤོས་དེ་སླར་ལོག་འབད།\/\/\/ >>> search(vec![4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(vec![5, 5, 4, 4, 4])\n\/\/\/ -1\nfn search(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn search(lst: Vec<isize>) -> isize {\n    use std::collections::HashMap;\n    \n    let mut frequency_map = HashMap::new();\n    \n    \/\/ Count the frequency of each integer in the vector\n    for &num in &lst {\n        *frequency_map.entry(num).or_insert(0) += 1;\n    }\n    \n    let mut result = -1;\n    \n    \/\/ Iterate over the map to find the greatest integer with a frequency\n    \/\/ greater than or equal to its value\n    for (&num, &freq) in &frequency_map {\n        if freq >= num && num > result {\n            result = num;\n        }\n    }\n    \n    result\n}\n\n\/\/ Test cases\nfn main() {\n    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);\n    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);\n    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);\n}","tests":"}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n    assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]), 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]), -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n}\n"},{"task_id":"HumanEval_70","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/དེ་ལས་ལྷག་ལུས་ཨང་གྲངས་ཆ་མཉམ་ནང་ལས་ མཐོ་ཤོས་དང་ དམའ་ཤོས་ དེ་ལས་འདི་བཟུམ་འབད་ཡོདཔ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཇི་ཉུང་མཐའ་ལས་འགོ་བཙུགས་པ་ཅིན་ ཇི་ཉུང་མཐའ་འདི་ ཇི་ཉུང་མཐའ་ལས་འགོ་བཙུགས་པ་ཅིན་ ཇི་ཉུང་མཐའ་འདི་ ཇི་ཉུང་མཐའ་ལས་འགོ་བཙུགས་པ་ཅིན་ ཇི་ཉུང་མཐའ་འདི་ ཇི་ཉུང་མཐའ་ལས་འགོ་བཙུགས་པ་ཅིན་ ཇི་ཉུང་མཐའ་ལས་འགོ་བཙུགས་པ་ཅིན་\/\/\/ ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊ་འདི་བྱིན་པ་ཅིན་ ཝི་ཅཊ་འདི་རིམ་པ་རྣམ་རྟོག་ཅན་སྦེ་ལོག་གཏང་འོང་།\/\/\/ >>> strange_sort_list(vec![1, 2, 3, 4])\n\/\/\/ vec![1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(vec![5, 5, 5, 5])\n\/\/\/ vec![5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(vec![])\n\/\/\/ Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(lst.len());\n    lst.sort();\n\n    while !lst.is_empty() {\n        \/\/ Take the smallest element\n        if let Some(min) = lst.first().cloned() {\n            result.push(min);\n            lst.remove(0);\n        }\n        \/\/ Take the largest element\n        if let Some(max) = lst.last().cloned() {\n            result.push(max);\n            lst.pop();\n        }\n    }\n\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", strange_sort_list(vec![1, 2, 3, 4])); \/\/ Output: vec![1, 4, 2, 3]\n    println!(\"{:?}\", strange_sort_list(vec![5, 5, 5, 5])); \/\/ Output: vec![5, 5, 5, 5]\n    println!(\"{:?}\", strange_sort_list(vec![])); \/\/ Output: Vec::<isize>::new()\n}","tests":"}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n"},{"task_id":"HumanEval_71","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/དེ་ལས་གསུམ་པ་གི་ཁ་ཐུག་ལས་ \/\/གཡོན་གསུམ་གྱིས་ ཟུར་གཉིས་ཆ་རའི་བསྡོམས་སྦོམ་པ་ཅིན་ ཟུར་གསུམ་ཐིག་ཁྲམ་ཅིག་ བཟོ་ཚུགས།\/\/\/ དེ་མེན་པ་ཅིན་ལོག་གཏང་ -1 \/\/\/ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཟུར་གསུམ་འདི་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ ཆ་མཉམ་སྦེ་ཡོད་པ་ཅིན་\/\/\/ ཟུར་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཚུ་བྱིན་ཏེ་ གི་ཁྱབ་ཚད་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> triangle_area(3, 4, 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(1, 2, 10)\n\/\/\/ -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 \/ 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        (area * 100.0).round() \/ 100.0\n    } else {\n        -1.0\n    }\n}\n\nfn main() {\n    println!(\"{}\", triangle_area(3, 4, 5)); \/\/ 6.0\n    println!(\"{}\", triangle_area(1, 2, 10)); \/\/ -1.0\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3, 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4, 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1, 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2, 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2, 2, 10), -1.0);\n}\n"},{"task_id":"HumanEval_72","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/དངོས་པོ་ q འདི་ཚད་ལྡན་ཨིན་པ་ཅིན་ འཕུར་འགྲུལ་འབད་འོང་། (འདི་ palindromic vector ཅིག་ཨིནམ་དང་ འདི་ནང་གི་ཆ་ཤས་ཚུ་གི་བསྡོམས་དེ་ ཚད་ལྡན་གྱི་ལྗིད་ཚད་ w ལས་ཉུང་ ཡང་ན་ འདྲན་འདྲ་ཨིན།)\/\/དངོས་པོ་ q འདི་འཕུར་འགྱོ་བ་ཅིན་ true དང་ གཞན་འབད་བ་ཅིན་ false སླར་ལོག་འབད་ནིའི་འགན་ཁུར་ཅིག་འབྲི་དགོ།\/\/\/ >>> will_it_fly(vec![1, 2], 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(vec![3], 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n","canonical_solution":"fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let is_palindromic = q.iter().eq(q.iter().rev());\n\n    is_palindromic && sum <= w\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{}\", will_it_fly(vec![1, 2], 5)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 1)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 9)); \/\/ true\n    println!(\"{}\", will_it_fly(vec![3], 5)); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"},{"task_id":"HumanEval_73","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ འདི་ ཕྱོགས་གཉིས་ཆ་ར་ལུ་ འདྲ་མཉམ་སྦེ་ལྷག་ཨིན། བསྒྱུར་བཅོས་གཅིག་གི་ནང་ ཁྱོད་ཀྱིས་ ཨེཆ་ཨེམ་ཅིག་ལུ་ ཨེཆ་ཨེམ་གཞན་གཅིག་ལུ་ བསྒྱུར་བཅོས་འབད་ཚུགས།\/\/\/ འདི་ལུ་ བེ་ཊར་འདི་ ཇི་བཱལ་ཌི་རོམ་སྦེ་བཟོ་ནིའི་དོན་ལུ་ བསྒྱུར་བཅོས་འབད་དགོཔ་ཨིན། བེ་ཊར་ཇི་བཱལ་ཌི་རོམ་འདི་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཇི་བཱལ་ཌི་རོམ་ ཨིན།\/\/ཕྲང་གྲངས་མཐའ་དག་གི་ ཝི་ཅཊར་ཅིག་བྱིནམ་ད་ ཕྲང་གྲངས་མཐའ་དག་གི་ ཉུང་མཐའ་ཨང་གྲངས་འདི་འཚོལ་དགོ།\/\/\/ >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 2, 1])\n\/\/\/ 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn smallest_change(arr: Vec<isize>) -> isize {\n    let mut changes = 0;\n    let n = arr.len();\n    \n    for i in 0..n\/2 {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1;\n        }\n    }\n    \n    changes\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);\n\/\/     println!(\"{}\", result); \/\/ Outputs: 4\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"},{"task_id":"HumanEval_74","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་ \/\/ཝེ་ཀཊར་གཉིས་ཆ་ར་ལུ་ ཀ་ར་གྲངས་འདྲ་མཉམ་ཡོད་པ་ཅིན་ དང་པ་ཝེ་ཀཊར་འདི་ལོག་གཏང་།\/\/ཝེཊ་ཊར་གྱི་ཐིག་ཁྲམ་ཆ་མཉམ་ནང་ ཝེཊ་ཊར་གཞན་ལས་ཉུང་བའི་ ཌའི་ལོག་གི་གྱངས་ཁ་འདི་ཡོདཔ་ཨིན།\/\/\/ ལས་འགན་ཅིག་འབྲི་བ་ཅིན་ string གི་བེ་ཊར་གཉིས་ལེན་ཏེ་ ཡོད་པའི་བེ་ཊར་ལོག་ཐོབ་འོང་།\/\/\/ >>> total_match(vec![], vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"Hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n\/\/\/ vec![String::from(\"hi\"), String::from(\"admin\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n\/\/\/ vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();\n\n    if char_count(&lst1) <= char_count(&lst2) {\n        lst1\n    } else {\n        lst2\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    let result1 = total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    println!(\"{:?}\", result1);\n\n    let result2 = total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]);\n    println!(\"{:?}\", result2);\n}","tests":"}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"},{"task_id":"HumanEval_75","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/(a) འདི་ ༡༠༠ ལས་ཆུང་བ་ཨིནམ་ཤེས་པ་ཅིན་\/\/\/ དེ་ལས་རྫུས་མ་ཨིན།\/\/\/ གནས་རིམ་འདི་ true སླར་ལོག་འབད་ཡོད་པ་ཅིན་ ཨང་གྲངས་འདི་ ཨང་གྲངས་གཙོ་བོ་༣ གྱི་གྱངས་ཁ་ཨིན།\/\/\/ >>> is_multiply_prime(30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n","canonical_solution":"fn is_multiply_prime(a: isize) -> bool {\n    fn is_prime(n: isize) -> bool {\n        if n <= 1 {\n            return false;\n        }\n        if n <= 3 {\n            return true;\n        }\n        if n % 2 == 0 || n % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    if a < 2 {\n        return false;\n    }\n\n    let mut primes = Vec::new();\n    for i in 2..a {\n        if is_prime(i) {\n            primes.push(i);\n        }\n    }\n\n    let p_len = primes.len();\n    for i in 0..p_len {\n        for j in i..p_len {\n            for k in j..p_len {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = is_multiply_prime;\n    assert_eq!(candidate(5), false);\n    assert_eq!(candidate(30), true);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(125), true);\n    assert_eq!(candidate(105), true);\n    assert_eq!(candidate(126), false);\n    assert_eq!(candidate(729), false);\n    assert_eq!(candidate(891), false);\n    assert_eq!(candidate(1001), true);\n}\n"},{"task_id":"HumanEval_76","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/x འདི་ n གི་ཤུགས་ལྡན་ཅིག་ཨིན་པ་ཅིན་ n**int=x ཨིན།\/\/\/ ནུས་ཤུགས་དང་ གཞན་དོན་ཚན་ཚུ་ནང་རྫུས་མ་ཨིན།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ གྲངས་ཀ་ x འདི་ ཕྲང་ཨིན་པ་ཅིན་ true སླར་ལོག་འབད་ནིའི་འགན་ཁུར་འདི་འབྲི་ནི་ཨིན།\/\/\/ >>> is_simple_power(1, 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(2, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(8, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(3, 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(3, 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(5, 3)\n\/\/\/ false\nfn is_simple_power(x: isize, n: isize) -> bool {\n","canonical_solution":"fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n        return false;\n    } else if x == 1 {\n        return true;\n    } else if n == 1 {\n        return x == 1;\n    }\n\n    let mut power_n = n;\n    while power_n < x {\n        power_n *= n;\n    }\n    power_n == x\n}\n\nfn main() {\n    println!(\"{}\", is_simple_power(1, 4)); \/\/ true\n    println!(\"{}\", is_simple_power(2, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(8, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(3, 2)); \/\/ false\n    println!(\"{}\", is_simple_power(3, 1)); \/\/ false\n    println!(\"{}\", is_simple_power(5, 3)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"},{"task_id":"HumanEval_77","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་འཛུལ་ཞུགས་འདི་ དུས་རྒྱུན་དུ་ ཆ་གནས་ཅན་སྦེ་ར་ ཆ་བཞགཔ་ཨིན།\/\/འ་ནི་ཨང་གྲངས་འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་ཅིག་གི་ ཀུ་བིཀ་ཨིན་པ་ཅིན་།\/\/ཨང་གྲངས་ཧྲིལ་ཨང་ a དང་སླར་ལོག་འབད་མི་ལས་འགན་ཅིག་འབྲི་ \/\/\/ >>> iscube(1)\n\/\/\/ true\n\/\/\/ >>> iscube(2)\n\/\/\/ false\n\/\/\/ >>> iscube(-1)\n\/\/\/ true\n\/\/\/ >>> iscube(64)\n\/\/\/ true\n\/\/\/ >>> iscube(0)\n\/\/\/ true\n\/\/\/ >>> iscube(180)\n\/\/\/ false\nfn iscube(a: isize) -> bool {\n","canonical_solution":"fn iscube(a: isize) -> bool {\n    if a < 0 {\n        \/\/ For negative numbers, take the cube root of the absolute value.\n        let cube_root = (-a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    } else {\n        let cube_root = (a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    }\n}\n\nfn main() {\n    println!(\"{}\", iscube(1));   \/\/ true\n    println!(\"{}\", iscube(2));   \/\/ false\n    println!(\"{}\", iscube(-1));  \/\/ true\n    println!(\"{}\", iscube(64));  \/\/ true\n    println!(\"{}\", iscube(0));   \/\/ true\n    println!(\"{}\", iscube(180)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n"},{"task_id":"HumanEval_78","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/རྟགས་མཚན་ A,B,C,D,E,F འདི་ཨ་རྟག་རང་ སྦོམ་ཡིག་སྦེ་རང་ཨིན།\/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་ཨེབ་གཏང་འདི་ རྒྱུན་ཆད་མེད་པར་ཕྲང་ ཡང་ན་ སྟོང་པ་སྦེ་བཟོཝ་ཨིན།\/\/\/ བི་ (=བཅུ་ཆ་༡༡) དང་ཌི་ (=བཅུ་ཆ་༡༣) ཨིན།\/\/ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཚུ་ ངེས་གཏན་བཟོ་དགོཔ་ཨིན། ༢,༣,༥,༧, \/\/ཨང་གྲངས་ཨང་གྲངས་ཚུ་འདི་ ༢,༣,༥,༧,༡༡,༡༣,༡༧ ...ཨིན།\/\/ཨང་གྲངས་ཧེ་ཀ་ཌེ་སི་མཱལ་འདི་ ༠,༡,༢,༣,༤,༥,༦,༧,༨,༩, A,B,C,D,E,F ཨིན།\/\/\/ 1ལས་སྦོམ་འདི་ ཆུང་ཤོས་རང་ རང་བཞིན་གྱི་ཨང་གྲངས་གཉིས་ལས་ཐོན་མི་ཨིན།)\/\/ཨང་གྲངས་ཚུའི་ཨང་གྲངས་ཚུ་ (ཨང་གྲངས་ཚུའི་ཨང་གྲངས་ ཡང་ན་ ཨང་གྲངས་ཚུའི་ཨང་གྲངས་འདི་ རང་བཞིན་གྱི་ཨང་གྲངས་ཨིན།\/\/\/ ཨང་གྲངས་ཧེ་ཀ་ཌེ་སི་མཱལ་འདི་ string སྦེ་བཙུགས་ཏེ་ ཨང་གྲངས་ཧེ་ཀ་ཌེ་སི་མཱལ་ ཚུ་རྩིས་སྟོནམ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཐོབ་མི་ལས་འགན་ཅིག་འབྲི་དགོཔ་ཨིན།\/\/\/ >>> hex_key(String::from(\"AB\"))\n\/\/\/ 1\n\/\/\/ >>> hex_key(String::from(\"1077E\"))\n\/\/\/ 2\n\/\/\/ >>> hex_key(String::from(\"ABED1A33\"))\n\/\/\/ 4\n\/\/\/ >>> hex_key(String::from(\"123456789ABCDEF0\"))\n\/\/\/ 6\n\/\/\/ >>> hex_key(String::from(\"2020\"))\n\/\/\/ 2\nfn hex_key(num: String) -> isize {\n","canonical_solution":"fn hex_key(num: String) -> isize {\n    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars()\n        .filter(|c| prime_hex_chars.contains(c))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"},{"task_id":"HumanEval_79","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ ལྷག་ལུས་ཡིག་འབྲུ་ཚུ་ འབྲི་ཐངས་ལུ་ཕན་ཐོགས་པའི་དོན་ལུ་ཨིན།\/\/\/ string གི་འགོ་དང་མཇུག་ནང་ལུ་ ཌི་བི་ཡིག་འབྲུ་གཉིས་རེ་ལྷག་ལུས་འོང་།\/\/ཨང་གྲངས་ནང་ཡིག་འབྲུ་རེ་རེ་ '0' ཡང་ན་ '1' ཨིན།\/\/\/ binary format. functionའདི་གིས་ string སླར་ལོག་འབད་དགོཔ་ཨིན་ དེ་ལས་ཡིག་འབྲུ་རེ་རེ་གིས་ binary ཅིག་ངོ་ཚབ་འབདཝ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཨང་གྲངས་འདི་ ཨང་གྲངས་བཅུ་གྲངས་སྦེ་ཐོབ་སྟེ་ ཁྱོད་ཀྱི་ལཱ་འདི་ ཨང་གྲངས་འདི་ ལུ་བསྒྱུར་གཏང་ནི་ཨིན།\/\/\/ >>> decimal_to_binary(15)\n\/\/\/ String::from(\"db1111db\")\n\/\/\/ >>> decimal_to_binary(32)\n\/\/\/ String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n","canonical_solution":"fn decimal_to_binary(decimal: isize) -> String {\n    let binary_string = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary_string)\n}\n\nfn main() {\n    \/\/ Example usage\n    let binary_15 = decimal_to_binary(15);\n    let binary_32 = decimal_to_binary(32);\n    println!(\"{}\", binary_15); \/\/ Outputs: db1111db\n    println!(\"{}\", binary_32); \/\/ Outputs: db100000db\n}","tests":"}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n}\n"},{"task_id":"HumanEval_80","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/string འདི་ haprs ཨིནམ་ད་ འདི་ལུ་ ཡུན་ཚད་ཉུང་ཤོས་རང་ 3 དང་ ཚར་གསུམ་གྱི་ཡིག་འབྲུ་སོ་སོ་ཡོད་པ་ཅིན་ཨིན།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ stringའདི་ཕྲང་ཨིན་ན་མེན་ན་བརྟག་དཔྱད་འབད་དགོ\/\/ཁྱོད་ཀྱིས་ string s ཅིག་ཐོབ་ནུག\/\/\/ >>> is_happy(String::from(\"a\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"aa\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"aabb\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"adb\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"xyy\"))\n\/\/\/ false\nfn is_happy(s: String) -> bool {\n","canonical_solution":"fn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n\n    let chars: Vec<char> = s.chars().collect();\n    for i in 0..(chars.len() - 2) {\n        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    println!(\"{}\", is_happy(String::from(\"a\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"aa\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"aabb\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"adb\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"xyy\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"},{"task_id":"HumanEval_81","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/\/ 0.0 E ཨིན།\/\/\/ > 0.0 D- ཟེར་མི་འདི་\/\/\/ > 0.7 D ཨིན།\/\/\/ >༡.༠ D+ \/\/\/ > 1.3 C- ཟེར་མི་འདི་\/\/\/ > 1.7 C ཨིན།\/\/\/ >2.0 C+ ཟེར་མི་འདི་ཨིན།\/\/\/ > 2.3 བི་- \/\/\/ > 2.7 B ཨིན།\/\/\/ > ༣.༠ བི་+ \/\/\/ > 3.3 A- ཟེར་མི་འདི་\/\/\/ > 3.7 A ཟེར་མི་འདི་ཨིན།\/\/\/ ༤.༠ ཨེ+ ཨིན།\/\/GPA འབྲི་ཤོག་གི་ཨང་རྟགས་ \/\/\/ འདི་ནང་ལུ་ཡིག་འབྲུ་གི་ཚད་གཞི་ཚུ་ ཌའི་ལོག་ནང་ལུ་བཏོན་བཏུབ་པའི་ལས་འགན་ཅིག་ཨིན།\/\/ཁྱོད་ཀྱིས་ འབྲི་ཤོག་གི་ཐོག་ལས་ སློབ་ཕྲུག་ཚུ་གི་ GPA ཚད་གཞི་ཅིག་ བྱིན་ནུག\/\/དཀའ་ངལ་འདི་ མོ་གིས་གན་རྒྱ་བྱིན་ནིའི་དོན་ལུ་ ལག་ལེན་འཐབ་མི་ ཨང་བཏགས་འདི་འབྱང་སོང་ཡོདཔ་ཨིན།\/\/སློབ་དཔོན་གྱིས་ སྐུགས་ཚད་ཀྱི་དོན་ལུ་ མོ་རང་གི་ ཨལ་གོར་ཇི་མཱིས་བཟོ་ནུག\/\/སློབ་རིམ་མཇུག་གི་ བདུན་ཕྲག་འདི་ཨིནམ་ལས་ སློབ་དཔོན་གྱིས་ སྐུགས་ཚད་ཚུ་བྱིན་དགོཔ་ཨིན།\/\/\/ >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n\/\/\/ vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n","canonical_solution":"fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    grades.into_iter().map(|gpa| {\n        match gpa {\n            4.0 => String::from(\"A+\"),\n            v if v > 3.7 => String::from(\"A\"),\n            v if v > 3.3 => String::from(\"A-\"),\n            v if v > 3.0 => String::from(\"B+\"),\n            v if v > 2.7 => String::from(\"B\"),\n            v if v > 2.3 => String::from(\"B-\"),\n            v if v > 2.0 => String::from(\"C+\"),\n            v if v > 1.7 => String::from(\"C\"),\n            v if v > 1.3 => String::from(\"C-\"),\n            v if v > 1.0 => String::from(\"D+\"),\n            v if v > 0.7 => String::from(\"D\"),\n            v if v > 0.0 => String::from(\"D-\"),\n            _ => String::from(\"E\"),\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = numerical_letter_grade;\n    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]);\n    assert_eq!(candidate(vec![1.2]), vec![String::from(\"D+\")]);\n    assert_eq!(candidate(vec![0.5]), vec![String::from(\"D-\")]);\n    assert_eq!(candidate(vec![0.0]), vec![String::from(\"E\")]);\n    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(\"D\"), String::from(\"D-\"), String::from(\"C-\"), String::from(\"B\"), String::from(\"B+\")]);\n    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(\"E\"), String::from(\"D-\")]);\n}\n"},{"task_id":"HumanEval_82","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་ \/\/\/ length དེ་ཨང་གྲངས་ངོ་མ་ཅིག་ཨིན་པ་ཅིན་ ཡང་ན་ ཨང་གྲངས་རྫུས་མ་ཅིག་ཨིན་པ་ཅིན་ \/\/\/ སྒྲུབ་རྟགས་ཅིག་ཡིག་དཔར་འབད་ཞིནམ་ལས་ string འདི་བདེན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> prime_length(String::from(\"Hello\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"abcdcba\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"kittens\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"orange\"))\n\/\/\/ false\nfn prime_length(string: String) -> bool {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn prime_length(string: String) -> bool {\n    let length = string.len();\n    is_prime(length)\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", prime_length(String::from(\"Hello\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"abcdcba\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"kittens\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"orange\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"},{"task_id":"HumanEval_83","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དེ་ ༡ ལས་འགོ་བཙུགསཔ་ ཡང་ན་ མཇུག་བསྡུ་མི་ ནུས་ལྡན་ཨང་གྲངས་ཨིན།\/\/\/ ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ n ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ n-digit ཚུ་གི་རྩིས་ལོག་འབདཝ་ཨིན།fn starts_one_ends(n: isize) -> isize {\n","canonical_solution":"fn starts_one_ends(n: isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1; \/\/ only '1' satisfies the condition for a single-digit\n    }\n\n    \/\/ Consider numbers starting with '1' (1XXXX...)\n    let start_with_one = 9isize.pow((n-1) as u32);\n\n    \/\/ Consider numbers ending with '1' (...XXXX1)\n    let end_with_one = 9isize.pow((n-1) as u32);\n    \n    \/\/ Consider numbers both starting and ending with '1' and check overlaps (1XXX1)\n    let both_start_end_one = 9isize.pow((n-2) as u32);\n\n    \/\/ Total numbers starting or ending with '1'\n    start_with_one + end_with_one - both_start_end_one\n}\n\nfn main() {\n    \/\/ Example usage:\n    let n = 3;\n    println!(\"Count of n-digit numbers starting or ending with 1: {}\", starts_one_ends(n));\n}","tests":"}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"},{"task_id":"HumanEval_84","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ \/\/\/ ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ N ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཀྱི་རྩིས་གཞི་འདི་ གཉིས་ལྡན་སྦེ་ལོག་གཏང་། \/\/\/ >>> solve(1000)\n\/\/\/ String::from(\"1\")\n\/\/\/ >>> solve(150)\n\/\/\/ String::from(\"110\")\n\/\/\/ >>> solve(147)\n\/\/\/ String::from(\"1100\")\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfn solve(N: isize) -> String {\n","canonical_solution":"fn solve(N: isize) -> String {\n    let sum_of_digits: isize = N\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as isize)\n        .sum();\n    \n    format!(\"{:b}\", sum_of_digits)\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(1000), String::from(\"1\"));\n    assert_eq!(candidate(150), String::from(\"110\"));\n    assert_eq!(candidate(147), String::from(\"1100\"));\n    assert_eq!(candidate(333), String::from(\"1001\"));\n    assert_eq!(candidate(963), String::from(\"10010\"));\n}\n"},{"task_id":"HumanEval_85","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ སྟོངམ་མེན་པའི་ ཝི་ཅཊར་ཅིག་བྱིན་ཏེ་ lst འདི་ཡང་ ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་རྩིས་རྐྱབ་ཨིན།\/\/\/ >>> add(vec![4, 2, 6, 7])\n\/\/\/ 2\nfn add(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn add(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, _)| i % 2 == 1) \/\/ select odd indices\n        .map(|(_, &x)| x) \/\/ get the values at odd indices\n        .filter(|&x| x % 2 == 0) \/\/ filter even values\n        .sum() \/\/ sum the values\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(vec![4, 88]), 88);\n    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);\n    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);\n    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);\n}\n"},{"task_id":"HumanEval_86","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་ཚིག་དང་ བར་སྟོང་གི་རིམ་པ་ཚུ་ ཚིག་ཡིག་ནང་ལུ་བཞག་དགོ།\/\/\/ཡར་སེང་གི་རིམ་པ་ལུ་གཞི་བཞག་སྟེ་ ascii གནས་གོང་ལུ་གཞི་བཞག་སྟེ་ཨིན།\/\/\/ འདི་ ཚིག་གསརཔ་ཅིག་གིས་ཚབ་བཙུགས་ཡོདཔ་ད་ འདི་ནང་ལུ་ ཡིག་འབྲུ་ཆ་མཉམ་རིམ་སྒྲིག་འབད་ཡོདཔ་ཨིན།\/\/string གི་རིམ་སྒྲིག་འབད་ཡོད་པའི་རྣམ་པ་འདི་ string འདི་ནང་ལུ་ ཚིག་ཆ་མཉམ་ (བར་སྟོང་གིས་སོ་སོར་) ཨིན།\/\/\/ ལས་འགན་ཅིག་འབྲི་བ་ཅིན་ string དང་ ordered version འདི་ལོག་ཐོབ་འོང་།\/\/\/ >>> anti_shuffle(String::from(\"Hi\"))\n\/\/\/ String::from(\"Hi\")\n\/\/\/ >>> anti_shuffle(String::from(\"hello\"))\n\/\/\/ String::from(\"ehllo\")\n\/\/\/ >>> anti_shuffle(String::from(\"Hello World!!!\"))\n\/\/\/ String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n","canonical_solution":"fn anti_shuffle(s: String) -> String {\n    let mut result = String::new();\n    let mut word = String::new();\n\n    for c in s.chars() {\n        if c.is_whitespace() {\n            if !word.is_empty() {\n                let mut chars: Vec<char> = word.chars().collect();\n                chars.sort_unstable();\n                result.push_str(&chars.into_iter().collect::<String>());\n                word.clear();\n            }\n            result.push(c);\n        } else {\n            word.push(c);\n        }\n    }\n\n    if !word.is_empty() {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort_unstable();\n        result.push_str(&chars.into_iter().collect::<String>());\n    }\n\n    result\n}\n\nfn main() {\n    \/\/ Example usages:\n    println!(\"{}\", anti_shuffle(String::from(\"Hi\")));              \/\/ \"Hi\"\n    println!(\"{}\", anti_shuffle(String::from(\"hello\")));           \/\/ \"ehllo\"\n    println!(\"{}\", anti_shuffle(String::from(\"Hello World!!!\")));  \/\/ \"Hello !!!Wdlor\"\n}","tests":"}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"},{"task_id":"HumanEval_87","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ འདི་བཟུམ་སྦེ་ གྲལ་ཐིག་གི་ས་སྒོ་ཚུ་ ཀེར་ཐིག་གི་ཐོག་ལས་ མར་འབབ་འགྱོ་མི་རིམ་པ་ལུ་དབྱེ་བ་ཕྱེ་དགོ།\/\/\/ འགོ་ཐོག་ལུ་ གྱལ་རིམ་ནང་ཐིག་ཁྲམ་ཚུ་རིམ་སྒྲིག་འབད།\/\/\/ ཐུབ་ཡིག་རེ་རེ་འདི་ ཕྲང་སྒྲིག་ - (གྲལ་ཐིག་དང་ཐིག་ཁྲམ་) ཚུ་ཨིནམ་དང་ འདི་ཚུ་ ༠ ལས་འགོ་བཙུགསཔ་ཨིན།\/\/ཌེ་བི་ཡཱན་འདི་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་དང་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་ ཌེ་བི་ཡཱན་གི་ཨང་གྲངས་ཚུ་\/\/སྐར་མ་ ༡ དང་ཧྲིལ་ཨང་ x ཚུ་བྱིན་ཏེ་ ཝི་ཅཊར་ནང་ལུ་ཧྲིལ་ཨང་ x འཚོལ་ཞིབ་འབད་ \/\/\/ ནང་ཐིག་རེ་རེའི་ནང་ ཀེར་ཐིག་གྱངས་ཁ་མ་འདྲཝ་ཅིག་ཡང་ འཐོབ་ཚུགས།\/\/ཇི་ཨེམ་ཊི་སི་དང་འདྲ་བ་ཨིན། མ་གཞི་ མ་ཊི་སི་དང་མ་འདྲ་བ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཌི་ཨེམ་སི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་ཌི་\/\/\/ >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n\/\/\/ vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(vec![], 1)\n\/\/\/ Vec::<(isize, isize)>::new()\n\/\/\/ >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n\/\/\/ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n","canonical_solution":"fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut result = Vec::new();\n\n    for (row_index, row) in lst.iter().enumerate() {\n        let mut found_indices: Vec<isize> = row.iter()\n            .enumerate()\n            .filter(|&(_, &value)| value == x)\n            .map(|(col_index, _)| col_index as isize)\n            .collect();\n\n        found_indices.sort_by(|a, b| b.cmp(a)); \/\/ Sort column indices in descending order\n\n        for col_index in found_indices {\n            result.push((row_index as isize, col_index));\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"},{"task_id":"HumanEval_88","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/* བྱིན་ཡོད་པའི་ ཝེ་ཊར་འདི་མ་སོར་དགོ།\/\/\/ དྲན་གསོ།: \/\/ཡང་ན་ ཨང་གྲངས་ཚུ་མར་འབབ་འགྱོ་མི་རིམ་པ་ལུ་དབྱེ་བ་ཕྱེ་བ་ཅིན་ (རྩིས་གཞི་དང་པའི་གནས་གོང་དང་ མཇུག་གི་གནས་གོང་) འདི་ཡང་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཝི་ཅཊ་འདི་ཡར་སེང་གི་རིམ་པ་ལུ་དབྱེ་བ་ཕྱེ་ནི་ཨིན་པ་ཅིན་ (འབྱུང་ཁུངས་དང་པའི་ཨེན་ཌིསི་གི་གནས་གོང་དང་ མཇུག་གི་ཨེན་ཌིསི་གི་གནས་གོང་) འདི་ཨེན་ཌིསི་མེན་པ་ཅིན་ \/\/\/ ནུས་མེད་ཨང་གྲངས་ཀྱི་ ཝི་ཅཊ་ཅིག་བྱིན་ཏེ་ཡོད་པ་ཅིན་ དབྱེ་བ་ཕྱེ་ཚར་བའི་ཤུལ་ལས་ ཝི་ཅཊ་དེ་གི་ ཀོར་སི་ཅིག་ལོག་གཏང་།\/\/\/ >>> sort_array(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> sort_array(vec![5])\n\/\/\/ vec![5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n\/\/\/ vec![0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n\/\/\/ vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::<isize>::new();\n    }\n\n    let first = array.first().unwrap_or(&0);\n    let last = array.last().unwrap_or(&0);\n    let sum = first + last;\n\n    let mut sorted_array = array.clone();\n    if sum % 2 == 0 {\n        sorted_array.sort_by(|a, b| b.cmp(a)); \/\/ Descending order\n    } else {\n        sorted_array.sort(); \/\/ Ascending order\n    }\n\n    sorted_array\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", sort_array(vec![])); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", sort_array(vec![5])); \/\/ vec![5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5])); \/\/ vec![0, 1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); \/\/ vec![6, 5, 4, 3, 2, 1, 0]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"},{"task_id":"HumanEval_89","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ ཌའི་ལོག་འདི་ གྱངས་ཁ་གཉིས་དང་ལྡནམ་སྦེ་ས་སྒོ་གཉིས་ལུ་སྤོ་བཤུད་འབདཝ་ཨིན།\/\/ཨེཕ་བི་འདི་ ཚིག་ཡིག་ཚུ་ ཡོད་པའི་ཐབས་ལམ་ཅིག་ནང་ བསྒྱུར་གཏང་དགོ།\/\/\/ གིས་ ཨེབ་གཏང་འབད་ཡོད་པའི་ཡིག་འབྲུ་ཅིག་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ ལས་འགན་ཨེན་ཀིརོཊི་ཅིག་བཟོཝ་ད་ ཨེ་རེ་དེ་ ཨེ་རེ་རྟགས་སྦེ་ལེན་ \/\/\/ >>> encrypt(String::from(\"hi\"))\n\/\/\/ String::from(\"lm\")\n\/\/\/ >>> encrypt(String::from(\"asdfghjkl\"))\n\/\/\/ String::from(\"ewhjklnop\")\n\/\/\/ >>> encrypt(String::from(\"gf\"))\n\/\/\/ String::from(\"kj\")\n\/\/\/ >>> encrypt(String::from(\"et\"))\n\/\/\/ String::from(\"ix\")\nfn encrypt(s: String) -> String {\n","canonical_solution":"fn encrypt(s: String) -> String {\n    s.chars()\n        .map(|c| {\n            if c.is_ascii_lowercase() {\n                let offset = (c as u8 - b'a' + 4) % 26;\n                (b'a' + offset) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"},{"task_id":"HumanEval_90","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དེ་བཟུམ་གྱི་ཆ་ཤས་མེད་པ་ཅིན་ སླར་ལོག་འབདཝ་ཨིན།\/\/\/ function next_smallest () འདི་ ཝི་ཅཊར་གྱི་ཆ་ཤས་ཆུང་ཤོས་གཉིས་པ་སླར་ལོག་འབདཝ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ ཝི་ཅཊར་ཐོབ་ཡོདཔ་ཨིན།\/\/\/ >>> next_smallest(vec![1, 2, 3, 4, 5])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![5, 1, 4, 3, 2])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![])\n\/\/\/ None\n\/\/\/ >>> next_smallest(vec![1, 1])\n\/\/\/ None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();\n    if unique_elements.len() < 2 {\n        return None;\n    }\n    unique_elements.sort();\n    Some(unique_elements[1])\n}\n\nfn main() {\n    println!(\"{:?}\", next_smallest(vec![1, 2, 3, 4, 5])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![5, 1, 4, 3, 2])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![])); \/\/ None\n    println!(\"{:?}\", next_smallest(vec![1, 1])); \/\/ None\n}","tests":"}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"},{"task_id":"HumanEval_91","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ ཚིག་ཡིག་ཚུ་ '.', '?' ཡང་ན་ '!' ཚུ་གིས་ ཚད་འཛིན་འབདཝ་ཨིན།\/\/རྒྱུད་བསྐུལ་འདི་ \"ང་\" ཟེར་ཚིག་འདི་ལས་ འགོ་བཙུགས་མི་ཚིག་ཅིག་ཨིན།\/\/ཁྱོད་ཀྱིས་ཚིག་ཡིག་གི་ཐིག་ཁྲམ་ཅིག་ཐོབ་སྟེ་ ཁྱོད་ཀྱི་ལཱ་འདི་ ཨང་གྲངས་རྩིས་ནི་ཨིན།\/\/\/ >>> is_bored(String::from(\"Hello world\"))\n\/\/\/ 0\n\/\/\/ >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n\/\/\/ 1\nfn is_bored(S: String) -> isize {\n","canonical_solution":"fn is_bored(S: String) -> isize {\n    S.split(|c| c == '.' || c == '?' || c == '!')\n        .filter(|sentence| sentence.trim_start().starts_with(\"I\"))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n"},{"task_id":"HumanEval_92","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་ \/\/\/ གཞན་དོན་ཚན་ཚུ་ནང་ false སླར་ལོག་འབདཝ་ཨིན།\/\/ཨང་གྲངས་གཅིག་འདི་ གཞན་གཉིས་བསྡོམས་དང་ ཨང་གྲངས་ཆ་མཉམ་འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།\/\/ཨང་གྲངས་༣ འབད་མི་ལས་འགན་ཅིག་བཟོ།\/\/\/ >>> any_int(5, 2, 7)\n\/\/\/ true\n\/\/\/ >>> any_int(3, 2, 2)\n\/\/\/ false\n\/\/\/ >>> any_int(3, -2, 1)\n\/\/\/ true\n\/\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/\/ false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n","canonical_solution":"fn any_int(x: f64, y: f64, z: f64) -> bool {\n    \/\/ Check if all the numbers are integers\n    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {\n        \/\/ Convert f64 to i64 because they are integers\n        let xi = x as i64;\n        let yi = y as i64;\n        let zi = z as i64;\n\n        \/\/ Check if any one of the numbers is equal to the sum of the other two\n        xi == yi + zi || yi == xi + zi || zi == xi + yi\n    } else {\n        false\n    }\n}\n\nfn main() {\n    \/\/ Examples\n    println!(\"{}\", any_int(5.0, 2.0, 7.0)); \/\/ true\n    println!(\"{}\", any_int(3.0, 2.0, 2.0)); \/\/ false\n    println!(\"{}\", any_int(3.0, -2.0, 1.0)); \/\/ true\n    println!(\"{}\", any_int(3.6, -2.2, 2.0)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"},{"task_id":"HumanEval_93","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ ཡིག་འབྲུ་ཚུ་རྐྱངམ་ཅིག་ ཆ་བཞག་དགོ།\/\/ཨིང་ལིཤ་གི་ཡིག་གཟུགས་ནང་ ཚིག་ཡིག་འདི་ ཝོ་ཀེལ་ཨིན།\/\/\/ འདི་ལས་ ཤོག་ལེབ་གཉིས་ཧེ་མ་ཡོད་མི་ཡིག་འབྲུ་འདི་ \/\/\/ འདི་ནང་ཡིག་འབྲུ་ཆ་མཉམ་ལུ་ ཀྱི་ཚབ་ལུ་ ནང་ལུ་ ཚིག་ཡིག་ཆ་མཉམ་ལུ་ ཀྱི་ཚབ་ལུ་ ཟེར་བཀོད་དེ་ཡོདཔ་ཨིན།\/\/བརྡ་འཕྲིན་ཅིག་ལེན་ཏེ་ འདི་བཟུམ་ཅིག་སྦེ་ ཨང་བཏགས་མི་ལས་འགན་ཅིག་འབྲི་དགོ།\/\/\/ >>> encode(String::from(\"test\"))\n\/\/\/ String::from(\"TGST\")\n\/\/\/ >>> encode(String::from(\"This is a message\"))\n\/\/\/ String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n","canonical_solution":"fn encode(message: String) -> String {\n    message.chars().map(|c| {\n        match c {\n            'a' => 'C',\n            'e' => 'G',\n            'i' => 'K',\n            'o' => 'Q',\n            'u' => 'W',\n            'A' => 'c',\n            'E' => 'g',\n            'I' => 'k',\n            'O' => 'q',\n            'U' => 'w',\n            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"},{"task_id":"HumanEval_94","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/ཁྱོད་ཀྱིས་ སྦོམ་ཤོས་ཨང་གྲངས་ཨང་གྲངས་དང་བསྟུན་པའི་ གནས་གོང་འདི་འཚོལ་དགོཔ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ ཝི་ཅཊར་ཐོབ་ཡོདཔ་ཨིན།\/\/\/ >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn digit_sum(n: isize) -> isize {\n    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()\n}\n\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    match lst.into_iter().filter(is_prime).max() {\n        Some(max_prime) => digit_sum(max_prime),\n        None => 0,\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n"},{"task_id":"HumanEval_95","nl":"dzo_Tibt","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ དཔེ་སྟོན་: \/\/\/ ལས་འགན་འདི་གིས་ false སླར་ལོག་འབད་དགོཔ་ཨིན། འདི་ཡང་ HashMap འདི་སྟོངམ་ཨིན།\/\/\/ case ཡང་ན་ ཀི་བཱའིན་ཚུ་ཆ་མཉམ་རང་ uppercase ལུ་ཐིག་ཁྲམ་ཨིནམ་དང་ གཞན་འབད་བ་ཅིན་ false སླར་ལོག་འབདཝ་ཨིན།\/\/\/ HashMap ཅིག་བྱིན་པ་ཅིན་ ཨེབ་རྟ་ཆ་མཉམ་རང་ འོག་ལུ་ཡོད་པའི་ string ཚུ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n\/\/\/ true\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n\/\/\/ true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n","canonical_solution":"use std::collections::HashMap;\n\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return false;\n    }\n\n    let mut lowercase = true;\n    let mut uppercase = true;\n\n    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_lowercase()) {\n            lowercase = false;\n        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            uppercase = false;\n        }\n    }\n\n    lowercase || uppercase\n}\n\nfn main() {\n    let dict1 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict1), true);\n\n    let dict2 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict2), false);\n\n    let dict3 = HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]);\n    assert_eq!(check_dict_case(dict3), true);\n\n    let dict4 = HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]);\n    assert_eq!(check_dict_case(dict4), false);\n}","tests":"}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"},{"task_id":"HumanEval_96","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་: \/\/\/ ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་དང་ n ལས་ཆུང་བ་ཨིན།\/\/\/ ལས་འགན་ཅིག་ལག་ལེན་འཐབ་ད་ ནུས་མེད་ཨང་གྲངས་ཆ་མཉམ་ལེན་ཏེ་ དང་པ་ n གི་བེ་ཊར་ཅིག་ལོག་བྱིན་འོང་།\/\/\/ >>> count_up_to(5)\n\/\/\/ vec![2, 3]\n\/\/\/ >>> count_up_to(11)\n\/\/\/ vec![2, 3, 5, 7]\n\/\/\/ >>> count_up_to(0)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(20)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(1)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(18)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n","canonical_solution":"fn count_up_to(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\n    for num in 2..n {\n        let mut is_prime = true;\n\n        for divisor in 2..=((num as f64).sqrt() as isize) {\n            if num % divisor == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n\n        if is_prime {\n            primes.push(num);\n        }\n    }\n\n    primes\n}\n\nfn main() {\n    println!(\"{:?}\", count_up_to(5)); \/\/ vec![2, 3]\n    println!(\"{:?}\", count_up_to(11)); \/\/ vec![2, 3, 5, 7]\n    println!(\"{:?}\", count_up_to(0)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(20)); \/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n    println!(\"{:?}\", count_up_to(1)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(18)); \/\/ vec![2, 3, 5, 7, 11, 13, 17]\n}","tests":"}\n\nfn main() {\n    let candidate = count_up_to;\n    assert_eq!(candidate(5), vec![2, 3]);\n    assert_eq!(candidate(6), vec![2, 3, 5]);\n    assert_eq!(candidate(7), vec![2, 3, 5]);\n    assert_eq!(candidate(10), vec![2, 3, 5, 7]);\n    assert_eq!(candidate(0), Vec::<isize>::new());\n    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    assert_eq!(candidate(1), Vec::<isize>::new());\n    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n"},{"task_id":"HumanEval_97","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ ནང་བསྐྱོད་དེ་ དུས་རྒྱུན་དུ་ ཆ་གནས་ཅན་སྦེ་ར་སྡོད་འོང་ཟེར་ཆ་བཞགཔ་ཨིན།\/\/\/ འདི་ཚུ་ཨང་གྲངས་ཀྱི་ ཨང་གྲངས་ཚུ་དང་བསྡོམས་ཨིན།\/\/\/ ལས་འགན་འདི་ཆ་མཉམ་གཉིས་ལེན་ཏེ་ལོག་གཏང་འོང་།\/\/\/ >>> multiply(148, 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(19, 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(2020, 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(14, -15)\n\/\/\/ 20\nfn multiply(a: isize, b: isize) -> isize {\n","canonical_solution":"fn multiply(a: isize, b: isize) -> isize {\n    let unit_digit_a = (a % 10).abs();\n    let unit_digit_b = (b % 10).abs();\n    unit_digit_a * unit_digit_b\n}","tests":"}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"},{"task_id":"HumanEval_98","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ string s ཅིག་བྱིན་པ་ཅིན་ སྦོམ་ཡིག་གི་སྐད་ཡིག་ཚུ་རྩིས་སྟོནམ་ཨིན།\/\/\/ >>> count_upper(String::from(\"aBCdEf\"))\n\/\/\/ 1\n\/\/\/ >>> count_upper(String::from(\"abcdefg\"))\n\/\/\/ 0\n\/\/\/ >>> count_upper(String::from(\"dBBE\"))\n\/\/\/ 0\nfn count_upper(s: String) -> isize {\n","canonical_solution":"fn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(i, c)| {\n        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')\n    }).count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"},{"task_id":"HumanEval_99","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་ \/\/ཨང་གྲངས་ཆ་མཉམ་གཉིས་ལས་ བསྐོར་རྒྱབ་འབད་ཞིནམ་ལས་ ༠ ལས་ཁ་འབྱལ་གཏང་།\/\/ཨང་གྲངས་འདི་ རྒྱང་ཚད་འདྲ་མཉམ་ཡོད་པ་ཅིན་\/\/\/ ཨང་གྲངས་ངོ་ཚབ་འབད་ཡོད་པའི་ གནས་གོང་ (ཐིག་ཡིག་) ཅིག་ལེན་མི་ལས་འགན་ཅིག་བཟོ།\/\/\/ >>> closest_integer(String::from(\"10\"))\n\/\/\/ 10\n\/\/\/ >>> closest_integer(String::from(\"15.3\"))\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n","canonical_solution":"fn closest_integer(value: String) -> isize {\n    let num: f64 = value.parse().expect(\"Invalid number format\");\n    if num.fract().abs() == 0.5 {\n        if num.is_sign_positive() {\n            num.ceil() as isize\n        } else {\n            num.floor() as isize\n        }\n    } else {\n        num.round() as isize\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", closest_integer(String::from(\"10\")));   \/\/ Output: 10\n    println!(\"{}\", closest_integer(String::from(\"15.3\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"14.5\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"-14.5\"))); \/\/ Output: -15\n}","tests":"}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"},{"task_id":"HumanEval_100","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/i འདི་ ཚད་ (i+1) ནང་ རྡོ་གི་གྱངས་ཁ་འདི་ཨིན།\/\/\/ ཝི་ཅཊ་ནང་ལུ་ ཚད་རེ་རེ་ནང་ རྡོ་གི་གྱངས་ཁ་སླར་ལོག་འབདཝ་ཨིན།\/\/ཤུལ་མའི་ཨང་གྲངས་ཆ་མཉམ་འདི་ n འདི་ཆ་མཉམ་ཨིན་པ་ཅིན་ཨིན།\/\/nའདི་ གྱངས་ཁ་མ་ཚངམ་ཨིན་པ་ཅིན་ ཤུལ་མའི་གྱངས་ཁ་འདི་ གྱངས་ཁ་མ་ཚངམ་ཨིན།\/\/\/ ཤུལ་མའི་གནས་ཚད་ནང་ལུ་ རྡོ་གི་གྱངས་ཁ་འདི་: ཨིན།\/\/\/ ཐོག་ཚད་དང་པའི་ནང་ རྡོ་ n ཡོདཔ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ནུས་ལྡན་ཨང་གྲངས་ n བྱིན་པ་ཅིན་ ཁྱོད་ཀྱིས་ རྡོ་གི་ཚད་ n འབད་མི་རྡོ་བསྡམ་དགོཔ་ཨིན།\/\/\/ >>> make_a_pile(3)\n\/\/\/ vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n","canonical_solution":"fn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n    let mut current = n;\n    \n    for _ in 0..n {\n        pile.push(current);\n        current = if n % 2 == 1 {\n            current + 2\n        } else {\n            current + 2\n        };\n    }\n    \n    pile\n}\n\nfn main() {\n    let level = make_a_pile(3);\n    println!(\"{:?}\", level);\n}","tests":"}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"},{"task_id":"HumanEval_101","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ ཚིག་ཡིག་ཚུ་ནང་ཐིག་ཡིག་འདི་ཆ་དབྱེ་ཞིནམ་ལས་ ཚིག་ཡིག་གི་ ཝི་ཅཊར་ཅིག་ལོག་གཏང་འོང་།\/\/ཁྱོད་ཀྱིས་ཚིག་ཡིག་གི་ཐིག་ཁྲམ་ཅིག་བྱིན་ནི་ཨིན་ འདི་ནང་ ཀམ་ཡང་ན་ བར་སྟོང་བཙུགས་ཏེ་ དབྱེ་བ་ཕྱེ་འོང་། ཁྱོད་ཀྱི་ལཱ་འདི་ ཨིན།\/\/\/ >>> words_string(String::from(\"Hi, my name is John\"))\n\/\/\/ vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n\/\/\/ >>> words_string(String::from(\"One, two, three, four, five, six\"))\n\/\/\/ vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n","canonical_solution":"fn words_string(s: String) -> Vec<String> {\n    s.split(|c: char| c.is_whitespace() || c == ',')\n        .filter(|word| !word.is_empty())\n        .map(String::from)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = words_string;\n    assert_eq!(candidate(String::from(\"Hi, my name is John\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]);\n    assert_eq!(candidate(String::from(\"One, two, three, four, five, six\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"Hi, my name\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\")]);\n    assert_eq!(candidate(String::from(\"One,, two, three, four, five, six,\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"ahmed     , gamal\")), vec![String::from(\"ahmed\"), String::from(\"gamal\")]);\n}\n"},{"task_id":"HumanEval_102","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/ཇི་ཨེམ་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ཨེན་ ཨེབ།\/\/སྦོམ་ཤོས་འདི་ [x, y] ནང་ཚུད་ཡོད་པའི་ཨང་གྲངས་ཧྲིལ་བུམ་ཆ་མཉམ་ཨིན།\/\/\/ འ་ནི་ལས་འགན་འདི་གིས་ ནུས་ལྡན་ཨང་གྲངས་ x དང་ y གཉིས་ལེན་ཏེ་ སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> choose_num(12, 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(13, 12)\n\/\/\/ -1\nfn choose_num(x: isize, y: isize) -> isize {\n","canonical_solution":"fn choose_num(x: isize, y: isize) -> isize {\n    let (start, end) = if x < y { (x, y) } else { (y, x) };\n    for n in (start..=end).rev() {\n        if n % 2 == 0 {\n            return n;\n        }\n    }\n    -1\n}\n\nfn main() {\n    println!(\"{}\", choose_num(12, 15)); \/\/ 14\n    println!(\"{}\", choose_num(13, 12)); \/\/ -1\n}","tests":"}\n\nfn main() {\n    let candidate = choose_num;\n    assert_eq!(candidate(12, 15), 14);\n    assert_eq!(candidate(13, 12), -1);\n    assert_eq!(candidate(33, 12354), 12354);\n    assert_eq!(candidate(5234, 5233), -1);\n    assert_eq!(candidate(6, 29), 28);\n    assert_eq!(candidate(27, 10), -1);\n    assert_eq!(candidate(7, 7), -1);\n    assert_eq!(candidate(546, 546), 546);\n}\n"},{"task_id":"HumanEval_104","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ དྲན་གསོ། ཕྱིར་ལོག་འབད་མི་ ཝི་ཀཊར་ཚུ་ ཡར་སེང་རིམ་སྒྲིག་ནང་དབྱེ་བ་ཕྱེ་དགོ།\/\/\/ ཆ་ཤས་ཚུ་ནང་ ཨང་གྲངས་ཆ་མཉམ་མེདཔ་ཨིན།\/\/\/ ནུས་པ་ཅན་གྱི་ཧྲིལ་གྲངས་ x གི་བེ་ཊར་ཅིག་བྱིན་ཏེ་ ཚང་མའི་རིམ་སྒྲིག་འབད་མི་བེ་ཊར་ཅིག་ལོག་གཏང་།\/\/\/ >>> unique_digits(vec![15, 33, 1422, 1])\n\/\/\/ vec![1, 15, 33]\n\/\/\/ >>> unique_digits(vec![152, 323, 1422, 10])\n\/\/\/ Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = x.into_iter()\n        .filter(|&num| {\n            num.to_string().chars().all(|c| {\n                match c {\n                    '0' | '2' | '4' | '6' | '8' => false,\n                    _ => true,\n                }\n            })\n        })\n        .collect();\n    result.sort();\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = unique_digits;\n    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);\n    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());\n    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);\n    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);\n}\n"},{"task_id":"HumanEval_105","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/གཅིག་ གཉིས་ གསུམ་ བཞི་ ལྔ་ དྲུག་ བདུན་ བརྒྱད་ དགུ་\/\/\/ གིས་ འཐོན་སྐྱེད་འབད་ཡོད་པའི་ ཝི་ཅཊར་འདི་ ཕྱོགས་བསྒྱུར་འབད་ཞིནམ་ལས་ ཨང་གྲངས་རེ་རེ་ལུ་ ནང་ལས་ མིང་ཚིག་འདི་དང་བསྟུན་ཏེ་ཚབ་བཙུགས་འོང་།\/\/\/ ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊར་ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཧྲིལ་བུའི་དབྱེ་བ་འདི་ ༡ དང་ ༩ འི་བར་ན་འབད་དགོཔ་ཨིན།\/\/\/ >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n\/\/\/ If the vector is empty, return an empty vector:\n\/\/\/ >>> by_length(vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ If the vector has any strange number ignore it:\n\/\/\/ >>> by_length(vec![1, -1, 55])\n\/\/\/ vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n","canonical_solution":"fn by_length(arr: Vec<isize>) -> Vec<String> {\n    let digit_names = [\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \n        \"Six\", \"Seven\", \"Eight\", \"Nine\",\n    ];\n\n    let mut filtered: Vec<isize> = arr.into_iter()\n        .filter(|&x| x >= 1 && x <= 9)\n        .collect();\n\n    filtered.sort();\n    filtered.reverse();\n\n    filtered.into_iter()\n        .map(|x| String::from(digit_names[(x - 1) as usize]))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"},{"task_id":"HumanEval_106","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/i གི་གནས་གོང་འདི་ 1 ལས་ i ཚུན་གྱི་ཨང་གྲངས་ཚུ་དང་འཕྱདཔ་ད་ (1 * 2 * ... * i) ཨིན།\/\/ཤོག་ལེབ་འདི་ ༡ ལས་འགོ་བཙུགསཔ་ཨིན།\/\/ཡང་ན་ ཨང་གྲངས་ ༡ ལས་ ༡ ཚུན་གྱི་བསྡོམས་ཚུ་ཨིན།\/\/དེ་ལས་ ཚད་ n གི་ ཝེ་ཊར་ཅིག་ལོག་བྱིན་ནི་ཨིན་པ་ཅིན་ ཨེཌིསི་ i གི་ནང་དོན་གྱི་གནས་གོང་འདི་ i གི་གནས་གོང་ཨིནམ་ད་ i འདི་ཡང་ ཨིན།\/\/\/ ལས་འགན་ f འདི་ n འདི་ཚད་འཛིན་སྦེ་ལེན་ཏེ་ལག་ལེན་འཐབ་ཨིན།\/\/\/ >>> f(5)\n\/\/\/ vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n","canonical_solution":"fn f(n: isize) -> Vec<isize> {\n    fn factorial(x: isize) -> isize {\n        (1..=x).product()\n    }\n\n    fn sum_up_to(x: isize) -> isize {\n        (1..=x).sum()\n    }\n\n    (1..=n)\n        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);\n    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);\n    assert_eq!(candidate(1), vec![1]);\n    assert_eq!(candidate(3), vec![1, 2, 6]);\n}\n"},{"task_id":"HumanEval_107","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ ༡:\/\/ནང་ལུ་ཡོད་པའི་ཨང་གྲངས་ཧྲིལ་བུམ་ཚུ་ཨིན།\/\/\/ ནུས་ལྡན་ཨང་གྲངས་ n ཅིག་བྱིན་པ་ཅིན་ ཕྲང་དང་གྱངས་ཁ་མེད་པའི་ ཌི་ཨེམ་པི་ཅིག་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> even_odd_palindrome(3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n","canonical_solution":"fn is_palindrome(x: isize) -> bool {\n    let s = x.to_string();\n    s == s.chars().rev().collect::<String>()\n}\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    \n    for i in 1..=n {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_palindrome;\n    assert_eq!(candidate(123), (8, 13));\n    assert_eq!(candidate(12), (4, 6));\n    assert_eq!(candidate(3), (1, 2));\n    assert_eq!(candidate(63), (6, 8));\n    assert_eq!(candidate(25), (5, 6));\n    assert_eq!(candidate(19), (4, 6));\n    assert_eq!(candidate(9), (4, 5));\n    assert_eq!(candidate(1), (0, 1));\n}\n"},{"task_id":"HumanEval_108","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེར་ན་ -123 གིས་ ཨང་གྲངས་ -1, 2 དང་ 3 ལུ་རྟགས་བཀོད་འབད་ཡོདཔ་ཨིན།\/\/\/ ག་དེམ་ཅིག་སྦེ་ ཨང་གྲངས་འདི་ ནུས་མེད་ཨིན་པ་ཅིན་ ཨང་གྲངས་དང་པ་གི་ཨང་རྟགས་འདི་ ནུས་མེད་ཨིན།: \/\/ཨང་གྲངས་ཚུ་བསྡོམས་ཏེ་ཡོད་མི་འདི་ ༠ ལས་ལྷག་སྟེ་ཡོད་མི་འདི་ ཨང་གྲངས་ཀྱི་གྱངས་ཁ་ཨིན།\/\/\/ ལས་འགན་ count_nums དེ་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་ ཝི་ཅཊར་ཅིག་ལེན་ཏེ་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> count_nums(vec![])\n\/\/\/ 0\n\/\/\/ >>> count_nums(vec![-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(vec![1, 1, 2])\n\/\/\/ 3\nfn count_nums(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn count_nums(arr: Vec<isize>) -> isize {\n    arr.into_iter()\n        .filter(|&num| {\n            let mut n = num;\n            let mut sum = 0;\n            let mut is_first_digit = true;\n\n            while n != 0 {\n                let digit = if is_first_digit {\n                    is_first_digit = false;\n                    n % 10\n                } else {\n                    (n % 10).abs()\n                };\n                sum += digit;\n                n \/= 10;\n            }\n            sum > 0\n        })\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n"},{"task_id":"HumanEval_109","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་: \/\/\/ དྲན་གསོ། བྱིན་ཡོད་པའི་བེ་ཊར་ནང་ལུ་ རང་བཞིན་གྱི་ཡན་ལག་ཚུ་ཡོད་མི་འདི་ ངེས་གཏན་ཨིན།\/\/\/ གལ་སྲིད་ ཝི་ཅཊ་འདི་ སྟོངམ་ཨིན་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།\/\/དེ་ལས་བདེན་པ་ལོག་གཏང་ ཡང་ན་རྫུས་མ་ལོག་གཏང་།\/\/\/ གོང་གི་ལཱ་འདི་འབད་ཐོག་ལས་ དབྱེ་བ་ཕྱེ་མི་ ཝི་ཅཊར་ཐོབ་ཚུགསཔ་ཨིན་པ་ཅིན་ \/\/ཝེ་ཀཊར་ནང་ འགོ་ཐོག་གི་ས་སྒོ་དེ་ ཨིནཌེཀསི་ ༠ པ་ཨིན།\/\/ནང་ལུ་ ཕྱོགས་བཞིར་གནས་སོར་འབདཝ་ཨིན། ཝི་ཅཊར་གྱི་མཐའ་མཇུག་གི་ཆ་ཤས་འདི་ ནང་ལུ་སྤོ་འོང་།\/\/\/ གཡས་ཕྱོགས་ལུ་སོར་གཏང་ནིའི་ལཱ་འདི་ ཝེ་ཊར་གྱི་ཆ་ཤས་ཆ་མཉམ་ལུ་ གཅིག་གིས་སོར་གཏང་ནི་ཨིན་མས།\/\/ཁྱོད་ཀྱིས་ ཕྲང་ལམ་འདི་ ཚར་ལེ་ཤ་ཅིག་ར་ བསྒྱུར་བཅོས་འབད་ཚུགས།\/\/\/ འདི་ནང་ལུ་ ཝི་ཅཊར་འདི་ནང་ལུ་ ལས་རིམ་འདི་འབད་དགོཔ་ཨིན།\/\/ནང་ལུ་འབད་ཞིནམ་ལས་ ཝི་ཅཊར་ཚུ་ མར་འབབ་འགྱོ་མི་རིམ་པ་ནང་རིམ་སྒྲིག་འབད་ཚུགས།\/\/ཁྱོད་ཀྱིས་ ཝེ་ཀཊར་ནང་ལུ་ ཨང་གྲངས་ཚུ་ སྟབས་བདེ་ཏོག་ཏོ་སྦེ་ བཙུགས་འོང་། ཁྱོད་ཀྱི་ལཱ་འདི་ ཝེ་ཀཊར་འདི་ ཌའི་ལོག་ནང་ཡོད་མེད་བརྟག་དཔྱད་འབད་ནི་ཨིན།\/\/ང་བཅས་ནང་ལུ་ ཝི་ཅཊ་ 'arr' ཡོད་པའི་ནང་ ཨང་གྲངས་ཧྲིལ་པོ་ N ཡོད་པའི་ནང་ arr[1], arr[2], ..., arr[N] ཟེར་ཡོདཔ་ཨིན།\/\/\/ >>> move_one_ball(vec![3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given vector.\n\/\/\/ >>> move_one_ball(vec![3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n","canonical_solution":"fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.is_empty() {\n        return true; \/\/ An empty array is already considered sorted.\n    }\n    \n    let mut break_point = 0;\n    let mut break_found = false;\n    let len = arr.len();\n\n    for i in 0..len {\n        if arr[i] > arr[(i + 1) % len] {\n            if break_found {\n                return false;  \/\/ Found more than one break point, not possible.\n            }\n            break_point = i + 1;\n            break_found = true;\n        }\n    }\n    \n    \/\/ After finding a single break point, simulate the right shift by 'break_point'\n    for i in 0..len {\n        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {\n            return false; \/\/ Not sorted in non-decreasing order with this shift.\n        }\n    }\n    \n    true\n}\n\n\/\/ Example usages:\n\n\/\/ This will return true, as we can shift twice to sort it.\nassert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);\n\n\/\/ This will return false, as we can't sort this by any number of shifts.\nassert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","tests":"}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"},{"task_id":"HumanEval_110","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/དེ་མེན་པ་ཅིན་ \"མེན་\" ཟེར་ལོག་གཏང་།\/\/lst1 གི་ཆ་ཤས་ཚུ་ཆ་མཉམ་རང་ཡོད་པ་ཅིན་ \"YES\" སླར་ལོག་འབདཝ་ཨིན།\/\/ཇི་ཨེས་ཊི་༡ དང་ཇི་ཨེས་ཊི་༢ ཀྱི་བར་ན་ དབྱེ་བ་ཕྱེ་ནིའི་དོན་ལས་ ཇི་ཨེས་ཊི་༡ དང་ཇི་ཨེས་ཊི་༢ ཀྱི་བར་ན་ དབྱེ་བ་ཕྱེ་ནི་དེ་ འབད་ཚུགས་པ་ཅིན་\/\/lst1 དང་ lst2 ཀྱི་བར་ན་ བརྗེ་སོར་འབད་མི་ཆ་ཤས་ཚུ་གི་གྱངས་ཁ་ལུ་ཚད་གཞི་མེདཔ་ཨིན།\/\/ཇི་ཨེམ་ཨེས་1 འདི་ ཨེཆ་ཨེམ་ཨེས་1 འབད་མི་ ཨང་གྲངས་རྐྱང་པའི་ ཝི་ཅཊར་ཅིག་བཟོ་ནིའི་དོན་ལུ་ ཇི་ཨེམ་ཨེས་1 འདི་ ཨེཆ་ཨེམ་ཨེས་1 འབད་མི་ ཨང་གྲངས་རྐྱང་པའི་ ཝི་ཅཊར་ཅིག་བཟོ་དགོ།\/\/\/ དང་ཆ་ཤས་ཚུ་བརྗེ་སོར་འབད་ཚུགསཔ་ཨིན་ན་ ངེས་གཏན་བཟོ་འོང་།\/\/འ་ནི་དཀའ་ངལ་འདི་ནང་ལུ་ ཁྱོད་ཀྱིས་གྲངས་ཀྱི་ ཝི་ཅཊར་གཉིས་ལེན་མི་ལས་འགན་ཅིག་ལག་ལེན་འཐབ་འོང་།\/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n\/\/\/ String::from(\"YES\")\n\/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n\/\/\/ String::from(\"NO\")\n\/\/\/ It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n","canonical_solution":"fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut even_in_lst2 = false;\n    for &num in &lst2 {\n        if num % 2 == 0 {\n            even_in_lst2 = true;\n            break;\n        }\n    }\n\n    if even_in_lst2 {\n        for &num in &lst1 {\n            if num % 2 != 0 {\n                return String::from(\"YES\");\n            }\n        }\n        return String::from(\"YES\");\n    }\n\n    String::from(\"NO\")\n}\n\nfn main() {\n    \/\/ Example cases\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); \/\/ \"YES\"\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); \/\/ \"NO\"\n}","tests":"}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(\"YES\"));\n}\n"},{"task_id":"HumanEval_111","nl":"dzo_Tibt","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/ཡི་གུ་ལེ་ཤ་ཅིག་རང་ འབྱུང་ཁུངས་གཅིག་ཡོད་པ་ཅིན་ དེ་ཚུ་ག་ར་ལོག་གཏང་།\/\/\/ ཚར་གཅིག་ལོག་རྐྱབ་པའི་ཡིག་འབྲུ་དང་ འདི་དང་བསྟུན་པའི་ཨང་གྲངས་ཚུ་ \/\/\/ ནང་ཐིག་ནང་ལུ་ བར་སྟོང་བཞག་ཡོད་པའི་ཡིག་འབྲུ་ཆུང་བ་ཚུ་ཡོད་པའི་ string ཅིག་བྱིན་པ་ཅིན་ HashMap ཅིག་ལོག་གཏང་།\/\/\/ >>> histogram(String::from(\"a b c\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\/\/\/ >>> histogram(String::from(\"a b b a\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"a b c a b\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"b b b b a\"))\n\/\/\/ HashMap::from([(String::from(\"b\"), 4)])\n\/\/\/ >>> histogram(String::from(\"\"))\n\/\/\/ HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut counts: HashMap<String, isize> = HashMap::new();\n    let mut max_count = 0;\n\n    for letter in test.split_whitespace() {\n        let count = counts.entry(letter.to_string()).or_insert(0);\n        *count += 1;\n        if *count > max_count {\n            max_count = *count;\n        }\n    }\n\n    counts.retain(|_, &mut val| val == max_count);\n    counts\n}\n\nfn main() {\n    let result = histogram(String::from(\"a b c\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\n    let result = histogram(String::from(\"a b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"a b c a b\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"b b b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"b\"), 4)])\n\n    let result = histogram(String::from(\"\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([])\n}","tests":"}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")), HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"a\"), 1)]));\n}\n"},{"task_id":"HumanEval_112","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ \/\/ཁྱོད་ཀྱིས་ གྲུབ་འབྲས་ཐིག་ཡིག་དང་ བདེན་\/རྫུན་མ་ཡོད་པའི་ ཌའི་ལོག་ལོག་ཅིག་སླར་ལོག་འབད་དགོ།\/\/\/ string འདི་རྒྱབ་དང་མདུན་ལུ་འདྲ་མཉམ་སྦེ་ཡོད་པ་ཅིན་ palindrome ཟེར་སླབ་ཨིན།\/\/\/ དེ་ལས་ གྲུབ་འབྲས་ཐིག་ཁྲམ་འདི་ པཱ་ལིན་ཌོརམསི་ཨིནམ་སྦེ་བརྟག་དཔྱད་འབད།\/\/ང་བཅས་ལུ་ string s དང་ c གཉིས་བྱིན་ཡོདཔ་ད་ ཁྱོད་ཀྱིས་ s ནང་གི་ཡིག་འབྲུ་ཚུ་ ཆ་མཉམ་སྦེ་ c ནང་གི་ཡིག་འབྲུ་ཚུ་ ཕྱིར་བཏོན་འབད་དགོཔ་ཨིན།\/\/ལཱ་འགན་ \/\/\/ >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n\/\/\/ (String::from(\"bcd\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n\/\/\/ (String::from(\"acdef\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n\/\/\/ (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n","canonical_solution":"fn reverse_delete(s: String, c: String) -> (String, bool) {\n    \/\/ Create a set of characters to delete for quick lookup\n    let delete_chars: std::collections::HashSet<char> = c.chars().collect();\n    \n    \/\/ Filter the string, keeping only characters not in the delete set\n    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();\n    \n    \/\/ Check if the filtered string is a palindrome\n    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();\n    \n    \/\/ Return the filtered string and whether it's a palindrome\n    (filtered, is_palindrome)\n}","tests":"}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"},{"task_id":"HumanEval_113","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཨང་གྲངས་ཆ་མེད་ཀྱི་ཨང་གྲངས་ཚུ་ ཨང་གྲངས་ནང་ཐིག་ i'th ནང་བཙུགས་ནུག\/\/ནང་བསྐྱོད་ཀྱི་ string i. \" འདི་ནང་ལུ་ i ཚུ་ཆ་མཉམ་ཨང་གྲངས་ཀྱི་ཚབ་བཙུགས་དགོ།\/\/\/ ཐོན་རིམ་ནང་གི་ཆ་ཤས་རེ་རེ་ i འདི་ ནང་ལུ་ གྱངས་ཁ་མེད་པའི་ཆ་ཤས་ཚུ་ ཨིནམ་སྦེ་ངེས་འཛིན་འབད་དགོཔ་ཨིན།\/\/\/ string གི་བེ་ཊར་ཅིག་བྱིན་ཏེ་ འདི་ནང་ལུ་ string རེ་རེ་ནང་ ཨང་གྲངས་རྐྱངམ་ཅིག་ཡོདཔ་ལས་ བེ་ཊར་ཅིག་ལོག་གཏང་།\/\/\/ >>> odd_count(vec![String::from(\"1234567\")])\n\/\/\/ vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n\/\/\/ >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n\/\/\/ vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn odd_count(lst: Vec<String>) -> Vec<String> {\n    lst.iter()\n        .map(|s| {\n            let odd_count = s.chars().filter(|&c| {\n                match c {\n                    '1' | '3' | '5' | '7' | '9' => true,\n                    _ => false,\n                }\n            }).count();\n            format!(\"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\", odd_count)\n        })\n        .collect()\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = odd_count(vec![String::from(\"1234567\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ \n\/\/     let result = odd_count(vec![String::from(\"3\"), String::from(\"11111111\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = odd_count;\n    assert_eq!(candidate(vec![String::from(\"1234567\")]), vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"3\"), String::from(\"11111111\")]), vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"271\"), String::from(\"137\"), String::from(\"314\")]), vec![String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\"), String::from(\"the number of odd elements 3n the str3ng 3 of the 3nput.\"), String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\")]);\n}\n"},{"task_id":"HumanEval_114","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ \/\/\/ ཨང་གྲངས་ཚུ་ཨིན།\/\/\/ ཨང་གྲངས་ཧྲིལ་ཨང་ n གི་བེ་ཊར་ཅིག་བྱིན་པ་ཅིན་ སྟོངམ་མེན་པའི་བེ་ཊར་ཆུང་ཤོས་ཀྱི་བསྡོམས་འཚོལ་དགོ།\/\/\/ >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(vec![-1, -2, -3])\n\/\/\/ -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut min_sum = nums[0];\n    let mut current_sum = nums[0];\n\n    for &num in nums.iter().skip(1) {\n        current_sum = current_sum.min(current_sum + num);\n        min_sum = min_sum.min(current_sum);\n    }\n\n    min_sum\n}","tests":"}\n\nfn main() {\n    let candidate = minSubArraySum;\n    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);\n    assert_eq!(candidate(vec![-1, -2, -3]), -6);\n    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);\n    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);\n    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);\n    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);\n    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);\n    assert_eq!(candidate(vec![-10]), -10);\n    assert_eq!(candidate(vec![7]), 7);\n    assert_eq!(candidate(vec![1, -1]), -1);\n}\n"},{"task_id":"HumanEval_115","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ ༡:\/\/ཁྱོད་ཀྱིས་བེག་ཚུ་མར་ཕབ་འབད་དགོ་པའི་ ཚར་གྲངས་དེ་ཨེབ་གཏང་འབད།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ ཆུ་དོང་འདི་ལངམ་སྦེ་འབད་ནིའི་དོན་ལུ་ ཆུ་རྫམ་འདི་ལག་ལེན་འཐབ་དགོ།\/\/\/དང་ འ་ནི་བེག་ག་ར་ནང་ ཚད་གཞི་གཅིག་རང་ཡོདཔ་ཨིན།\/\/ཆུ་རྐ་རེ་ནང་ ཆུ་བཏོན་ནིའི་དོན་ལུ་ ཆུ་རྫིང་རེ་ཡོདཔ་ད་ ཆུ་དེ་ནང་ལས་ ཆུ་བཏོན་ནིའི་དོན་ལུ་ ཆུ་རྫིང་རེ་ནང་ ཆུ་བླུག་སྟེ་ ཆུ་བླུགས་ཏེ་ ཆུ་བཏོན་བཏངམ་ཨིན།\/\/\/ དང་གྲལ་རིམ་ནང་ལུ་ ༡ གིས་ཆུ་གི་ཆ་ཕྲན་གཅིག་འདི་ངོ་ཚབ་འབདཝ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཟུར་ལམ་གྲུ་བཞི་འབད་མི་ ཟུར་ལམ་རེ་ཐོབ་ཨིན། ཟུར་ལམ་རེ་རེ་གིས་ ཟུར་ལམ་གཅིག་འདི་ངོ་ཚབ་འབདཝ་ཨིན།\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n","canonical_solution":"fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total_water_units = 0;\n\n    for row in grid.iter() {\n        for &unit in row.iter() {\n            total_water_units += unit;\n        }\n    }\n\n    \/\/ Calculate how many times we need to lower the bucket to extract all water units\n    (total_water_units + capacity - 1) \/ capacity\n}\n\nfn main() {\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); \/\/ 6\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); \/\/ 5\n    println!(\"{}\", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"},{"task_id":"HumanEval_116","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ འདི་ཚུ་ འ་ནི་བཟུམ་སྦེ་ལག་ལེན་འཐབ་དགོཔ་ཨིན།: \/\/\/ འདྲ་མཉམ་ཨང་གྲངས་ ༡ གི་དོན་ལུ་ ཨང་གྲངས་བཅུ་ཐམ་གི་གནས་གོང་ལུ་གཞི་བཞག་སྟེ་ དབྱེ་བ་ཕྱེ་དགོ།\/\/\/ གཅིག་གཉིས་སྦེ་བཙུགསཔ་ད་ ཨང་གྲངས་ཚུ་ཡར་འཕར་འགྱོ་ནིའི་རིམ་པ་ལུ་བཙུགསཔ་ཨིན།\/\/འ་ནི་ཀཱད་ལུ་ ཁྱོད་ཀྱིས་ ནུས་མེད་ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊ་འདི་ ཇི་ཇི་ཨའི་ལུ་གཞི་བཞག་སྟེ་ དབྱེ་བ་ཕྱེ་དགོ།\/\/\/ >>> sort_array(vec![1, 5, 2, 3, 4])\n\/\/\/ vec![1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![-2, -3, -4, -5, -6])\n\/\/\/ vec![-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(vec![1, 0, 2, 3, 4])\n\/\/\/ vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_by(|&a, &b| {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n        if ones_a == ones_b {\n            a.cmp(&b)\n        } else {\n            ones_a.cmp(&ones_b)\n        }\n    });\n    arr\n}\n\nfn main() {\n    println!(\"{:?}\", sort_array(vec![1, 5, 2, 3, 4])); \/\/ Output: [1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![-2, -3, -4, -5, -6])); \/\/ Output: [-6, -5, -4, -3, -2]\n    println!(\"{:?}\", sort_array(vec![1, 0, 2, 3, 4])); \/\/ Output: [0, 1, 2, 3, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"},{"task_id":"HumanEval_117","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ དྲན་གསོ། ཁྱོད་ཀྱིས་ཨེབ་གཏང་ཐིག་ནང་ ཡིག་འབྲུ་དང་བར་སྟོང་ཚུ་རྐྱངམ་ཅིག་ཡོད་ཟེར་ཆ་བཞག་བཏུབ།\/\/\/ string s འདི་སྟོངམ་ཨིན་པ་ཅིན་ ལས་འགན་འདི་གིས་ སྟོངམ་གི་བེ་ཊར་ཅིག་ལོག་བྱིན་འོང་།\/\/\/n ཕྲ་རིང་ཚུ་ཡོདཔ་དང་ འདི་ཚུ་ ཚིག་ཡིག་གི་ཐིག་ཁྲམ་ནང་འོང་ནི་ཨིནམ་སྦེ་བཀོད་དེ་ཡོདཔ་ཨིན།\/\/\/ འདི་ལས་ string s ནང་ལུ་ ཕྲ་རིང་ཅིག་རང་ཡོད་མི་འདི་ལས་ ཚིག་ཡིག་ག་ར་སླར་ལོག་འབདཝ་ཨིན།\/\/ཁྱོད་ཀྱིས་ string s དང་ natural number n ཚུ་བྱིན་པ་ཅིན་ ཁྱོད་ཀྱིས་ ཚུ་ལག་ལེན་འཐབ་ནིའི་ལཱ་ཐོབ་འོང་།\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\/\/\/ vec![String::from(\"little\")]\n\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n\/\/\/ vec![String::from(\"Mary\"), String::from(\"lamb\")]\n\/\/\/ >>> select_words(String::from(\"simple white space\"), 2)\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> select_words(String::from(\"Hello world\"), 4)\n\/\/\/ vec![String::from(\"world\")]\n\/\/\/ >>> select_words(String::from(\"Uncle sam\"), 3)\n\/\/\/ vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n","canonical_solution":"fn select_words(s: String, n: isize) -> Vec<String> {\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let mut result = Vec::new();\n\n    for word in s.split_whitespace() {\n        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();\n        if consonant_count == n as usize {\n            result.push(word.to_string());\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"},{"task_id":"HumanEval_118","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/ཁྱོད་ཀྱིས་བྱིན་ཡོད་པའི་ string འདི་ནང་ལུ་ ཨིང་སྐད་ཡིག་འབྲུ་རྐྱངམ་གཅིག་ཡོད་ཟེར་ཆ་བཞག་བཏུབ།\/\/\/ གོང་གི་གནས་སྟངས་འདི་ནང་ ཚིག་ཡིག་ཚུ་ཐོབ་ཡོདཔ་ཨིན།\/\/འགོ་བཙུགས་དང་མཇུག་གི་སྐད་ཡིག་ཚུ་རྩིས་མི་བཏུབ། གལ་སྲིད་ ཁྱོད་ཀྱིས་ ཕྱིར་བསྐྱོད་འབད་མ་བཏུབ།\/\/\/ ཚིག་གི་གཡས་ཁ་ཐུག་ལས་ ཟུར་སྒྲོམ་གཉིས་ (ཡིག་འབྲུ་ཆུང་ཆུང་ལུ་དྭངས་གསལ་སྦེ་) ཨིན།\/\/ཁྱོད་ཀྱིས་ཚིག་གཅིག་ཐོབ་ད་ འདི་གི་བར་ན་ལུ་ཡོད་མི་ སྒྲ་དབྱངས་ཀྱི་ ཕྲ་རིང་འདི་འཚོལ་དགོ།\/\/\/ >>> get_closest_vowel(String::from(\"yogurt\"))\n\/\/\/ String::from(\"u\")\n\/\/\/ >>> get_closest_vowel(String::from(\"FULL\"))\n\/\/\/ String::from(\"U\")\n\/\/\/ >>> get_closest_vowel(String::from(\"quick\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> get_closest_vowel(String::from(\"ab\"))\n\/\/\/ String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n","canonical_solution":"fn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let chars: Vec<char> = word.chars().collect();\n    if chars.len() < 3 {\n        return String::from(\"\");\n    }\n\n    for i in (1..chars.len() - 1).rev() {\n        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {\n            return chars[i].to_string();\n        }\n    }\n    String::from(\"\")\n}","tests":"}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"},{"task_id":"HumanEval_119","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ འདི་ལུ་ཐིག་ཁྲམ་ལེགས་ཤོམ་བཟོ་ནིའི་ལམ་ཡོད་པ་ཅིན་ 'Yes' སླར་ལོག་འབད་ དེ་ལས་མེན་པ་ཅིན་ 'No' སླར་ལོག་འབད་འོང་།\/\/\/ \"())\"འདི་མེན།\/\/དཔེར་ན་ string '(())))) འདི་ལེགས་ཤོམ་ཨིན་ དེ་ལས་ string  འདི་ལེགས་ཤོམ་ཨིན་\/\/\/ string S འདི་ ལེགས་ལྡན་ཅིག་སྦེ་བརྩི་ནི་ཨིན་པ་ཅིན་ S ནང་ལུ་ ནང་ཐིག་ག་ར་ ལེགས་ལྡན་ཅིག་སྦེ་བརྩི་ནི་ཨིན་པ་ཅིན་རྐྱངམ་གཅིག་ཨིན།\/\/\/ གོ་རིམ་ཅིག་ལུ་བརྟེན་ ཀེར་ཐིག་འདི་ལེགས་ཤོམ་འོང་ནི་ཨིན་མས།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ string གཉིས་བསྡོམས་འབད་ཚུགས་ག་ བལྟ་ནི་ཨིན།\/\/\/ ནང་ཐིག་ནང་ \"(\" ཡང་ན་ ནང་ཐིག་གི་མཐའ་མ་ནང་ \") \"རྐྱངམ་ཅིག་བཙུགས་དགོ།\/\/ཁྱོད་ཀྱིས་ string གཉིས་ལས་ ཝེ་ཀཊར་ཐོབ་ཡོདཔ་ད་ ཝེ་ཀཊར་གཉིས་ཆ་ར་ལུ་ open ཟེར་ཡོདཔ་ཨིན།\/\/\/ >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n\/\/\/ String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n","canonical_solution":"fn match_parens(lst: Vec<String>) -> String {\n    fn is_balanced(s: &str) -> bool {\n        let mut balance = 0;\n        for ch in s.chars() {\n            if ch == '(' {\n                balance += 1;\n            } else {\n                balance -= 1;\n            }\n            if balance < 0 {\n                return false;\n            }\n        }\n        balance == 0\n    }\n\n    if lst.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let s1 = &lst[0];\n    let s2 = &lst[1];\n\n    let combined1 = format!(\"{}{}\", s1, s2);\n    let combined2 = format!(\"{}{}\", s2, s1);\n\n    if is_balanced(&combined1) || is_balanced(&combined2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"},{"task_id":"HumanEval_120","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ ༡:\/\/\/ ཡུན་རིང་ k དང་ མཐོ་ཤོས་ k ཨང་གྲངས་ཚུ་ arr ནང་ལུ་ཡོད།\/\/\/ ཨང་གྲངས་ཧྲིལ་བུའི་བེ་ཊར་ arr དང་ ནུས་པའི་ཨང་གྲངས་ཧྲིལ་བུམ་ k ཅིག་བྱིན་པ་ཅིན་ དབྱེ་བ་ཕྱེ་མི་བེ་ཊར་ཅིག་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> maximum(vec![-3, -4, 5], 3)\n\/\/\/ vec![-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(vec![4, -4, 4], 2)\n\/\/\/ vec![4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/\/ vec![2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the vector will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the vector will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_unstable_by(|a, b| b.cmp(a));\n    let k = k as usize;\n    let mut result: Vec<isize> = arr.into_iter().take(k).collect();\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n}","tests":"}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_121","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་ \/\/\/ ཨང་གྲངས་ཧྲིལ་བུམ་མེད་པའི་ ཝི་ཅཊ་ཅིག་བྱིན་པ་ཅིན་ གནས་རིམ་ཆ་མཉམ་ནང་ཡོད་པའི་ ཨང་གྲངས་ཧྲིལ་བུམ་གྱི་བསྡོམས་ལོག་གཏང་།\/\/\/ >>> solution(vec![5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(vec![3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(vec![30, 13, 24, 321])\n\/\/\/ 0\nfn solution(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn solution(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)\n        .map(|(_, &x)| x)\n        .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = solution;\n    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);\n    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);\n    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);\n    assert_eq!(candidate(vec![5, 9]), 5);\n    assert_eq!(candidate(vec![2, 4, 8]), 0);\n    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);\n    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);\n}\n"},{"task_id":"HumanEval_122","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/ཨེ་རེ་འདི་ ཨེ་རེ་འདི་གི་ དང་པ་གི་ཨེ་རེ་ཚུ་ནང་ལས་ ཨང་གྲངས་གཉིས་ལས་ལྷག་སྟེ་མེད་རུང་ ཨེ་རེ་འདི་བསྡོམས་ཨིན།\/\/\/ ཨང་གྲངས་ཧྲིལ་བུམ་ arr དང་ ཨང་གྲངས་ཧྲིལ་བུམ་ k གི་ སྟོངམ་མེན་པའི་ ཝི་ཅཊ་ཅིག་བྱིན་པ་ཅིན་ སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n","canonical_solution":"fn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    arr.iter()\n        .take(k as usize)\n        .filter(|&&x| x > -100 && x < 100)\n        .sum()\n}\n\nfn main() {\n    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);\n    println!(\"{}\", result);  \/\/ Output: 24\n}","tests":"}\n\nfn main() {\n    let candidate = add_elements;\n    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);\n    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n    assert_eq!(candidate(vec![1], 1), 1);\n}\n"},{"task_id":"HumanEval_123","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ get_odd_collatz(5) གིས་ [1, 5] སླར་ལོག་འབདཝ་ཨིན། # ཀོ་ལ་ཊ་ཛརིམ་པ་ 5 གི་དོན་ལུ་ [5, 16, 8, 4, 2, 1]ཨིནམ་ལས་ ཨང་གྲངས་ཆ་མེད་ཚུ་ ༡ དང་ ༥ རྐྱངམ་གཅིག་ཨིན།\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ ༢། སླར་ལོག་འབད་མི་ ཝི་ཅཊ་ཚུ་ ཡར་སེང་རིམ་སྒྲིག་ནང་དབྱེ་བ་ཕྱེ་ཡོདཔ་ཨིན།\/\/ཤོག་ཁྲམ་འདི་ [1] ཨིན།\/\/\/ དྲན་གསོ།: \/\/\/term+1 འདི་ཡང་ n གི་གནས་གོང་ག་བཟུམ་ཅིག་ཨིན་རུང་ གྲུབ་འབྲས་རིམ་པ་འདི་ ཨ་རྟག་ར་ 1 ལུ་ལྷོད་འོང་།\/\/\/ སྔོན་མའི་གནས་རིམ་འདི་ཨིན། སྔོན་མའི་གནས་རིམ་འདི་ གྱངས་ཁ་མ་ཚངམ་ཅིག་ཨིན་པ་ཅིན་ ཤུལ་མའི་གནས་རིམ་འདི་ སྔོན་མའི་གནས་རིམ་ལས་ ༣ ལུ་གྱངས་ཁ་རྐྱབ་ཨིན།\/\/\/ སྔོན་མའི་གནས་རིམ་འདི་ འདྲན་འདྲ་ཨིན་པ་ཅིན་ ཤུལ་མའི་གནས་རིམ་འདི་ གི་ཕྱེད་ཀ་ཨིན།\/\/\/ འདི་བཟུམ་འབད་: ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ n ལས་འགོ་བཙུགས་ ཤུལ་མམ་གྱི་དོན་ཚན་རེ་རེ་ ནང་ལས་ཐོབ་ཨིན།\/\/ཀོ་ལ་ཊ་གི་བསམ་འཆར་འདི་ རྩིས་རིག་ནང་ལུ་ གྲུབ་རྟགས་ཅིག་ཨིནམ་དང་ འདི་ཡང་ དབྱེ་ཞིབ་འབད་ཡོད་པའི་རིམ་པ་ཅིག་ལུ་ འབྲེལ་གཏུགས་འབདཝ་ཨིན།\/\/\/ ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ n ཅིག་བྱིན་པ་ཅིན་ ཀོ་ལ་ཊི་གི་རིམ་པ་ནང་ལུ་ ཨང་གྲངས་རྣམ་རྟོག་ཚུ་ཡོད་པའི་ དབྱེ་བ་ཕྱེ་མི་ ཝི་ཅཊར་ཅིག་ལོག་གཏང་།\/\/\/ >>> get_odd_collatz(5)\n\/\/\/ vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n","canonical_solution":"fn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut sequence = Vec::new();\n    let mut current = n;\n\n    while current != 1 {\n        if current % 2 != 0 {\n            sequence.push(current);\n        }\n\n        if current % 2 == 0 {\n            current \/= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    \n    \/\/ Add the final odd number 1 if n is 1\n    sequence.push(1);\n\n    sequence.sort();\n    sequence\n}\n\nfn main() {\n    let result = get_odd_collatz(5);\n    println!(\"{:?}\", result); \/\/ Outputs: [1, 5]\n}","tests":"}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"},{"task_id":"HumanEval_124","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཚེས་གྲངས་འདི་ ཨེཆ་ཨེམ་-དི་-ཨའི་ཨའི་གི་རྣམ་པ་ནང་ལུ་དགོཔ་ཨིན།\/\/ཟླཝ་འདི་ ༡ ལས་ཉུང་ ཡང་ན་ ༡༢ ལས་ལྷག་སྟེ་མི་འོང་།\/\/ཟླཝ་ ༡,༣,༥,༧,༨,༡༠,༡༢ ཀྱི་དོན་ལུ་ ཉིན་གྲངས་ ༡ ལས་ཉུང་ ཡང་ན་ ༣༡ ལས་ལྷག་སྟེ་མེདཔ་ད་ ཟླཝ་ ༤,༦,༩,༡༡ གྱི་དོན་ལུ་ ཉིན་གྲངས་ ༡ ལས་ཉུང་ ཡང་ན་ ༣༠ ལས་ལྷག་སྟེ་མེདཔ་དང་ ཟླཝ་ ༢ ཀྱི་དོན་ལུ་ ཉིན་གྲངས་ ༡ ལས་ཉུང་ ཡང་ན་ ༢༩ ལས་ལྷག་སྟེ་མེདཔ་ཨིན།\/\/\/ ༡། ཚེས་གྲངས་ཐིག་ཁྲམ་འདི་ སྟོངམ་མེན།\/\/\/ འོག་གི་བཀོད་རྒྱ་ཚུ་ཆ་མཉམ་ར་ཆ་མཉམ་ར་ཆ་བཞག་པ་ཅིན་ ཚེས་གྲངས་འདི་ ཆ་གནས་ཨིན།\/\/\/ གིས་ ཚེས་གྲངས་འདི་ ཆ་གནས་ཡོད་པ་ཅིན་བདེན་པ་ སླར་ལོག་འབདཝ་ཨིན། དེ་མེན་པ་ཅིན་རྫུས་མ་ཨིན།\/\/\/ ཁྱོད་ཀྱིས་ ཚེས་གྲངས་ཐིག་ཡིག་ཅིག་ལུ་ ཆ་གནས་འབད་ནིའི་དོན་ལས་ ལས་འགན་ཅིག་འབྲི་དགོཔ་ཨིན།\/\/\/ >>> valid_date(String::from(\"03-11-2000\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"15-01-2012\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"04-0-2040\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"06-04-2020\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"06\/04\/2020\"))\n\/\/\/ false\nfn valid_date(date: String) -> bool {\n","canonical_solution":"fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return false;\n    }\n\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n\n    let maybe_month = parts[0].parse::<u32>();\n    let maybe_day = parts[1].parse::<u32>();\n    let maybe_year = parts[2].parse::<u32>();\n\n    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {\n        return false;\n    }\n\n    let month = maybe_month.unwrap();\n    let day = maybe_day.unwrap();\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return false;\n            }\n        }\n        2 => {\n            if day < 1 || day > 29 {\n                return false;\n            }\n        }\n        _ => return false, \/\/ This case should never be reached\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"},{"task_id":"HumanEval_126","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་ \/\/\/ number, return false དེ་ ནུས་མེད་ཨང་གྲངས་དང་ཧྲིལ་ཨང་རྐྱངམ་ཅིག་ཨིནམ་སྦེ་ཆ་བཞགཔ་ཨིན།\/\/ཝེ་ཀཊར་འདི་ འདྲ་བཤུས་ ༡ ལས་ལྷག་སྟེ་ཡོད་པ་ཅིན་ \/\/ཨང་གྲངས་ཀྱི་ ཝི་ཅཊར་ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཚུ་རིམ་སྒྲིག་འབད་རུང་ ཡང་ན་མེན་རུང་ ལོག་བྱིན་འོང་།\/\/\/ >>> is_sorted(vec![5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfn is_sorted(lst: Vec<isize>) -> bool {\n","canonical_solution":"fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.is_empty() || lst.len() == 1 {\n        return true;\n    }\n    \n    let mut previous = lst[0];\n    let mut repeat_count = 0;\n\n    for &current in &lst[1..] {\n        if current < previous {\n            return false;\n        }\n        if current == previous {\n            repeat_count += 1;\n            if repeat_count >= 2 {\n                return false;\n            }\n        } else {\n            repeat_count = 0;\n        }\n        previous = current;\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n}\n"},{"task_id":"HumanEval_127","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ [འཛུལ་སྒོ་\/ཐོན་ཁུངས་] དཔེ་ཚད་ཚུ་: \/\/\/ ག་དེམ་ཅིག་སྦེ་ བར་མཚམས་གཉིས་ཆ་ར་ ཕྲལ་མ་ཐལཝ་ཨིན་པ་ཅིན་ \"NO\" སླར་ལོག་འབདཝ་ཨིན།\/\/དེ་མེན་པ་ཅིན་ \"NO\" སླར་ལོག་འབདཝ་ཨིན།\/\/\/ ག་དེམ་ཅིག་སྦེ་ ཟུར་གྱི་རིང་ཚད་དེ་ ཨང་གྲངས་ངོ་མ་ཅིག་ཨིན་པ་ཅིན་ \"YES\" སླར་ལོག་འབདཝ་ཨིན།\/\/\/ འདི་ལུ་རིང་ཚད་ ༡ ཨིནམ་དང་ དེ་ཨང་གྲངས་ངོ་མ་མེན་པས།\/\/དཔེ་འབད་བ་ཅིན་ བར་མཚམས་ (1,3) དང་ (2,4) གི་བར་མཚམས་འདི་ (2,3) ཨིན།\/\/\/ བར་མཚམས་འདི་ཨང་གྲངས་ངོ་མ་ཨིན།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ འ་ནི་གཉིས་ཆ་རའི་ ཕྲང་ལམ་འདི་ ཚད་ཅིག་ཨིན་ན་མེན་ན་འཚོལ་ནི་ཨིན།\/\/\/ ཇི་ཇི་བར་ལཱསི་རེ་ལུ་ འགོ་བཙུགས་དེ་ མཐའ་མཇུག་དང་ ཆུང་བ་ ཡང་ན་ འདྲན་འདྲ་སྦེ་ར་ཆ་བཞག་ཡོདཔ་ཨིན།\/\/\/ འདི་ནང་ འགོ་བཙུགས་དང་མཇུག་གཉིས་ཆ་ར་ཚུད་དེ་ཡོད།\/\/\/ བྱིན་ཡོད་པའི་བར་སྟོང་འདི་བསྡམས་ཡོདཔ་ལས་ བར་སྟོང་འདི་ (འགོ་བཙུགས་,མཇུག་) ཨིན།\/\/\/ འདི་ནང་ལུ་ བར་མཚམས་རེ་རེ་ནི་ ཨང་གྲངས་ཆ་མཉམ་ཅིག་ཨིན། དཔེར་ན་ བར་མཚམས་ = (འགོ་ཐོག་,མཇུག་) = (1, 2) ཨིན།\/\/\/ ཁྱོད་ལུ་དུས་ཡུན་གཉིས་གནང་ཡོདཔ་ཨིན།\/\/\/ >>> intersection((1, 2), (2, 3))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-1, 1), (0, 4))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-3, -1), (-5, 5))\n\/\/\/ String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start_intersection = std::cmp::max(start1, start2);\n    let end_intersection = std::cmp::min(end1, end2);\n\n    if start_intersection <= end_intersection {\n        let length = (end_intersection - start_intersection + 1) as usize;\n        if is_prime(length) {\n            return String::from(\"YES\");\n        }\n    }\n    String::from(\"NO\")\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", intersection((1, 2), (2, 3))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-1, 1), (0, 4))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-3, -1), (-5, 5))); \/\/ \"YES\"\n}","tests":"}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"},{"task_id":"HumanEval_128","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/\/ དྲན་གསོ།: སྟོངམ་ཡོད་པའི་ཨར་ཚུ་གི་དོན་ལུ་སླར་ལོག་འབདཝ་ཨིན།\/\/ཝེ་ཀཊར་ནང་ལུ་ ཨང་གྲངས་རེ་རེ་ལུ་ ༡ དང་ ༡ དང་ ༠ སྦེ་ངོ་ཚབ་འབདཝ་ཨིན།\/\/ཨང་གྲངས་ཧྲིལ་བུའི་ཆེ་ཆུང་ཚུ་བསྡོམས་ཏེ་ རྟགས་མཚན་ཆ་མཉམ་གྱི་ཐོན་རིམ་གྱིས་ ཕབ་ལེན་འབདཝ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཝི་ཅཊ་ཨར་ཨར་ ཨང་གྲངས་ཧྲིལ་བུམ་ཐོབ་ཡོདཔ་ལས་ ཁྱོད་ཀྱིས་ལོག་གཏང་དགོཔ་ཨིན།\/\/\/ >>> prod_signs(vec![1, 2, 2, -4])\n\/\/\/ Some(9)\n\/\/\/ >>> prod_signs(vec![0, 1])\n\/\/\/ Some(0)\n\/\/\/ >>> prod_signs(vec![])\n\/\/\/ None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut sum_of_magnitudes = 0;\n    let mut product_of_signs = 1;\n\n    for &num in &arr {\n        sum_of_magnitudes += num.abs();\n        if num == 0 {\n            product_of_signs = 0;\n            break;\n        } else if num > 0 {\n            product_of_signs *= 1;\n        } else {\n            product_of_signs *= -1;\n        }\n    }\n\n    Some(sum_of_magnitudes * product_of_signs)\n}","tests":"}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n}\n"},{"task_id":"HumanEval_129","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ ཉུང་མཐའི་ལམ་འདི་འགྱོ་མི་ ཁམས་ཕྲན་ཚུ་ནང་ གནས་གོང་ཚུ་རིམ་སྒྲིག་འབད་མི་ ཝི་ཅཊར་ཅིག་ལོག་གཏང་།\/\/འདི་ལུ་ལན་འདི་ འདྲ་མིན་ཅིག་སྦེ་རང་ ངེས་བརྟན་སྦེ་རང་ བྱིན་ཚུགསཔ་ཨིན།\/\/\/ lst_A[j] = lst_B[j] ཨིན།\/\/\/ འདི་བཟུམ་འབད་ lst_A[i] < lst_B[i] དང་ j (1 <= j < i) གི་དོན་ལུ་ ང་བཅས་ལུ་ ཡོད་\/\/\/ལས་ lst_B འདི་ཡང་ ཚིག་གཞན་ཅིག་ནང་འབད་བ་ཅིན་ ཨང་གྲངས་ཧྲིལ་ཨང་གཞི་གྲངས་i (1 <= i <= k) ཅིག་ཡོདཔ་ཨིན།\/\/རྒྱུད་རིམ་འདི་ (འདི་ཚུ་ལུ་ lst_A དང་ lst_B ཟེར་སླབ་གེ་) རྒྱུད་རིམ་འདི་ཚིག་མཛོད་རིག་པ་ནང་ལུ་ཉུང་སུ་ཅིག་ཨིན།\/\/A དང་ B འདི་ཚུ་ནང་ཡོད་པའི་གནས་གོང་ཚུ་ ཝི་ཅཊར་རིམ་སྒྲིག་འབད་ཞིནམ་ལས་ \/\/\/ ལམ་ A (རིང་ཚད་ k) འདི་ ལམ་ B (རིང་ཚད་ k) ལས་ཆུང་བ་སྦེ་བརྩི་པ་ཅིན་ \/\/ཁྱོད་ཀྱིས་ ཇི་རིཊི་ནང་ལས་འཐོན་འགྱོ་མི་ཚུགས།\/\/\/ ངེས་པར་དུ་ཁྱད་པར་ཅན་ཨིན།)\/\/\/ འདི་ལུ་དྲན་གསོ་འབད་དགོ ཕྲང་ལམ་ k འདི་ ཀེལ་སི་ k སྦེ་བལྟ་ནི་ཨིནམ་ (འདི་མེན་ \/\/\/ ཁང་མིག་འདི་ཨིན། \/\/འདི་ཡང་ ཁྱོད་ཀྱིས་ ཕྲང་ལམ་གྱི་ཟུར་ཁ་ལུ་ཡོད་པའི་ ཀེལ་སི་ཚུ་ནང་འགྱོ་ཚུགས།\/\/ཇི་ཨའི་ཨའི་ཨའི་ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་ ཨའི་ཨའི་ཨའི་\/\/ཁྱོད་ཀྱིས་ ཀ་རིང་ཚད་ཀྱི་ཕྲང་ལམ་ཉུང་ཤོས་ཅིག་འཚོལ་དགོཔ་ཨིན། ཁྱོད་ཀྱིས་འགོ་བཙུགས་ཚུགས།\/\/\/ inclusive འདི་ གེཌི་གི་སྒོ་སྒྲིག་ནང་ལུ་ ཚར་གཅིག་རང་འཐོན་འོང་།\/\/\/ གིཌི་གི་སྒོ་སྒྲིག་རེ་རེའི་ནང་ གནས་གོང་ཅིག་ཡོདཔ་ཨིན། [༡, ནི * ནི] གི་ནང་དོན་ནང་གི་ཨང་གྲངས་ཆ་མཉམ་ཨིན།\/\/\/ གྲལ་ཐིག་ N དང་ ཀེར་ཐིག་ N (N >=2) དང་ ནུས་པའི་ཨང་གྲངས་ k ཡོད་མི་ལུ་བརྟེན་།\/\/\/ >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n\/\/\/ vec![1, 2, 1]\n\/\/\/ >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n\/\/\/ vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let n = grid.len();\n    let mut best_path = vec![];\n    let mut best_values = vec![isize::MAX; k as usize];\n    \n    fn dfs(\n        grid: &Vec<Vec<isize>>, \n        row: usize, \n        col: usize, \n        path: &mut Vec<(usize, usize)>, \n        values: &mut Vec<isize>, \n        k: isize, \n        best_values: &mut Vec<isize>\n    ) {\n        if path.len() == k as usize {\n            if values < best_values {\n                best_values.clone_from(values);\n            }\n            return;\n        }\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n        for &(dr, dc) in directions.iter() {\n            let new_row = row as isize + dr;\n            let new_col = col as isize + dc;\n            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {\n                path.push((new_row as usize, new_col as usize));\n                values.push(grid[new_row as usize][new_col as usize]);\n                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);\n                values.pop();\n                path.pop();\n            }\n        }\n    }\n\n    for r in 0..n {\n        for c in 0..n {\n            let mut path = vec![(r, c)];\n            let mut values = vec![grid[r][c]];\n            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);\n        }\n    }\n\n    best_values\n}","tests":"}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n"},{"task_id":"HumanEval_130","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ དང་པ་ n+1 གི་ Tribonacci གི་རིམ་པ་ཚུ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ནུས་མེད་ཨང་གྲངས་ཧྲིལ་བུམ་ n ཅིག་ཐོབ་པ་ཅིན་ ཁྱོད་ཀྱིས་ གི་ ཝི་ཅཊ་ཨེན་སླར་ལོག་འབད་དགོཔ་ཨིན།\/\/\/ = ༢་༣་༣་ = ༨་\/\/\/ tri(3) = tri(2) + tri(1) + tri(4) ཨིན།\/\/\/tri(4) =༣ ཨིན་པུཊི་\/\/\/ tri(2) = ༡ + ༢ \/ ༢ = ༢ ཨིན།\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/tri(n) =tri(n - 1) +tri(n - 2) +tri(n + 1) འདི་ nའདི་ གྱངས་ཁ་མ་རྐྱང་པ་ཨིན་པ་ཅིན་ཨིན།\/\/\/tri(n) = 1 + n \/ 2 འདི་ n འདི་ཆ་མཉམ་ཡོད་པ་ཅིན་ཨིན།\/\/\/ tri(1) = ༣་\/\/\/ Tribonacci sequence འདི་ཡང་བསྐྱར་དུ་འབྱུང་མི་གིས་གསལ་སྟོན་འབདཝ་ཨིན།\/\/ཨིན་རུང་ མི་སེར་ཚུ་གིས་ མ་ཤེས་མི་དེ་ ཏིརི་བཱོན་ཅིཤི་གི་རིམ་པ་ཨིན།\/\/མི་ག་ར་གིས་ ཕི་བེ་ནའ་ཀི་གི་རིམ་པ་ཤེས་དོ་ འདི་ལུ་ ཚོད་རྩིས་མཁས་མཆོག་ཚུ་གིས་ ཚོད་རྩིས་ཀྱི་ནང་འཁོད་ལུ་ ཞིབ་འཇུག་འབད་དེ་ཡོདཔ་ཨིན།\/\/\/ >>> tri(3)\n\/\/\/ vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n","canonical_solution":"fn tri(n: isize) -> Vec<isize> {\n    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {\n        if n < memo.len() as isize {\n            return memo[n as usize];\n        }\n\n        let result = if n == 1 {\n            3\n        } else if n % 2 == 0 {\n            1 + n \/ 2\n        } else {\n            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)\n        };\n\n        if n as usize >= memo.len() {\n            memo.resize(n as usize + 1, 0);\n        }\n        memo[n as usize] = result;\n        result\n    }\n\n    let mut sequence = Vec::new();\n    let mut memo = Vec::new();\n\n    for i in 0..=n {\n        sequence.push(tribonacci(i, &mut memo));\n    }\n\n    sequence\n}","tests":"}\n\nfn main() {\n    let candidate = tri;\n    assert_eq!(candidate(3), vec![1, 3, 2, 8]);\n    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);\n    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);\n    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);\n    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);\n    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);\n    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n    assert_eq!(candidate(0), vec![1]);\n    assert_eq!(candidate(1), vec![1, 3]);\n}\n"},{"task_id":"HumanEval_131","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/ཨང་གྲངས་ཆ་མཉམ་རང་ཆ་མཉམ་ཨིན་པ་ཅིན་ ༠ སླར་ལོག་འབདཝ་ཨིན།\/\/\/ ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ཧྲིལ་བུམ་ n ཅིག་ཐོབ་པ་ཅིན་ ཨང་གྲངས་ཉོག་ཕྲ་འབད་མི་ཚུ་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> digits(1)\n\/\/\/ 1\n\/\/\/ >>> digits(4)\n\/\/\/ 0\n\/\/\/ >>> digits(235)\n\/\/\/ 15\nfn digits(n: isize) -> isize {\n","canonical_solution":"fn digits(n: isize) -> isize {\n    let mut product = 1;\n    let mut has_odd = false;\n    let mut num = n;\n\n    while num > 0 {\n        let digit = num % 10;\n        if digit % 2 != 0 {\n            product *= digit;\n            has_odd = true;\n        }\n        num \/= 10;\n    }\n\n    if has_odd {\n        product\n    } else {\n        0\n    }\n}\n\nfn main() {\n    println!(\"{}\", digits(1));  \/\/ 1\n    println!(\"{}\", digits(4));  \/\/ 0\n    println!(\"{}\", digits(235)); \/\/ 15\n}","tests":"}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5), 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n    assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n    assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n}\n"},{"task_id":"HumanEval_132","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ འདི་ནང་ལུ་ ཤུལ་མམ་གྱི་ནང་ཐིག་གཅིག་ཡང་ སྦྲེལ་མཐུད་འབད་ཡོདཔ་ཨིན།\/\/\/ ལས་འགན་འདི་བདེན་པའི་སླར་ལོག་འབད་དགོཔ་ཨིན། གལ་སྲིད་དང་རྐྱངམ་ཅིག་ ཆ་གནས་ཅན་གྱི་ སྦྲེལ་རྟགས་ཀྱི་རིམ་པ་ ཅིག་ཡོད་པ་ཅིན་ཨིན།\/\/\/ ཀྲོང་ཁའི་ལྡེ་མིག་རྐྱངམ་ཅིག་ཡོད་པའི་ ནང་ཐིག་ཅིག་སྦེ་ ལག་ལེན་འཐབ་མི་ལས་འགན་ཅིག་བཟོ།\/\/\/ >>> is_nested(String::from(\"[[]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[][]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[[][]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[[]][[\"))\n\/\/\/ true\nfn is_nested(string: String) -> bool {\n","canonical_solution":"fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let mut nested = false;\n\n    for bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n        } else if bracket == ']' {\n            if let Some(_) = stack.pop() {\n                if !stack.is_empty() {\n                    nested = true;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n\n    nested\n}\n\nfn main() {\n    println!(\"{}\", is_nested(String::from(\"[[]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[]]]]]]][[[[[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[][]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[[][]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[[]][[\"))); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"},{"task_id":"HumanEval_133","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ ཝེ་ཊར་ནང་ལུ་ ཨེགསི་ཆ་མཉམ་ལུ་ཡར་མཐོ་སའི་ int ((Ceiling) དང་པོ་ལུ་ སྐོར་རྐྱབས་འབད།\/\/ཁྱོད་ཀྱིས་ ཝི་ཅཊ་ནང་ཡོད་པའི་ཨང་གྲངས་ཀྱི་གྲུ་བཞི་གི་བསྡོམས་སླར་ལོག་འབད་དགོ་འོང་།\/\/ཁྱོད་ཀྱིས་ ཨང་གྲངས་ཀྱི་ ཝི་ཅཊར་ཐོབ་ཡོདཔ་ཨིན།\/\/\/ >>> lst(vec![1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> lst(vec![1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> lst(vec![1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> lst(vec![-2.4, 1.0, 1.0])\n\/\/\/ 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .map(|&x| x.ceil() as isize)  \/\/ Round each element to the nearest upper integer\n        .map(|x| x * x)               \/\/ Square each element\n        .sum()                        \/\/ Sum all the squared elements\n}\n\nfn main() {\n    println!(\"{}\", sum_squares(vec![1.0, 2.0, 3.0])); \/\/ 14\n    println!(\"{}\", sum_squares(vec![1.0, 4.0, 9.0])); \/\/ 98\n    println!(\"{}\", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); \/\/ 84\n    println!(\"{}\", sum_squares(vec![1.4, 4.2, 0.0])); \/\/ 29\n    println!(\"{}\", sum_squares(vec![-2.4, 1.0, 1.0])); \/\/ 6\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);\n    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);\n    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);\n    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);\n    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);\n    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);\n    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n    assert_eq!(candidate(vec![0.0]), 0);\n    assert_eq!(candidate(vec![-1.0]), 1);\n    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);\n}\n"},{"task_id":"HumanEval_134","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ དྲན་གསོ། \"ཚིག་\"འདི་ ཡིག་འབྲུ་ཚུ་ས་སྒོ་གིས་སོ་སོར་སྦེ་དབྱེ་བ་ཕྱེ་མི་ སྡེ་ཚན་ཨིན།\/\/\/ འདི་ཡང་ཚིག་གི་ཆ་ཤས་ཅིག་ཨིནམ་ལས་ དེ་མེན་ན་ རྫུན་མ་ཅིག་ཨིན།\/\/\/ འདི་ཡིག་འབྲུ་ཨང་གྲངས་ཀྱི་ཡིག་འབྲུ་ཅིག་ཨིནམ་དང་ འདི་མེན་པས།\/\/\/ མཐའན་མཇུག་གི་ཡིག་འབྲུ་འདི་ ཨིན་པ་ཅིན་ true སླར་ལོག་འབད་མི་ལས་འགན་ཅིག་བཟོ།\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"\"))\n\/\/\/ false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n","canonical_solution":"fn check_if_last_char_is_a_letter(txt: String) -> bool {\n    if let Some(c) = txt.trim().chars().rev().next() {\n        if c.is_alphabetic() {\n            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {\n                return !prev_char.is_alphabetic();\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pie\")));  \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e\"))); \/\/ true\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e \"))); \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"\")));           \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n"},{"task_id":"HumanEval_135","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ གནས་གོང་གཉིས་སྦེ་འཐོན་འོང་།\/\/\/ འདི་བཟུམ་གྱི་ཆ་ཤས་མེད་པ་ཅིན་ལོག་གཏང་ -1. བྱིན་ཡོད་པའི་བེ་ཊར་ནང་ལུ་ མི་འོང་།\/\/\/ འདི་ སྦོམ་ཤོས་དང་ ཡང་ན་ འདྲ་མཉམ་མིན་འདུག་ དེ་འཕྲོ་ལས་གོང་མའི་ཆ་ཤས་འདི་དང་འདྲན་འདྲ་ཨིན།\/\/\/ ལས་འགན་ཅིག་བཟོ། འདི་ལུ་ ཨེལ་མཱེན་གྱི་ཨང་གྲངས་སྦོམ་ཤོས་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> can_arrange(vec![1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(vec![1, 2, 3])\n\/\/\/ -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn can_arrange(arr: Vec<isize>) -> isize {\n    for i in (1..arr.len()).rev() {\n        if arr[i] < arr[i - 1] {\n            return i as isize;\n        }\n    }\n    -1\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 4, 3, 5])); \/\/ Outputs: 3\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 3])); \/\/ Outputs: -1\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"},{"task_id":"HumanEval_136","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ ནུས་མེད་ ཡང་ན་ གྲུབ་འབྲས་ཅན་ཨང་གྲངས་མེད་པ་ཅིན་ དེ་ཚུ་ Noneསྦེ་ལོག་གཏང་།\/\/ཝི་ཅཊར་ནང་ལུ་ ནུས་ཅན་ཨང་གྲངས་ཆ་མཉམ་ཚུ་ ཨིན།\/\/\/འདི་ ནུས་མེད་ཨང་གྲངས་ཚུ་གི་གྲས་ལས་སྦོམ་ཤོས་དང་ bའདི་ ཆུང་ཤོས་ཨིན།\/\/\/ ལས་འགན་ཅིག་བཟོཝ་ད་ འདི་ནང་ལུ་ 'a' འདི་ ཨིནམ་ལས་ (a, b) ཅིག་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\/\/\/ (None, Some(1))\n\/\/\/ >>> largest_smallest_integers(vec![])\n\/\/\/ (None, None)\n\/\/\/ >>> largest_smallest_integers(vec![0])\n\/\/\/ (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n","canonical_solution":"fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative: Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\n    for &num in &lst {\n        if num < 0 {\n            largest_negative = match largest_negative {\n                Some(largest) => Some(largest.max(num)),\n                None => Some(num),\n            };\n        } else if num > 0 {\n            smallest_positive = match smallest_positive {\n                Some(smallest) => Some(smallest.min(num)),\n                None => Some(num),\n            };\n        }\n    }\n\n    (largest_negative, smallest_positive)\n}\n\nfn main() {\n    println!(\"{:?}\", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); \/\/ (None, Some(1))\n    println!(\"{:?}\", largest_smallest_integers(vec![])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![0])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); \/\/ (Some(-1), Some(2))\n}","tests":"}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));\n}\n"},{"task_id":"HumanEval_138","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ \/\/བྱིན་ཡོད་པའི་ཨང་གྲངས་ n འདི་ཨང་གྲངས་ཆ་མཉམ་ 4 གི་རྩིས་གཞི་སྦེ་འབྲི་ཚུགས་ག་མེད་ བརྟག་དཔྱད་འབད།\/\/\/ >>> is_equal_to_sum_even(4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(8)\n\/\/\/ true\nfn is_equal_to_sum_even(n: isize) -> bool {\n","canonical_solution":"fn is_equal_to_sum_even(n: isize) -> bool {\n    \/\/ A number n can be expressed as the sum of 4 positive even numbers if and only if\n    \/\/ it is greater than or equal to 8 and even\n    n >= 8 && n % 2 == 0\n}\n\n\/\/ Test cases\nfn main() {\n    println!(\"{}\", is_equal_to_sum_even(4));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(6));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(8));  \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_equal_to_sum_even;\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), true);\n    assert_eq!(candidate(11), false);\n    assert_eq!(candidate(12), true);\n    assert_eq!(candidate(13), false);\n    assert_eq!(candidate(16), true);\n}\n"},{"task_id":"HumanEval_139","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ འདི་ནང་ལུ་ n > 0 \/\/\/ brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/\/ བེརཱཇི་ལི་གི་གནས་སྡུད་འདི་ འ་ནི་བཟུམ་སྦེ་གསལ་བཀོད་འབདཝ་ཨིན།\/\/\/ >>> special_factorial(4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n","canonical_solution":"fn factorial(n: isize) -> isize {\n    (1..=n).product()\n}\n\nfn special_factorial(n: isize) -> isize {\n    (1..=n).map(factorial).product()\n}\n\nfn main() {\n    let result = special_factorial(4);\n    println!(\"{}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"},{"task_id":"HumanEval_140","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དེ་ལས་ཤུལ་མམ་གྱི་ས་སྟོང་ཚུ་ཆ་མཉམ་ལུ་ -  དང་གཅིག་ཁར་ཚབ་རྐྱབས།\/\/\/ དང་ string ལུ་ཤུལ་མམ་གྱི་ས་སྟོང་གཉིས་ལས་ལྷག་ཡོད་པ་ཅིན་ \/\/\/ ཚིག་ཡིག་ཐིག་ཁྲམ་ཅིག་བྱིན་པ་ཅིན་ ནང་འཁོད་ས་སྟོང་ཆ་མཉམ་ལུ་ འོག་ལུ་ཡོད་མི་ཡིག་དཔར་ཚུ་ དང་གཅིག་ཁར་ཚབ་བཙུགས་དགོ།\/\/\/ >>> fix_spaces(String::from(\" Example\"))\n\/\/\/ String::from(\"Example\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 1\"))\n\/\/\/ String::from(\"Example_1\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 2\"))\n\/\/\/ String::from(\"_Example_2\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 3\"))\n\/\/\/ String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n","canonical_solution":"fn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut space_count = 0;\n\n    for c in text.chars() {\n        if c == ' ' {\n            space_count += 1;\n        } else {\n            if space_count > 2 {\n                result.push('-');\n            } else if space_count > 0 {\n                result.push_str(&\"_\".repeat(space_count));\n            }\n            result.push(c);\n            space_count = 0;\n        }\n    }\n\n    if space_count > 2 {\n        result.push('-');\n    } else if space_count > 0 {\n        result.push_str(&\"_\".repeat(space_count));\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = fix_spaces;\n    assert_eq!(candidate(String::from(\"Example\")), String::from(\"Example\"));\n    assert_eq!(candidate(String::from(\"Mudasir Hanif \")), String::from(\"Mudasir_Hanif_\"));\n    assert_eq!(candidate(String::from(\"Yellow Yellow  Dirty  Fellow\")), String::from(\"Yellow_Yellow__Dirty__Fellow\"));\n    assert_eq!(candidate(String::from(\"Exa   mple\")), String::from(\"Exa-mple\"));\n    assert_eq!(candidate(String::from(\"   Exa 1 2 2 mple\")), String::from(\"-Exa_1_2_2_mple\"));\n}\n"},{"task_id":"HumanEval_141","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ - ཌོཊི་གི་ཤུལ་ལས་ཡོད་པའི་སབ་སི་ཊི་རིང་འདི་ སྦྲགས་ཏེ་ཡོད་: ['txt', 'exe', 'dll'] \/\/\/ Latin alphabet ('a'-'z' and 'A'-'Z') ཚུ་ནང་ལུ་བསྒྱུར་བཅོས་འབད་ཡོདཔ་ཨིན།\/\/\/ - ཌོཊི་གི་ཧེ་མ་གི་ཡིག་འབྲུ་འདི་ སྟོངམ་མ་སྡོད་དགོཔ་མ་ཚད་ ནང་ལས་ཡིག་འབྲུ་ཅིག་ལས་ འགོ་བཙུགས་འོང་།\/\/\/ - ཡིག་སྣོད་མིང་ནང་ལུ་ གནད་སྡུད་གཅིག་རང་ཡོད་ '.' \/\/\/ - ཡིག་སྣོད་མིང་ནང་ལུ་ ཨང་གྲངས་གསུམ་ལས་ལྷག་སྟེ་ (\"0\" - \"9\") འབད་མི་བཏུབ་ཨིན།\/\/\/ འདི་ཚུ་གྲུབ་ནུག: \/\/\/ ཡིག་སྣོད་ཅིག་གི་མིང་འདི་ འོག་གི་གནས་སྟངས་ཚུ་ཆ་མཉམ་ནང་ཡོད་པ་ཅིན་རྐྱངམ་གཅིག་ ཆ་གནས་ཅན་སྦེ་བརྩི་འོང་།\/\/\/ འ་ནི་མིང་འདི་ཆ་རྐྱེན་ཅན་ཨིན་པ་ཅིན་ \"Yes\" ཟེར་ཨེབ་གཏང་འབད་ དེ་ལས་མེན་པ་ཅིན་ \"No\" ཟེར་ལོག་གཏང་འོང་།\/\/\/ ལས་འགན་ཅིག་བཟོཝ་ད་ ཡིག་སྣོད་ཅིག་གི་མིང་འདི་ ཕྱིར་འཐོན་འབད་འོང་།\/\/\/ >>> file_name_check(String::from(\"example.txt\"))\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> file_name_check(String::from(\"1example.dll\"))\n\/\/\/ String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n","canonical_solution":"fn file_name_check(file_name: String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n\n    if parts.len() != 2 {\n        return String::from(\"No\");\n    }\n\n    let before_dot = parts[0];\n    let after_dot = parts[1];\n\n    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {\n        return String::from(\"No\");\n    }\n\n    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return String::from(\"No\");\n    }\n\n    match after_dot {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _ => String::from(\"No\"),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\/this_is_valid.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n}\n"},{"task_id":"HumanEval_142","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ གིས་ ཝི་ཅཊར་ནང་ལུ་ ཨང་གྲངས་ཚུ་སོར་བསྒྱུར་འབད་དོ་ཡོདཔ་དང་ འདི་ནང་ལུ་ ཨང་གྲངས་ཚུ་ 3 དང་ 4 གི་གྱངས་ཁ་སྦེ་མི་འཐོན་ འདི་གི་ཤུལ་ལུ་ ལས་འགན་གིས་ ཨང་གྲངས་ཚུ་ཆ་མཉམ་བསྡོམས་འབད་ཡོདཔ་ཨིན།\/\/ཨང་གྲངས་ཧྲིལ་བུམ་འདི་ ཇི་ཨེན་ཌི་སི་འདི་ ཨང་གྲངས་༤ གི་ཨང་གྲངས་དང་ ཨང་གྲངས་༣ གྱི་ཨང་གྲངས་མེན་པ་ཅིན་ ཇི་ཨེན་ཌི་སི་འདི་ ཨང་གྲངས་ཧྲིལ་བུམ་ལུ་འགྱུར་འོང་།\/\/\/ འ་ནི་ལས་འགན་འདི་ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊ་ཅིག་ལེན་འོང་། ཝི་ཅཊ་ནང་གི་ནང་དོན་ག་ར་ལུ་ ལས་འགན་གྱིས་ ཨང་གྲངས་ཧྲིལ་བུའི་ནང་དོན་འདི་ ཚད་འཛིན་འབད་ཡོད་པ་ཅིན་ ཝར་ཀའཌི་འབདཝ་ཨིན།\/\/\/ \" ཟེར་\/\/\/ >>> lst\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> lst\n\/\/\/ vec![]\n\/\/\/ >>> lst\n\/\/\/ vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<isize>) -> isize {\n    lst.into_iter()\n        .enumerate()\n        .map(|(i, value)| {\n            if i % 3 == 0 {\n                value * value\n            } else if i % 4 == 0 {\n                value * value * value\n            } else {\n                value\n            }\n        })\n        .sum()\n}\n\nfn main() {\n    let lst = vec![1, 2, 3];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 14\n\n    let lst = vec![];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 0\n\n    let lst = vec![-1, -5, 2, -1, -5];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 112\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1, 2, 3]), 6);\n    assert_eq!(candidate(vec![1, 4, 9]), 14);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n    assert_eq!(candidate(vec![0]), 0);\n    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);\n    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);\n    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);\n    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n}\n"},{"task_id":"HumanEval_143","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་གཞི་ ༡:\/\/\/ ཚིག་ཡིག་གི་རིམ་པ་འདི་ ཚིག་ཡིག་གསརཔ་ནང་ དང་ཕུའི་རིམ་པ་བཟུམ་ཅིག་སྦེ་བཞག་དགོ།\/\/\/ འདི་ཚུ་ཨང་གྲངས་ངོ་མ་ཨིནམ་དང་ \/\/ཁྱོད་ཀྱིས་ ཚིག་ཡིག་གཞི་རྟེན་ནང་ལས་ ཚིག་ཡིག་ཚུ་ཡོད་པའི་ string སླར་ལོག་འབད་དགོཔ་ཨིན།\/\/\/ ཚིག་ཡིག་ནང་ལུ་ བར་སྟོང་བཙུགས་ཏེ་ དབྱེ་བ་ཕྱེ་མི་ཚིག་ཚུ་ཡོདཔ་ཨིན།\/\/ཁྱོད་ཀྱིས་ཚིག་ཡིག་ཅིག་ལུ་ངོ་ཚབ་འབད་ཡོད་པའི་ ཀེར་ཐིག་ཅིག་ཐོབ་འོང་།\/\/\/ >>> words_in_sentence(String::from(\"This is a test\"))\n\/\/\/ String::from(\"is\")\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(String::from(\"lets go for swimming\"))\n\/\/\/ String::from(\"go for\")\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n    let prime_length_words: Vec<&str> = words\n        .iter()\n        .filter(|&&word| is_prime(word.len()))\n        .cloned()\n        .collect();\n    prime_length_words.join(\" \")\n}\n\nfn main() {\n    assert_eq!(\n        words_in_sentence(String::from(\"This is a test\")),\n        String::from(\"is\")\n    );\n    assert_eq!(\n        words_in_sentence(String::from(\"lets go for swimming\")),\n        String::from(\"go for\")\n    );\n}","tests":"}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"));\n}\n"},{"task_id":"HumanEval_144","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཁྱོད་ཀྱིས་ x དང་ n འདི་ ཆ་ཤས་ངོ་མ་ཨིནམ་དང་ བཏུབ་པའི་གྲངས་སུ་ ༠ ཡོད་མེད་སྦེ་བཟོཝ་ཨིན།\/\/\/ <གྲངས་རྩིས་>\/<གྲངས་རྩིས་> འདི་ནང་ལུ་ གྲངས་རྩིས་དང་གྲངས་རྩིས་གཉིས་ཆ་ར་ ནུས་པ་ཅན་གྱི་ཨང་གྲངས་ཧྲིལ་བུམ་ཨིན།\/\/x དང་ n གཉིས་ཆ་རང་ལུ་ བརྒྱ་ཆ་གི་ཡིག་འབྲུ་སྦེ་སྟོན་ཡོདཔ་དང་ འདི་ཚུ་ནང་བཀོད་ཡོད་པའི་རྣམ་པ་ཡོདཔ་ཨིན།\/\/\/ x * n ལས་འགན་གྱིས་ x * n གིས་ ཨང་གྲངས་ཧྲིལ་བུམ་ཅིག་སྦེ་བརྟག་ཞིབ་འབད་བ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ བརྡ་བཀོད་འདི་འཇམ་ཏོང་ཏོ་འབད་འབད་འབད་ནིའི་འགན་ཁུར་འདི་ཨིན།\/\/\/ >>> simplify(String::from(\"1\/5\"), String::from(\"5\/1\"))\n\/\/\/ true\n\/\/\/ >>> simplify(String::from(\"1\/6\"), String::from(\"2\/1\"))\n\/\/\/ false\n\/\/\/ >>> simplify(String::from(\"7\/10\"), String::from(\"10\/2\"))\n\/\/\/ false\nfn simplify(x: String, n: String) -> bool {\n","canonical_solution":"fn gcd(a: u32, b: u32) -> u32 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn simplify(x: String, n: String) -> bool {\n    let x_parts: Vec<&str> = x.split('\/').collect();\n    let n_parts: Vec<&str> = n.split('\/').collect();\n    \n    let x_num: u32 = x_parts[0].parse().unwrap();\n    let x_den: u32 = x_parts[1].parse().unwrap();\n    let n_num: u32 = n_parts[0].parse().unwrap();\n    let n_den: u32 = n_parts[1].parse().unwrap();\n    \n    let result_num = x_num * n_num;\n    let result_den = x_den * n_den;\n    \n    let gcd_value = gcd(result_num, result_den);\n    \n    result_den \/ gcd_value == 1\n}","tests":"}\n\nfn main() {\n    let candidate = simplify;\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/6\"), String::from(\"2\/1\")), false);\n    assert_eq!(candidate(String::from(\"5\/1\"), String::from(\"3\/1\")), true);\n    assert_eq!(candidate(String::from(\"7\/10\"), String::from(\"10\/2\")), false);\n    assert_eq!(candidate(String::from(\"2\/10\"), String::from(\"50\/10\")), true);\n    assert_eq!(candidate(String::from(\"7\/2\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"11\/6\"), String::from(\"6\/1\")), true);\n    assert_eq!(candidate(String::from(\"2\/3\"), String::from(\"5\/2\")), false);\n    assert_eq!(candidate(String::from(\"5\/2\"), String::from(\"3\/5\")), false);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"8\/4\")), true);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"1\/5\")), false);\n}\n"},{"task_id":"HumanEval_145","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ འདི་ཚུ་ རང་བཞིན་གྱི་བེ་ཊར་ནང་ལུ་གཞི་བསྟུན་འབད་ཐོག་ལས་རིམ་སྒྲིག་འབདཝ་ཨིན།\/\/\/ དྲན་གསོ། དབྱེ་ཁག་ལེ་ཤ་ཅིག་ནང་ ཨང་གྲངས་ཚུ་བསྡོམས་ཏེ་ཡོད་པ་ཅིན་ \/\/\/ འདི་ཚུ་ཨང་གྲངས་ཚུ་བསྡོམས་ཏེ་ ཡར་སེང་འགྱོ་བའི་རིམ་པ་ལུ་ཨིན།\/\/\/ གནས་རིམ་འདི་ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊ་འདི་རིམ་སྒྲིག་འབད་ནིའི་དོན་ལས་ འབྲི་དགོ།\/\/\/ >>> order_by_points(vec![1, 11, -1, -11, -12])\n\/\/\/ vec![-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(vec![])\n\/\/\/ Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();\n\n    nums_with_indices.sort_by_key(|&(num, index)| {\n        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();\n        (sum_of_digits, index)\n    });\n\n    nums_with_indices.iter().map(|&(num, _)| num).collect()\n}\n\nfn main() {\n    \/\/ Example usage\n    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);\n    println!(\"{:?}\", sorted); \/\/ Output: [-1, -11, 1, -12, 11]\n}","tests":"}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"},{"task_id":"HumanEval_146","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/ཨང་གྲངས་ཀྱི་ཨང་གྲངས་དང་པ་དང་མཇུག་འདི་ གྱངས་ཁ་རྐྱང་པ་ (1, 3, 5, 7, 9) ཨིན།\/\/\/ འདི་ཡང་ ཝེ་ཀཊར་ནང་ལུ་ ཨེ་རེ་ ༡༠ ལས་སྦོམ་དང་ གཉིས་ཆ་ར་ཨིན།\/\/\/ ཨང་གྲངས་ཀྱི་བེ་ཊར་ཅིག་ཨེབ་གཏང་འབད་སྦེ་ ལོག་གཏང་མི་ལས་འགན་ཅིག་འབྲི་དགོ།\/\/\/ >>> specialFilter(vec![15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn specialFilter(nums: Vec<isize>) -> isize {\n    nums.into_iter().filter(|&num| {\n        let abs_num = num.abs();\n        abs_num > 10 && {\n            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();\n            let first_digit = digits.first().unwrap();\n            let last_digit = digits.last().unwrap();\n            first_digit % 2 == 1 && last_digit % 2 == 1\n        }\n    }).count() as isize\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result1 = specialFilter(vec![15, -73, 14, -15]);\n\/\/     println!(\"{}\", result1); \/\/ Output: 1\n\n\/\/     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);\n\/\/     println!(\"{}\", result2); \/\/ Output: 2\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = specialFilter;\n    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);\n    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);\n    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);\n    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);\n    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n}\n"},{"task_id":"HumanEval_147","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/a[i]+a[j]+a[k] འདི་ ༣ གི་གྱངས་ཁ་ཨིན།\/\/\/ i < j < k ཡོད་པའི་ a གི་ triples (a[i], a[j], a[k]) གི་གྱངས་ཁ་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ iརེ་ལུ་ (1 ≤ i ≤ n) གིས་ a[i] =i * i - i + 1 གྱི་གནས་གོང་འདི་ཐོབ་ཡོདཔ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ནུས་ལྡན་ཨང་གྲངས་ n ཐོབ་པ་ཅིན་ ཚེ་རིང་ n འབད་མི་ ཨང་གྲངས་ཧྲིལ་བུམ་ ཝེ་ཊར་ a བཟོ་དགོཔ་ཨིན།\/\/\/ >>> get_max_triples(5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n","canonical_solution":"fn get_max_triples(n: isize) -> isize {\n    let mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    \n    let mut count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    println!(\"{}\", get_max_triples(5)); \/\/ Output: 1\n}","tests":"}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5), 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n    assert_eq!(candidate(100), 53361);\n}\n"},{"task_id":"HumanEval_149","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/ཁྱོད་ཀྱིས་ཚིག་ཆ་མཉམ་ ཡུན་རིང་འདྲ་མཉམ་སྦེ་ཡོད་ཟེར་ མནོ་བསམ་བཏུབ།\/\/\/ ལས་འགན་འདི་གིས་ གྲལ་ཐིག་ཚུ་རིམ་སྒྲིག་འབད་ཡོད་པའི་ ཝེ་ཀཊར་ཅིག་ལོག་བྱིན་དགོ།\/\/ཚིག་གཉིས་ཆ་ར་ ཡུན་ཚད་འདྲན་འདྲ་ཡོད་པ་ཅིན་ ཝི་ཅཊ་འདི་ ཨེཕ་ཊི་གི་རིམ་པ་ལུ་དབྱེ་ཞིབ་འབད་དགོ\/\/\/ གིས་ ཚད་གཞི་འདི་དང་བསྟུན་ཏེ་ དབྱེ་བ་ཕྱེ་ཡོད་པའི་ ཝི་ཅཊར་ལོག་གཏང་དགོ།\/\/ཁྱོད་ཀྱིས་ ཚིག་རེ་རེ་ནང་ ཚིག་གི་ཚད་གཞི་ཡར་སེང་འབད་དགོཔ་ཨིན།\/\/\/ འདི་ནང་ལུ་ ཐེངས་གཉིས་འབད་མི་ཡང་ འཐོབ་ཚུགས།\/\/ཝེ་ཀཊར་འདི་ རྟག་བུ་རང་ ཚིག་ཡིག་གི་ཝེ་ཀཊར་དང་ ཨང་གྲངས་ཀྱི་ཝེ་ཀཊར་མེན།\/\/\/ དང་ གྲུབ་འབྲས་ཅན་གྱི་ ཝེ་ཀཊར་འདི་རིམ་སྒྲིག་འབད་ཡོད་པའི་རིམ་སྒྲིག་འབད་ཡོད་པའི་ ཝེ་ཀཊར་འདི་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ འདི་ནང་ལས་ ཚར་མ་ཅན་གྱི་རིང་ཚད་ཡོད་མི་ string ཚུ་སེལ་འཐུ་འབདཝ་ཨིན།\/\/\/ ཚད་གཞི་ཅིག་སྦེ་ string གི་བེ་ཊར་ཅིག་ལེན་མི་ལས་འགན་ཅིག་འབྲི་དགོ།\/\/\/ >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n\/\/\/ vec![String::from(\"aa\")]\n\/\/\/ >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n\/\/\/ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut even_length_strings: Vec<String> = lst\n        .into_iter()\n        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    \n    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    \n    even_length_strings\n}\n\nfn main() {\n    let result = sorted_list_sum(vec![\n        String::from(\"aa\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"aa\"]\n\n    let result = sorted_list_sum(vec![\n        String::from(\"ab\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n        String::from(\"cd\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"ab\", \"cd\"]\n}","tests":"}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")]);\n}\n"},{"task_id":"HumanEval_150","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ དེ་ཨང་གྲངས་ངོ་མ་ཅིག་ཨིནམ་ལས་ y གི་གནས་གོང་ལོག་སྤྲོད་དགོཔ་ཨིན།\/\/\/ ལས་རིམ་ཅིག་ཨིནམ་ད་ དེ་གིས་ n འདི་ ཨིན་པ་ཅིན་ x གི་གནས་གོང་ལོག་བྱིན་འོང་།\/\/\/ >>> x_or_y(7, 34, 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(15, 8, 5)\n\/\/\/ 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n","canonical_solution":"fn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        for i in 2..=((num as f64).sqrt() as isize) {\n            if num % i == 0 {\n                return false;\n            }\n        }\n        true\n    }\n    \n    if is_prime(n) {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    println!(\"{}\", x_or_y(7, 34, 12)); \/\/ Output: 34\n    println!(\"{}\", x_or_y(15, 8, 5)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = x_or_y;\n    assert_eq!(candidate(7, 34, 12), 34);\n    assert_eq!(candidate(15, 8, 5), 5);\n    assert_eq!(candidate(3, 33, 5212), 33);\n    assert_eq!(candidate(1259, 3, 52), 3);\n    assert_eq!(candidate(7919, -1, 12), -1);\n    assert_eq!(candidate(3609, 1245, 583), 583);\n    assert_eq!(candidate(91, 56, 129), 129);\n    assert_eq!(candidate(6, 34, 1234), 1234);\n    assert_eq!(candidate(1, 2, 0), 0);\n    assert_eq!(candidate(2, 2, 0), 2);\n}\n"},{"task_id":"HumanEval_151","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཕྲང་སྒྲིག་ནང་ལུ་ ཨང་གྲངས་ཆ་མེད་ཚུ་ཡོད་པ་ཅིན་ ཕྲང་སྒྲིག་འདི་ནང་ ཨང་གྲངས་ཆ་མེད་ཚུ་ཡོད་པ་ཅིན་ ཕྲང་སྒྲིག་འདི་ནང་ ཨང་གྲངས་ཆ་མེད་ཚུ་ཡོད་པ་ཅིན་ ཕྲང་སྒྲིག་འདི་ནང་ ཨང་གྲངས་ཆ་མེད་ཚུ་ཡོད་པ་ཅིན་\/\/ཨང་གྲངས་ཀྱི་ ཝི་ཅཊར་ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཀྱི་གྲུ་བཞི་བསྡོམས་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> double_the_difference(vec![1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(vec![-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(vec![9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(vec![0])\n\/\/\/ 0\n\/\/\/ If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn double_the_difference(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)\n        .map(|&x| (x as isize).pow(2))\n        .sum()\n}\n\nfn main() {\n    println!(\"{}\", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); \/\/ 10\n    println!(\"{}\", double_the_difference(vec![-1.0, -2.0, 0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![9.0, -2.0])); \/\/ 81\n    println!(\"{}\", double_the_difference(vec![0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![])); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()), 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"},{"task_id":"HumanEval_152","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/ཚད་འདི་ ༠ ཨིན་པ་ཅིན་ ཚད་འདི་དཔའ་རྟགས་དང་ ཨང་གི་བར་ན་ ཁྱད་པར་ངོ་མ་ཨིན།\/\/ཚད་གཞི་འདི་ ཚད་གཞི་འདི་དང་འདྲཝ་སྦེ་ལོག་གཏང་། ཚད་གཞི་འདི་ལས་ ཚོད་དཔག་འབད་མི་འདི་ག་དེམ་ཅིག་ཐག་རིང་ཡོདཔ་ཨིན་ན་སྟོན་འོང་།\/\/ཁྱོད་ཀྱིས་ ཨང་དང་ཚོད་དཔག་འབད་ཡོད་པའི་ ཝི་ཅཊ་གཉིས་ཐོབ་ཡོདཔ་དང་ འདི་ནང་ བརྡ་བཀོད་རེ་རེ་གི་ནང་ མཉམ་འབྲེལ་ཅིག་སྟོན་ཡོདཔ་ཨིན།\/\/ཁྱོད་ཀྱི་ལཱ་འདི་ མི་གཅིག་གིས་ རྩེད་འགྲན་གྱི་གྲུབ་འབྲས་ཚུ་ ལེགས་ཤོམ་སྦེ་ར་ ཧ་གོ་ཡོདཔ་ཨིན་ན་ བལྟ་ནི་དེ་ཨིན།\/\/\/ འདི་ཚུ་ཆ་བཞག་ནི་དང་བསྡུར་རྐྱབ་ནི་དེ་ ངེས་པ་ཅིག་ཨིན།\/\/བྱུང་རྐྱེན་འདི་ མཇུག་བསྡུ་བའི་སྐབས་ལུ་ ཤེས་ཚུགས་འོང་། ཚོར་སྣང་དང་མནོ་བསམ་འདི་ ད་ལྟོ་རང་ ཁྱོད་དང་གཅིག་ཁར་ཡོད་མི་འདི་ཨིན།\/\/ང་བཅས་ག་ར་གིས་ འདི་བཟུམ་གྱི་ཚོར་སྣང་འདི་ སེམས་ཁར་དྲན་ཏེ་རང་སྡོད་འོང་ ག་ཅི་སྨོ་ཟེར་བ་ཅིན་ ཤུལ་ལས་ཅིག་ལས་ བྱུང་མི་རེ་བ་འདི་ ཡུན་རིངམོ་སྦེ་ར་ བསྒུག་སྡོད་ནུག\/\/\/ >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n\/\/\/ vec![0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n\/\/\/ vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    game.iter()\n        .zip(guess.iter())\n        .map(|(g, gss)| (g - gss).abs())\n        .collect()\n}\n\nfn main() {\n    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);\n    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);\n    println!(\"{:?}\", result1); \/\/ Output: [0, 0, 0, 0, 3, 3]\n    println!(\"{:?}\", result2); \/\/ Output: [4, 4, 1, 0, 0, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = compare;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);\n    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);\n    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);\n    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);\n}\n"},{"task_id":"HumanEval_153","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/\/ (ཤུགས་དེ་ -༡ ཨིན།)\/\/\/ return 'Slices.SErviNGSliCes' འདི་ ཤུགས་ཅན་ཅིག་ཨིནམ་ལས་ 'SErviNGSliCes' འདི་ ཤུགས་ཅན་ཅིག་སྦེ་རང་ \/\/\/ extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] འདི་ཨིན་པ་ཅིན་ ཁྱོད་ཀྱིས་ \/\/དཔེར་ན་ ཁྱོད་ཀྱིས་ \"Slices\" འདི་ གི་དབྱེ་བ་དང་ གི་བེ་ཊར་སྦེ་བྱིན་པ་ཅིན་\/\/ཝེ་ཀཊར་ནང་ལུ་ འགོ་དང་པ་འོང་མི་འདི་ གདམ་ཁ་རྐྱབས།\/\/\/ ག་དེམ་ཅིག་སྦེ་ ཤུགས་འདྲ་མཉམ་ཡོད་མི་ ཌའི་ལོག་གཉིས་ ཡང་ན་དེ་ལས་མང་ཡོད་པ་ཅིན་ ཁྱོད་ཀྱིས་ ཌའི་ལོག་འདི་ ཌའི་ལོག་གི་ ཌའི་ལོག་གི་ ཌའི་ལོག་ནང་བཙུགས་དགོ།\/\/\/ format: ClassName.StrongestExtensionName.  བཟོ་རྣམ་: ཌའི་ལོག་གི་མིང་། \/\/ཁྱོད་ཀྱིས་ ཤུགས་ཅན་ཅིག་བཙག་ཞིནམ་ལས་ string འདི་ནང་སླར་ལོག་འབད་དགོ།\/\/\/ རྒྱ་སྐྱེད་ཀྱི་མིང་ནང་ལུ་ ནུས་ཤུགས་འདི་ CAP - SM གི་ཆ་ཤས་གིས་བྱིན་ཡོདཔ་ཨིན།\/\/ཨེགསི་ཨེན་གྱི་མིང་ནང་ལུ་ཡིག་འབྲུ་ཚུ་དང་ SM འདི་ཡིག་འབྲུ་ཆུང་བའི་གྱངས་ཁ་ཨིན།\/\/\/ ཁྱབ་ཚད་ཀྱི་ཤུགས་འདི་ འོག་ལུ་བཟུམ་སྦེ་ཨིན། CAP འདི་ཡིག་འབྲུ་སྦོམ་པའི་ཨང་གྲངས་ཅིག་སྦེ་བཞག་དགོ།\/\/\/ ཁྱབ་ཚད་ཚུ་ལག་ལེན་འཐབ་ནི་དེ་ སློབ་ཚན་ནང་ ཁ་སྐོང་སློབ་ཚན་ཚུ་ ལེཌ་གཏང་ནིའི་དོན་ལུ་ཨིན།\/\/ཁྱོད་ཀྱིས་ ཚད་འཛིན་གྱི་མིང་ (ཐིག་ཡིག་) དང་ ཁྱབ་ཚད་ཀྱི་ ཝི་ཅཊར་ཐོབ་འོང་།\/\/\/ >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n\/\/\/ String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n","canonical_solution":"fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut strongest_extension = String::new();\n    let mut max_strength = i32::MIN;\n\n    for extension in extensions {\n        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;\n        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;\n        let strength = cap_count - sm_count;\n\n        if strength > max_strength {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, strongest_extension)\n}","tests":"}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"},{"task_id":"HumanEval_154","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/ཁྱོད་ཀྱིས་ཚིག་གཉིས་ཐོབ་ཨིན། ཁྱོད་ཀྱིས་ཚིག་གཉིས་པ་ ཡང་ན་ འདི་གི་འཁོར་ལོའི་གྲལ་རིམ་ཚུ་ ཚིག་དང་པ་ནང་ ནང་ཐིག་ཅིག་ཨིན་པ་ཅིན་ ཁྱོད་ཀྱིས་བདེན་པ་སྦེ་ལོག་གཏང་དགོ།\/\/\/ >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n\/\/\/ true\nfn cycpattern_check(a: String, b: String) -> bool {\n","canonical_solution":"fn cycpattern_check(a: String, b: String) -> bool {\n    let len_b = b.len();\n    if len_b == 0 {\n        return true;\n    }\n    let doubled_b = b.clone() + &b;\n    for i in 0..len_b {\n        if let Some(sub) = doubled_b.get(i..i + len_b) {\n            if a.contains(sub) {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = cycpattern_check;\n    assert_eq!(candidate(String::from(\"xyzw\"), String::from(\"xyw\")), false);\n    assert_eq!(candidate(String::from(\"yello\"), String::from(\"ell\")), true);\n    assert_eq!(candidate(String::from(\"whattup\"), String::from(\"ptut\")), false);\n    assert_eq!(candidate(String::from(\"efef\"), String::from(\"fee\")), true);\n    assert_eq!(candidate(String::from(\"abab\"), String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"winemtt\"), String::from(\"tinem\")), true);\n}\n"},{"task_id":"HumanEval_155","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/\/ ཨང་གྲངས་ཧྲིལ་བུམ་ཅིག་བྱིན་པ་ཅིན་ ཨང་གྲངས་ཆ་མཉམ་དང་ཆ་མཉམ་མེད་པའི་ཨང་གྲངས་ཚུ་ཡོད་མི་འདི་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> even_odd_count(-12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(123)\n\/\/\/ (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n","canonical_solution":"fn even_odd_count(num: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    let num_str = num.abs().to_string();\n    \n    for ch in num_str.chars() {\n        if let Some(digit) = ch.to_digit(10) {\n            if digit % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_count;\n    assert_eq!(candidate(7), (0, 1));\n    assert_eq!(candidate(-78), (1, 1));\n    assert_eq!(candidate(3452), (2, 2));\n    assert_eq!(candidate(346211), (3, 3));\n    assert_eq!(candidate(-345821), (3, 3));\n    assert_eq!(candidate(-2), (1, 0));\n    assert_eq!(candidate(-45347), (2, 3));\n    assert_eq!(candidate(0), (1, 0));\n}\n"},{"task_id":"HumanEval_156","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་: \/\/\/ བཀག་དམ་: ༡ <= ཨང་གྲངས་ <= ༡༠༠༠\/\/དེ་ལས་ཡིག་འབྲུ་ཆུང་བ་ནང་ལོག་གཏང་།\/\/ཨང་གྲངས་ཧྲིལ་བུམ་ཅིག་ཐོབ་པ་ཅིན་ རོམ་ཨང་གྲངས་ནང་ ཝིན་ཌིང་གི་ཨང་གྲངས་ སྦེ་ཐོབ་དགོ།\/\/\/ >>> int_to_mini_roman(19)\n\/\/\/ String::from(\"xix\")\n\/\/\/ >>> int_to_mini_roman(152)\n\/\/\/ String::from(\"clii\")\n\/\/\/ >>> int_to_mini_roman(426)\n\/\/\/ String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n","canonical_solution":"fn int_to_mini_roman(mut number: isize) -> String {\n    let roman_numerals = [\n        (1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n        (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n        (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"),\n        (1, \"i\"),\n    ];\n    \n    let mut result = String::new();\n    \n    for &(value, symbol) in roman_numerals.iter() {\n        while number >= value {\n            number -= value;\n            result.push_str(symbol);\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"},{"task_id":"HumanEval_157","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/\/ དབྱེ་ཁག་༩༠་ཨིན།\/\/ཟུར་ཐིག་ཕྲང་ཟུར་གསུམ་འདི་ ཟུར་ཐིག་གཅིག་ ཟུར་ཐིག་ཕྲང་ཟུར་ ཡང་ན་ ཟུར་ཐིག་ཕྲང་ཟུར་ཨིནམ་སྦེ་དབྱེ་བའི་ ཟུར་ཐིག་ཨིན།\/\/\/ ཕྱོགས་ཚུ་ ཟུར་ཟུར་གསུམ་སྦེ་བཟོ་སྟེ་ཡོདཔ་དང་ གཞན་མི་ཐད་ཀར་ཚུ་རྫུས་མ་ཨིན།\/\/ཚད་གསུམ་གྱི་ཟུར་གསུམ་གྱི་རིང་ཚད་ཚུ་བྱིན་ཏེ་ཡོད་པ་ཅིན་ true སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/\/ false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n","canonical_solution":"fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let mut sides = [a, b, c];\n    sides.sort_unstable();\n\n    let [x, y, z] = sides;\n    x * x + y * y == z * z\n}","tests":"}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3, 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10, 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7, 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5, 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48, 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2, 2, 10), false);\n}\n"},{"task_id":"HumanEval_158","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ཡིག་འབྲུ་ཚུ་ འབྲི་ཤོག་གི་རིམ་པ་ནང་ དང་པ་འཐོན་མི་འདི་ལོག་གཏང་།\/\/\/ ནང་ལུ་ཡིག་འབྲུ་མ་འདྲཝ་ཚུ་ཡོདཔ་ཨིན།\/\/\/ ཝི་ཅཊར་ནང་ལུ་ ཚིག་མ་འདྲཝ་ཚུ་ཡོདཔ་ཨིན་ ཚིག་འདི་ཨང་གྲངས་མང་ཤོས་ཅིག་དང་གཅིག་ཁར་ལོག་གཏང་།\/\/\/ ཝེ་ཀཊར་ཚུ་ལེན་མི་ལས་འགན་ཅིག་འབྲི་དགོ།\/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n\/\/\/ String::from(\"string\")\n\/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n\/\/\/ String::from(\"enam\")\n\/\/\/ >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n\/\/\/ String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n","canonical_solution":"fn find_max(words: Vec<String>) -> String {\n    fn unique_char_count(s: &str) -> usize {\n        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();\n        for c in s.chars() {\n            chars.insert(c);\n        }\n        chars.len()\n    }\n\n    words\n        .into_iter()\n        .max_by(|a, b| {\n            let count_a = unique_char_count(a);\n            let count_b = unique_char_count(b);\n            count_a.cmp(&count_b).then_with(|| a.cmp(b))\n        })\n        .unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n"},{"task_id":"HumanEval_159","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/གལ་སྲིད་ ཀ་ར་ཏཱན་ལངམ་མེད་པ་ཅིན་ ཀ་ར་ཏཱན་ལངམ་ཡོད་མི་ཚུ་ག་ར་ བཟའ་ནི་ཡོད་རུང་ ལྟོཝ་བཀྱེས་ནི་ཨིན་མས།\/\/ཁྱོད་ཀྱིས་ཟ་ཚར་བའི་ཤུལ་ལུ་ ཀ་རོཊ་ག་དེ་ཅིག་ལུས་ཡོདཔ་ཨིན་ན་ [ སྟོན་ནི་]\/\/ཁྱོད་ཀྱིས་ ཟ་ཚར་བའི་ཤུལ་ལུ་ ཟད་འགྲོ་བཏང་མི་ ཀ་རོཊ་གི་གྱངས་ཁ་འདི་ སླར་ལོག་འབད་དགོཔ་ཨིན།\/\/ད་ཁྱོད་ཀྱིས་ ཉིནམ་འདི་ནང་གི་བཞེས་སྒོ་ཚུ་ ཟ་ནི་གི་དོན་ལུ་ ཀ་ར་ཏོ་ལེ་ཤ་ཟ་དགོ\/\/ཁྱོད་ལྟོཝ་བཀྱེས་པའི་བྱ་རྒོད་ཅིག་ཨིན་ ཁྱོད་ཀྱིས་ གུ་རུའི་རིགས་ཚུ་ ལེ་ཤ་ཅིག་རང་ བཟའ་ཚར་ནུག\/\/\/ >>> eat(5, 6, 10)\n\/\/\/ vec![11, 4]\n\/\/\/ >>> eat(4, 8, 9)\n\/\/\/ vec![12, 1]\n\/\/\/ >>> eat(1, 10, 10)\n\/\/\/ vec![11, 0]\n\/\/\/ >>> eat(2, 11, 5)\n\/\/\/ vec![7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n","canonical_solution":"fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let to_eat = if need <= remaining { need } else { remaining };\n    vec![number + to_eat, remaining - to_eat]\n}","tests":"}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"},{"task_id":"HumanEval_160","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ ལས་འགན་བེ་ཊར་ནང་ལུ་ ལས་འགན་ཉུང་ཤོས་ཅིག་དང་ ལས་འགན་བེ་ཊར་ནང་ལུ་ ལས་འགན་ཉུང་ཤོས་གཉིས་ཡོདཔ་ཨིན།\/\/ཨོ་པེ་རེན་ཌི་འདི་ ནེ་གེ་ཊར་མེན་པའི་ཨང་གྲངས་ཧྲིལ་བུའི་ ཝི་ཅཊར་ཨིན།\/\/\/ ལས་འགན་གི་རིང་ཚད་འདི་ ལས་འགན་གི་རིང་ཚད་དང་མཉམ་པ་ཨིན།\/\/\/ དྲན་གསོ།: \/\/= = གྲུབ་འབྲས་འདི་ ༩ ཨིན།\/\/\/ གྲུབ་འབྲས་ = ༢ + ༣ * ༤ - ༥\/\/\/ ཝེཊ་ཊར་ = [༢,༣,༤,༥] ཨིན།\/\/\/ ལས་གཡོགཔ་['+', '*', '-'] \/\/\/ དཔེ་འབད་བ་ཅིན་: \/\/\/ གྱངས་ཁ་འདི་ (**) ཨིན།\/\/\/ ས་ཐོག་གི་དབྱེ་ཁག་ ( \/\/) \/\/\/ དབྱེ་བ་ (*) ཚུ་\/\/\/ མར་ཕབ་ ( - ) \/\/\/ ཁ་སྐོང་ (+) \/\/\/ གཞི་རྟེན་ཨེལ་ཇི་བཱེར་ལཱ་ཚུ་: \/\/\/ expression དང་ expression གི་མཐའ་དཔྱད་འདི་ལོག་གཏང་།\/\/ཝེ་ཀཊར་གཉིས་པ་འདི་ ཨང་གྲངས་ཧྲིལ་བུའི་ ཝེ་ཀཊར་ཅིག་ཨིན། ཨེལ་ཇི་བཱརཀ་བཟོ་ནིའི་དོན་ལུ་ ཝེ་ཀཊར་གཉིས་འདི་ལག་ལེན་འཐབ་ཨིན།\/\/\/ ཝི་ཅཊ་གཉིས་བྱིན་ཏེ་ ཨོ་པེ་རེན་ཌ། དང་པ་ཝི་ཅཊ་འདི་ནང་ལུ་ གཞི་རྟེན་ཨེལ་ཇི་བཱར་གི་ལཱ་ཚུ་ཡོདཔ་དང་ fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n","canonical_solution":"fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = operand[0];\n    \n    for i in 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i+1],\n            \"-\" => result -= operand[i+1],\n            \"*\" => result *= operand[i+1],\n            \"\/\/\" => result \/= operand[i+1],\n            \"**\" => result = result.pow(operand[i+1] as u32),\n            _ => panic!(\"Unexpected operator\"),\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    let operators = vec![\"+\",\"*\",\"-\"].iter().map(|s| s.to_string()).collect();\n    let operands = vec![2, 3, 4, 5];\n    let result = do_algebra(operators, operands);\n    println!(\"Result: {}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"**\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"+\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\/\/\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"},{"task_id":"HumanEval_161","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ དཔེ་སྟོན་ \/\/\/ ལས་འགན་འདི་གིས་ གྲུབ་འབྲས་ཀྱི་ཐིག་ཡིག་ལོག་བྱིན་དགོ།\/\/stringནང་ལུ་ཡིག་འབྲུ་མེད་པ་ཅིན་ stringའདི་ཁ་བསྒྱུར་འབད།\/\/དེ་མེན་པ་ཅིན་ འདི་བཟུམ་སྦེ་རང་བཞག་དགོ\/\/\/ s[i]འདི་ཡིག་འབྲུ་ཅིག་ཨིན་པ་ཅིན་ དེའི་ཡིག་གཟུགས་འདི་ འོག་ལས་མཐོ་ ཡང་ན་ ཕྱོགས་གཞན་ཁ་ཐུག་ལས་ བསྒྱུར་གཏང་།\/\/ཁྱོད་ཀྱིས་ string s ཅིག་ཐོབ་ནུག\/\/\/ >>> solve(String::from(\"1234\"))\n\/\/\/ String::from(\"4321\")\n\/\/\/ >>> solve(String::from(\"ab\"))\n\/\/\/ String::from(\"AB\")\n\/\/\/ >>> solve(String::from(\"#a@C\"))\n\/\/\/ String::from(\"#A@c\")\nfn solve(s: String) -> String {\n","canonical_solution":"fn solve(s: String) -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n        s.chars()\n            .map(|c| {\n                if c.is_lowercase() {\n                    c.to_ascii_uppercase()\n                } else if c.is_uppercase() {\n                    c.to_ascii_lowercase()\n                } else {\n                    c\n                }\n            })\n            .collect()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"},{"task_id":"HumanEval_162","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/\/ 'text'འདི་ སྟོངམ་ཐིག་ཁྲམ་ཨིན་པ་ཅིན་ None སླར་ལོག་འབདཝ་ཨིན།\/\/\/ string 'text' ཅིག་བྱིན་པ་ཅིན་ md5 hash འདྲ་མཉམ་ string འདི་ལོག་གཏང་།\/\/\/ >>> string_to_md5(String::from(\"Hello world\"))\n\/\/\/ Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n","canonical_solution":"use md5;\n\nfn string_to_md5(text: String) -> Option<String> {\n    if text.is_empty() {\n        return None;\n    }\n    let digest = md5::compute(text);\n    Some(format!(\"{:x}\", digest))\n}","tests":"}\n\nfn main() {\n    let candidate = string_to_md5;\n    assert_eq!(candidate(String::from(\"Hello world\")), Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert_eq!(candidate(String::from(\"\")), None);\n    assert_eq!(candidate(String::from(\"A B C\")), Some(String::from(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert_eq!(candidate(String::from(\"password\")), Some(String::from(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n}\n"},{"task_id":"HumanEval_163","nl":"dzo_Tibt","pl":"rs","prompt":"\/\/དཔེ་འབད་བ་ཅིན་:\/\/\/ དང་ b འདི་ཡར་སེང་གི་རིམ་པ་ལུ་ཨིན།\/\/\/ ཨང་གྲངས་ཆ་མཉམ་ a དང་ b གཉིས་ཐོབ་པ་ཅིན་ ཨང་གྲངས་ཆ་མཉམ་ a དང་ b གི་བར་ན་སླར་ལོག་འབདཝ་ཨིན།\/\/\/ >>> generate_integers(2, 8)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(8, 2)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(10, 14)\n\/\/\/ Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n","canonical_solution":"fn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let (start, end) = if a < b { (a, b) } else { (b, a) };\n    (start..=end).filter(|&x| x % 2 == 0).collect()\n}\n\nfn main() {\n    let result1 = generate_integers(2, 8);\n    println!(\"{:?}\", result1); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result2 = generate_integers(8, 2);\n    println!(\"{:?}\", result2); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result3 = generate_integers(10, 14);\n    println!(\"{:?}\", result3); \/\/ Output: vec![10, 12, 14]\n}","tests":"}\n\nfn main() {\n    let candidate = generate_integers;\n    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(17, 89), Vec::<isize>::new());\n}\n"}]