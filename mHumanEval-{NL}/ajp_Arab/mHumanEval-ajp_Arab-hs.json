[{"task_id":"HumanEval_0","nl":"ajp_Arab","pl":"hs","prompt":"--عتبة معينة.--شوف لو في قائمة أرقام معينة، أي رقمين قريبين من بعضهم أكثر من--  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =","canonical_solution":"hasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold = any (\\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a \/= b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_1","nl":"ajp_Arab","pl":"hs","prompt":"--ما بتتجاهل أي فراغات في سلسلة الإدخال.--المجموعات المفصولة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) ولا متداخلة مع بعضها البعض.--فصل المجموعة دي في سلسلة مفردة و ارجع قائمة منها.--المدخلات لهذه الدالة هي سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو--  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =","canonical_solution":"separateParenGroups :: String -> [String]\nseparateParenGroups paren_string = go paren_string 0 [] \"\" []\n  where\n    go [] _ _ current acc = if null current then acc else acc ++ [current]\n    go (x:xs) depth stack current acc\n      | x == ' ' = go xs depth stack current acc\n      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc\n      | x == ')' =\n          let newCurrent = current ++ [x]\n              newDepth = depth - 1\n          in if newDepth == 0\n             then go xs newDepth (tail stack) \"\" (acc ++ [newCurrent])\n             else go xs newDepth (tail stack) newCurrent acc\n      | otherwise = error \"Unexpected character\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_2","nl":"ajp_Arab","pl":"hs","prompt":"--ارجع الجزء العشري من الرقم.--(الجزء الباقي دايماً أصغر من واحد).--و جزء عدد صحيح (اكبر عدد صحيح أصغر من الرقم المعطى) و العشريات --مع عدد نقطة تعويم موجب، ممكن نحلله لـ--  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =","canonical_solution":"truncateNumber :: Float -> Float\ntruncateNumber number = number - fromIntegral (floor number)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_3","nl":"ajp_Arab","pl":"hs","prompt":"--في هذه النقطة، المفروض ان الوظيفة تعيد الصواب. و إلا، يجب ان تعيد الصواب.--مهمتك هي انك تكتشف اذا في اي وقت رصيد الحساب هيقل تحت الصفر، و--بتعطيك قائمة عمليات الإيداع والسحب على حساب مصرفي بتبدأ ب--  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =","canonical_solution":"belowZero :: [Int] -> Bool\nbelowZero operations = any (< 0) $ scanl (+) 0 operations","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_4","nl":"ajp_Arab","pl":"hs","prompt":"--MAD = متوسط. x - x_mean.--عنصر ونقطة وسط (الوسط في الحالة دي):--متوسط الانحراف المطلق هو متوسط الاختلاف المطلق بين كل --حوالي متوسط مجموعة البيانات.--لليست المعطى من الأرقام المدخلة، احسب متوسط الانحراف المطلق.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =","canonical_solution":"meanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers = sum absoluteDifferences \/ fromIntegral (length numbers)\n  where\n    mean = sum numbers \/ fromIntegral (length numbers)\n    absoluteDifferences = map (\\x -> abs (x - mean)) numbers","tests":"\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_5","nl":"ajp_Arab","pl":"hs","prompt":"--ضعي رقم 'محدد' بين كل عنصرين متتاليين من قائمة الإدخال ∀numbers' --  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =","canonical_solution":"intersperse :: [Int] -> Int -> [Int]\nintersperse [] _ = []\nintersperse [x] _ = [x]\nintersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_6","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً (() (()) عندها حد أقصى مستويين من التعشيش بينما ((())) عندها ثلاثة.--لكل مجموعة، اخرج أعمق مستوى من التأمين بين قوسين.--المدخلات لهذه الدالة هي سلسلة تمثل مجموعات متعددة لترابط بين قوسين مفصولين بالفراغات.--  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =","canonical_solution":"parseNestedParens :: String -> [Int]\nparseNestedParens paren_string = map maxDepth (words paren_string)\n  where\n    maxDepth :: String -> Int\n    maxDepth = go 0 0\n      where\n        go :: Int -> Int -> String -> Int\n        go currentDepth maxDepth [] = maxDepth\n        go currentDepth maxDepth (c:cs)\n          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs\n          | c == ')'  = go (currentDepth - 1) maxDepth cs\n          | otherwise = go currentDepth maxDepth cs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_7","nl":"ajp_Arab","pl":"hs","prompt":"--تصفية قائمة السلاسل المضمنة بس للسلسلة الفرعية المعطاة--  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =","canonical_solution":"filterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring = filter (substring `isInfixOf`) strings\n  where isInfixOf = isInfixOf","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_8","nl":"ajp_Arab","pl":"hs","prompt":"--المجموع الفارغ لازم يساوي صفر والمنتج الفارغ لازم يساوي واحد.--لليحة المعطاة من الأعداد الصحيحة، ارجع توبل يتكون من مجموع و ضرب كل الأعداد الصحيحة في القائمة.--  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =","canonical_solution":"sumProduct :: [Int] -> (Int, Int)\nsumProduct numbers = (sum numbers, product numbers)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_9","nl":"ajp_Arab","pl":"hs","prompt":"--في التسلسل.--من قائمة معينة من الأعداد الصحيحة، احصل على قائمة بأكبر عدد ممكن من العناصر الموجودة حتى اللحظة المعينة.--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =","canonical_solution":"rollingMax :: [Int] -> [Int]\nrollingMax = scanl1 max","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_10","nl":"ajp_Arab","pl":"hs","prompt":"--- اضف لنهاية السلسلة عكس سلفة السلسلة اللي بتأتي قبل اللحافه المتداخلة.--شوف أطول بعد من السلسلة المقدمة واللي هي بالندروم.--فكرة الخوارزمية بسيطة:--شوف اقصر حزمة تبدأ بحزمة موجودة.--  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =","canonical_solution":"makePalindrome :: String -> String\nmakePalindrome string = string ++ reverse (take (length string - palindromeLength) string)\n  where\n    palindromeLength = longestPalindromicSuffix string\n\nlongestPalindromicSuffix :: String -> Int\nlongestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]\n\nisPalindrome :: String -> Bool\nisPalindrome s = s == reverse s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_11","nl":"ajp_Arab","pl":"hs","prompt":"--عمل XOR ثنائي على هذه المدخلات و يرجع النتيجة كسلسلة.--\"المدخل هو سلسلتين \"أ\" و \"ب\" يتكونوا من واحد و صفر فقط.--  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =","canonical_solution":"stringXor :: String -> String -> String\nstringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_12","nl":"ajp_Arab","pl":"hs","prompt":"--return nothing في حالة القائمة المضافة فارغة.--من قائمة السلاسل، ارجع أطول واحد. ارجع الأول في حالة وجود عدد مضاعف.--  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =","canonical_solution":"longest :: [String] -> Maybe String\nlongest [] = Nothing\nlongest strings = Just $ foldl1 (\\acc x -> if length x > length acc then x else acc) strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_13","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع أكبر مقسم مشترك لعددين صحيحين أ و ب--  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =","canonical_solution":"greatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b\n  | b == 0    = a\n  | otherwise = greatestCommonDivisor b (a `mod` b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_14","nl":"ajp_Arab","pl":"hs","prompt":"--يسترد قائمة بكل البدايات من أقصر ل أطول من السلسلة المدخلة--  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =","canonical_solution":"allPrefixes :: String -> [String]\nallPrefixes string = [take n string | n <- [1 .. length string]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_15","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع سلسلة تحتوي على أرقام محددة مساحة تبدأ من 0 حتى n.--  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =","canonical_solution":"stringSequence :: Int -> String\nstringSequence n = unwords $ map show [0..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_16","nl":"ajp_Arab","pl":"hs","prompt":"--معطى سلسلة، شوف كم حرف مميز (بغض النظر عن الحرف الكبير) بتتكون من--  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =","canonical_solution":"import Data.Char (toLower)\nimport Data.Set (fromList, size)\n\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string = size . fromList $ map toLower string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_17","nl":"ajp_Arab","pl":"hs","prompt":"--\"كوكاي\" - نوتة رباعية، بتستمر لضربة واحدة.--\"أو ماشي\" - نص نوتة، بيستمر لثنين ضربات --\"أو\" -- كل النوتة، بتستمر أربع ضربات.--هاي أسطورة:--مش اخر واحد.--مهمتك هي تحليل السلسلة و إرجاع قائمة بالأعداد الصحيحة اللي بتتوافق مع عدد الضربات لكل واحد منها--المدخلات لهذه الدالة هي سلسلة تمثل الملاحظات الموسيقية في شكل خاص من نوع ASCII.--  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =","canonical_solution":"parseMusic :: String -> [Int]\nparseMusic music_string = map beats (words music_string)\n  where\n    beats \"o\" = 4\n    beats \"o|\" = 2\n    beats \".|\" = 1\n    beats _ = 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_18","nl":"ajp_Arab","pl":"hs","prompt":"--شوف كم مرة ممكن نلاقي فيها سلسلة فرعية معينة في السلسلة الأصلية. عد الحالات المتداخلة.--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =","canonical_solution":"howManyTimes :: String -> String -> Int\nhowManyTimes string substring\n  | null substring = 0\n  | otherwise = length . filter isPrefixOfSubstring $ tails string\n  where\n    isPrefixOfSubstring = isPrefixOf substring\n    isPrefixOf :: Eq a => [a] -> [a] -> Bool\n    isPrefixOf prefix str = prefix `isPrefixOf` str","tests":"\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_19","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع السلسلة مع ارقام مرتبة من أصغر لأكبر --الخيارات الصحيحة هي \"صفر\" و \"واحد\" و \"اثنين\" و \"ثلاثة\" و \"أربعة\" و \"خمسة\" و \"ستة\" و \"سبعة\" و \"ثمانية\" و \"تسعة\".--المدخل هو سلسلة من الأرقام المحددة مساحة من الصفر إلى التسعة.--  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =","canonical_solution":"import Data.List (sort)\nimport Data.Maybe (fromJust)\nimport Data.Map (Map, fromList, lookup)\n\nsortNumbers :: String -> String\nsortNumbers numbers = unwords $ map snd $ sort $ map (\\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)\n  where\n    wordToNumber :: Map String Int\n    wordToNumber = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4),\n                             (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_20","nl":"ajp_Arab","pl":"hs","prompt":"--ويعيدهم بالترتيب (عدد أقل، عدد أكبر).--من قائمة الأرقام المقدمة (من طولها على الأقل اثنين) حدد وإرجع اثنين اللي قريبين من كل واحد --  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =","canonical_solution":"findClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)\n  where\n    sortedNumbers = sort numbers\n    minByDiff (a1, b1) (a2, b2)\n      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)\n      | otherwise = (a2, b2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_21","nl":"ajp_Arab","pl":"hs","prompt":"--بحيث أصغر رقم يصير صفر وأكبر يصير واحد --مع قائمة من الأرقام (من عنصرين على الأقل) ، استخدم تحويل خطي على القائمة،--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =","canonical_solution":"rescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers = map (\\x -> (x - minVal) \/ range) numbers\n  where\n    minVal = minimum numbers\n    maxVal = maximum numbers\n    range = maxVal - minVal","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_23","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع طول السلسلة المعطاة.--  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =","canonical_solution":"strlen :: String -> Int\nstrlen string = length string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_24","nl":"ajp_Arab","pl":"hs","prompt":"--لعدد معين n، شوف اكبر عدد يقسم n بالتساوي، اصغر من n--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =","canonical_solution":"largestDivisor :: Int -> Int\nlargestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_25","nl":"ajp_Arab","pl":"hs","prompt":"--الرقم المدخل لازم يكون مساو للضربة لكل العوامل --كل عامل لازم يرد مرات تتوافق مع عدد مرات ظهوره في الفاكتور.--يرجع قائمة بعوامل أولية لعدد صحيح معين بالترتيب من أصغر لأكبر.--  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =","canonical_solution":"factorize :: Int -> [Int]\nfactorize n = factorize' n 2\n  where\n    factorize' 1 _ = []\n    factorize' m f\n      | m `mod` f == 0 = f : factorize' (m `div` f) f\n      | otherwise      = factorize' m (f + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_26","nl":"ajp_Arab","pl":"hs","prompt":"--خلي ترتيب العناصر نفس اللي في المدخلات.--من قائمة من الأعداد الصحيحة، ابعد كل العناصر اللي بتظهر اكثر من مرة.--  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =","canonical_solution":"removeDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers = filter (\\x -> count x numbers == 1) numbers\n  where\n    count x = length . filter (== x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_27","nl":"ajp_Arab","pl":"hs","prompt":"--لسلسلة معينة، حول الأحرف الصغيرة للكبيرة والكبيرة للكبيرة.--  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =","canonical_solution":"flipCase :: String -> String\nflipCase = map flipChar\n  where\n    flipChar c\n      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)\n      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_28","nl":"ajp_Arab","pl":"hs","prompt":"---- اجمع قائمة السلاسل في سلاسل واحدة ----  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =","canonical_solution":"concatenate :: [String] -> String\nconcatenate strings = concat strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_29","nl":"ajp_Arab","pl":"hs","prompt":"--تصفية قائمة السلاسل المضمنة بس للواحد اللي بيبدأ بمسبق معين.--  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =","canonical_solution":"filterByPrefix strings prefix = filter (isPrefixOf prefix) strings\n  where\n    isPrefixOf pfx str = take (length pfx) str == pfx","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_30","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع فقط الأرقام الإيجابية في القائمة.--  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =","canonical_solution":"getPositive :: [Int] -> [Int]\ngetPositive l = filter (> 0) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_31","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع الصواب اذا رقم معين هو عدد أولي، و غلط غير ذلك.--  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =","canonical_solution":"isPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = not (any (\\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_33","nl":"ajp_Arab","pl":"hs","prompt":"--قيم المؤشرات المقابلة لـ، لكن مرتبة.--l' هو متطابق لـ l في المؤشرات اللي مش قابلة للقسمة على ثلاثة، بينما قيمته في المؤشرات اللي قابلة للقسمة على ثلاثة متساوية --هاي الدالة بتأخذ قائمة l وتعيد قائمة l زي--  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =","canonical_solution":"sortThird :: [Int] -> [Int]\nsortThird l = map selectElem indexed\n  where\n    indexed = zip [0..] l\n    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]\n    sortedThirdElems = sortedElems thirdIndicesElems\n    sortedElems = id -- or List.sort if imported\n    selectElem (i, x)\n      | i `mod` 3 == 0 = head sortedThirdElems\n      | otherwise = x\n    replaceSortedElem xs sorted = map selectElem indexed\n      where\n        replaceElem i (x:xs)\n          | i == 0 = x:xs\n          | otherwise = replaceElem (i - 1) xs\n        selectElem (i, x)\n          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)\n          | otherwise = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_34","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع عناصر فريدة مرتبة في قائمة.--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =","canonical_solution":"unique :: [Int] -> [Int]\nunique l = sort $ nub l\n  where\n    -- | Remove duplicate elements from a list.\n    nub :: (Eq a) => [a] -> [a]\n    nub [] = []\n    nub (x:xs) = x : nub (filter (\/= x) xs)\n\n    -- | Sort a list of elements (using QuickSort algorithm).\n    sort :: (Ord a) => [a] -> [a]\n    sort [] = []\n    sort (x:xs) =\n      let smallerSorted = sort [a | a <- xs, a <= x]\n          biggerSorted = sort [a | a <- xs, a > x]\n      in  smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_35","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع العنصر الأقصى في القائمة.--  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =","canonical_solution":"maxElement :: [Int] -> Int\nmaxElement [] = error \"List cannot be empty\"\nmaxElement (x:xs) = maxElementHelper xs x\n  where\n    maxElementHelper [] currentMax = currentMax\n    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_36","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع عدد مرات ظهور الرقم 7 في عدد صحيح أقل من n قابل للقسمة على 11 أو 13.--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =","canonical_solution":"fizzBuzz :: Int -> Int\nfizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_37","nl":"ajp_Arab","pl":"hs","prompt":"--قيمة المؤشرات الزوجية لـ l، لكن مرتبة.--l' هو متطابق مع l في المؤشرات الفردية، بينما قيمته في المؤشرات الزوجية متساوية --هاي الدالة بتأخذ قائمة l وتعيد قائمة l زي--  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =","canonical_solution":"sortEven :: [Int] -> [Int]\nsortEven l = merge odds sortedEvens\n  where\n    (odds, evens) = partitionList l\n    sortedEvens = sort evens\n\n    partitionList :: [Int] -> ([Int], [Int])\n    partitionList [] = ([], [])\n    partitionList [x] = ([x], [])\n    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)\n      where\n        (xsOdds, xsEvens) = partitionList xs\n\n    merge :: [Int] -> [Int] -> [Int]\n    merge [] ys = ys\n    merge (x:xs) [] = x:xs\n    merge (x:xs) (y:ys) = x:y:merge xs ys","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_39","nl":"ajp_Arab","pl":"hs","prompt":"--prime_fib بيرد رقم n وهو رقم فيبوناتشي وهو ايضاً عدد أولي.--  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =","canonical_solution":"primeFib :: Int -> Int\nprimeFib n = primeFibs !! (n - 1)\n  where\n    primeFibs = filter isPrime fibs\n    fibs = map fst $ iterate (\\(a, b) -> (b, a + b)) (0, 1)\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2 = False\n  | k == 2 = True\n  | even k = False\n  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]\n  where\n    upperLimit = floor . sqrt $ fromIntegral k","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_40","nl":"ajp_Arab","pl":"hs","prompt":"--مجموع صفر، وإلا غلط.--بيرد صح اذا كان في ثلاث عناصر متميزة في القائمة --triples_sum_to_zero ياخد قائمة من الأعداد الصحيحة كمدخل.--  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =","canonical_solution":"triplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]\n  where\n    tails [] = []\n    tails xs@(_:xs') = xs : tails xs'","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_41","nl":"ajp_Arab","pl":"hs","prompt":"--هاي الدالة بتخرج عدد هالتصادمات.--في مسارهم كأنو ما اصطدموا.--بس، العربيات قوية و قوية جداً، و نتيجة، هي بتستمر في التحرك.--لما سيارة بتتحرك من اليسار لليمين تصطدم بسيارة بتتحرك من اليمين لليسار.--كل السيارات بتتحرك بنفس السرعة. يقال إن سيارتين تتصادموا.--رح يروحوا يمين لليسار.--n سيارات بتسير من اليسار لليمين، وفي نفس الوقت مجموعة مختلفة من n سيارات.--تخيل طريق مستقيم تمامًا خط طويل بلا حدود.carRaceCollision :: Int -> Int\ncarRaceCollision n =","canonical_solution":"carRaceCollision :: Int -> Int\ncarRaceCollision n = n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_42","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع قائمة مع عناصر زيادة بـ 1.--  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =","canonical_solution":"incrList :: [Int] -> [Int]\nincrList l = map (+1) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_43","nl":"ajp_Arab","pl":"hs","prompt":"--مجموع صفر، وإلا غلط.--بيرد صح اذا كان في عنصرين متميزين في القائمة --pairs_sum_to_zero ياخد قائمة من الأعداد الصحيحة كمدخل.--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =","canonical_solution":"pairsSumToZero :: [Int] -> Bool\npairsSumToZero l = any (\\x -> -x `elem` l) l && (length l > 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_44","nl":"ajp_Arab","pl":"hs","prompt":"--أرقام الأساس أقل من عشرة.--يعيد تمثيل السلسلة بعد التحويل.--غير القاعدة العددية لعدد x المدخل لقاعدة.--  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =","canonical_solution":"changeBase :: Int -> Int -> String\nchangeBase x base\n  | x < base  = show x\n  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_45","nl":"ajp_Arab","pl":"hs","prompt":"--مع طول الجانب و مساحة العودة العالية للمثلث.--  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =","canonical_solution":"triangleArea :: Int -> Int -> Float\ntriangleArea a h = 0.5 * fromIntegral a * fromIntegral h","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_46","nl":"ajp_Arab","pl":"hs","prompt":"--لو سمحت اكتب دالة عشان تحسب العنصر الـ ن من تسلسل الأرقام فيب4 بكفاءة. لا تستخدم التكرار.--fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --تسلسل الأرقام فيب 4 هو تسلسل مشابه لسلسلة فيبوناتشي واللي يعرف على النحو التالي:--  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =","canonical_solution":"fib4 :: Int -> Int\nfib4 n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 2\n  | n == 3 = 0\n  | otherwise = iter 0 0 2 0 n\n  where\n    iter a b c d 4 = a + b + c + d\n    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_47","nl":"ajp_Arab","pl":"hs","prompt":"--إسترجع الوسط العنصر في القائمة.--  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =","canonical_solution":"median :: [Int] -> Float\nmedian l \n  | odd n     = fromIntegral $ sorted !! mid\n  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) \/ 2\n  where\n    sorted = sort l\n    n = length l\n    mid = n `div` 2\n    sort = sortBy compare","tests":"\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_48","nl":"ajp_Arab","pl":"hs","prompt":"--بتتحقق اذا السلسلة المعطية هي بالندروم.--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =","canonical_solution":"isPalindrome :: String -> Bool\nisPalindrome text = text == reverse text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_49","nl":"ajp_Arab","pl":"hs","prompt":"--إسترد 2^n مودولو p (كونوا على علم بالعدد).--  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =","canonical_solution":"modp :: Int -> Int -> Int\nmodp n p = powMod 2 n p\n\npowMod :: Int -> Int -> Int -> Int\npowMod base exp modulus\n  | modulus == 1 = 0\n  | exp == 0     = 1\n  | exp == 1     = base `mod` modulus\n  | otherwise    = if odd exp\n                   then (base * halfExp * halfExp) `mod` modulus\n                   else (halfExp * halfExp) `mod` modulus\n  where\n    halfExp = powMod base (exp `div` 2) modulus","tests":"\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_51","nl":"ajp_Arab","pl":"hs","prompt":"--remove_vowels هي وظيفة بتأخذ السلسلة وتعيد السلسلة بدون حروف علة.--  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =","canonical_solution":"removeVowels :: String -> String\nremoveVowels text = filter (`notElem` \"aeiouAEIOU\") text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_52","nl":"ajp_Arab","pl":"hs","prompt":"--إسترد صحيح إذا كل الأرقام في القائمة l هي تحت الحد الزمني t.--  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =","canonical_solution":"belowThreshold l t = all (< t) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_53","nl":"ajp_Arab","pl":"hs","prompt":"--اضف رقمين x و y.--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =","canonical_solution":"add :: Int -> Int -> Int\nadd x y = x + y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_54","nl":"ajp_Arab","pl":"hs","prompt":"--شوف اذا كلمتين عندهم نفس الحروف.--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =","canonical_solution":"import Data.List (nub, sort)\n\nsameChars :: String -> String -> Bool\nsameChars s0 s1 = sort (nub s0) == sort (nub s1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_55","nl":"ajp_Arab","pl":"hs","prompt":"--ارجع رقم فيبوناتشي رقم n.--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =","canonical_solution":"fib :: Int -> Int\nfib n = fibHelper 0 1 n\n  where\n    fibHelper a _ 0 = a\n    fibHelper a b n = fibHelper b (a + b) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_56","nl":"ajp_Arab","pl":"hs","prompt":"--return صحيح اذا كل قوس افتتاح فيه قوس اغلاق متطابق.--\"قوسين\" هو سلسلة من \"<\" و \">\".--  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBrackets brackets 0 == 0\n\ncheckBrackets :: String -> Int -> Int\ncheckBrackets [] n = n\ncheckBrackets (x:xs) n\n  | n < 0 = -1\n  | x == '<' = checkBrackets xs (n + 1)\n  | x == '>' = checkBrackets xs (n - 1)\n  | otherwise = checkBrackets xs n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_57","nl":"ajp_Arab","pl":"hs","prompt":"--إسترد صحيح هو إن عناصر القائمة بتزايد أو بتقلص بشكل متواصل.--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =","canonical_solution":"monotonic :: [Int] -> Bool\nmonotonic l = increasing l || decreasing l\n  where\n    increasing xs = all (uncurry (<=)) (zip xs (tail xs))\n    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_58","nl":"ajp_Arab","pl":"hs","prompt":"--يرجع عناصر مشتركة فريدة من نوعها لليتين.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =","canonical_solution":"common :: [Int] -> [Int] -> [Int]\ncommon l1 l2 = uniqueSortedCommon\n  where\n    commonElements = filter (`elem` l2) l1\n    uniqueCommon = removeDuplicates commonElements\n    uniqueSortedCommon = sort uniqueCommon\n\n    removeDuplicates :: [Int] -> [Int]\n    removeDuplicates = foldr (\\x seen -> if x `elem` seen then seen else x : seen) []\n\n    sort :: [Int] -> [Int]\n    sort [] = []\n    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)\n      where\n        lesser  = filter (< p) xs\n        greater = filter (>= p) xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_59","nl":"ajp_Arab","pl":"hs","prompt":"--رد أكبر عامل أولي لـ n. افترض إن n > 1 و مش أولي.--  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =","canonical_solution":"largestPrimeFactor :: Int -> Int\nlargestPrimeFactor n = helper n 2\n  where\n    helper n factor\n      | factor * factor > n = n\n      | n `mod` factor == 0 = helper (n `div` factor) factor\n      | otherwise = helper n (factor + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_60","nl":"ajp_Arab","pl":"hs","prompt":"--sum_to_n هي دالة بتجمع الأرقام من 1 لـ n.--  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =","canonical_solution":"sumToN :: Int -> Int\nsumToN n = sum [1..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_61","nl":"ajp_Arab","pl":"hs","prompt":"--return صحيح اذا كل قوس افتتاح فيه قوس اغلاق متطابق.--\"برانتس\" هو سلسلة من \"(\" و \"\")--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBalance brackets 0\n  where\n    checkBalance [] 0 = True\n    checkBalance [] _ = False\n    checkBalance (x:xs) n\n      | x == '('  = checkBalance xs (n + 1)\n      | x == ')' && n > 0 = checkBalance xs (n - 1)\n      | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_62","nl":"ajp_Arab","pl":"hs","prompt":"--ارجع مشتقة من هذا الكثيمي بنفس الشكل.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --xs يمثل معاملات كتير الحدود.--  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =","canonical_solution":"derivative :: [Int] -> [Int]\nderivative xs = zipWith (*) (tail xs) [1..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_63","nl":"ajp_Arab","pl":"hs","prompt":"--لو سمحت اكتب دالة لحساب العنصر الـ ن من تسلسل الأرقام فيب فيب بكفاءة.--fibfib{n} == fibfib{n-1} + fibfib{n-2} + fibfib{n-3}--fibfib(2) == 1 --fibfib ((1) == 0 --fibfib(0) == 0 --تسلسل الأرقام فيب فيب هو تسلسل مشابه لسلسلة فيبوناتشي واللي يعرف على النحو التالي:--  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =","canonical_solution":"fibfib :: Int -> Int\nfibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibs !! n\n  where\n    fibs = 0 : 0 : 1 : zipWith3 (\\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_64","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--حرف صوتي، بس بس لما يكون في نهاية الكلمة المعطية.--في الحالة دي، الحروف الصوتية هي \"أ\" و \"إي\" و \"آي\" و \"أو\" و \"يو\" وهنا، \"ي\" هي كمان \"أ\"--كلمة كمدخل ويعيد عدد الحروف العلوية في السلسلة.--اكتب دالة vowels_count بتأخذ سلسلة تمثل--  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =","canonical_solution":"vowelsCount :: String -> Int\nvowelsCount s = length $ filter isVowel $ zip s [1..]\n  where\n    isVowel (c, pos) =\n      let lowercaseC = toLower c\n          isRegularVowel = lowercaseC `elem` \"aeiou\"\n          isLastCharY = lowercaseC == 'y' && pos == length s\n      in isRegularVowel || isLastCharY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_65","nl":"ajp_Arab","pl":"hs","prompt":"--اذا التحول > عدد الارقام، ارقام العودة عكسها.--ويرجع النتيجة كسلسلة.----حرك رقم العدد الصحيح x بدور، حرك رقم العدد الصحيح بدور.--  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =","canonical_solution":"circularShift :: Int -> Int -> String\ncircularShift x shift =\n  let digits = show x\n      len = length digits\n      effectiveShift = shift `mod` len\n  in if shift > len\n     then reverse digits\n     else let (begin, end) = splitAt (len - effectiveShift) digits\n          in end ++ begin","tests":"\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_66","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--رموز ASCII.--اكتب دالة بتأخذ سلسلة كمدخل وتعيد مجموع الحروف العليا بس' --مهمة.--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =","canonical_solution":"digitsum :: String -> Int\ndigitsum s = sum $ map fromEnum $ filter isUpper s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_67","nl":"ajp_Arab","pl":"hs","prompt":"--للكسابل:--في السلة، ارجع رقم فواكه المانجو في السلة.--البرتقال والتفاح و عدد صحيح بيعبر عن العدد الكلي للفواكه --التفاح، البرتقال، و الفواكه المانجو. مع العدد اللي بيعبر عن العدد الكلي لـ--بتوزع في سلة فواكه بتحتوي على هذه السلة--في المهمه دي، راح تعطيك سلسلة تمثل عدد التفاح والبرتقال.--  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =","canonical_solution":"import Text.Read (readMaybe)\n\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n = n - totalApplesOranges\n  where\n    totalApplesOranges = sum $ map (readNumber . words) [\"apples\", \"oranges\"]\n    readNumber keyword = case dropWhile (not . (==\" \") . dropWhile (\/=' ')) $ words s of\n      [] -> 0\n      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_68","nl":"ajp_Arab","pl":"hs","prompt":"--مثال 1:--اذا ما في قيم زوجي او القائمة اللي اتعطيت فارغة، ارجع [].--العقدة المقطوعة لازم ترجع في قائمة، [smallest_value، فهرسها]، --اذا وجدت عدة عقد بنفس القيمة الزوجية الأصغر، ارجع العقدة اللي عندها أصغر مؤشر.--العقدة المقطوعة لازم تكون العقدة بأقل قيمة زوجية.--مهمتك هي ان تقطعي واحد من العقدة و ترجعيه.--\"بإعطاء قائمة تمثل فرع من شجرة فيها عقد عدد صحيح غير سلبي--  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =","canonical_solution":"pluck :: [Int] -> [Int]\npluck arr = case filter (\\(x, _) -> even x) (zip arr [0..]) of\n    [] -> []\n    evens -> let (value, index) = minimum evens in [value, index]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_69","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--اذا ما كانت القيمة موجودة، رح نرجع -1.--التردد للرقم الصحيح هو عدد المرات اللي بيبدو فيها في القائمة.--صفر، وله تردد أكبر من أو يساوي قيمة العدد الصحيح نفسه.--معطيك قائمة غير فارغة من الأعداد الصحيحة الإيجابية، ارجع أكبر عدد صحيح أكبر من --  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nsearch :: [Int] -> Int\nsearch lst = \n    let frequencies = map (\\g -> (head g, length g)) . group . sort $ lst\n        candidates = filter (\\(val, freq) -> freq >= val) frequencies\n    in case candidates of\n         [] -> -1\n         _  -> fst . maximum $ candidates","tests":"\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_70","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--بعدين اكبر عدد من الأعداد الصحيحة المتبقية، بعدين اقل، وهكذا.--التفرز الغريب، هو عندما تبدأ مع القيمة الدنيا، --مع قائمة من الأعداد الصحيحة، نعيد قائمة بأسلوب غريب.--  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =","canonical_solution":"strangeSortList :: [Int] -> [Int]\nstrangeSortList [] = []\nstrangeSortList lst = go (sort lst) True\n  where\n    go [] _ = []\n    go xs toggle\n      | toggle    = head xs : go (tail xs) False\n      | otherwise = last xs : go (init xs) True","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_71","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--من الجانب الثالث.--تلاتة جوانب بتكون مثلث صحيح لما تكون مجموع جانبين أكبر من أي واحد .--و إلا، رح يرجع -1 --المثلث مقرب ل2 نقاط عشرية اذا الجوانب الثلاثة بتشكل مثلث صحيح.--مع طول الجوانب الثلاثة للمثلث، احصل على مساحة--  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =","canonical_solution":"import Text.Printf (printf)\n\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c\n    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))\n    | otherwise = -1\n  where\n    s = (fromIntegral (a + b + c)) \/ 2\n    isValidTriangle x y z = x + y > z && x + z > y && y + z > x\n    roundToTwoDecimals x = read (printf \"%.2f\" x) :: Float","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_72","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--الجسم q رح يطير اذا كان متوازن (هوه قائمة بالندرومية) ومجموع عناصرها أقل من أو يساوي الحد الأقصى ممكن للوزن w.--اكتب دالة تعيد صح اذا جسم q رح يطير، و غلط اذا ما كان.--  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =","canonical_solution":"willItFly :: [Int] -> Int -> Bool\nwillItFly q w = isPalindrome q && sum q <= w\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome xs = xs == reverse xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_73","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--بتقرأ نفس الشي للوراء والعكس. في تغيير واحد، بتقدر تغير عنصر واحد لأي عنصر آخر.--لازم يتغير ليكون القائمة متكاملة.--معطياً قائمة arr من الأعداد الصحيحة، اعثر على الحد الأدنى من العناصر اللي--  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =","canonical_solution":"smallestChange :: [Int] -> Int\nsmallestChange arr = sum $ zipWith (\\x y -> if x \/= y then 1 else 0) arr (reverse arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_74","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة --اذا القوائم الاثنين عندهم نفس عدد الحروف، ارجع القائمة الاولى.--العدد الكلي للخطوط في كل السلاسل في القائمة أقل من القائمة الأخرى.--اكتب دالة تقبل قائمتين من السلاسل وتعيد القائمة اللي فيها--  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =","canonical_solution":"totalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2\n  | totalChars lst1 < totalChars lst2 = lst1\n  | totalChars lst1 > totalChars lst2 = lst2\n  | otherwise = lst1\n  where\n    totalChars = sum . map length","tests":"\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_75","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--مع العلم ان (أ) اقل من 100.--و غير كاذب.--كتب دالة بترد صح إذا الرقم المعطى ضرب 3 أرقام أولية.--  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =","canonical_solution":"isMultiplyPrime :: Int -> Bool\nisMultiplyPrime a = any isTriplePrimeProduct primeTriples\n  where\n    primes = filter isPrime [2..99]\n    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]\n    isTriplePrimeProduct (x, y, z) = x * y * z == a\n\nisPrime :: Int -> Bool\nisPrime n \n  | n < 2     = False\n  | otherwise = not (any (\\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_76","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--x هي قوة بسيطة لـ n اذا n**int=x --قوة n و غلط في الحالات التانية.--مهمتك هي تكتب دالة ترجع true اذا الرقم x هو عدد بسيط--  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =","canonical_solution":"isSimplePower :: Int -> Int -> Bool\nisSimplePower x n\n  | x < 1 || n < 1 = False\n  | n == 1 = x == 1\n  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_77","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--ملاحظة: ممكن تتخيل ان المدخلات صالحة دائماً.--اذا كان هذا انجيجر مكعب لعدد صحيح.--اكتب دالة بتأخذ عدد صحيح a وترد True.--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =","canonical_solution":"iscube :: Int -> Bool\niscube a = let n = round (fromIntegral a ** (1\/3)) in n^3 == a","tests":"\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_78","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--و الرموز أ، ب، ج، د، إي، ف دائماً بحروف كبيرة.--ملاحظة: ممكن تتخيل ان الدخل صحيح او عبارة عن سلسلة فارغة،--ب (= عشري 11) ، د (= عشري 13).--لازم تحدد عدد من الرقمين التاليين: 2، 3، 5، 7، --الأعداد الأولية هي 2، 3، 5، 7، 11، 13، 17، ...--الرقم السداس عشري هو 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، أ، ب، ج، د، إي، ف.--اكبر من 1 اللي مش ضرب لعددين أصغر من الأعداد الطبيعية).--الأرقام اللي هي أرقام أولية (عدد أول، أو أرقام أولية، هو رقم طبيعي --رقم عشري عشري كسلسلة ويحسب عدد عشري عشري --انت بتتولى تكتب دالة بتستلم--  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =","canonical_solution":"hexKey :: String -> Int\nhexKey num = length . filter (`elem` primeHexDigits) $ num\n  where\n    primeHexDigits = \"2357BD\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_79","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--الحروف الإضافية موجودة عشان تساعد في التنسيق.--راح يكون هناك زوجين إضافيين من الأحرف \"db\" في بداية و نهاية السلسلة.--كل حرف في السلسلة هيكون \"0\" أو \"1\".--الشكل الثنائي. المهام لازم ترجع سلسلة، مع كل حرف يمثل ثنائي --رح تعطيك رقم على شكل عشري و مهمتك هي تحويله لـ--  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =","canonical_solution":"decimalToBinary :: Int -> String\ndecimalToBinary decimal = \"db\" ++ toBinary decimal ++ \"db\"\n  where\n    toBinary 0 = \"0\"\n    toBinary n = reverse (binaryHelper n)\n\n    binaryHelper 0 = \"\"\n    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_80","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--السلسلة هي هف إذا طولها 3 على الأقل وكل 3 حروف متتالية مميزة --مهمتك هي تتحقق اذا السلسلة هي haphs او لا.--بتعطيك سلسلة اس.--  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =","canonical_solution":"isHappy :: String -> Bool\nisHappy s\n  | length s < 3 = False\n  | otherwise = all distinctTriples (windows 3 s)\n  where\n    distinctTriples [x, y, z] = x \/= y && y \/= z && x \/= z\n    distinctTriples _ = False\n    windows n xs\n      | length xs < n = []\n      | otherwise = take n xs : windows n (tail xs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_81","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--0.0 E --> 0.0 D- --> 0.7 D --> 1.0 د+ --> 1.3 C- --> 1.7 درجة مئوية --> 2.0 C+ --> 2.3 بي- --> 2.7 ب--> 3.0 بي+ --> 3.3 أ- --> 3.7 أ--4.0 A+ --متوسط المعدل. درجة الحروف.--دالة بتقدر تصدر قائمة من درجات الحروف باستخدام الجدول التالي: --هي عطتك لائحة معدل معدل بعض الطلاب و لازم تكتب .--المشكلة الوحيدة هي، هي ضاعت الشفرة اللي كانت بتستخدمها للدرجات.--المعلم عمل خوارزمية خاصة به للتقييم.--هوه الاسبوع الاخير من الفصل الدراسي والمعلم لازم يعطي الدرجات--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =","canonical_solution":"numericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades = map gpaToLetterGrade grades\n  where\n    gpaToLetterGrade gpa\n      | gpa == 4.0 = \"A+\"\n      | gpa > 3.7  = \"A\"\n      | gpa > 3.3  = \"A-\"\n      | gpa > 3.0  = \"B+\"\n      | gpa > 2.7  = \"B\"\n      | gpa > 2.3  = \"B-\"\n      | gpa > 2.0  = \"C+\"\n      | gpa > 1.7  = \"C\"\n      | gpa > 1.3  = \"C-\"\n      | gpa > 1.0  = \"D+\"\n      | gpa > 0.7  = \"D\"\n      | gpa > 0.0  = \"D-\"\n      | otherwise  = \"E\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_82","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة --length هو رقم أولي أو غلط وإلا --اكتب دالة بتأخذ سلسلة وترجع صح اذا السلسلة--  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =","canonical_solution":"primeLength :: String -> Bool\nprimeLength string = isPrime (length string)\n\nisPrime :: Int -> Bool\nisPrime n\n  | n < 2     = False\n  | n == 2    = True\n  | even n    = False\n  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_83","nl":"ajp_Arab","pl":"hs","prompt":"--الأعداد الصحيحة الإيجابية اللي بتبدأ أو تنتهي بـ 1.--مع عدد صحيح موجب n، ارجع عدد الأرقام من رقم n.startsOneEnds :: Int -> Int\nstartsOneEnds n =","canonical_solution":"startsOneEnds :: Int -> Int\nstartsOneEnds n\n  | n <= 0    = 0\n  | n == 1    = 1\n  | otherwise = 18 * 10^(n-2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_84","nl":"ajp_Arab","pl":"hs","prompt":"--مثال --مع عدد صحيح موجب N، ارجع مجموع رقميه بالبائنري.--  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 ≤ N ≤ 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =","canonical_solution":"solve :: Int -> String\nsolve N = toBinary (sumOfDigits N)\n  where\n    sumOfDigits 0 = 0\n    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)\n\n    toBinary 0 = \"0\"\n    toBinary n = reverse (toBinary' n)\n      where\n        toBinary' 0 = \"\"\n        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_85","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--مع وجود قائمة غير فارغة من الأعداد الصحيحة، بداية اضف العناصر الزوجية اللي عند المؤشرات الغريبة.--  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =","canonical_solution":"add :: [Int] -> Int\nadd lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_86","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--ملاحظة: لازم تحافظ على ترتيب الكلمات والمساحات الفارغة في الجملة.--ترتيب تصاعدي بناء على قيمة ascii.--بتتبدل بكلمة جديدة حيث كل الحروف مرتبة في --النسخة المترتبة من السلسلة، هي سلاسل فيها كل الكلمات (مفصولة بالفراغ) --اكتب دالة بتأخذ سلسلة وترجع نسخة مرتبة منها.--  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =","canonical_solution":"import Data.List (sort)\nimport Data.Char (isAlpha)\n\nantiShuffle :: String -> String\nantiShuffle s = unwords $ map sortWord (wordsAndSpaces s)\n  where\n    sortWord word = if all isAlpha word then sort word else word\n    wordsAndSpaces [] = []\n    wordsAndSpaces xs = if head xs == ' ' \n                        then \" \" : wordsAndSpaces (dropWhile (== ' ') xs)\n                        else let (word, rest) = break (== ' ') xs\n                             in word : wordsAndSpaces rest","tests":"\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_87","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--وبالإضافة، رتبوا إحداثيات الصف حسب الأعمدة بالترتيب الهابط.--ترتيب الإحداثيات في البداية بالصفوف بالترتيب المتصاعد.--كل توبل هو إحداثي - (صف، عمود) ، بداية من 0.--ويعيد قائمة من التوبلات، [(x1، y1، (x2، y2) ...] بحيث --مع إعطاء lst، وعدد صحيح x، اعثر على عدد صحيح x في القائمة، --كل صف ممكن يحتوي على عدد مختلف من الأعمدة.--اللي شبه المصفوفة، بس، على عكس المصفوفات،--بتعطيك بيانات ثنائية الأبعاد، على شكل قوائم محشورة،--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =","canonical_solution":"getRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x = concatMap processRow (zip [0..] lst)\n  where\n    processRow (rowIndex, row) = \n      let colIndices = reverse $ findIndices (== x) row\n      in [(rowIndex, colIndex) | colIndex <- colIndices]\n\nfindIndices :: (a -> Bool) -> [a] -> [Int]\nfindIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_88","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--* ما تغيرلي القائمة اللي اتعطيتني .--ملاحظة:--أو رتبها بترتيب نزولي إذا كان مجموع ((قيمة المؤشر الأولى، قيمة المؤشر الأخيرة) زوج.--رح تصنف القائمة المعطاة بالترتيب الصاعد اذا كان مجموع ((قيمة المؤشر الاول، القيمة المؤشر الاخيرة) غريب، --مع قائمة من الأعداد الصحيحة غير السالبة، ارجع a cohs من القائمة اللي اتعطيت بعد الترتيب،--  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =","canonical_solution":"sortArray :: [Int] -> [Int]\nsortArray array\n  | null array = array\n  | otherwise =\n    let first = head array\n        last = last array\n        sumFirstLast = first + last\n    in if odd sumFirstLast\n       then sort array\n       else reverse (sort array)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_89","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--زحف للاسفل بمرتين ضربين لمكانين.--لازم يدور الأبجدية بطريقة بحيث الحروف --بيرد سلسلة مشفرة مع تدوير الأبجدية.--احضر وظيفة تشفير بتأخذ سلسلة كحجة و--  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =","canonical_solution":"encrypt :: String -> String\nencrypt s = map shiftChar s\n  where\n    shiftChar c\n      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')\n      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_90","nl":"ajp_Arab","pl":"hs","prompt":"--رد لا شيء اذا ما كان هناك عنصر.--اكتب دالة next_smallest ({\\displaystyle next_smallest}) اللي بترد اقل عنصر ثان في القائمة.--بتعطيك قائمة من الأعداد الصحيحة.--  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =","canonical_solution":"nextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =\n  let uniqueSorted = removeDuplicates $ quicksort lst\n  in if length uniqueSorted < 2\n     then Nothing\n     else Just (uniqueSorted !! 1)\n\nremoveDuplicates :: (Ord a) => [a] -> [a]\nremoveDuplicates = foldr (\\x acc -> if x `elem` acc then acc else x : acc) []\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_91","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--الجمل بيتم تقسيمها بواسطة \"\"، \"؟\" أو \"!\"--الملل هو جملة تبدأ بكلمة \"أنا\".--راح تعطيك سلسلة كلمات، ومهمتك هي تعدي الرقم.--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =","canonical_solution":"isBored :: String -> Int\nisBored s = length $ filter (startsWithI . words) $ splitSentences s\n  where\n    splitSentences :: String -> [String]\n    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters \".?!\"\n    \n    splitOnDelimiters :: String -> String -> [String]\n    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of\n      \"\" -> []\n      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''\n    \n    startsWithI :: [String] -> Bool\n    startsWithI [] = False\n    startsWithI (x:_) = map toLower x == \"i\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_92","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة --بيرد غلط في أي حالات تانية.--بيرد صح إذا واحد من الأرقام يساوي مجموع الأرقام التانية، وكل الأرقام هي أرقام صحيحة.--احضر دالة بتأخذ 3 ارقام.--  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =","canonical_solution":"anyInt :: Float -> Float -> Float -> Bool\nanyInt x y z\n  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =\n      x == y + z || y == x + z || z == x + y\n  | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_93","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--بس خذ الحروف.--حرف صوتي في الأبجدية الإنجليزية.--الرسالة مع الحرف اللي بيظهر مكانين قدامها .--طريقة بتبديل الحروف، وتبديل كل الحروف الصوتية في --اكتب دالة بتأخذ رسالة، وتقوم بتشفيرها في مثل هذه الطريقة.--  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =","canonical_solution":"encode :: String -> String\nencode = map transformChar\n  where\n    transformChar :: Char -> Char\n    transformChar c\n      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c\n      | otherwise      = swapCase c c\n      where\n        lowerC = toLower c\n\n    isVowel :: Char -> Bool\n    isVowel c = c `elem` \"aeiou\"\n\n    swapCase :: Char -> Char -> Char\n    swapCase origC c\n      | isUpper origC = toLower c\n      | otherwise     = toUpper c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_94","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--لازم تلاقي أكبر قيمة أولية وترد مجموع أرقامها.--بتعطيك قائمة من الأعداد الصحيحة.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =","canonical_solution":"skjkasdkd :: [Int] -> Int\nskjkasdkd lst = sumDigits (largestPrime lst)\n\n-- Function to check if a number is prime\nisPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]\n\n-- Integer square root using binary search, O(log n)\nisqrt :: Int -> Int\nisqrt n = floor . sqrt $ fromIntegral n\n\n-- Function to find the largest prime in the list\nlargestPrime :: [Int] -> Int\nlargestPrime = foldr (\\x acc -> if isPrime x && x > acc then x else acc) 0\n\n-- Function to calculate the sum of the digits of a number\nsumDigits :: Int -> Int\nsumDigits 0 = 0\nsumDigits n = n `mod` 10 + sumDigits (n `div` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_95","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--المفروض ان الدالة ترجع غلط اذا القائمة المعطاة فارغة.--الحرف الكبير او كل المفاتيح سلسلة بحرف كبير، والا رح نرجع false.--مع وجود قائمة ارتباط، ارجع True اذا كل المفاتيح سلسلة في الاسفل--  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =","canonical_solution":"import Data.Char (isUpper, isLower)\n\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase [] = False\ncheckDictCase dict = all isLower allKeys || all isUpper allKeys\n  where\n    allKeys = concatMap fst dict","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_96","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً: --عدد صحيح هو عدد أولي وأقل من n.--باش نطبق دالة بتأخذ عدد صحيح غير سلبي وتعيد قائمة بأول n --  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =","canonical_solution":"countUpTo :: Int -> [Int]\ncountUpTo n = filter isPrime [2..n-1]\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_97","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--افترض ان المدخلات صالحة دائماً.--ضرب أرقام وحداتهم.--أكمل الدالة اللي بتأخذ رقمين صحيحين و ترجع--  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =","canonical_solution":"multiply :: Int -> Int -> Int\nmultiply a b = (abs a `mod` 10) * (abs b `mod` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_98","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--نظراً لسلسلة \"س\"، احسب عدد الحروف العلوية الكبيرة في الحروف الزوجية.--  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =","canonical_solution":"countUpper :: String -> Int\ncountUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` \"AEIOU\"]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_99","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة --من رقمين صحيحين، اقربها عن الصفر.--ويعيد اقرب عدد صحيح له. اذا الرقم مساوي.--اختر وظيفة بتأخذ قيمة (سلسلة) تمثل رقم.--  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =","canonical_solution":"closestInteger :: String -> Int\nclosestInteger value = \n  let n = read value :: Double\n  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_100","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--i يمثل عدد الحجارة في المستوى (i+1).--يعيد عدد الحجارة في كل مستوى في قائمة، حيث عنصر في مؤشر --- الرقم الزوج التالي اذا n زوجي.--- الرقم الغريب التالي اذا n غريبي.--عدد الحجارة في المستوى التالي هو:--المستوى الأول عنده n حجر.--مع عدد صحيح موجب n، لازم تعمل كومة من n مستويات من الحجارة.--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =","canonical_solution":"makeAPile :: Int -> [Int]\nmakeAPile n = take n [n, n + 2 ..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_101","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--ليقسم السلسلة للكلمات ويرجع قائمة الكلمات.--راح تعطيك سلسلة كلمات مفصولة بالفواصل او المسافات. مهمتك هي--  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =","canonical_solution":"wordsString :: String -> [String]\nwordsString s = words $ map (\\c -> if c == ',' then ' ' else c) s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_102","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--ما في رقم من هذا القبيل، اذاً الميزة لازم ترجع -1--أكبر عدد صحيح زوجي موجود في النطاق [x، y] شامل. اذا --هاي الدالة بتأخذ رقمين موجبين x و y و بتعيد--  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =","canonical_solution":"chooseNum :: Int -> Int -> Int\nchooseNum x y\n    | x > y = -1\n    | even upperBound = upperBound\n    | even (upperBound - 1) = upperBound - 1\n    | otherwise = -1\n  where\n    upperBound = max x y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_104","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--ملاحظة: القائمة اللي رجعت لازم تصنف بالترتيب المتزايد.--العناصر اللي ما بيها رقم زوج.--مع قائمة من الأعداد الصحيحة الإيجابية x، ارجع قائمة مرتبة من كل الأعداد الصحيحة الإيجابية--  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =","canonical_solution":"uniqueDigits :: [Int] -> [Int]\nuniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_105","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--واحد، اثنين، ثلاثة، أربعة، خمسة، ستة، سبعة، ثمانية، تسعة.--عكس القائمة الناتجة، وبعدين بديل كل رقم باسمها المقابل من --مع قائمة من الأعداد الصحيحة، رتب الأعداد الصحيحة اللي بين 1 و 9،--  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the list is empty, return an empty list:\n--  >>> byLength []\n--  []\n--  If the list has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =","canonical_solution":"byLength :: [Int] -> [String]\nbyLength arr = map digitName . reverse . sort . filter isValid $ arr\n  where\n    isValid x = x >= 1 && x <= 9\n    digitName x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"\n      _ -> error \"Unexpected number\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_106","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--عامل i هو ضرب الأرقام من 1 إلى i (1 * 2 * ... * i).--أنا بيبدأ من واحد.--أو مجموع الأرقام من 1 إلى i.--ويعيد قائمة بحجم n، بحيث تكون قيمة العنصر في المؤشر i هي عامل i اذا كان i زوجي --نطبق الدالة f اللي بتأخذ n كمعلم،--  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =","canonical_solution":"f :: Int -> [Int]\nf n = map g [1..n]\n  where\n    g i\n      | even i    = factorial i\n      | otherwise = sum [1..i]\n    \n    factorial 0 = 1\n    factorial m = product [1..m]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_107","nl":"ajp_Arab","pl":"hs","prompt":"--مثال 1:--باليندرومات عدد صحيح اللي بتقع ضمن النطاق ((1، ن) ، متضمنة.--مع عدد صحيح موجب n، ارجع توبل بيكون فيه عدد الزوج والغريب.--  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =","canonical_solution":"evenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n = (length evens, length odds)\n  where\n    isPalindrome x = show x == reverse (show x)\n    palindromes = filter isPalindrome [1..n]\n    evens = filter even palindromes\n    odds  = filter odd palindromes","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_108","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً، -123 عنده أرقام -1, 2 و 3.--إذا الرقم سالب، فبعدين رقم التوقيع الأول سيكون سالب: --عدد العناصر اللي مجموع الرقمين فيها اكبر من صفر.--اكتب دالة count_nums بتأخذ قائمة من الأعداد الصحيحة وتعود--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =","canonical_solution":"countNums :: [Int] -> Int\ncountNums arr = length $ filter ((> 0) . sumDigits) arr\n  where\n    sumDigits 0 = 0\n    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)\n                  in sum digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_109","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--ملاحظة: اللي في القائمة اللي اتعطيت تضمن وجود عناصر فريدة.--اذا القائمة اللي اتعطيت فارغة، رح نرجع True.--بعدين ارجع صحيح، بعدين ارجع غلط.--اذا كان ممكن نلقى القائمة المصنفة عن طريق عمل العملية اللي فوق --الموقع الأولي في القائمة، يعني المؤشر رقم صفر.--آخر عنصر في القائمة رح يتنقل ل --عملية نقل واحد لليمان تعني نقل كل عناصر القائمة واحد .--بتقدر تعمل عملية التحول لليمان أي عدد من المرات.--العملية التالية في القائمة اللي اتعطيت:--ممكن نحصل على ترتيب قائمة بأسلوب غير متناقص عن طريق عمل --الرقم في القائمة رح يكون مرتب بشكل عشوائي. مهمتك هي تحديد اذا --عنا قائمة 'arr' من N عدد صحيح arr[1], arr[2]، ..., arr[N].--  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given list.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  list by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =","canonical_solution":"moveOneBall :: [Int] -> Bool\nmoveOneBall [] = True\nmoveOneBall arr = canBeSorted (arr ++ arr)\n  where\n    n = length arr\n    canBeSorted xs = any isSorted (take n <$> tails xs)\n    isSorted ys = and $ zipWith (<=) ys (tail ys)\n    tails [] = []\n    tails l@(_:xs) = l : tails xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_110","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--و إلا، ارجع \"لا\".--كل عناصر lst1 تكون زوجية، ارجع \"نعم\".--اذا كان ممكن تبادل عناصر بين lst1 و lst2 ليعملوا--ما في حد على عدد العناصر المتبادلة بين lst1 و lst2.--بينهم لنجعل lst1 قائمة من الأرقام الزوجية فقط.--ويحدد اذا كان ممكن ان يقوموا بتبادل العناصر --في المشكلة، رح نطبق دالة بتأخذ قائمتين من الأرقام،--  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =","canonical_solution":"exchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | all even lst1 = \"YES\"\n  | null oddLst1 || null evenLst2 = \"NO\"\n  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)\n                in if possibility then \"YES\" else \"NO\"\n  where\n    oddLst1 = filter odd lst1\n    evenLst2 = filter even lst2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_111","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--اذا كان في عدة حروف نفس الحالة، ارجعهم كلهم.--من الحرف اللي اكتر تكرار ويحتوي على العدد المقابل.--مع وجود سلسلة تمثل حروف صغيرة منفصلة عن بعضها، ارجع قائمة ارتباطات.--  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nhistogram :: String -> [(String, Int)]\nhistogram input =\n  let wordsList = words input\n      grouped = group $ sort wordsList\n      countList = map (\\ws -> (head ws, length ws)) grouped\n      maxCount = if null countList then 0 else maximum $ map snd countList\n  in filter ((== maxCount) . snd) countList","tests":"\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_112","nl":"ajp_Arab","pl":"hs","prompt":"--مثال --لازم ترجع توبل يحتوي على سلسلة النتيجة و صحيح\/كذب للتحقق.--السلسلة تسمى بالندروم اذا كانت بتقرأ نفس القراءة للوراء والامام.--بعدين شوف اذا السلسلة الناتجة هي بالندروم.--عنا سلاسل اس و سي، لازم نحذف كل الحروف في اس اللي مساوية لأي حرف في سي--مهمة.--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =","canonical_solution":"import Data.List (filter)\n\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =\n  let result = filter (`notElem` c) s\n  in (result, result == reverse result)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_113","nl":"ajp_Arab","pl":"hs","prompt":"--في رقمين غير فردين في السلسلة الـ i'th للدخل.--السلسلة i من المدخل. \" حيث كل الـ i's لازم يبدلوا بالعدد --كل عنصر i من الناتج لازم يكون \"عدد العناصر الغريبة في --مع وجود قائمة من السلاسل، حيث كل سلاسل بتتكون من أرقام فقط، ارجع قائمة.--  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =","canonical_solution":"oddCount :: [String] -> [String]\noddCount lst = map formatString lst\n  where\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"\n\n    countOdds :: String -> Int\n    countOdds str = length $ filter isOddDigit str\n\n    formatString :: String -> String\n    formatString str =\n      let oddCount = countOdds str in\n      \"the number of odd elements \" ++ show oddCount ++ \n      \"n the str\" ++ show oddCount ++ \"ng \" ++ show oddCount ++\n      \" of the \" ++ show oddCount ++ \"nput.\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_114","nl":"ajp_Arab","pl":"hs","prompt":"--مثال --من العدد.--معطياً قائمة من الأعداد الصحيحة، اعثر على الحد الأدنى من مجموع أي قائمة فرعية غير فارغة.--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =","canonical_solution":"minsubarraysum :: [Int] -> Int\nminsubarraysum nums = minimum $ scanl1 (\\acc x -> min x (acc + x)) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_115","nl":"ajp_Arab","pl":"hs","prompt":"--مثال 1:--اكتب عدد المرات اللي بدك تنزل الدلو.--مهمتك هي استخدم الدلوين لتفريغ البئر.--وكل الدلوين عندهم نفس القدرة.--كل بئر عنده دلو متوافق يقدر يستخدم ليحصل منه على المياه،--وكل واحد في الصف بيعبر عن وحدة واحدة من الماء.--بتعطيك شبكة مستطيلة من الآبار. كل صف يمثل بئر واحد،--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =","canonical_solution":"maxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity = ceiling (fromIntegral totalWater \/ fromIntegral capacity)\n  where\n    totalWater = sum (map sum grid)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_116","nl":"ajp_Arab","pl":"hs","prompt":"--لازم يتعمل هيك:--لعدد مماثل من الأحاد، رتب بناءً على القيمة العشرية.--عدد الأحاديات في التمثيل الثنائي بالترتيب الصاعد.--في الكاتا، لازم نحدد قائمة بالأعداد الصحيحة غير السالبة حسب--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =","canonical_solution":"import Data.Bits (popCount)\nimport Data.List (sortBy)\n\nsortArray :: [Int] -> [Int]\nsortArray arr = sortBy compareOnesAndValues arr\n  where\n    compareOnesAndValues x y =\n      let onesX = popCount x\n          onesY = popCount y\n      in if onesX == onesY\n         then compare x y\n         else compare onesX onesY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_117","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--ملاحظة: ممكن تتخيل ان السلسلة اللي بتدخل فيها حروف وفراغات بس.--اذا السلسلة s فارغة، اذا الميزة لازم ترجع قائمة فارغة.--n كلمات مصممة، بالترتيب اللي بتظهر فيه الكلمات في السلسلة s.--دالة بترد قائمة بكلمات من السلسلة s اللي فيها بالضبط --مع وجود سلسلة اس و رقم طبيعي ن، انت بتتولى تنفيذ--  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =","canonical_solution":"selectWords :: String -> Int -> [String]\nselectWords s n = filter (\\word -> countConsonants word == n) (words s)\n  where\n    countConsonants = length . filter (`elem` consonants)\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_118","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--ممكن تتخيل ان السلسلة اللي اتعطيت فيها حروف انجليزية بس.--شوف أي حرف عادي يوافق الشرط اللي فوق.--الصفوف في البداية والنهاية ما بتحسبش. رجع السلسلة الفارغة اذا ما كان عندك.--حرفين من جهة اليمين من الكلمة (حساس لحالة الكبير والكبير).--بتعطيك كلمة. مهمتك هي ان تجد اقرب حرف متناوب بينها.--  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =","canonical_solution":"getClosestVowel :: String -> String\ngetClosestVowel word = go (reverse word) False\n  where\n    vowels = \"aeiouAEIOU\"\n    go [] _ = \"\"\n    go (x:xs) lastWasConsonant\n      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False\n      | x `notElem` vowels = go xs True\n      | otherwise = go xs False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_119","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--ارجع \"نعم\" اذا كان هناك طريقة لتصنع سلسلة جيدة، ورجع \"لا\" اذا كان غير كده.--\"()) \" مش موجود.--مثلًا: السلسلة '(((() ' كويسة، بينما السلسلة --سلاسل S يعتبر جيد اذا و فقط اذا كل قوسين في S --في بعض الاوامر، ان السلسلة الناتجة ستكون جيدة.--شغلك هو تتحقق لو ممكن تربط السلاسل في .--بس البارنتيز \"(\" او البارنتيز الاخرى \") \".--بتعطيك قائمة من سلسلتين، كلتا السلاسل بتتكون من مفتوحة.--  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =","canonical_solution":"matchParens :: [String] -> String\nmatchParens [a, b] =\n    if isValid (a ++ b) || isValid (b ++ a) then \"Yes\" else \"No\"\n  where\n    isValid :: String -> Bool\n    isValid = go 0\n      where\n        go 0 [] = True\n        go _ [] = False\n        go n (x:xs)\n            | x == '('  = go (n + 1) xs\n            | x == ')'  = n > 0 && go (n - 1) xs\n    isValid _ = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_120","nl":"ajp_Arab","pl":"hs","prompt":"--مثال 1:--من طول ك مع اكبر عدد ك في ارررررررررررررررررررررررررررررررررررر--مع وجود قائمة arr من الأعداد الصحيحة و k من الأعداد الصحيحة الإيجابية، ارجع قائمة مرتبة.--  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the list will be in the range of [1, 1000].\n--  2. The elements in the list will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =","canonical_solution":"maximum :: [Int] -> Int -> [Int]\nmaximum arr k = take k $ reverse $ sort arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_121","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة --مع وجود قائمة غير فارغة من الأعداد الصحيحة، ارجع مجموع كل العناصر الغريبة اللي في مواقع زوجية.--  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =","canonical_solution":"solution :: [Int] -> Int\nsolution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_122","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--مجموع العناصر اللي فيها رقمين على الأكثر من العناصر الكل الأولين من arr.--مع وجود قائمة غير فارغة من الأعداد الصحيحة arr و k، ارجع--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =","canonical_solution":"addElements :: [Int] -> Int -> Int\naddElements arr k = sum $ filter (\\x -> x >= -99 && x <= 99) $ take k arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_123","nl":"ajp_Arab","pl":"hs","prompt":"--get_odd_collatz(5) يرجع [1, 5] # تسلسل كولاتز لـ 5 هو [5, 16, 8, 4, 2, 1], عشان كده الأعداد الغريبة هي 1 و 5 بس. --مثلاً:--2. القائمة المرجعة مرتبة بترتيب متزايد.--1. كولاتز ((1) هو [1].--ملاحظة:--المفترض هو إنه مهما كانت قيمة n، التسلسل دايماً بيوصل لـ1.--اذا العبارة السابقة غريبة، العبارة الجاية هي 3 مرات العبارة السابقة--العبارة السابقة على النحو التالي: اذا العبارة السابقة زوجية، العبارة الجاية هي نص --زي ما يلي: ابدأ بأي عدد صحيح موجب n. بعدين كل مصطلح يحصل من --تخمين كولاتز هو تخمين في الرياضيات اللي بيحتوي على تسلسل محدد --مع عدد صحيح موجب n، ارجع قائمة مرتبة فيها الأرقام الغير متساوية في تسلسل كولاتز.--  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =","canonical_solution":"getOddCollatz :: Int -> [Int]\ngetOddCollatz n = sort . filter odd $ collatzSequence n\n  where\n    collatzSequence 1 = [1]\n    collatzSequence x\n      | even x    = x : collatzSequence (x `div` 2)\n      | otherwise = x : collatzSequence (3 * x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_124","nl":"ajp_Arab","pl":"hs","prompt":"--التاريخ لازم يكون على الشكل: مم-د-م-م-م --الشهور ما لازم تكون أقل من شهر أو اكبر من 12 شهر.--عدد الأيام ما يكون أقل من واحد أو أكبر من 31 يوم لشهر واحد، ثلاثة، خمسة، سبعة، ثمانية، عشر، و12، وعدد الأيام ما يكون أقل من واحد أو أكبر من 30 يوم لشهر أربعة، ستة، تسعة و11، وعدد الأيام ما يكون أقل من واحد أو أكبر من 29 يوم للشهر 2.--1. السلسلة التاريخ مش فارغة.--التاريخ صالح اذا كل القواعد التالية بتتوافق: --يرجع صح إذا التاريخ صحيح وإلا غلط.--لازم تكتب دالة بتحقق من صحة سلسلة تاريخ معينة و--  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06\/04\/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =","canonical_solution":"import Text.Read (readMaybe)\nimport Data.List.Split (splitOn)\n\nvalidDate :: String -> Bool\nvalidDate date =\n    case splitOn \"-\" date of\n        [m, d, y] -> isValidMonthDayYear m d y\n        _         -> False\n\nisValidMonthDayYear :: String -> String -> String -> Bool\nisValidMonthDayYear m d y =\n    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of\n        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day\n        _ -> False\n\nisValidMonth :: Int -> Bool\nisValidMonth month = month >= 1 && month <= 12\n\nisValidDay :: Int -> Int -> Bool\nisValidDay month day\n    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31\n    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30\n    | month == 2                           = day >= 1 && day <= 29\n    | otherwise                            = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_126","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة --رقم، يرجع غلط. افترض انه ما في أرقام سالبة وبالكاد عدد صحيح.--في الترتيب الصاعد. لو في قائمة فيها اكثر من نسخة واحدة من نفس القائمة--مع قائمة أرقام، ارجع سواء تم ترتيبها أو لا.--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =","canonical_solution":"isSorted :: [Int] -> Bool\nisSorted lst = go lst Nothing\n  where\n    go [] _ = True\n    go [x] _ = True\n    go (x:y:xs) prev\n      | x > y = False\n      | x == y && prev == Just x = False\n      | otherwise = go (y:xs) (Just x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_127","nl":"ajp_Arab","pl":"hs","prompt":"--[المدخل\/المخرج] العينات: --اذا الفاصلين ما يتقاطعوا، ارجع \"لا\".--و إلا، ارجع \"لا\".--اذا طول التقاطع رقم أولي، ارجع \"نعم\"،--اللي طوله 1، اللي مش عدد أولي.--مثلاً، تقاطع الفراغات (1, 3) ، (2، 4) هو (2، 3) --الفاصل بينهما هو رقم أولي.--مهمتك هي تحديد طول تقاطع هذين الاثنين --لكل فترة معينة، من المفترض ان بدايتها هي اقل من أو تساوي نهايتها.--بتشمل بداية ونهاية.--الفترات المحددة مغلقة يعني ان الفترة (البداية، النهاية)--حيث كل فترة هي زوج من الأعداد الصحيحة. مثلاً، فترة = (بداية، نهاية) = (1, 2).--بتعطيك فترتين،--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =","canonical_solution":"intersection :: (Int, Int) -> (Int, Int) -> String\nintersection (start1, end1) (start2, end2) = \n    if intersectionLength > 0 && isPrime intersectionLength\n    then \"YES\"\n    else \"NO\"\n  where\n    intersectionStart = max start1 start2\n    intersectionEnd = min end1 end2\n    intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    isPrime :: Int -> Bool\n    isPrime n\n      | n <= 1 = False\n      | n == 2 = True\n      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_128","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--ملاحظة: رح يرجع لا شيء لـ arr فارغ.--كل رقم في القائمة، يمثله 1، -1 او 0--مجموع مقادير الأعداد الصحيحة مضروبة بإنتاج كل العلامات --بتعطيك قائمة من ارقام صحيحة و لازم ترجع--  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =","canonical_solution":"prodSigns :: [Int] -> Maybe Int\nprodSigns [] = Nothing\nprodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_129","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--بيرد قائمة مرتبة للقيم على الخلايا اللي طريق الحد الأدنى يمر من خلالها.--من الضمان ان الجواب فريد.--lst_A[j] = lst_B[j].--مثلًا lst_A[i] < lst_B[i] ولأي j (1 <= j <i) عندنا --من lst_B، بعبارة أخرى، هناك مؤشر عدد صحيح i (1 <= i <= k) --من خلال (لنتسمى بـ lst_A و lst_B) ، lst_A أقل من الناحية المفصومة--بعد ما عملنا القوائم المترتبة للقيم على الخلايا اللي أ و ب يروحوا--مسار A (طول k) يعتبر أصغر من مسار B (طول k) اذا --ما تقدرش تروح من الشبكة.--لازم يكونوا مختلفين).--لو سمحت لاحظ ان مسار طوله k يعني زيارة بالضبط k خلية (وليس ----بعبارة أخرى، بتقدر تروح للخلايا اللي بتشارك الحافة مع التيار.--من اي خلية، وفي كل خطوة بتقدر تنتقل لأي خلية مجاورة،--لازم تلاقي الحد الأدنى من المسار الطويل k في الشبكة.--شامل بيظهر مرة واحدة بالضبط على خلايا الشبكة.--كل خلية في الشبكة فيها قيمة. كل رقم صحيح في النطاق [1, N * N] --مع شبكة مع n صفوف و n عمود (ن >= 2) و عدد صحيح k موجب،--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =","canonical_solution":"import Data.List (sort, sortBy)\nimport Data.Ord (comparing)\nimport Control.Monad (guard)\n\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k = head $ sort paths\n  where\n    n = length grid\n    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]\n    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n      where\n        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n\n    value (r, c) = grid !! r !! c\n    paths = do\n      start <- cells\n      findPaths k [start]\n    findPaths 1 path = return $ map value path\n    findPaths l path@(current:_) = do\n      next <- neighbors current\n      findPaths (l-1) (next : path)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_130","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--أول عدد n+1 من تسلسل تريبوناتشي.--بتعطيك عدد صحيح غير سالب n، لازم ترجع قائمة من --= 2 + 3 + 3 = 8 --ثلاثي ((3) = ثلاثي ((2) + ثلاثي ((1) + ثلاثي ((4) --tri(4) = 3 --tri(2) = 1 + (2 \/ 2) = 2 --مثلاً:--tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), اذا n فريد. --tri (n) = 1 + n \/ 2، اذا n زوجي.--tri(1) = 3 --تسلسل تريبوناتشي محدد من خلال تكرار:--بالرغم من كده، اللي الناس ما بعرفوه هو تسلسل تريبوناتشي.--كل واحد يعرف تسلسل فيبوناتشي، تم دراسته بعمق من قبل علماء الرياضيات في--  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =","canonical_solution":"tri :: Int -> [Int]\ntri n = map tribonacci [0..n]\n  where\n    -- Define the recursive function to calculate the tribonacci value for a given n\n    tribonacci :: Int -> Int\n    tribonacci 0 = 1\n    tribonacci 1 = 3\n    tribonacci x\n      | even x    = 1 + x `div` 2\n      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_131","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--يرجع صفر اذا كل الرقمين زوجيين.--نظراً لعدد صحيح موجب n، ارجع ضرب الأرقام الغريبة.--  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =","canonical_solution":"digits :: Int -> Int\ndigits n\n  | null oddDigits = 0\n  | otherwise      = product oddDigits\n  where\n    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_132","nl":"ajp_Arab","pl":"hs","prompt":"--وين موجود واحد على الأقل من الأقواس في التسلسل الفرعي.--المفروض ان الدالة ترجع صحيح اذا و فقط اذا كان هناك تسلسل ثانوي صالح من القوسين --احضر دالة بتأخذ سلسلة كمدخلات بتحتوي فقط اقواس مربعة.--  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =","canonical_solution":"isNested :: String -> Bool\nisNested string = go string 0 False\n  where\n    go [] _ nested = nested\n    go (x:xs) depth nested\n      | x == '['  = go xs (depth + 1) (nested || depth >= 1)\n      | x == ']' && depth > 0 = go xs (depth - 1) nested\n      | otherwise = go xs depth nested","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_133","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--اقرب كل عنصر في القائمة لحد الارتفاع int ((السقف)) اولا.--لازم ترجع مجموع الأرقام المربعة في القائمة اللي اتعطيت، --بتعطيك قائمة أرقام.--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =","canonical_solution":"import Data.List (foldl')\nimport Prelude hiding (sum)\n\nsumSquares :: [Float] -> Int\nsumSquares lst = foldl' (\\acc x -> acc + ceiling x ^ 2) 0 lst","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_134","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--ملاحظة: \"كلمة\" هي مجموعة من الأحرف مفصولة بالفراغ.--جزء من كلمة، وكذب غير ذلك.--من سلسلة معينة هو حرف أبجدي و مش هو --احضر دالة ترجع صح اذا اخر حرف--  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =","canonical_solution":"checkIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt = \n    let trimmed = reverse . dropWhile (== ' ') $ reverse txt\n    in case trimmed of\n        [] -> False\n        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_135","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--القيم المكررة.--ما في عنصر من هذا القبيل، اذاً رح يرجع -1. القائمة اللي اتعطيت مش بتحتوي على --مش اكبر من أو يساوي العنصر اللي بسببه مباشرة. اذا --احضر دالة ترجع اكبر مؤشر لعنصر--  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =","canonical_solution":"canArrange :: [Int] -> Int\ncanArrange arr = go arr (-1) 0\n  where\n    go [] maxIdx _ = maxIdx\n    go [_] maxIdx _ = maxIdx\n    go (x:y:xs) maxIdx idx\n      | x >= y    = go (y:xs) idx (idx + 1)\n      | otherwise = go (y:xs) maxIdx (idx + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_136","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--اذا ما كان في عدد صحيح سالب او ايجابي، رجعهم على شكل لا شيء.--من عدد صحيح ايجابي في قائمة.--أكبر عدد صحيح سالب، و \"ب\" أصغر --احضر دالة ترجع توبل (أ، ب) ، حيث 'أ' هو --  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =","canonical_solution":"largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst = (largestNegative, smallestPositive)\n  where\n    negatives = filter (< 0) lst\n    positives = filter (> 0) lst\n    largestNegative = if null negatives then Nothing else Just (maximum negatives)\n    smallestPositive = if null positives then Nothing else Just (minimum positives)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_138","nl":"ajp_Arab","pl":"hs","prompt":"--مثال --احكم اذا الرقم المعطى n ممكن يكتب كمجموع من أربعة أرقام موجبة حتى.--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =","canonical_solution":"isEqualToSumEven :: Int -> Bool\nisEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_139","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--وين n > 0 --brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! --المعامل البرازيلي يعرف على انه:--  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =","canonical_solution":"specialFactorial :: Int -> Int\nspecialFactorial n = product [factorial x | x <- [1..n]]\n  where\n    factorial 0 = 1\n    factorial k = k * factorial (k - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_140","nl":"ajp_Arab","pl":"hs","prompt":"--بعدين بدي كل المساحات المتتاليين مع - --ولو السلسلة فيها اكثر من 2 مساحات متتالية،--مع وجود سلسلة نصية، بديل كل الفراغات فيها مع علامات تحت،--  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =","canonical_solution":"fixSpaces :: String -> String\nfixSpaces text = concatMap replaceSpaces (groupSpaces text)\n  where\n    groupSpaces :: String -> [String]\n    groupSpaces [] = []\n    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest\n\n    replaceSpaces :: String -> String\n    replaceSpaces spaces@(x:_)\n      | x == ' ' && length spaces > 2 = \"-\"\n      | x == ' ' = replicate (length spaces) '_'\n      | otherwise = spaces","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_141","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--السلسلة الفرعية بعد النقطة لازم تكون واحدة من هذه: ['txt'، 'exe'، 'dll'] --الأبجدية اللاتينية ('a'-'z' و 'A'-'Z').--السلسلة الفرعية اللي قبل النقطة مش لازم تكون فارغة، وبتبدأ بحرف من --اسم الملف فيه نقطة واحدة بالضبط.--- اسم الملف ما يشتملش على اكثر من ثلاثة ارقام ('0' - '9').--بتتحقق:--اسم الملف يعتبر صالح اذا ولو بس اذا كل الشروط اللي تحتوي عليها موجودة --\"نعم\" اذا اسم الملف صحيح، ويعيد \"لا\" اذا كان غير كده.--احضر دالة بتأخذ سلسلة تمثل اسم الملف، وتعود--  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =","canonical_solution":"import Data.Char (isDigit, isLetter)\n\nfileNameCheck :: String -> String\nfileNameCheck file_name \n  | countDots \/= 1 = \"No\"\n  | length digits > 3 = \"No\"\n  | null beforeDot || not (isLetter (head beforeDot)) = \"No\"\n  | afterDot `notElem` validExtensions = \"No\"\n  | otherwise = \"Yes\"\n  where \n    (beforeDot, afterDot) = span (\/= '.') file_name\n    countDots = length $ filter (== '.') file_name\n    digits = filter isDigit file_name\n    validExtensions = [\"txt\", \"exe\", \"dll\"]\n    afterDot = if null dotAndAfter then \"\" else tail dotAndAfter\n    dotAndAfter = dropWhile (\/= '.') file_name","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"\/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_142","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--بتغير الإدخالات في القائمة اللي مؤشراتها مش مضروبة بـ 3 أو 4.--ضرب من 3 و بيعمل مكعب للدخل الصحيح اذا كان مؤشرها ضرب من 4 و مش ضرب من 3.--هاي الدالة بتأخذ قائمة من الأعداد الصحيحة. لكل الإدخالات في القائمة، الدالة بتقوم على تربيع الإدخال الصحيح إذا كان مؤشرها هو --\"--  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =","canonical_solution":"sumSquares :: [Int] -> Int\nsumSquares lst = sum $ zipWith transform [0..] lst\n  where\n    transform idx x\n      | idx `mod` 3 == 0 = x * x\n      | idx `mod` 4 == 0 = x * x * x\n      | otherwise        = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_143","nl":"ajp_Arab","pl":"hs","prompt":"--مثال 1:--ترتيب الكلمات في السلسلة الجديدة لازم يكون نفس الترتيب في السلسلة الأصلية.--الطول فيها أرقام أولية، --و لازم ترجع سلسلة الكلمات اللي فيها الكلمات من الجملة الأصلية، --الجملة فيها كلمات مفصولة بحركة فضاء، --بتعطيك سلسلة تمثل جملة،--  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =","canonical_solution":"import Data.List (intercalate)\n\nwordsInSentence :: String -> String\nwordsInSentence sentence = intercalate \" \" $ filter (isPrime . length) (words sentence)\n\nisPrime :: Int -> Bool\nisPrime n | n < 2     = False\n          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_144","nl":"ajp_Arab","pl":"hs","prompt":"--ممكن تتخيل ان x و n هي كسور صحيحة، و ما عندهم الصفر كمقام.--<عدد>\/<اسم> حيث كل من العد والاسم عدداً صحيحاً موجب.--كل من x و n، هي تمثيلات سلسلة للكسر، ولها الشكل التالي، --x * n. الدالة بترد صح إذا x * n بتقييم لعدد صحيح و False --مهمتك هي تنفيذ دالة بتبسيط التعبير.--  >>> simplify \"1\/5\" \"5\/1\"\n--  True\n--  >>> simplify \"1\/6\" \"2\/1\"\n--  False\n--  >>> simplify \"7\/10\" \"10\/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =","canonical_solution":"import Data.Ratio (denominator, numerator, (%))\n\nsimplify :: String -> String -> Bool\nsimplify x n =\n  let (xNum, xDen) = toFraction x\n      (nNum, nDen) = toFraction n\n      result = (xNum * nNum) % (xDen * nDen)\n  in denominator result == 1\n\ntoFraction :: String -> (Integer, Integer)\ntoFraction s =\n  let (numStr, _:denStr) = break (=='\/') s\n  in (read numStr, read denStr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/6\" \"2\/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/1\" \"3\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/10\" \"10\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/10\" \"50\/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/2\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11\/6\" \"6\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/3\" \"5\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/2\" \"3\/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"8\/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"1\/5\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_145","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--ترتيبهم حسب مؤشرهم في القائمة الأصلية.--ملاحظة: اذا كان هناك عدة بنود مع مجموع رقميه متشابهة،--بالترتيب المتصاعد حسب مجموع أرقامهم.--اكتب دالة بتفرز القائمة اللي عناها من الأعداد الصحيحة.--  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =","canonical_solution":"import Data.List (sortBy)\nimport Data.Function (on)\n\norderByPoints :: [Int] -> [Int]\norderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums\n  where\n    sumOfDigits :: Int -> Int\n    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)\n    \n    indexedNums :: [(Int, Int)]\n    indexedNums = zip (map sumOfDigits nums) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_146","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--الرقم الأول والأخير من الرقم عادي (1, 3, 5, 7, 9).--عدد العناصر في القائمة اكبر من 10 و كلاهما --اكتب دالة بتأخذ قائمة من الأرقام كمدخل وتعود.--  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =","canonical_solution":"specialfilter :: [Int] -> Int\nspecialfilter nums = length $ filter isSpecial nums\n  where\n    isSpecial n = n > 10 && isOddFirstAndLast (abs n)\n\n    isOddFirstAndLast :: Int -> Bool\n    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit\n      where\n        xStr = show x\n        firstDigit = head xStr\n        lastDigit = last xStr\n\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_147","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--و a[i] + a[j] + a[k] هو مضروب لـ 3.--يعيد عدد الثلاثيات (a[i], a[j], a[k]) من a حيث i < j < k، --لكل i (1 ≤ i ≤ n) ، قيمة a[i] = i * i - i + 1.--انت معطيت رقم صحيح مثبت n. لازم تخلق قائمة من الأعداد الصحيحة a بطول n.--  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =","canonical_solution":"getMaxTriples :: Int -> Int\ngetMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]\n  where\n    a = [i * i - i + 1 | i <- [1..n]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_149","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--ممكن تتخيل ان كل الكلمات بتكون بنفس الطول.--المفروض ان الدالة ترجع قائمة من السلاسل بترتيب مرتب.--اذا كلمتين طولهم نفس، رتبوا القائمة حسب الأبجدية.--لازم يرجع القائمة مرتبة حسب القاعدة.--لازم ترتيب القائمة يطلع حسب طول كل كلمة، و انت.--و ممكن يحتوي على نسخ متكررة.--القائمة دايما قائمة من السلاسل ومش قائمة من الأرقام، --ويعيد القائمة الناتجة بترتيب مرتب، --حطم السلاسل اللي طولها غير متساوي منه، --كتب دالة تقبل قائمة من السلاسل كمعلم،--  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =","canonical_solution":"sortedListSum :: [String] -> [String]\nsortedListSum lst = sortBy compareStrings (filter evenLength lst)\n  where\n    evenLength s = even (length s)\n    compareStrings s1 s2\n      | length s1 == length s2 = compare s1 s2\n      | otherwise = compare (length s1) (length s2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_150","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--عدد أولي و لازم يعيد قيمة y و إلا.--برنامج بسيط اللي لازم يرجع قيمة x اذا n هو --  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =","canonical_solution":"xOrY :: Int -> Int -> Int -> Int\nxOrY n x y = if isPrime n then x else y\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_151","nl":"ajp_Arab","pl":"hs","prompt":"--في القائمة اللي مش فردية. اتجاهل الارقام اللي مش سالبة او غير صحيحة.--معطى قائمة من الأرقام، ارجع مجموع مربعات الأرقام.--  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =","canonical_solution":"doubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst = \n    sum [x * x | x <- map round lst, x > 0, odd x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_152","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--القيمة هي صفر، وإذا كانت غير صحيحة، القيمة هي الفرق المطلق بين التخمين والنتيجة.--يرجعوا قائمة بنفس الطول بتشير الى اي مدى كل تخمين كان بعيد. اذا كانوا قد تخمينوا بشكل صحيح، --بتعطيك قائمتين من النتائج والخمسينات بنفس الطول، حيث كل مؤشر يبين تطابق.--مهمتك هي تحديد اذا كان الشخص خمنت نتائج عدد من المباريات بشكل صحيح.--أكيد يستحق الإشارة والمقارنة.--الحدث معروف أخيراً. المشاعر والأفكار اللي عندك في تلك اللحظة هي--اعتقد اننا كلنا نتذكر الشعور الذي كان فيه نتيجة لبعض الاشياء المتوقعة--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =","canonical_solution":"compare :: [Int] -> [Int] -> [Int]\ncompare game guess = zipWith (\\g s -> abs (g - s)) game guess","tests":"\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_153","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--(قوهوه -1).--يعود \"Slices.SErviNGSliCes\" لأن \"SErviNGSliCes\" هو أقوى امتداد --['SERVINGSliCes'، 'Cheese'، 'StuFfed'] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .--مثلاً، لو اعطيت \"شرائح\" كصنف وقائمة من ال --اختار اللي بيجي اول واحد في القائمة.--اذا كان هناك اثنين او اكثر من التمديدات بنفس القوة، يجب عليك--الشكل: ClassName.StrongestExtensionName. --لازم تلاقي أقوى امتداد وترجع سلسلة في هذا .--في اسم التوسع، القوة بتعطى بالكسر CAP - SM.--حروف في اسم التوسيع، و SM يكون عدد الحروف الصغيرة --قوة التوسع هي زي ما يلي: خلي CAP يكون رقم الحرف الكبير --التوسعات لازم تستخدم علشان تحميل طبقات إضافية للطبقة.--رح تعطيك اسم الفئة (سلسلة) وقائمة التمديدات.--  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =","canonical_solution":"strongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions = class_name ++ \".\" ++ strongestExt\n  where\n    calculateStrength :: String -> Int\n    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)\n    \n    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)\n    \n    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)\n    maxStrength ext1 ext2\n      | snd ext1 > snd ext2 = ext1\n      | otherwise           = ext2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_154","nl":"ajp_Arab","pl":"hs","prompt":"--بتعطيك كلمتين. لازم ترجع True اذا الكلمة الثانية او اي من تدويراتها هي سلسلة فرعية في الكلمة الاولى.--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =","canonical_solution":"cycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b = any (`isInfixOf` a) rotations\n  where\n    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_155","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--مع عدد صحيح، ارجع توبل بيكون فيه عدد رقميين زوجي وعزيزي على التوالي.--  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =","canonical_solution":"evenOddCount :: Int -> (Int, Int)\nevenOddCount num = (length evens, length odds)\n  where\n    digits = map (read . (:[])) . show . abs $ num\n    evens = filter even digits\n    odds  = filter odd digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_156","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة:--قيود: 1 <= num <= 1000 --و ارجعها بحروف صغيرة.--مع عدد صحيح موجب، احصل على مكافئ الرقم الروماني كسلسلة،--  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =","canonical_solution":"intToMiniRoman :: Int -> String\nintToMiniRoman number = concatMap (replicateSymbol number) romanNumerals\n  where\n    romanNumerals = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n                     (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n                     (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    \n    replicateSymbol :: Int -> (Int, String) -> String\n    replicateSymbol n (value, symbol)\n      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)\n      | otherwise = \"\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_157","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--90 درجة.--مثلث ذي زاوية مستقيمة هو مثلث فيه زاوية واحدة زاوية مستقيمة او--الطرفين يشكلوا مثلث زاوية مستقيمة، غلط غير كده.--مع طول الجهات الثلاثة للمثلث، رح نعيد الصواب اذا الجهات الثلاثة--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =","canonical_solution":"rightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c = \n    let [x, y, z] = sort [a, b, c]\n    in x^2 + y^2 == z^2\n    where sort = Data.List.sort","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_158","nl":"ajp_Arab","pl":"hs","prompt":"--حروف، ارجع اللي بيجي اولا بالترتيب المفرد.--اذا كان عدد السلاسل متعدد يكون فيه اكبر عدد من الحروف الفريدة--القائمة فيها كلمات مختلفة. ارجع الكلمة مع اكبر عدد ممكن --اكتب دالة تقبل قائمة من السلاسل.--  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =","canonical_solution":"import Data.List (nub, sort)\n\nfindMax :: [String] -> String\nfindMax words = \n    head . sort . map snd . filter (\\(n, _) -> n == maxUnique) $ wordUniquePairs\n  where\n    wordUniquePairs = [(length . nub $ word, word) | word <- words]\n    maxUnique = maximum $ map fst wordUniquePairs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_159","nl":"ajp_Arab","pl":"hs","prompt":"--مثال:--اذا ما بقى ما يكفي من الجزر، بتأكلو كل الجزر اللي بقى، بس بتبقى جوعان.--كم بقي من الجزر بعد الوجبات؟--لازم ترجعلي قائمة [ مجموع عدد الجزر اللي اكلتيه بعد الوجبات، --بس هسه لازم تاكل كرتون اكتر عشان تكمل وجبات اليوم.--انت ارنب جائع، و انت اكلت عدد معين من الجزر،--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =","canonical_solution":"eat :: Int -> Int -> Int -> [Int]\neat number need remaining\n  | remaining >= need = [number + need, remaining - need]\n  | otherwise = [number + remaining, 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_160","nl":"ajp_Arab","pl":"hs","prompt":"--قائمة المشغلات فيها مشغل واحد على الأقل، وقائمة المشغلات فيها مشغلين على الأقل.--أوبراند هو قائمة من الأعداد الصحيحة غير السالبة.--طول قائمة المشغلات يساوي طول قائمة العاملات ناقص واحد.--ملاحظة:--=> النتيجة = 9 --النتيجة = 2 + 3 * 4 - 5 --القائمة = [2, 3, 4, 5] --عامل التشغيل['+'، '*'، '-'] --مثال:--التكبير بالأعداد (**) --تقسيم الطابق (\/\/)--ضرب (*) --طرح ( - ) --إضافة (+) --عمليات الجبر الأساسية:--معبر و يرجع تقييم هذا المعبر.--القائمة التانية هي قائمة من الأعداد الصحيحة. استخدم القائمتين اللي اتعطيتموها لبناء الجبر.--في القائمة الاولى عملات جبرية اساسية، وdoAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =","canonical_solution":"doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand = evaluate operand operator\n  where\n    evaluate [x] [] = x\n    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops\n      where\n        result = applyOperation op x y\n\n    applyOperation \"+\" a b = a + b\n    applyOperation \"-\" a b = a - b\n    applyOperation \"*\" a b = a * b\n    applyOperation \"\/\/\" a b = a `div` b\n    applyOperation \"**\" a b = a ^ b\n    applyOperation _ _ _ = error \"Unsupported operation\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"\/\/\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_161","nl":"ajp_Arab","pl":"hs","prompt":"--أمثلة --المفروض ان الدالة ترجع السلسلة الناتجة.--اذا السلسلة ما تحتوي على حروف، عكس السلسلة.--و إلا خليه زي ما هو.--إذا s[i] هو حرف، عكس الحالة من الأسفل للأسفل أو العكس.--بتعطيك سلسلة اس.--  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =","canonical_solution":"solve :: String -> String\nsolve s\n  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s\n  | otherwise = reverse s\n  where\n    toggleCase c\n      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char\n      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_162","nl":"ajp_Arab","pl":"hs","prompt":"--اذا 'text' هو سلسلة صفات فارغة، ارجع Nothing.--معطى سلسلة 'text'، ارجع سلسلة ميش md5 المكافئة.--  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =","canonical_solution":"import qualified Data.ByteString.Char8 as C\nimport qualified Data.Digest.Pure.MD5 as MD5\n\nstringToMd5 :: String -> Maybe String\nstringToMd5 text\n  | null text = Nothing\n  | otherwise = Just $ show $ MD5.md5 $ C.pack text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_163","nl":"ajp_Arab","pl":"hs","prompt":"--مثلاً:--و ب، بترتيب تصاعدي.--مع وجود عددين صحيحين ايجابيين أ و ب، ارجع رقم الزوج بين أ و ب.--  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =","canonical_solution":"generateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b = filter even [min a b .. max a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()"}]