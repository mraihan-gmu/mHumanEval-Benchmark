[{"task_id":"HumanEval_0","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ନିର୍ଦ୍ଦିଷ୍ଟ ସୀମା ।\/\/\/ ଯାଞ୍ଚ କରନ୍ତୁ ଯେ, କୌଣସି ଦୁଇଟି ସଂଖ୍ୟା  ଠାରୁ ପରସ୍ପରର ନିକଟତର କି ନୁହେଁ\/\/\/ >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/\/ true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n","canonical_solution":"fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"},{"task_id":"HumanEval_1","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଇନପୁଟ୍ ଷ୍ଟ୍ରିଙ୍ଗରେ ଥିବା କୌଣସି ସ୍ପେସ୍ କୁ ଅଣଦେଖା କରନ୍ତୁ.\/\/ଅଲଗା ଅଲଗା ଗୋଷ୍ଠୀ ସନ୍ତୁଳିତ (ପ୍ରତ୍ୟେକ ଖୋଲା କଣ୍ଟା ସଠିକ ଭାବରେ ବନ୍ଦ) ଏବଂ ପରସ୍ପର ମଧ୍ୟରେ ନାଇଷ୍ଟ୍ ହୋଇନଥାଏ ।\/\/\/ ସେହି ଗୋଷ୍ଠୀକୁ ଅଲଗା ଅଲଗା ଷ୍ଟ୍ରିଙ୍ଗରେ ଅଲଗା କରି ସେହିମାନଙ୍କର ଭେକ୍ଟର ଫେରାଇଥାଏ. \/\/\/ ଏହି ଫଳନକୁ ଇନପୁଟ୍ କରିବା ପାଇଁ ଗୋଟିଏ ଷ୍ଟ୍ରିଙ୍ଗ ଅଛି ଯେଉଁଥିରେ ନେଷ୍ଟ୍ ବାକ୍ୟଖଣ୍ଡର ଏକାଧିକ ଗୋଷ୍ଠୀ ଅଛି. ଆପଣଙ୍କର ଲକ୍ଷ୍ୟ ହେଉଛି \/\/\/ >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n\/\/\/ vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n","canonical_solution":"fn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut current_group = String::new();\n    let mut open_count = 0;\n\n    for char in paren_string.chars() {\n        if char == '(' {\n            open_count += 1;\n            current_group.push(char);\n        } else if char == ')' {\n            open_count -= 1;\n            current_group.push(char);\n        }\n\n        if open_count == 0 && !current_group.is_empty() {\n            groups.push(current_group.clone());\n            current_group.clear();\n        }\n    }\n\n    groups\n}","tests":"}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n"},{"task_id":"HumanEval_2","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସଂଖ୍ୟାର ଦଶମିକ ଅଂଶକୁ ଫେରାଇଦିଅନ୍ତୁ. \/\/\/ (ବଳକା ଅଂଶ ସବୁବେଳେ ୧ ରୁ ଛୋଟ) \/\/\/ ଏବଂ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଅଂଶ (ଦତ୍ତ ସଂଖ୍ୟା ଠାରୁ ବଡ଼ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଛୋଟ) ଏବଂ ଦଶମିକ ସଂଖ୍ୟା \/\/\/ ଏକ ସକାରାତ୍ମକ ଭାସମାନ ବିନ୍ଦୁ ସଂଖ୍ୟା ଦିଆଗଲା, ଏହାକୁ ରେ ବିଭକ୍ତ କରାଯାଇପାରେ\/\/\/ >>> truncate_number(3.5)\n\/\/\/ 0.5\nfn truncate_number(number: f64) -> f64 {\n","canonical_solution":"fn truncate_number(number: f64) -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    println!(\"{}\", truncate_number(3.5)); \/\/ 0.5\n}","tests":"}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"},{"task_id":"HumanEval_3","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସେହି ସମୟରେ ଫଳନ true ଫେରାଇବ ଅନ୍ୟଥା ଏହା false ଫେରାଇବ.\/\/ଆପଣଙ୍କ କାମ ହେଉଛି ଯେ କୌଣସି ସମୟରେ ଖାତାର ବାଲାନ୍ସ ଶୂନ ତଳକୁ ଖସିଗଲେ, ଏବଂ \/\/\/ ଆପଣଙ୍କୁ ଏକ ବ୍ୟାଙ୍କ ଖାତାରେ ଜମା ଓ ଉଠାଣର ଏକ ଭେକ୍ଟର ଦିଆଯାଉଛି ଯାହା  ସହିତ ଆରମ୍ଭ ହୋଇଥାଏ\/\/\/ >>> below_zero(vec![1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(vec![1, 2, -4, 5])\n\/\/\/ true\nfn below_zero(operations: Vec<isize>) -> bool {\n","canonical_solution":"fn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations {\n        balance += operation;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", below_zero(vec![1, 2, 3])); \/\/ false\n    println!(\"{}\", below_zero(vec![1, 2, -4, 5])); \/\/ true\n    println!(\"{}\", below_zero(vec![1, -1, -1, 2])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"},{"task_id":"HumanEval_4","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ MAD = ହାରାହାରି ∙ x - x_mean ∙\/\/\/ ଉପାଦାନ ଏବଂ ଏକ କେନ୍ଦ୍ର ବିନ୍ଦୁ (ଏହି କ୍ଷେତ୍ରରେ ମଧ୍ୟମ): \/\/\/ ହାରାହାରି ଅବଶୋଲଟ ଡିଭାୟେସନ ହେଉଛି ଉଭୟର ହାରାହାରି ଅବଶୋଲଟ ଡିଫେରେନ୍ସ \/\/\/ ଏହି ଡାଟାସେଟର ହାରାହାରି ପାଖାପାଖି ।\/\/\/ ଇନପୁଟ୍ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ଭେକ୍ଟର ପାଇଁ, ମିଆଁନ ଅବସୋଲ୍ଟ ଡିଭାଇଏସନକୁ ଗଣନା କରନ୍ତୁ \/\/\/ >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n","canonical_solution":"fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    let n = numbers.len() as f64;\n    if n == 0.0 {\n        return 0.0;\n    }\n\n    let mean: f64 = numbers.iter().sum::<f64>() \/ n;\n    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() \/ n;\n    \n    mad\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0];\n    println!(\"{}\", mean_absolute_deviation(numbers)); \/\/ Output: 1.0\n}","tests":"}\n\nfn main() {\n    let candidate = mean_absolute_deviation;\n    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);\n}\n"},{"task_id":"HumanEval_5","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ପ୍ରତ୍ୟେକ ଦୁଇ କ୍ରମିକ ଉପାଦାନ ମଧ୍ୟରେ ଏକ ସଂଖ୍ୟା 'ଡିଲିମିଟର' ଭର୍ତ୍ତି କରନ୍ତୁ _\/\/\/ >>> intersperse(vec![], 4)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> intersperse(vec![1, 2, 3], 4)\n\/\/\/ vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n","canonical_solution":"fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n    }\n    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n    for (i, &num) in numbers.iter().enumerate() {\n        result.push(num);\n        if i != numbers.len() - 1 {\n            result.push(delimiter);\n        }\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", intersperse(vec![], 4)); \/\/ Output: Vec::<isize>::new()\n    println!(\"{:?}\", intersperse(vec![1, 2, 3], 4)); \/\/ Output: vec![1, 4, 2, 4, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"},{"task_id":"HumanEval_6","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ (() (()) ରେ ସର୍ବାଧିକ ଦୁଇଟି ସ୍ତର ଥିବା ବେଳେ ((())) ରେ ତିନୋଟି ସ୍ତର ରହିଛି । \/\/\/ ପ୍ରତ୍ୟେକ ଗ୍ରୁପ ପାଇଁ, ବ୍ରେକନେଡର ଗଭୀରତମ ସ୍ତରକୁ ଆଉଟପୁଟ୍ କରନ୍ତୁ.\/\/\/ ଏହି ଫଳନକୁ ଇନପୁଟ୍ ହେଉଛି ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଯାହାକି ଅନ୍ତଃସ୍ଥଳ ବନ୍ଧନୀ ପାଇଁ ସ୍ପେସ୍ ଦ୍ୱାରା ପୃଥକ ହୋଇଥିବା ଏକାଧିକ ଗୋଷ୍ଠୀକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ।\/\/\/ >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n\/\/\/ vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    paren_string.split_whitespace().map(|group| {\n        let mut max_depth = 0;\n        let mut current_depth = 0;\n        for char in group.chars() {\n            match char {\n                '(' => {\n                    current_depth += 1;\n                    if current_depth > max_depth {\n                        max_depth = current_depth;\n                    }\n                },\n                ')' => {\n                    current_depth -= 1;\n                },\n                _ => {}\n            }\n        }\n        max_depth\n    }).collect()\n}\n\nfn main() {\n    let result = parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"));\n    println!(\"{:?}\", result); \/\/ Output: [2, 3, 1, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n"},{"task_id":"HumanEval_7","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ କେବଳ ସେହିଗୁଡ଼ିକ ପାଇଁ ଗୋଟିଏ ଇନପୁଟ୍ ଭେକ୍ଟର ଫିଲ୍ଟର୍ କରନ୍ତୁ ଯେଉଁଥିରେ ଦିଆଯାଇଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗ୍ ଅଛି \/\/\/ >>> filter_by_substring(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.into_iter().filter(|s| s.contains(&substring)).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\")), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"},{"task_id":"HumanEval_8","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଶୂନ୍ୟ ସମୂହ 0 ହେବା ଉଚିତ ଏବଂ ଶୂନ୍ୟ ଗୁଣନ 1 ହେବା ଉଚିତ ।\/\/\/ ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ଭେକ୍ଟର ପାଇଁ, ଏକ ଟାପଲ୍ ଫେରାଇ ଦିଅନ୍ତୁ ଯେଉଁଥିରେ ଏକ ଭେକ୍ଟରରେ ଥିବା ସମସ୍ତ ସଂଖ୍ୟାର ସମୁଦାୟ ଏବଂ ଗୁଣନ ଥାଏ ।\/\/\/ >>> sum_product(vec![])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(vec![1, 2, 3, 4])\n\/\/\/ (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n","canonical_solution":"fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n}\n\nfn main() {\n    println!(\"{:?}\", sum_product(vec![])); \/\/ (0, 1)\n    println!(\"{:?}\", sum_product(vec![1, 2, 3, 4])); \/\/ (10, 24)\n}","tests":"}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"},{"task_id":"HumanEval_9","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଧାରାବାହିକରେ ।\/\/\/ ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ଭେକ୍ଟରରୁ, ନିର୍ଦ୍ଦିଷ୍ଟ ମୁହୂର୍ତ୍ତ ପର୍ଯ୍ୟନ୍ତ ମିଳିଥିବା ସର୍ବାଧିକ ରୋଲିଂ ଉପାଦାନର ଭେକ୍ଟର ସୃଷ୍ଟି କରନ୍ତୁ \/\/\/ >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n\/\/\/ vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max = isize::MIN;\n    for &num in &numbers {\n        if num > current_max {\n            current_max = num;\n        }\n        result.push(current_max);\n    }\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"},{"task_id":"HumanEval_10","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ - ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ପ୍ରିଫିକ୍ସର ଷ୍ଟ୍ରିଙ୍ଗ୍ ରିଭର୍ସକୁ ଯୋଡନ୍ତୁ ଯାହା ପାଲିଣ୍ଡ୍ରୋମିକ୍ ସଫିକ୍ସ ପୂର୍ବରୁ ଆସେ ।\/\/\/ - ପ୍ରଦାନ କରାଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗର ସବୁଠାରୁ ଲମ୍ବା ପୋଷ୍ଟଫିକ୍ସ ଖୋଜନ୍ତୁ ଯାହା ଏକ ପାଲିଣ୍ଡ୍ରୋମ ଅଟେ ।\/\/\/ ଆଲଗୋରିଦମ ଧାରଣା ସରଳ: \/\/\/ ଯେଉଁଟାକି ଏକ ସରଞ୍ଜାମରେ ଆରମ୍ଭ ହୋଇଥାଏ, ସେହିଟା ସବୁଠାରୁ ଛୋଟ ପାଲିଣ୍ଡ୍ରୋମକୁ ଖୋଜନ୍ତୁ.\/\/\/ >>> make_palindrome(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> make_palindrome(String::from(\"cat\"))\n\/\/\/ String::from(\"catac\")\n\/\/\/ >>> make_palindrome(String::from(\"cata\"))\n\/\/\/ String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n","canonical_solution":"fn make_palindrome(string: String) -> String {\n    fn is_palindrome(s: &str) -> bool {\n        s.chars().eq(s.chars().rev())\n    }\n\n    if string.is_empty() || is_palindrome(&string) {\n        return string;\n    }\n\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..]) {\n            let prefix = &string[..i];\n            let reversed_prefix: String = prefix.chars().rev().collect();\n            return string + &reversed_prefix;\n        }\n    }\n\n    string\n}\n\nfn main() {\n    println!(\"{:?}\", make_palindrome(String::from(\"\"))); \/\/ String::from(\"\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cat\"))); \/\/ String::from(\"catac\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cata\"))); \/\/ String::from(\"catac\")\n}","tests":"}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n}\n"},{"task_id":"HumanEval_11","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏହି ଇନପୁଟ ଉପରେ ବାଇନାରୀ XOR କରନ୍ତୁ ଏବଂ ଫଳାଫଳକୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଭାବରେ ଫେରାନ୍ତୁ. \/\/\/ ଇନପୁଟ୍ ହେଉଛି ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗ୍ a ଏବଂ b ଯାହା କେବଳ 1s ଏବଂ 0s ର ।\/\/\/ >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n\/\/\/ String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n","canonical_solution":"fn string_xor(a: String, b: String) -> String {\n    a.chars()\n     .zip(b.chars())\n     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })\n     .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"},{"task_id":"HumanEval_12","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସମାନ ଲମ୍ବର ଶୃଙ୍ଖଳା _ ଯଦି ଇନପୁଟ୍ ଭେକ୍ଟର ଖାଲି ଥାଏ ତେବେ None ଫେରାଇବ _\/\/\/ ଷ୍ଟ୍ରିଙ୍ଗ୍ ର ଭେକ୍ଟର ବାହାରେ, ସବୁଠାରୁ ଲମ୍ବାକୁ ଫେରାଇଦିଅନ୍ତୁ. ଏକାଧିକ  କ୍ଷେତ୍ରରେ ପ୍ରଥମକୁ ଫେରାଇଦିଅନ୍ତୁ.\/\/\/ >>> longest(vec![])\n\/\/\/ None\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ Some(String::from(\"a\"))\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\/\/\/ Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n","canonical_solution":"fn longest(strings: Vec<String>) -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len())\n}","tests":"}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"},{"task_id":"HumanEval_13","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦୁଇଟି ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା a ଓ b ର ସର୍ବ ବୃହତ ସାଧାରଣ ବିଭାଜକକୁ ଫେରାଇଥାଏ \/\/\/ >>> greatest_common_divisor(3, 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(25, 15)\n\/\/\/ 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n","canonical_solution":"fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}","tests":"}\n\nfn main() {\n    let candidate = greatest_common_divisor;\n    assert_eq!(candidate(3, 7), 1);\n    assert_eq!(candidate(10, 15), 5);\n    assert_eq!(candidate(49, 14), 7);\n    assert_eq!(candidate(144, 60), 12);\n}\n"},{"task_id":"HumanEval_14","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ନିବେଶ ଷ୍ଟ୍ରିଙ୍ଗର ସର୍ବୋଚ୍ଚରୁ ସର୍ବୋଚ୍ଚ ପର୍ଯ୍ୟନ୍ତ ସମସ୍ତ ଉପସର୍ଗର ଭେକ୍ଟର ଫେରାଇଥାଏ \/\/\/ >>> all_prefixes(String::from(\"abc\"))\n\/\/\/ vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n","canonical_solution":"fn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 1..=string.len() {\n        prefixes.push(string[..i].to_string());\n    }\n    prefixes\n}\n\n\/\/ Example usage\nfn main() {\n    let prefixes = all_prefixes(String::from(\"abc\"));\n    println!(\"{:?}\", prefixes);\n}","tests":"}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\")]);\n}\n"},{"task_id":"HumanEval_15","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ 0 ରୁ ଆରମ୍ଭ କରି n ସମେତ ଅନ୍ତରୀଣ-ସୀମିତ ସଂଖ୍ୟା ଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇଥାଏ. \/\/\/ >>> string_sequence(0)\n\/\/\/ String::from(\"0\")\n\/\/\/ >>> string_sequence(5)\n\/\/\/ String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n","canonical_solution":"fn string_sequence(n: isize) -> String {\n    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = string_sequence;\n    assert_eq!(candidate(0), String::from(\"0\"));\n    assert_eq!(candidate(3), String::from(\"0 1 2 3\"));\n    assert_eq!(candidate(10), String::from(\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"},{"task_id":"HumanEval_16","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଗଲା, କେତେ ଅଲଗା ଅକ୍ଷର (କେସକୁ ନେଇ) ଅଛି ତାହା ଖୋଜନ୍ତୁ \/\/\/ >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(String::from(\"Jerry\"))\n\/\/\/ 4\nfn count_distinct_characters(string: String) -> isize {\n","canonical_solution":"use std::collections::HashSet;\n\nfn count_distinct_characters(string: String) -> isize {\n    let lowercase_string = string.to_lowercase();\n    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();\n    distinct_chars.len() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_distinct_characters;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abcde\")), 5);\n    assert_eq!(candidate(String::from(\"abcdecadeCADE\")), 5);\n    assert_eq!(candidate(String::from(\"aaaaAAAAaaaa\")), 1);\n    assert_eq!(candidate(String::from(\"Jerry jERRY JeRRRY\")), 5);\n}\n"},{"task_id":"HumanEval_17","nl":"ory_Orya","pl":"rs","prompt":"\/\/'କ୍ୱାର୍ଟର ନୋଟ୍, ଗୋଟିଏ ବିଟ୍ ପର୍ଯ୍ୟନ୍ତ ରହିଥାଏ'\/\/'ଓ ରାଇଡର୍' - ଅଧା ନୋଟ୍, ଦୁଇ ଥର ବାଜିବା ପାଇଁ \/\/'ଓ' - ପୁରା ନୋଟ୍, ଚାରିଟି ବିଟ୍ ପର୍ଯ୍ୟନ୍ତ \/\/ଏଠାରେ ଏକ କିମ୍ବଦନ୍ତୀ ଅଛି:\/\/\/ ଶେଷ ନୁହେଁ ।\/\/\/ ଆପଣଙ୍କର କାମ ହେଉଛି ଏହି ଷ୍ଟ୍ରିଙ୍ଗକୁ ବିଶ୍ଳେଷଣ କରିବା ଏବଂ ପ୍ରତ୍ୟେକ କେତେ ବିଟ୍ କରେ ତାହା ସହିତ ସମାନ ସଂଖ୍ୟକ ଭେକ୍ଟର ଫେରାଇବା \/\/\/ ଏହି ଫଙ୍କସନକୁ ଇନପୁଟ କରିବା ପାଇଁ ଏକ ସ୍ୱତନ୍ତ୍ର ASCII ଫର୍ମାଟରେ ମ୍ୟୁଜିକାଲ ନୋଟକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ଥାଏ ।\/\/\/ >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n\/\/\/ vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_music(music_string: String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let notes: Vec<&str> = music_string.split_whitespace().collect();\n\n    for note in notes {\n        match note {\n            \"o\" => result.push(4),\n            \"o|\" => result.push(2),\n            \".|\" => result.push(1),\n            _ => (),\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let music_string = String::from(\"o o| .| o| o| .| .| .| .| o o\");\n    let beats = parse_music(music_string);\n    println!(\"{:?}\", beats); \/\/ Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"},{"task_id":"HumanEval_18","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ମୂଳ ଷ୍ଟ୍ରିଙ୍ଗରେ କେତେଥର ଦିଆଯାଇଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗ୍ ମିଳିପାରିବ ତାହା ଖୋଜ _ ଆଲଟପଲ୍ଲଟ କେସ୍ ଗୁଡିକୁ ଗଣନା କର _\/\/\/ >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n\/\/\/ 0\n\/\/\/ >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n\/\/\/ 3\n\/\/\/ >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n\/\/\/ 3\nfn how_many_times(string: String, substring: String) -> isize {\n","canonical_solution":"fn how_many_times(string: String, substring: String) -> isize {\n    if substring.is_empty() || string.is_empty() {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut position = 0;\n\n    while let Some(pos) = string[position..].find(&substring) {\n        count += 1;\n        position += pos + 1; \/\/ Move to the start of the next potential substring\n    }\n\n    count\n}\n\nfn main() {\n    println!(\"{}\", how_many_times(String::from(\"\"), String::from(\"a\"))); \/\/ 0\n    println!(\"{}\", how_many_times(String::from(\"aaa\"), String::from(\"a\"))); \/\/ 3\n    println!(\"{}\", how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))); \/\/ 3\n}","tests":"}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n"},{"task_id":"HumanEval_19","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସଂଖ୍ୟାଗୁଡ଼ିକୁ ସର୍ବନିମ୍ନରୁ ସର୍ବାଧିକକୁ ସର୍ଟ କରି ସ୍ଟ୍ରିଙ୍ଗକୁ ଫେରାଇଥାଏ \/\/\/ ବୈଧ ବିକଳ୍ପଗୁଡ଼ିକ ହେଉଛି 'ଶୂନ', 'ଏକ', 'ଦୁଇ', 'ତିନି', 'ଚାରି', 'ପାଞ୍ଚ', 'ଛଅ', 'ସାତ', 'ଆଠ' ଏବଂ 'ନଅ'। \/\/\/ ଇନପୁଟ୍ ହେଉଛି 'ଶୂନ'ରୁ 'ନଅ' ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ସ୍ପେସ୍-ସୀମିତ ଷ୍ଟ୍ରିଙ୍ଗ୍ ।\/\/\/ >>> sort_numbers(String::from(\"three one five\"))\n\/\/\/ String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n","canonical_solution":"fn sort_numbers(numbers: String) -> String {\n    let word_to_number = |word: &str| -> u32 {\n        match word {\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => panic!(\"Invalid input\"),\n        }\n    };\n\n    let words: Vec<&str> = numbers.split_whitespace().collect();\n    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();\n\n    number_words.sort_by_key(|&(_, number)| number);\n\n    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = sort_numbers;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"three\")), String::from(\"three\"));\n    assert_eq!(candidate(String::from(\"three five nine\")), String::from(\"three five nine\"));\n    assert_eq!(candidate(String::from(\"five zero four seven nine eight\")), String::from(\"zero four five seven eight nine\"));\n    assert_eq!(candidate(String::from(\"six five four three two one zero\")), String::from(\"zero one two three four five six\"));\n}\n"},{"task_id":"HumanEval_20","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଅନ୍ୟକୁ ଏବଂ ସେମାନଙ୍କୁ କ୍ରମରେ ଫେରାଇ ଦିଅନ୍ତୁ (ଅଧିକ ସଂଖ୍ୟା, କମ୍ ସଂଖ୍ୟା) ।\/\/\/ ଦିଆଯାଇଥିବା ସଂଖ୍ୟା ଭେକ୍ଟରରୁ (ଅତିକମରେ ଦୁଇଟି ଲମ୍ବ) ପ୍ରତ୍ୟେକର ନିକଟତମ ଦୁଇଟିକୁ ବାଛନ୍ତୁ ଏବଂ ଫେରାନ୍ତୁ \/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n","canonical_solution":"fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::INFINITY;\n    let mut result = (0.0, 0.0);\n\n    for i in 0..(numbers.len() - 1) {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff {\n            min_diff = diff;\n            result = (numbers[i], numbers[i + 1]);\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    \/\/ Example usage\n    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];\n    let res1 = find_closest_elements(vec1);\n    println!(\"{:?}\", res1); \/\/ (2.0, 2.2)\n\n    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];\n    let res2 = find_closest_elements(vec2);\n    println!(\"{:?}\", res2); \/\/ (2.0, 2.0)\n}","tests":"}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"},{"task_id":"HumanEval_21","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏପରି କି ସବୁଠାରୁ ଛୋଟ ସଂଖ୍ୟା 0 ହେବ ଏବଂ ସବୁଠାରୁ ବଡ ସଂଖ୍ୟା 1 ହେବ \/\/\/ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ଭେକ୍ଟର (ଅତିକମରେ ଦୁଇଟି ଉପାଦାନର) ଦିଆଗଲା, ସେହି ଭେକ୍ଟର ପାଇଁ ଏକ ରେଖୀ ପରିବର୍ତ୍ତନ ପ୍ରୟୋଗ କରନ୍ତୁ, \/\/\/ >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n","canonical_solution":"fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\n    numbers.into_iter().map(|x| (x - min_value) \/ (max_value - min_value)).collect()\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let rescaled = rescale_to_unit(numbers);\n    println!(\"{:?}\", rescaled);\n}","tests":"}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"},{"task_id":"HumanEval_23","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦିଆଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗର ରିଟର୍ଣ୍ଣ ଲମ୍ବ \/\/\/ >>> strlen(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> strlen(String::from(\"abc\"))\n\/\/\/ 3\nfn strlen(string: String) -> isize {\n","canonical_solution":"fn strlen(string: String) -> isize {\n    string.chars().count() as isize\n}\n\nfn main() {\n    println!(\"{}\", strlen(String::from(\"\"))); \/\/ Output: 0\n    println!(\"{}\", strlen(String::from(\"abc\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = strlen;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"x\")), 1);\n    assert_eq!(candidate(String::from(\"asdasnakj\")), 9);\n}\n"},{"task_id":"HumanEval_24","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ କୌଣସି ଏକ n ସଂଖ୍ୟା ପାଇଁ, n ଠାରୁ ଛୋଟ, ସବୁଠାରୁ ବଡ ସଂଖ୍ୟା ଖୋଜନ୍ତୁ ଯାହା n କୁ ସମାନ ଭାବରେ ବିଭକ୍ତ କରେ \/\/\/ >>> largest_divisor(15)\n\/\/\/ 5\nfn largest_divisor(n: isize) -> isize {\n","canonical_solution":"fn largest_divisor(n: isize) -> isize {\n    for i in (1..n).rev() {\n        if n % i == 0 {\n            return i;\n        }\n    }\n    1 \/\/ If no other divisor is found, return 1\n}\n\nfn main() {\n    println!(\"{}\", largest_divisor(15)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3), 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n    assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n"},{"task_id":"HumanEval_25","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଇନପୁଟ୍ ସଂଖ୍ୟା ସବୁ ଗୁଣକର ଗୁଣନ ସହିତ ସମାନ ହେବା ଉଚିତ \/\/\/ ପ୍ରତ୍ୟେକ ଗୁଣକକୁ କେତେଥର ଭେକ୍ଟୋରୀକରଣ କରାଯିବ ତାହା ସୂଚାଇଥାଏ ଯେ ଏହା କେତେଥର ଉପସ୍ଥିତ ହେବ ।\/\/\/ ଛୋଟରୁ ବଡ଼ ପର୍ଯ୍ୟନ୍ତ କ୍ରମରେ ଦିଆଯାଇଥିବା ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଅଶେଷ ଗୁଣକମାନଙ୍କର ରିଟର୍ଣ୍ଣ ଭେକ୍ଟର ।\/\/\/ >>> factorize(8)\n\/\/\/ vec![2, 2, 2]\n\/\/\/ >>> factorize(25)\n\/\/\/ vec![5, 5]\n\/\/\/ >>> factorize(70)\n\/\/\/ vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n","canonical_solution":"fn factorize(mut n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    while n >= divisor * divisor {\n        while n % divisor == 0 {\n            factors.push(divisor);\n            n \/= divisor;\n        }\n        divisor += 1;\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", factorize(8));  \/\/ Should print: [2, 2, 2]\n    println!(\"{:?}\", factorize(25)); \/\/ Should print: [5, 5]\n    println!(\"{:?}\", factorize(70)); \/\/ Should print: [2, 5, 7]\n}","tests":"}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"},{"task_id":"HumanEval_26","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉପାଦାନଗୁଡ଼ିକର କ୍ରମାଙ୍କକୁ ଇନପୁଟରେ ଥିବା କ୍ରମାଙ୍କ ସହିତ ସମାନ ରଖନ୍ତୁ ।\/\/\/ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡ଼ିକର ଭେକ୍ଟରରୁ, ସମସ୍ତ ଉପାଦାନଗୁଡ଼ିକୁ କାଢ଼ି ଦିଅନ୍ତୁ ଯାହା ଥରେରୁ ଅଧିକ ଥର ଘଟେ ।\/\/\/ >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n\/\/\/ vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut occurrences = HashMap::new();\n    \n    \/\/ Count occurrences of each number\n    for &number in &numbers {\n        *occurrences.entry(number).or_insert(0) += 1;\n    }\n\n    \/\/ Filter out numbers that occur more than once\n    numbers.into_iter()\n        .filter(|&number| occurrences[&number] == 1)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_duplicates;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);\n}\n"},{"task_id":"HumanEval_27","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଗୋଟିଏ ଧାର୍ଯ୍ୟ ବାକ୍ୟଖଣ୍ଡ ପାଇଁ, ଛୋଟ ଅକ୍ଷରକୁ ବଡ଼ ଅକ୍ଷର ଓ ବଡ଼ ଅକ୍ଷରକୁ ଛୋଟ ଅକ୍ଷର ଭାବରେ ବଦଳାନ୍ତୁ. \/\/\/ >>> flip_case(String::from(\"Hello\"))\n\/\/\/ String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n","canonical_solution":"fn flip_case(string: String) -> String {\n    string.chars().map(|c| {\n        if c.is_lowercase() {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")), String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"},{"task_id":"HumanEval_28","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏକକ ଷ୍ଟ୍ରିଙ୍ଗରେ ଷ୍ଟ୍ରିଙ୍ଗର କନକଟେନେଟ୍ ଭେକ୍ଟର \/\/\/ >>> concatenate(vec![])\n\/\/\/ String::from(\"\")\n\/\/\/ >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n","canonical_solution":"fn concatenate(strings: Vec<String>) -> String {\n    strings.concat()\n}","tests":"}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n}\n"},{"task_id":"HumanEval_29","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ କେବଳ ସେହିମାନଙ୍କ ପାଇଁ ଏକ ଇନପୁଟ୍ ଭେକ୍ଟର ଫିଲ୍ଟର୍ କରନ୍ତୁ ଯାହା ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ଉପସର୍ଗ ସହିତ ଆରମ୍ଭ ହୋଇଥାଏ ।\/\/\/ >>> filter_by_prefix(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_prefix;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n}\n"},{"task_id":"HumanEval_30","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଭେକ୍ଟରରେ କେବଳ ସକାରାତ୍ମକ ସଂଖ୍ୟାଗୁଡ଼ିକୁ ଫେରାଇଥାଏ. \/\/\/ >>> get_positive(vec![-1, 2, -4, 5, 6])\n\/\/\/ vec![2, 5, 6]\n\/\/\/ >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().filter(|&x| x > 0).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = get_positive;\n    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);\n    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_31","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଯଦି କୌଣସି ଦିଆଯାଇଥିବା ସଂଖ୍ୟାଟି ଅଶୂନ୍ୟ ହୋଇଥାଏ, ତେବେ ଏହା ସତ୍ୟ ଫେରାଇଥାଏ, ଅନ୍ୟଥା ଏହା ମିଥ୍ୟା ହୋଇଥାଏ ।\/\/\/ >>> is_prime(6)\n\/\/\/ false\n\/\/\/ >>> is_prime(101)\n\/\/\/ true\n\/\/\/ >>> is_prime(11)\n\/\/\/ true\n\/\/\/ >>> is_prime(13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(61)\n\/\/\/ true\n\/\/\/ >>> is_prime(4)\n\/\/\/ false\n\/\/\/ >>> is_prime(1)\n\/\/\/ false\nfn is_prime(n: isize) -> bool {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n}\n"},{"task_id":"HumanEval_33","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସମାନ ସୂଚକାଙ୍କର ମୂଲ୍ୟକୁ l, କିନ୍ତୁ ସର୍ଟ କରାଯାଇଛି ।\/\/\/ l' ହେଉଛି l ସହିତ ସମାନ ଯେଉଁ ସୂଚକାଙ୍କଗୁଡ଼ିକ ତିନି ଭାଗରେ ବିଭକ୍ତ ହୋଇନଥାଏ, ଯେତେବେଳେ କି ଏହାର ମୂଲ୍ୟଗୁଡ଼ିକ ସେହି ସୂଚକାଙ୍କଗୁଡ଼ିକରେ ସମାନ ହୋଇଥାଏ ଯାହା ତିନି ଭାଗରେ ବିଭକ୍ତ ହୋଇଥାଏ ।\/\/\/ ଏହି ଫଳନ ଏକ ଭେକ୍ଟର l ନେଇଥାଏ ଏବଂ ଏକ ଭେକ୍ଟର l' ଫେରାଇଥାଏ ଯେପରିକି \/\/\/ >>> sort_third(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n\/\/\/ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()\n        .enumerate()\n        .filter(|&(i, _)| i % 3 == 0)\n        .map(|(i, &value)| (i, value))\n        .collect();\n\n    \/\/ Sort the values that are at indices divisible by 3\n    divisible_by_three.sort_by_key(|&(_, value)| value);\n\n    let mut result = l.clone();\n    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {\n        result[*original_index] = divisible_by_three[sorted_index].1;\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"},{"task_id":"HumanEval_34","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏକ ଭେକ୍ଟରରେ ସର୍ଟ ହୋଇଥିବା ଅନନ୍ୟ ଉପାଦାନଗୁଡ଼ିକୁ ଫେରାଇଥାଏ \/\/\/ >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique(mut l: Vec<isize>) -> Vec<isize> {\n    l.sort_unstable();\n    l.dedup();\n    l\n}\n\nfn main() {\n    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);\n    println!(\"{:?}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = unique;\n    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);\n}\n"},{"task_id":"HumanEval_35","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଭେକ୍ଟରରେ ସର୍ବାଧିକ ଉପାଦାନକୁ ଫେରାଇଥାଏ. \/\/\/ >>> max_element(vec![1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfn max_element(l: Vec<isize>) -> isize {\n","canonical_solution":"fn max_element(l: Vec<isize>) -> isize {\n    l.into_iter().max().unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = max_element;\n    assert_eq!(candidate(vec![1, 2, 3]), 3);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);\n}\n"},{"task_id":"HumanEval_36","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ 11 କିମ୍ବା 13 ଦ୍ୱାରା ବିଭାଜନ ହେଉଥିବା n ରୁ କମ୍ ସଂଖ୍ୟାରେ 7 ସଂଖ୍ୟା କେତେ ଥର ଦେଖାଯାଏ ତାହା ଫେରାଇଥାଏ ।\/\/\/ >>> fizz_buzz(50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(79)\n\/\/\/ 3\nfn fizz_buzz(n: isize) -> isize {\n","canonical_solution":"fn fizz_buzz(n: isize) -> isize {\n    (0..n)\n        .filter(|&x| x % 11 == 0 || x % 13 == 0)\n        .flat_map(|x| x.to_string().chars())\n        .filter(|&c| c == '7')\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = fizz_buzz;\n    assert_eq!(candidate(50), 0);\n    assert_eq!(candidate(78), 2);\n    assert_eq!(candidate(79), 3);\n    assert_eq!(candidate(100), 3);\n    assert_eq!(candidate(200), 6);\n    assert_eq!(candidate(4000), 192);\n    assert_eq!(candidate(10000), 639);\n    assert_eq!(candidate(100000), 8026);\n}\n"},{"task_id":"HumanEval_37","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ l ର ଯୁଗ୍ମ ସୂଚକାଙ୍କଗୁଡ଼ିକର ମୂଲ୍ୟକୁ, କିନ୍ତୁ ସର୍ଟ କରାଯାଇଛି ।\/\/\/ l' ଅଙ୍କରେ l ସହିତ ସମାନ, କିନ୍ତୁ ସମାନ ଅଙ୍କରେ l ସମାନ ।\/\/\/ ଏହି ଫଳନ ଏକ ଭେକ୍ଟର l ନେଇଥାଏ ଏବଂ ଏକ ଭେକ୍ଟର l' ଫେରାଇଥାଏ ଯେପରିକି \/\/\/ >>> sort_even(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_even(vec![5, 6, 3, 4])\n\/\/\/ vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    \/\/ Collect even indexed elements and sort them\n    let mut even_elements: Vec<isize> = l.iter().enumerate()\n        .filter(|&(i, _)| i % 2 == 0)\n        .map(|(_, &val)| val)\n        .collect();\n    even_elements.sort();\n\n    \/\/ Reconstruct the vector `l'`\n    let mut result = l.clone();\n    let mut even_index = 0;\n\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result[i] = even_elements[even_index];\n            even_index += 1;\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"},{"task_id":"HumanEval_39","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ prime_fib n-th ସଂଖ୍ୟାକୁ ଫେରାଇଥାଏ ଯାହାକି ଏକ ଫିବୋନାସୀ ସଂଖ୍ୟା ଅଟେ ଏବଂ ଏହା ମଧ୍ୟ ଅଶୂର ଅଟେ \/\/\/ >>> prime_fib(1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(5)\n\/\/\/ 89\nfn prime_fib(n: isize) -> isize {\n","canonical_solution":"fn prime_fib(n: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        if num <= 3 {\n            return true;\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    fn fibonacci() -> impl Iterator<Item = isize> {\n        let mut a: isize = 0;\n        let mut b: isize = 1;\n        std::iter::from_fn(move || {\n            let next = a + b;\n            a = b;\n            b = next;\n            Some(a)\n        })\n    }\n\n    let mut count = 0;\n    for fib_num in fibonacci() {\n        if is_prime(fib_num) {\n            count += 1;\n            if count == n {\n                return fib_num;\n            }\n        }\n    }\n    -1\n}","tests":"}\n\nfn main() {\n    let candidate = prime_fib;\n    assert_eq!(candidate(1), 2);\n    assert_eq!(candidate(2), 3);\n    assert_eq!(candidate(3), 5);\n    assert_eq!(candidate(4), 13);\n    assert_eq!(candidate(5), 89);\n    assert_eq!(candidate(6), 233);\n    assert_eq!(candidate(7), 1597);\n    assert_eq!(candidate(8), 28657);\n    assert_eq!(candidate(9), 514229);\n    assert_eq!(candidate(10), 433494437);\n}\n"},{"task_id":"HumanEval_40","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସମୂହ ଶୂନ, ଅନ୍ୟଥା ମିଥ୍ୟା ।\/\/\/ ଏହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଭେକ୍ଟରରେ ତିନୋଟି ଭିନ୍ନ ଉପାଦାନ ଅଛି ଯାହା \/\/\/ triples_sum_to_zero ଏକ ଭେକ୍ଟର ଇଣ୍ଟେଜରକୁ ଇନପୁଟ ଭାବରେ ଗ୍ରହଣ କରିଥାଏ ।\/\/\/ >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1])\n\/\/\/ false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    let n = l.len();\n    if n < 3 {\n        return false;\n    }\n\n    let mut sorted_l = l.clone();\n    sorted_l.sort();\n\n    for i in 0..n-2 {\n        let a = sorted_l[i];\n        let mut left = i + 1;\n        let mut right = n - 1;\n\n        while left < right {\n            let sum = a + sorted_l[left] + sorted_l[right];\n            if sum == 0 {\n                return true;\n            } else if sum < 0 {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n    }\n\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n}\n"},{"task_id":"HumanEval_41","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏହି ଫଙ୍କସନ ଏପରି ଧକ୍କାର ସଂଖ୍ୟାକୁ ଆଉଟପୁଟ କରିଥାଏ ।\/\/\/ ସେମାନଙ୍କ ଗତିପଥରେ ଏପରି ଭାବରେ ଗତି କରୁଛି ଯେପରି ସେମାନେ ମୁହାଁମୁହିଁ ହୋଇନାହାନ୍ତି ।\/\/କିନ୍ତୁ ଏହି କାରଗୁଡିକ ଅକଳନୀୟ ଦୃଢ଼ ଓ ଶକ୍ତିଶାଳୀ, ତେଣୁ ସେମାନେ ଆଗକୁ ବଢ଼ି ଚାଲିଥାନ୍ତି ।\/\/\/ ଯେତେବେଳେ ବାମରୁ ଡାହାଣକୁ ଯାଉଥିବା ଏକ କାର ଡାହାଣରୁ ବାମକୁ ଯାଉଥିବା ଏକ କାରକୁ ଧକ୍କା ଦେଇଥାଏ. \/\/ସମସ୍ତ ଗାଡି ସମାନ ବେଗରେ ଗତି କରିଥାଏ ଦୁଇଟି ଗାଡି ଧକ୍କା ହେବା କଥା କୁହାଯାଏ\/\/ଏହି ଦୁଇ ଦଫାର କାର ବହୁତ ଦୂରରେ ଆରମ୍ଭ ହୋଇଥିଲା ।\/\/\/nଟି କାର ବାମରୁ ଡାହାଣକୁ ଯାଉଛନ୍ତି; ଏକ ସମୟରେ, nଟି କାରର ଭିନ୍ନ ସେଟ୍ _\/\/କଳ୍ପନା କରନ୍ତୁ ଯେ ଏକ ରାସ୍ତା ହେଉଛି ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସିଧା ଅସୀମ ଦୀର୍ଘ ରେଖା ।fn car_race_collision(n: isize) -> isize {\n","canonical_solution":"fn car_race_collision(n: isize) -> isize {\n    \/\/ Since every car moving left to right will collide exactly once\n    \/\/ with every car moving right to left, the number of collisions is n * n\n    n * n\n}\n\nfn main() {\n    let n = 5;\n    println!(\"Number of collisions: {}\", car_race_collision(n));\n}","tests":"}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"},{"task_id":"HumanEval_42","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ 1 ଦ୍ୱାରା ବୃଦ୍ଧି କରାଯାଇଥିବା ଉପାଦାନ ସହିତ ରିଟର୍ଣ୍ଣ ଭେକ୍ଟର _\/\/\/ >>> incr_list(vec![1, 2, 3])\n\/\/\/ vec![2, 3, 4]\n\/\/\/ >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|&x| x + 1).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = incr_list;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);\n    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n"},{"task_id":"HumanEval_43","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସମୂହ ଶୂନ, ଅନ୍ୟଥା ମିଥ୍ୟା ।\/\/\/ ଏହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଭେକ୍ଟରରେ ଦୁଇଟି ଭିନ୍ନ ଉପାଦାନ ଅଛି ଯାହା \/\/\/ pairs_sum_to_zero ଏକ ଭେକ୍ଟର ଇଣ୍ଟେଜରକୁ ଇନପୁଟ ଭାବରେ ଗ୍ରହଣ କରିଥାଏ ।\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(vec![1])\n\/\/\/ false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    use std::collections::HashSet;\n    let mut seen = HashSet::new();\n    \n    for &num in &l {\n        if seen.contains(&-num) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, 5, 0])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, -2, 1])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 2, 3, 7])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); \/\/ true\n    println!(\"{}\", pairs_sum_to_zero(vec![1])); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"},{"task_id":"HumanEval_44","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଆଧାର ସଂଖ୍ୟା 10 ରୁ କମ୍ ।\/\/\/ ରୂପାନ୍ତର ପରେ ଶୃଙ୍ଖଳା ପ୍ରତିନିଧିତ୍ୱ ଫେରାଇଥାଏ ।\/\/\/ ନିବେଶ ସଂଖ୍ୟା x ର ସଂଖ୍ୟାଗତ ଆଧାରକୁ ଆଧାରରେ ପରିବର୍ତ୍ତନ କରନ୍ତୁ. \/\/\/ >>> change_base(8, 3)\n\/\/\/ String::from(\"22\")\n\/\/\/ >>> change_base(8, 2)\n\/\/\/ String::from(\"1000\")\n\/\/\/ >>> change_base(7, 2)\n\/\/\/ String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n","canonical_solution":"fn change_base(x: isize, base: isize) -> String {\n    if base < 2 || base > 9 {\n        panic!(\"Base must be between 2 and 9\");\n    }\n    \n    if x == 0 {\n        return String::from(\"0\");\n    }\n    \n    let mut result = String::new();\n    let mut number = x;\n    \n    while number > 0 {\n        let remainder = number % base;\n        result.push_str(&remainder.to_string());\n        number \/= base;\n    }\n    \n    result.chars().rev().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"},{"task_id":"HumanEval_45","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏକ ତ୍ରିଭୁଜ ପାଇଁ ଏକ ପାର୍ଶ୍ବ ଓ ଉଚ୍ଚ ରିଟର୍ଣ୍ଣ କ୍ଷେତ୍ରର ଲମ୍ବ ଦିଆଯାଇଥାଏ ।\/\/\/ >>> triangle_area(5, 3)\n\/\/\/ 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, h: isize) -> f64 {\n    (a as f64 * h as f64) \/ 2.0\n}\n\nfn main() {\n    let area = triangle_area(5, 3);\n    println!(\"{}\", area);\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5, 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10, 8), 40.0);\n}\n"},{"task_id":"HumanEval_46","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦୟାକରି fib4 ସଂଖ୍ୟା କ୍ରମର n-ତମ ଉପାଦାନକୁ ଦକ୍ଷତାର ସହିତ ଗଣନା କରିବା ପାଇଁ ଏକ ଫଳନ ଲେଖନ୍ତୁ । ପୁନଃପୌନିକତା ବ୍ୟବହାର କରନ୍ତୁ ନାହିଁ ।\/\/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \/\/\/ fib4(3) -> 0 \/\/\/ fib4(2) -> 2 \/\/\/ fib4(1) -> 0 \/\/\/ fib4(0) -> 0 \/\/\/ Fib4 ସଂଖ୍ଯା କ୍ରମ ହେଉଛି Fibbonacci କ୍ରମ ପରି ଏକ କ୍ରମ ଯାହାକି ନିମ୍ନଲିଖିତ ପରିଭାଷିତ: \/\/\/ >>> fib4(5)\n\/\/\/ 4\n\/\/\/ >>> fib4(6)\n\/\/\/ 8\n\/\/\/ >>> fib4(7)\n\/\/\/ 14\nfn fib4(n: isize) -> isize {\n","canonical_solution":"fn fib4(n: isize) -> isize {\n    if n < 0 {\n        return 0; \/\/ Define behavior for negative input\n    }\n\n    let mut sequence = vec![0, 0, 2, 0];\n\n    if n < 4 {\n        return sequence[n as usize];\n    }\n\n    for i in 4..=n {\n        let next_value = sequence[(i - 1) as usize] \n                       + sequence[(i - 2) as usize] \n                       + sequence[(i - 3) as usize] \n                       + sequence[(i - 4) as usize];\n        sequence.push(next_value);\n    }\n\n    sequence[n as usize]\n}\n\nfn main() {\n    println!(\"{}\", fib4(5)); \/\/ 4\n    println!(\"{}\", fib4(6)); \/\/ 8\n    println!(\"{}\", fib4(7)); \/\/ 14\n}","tests":"}\n\nfn main() {\n    let candidate = fib4;\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 28);\n    assert_eq!(candidate(10), 104);\n    assert_eq!(candidate(12), 386);\n}\n"},{"task_id":"HumanEval_47","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଭେକ୍ଟର l ରେ ଥିବା ଉପାଦାନର ରିଟର୍ଣ୍ଣ ମିଡିୟାନ ।\/\/\/ >>> median(vec![3, 1, 2, 4, 5])\n\/\/\/ 3.0\n\/\/\/ >>> median(vec![-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfn median(l: Vec<isize>) -> f64 {\n","canonical_solution":"fn median(l: Vec<isize>) -> f64 {\n    let mut l = l.clone();\n    l.sort();\n    let len = l.len();\n\n    if len % 2 == 0 {\n        let mid1 = len \/ 2;\n        let mid2 = mid1 - 1;\n        ((l[mid1] as f64) + (l[mid2] as f64)) \/ 2.0\n    } else {\n        l[len \/ 2] as f64\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6, 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"},{"task_id":"HumanEval_48","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦିଆଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗ୍ ଏକ ପାଲିଣ୍ଡ୍ରୋମ୍ କି ନୁହେଁ ଯାଞ୍ଚ କରେ \/\/\/ >>> is_palindrome(String::from(\"\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aba\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aaaaa\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"zbcd\"))\n\/\/\/ false\nfn is_palindrome(text: String) -> bool {\n","canonical_solution":"fn is_palindrome(text: String) -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in 0..len \/ 2 {\n        if chars[i] != chars[len - 1 - i] {\n            return false;\n        }\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"},{"task_id":"HumanEval_49","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ 2^n ମଡୁଲୋ p କୁ ଫେରାଇଦିଅନ୍ତୁ (ସଂଖ୍ୟାନ ବିଷୟରେ ସଚେତନ ରୁହନ୍ତୁ) \/\/\/ >>> modp(3, 5)\n\/\/\/ 3\n\/\/\/ >>> modp(1101, 101)\n\/\/\/ 2\n\/\/\/ >>> modp(0, 101)\n\/\/\/ 1\n\/\/\/ >>> modp(3, 11)\n\/\/\/ 8\n\/\/\/ >>> modp(100, 101)\n\/\/\/ 1\nfn modp(n: isize, p: isize) -> isize {\n","canonical_solution":"fn modp(n: isize, p: isize) -> isize {\n    if p == 1 {\n        return 0;\n    }\n    let mut result = 1;\n    let mut base = 2 % p;\n    let mut exponent = n;\n    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        exponent \/= 2;\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"},{"task_id":"HumanEval_51","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ remove_vowels ହେଉଛି ଏକ ଫଙ୍କସନ୍ ଯାହା କ୍ରମକୁ ନେଇଥାଏ ଏବଂ ବିନା ସ୍ୱରରେ କ୍ରମକୁ ଫେରାଇଥାଏ.\/\/\/ >>> remove_vowels(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"abcdef\"))\n\/\/\/ String::from(\"bcdf\")\n\/\/\/ >>> remove_vowels(String::from(\"aaaaa\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"aaBAA\"))\n\/\/\/ String::from(\"B\")\n\/\/\/ >>> remove_vowels(String::from(\"zbcd\"))\n\/\/\/ String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n","canonical_solution":"fn remove_vowels(text: String) -> String {\n    text.chars()\n        .filter(|&c| !\"aeiouAEIOU\".contains(c))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_vowels;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"abcdef\nghijklm\")), String::from(\"bcdf\nghjklm\"));\n    assert_eq!(candidate(String::from(\"fedcba\")), String::from(\"fdcb\"));\n    assert_eq!(candidate(String::from(\"eeeee\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"acBAA\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"EcBOO\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"ybcd\")), String::from(\"ybcd\"));\n}\n"},{"task_id":"HumanEval_52","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ true କୁ ଫେରାଇଦିଏ ଯଦି ଭେକ୍ଟର l ରେ ଥିବା ସମସ୍ତ ସଂଖ୍ୟା threshold t ତଳେ ଥାଏ ।\/\/\/ >>> below_threshold(vec![1, 2, 4, 10], 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(vec![1, 20, 4, 10], 5)\n\/\/\/ false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n","canonical_solution":"fn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().all(|&x| x < t)\n}\n\nfn main() {\n    println!(\"{}\", below_threshold(vec![1, 2, 4, 10], 100)); \/\/ true\n    println!(\"{}\", below_threshold(vec![1, 20, 4, 10], 5));  \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = below_threshold;\n    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);\n}\n"},{"task_id":"HumanEval_53","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦୁଇଟି ସଂଖ୍ୟା x ଓ y କୁ ମିଶାନ୍ତୁ \/\/\/ >>> add(2, 3)\n\/\/\/ 5\n\/\/\/ >>> add(5, 7)\n\/\/\/ 12\nfn add(x: isize, y: isize) -> isize {\n","canonical_solution":"fn add(x: isize, y: isize) -> isize {\n    x + y\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(0, 1), 1);\n    assert_eq!(candidate(1, 0), 1);\n    assert_eq!(candidate(2, 3), 5);\n    assert_eq!(candidate(5, 7), 12);\n    assert_eq!(candidate(7, 5), 12);\n}\n"},{"task_id":"HumanEval_54","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦୁଇଟି ଶବ୍ଦର ଅକ୍ଷର ସମାନ କି ନାହିଁ ଚେକ୍ କରନ୍ତୁ. \/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n\/\/\/ false\nfn same_chars(s0: String, s1: String) -> bool {\n","canonical_solution":"use std::collections::HashSet;\n\nfn same_chars(s0: String, s1: String) -> bool {\n    let set0: HashSet<char> = s0.chars().collect();\n    let set1: HashSet<char> = s1.chars().collect();\n    set0 == set1\n}\n\nfn main() {\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"aabb\"), String::from(\"aaccc\")), false);\n}\n"},{"task_id":"HumanEval_55","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ n-ତମ ଫିବୋନାସୀ ସଂଖ୍ୟାକୁ ଫେରାଇଦିଅନ୍ତୁ. \/\/\/ >>> fib(10)\n\/\/\/ 55\n\/\/\/ >>> fib(1)\n\/\/\/ 1\n\/\/\/ >>> fib(8)\n\/\/\/ 21\nfn fib(n: isize) -> isize {\n","canonical_solution":"fn fib(n: isize) -> isize {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }\n}\n\nfn main() {\n    println!(\"{}\", fib(10)); \/\/ 55\n    println!(\"{}\", fib(1));  \/\/ 1\n    println!(\"{}\", fib(8));  \/\/ 21\n}","tests":"}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10), 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n    assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"},{"task_id":"HumanEval_56","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ true କୁ ଫେରାଇଥାଏ ଯଦି ପ୍ରତ୍ୟେକ ଖୋଲିବା ବ୍ରାକେଟରେ ଏକ ଅନୁରୂପ ବନ୍ଦ କରିବା ବ୍ରାକେଟ ଥାଏ ।\/\/\/ brackets ହେଉଛି \"<\" ଏବଂ \">\" ର ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍.\/\/\/ >>> correct_bracketing(String::from(\"<\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"<>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"<<><>>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"><<>\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n            balance += 1;\n        } else if bracket == '>' {\n            balance -= 1;\n            if balance < 0 {\n                return false;\n            }\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n}\n"},{"task_id":"HumanEval_57","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ true ଫେରାଇଦିଏ, ଯଦି ଭେକ୍ଟର ଉପାଦାନଗୁଡ଼ିକ ଏକକ ଭାବରେ ବୃଦ୍ଧି କିମ୍ବା ହ୍ରାସ ହୁଏ _\/\/\/ >>> monotonic(vec![1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(vec![1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(vec![4, 1, 0, -10])\n\/\/\/ true\nfn monotonic(l: Vec<isize>) -> bool {\n","canonical_solution":"fn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n    \n    let mut increasing = true;\n    let mut decreasing = true;\n    \n    for i in 0..l.len() - 1 {\n        if l[i] < l[i + 1] {\n            decreasing = false;\n        }\n        if l[i] > l[i + 1] {\n            increasing = false;\n        }\n    }\n    \n    increasing || decreasing\n}\n\nfn main() {\n    println!(\"{}\", monotonic(vec![1, 2, 4, 20])); \/\/ true\n    println!(\"{}\", monotonic(vec![1, 20, 4, 10])); \/\/ false\n    println!(\"{}\", monotonic(vec![4, 1, 0, -10])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1, 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n    assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"},{"task_id":"HumanEval_58","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦୁଇ ଭେକ୍ଟର ପାଇଁ ସର୍ଟ ହୋଇଥିବା ଅନନ୍ୟ ସାଧାରଣ ଉପାଦାନ ଫେରାଇଥାଏ. \/\/\/ >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n\/\/\/ vec![1, 5, 653]\n\/\/\/ >>> common(vec![5, 3, 2, 8], vec![3, 2])\n\/\/\/ vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashSet;\n\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    \/\/ Convert both vectors to hash sets to remove duplicates and allow set operations\n    let set1: HashSet<_> = l1.into_iter().collect();\n    let set2: HashSet<_> = l2.into_iter().collect();\n\n    \/\/ Find the intersection of both sets\n    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();\n\n    \/\/ Convert the intersection set to a sorted vector\n    let mut result: Vec<_> = intersection.into_iter().collect();\n    result.sort();\n\n    result\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); \/\/ Should print: [1, 5, 653]\n    println!(\"{:?}\", common(vec![5, 3, 2, 8], vec![3, 2])); \/\/ Should print: [2, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_59","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ n ର ସବୁଠାରୁ ବଡ ଅକ୍ଷର ଫ୍ୟାକ୍ଟର ଫେରାଇ ଦିଅନ୍ତୁ. n > 1 କୁ ଧରି ନିଅନ୍ତୁ ଏବଂ ଅକ୍ଷର ନୁହେଁ. \/\/\/ >>> largest_prime_factor(13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(2048)\n\/\/\/ 2\nfn largest_prime_factor(n: isize) -> isize {\n","canonical_solution":"fn largest_prime_factor(mut n: isize) -> isize {\n    let mut largest_factor = 1;\n\n    \/\/ Check for number of twos that divide n\n    while n % 2 == 0 {\n        largest_factor = 2;\n        n \/= 2;\n    }\n\n    \/\/ n must be odd at this point, so we can skip even numbers\n    let mut factor = 3;\n    while factor * factor <= n {\n        while n % factor == 0 {\n            largest_factor = factor;\n            n \/= factor;\n        }\n        factor += 2;\n    }\n\n    \/\/ If n becomes a prime number greater than 2\n    if n > 2 {\n        largest_factor = n;\n    }\n\n    largest_factor\n}\n\nfn main() {\n    println!(\"{}\", largest_prime_factor(13195));\n    println!(\"{}\", largest_prime_factor(2048));\n}","tests":"}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"},{"task_id":"HumanEval_60","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ sum_to_n ହେଉଛି ଏକ ଫଙ୍କସନ୍ ଯାହା 1 ରୁ n ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ୟାଗୁଡିକୁ ଯୋଗ କରିଥାଏ ।\/\/\/ >>> sum_to_n(30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(1)\n\/\/\/ 1\nfn sum_to_n(n: isize) -> isize {\n","canonical_solution":"fn sum_to_n(n: isize) -> isize {\n    n * (n + 1) \/ 2\n}","tests":"}\n\nfn main() {\n    let candidate = sum_to_n;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(6), 21);\n    assert_eq!(candidate(11), 66);\n    assert_eq!(candidate(30), 465);\n    assert_eq!(candidate(100), 5050);\n}\n"},{"task_id":"HumanEval_61","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ true କୁ ଫେରାଇଥାଏ ଯଦି ପ୍ରତ୍ୟେକ ଖୋଲିବା ବ୍ରାକେଟରେ ଏକ ଅନୁରୂପ ବନ୍ଦ କରିବା ବ୍ରାକେଟ ଥାଏ ।\/\/\/ ବନ୍ଧନୀ ହେଉଛି \"(\" ଏବଂ \"\") ର ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍.\/\/\/ >>> correct_bracketing(String::from(\"(\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"()\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"(()())\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\")(()\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for c in brackets.chars() {\n        if c == '(' {\n            balance += 1;\n        } else if c == ')' {\n            balance -= 1;\n        }\n\n        if balance < 0 {\n            return false;\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n}\n"},{"task_id":"HumanEval_62","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏହି ବହୁବଚନ ର ସମକକ୍ଷକୁ ସେହି ରୂପରେ ଫେରାଇଦିଅନ୍ତୁ. \/\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + ....  ଏହା ଏକ ବର୍ଗର ଏକକ ଅଟେ ।\/\/\/ xs ଏକ ବହୁପଦାର୍ଥର ଗୁଣକକୁ ଦର୍ଶାଏ ।\/\/\/ >>> derivative(vec![3, 1, 2, 4, 5])\n\/\/\/ vec![1, 4, 12, 20]\n\/\/\/ >>> derivative(vec![1, 2, 3])\n\/\/\/ vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &coeff) in xs.iter().enumerate().skip(1) {\n        result.push(coeff * i as isize);\n    }\n    result\n}\n\nfn main() {\n    let poly1 = vec![3, 1, 2, 4, 5];\n    let poly2 = vec![1, 2, 3];\n    println!(\"{:?}\", derivative(poly1)); \/\/ Output: [1, 4, 12, 20]\n    println!(\"{:?}\", derivative(poly2)); \/\/ Output: [2, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_63","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଦୟାକରି ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଦ୍ବାରା ଫିବିବ ସଂଖ୍ଯା କ୍ରମର n-ତମ ଉପାଦାନକୁ ସଠିକ ଭାବରେ ଗଣନା କରାଯାଇପାରିବ ।\/\/\/ fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3) । \/\/\/ fib fib (୨) == ୧ \/\/\/ fib fib ((1) == 0 \/\/\/ fib fib (ଶୂନ୍ୟ) == 0 \/\/\/ FibFib ସଂଖ୍ୟା କ୍ରମ ହେଉଛି ଫିବୋନାସୀ କ୍ରମ ପରି ସମାନ କ୍ରମ ଯାହା ନିମ୍ନଲିଖିତ ପରିଭାଷିତ: \/\/\/ >>> fibfib(1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(8)\n\/\/\/ 24\nfn fibfib(n: isize) -> isize {\n","canonical_solution":"fn fibfib(n: isize) -> isize {\n    if n < 0 {\n        \/\/ Optionally handle negative indices as an error or specific value\n        return -1; \/\/ Example error indicator\n    }\n    match n {\n        0 => 0,\n        1 => 0,\n        2 => 1,\n        _ => {\n            let mut a = 0;\n            let mut b = 0;\n            let mut c = 1;\n            let mut result = 0;\n            for _ in 3..=n {\n                result = a + b + c;\n                a = b;\n                b = c;\n                c = result;\n            }\n            result\n        }\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = fibfib;\n    assert_eq!(candidate(2), 1);\n    assert_eq!(candidate(1), 0);\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 24);\n    assert_eq!(candidate(10), 81);\n    assert_eq!(candidate(12), 274);\n    assert_eq!(candidate(14), 927);\n}\n"},{"task_id":"HumanEval_64","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ସ୍ୱର, କିନ୍ତୁ କେବଳ ସେତେବେଳେ ଯେତେବେଳେ ଏହା ଦିଆଯାଇଥିବା ଶବ୍ଦର ଶେଷରେ ଥାଏ ।\/\/ଏହି କ୍ଷେତ୍ରରେ ସ୍ୱରଗୁଡ଼ିକ ହେଉଛି 'a', 'e', 'i', 'o', 'u' । ଏଠାରେ 'y' ମଧ୍ୟ ଏକ 'a' ।\/\/\/ ଶବ୍ଦକୁ ଇନପୁଟ୍ ଭାବରେ ବ୍ୟବହାର କରି, ସ୍ୱରଗୁଡ଼ିକର ସଂଖ୍ଯା ଫେରାଇଥାଏ.\/\/\/ ଏକ ଫଙ୍କସନ୍ ଲେଖନ୍ତୁ vowels_count ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ନେଇଥାଏ \/\/\/ >>> vowels_count(String::from(\"abcde\"))\n\/\/\/ 2\n\/\/\/ >>> vowels_count(String::from(\"ACEDY\"))\n\/\/\/ 3\nfn vowels_count(s: String) -> isize {\n","canonical_solution":"fn vowels_count(s: String) -> isize {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let s = s.to_lowercase();\n    let mut count = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {\n            count += 1;\n        }\n    }\n    \n    count\n}\n\nfn main() {\n    println!(\"{}\", vowels_count(String::from(\"abcde\"))); \/\/ Output: 2\n    println!(\"{}\", vowels_count(String::from(\"ACEDY\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"},{"task_id":"HumanEval_65","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଯଦି shift > ଅଙ୍କ ସଂଖ୍ୟା, ତେବେ ଅଙ୍କ ସଂଖ୍ୟାକୁ ଫେରାଇଦେବେ\/\/\/ ଏବଂ ଫଳାଫଳକୁ ଗୋଟିଏ ଷ୍ଟ୍ରିଙ୍ଗ ଭାବରେ ଫେରାଇଥାଏ. \/\/\/ ସର୍କୁଲାର ଭାବରେ x ର ଅଙ୍କକୁ ଘୁଞ୍ଚାଇ, ଅଙ୍କକୁ ଘୁଞ୍ଚାଇ ଡାହାଣକୁ ଘୁଞ୍ଚାଇ \/\/\/ >>> circular_shift(12, 1)\n\/\/\/ String::from(\"21\")\n\/\/\/ >>> circular_shift(12, 2)\n\/\/\/ String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n","canonical_solution":"fn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits: Vec<char> = x.abs().to_string().chars().collect();\n    let len = digits.len() as isize;\n    \n    if shift > len {\n        digits.reverse();\n    } else {\n        digits.rotate_right(shift as usize % len as usize);\n    }\n    \n    digits.into_iter().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100, 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12, 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"11\"));\n}\n"},{"task_id":"HumanEval_66","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଏଏସସିଆଇଆଇ କୋଡ ।\/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗକୁ ଇନପୁଟ ଭାବରେ ଗ୍ରହଣ କରେ ଏବଂ କେବଳ ଉପର ଅକ୍ଷରର ସମୁଦାୟ ଫେରାଇଥାଏ' \/\/\/ କାର୍ଯ୍ୟ \/\/\/ >>> digitSum(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> digitSum(String::from(\"abAB\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"abcCd\"))\n\/\/\/ 67\n\/\/\/ >>> digitSum(String::from(\"helloE\"))\n\/\/\/ 69\n\/\/\/ >>> digitSum(String::from(\"woArBld\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"aAaaaXa\"))\n\/\/\/ 153\nfn digitSum(s: String) -> isize {\n","canonical_solution":"fn digitSum(s: String) -> isize {\n    s.chars()\n     .filter(|c| c.is_uppercase())\n     .map(|c| c as isize)\n     .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = digitSum;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abAB\")), 131);\n    assert_eq!(candidate(String::from(\"abcCd\")), 67);\n    assert_eq!(candidate(String::from(\"helloE\")), 69);\n    assert_eq!(candidate(String::from(\"woArBld\")), 131);\n    assert_eq!(candidate(String::from(\"aAaaaXa\")), 153);\n    assert_eq!(candidate(String::from(\" How are yOu?\")), 151);\n    assert_eq!(candidate(String::from(\"You arE Very Smart\")), 327);\n}\n"},{"task_id":"HumanEval_67","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ପାଇଁ: \/\/\/ ବାସ୍କେଟରେ ଥିବା ଆମ୍ବ ଫଳର ସଂଖ୍ୟା ଫେରାଇ ଦିଅନ୍ତୁ ।\/\/\/ କମଳା ଓ ଆପଲ୍ ଏବଂ ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଯାହା ଫଳଗୁଡ଼ିକର ସମୁଦାୟ ସଂଖ୍ୟାକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ।\/\/\/ ସେଓ, କମଳା, ଏବଂ ଆମ୍ବ ଫଳ.\/\/\/ ଯାହାକି ଫଳ ବାସ୍କେଟରେ ବଣ୍ଟନ କରାଯାଇଥାଏ ଏହି ବାସ୍କେଟରେ ଫଳ ରହିଥାଏ \/\/ଏହି କାମରେ ଆପଣଙ୍କୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଯିବ ଯାହା ଆପଲ୍ ଓ କମଳା ସଂଖ୍ୟାକୁ ପ୍ରତିନିଧିତ୍ୱ କରିବ ।\/\/\/ >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n\/\/\/ 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n","canonical_solution":"fn fruit_distribution(s: String, n: isize) -> isize {\n    let mut parts = s.split_whitespace();\n    let apples: isize = parts.next().unwrap().parse().unwrap();\n    parts.next(); \/\/ skip \"apples\"\n    parts.next(); \/\/ skip \"and\"\n    let oranges: isize = parts.next().unwrap().parse().unwrap();\n    \n    n - (apples + oranges)\n}\n\nfn main() {\n    assert_eq!(fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120), 19);\n    println!(\"All test cases passed!\");\n}","tests":"}\n\nfn main() {\n    let candidate = fruit_distribution;\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 21), 10);\n    assert_eq!(candidate(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"1 apples and 0 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 5), 0);\n    assert_eq!(candidate(String::from(\"1 apples and 100 oranges\"), 120), 19);\n}\n"},{"task_id":"HumanEval_68","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ 1: \/\/\/ ଯଦି କୌଣସି ଯୁଗ୍ମ ମୂଲ୍ୟ ନଥାଏ କିମ୍ବା ଦିଆଯାଇଥିବା ଭେକ୍ଟରଟି ଖାଲି ଥାଏ, ତେବେ [] ଫେରାଇଦେବେ. \/\/\/ ଚୋରି ହୋଇଥିବା ନୋଡକୁ ଭେକ୍ଟର, [ smalest_value, ଏହାର ସୂଚକାଙ୍କ ],  ରେ ଫେରାଇଦିଆଯିବ\/\/\/ ଯଦି ଏକାଧିକ ନୋଡ ସମାନ ସର୍ବନିମ୍ନ ଯୁଗ୍ମ ମୂଲ୍ୟ ସହିତ ମିଳିଥାଏ ତେବେ ନୋଡକୁ ଫେରାଇଥାଏ ଯାହାର ସର୍ବନିମ୍ନ ସୂଚକାଙ୍କ ଅଛି _\/\/\/ ଚୋରା ନୋଡଟି ସବୁଠାରୁ ଛୋଟ ଯୁଗ୍ମ ମୂଲ୍ୟର ନୋଡ ହେବା ଉଚିତ ।\/\/\/ ଆପଣଙ୍କ କାମ ହେଉଛି ଗୋଟିଏ ନୋଡକୁ କାଢ଼ି ଫେରାଇ ଦେବା.\/\/\/ \"ଏକ ଭେକ୍ଟର ଦିଆଗଲା ଯାହାକି ଏକ ବୃକ୍ଷର ଶାଖାକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ଯାହାର ନନ୍-ନେଗେଟିଭ୍ ଇଣ୍ଟେଜର ନୋଡ ଅଛି \/\/\/ >>> pluck(vec![4, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(vec![1, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\/\/\/ vec![0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even: Option<(isize, usize)> = None;\n\n    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n            match smallest_even {\n                None => smallest_even = Some((value, index)),\n                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),\n                _ => {}\n            }\n        }\n    }\n\n    match smallest_even {\n        Some((value, index)) => vec![value, index as isize],\n        None => Vec::new(),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_69","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଯଦି ଏପରି କୌଣସି ମୂଲ୍ୟ ନଥାଏ, ତେବେ -1 ଫେରାଇଦେବେ.\/\/\/ ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ବାରମ୍ବାରତା ହେଉଛି ଭେକ୍ଟରରେ ଏହା କେତେଥର ଦେଖାଯାଏ ।\/\/\/ ଶୂନ, ଏବଂ ଏହାର ଫ୍ରିକ୍ୱେନ୍ସି ନିଜେ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ମୂଲ୍ୟ ଠାରୁ ଅଧିକ କିମ୍ବା ସମାନ ।\/\/\/ ଆପଣଙ୍କୁ ଧନାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଏକ ଅଣ-ଖାଲି ଭେକ୍ଟର ଦିଆଯାଇଛି. ସବୁଠାରୁ ବଡ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଫେରାଇ ଦିଅନ୍ତୁ ଯାହା  ଠାରୁ ବଡ ଅଟେ.\/\/\/ >>> search(vec![4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(vec![5, 5, 4, 4, 4])\n\/\/\/ -1\nfn search(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn search(lst: Vec<isize>) -> isize {\n    use std::collections::HashMap;\n    \n    let mut frequency_map = HashMap::new();\n    \n    \/\/ Count the frequency of each integer in the vector\n    for &num in &lst {\n        *frequency_map.entry(num).or_insert(0) += 1;\n    }\n    \n    let mut result = -1;\n    \n    \/\/ Iterate over the map to find the greatest integer with a frequency\n    \/\/ greater than or equal to its value\n    for (&num, &freq) in &frequency_map {\n        if freq >= num && num > result {\n            result = num;\n        }\n    }\n    \n    result\n}\n\n\/\/ Test cases\nfn main() {\n    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);\n    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);\n    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);\n}","tests":"}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n    assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]), 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]), -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n}\n"},{"task_id":"HumanEval_70","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ତାପରେ ବାକି ସଂଖ୍ୟାର ସର୍ବାଧିକ, ତାପରେ ସର୍ବନିମ୍ନ ଏବଂ ଏହିପରି _\/\/\/ ଅଜବ ସର୍ଟ, ଯେତେବେଳେ ଆପଣ ସର୍ବନିମ୍ନ ମୂଲ୍ୟ ସହିତ ଆରମ୍ଭ କରନ୍ତି, \/\/\/ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଭେକ୍ଟର ଦିଆଗଲା, ଅଜବ କ୍ରମରେ ଭେକ୍ଟର ଫେରାଇଦିଆଗଲା.\/\/\/ >>> strange_sort_list(vec![1, 2, 3, 4])\n\/\/\/ vec![1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(vec![5, 5, 5, 5])\n\/\/\/ vec![5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(vec![])\n\/\/\/ Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(lst.len());\n    lst.sort();\n\n    while !lst.is_empty() {\n        \/\/ Take the smallest element\n        if let Some(min) = lst.first().cloned() {\n            result.push(min);\n            lst.remove(0);\n        }\n        \/\/ Take the largest element\n        if let Some(max) = lst.last().cloned() {\n            result.push(max);\n            lst.pop();\n        }\n    }\n\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", strange_sort_list(vec![1, 2, 3, 4])); \/\/ Output: vec![1, 4, 2, 3]\n    println!(\"{:?}\", strange_sort_list(vec![5, 5, 5, 5])); \/\/ Output: vec![5, 5, 5, 5]\n    println!(\"{:?}\", strange_sort_list(vec![])); \/\/ Output: Vec::<isize>::new()\n}","tests":"}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n"},{"task_id":"HumanEval_71","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ତୃତୀୟ ପାର୍ଶ୍ବ ଅପେକ୍ଷା ।\/\/\/ ତିନୋଟି ପାର୍ଶ୍ବ ଏକ ବୈଧ ତ୍ରିଭୁଜ ସୃଷ୍ଟି କରେ ଯେତେବେଳେ କୌଣସି ଦୁଇଟି ପାର୍ଶ୍ବ ର ସମୁଦାୟ ଅଧିକ ହୋଇଥାଏ \/\/\/ ନଚେତ୍ ଫେରସ୍ତ -1 \/\/\/ ତ୍ରିଭୁଜକୁ ଦୁଇ ଦଶମିକ ବିନ୍ଦୁରେ ଗୋଲ କରନ୍ତୁ ଯଦି ତିନୋଟି ପାର୍ଶ୍ବ ଏକ ବୈଧ ତ୍ରିଭୁଜ ଗଠନ କରନ୍ତି ।\/\/\/ ଏକ ତ୍ରିଭୁଜର ତିନି ପାର୍ଶ୍ବ ର ଲମ୍ବ ଦିଆଗଲା.  ର କ୍ଷେତ୍ରଫଳ ଫେରେଇ ନିଅନ୍ତୁ.\/\/\/ >>> triangle_area(3, 4, 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(1, 2, 10)\n\/\/\/ -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 \/ 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        (area * 100.0).round() \/ 100.0\n    } else {\n        -1.0\n    }\n}\n\nfn main() {\n    println!(\"{}\", triangle_area(3, 4, 5)); \/\/ 6.0\n    println!(\"{}\", triangle_area(1, 2, 10)); \/\/ -1.0\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3, 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4, 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1, 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2, 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2, 2, 10), -1.0);\n}\n"},{"task_id":"HumanEval_72","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ବସ୍ତୁ q ଉଡିଯିବ ଯଦି ଏହା ସନ୍ତୁଳିତ (ଏହା ଏକ ପାଲିଣ୍ଡ୍ରୋମିକ ଭେକ୍ଟର) ଏବଂ ଏହାର ଉପାଦାନଗୁଡ଼ିକର ସମୁଦାୟ ସର୍ବାଧିକ ସମ୍ଭାବ୍ୟ ଓଜନ w ଠାରୁ କମ୍ କିମ୍ବା ସମାନ ହୋଇଥାଏ ।\/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ବସ୍ତୁ q ଉଡିଯିବ, ଏବଂ ଅନ୍ୟଥା ମିଥ୍ୟା _\/\/\/ >>> will_it_fly(vec![1, 2], 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(vec![3], 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n","canonical_solution":"fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let is_palindromic = q.iter().eq(q.iter().rev());\n\n    is_palindromic && sum <= w\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{}\", will_it_fly(vec![1, 2], 5)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 1)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 9)); \/\/ true\n    println!(\"{}\", will_it_fly(vec![3], 5)); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"},{"task_id":"HumanEval_73","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ସମାନ ଭାବରେ ପଢାଯାଏ _ ଗୋଟିଏ ପରିବର୍ତ୍ତନ ରେ ଆପଣ ଗୋଟିଏ ଉପାଦାନକୁ ଅନ୍ୟ ଉପାଦାନକୁ ବଦଳାଇ ପାରିବେ _\/\/\/ ଭେକ୍ଟରକୁ ପାଲିଣ୍ଡ୍ରୋମିକ କରିବା ପାଇଁ ପରିବର୍ତ୍ତନ କରିବାକୁ ପଡିବ । ପାଲିଣ୍ଡ୍ରୋମିକ ଭେକ୍ଟର ହେଉଛି ଏକ ଭେକ୍ଟର ଯାହା \/\/\/ ଏକ ଭେକ୍ଟର arr ଦେଇ, ଅତିକମରେ କେତେ ଉପାଦାନ ଅଛି \/\/\/ >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 2, 1])\n\/\/\/ 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn smallest_change(arr: Vec<isize>) -> isize {\n    let mut changes = 0;\n    let n = arr.len();\n    \n    for i in 0..n\/2 {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1;\n        }\n    }\n    \n    changes\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);\n\/\/     println!(\"{}\", result); \/\/ Outputs: 4\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"},{"task_id":"HumanEval_74","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଯଦି ଦୁଇଟି ଭେକ୍ଟର ସମାନ ସଂଖ୍ୟକ ଅକ୍ଷର ଅଛି, ତେବେ ପ୍ରଥମ ଭେକ୍ଟରକୁ ଫେରାଇଦିଅନ୍ତୁ.\/\/\/ ଭେକ୍ଟରର ସମସ୍ତ ଷ୍ଟ୍ରିଙ୍ଗରେ ଥିବା ଚାରର ମୋଟ ସଂଖ୍ୟା ଅନ୍ୟ ଭେକ୍ଟରଠାରୁ କମ୍ ।\/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗ ଭେକ୍ଟର ଗ୍ରହଣ କରେ ଏବଂ ଭେକ୍ଟର ଫେରାଇଥାଏ ଯାହାର \/\/\/ >>> total_match(vec![], vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"Hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n\/\/\/ vec![String::from(\"hi\"), String::from(\"admin\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n\/\/\/ vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();\n\n    if char_count(&lst1) <= char_count(&lst2) {\n        lst1\n    } else {\n        lst2\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    let result1 = total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    println!(\"{:?}\", result1);\n\n    let result2 = total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]);\n    println!(\"{:?}\", result2);\n}","tests":"}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"},{"task_id":"HumanEval_75","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଜାଣିଥିବା ଯେ (a) 100 ରୁ କମ ଅଟେ. \/\/\/ ଏବଂ ଅନ୍ୟଥା ମିଥ୍ୟା ।\/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଦିଆଯାଇଥିବା ସଂଖ୍ୟାଟି 3ଟି ଅଶୂର ସଂଖ୍ୟା ଗୁଡ଼ିକର ଗୁଣନ \/\/\/ >>> is_multiply_prime(30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n","canonical_solution":"fn is_multiply_prime(a: isize) -> bool {\n    fn is_prime(n: isize) -> bool {\n        if n <= 1 {\n            return false;\n        }\n        if n <= 3 {\n            return true;\n        }\n        if n % 2 == 0 || n % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    if a < 2 {\n        return false;\n    }\n\n    let mut primes = Vec::new();\n    for i in 2..a {\n        if is_prime(i) {\n            primes.push(i);\n        }\n    }\n\n    let p_len = primes.len();\n    for i in 0..p_len {\n        for j in i..p_len {\n            for k in j..p_len {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = is_multiply_prime;\n    assert_eq!(candidate(5), false);\n    assert_eq!(candidate(30), true);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(125), true);\n    assert_eq!(candidate(105), true);\n    assert_eq!(candidate(126), false);\n    assert_eq!(candidate(729), false);\n    assert_eq!(candidate(891), false);\n    assert_eq!(candidate(1001), true);\n}\n"},{"task_id":"HumanEval_76","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ x ହେଉଛି n ର ଏକ ସରଳ ଶକ୍ତି ଯଦି n**int=x \/\/\/ ଶକ୍ତି n ଏବଂ ଅନ୍ୟାନ୍ୟ କ୍ଷେତ୍ରରେ ମିଥ୍ୟା ।\/\/\/ ଆପଣଙ୍କର କାମ ହେଉଛି ଏକ ଫଳନ ଲେଖିବା ଯାହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଏକ ସଂଖ୍ୟା x ଏକ ସରଳ \/\/\/ >>> is_simple_power(1, 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(2, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(8, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(3, 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(3, 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(5, 3)\n\/\/\/ false\nfn is_simple_power(x: isize, n: isize) -> bool {\n","canonical_solution":"fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n        return false;\n    } else if x == 1 {\n        return true;\n    } else if n == 1 {\n        return x == 1;\n    }\n\n    let mut power_n = n;\n    while power_n < x {\n        power_n *= n;\n    }\n    power_n == x\n}\n\nfn main() {\n    println!(\"{}\", is_simple_power(1, 4)); \/\/ true\n    println!(\"{}\", is_simple_power(2, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(8, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(3, 2)); \/\/ false\n    println!(\"{}\", is_simple_power(3, 1)); \/\/ false\n    println!(\"{}\", is_simple_power(5, 3)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"},{"task_id":"HumanEval_77","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଟିପ୍ପଣୀ: ଆପଣ ଭାବୁଥିବେ ଇନପୁଟ୍ ସବୁବେଳେ ବୈଧ ।\/\/\/ ଯଦି ଏହି ଇନଗେଜର କୌଣସି ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଘନକ ଅଟେ. \/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା a କୁ ନେଇଥାଏ ଏବଂ true କୁ ଫେରାଇଥାଏ \/\/\/ >>> iscube(1)\n\/\/\/ true\n\/\/\/ >>> iscube(2)\n\/\/\/ false\n\/\/\/ >>> iscube(-1)\n\/\/\/ true\n\/\/\/ >>> iscube(64)\n\/\/\/ true\n\/\/\/ >>> iscube(0)\n\/\/\/ true\n\/\/\/ >>> iscube(180)\n\/\/\/ false\nfn iscube(a: isize) -> bool {\n","canonical_solution":"fn iscube(a: isize) -> bool {\n    if a < 0 {\n        \/\/ For negative numbers, take the cube root of the absolute value.\n        let cube_root = (-a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    } else {\n        let cube_root = (a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    }\n}\n\nfn main() {\n    println!(\"{}\", iscube(1));   \/\/ true\n    println!(\"{}\", iscube(2));   \/\/ false\n    println!(\"{}\", iscube(-1));  \/\/ true\n    println!(\"{}\", iscube(64));  \/\/ true\n    println!(\"{}\", iscube(0));   \/\/ true\n    println!(\"{}\", iscube(180)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n"},{"task_id":"HumanEval_78","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଏବଂ ଚିହ୍ନ A,B,C,D,E,F ସବୁ ବେଳେ ବଡ଼ ଅକ୍ଷର ରେ ଲେଖା ହୋଇଥାଏ. \/\/\/ ଟିପ୍ପଣୀ: ଆପଣ ଅନୁମାନ କରିପାରନ୍ତି ଯେ ଇନପୁଟ୍ ସର୍ବଦା ସଠିକ୍ କିମ୍ବା ଖାଲି ଷ୍ଟ୍ରିଙ୍ଗ୍, \/\/\/ ବି (= ଦଶମିକ 11), ଡି (= ଦଶମିକ 13) ।\/\/ତେଣୁ ଆପଣଙ୍କୁ ନିମ୍ନଲିଖିତ ଅଙ୍କ ମଧ୍ୟରୁ ଏକ ଅଙ୍କ ନିର୍ଣ୍ଣୟ କରିବାକୁ ହେବ: 2, 3, 5, 7, \/\/\/ ଅଶୂର ସଂଖ୍ୟା ଗୁଡିକ ହେଉଛି 2, 3, 5, 7, 11, 13, 17,... \/\/\/ ହେକ୍ସାଡେସିମାଲ ଅଙ୍କ ହେଉଛି 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/\/\/ 1 ରୁ ବଡ ଯାହାକି ଦୁଇଟି ଛୋଟ ପ୍ରାକୃତିକ ସଂଖ୍ଯାର ଗୁଣନ ନୁହେଁ) ।\/\/\/ ଅଙ୍କ ଯାହା ଅକ୍ଷର ସଂଖ୍ୟା (ଅକ୍ଷର ସଂଖ୍ୟା, କିମ୍ବା ଏକ ଅକ୍ଷର, ଏକ ପ୍ରାକୃତିକ ସଂଖ୍ୟା \/\/\/ ଏକ ହେକ୍ସାଡେସିମାଲ୍ ସଂଖ୍ୟାକୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଭାବରେ ଗଣନା କରେ ଏବଂ ହେକ୍ସାଡେସିମାଲ୍ ସଂଖ୍ୟା ଗଣନା କରେ \/\/\/ ଆପଣଙ୍କୁ ଏକ ଫଳନ ଲେଖିବା ପାଇଁ କୁହାଯାଇଥିଲା ଯାହା ଗ୍ରହଣ କରିଥାଏ \/\/\/ >>> hex_key(String::from(\"AB\"))\n\/\/\/ 1\n\/\/\/ >>> hex_key(String::from(\"1077E\"))\n\/\/\/ 2\n\/\/\/ >>> hex_key(String::from(\"ABED1A33\"))\n\/\/\/ 4\n\/\/\/ >>> hex_key(String::from(\"123456789ABCDEF0\"))\n\/\/\/ 6\n\/\/\/ >>> hex_key(String::from(\"2020\"))\n\/\/\/ 2\nfn hex_key(num: String) -> isize {\n","canonical_solution":"fn hex_key(num: String) -> isize {\n    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars()\n        .filter(|c| prime_hex_chars.contains(c))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"},{"task_id":"HumanEval_79","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଅତିରିକ୍ତ ଅକ୍ଷରଗୁଡ଼ିକ ଫର୍ମାଟ ପାଇଁ ସାହାଯ୍ୟକାରୀ ।\/\/\/ ସ୍ଟ୍ରିଙ୍ଗର ଆରମ୍ଭ ଏବଂ ଶେଷରେ ଅତିରିକ୍ତ କିଛି ଅକ୍ଷର 'db' ରହିବ. \/\/\/ ସଂଖ୍ୟା. ଷ୍ଟ୍ରିଙ୍ଗରେ ଥିବା ପ୍ରତ୍ୟେକ ଅକ୍ଷର '0' କିମ୍ବା '1' ହେବ.\/\/\/ ବାଇନାରୀ ଫର୍ମାଟ. ଫଳନଟି ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇବ, ଯେଉଁଥିରେ ପ୍ରତ୍ୟେକ ଅକ୍ଷର ଏକ ବାଇନାରୀ \/\/\/ ଆପଣଙ୍କୁ ଏକ ଦଶମିକ ସଂଖ୍ୟା ଦିଆଯିବ ଏବଂ ଆପଣଙ୍କର କାମ ହେଉଛି ଏହାକୁ ରେ ପରିବର୍ତ୍ତନ କରିବା\/\/\/ >>> decimal_to_binary(15)\n\/\/\/ String::from(\"db1111db\")\n\/\/\/ >>> decimal_to_binary(32)\n\/\/\/ String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n","canonical_solution":"fn decimal_to_binary(decimal: isize) -> String {\n    let binary_string = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary_string)\n}\n\nfn main() {\n    \/\/ Example usage\n    let binary_15 = decimal_to_binary(15);\n    let binary_32 = decimal_to_binary(32);\n    println!(\"{}\", binary_15); \/\/ Outputs: db1111db\n    println!(\"{}\", binary_32); \/\/ Outputs: db100000db\n}","tests":"}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n}\n"},{"task_id":"HumanEval_80","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଗୋଟିଏ ଧାଡ଼ି haprs ହୋଇଥାଏ ଯଦି ଏହାର ଲମ୍ବ ଅତିକମରେ 3 ହୋଇଥାଏ ଏବଂ ପ୍ରତ୍ୟେକ 3ଟି କ୍ରମିକ ଅକ୍ଷର ଅଲଗା ହୋଇଥାଏ \/\/\/ ଆପଣଙ୍କର କାର୍ଯ୍ୟ ହେଉଛି ଯାଞ୍ଚ କରିବା କି ଏହି ଷ୍ଟ୍ରିଙ୍ଗଟି ଠିକ ଅଛି କି ନାହିଁ. \/\/\/ ଆପଣଙ୍କୁ ଏକ କ୍ରମ s ଦିଆଯାଉଛି. \/\/\/ >>> is_happy(String::from(\"a\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"aa\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"aabb\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"adb\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"xyy\"))\n\/\/\/ false\nfn is_happy(s: String) -> bool {\n","canonical_solution":"fn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n\n    let chars: Vec<char> = s.chars().collect();\n    for i in 0..(chars.len() - 2) {\n        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    println!(\"{}\", is_happy(String::from(\"a\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"aa\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"aabb\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"adb\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"xyy\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"},{"task_id":"HumanEval_81","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ 0.0 E \/\/\/ > 0.0 ଡି- \/\/\/ > 0.7 ଡି \/\/\/ > 1.0 ଡି+ \/\/\/ > 1.3 C- \/\/\/ > ୧.୭ ଡିଗ୍ରୀ ସେଲସିୟସ\/\/\/ > ୨.୦ ସି+ \/\/\/ > 2.3 ବି- \/\/\/ > 2.7 ବି \/\/\/ > 3.0 ବି+ \/\/\/ > 3.3 A- \/\/\/ > 3.7 A  ଏହା\/\/\/ 4.0 A+  ଏହା\/\/\/ GPA ∙ ଅକ୍ଷର ଗ୍ରେଡ୍ ∙\/\/\/ ଏକ ଫଳନ ଯାହା ନିମ୍ନଲିଖିତ ସାରଣୀ ବ୍ୟବହାର କରି ଅକ୍ଷର ମାନର ଏକ ଭେକ୍ଟର ବାହାର କରିପାରିବ: \/\/ସେ ଆପଣଙ୍କୁ କିଛି ଛାତ୍ରଙ୍କ ପାଇଁ GPA ର ଏକ ଭେକ୍ଟର ଦେଇଛନ୍ତି ଏବଂ ଆପଣଙ୍କୁ ଲେଖିବାକୁ ପଡିବ ।\/\/କେବଳ ଗୋଟିଏ ସମସ୍ୟା ହେଉଛି, ସେ ଗ୍ରେଡିଂ ପାଇଁ ବ୍ୟବହାର କରୁଥିବା କୋଡ୍ ହଜିଯାଇଛି ।\/\/ଶିକ୍ଷୟତ୍ରୀମାନେ ନିଜସ୍ୱ ଗ୍ରେଡିଂ ଆଲଗୋରିଦମ ପ୍ରସ୍ତୁତ କରୁଛନ୍ତି ।\/\/\/ ଏହା ସେମିଷ୍ଟରର ଶେଷ ସପ୍ତାହ ଏବଂ ଶିକ୍ଷକଙ୍କୁ ଗ୍ରେଡ୍ ଦେବାକୁ ହେବ \/\/\/ >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n\/\/\/ vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n","canonical_solution":"fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    grades.into_iter().map(|gpa| {\n        match gpa {\n            4.0 => String::from(\"A+\"),\n            v if v > 3.7 => String::from(\"A\"),\n            v if v > 3.3 => String::from(\"A-\"),\n            v if v > 3.0 => String::from(\"B+\"),\n            v if v > 2.7 => String::from(\"B\"),\n            v if v > 2.3 => String::from(\"B-\"),\n            v if v > 2.0 => String::from(\"C+\"),\n            v if v > 1.7 => String::from(\"C\"),\n            v if v > 1.3 => String::from(\"C-\"),\n            v if v > 1.0 => String::from(\"D+\"),\n            v if v > 0.7 => String::from(\"D\"),\n            v if v > 0.0 => String::from(\"D-\"),\n            _ => String::from(\"E\"),\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = numerical_letter_grade;\n    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]);\n    assert_eq!(candidate(vec![1.2]), vec![String::from(\"D+\")]);\n    assert_eq!(candidate(vec![0.5]), vec![String::from(\"D-\")]);\n    assert_eq!(candidate(vec![0.0]), vec![String::from(\"E\")]);\n    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(\"D\"), String::from(\"D-\"), String::from(\"C-\"), String::from(\"B\"), String::from(\"B+\")]);\n    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(\"E\"), String::from(\"D-\")]);\n}\n"},{"task_id":"HumanEval_82","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଲମ୍ବ ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା କିମ୍ବା ଅନ୍ୟଥା ମିଥ୍ୟା \/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ନେଇଥାଏ ଏବଂ ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଷ୍ଟ୍ରିଙ୍ଗ \/\/\/ >>> prime_length(String::from(\"Hello\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"abcdcba\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"kittens\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"orange\"))\n\/\/\/ false\nfn prime_length(string: String) -> bool {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn prime_length(string: String) -> bool {\n    let length = string.len();\n    is_prime(length)\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", prime_length(String::from(\"Hello\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"abcdcba\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"kittens\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"orange\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"},{"task_id":"HumanEval_83","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଯାହା 1 ରୁ ଆରମ୍ଭ କିମ୍ବା ଶେଷ ହୁଏ _\/\/\/ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, n-ଅଙ୍କ ବିଶିଷ୍ଟ ସଂଖ୍ୟାର ଗଣନା ଫେରାଇଦେବେ fn starts_one_ends(n: isize) -> isize {\n","canonical_solution":"fn starts_one_ends(n: isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1; \/\/ only '1' satisfies the condition for a single-digit\n    }\n\n    \/\/ Consider numbers starting with '1' (1XXXX...)\n    let start_with_one = 9isize.pow((n-1) as u32);\n\n    \/\/ Consider numbers ending with '1' (...XXXX1)\n    let end_with_one = 9isize.pow((n-1) as u32);\n    \n    \/\/ Consider numbers both starting and ending with '1' and check overlaps (1XXX1)\n    let both_start_end_one = 9isize.pow((n-2) as u32);\n\n    \/\/ Total numbers starting or ending with '1'\n    start_with_one + end_with_one - both_start_end_one\n}\n\nfn main() {\n    \/\/ Example usage:\n    let n = 3;\n    println!(\"Count of n-digit numbers starting or ending with 1: {}\", starts_one_ends(n));\n}","tests":"}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"},{"task_id":"HumanEval_84","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା N ଦିଆଗଲା, ଏହାର ଅଙ୍କଗୁଡ଼ିକର ସମୁଦାୟ ସମୁଦାୟକୁ ବାଇନାରୀରେ ଫେରାଇଦିଅନ୍ତୁ. \/\/\/ >>> solve(1000)\n\/\/\/ String::from(\"1\")\n\/\/\/ >>> solve(150)\n\/\/\/ String::from(\"110\")\n\/\/\/ >>> solve(147)\n\/\/\/ String::from(\"1100\")\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfn solve(N: isize) -> String {\n","canonical_solution":"fn solve(N: isize) -> String {\n    let sum_of_digits: isize = N\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as isize)\n        .sum();\n    \n    format!(\"{:b}\", sum_of_digits)\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(1000), String::from(\"1\"));\n    assert_eq!(candidate(150), String::from(\"110\"));\n    assert_eq!(candidate(147), String::from(\"1100\"));\n    assert_eq!(candidate(333), String::from(\"1001\"));\n    assert_eq!(candidate(963), String::from(\"10010\"));\n}\n"},{"task_id":"HumanEval_85","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଏକ ଅସରନ୍ତି ଭେକ୍ଟର ସମୁଦାୟ ସଂଖ୍ୟା lst ଦିଆଗଲା, ସେହି ସମ ସମକକ୍ଷ ଉପାଦାନଗୁଡ଼ିକୁ ଯୋଡ଼ନ୍ତୁ ଯାହା ଅଜଣା ସୂଚକାଙ୍କରେ ଅଛି.. \/\/\/ >>> add(vec![4, 2, 6, 7])\n\/\/\/ 2\nfn add(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn add(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, _)| i % 2 == 1) \/\/ select odd indices\n        .map(|(_, &x)| x) \/\/ get the values at odd indices\n        .filter(|&x| x % 2 == 0) \/\/ filter even values\n        .sum() \/\/ sum the values\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(vec![4, 88]), 88);\n    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);\n    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);\n    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);\n}\n"},{"task_id":"HumanEval_86","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଟିପ୍ପଣୀ: ଆପଣ ବାକ୍ୟର ଶଦ୍ଦକ୍ରମ ଏବଂ ଧାଡ଼ିରେ ଖାଲି ସ୍ଥାନକୁ ଧ୍ୟାନରେ ରଖିବା ଉଚିତ ।\/\/\/ ଅସ୍ଥି ମୂଲ୍ୟ ଆଧାରରେ କ୍ରମାନୁସାରେ ।\/\/\/ ଏକ ନୂଆ ଶବ୍ଦ ଦ୍ୱାରା ବଦଳାଯିବ ଯେଉଁଠାରେ ସମସ୍ତ ଅକ୍ଷର ରେ ସଜାଯାଇଛି ।\/\/\/ ଶୃଙ୍ଖଳାର ଆଦେଶିତ ସଂସ୍କରଣ, ଏକ ଶୃଙ୍ଖଳ ଯେଉଁଠାରେ ସମସ୍ତ ଶବ୍ଦ (ସ୍ପେସ୍ ଦ୍ୱାରା ପୃଥକ) \/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ନେଇଥାଏ ଏବଂ ଏହାର ଏକ ଅର୍ଡର ହୋଇଥିବା ସଂସ୍କରଣ ଫେରାଇଥାଏ. \/\/\/ >>> anti_shuffle(String::from(\"Hi\"))\n\/\/\/ String::from(\"Hi\")\n\/\/\/ >>> anti_shuffle(String::from(\"hello\"))\n\/\/\/ String::from(\"ehllo\")\n\/\/\/ >>> anti_shuffle(String::from(\"Hello World!!!\"))\n\/\/\/ String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n","canonical_solution":"fn anti_shuffle(s: String) -> String {\n    let mut result = String::new();\n    let mut word = String::new();\n\n    for c in s.chars() {\n        if c.is_whitespace() {\n            if !word.is_empty() {\n                let mut chars: Vec<char> = word.chars().collect();\n                chars.sort_unstable();\n                result.push_str(&chars.into_iter().collect::<String>());\n                word.clear();\n            }\n            result.push(c);\n        } else {\n            word.push(c);\n        }\n    }\n\n    if !word.is_empty() {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort_unstable();\n        result.push_str(&chars.into_iter().collect::<String>());\n    }\n\n    result\n}\n\nfn main() {\n    \/\/ Example usages:\n    println!(\"{}\", anti_shuffle(String::from(\"Hi\")));              \/\/ \"Hi\"\n    println!(\"{}\", anti_shuffle(String::from(\"hello\")));           \/\/ \"ehllo\"\n    println!(\"{}\", anti_shuffle(String::from(\"Hello World!!!\")));  \/\/ \"Hello !!!Wdlor\"\n}","tests":"}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"},{"task_id":"HumanEval_87","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଏହା ସହିତ, ଧାଡ଼ିର କୋଅର୍ଡିନେଟଗୁଡ଼ିକୁ କ୍ରମବର୍ଦ୍ଧିଷ୍ଣୁ କ୍ରମରେ ସ୍ତମ୍ଭ ଅନୁସାରେ ସର୍ଟ କରନ୍ତୁ. \/\/\/ ଅକ୍ଷରଗୁଡ଼ିକୁ ପ୍ରଥମେ ଧାଡ଼ି ଅନୁସାରେ କ୍ରମାନୁସାରେ ସଜାଡ଼ନ୍ତୁ ।\/\/\/ ପ୍ରତ୍ୟେକ ଟାପୁଲ ହେଉଛି ଏକ କୋର୍ଡିନେଟ - (ଶୃଙ୍ଖଳା, ସ୍ତମ୍ଭ), 0 ରୁ ଆରମ୍ଭ ।\/\/\/ ଏବଂ ଟାପୁଲର ରିଟର୍ଣ୍ଣ ଭେକ୍ଟର, [(x1, y1), (x2, y2) ...] ଏପରି ଯେ \/\/lst, ଏବଂ ସଂଖ୍ଯା x ଦିଆୟାଇଥିବା, ଭେକ୍ଟର ରେ ସଂଖ୍ଯା x ଖୋଜ, \/\/\/ ପ୍ରତ୍ୟେକ ଧାଡ଼ିରେ ଭିନ୍ନ ଭିନ୍ନ ସଂଖ୍ୟକ ସ୍ତମ୍ଭ ରହିପାରେ ।\/\/\/ ଯାହା ମାଟ୍ରିକ୍ସ ସହିତ ସମାନ, କିନ୍ତୁ ମାଟ୍ରିକ୍ସ ପରି ନୁହେଁ, \/\/\/ ଆପଣଙ୍କୁ ଏକ 2D ତଥ୍ୟ ଦିଆଯାଉଛି, ଏକ ନେଷ୍ଟେଡ୍ ଭେକ୍ଟର ଭାବରେ, \/\/\/ >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n\/\/\/ vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(vec![], 1)\n\/\/\/ Vec::<(isize, isize)>::new()\n\/\/\/ >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n\/\/\/ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n","canonical_solution":"fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut result = Vec::new();\n\n    for (row_index, row) in lst.iter().enumerate() {\n        let mut found_indices: Vec<isize> = row.iter()\n            .enumerate()\n            .filter(|&(_, &value)| value == x)\n            .map(|(col_index, _)| col_index as isize)\n            .collect();\n\n        found_indices.sort_by(|a, b| b.cmp(a)); \/\/ Sort column indices in descending order\n\n        for col_index in found_indices {\n            result.push((row_index as isize, col_index));\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"},{"task_id":"HumanEval_88","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ * ଦିଆଯାଇଥିବା ଭେକ୍ଟରକୁ ପରିବର୍ତ୍ତନ କରନ୍ତୁ ନାହିଁ. \/\/\/ ଟିପ୍ପଣୀ: \/\/\/ କିମ୍ବା ଏହାକୁ କ୍ରମାନୁସାରେ ସର୍ଟ କରନ୍ତୁ ଯଦି ସମୁଦାୟ (ପ୍ରଥମ ସୂଚକାଙ୍କ ମୂଲ୍ୟ, ଶେଷ ସୂଚକାଙ୍କ ମୂଲ୍ୟ) ଯୁଗ୍ମ ଅଟେ ।\/\/\/ ଆପଣ ଦିଆଯାଇଥିବା ଭେକ୍ଟରକୁ କ୍ରମାନୁସାରେ ସର୍ଟ କରିବେ ଯଦି ସମୁଦାୟ (ପ୍ରଥମ ଇଣ୍ଡେକ୍ସ ମୂଲ୍ୟ, ଶେଷ ଇଣ୍ଡେକ୍ସ ମୂଲ୍ୟ) ଅଙ୍କ ବିଶିଷ୍ଟ, \/\/\/ ନନ୍-ନଗେଟିଭ୍ ଇଣ୍ଟେଜର ଭେକ୍ଟର ଦିଆଯାଇଥାଏ, ସର୍ଟ କରିବା ପରେ ଦିଆଯାଇଥିବା ଭେକ୍ଟରର ଏକ କୋର୍ସ ଫେରାଇ ଦିଅନ୍ତୁ, \/\/\/ >>> sort_array(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> sort_array(vec![5])\n\/\/\/ vec![5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n\/\/\/ vec![0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n\/\/\/ vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::<isize>::new();\n    }\n\n    let first = array.first().unwrap_or(&0);\n    let last = array.last().unwrap_or(&0);\n    let sum = first + last;\n\n    let mut sorted_array = array.clone();\n    if sum % 2 == 0 {\n        sorted_array.sort_by(|a, b| b.cmp(a)); \/\/ Descending order\n    } else {\n        sorted_array.sort(); \/\/ Ascending order\n    }\n\n    sorted_array\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", sort_array(vec![])); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", sort_array(vec![5])); \/\/ vec![5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5])); \/\/ vec![0, 1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); \/\/ vec![6, 5, 4, 3, 2, 1, 0]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"},{"task_id":"HumanEval_89","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଦୁଇଗୁଣିତ କରି ଦୁଇ ସ୍ଥାନକୁ ଘୁଞ୍ଚାଇବେ ।\/\/\/ ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର ଅକ୍ଷରଗୁଡ଼ିକର\/\/\/ ଆଲଫାବେଟକୁ ଘୁଞ୍ଚାଇ ଏକ ଏନକ୍ରିପ୍ଟ ହୋଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇଥାଏ. \/\/\/ ଏକ ଫଳନ ଏନକ୍ରିପ୍ଟ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ଷ୍ଟ୍ରିଙ୍ଗକୁ ଏକ ତର୍କ ଭାବରେ ଗ୍ରହଣ କରିଥାଏ ଏବଂ \/\/\/ >>> encrypt(String::from(\"hi\"))\n\/\/\/ String::from(\"lm\")\n\/\/\/ >>> encrypt(String::from(\"asdfghjkl\"))\n\/\/\/ String::from(\"ewhjklnop\")\n\/\/\/ >>> encrypt(String::from(\"gf\"))\n\/\/\/ String::from(\"kj\")\n\/\/\/ >>> encrypt(String::from(\"et\"))\n\/\/\/ String::from(\"ix\")\nfn encrypt(s: String) -> String {\n","canonical_solution":"fn encrypt(s: String) -> String {\n    s.chars()\n        .map(|c| {\n            if c.is_ascii_lowercase() {\n                let offset = (c as u8 - b'a' + 4) % 26;\n                (b'a' + offset) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"},{"task_id":"HumanEval_90","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏପରି କୌଣସି ଉପାଦାନ ନ ଥିଲେ None ଫେରାଇଦେବେ. \/\/\/ ଏକ ଫଙ୍କସନ next_smallest ଲେଖନ୍ତୁ ଯାହା ଭେକ୍ଟରର ଦ୍ବିତୀୟ କ୍ଷୁଦ୍ରତମ ଉପାଦାନକୁ ଫେରାଇଥାଏ. \/\/\/ ଆପଣଙ୍କୁ ଏକ ଭେକ୍ଟର ଦିଆଯାଉଛି.\/\/\/ >>> next_smallest(vec![1, 2, 3, 4, 5])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![5, 1, 4, 3, 2])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![])\n\/\/\/ None\n\/\/\/ >>> next_smallest(vec![1, 1])\n\/\/\/ None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();\n    if unique_elements.len() < 2 {\n        return None;\n    }\n    unique_elements.sort();\n    Some(unique_elements[1])\n}\n\nfn main() {\n    println!(\"{:?}\", next_smallest(vec![1, 2, 3, 4, 5])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![5, 1, 4, 3, 2])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![])); \/\/ None\n    println!(\"{:?}\", next_smallest(vec![1, 1])); \/\/ None\n}","tests":"}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"},{"task_id":"HumanEval_91","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ବାକ୍ୟଗୁଡ଼ିକ '', '?' କିମ୍ବା '!' ଦ୍ୱାରା ସୀମିତ ।\/\/ଏକ ବିରକ୍ତି ହେଉଛି ଏକ ବାକ୍ୟ ଯାହା \"ମୁଁ\" ଶବ୍ଦ ସହିତ ଆରମ୍ଭ ହୁଏ ।\/\/\/ ଆପଣଙ୍କୁ ଏକ ଶବ୍ଦ ଶୃଙ୍ଖଳ ଦିଆଯିବ, ଏବଂ ଆପଣଙ୍କର କାର୍ଯ୍ୟ ହେଉଛି ସଂଖ୍ୟା ଗଣନା କରିବା \/\/\/ >>> is_bored(String::from(\"Hello world\"))\n\/\/\/ 0\n\/\/\/ >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n\/\/\/ 1\nfn is_bored(S: String) -> isize {\n","canonical_solution":"fn is_bored(S: String) -> isize {\n    S.split(|c| c == '.' || c == '?' || c == '!')\n        .filter(|sentence| sentence.trim_start().starts_with(\"I\"))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n"},{"task_id":"HumanEval_92","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଅନ୍ୟ କୌଣସି କ୍ଷେତ୍ରରେ ମିଥ୍ୟା ଫେରାଇଥାଏ. \/\/\/ ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଏକ ସଂଖ୍ୟା ଅନ୍ୟ ଦୁଇଟିର ସମୁଦାୟ ସହିତ ସମାନ ହୋଇଥାଏ, ଏବଂ ସମସ୍ତ ସଂଖ୍ୟା ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ହୋଇଥାଏ \/\/\/ ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହା 3ଟି ସଂଖ୍ୟା ଗ୍ରହଣ କରେ. \/\/\/ >>> any_int(5, 2, 7)\n\/\/\/ true\n\/\/\/ >>> any_int(3, 2, 2)\n\/\/\/ false\n\/\/\/ >>> any_int(3, -2, 1)\n\/\/\/ true\n\/\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/\/ false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n","canonical_solution":"fn any_int(x: f64, y: f64, z: f64) -> bool {\n    \/\/ Check if all the numbers are integers\n    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {\n        \/\/ Convert f64 to i64 because they are integers\n        let xi = x as i64;\n        let yi = y as i64;\n        let zi = z as i64;\n\n        \/\/ Check if any one of the numbers is equal to the sum of the other two\n        xi == yi + zi || yi == xi + zi || zi == xi + yi\n    } else {\n        false\n    }\n}\n\nfn main() {\n    \/\/ Examples\n    println!(\"{}\", any_int(5.0, 2.0, 7.0)); \/\/ true\n    println!(\"{}\", any_int(3.0, 2.0, 2.0)); \/\/ false\n    println!(\"{}\", any_int(3.0, -2.0, 1.0)); \/\/ true\n    println!(\"{}\", any_int(3.6, -2.2, 2.0)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"},{"task_id":"HumanEval_93","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ କେବଳ ଅକ୍ଷର ମାନି ନିଅନ୍ତୁ ।\/\/\/ ଇଂରାଜୀ ଅକ୍ଷର ଅକ୍ଷରରେ ସ୍ୱର ।\/\/\/ ସେହି ଅକ୍ଷର ସହିତ ସନ୍ଦେଶ ଯାହା 2 ଟି ସ୍ଥାନ ପୂର୍ବରୁ ଦେଖାଯାଏ \/\/\/ ଏହିପରି ଭାବରେ ଏହା ସମସ୍ତ ଅକ୍ଷର ଗୁଡିକର କେସ୍ ବଦଳାଇଥାଏ,  ରେ ସମସ୍ତ ସ୍ୱରଗୁଡିକର ସ୍ଥାନ ନେଇଥାଏ\/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ସନ୍ଦେଶ ଗ୍ରହଣ କରେ, ଏବଂ ଏପରି ଏକ \/\/\/ >>> encode(String::from(\"test\"))\n\/\/\/ String::from(\"TGST\")\n\/\/\/ >>> encode(String::from(\"This is a message\"))\n\/\/\/ String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n","canonical_solution":"fn encode(message: String) -> String {\n    message.chars().map(|c| {\n        match c {\n            'a' => 'C',\n            'e' => 'G',\n            'i' => 'K',\n            'o' => 'Q',\n            'u' => 'W',\n            'A' => 'c',\n            'E' => 'g',\n            'I' => 'k',\n            'O' => 'q',\n            'U' => 'w',\n            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"},{"task_id":"HumanEval_94","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଆପଣଙ୍କୁ ସବୁଠାରୁ ବଡ ଅକ୍ଷର ମୂଲ୍ୟ ଖୋଜିବାକୁ ହେବ ଏବଂ ଏହାର ଅଙ୍କଗୁଡିକର ସମୁଦାୟ ଫେରାଇବାକୁ ହେବ. \/\/\/ ଆପଣଙ୍କୁ ଏକ ଭେକ୍ଟର ଦିଆଯାଉଛି.\/\/\/ >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn digit_sum(n: isize) -> isize {\n    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()\n}\n\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    match lst.into_iter().filter(is_prime).max() {\n        Some(max_prime) => digit_sum(max_prime),\n        None => 0,\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n"},{"task_id":"HumanEval_95","nl":"ory_Orya","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ ଉଦାହରଣ: \/\/\/ ଫଳନଟି false ଫେରାଇବ ଯଦି ଦିଆଯାଇଥିବା ହ୍ୟାସମ୍ୟାପଟି ଖାଲି ଥାଏ ।\/\/\/ କେସ୍ କିମ୍ବା ସମସ୍ତ କିଗୁଡ଼ିକ ବଡ଼ ଅକ୍ଷରରେ ଥିବା ଷ୍ଟ୍ରିଙ୍ଗ୍, ନଚେତ୍ false ଫେରାଇଥାଏ.\/\/\/ ଏକ ହ୍ୟାସମ୍ୟାପ ଦିଆଯାଇଥିବା, ଯଦି ସମସ୍ତ କି ଗୁଡିକ ତଳ ଠାରେ ଥିବା ଷ୍ଟ୍ରିଙ୍ଗ୍  ହୋଇଥାଏ ତେବେ true କୁ ଫେରାଇଥାଏ\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n\/\/\/ true\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n\/\/\/ true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n","canonical_solution":"use std::collections::HashMap;\n\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return false;\n    }\n\n    let mut lowercase = true;\n    let mut uppercase = true;\n\n    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_lowercase()) {\n            lowercase = false;\n        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            uppercase = false;\n        }\n    }\n\n    lowercase || uppercase\n}\n\nfn main() {\n    let dict1 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict1), true);\n\n    let dict2 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict2), false);\n\n    let dict3 = HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]);\n    assert_eq!(check_dict_case(dict3), true);\n\n    let dict4 = HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]);\n    assert_eq!(check_dict_case(dict4), false);\n}","tests":"}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"},{"task_id":"HumanEval_96","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଯାହା ଅଶୂନ୍ୟ ସଂଖ୍ୟା ଏବଂ n ରୁ ଛୋଟ ।\/\/\/ ଏକ ଫଳନକୁ କାର୍ଯ୍ୟକାରୀ କରନ୍ତୁ ଯାହା ଏକ ନନ୍-ନଗେଟିଭ୍ ଇଣ୍ଟେଜର ନେଇଥାଏ ଏବଂ ପ୍ରଥମ n ର ଭେକ୍ଟର ଫେରାଇଥାଏ \/\/\/ >>> count_up_to(5)\n\/\/\/ vec![2, 3]\n\/\/\/ >>> count_up_to(11)\n\/\/\/ vec![2, 3, 5, 7]\n\/\/\/ >>> count_up_to(0)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(20)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(1)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(18)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n","canonical_solution":"fn count_up_to(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\n    for num in 2..n {\n        let mut is_prime = true;\n\n        for divisor in 2..=((num as f64).sqrt() as isize) {\n            if num % divisor == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n\n        if is_prime {\n            primes.push(num);\n        }\n    }\n\n    primes\n}\n\nfn main() {\n    println!(\"{:?}\", count_up_to(5)); \/\/ vec![2, 3]\n    println!(\"{:?}\", count_up_to(11)); \/\/ vec![2, 3, 5, 7]\n    println!(\"{:?}\", count_up_to(0)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(20)); \/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n    println!(\"{:?}\", count_up_to(1)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(18)); \/\/ vec![2, 3, 5, 7, 11, 13, 17]\n}","tests":"}\n\nfn main() {\n    let candidate = count_up_to;\n    assert_eq!(candidate(5), vec![2, 3]);\n    assert_eq!(candidate(6), vec![2, 3, 5]);\n    assert_eq!(candidate(7), vec![2, 3, 5]);\n    assert_eq!(candidate(10), vec![2, 3, 5, 7]);\n    assert_eq!(candidate(0), Vec::<isize>::new());\n    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    assert_eq!(candidate(1), Vec::<isize>::new());\n    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n"},{"task_id":"HumanEval_97","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଧରନ୍ତୁ ଯେ ଇନପୁଟ୍ ସର୍ବଦା ବୈଧ ଅଟେ ।\/\/\/ ସେମାନଙ୍କର ଏକକ ଅଙ୍କ ଗୁଡ଼ିକର ଗୁଣନ ।\/\/\/ ଫଳନକୁ ପୂର୍ଣ୍ଣ କରନ୍ତୁ ଯାହାକି ଦୁଇଟି ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ନେଇଥାଏ ଏବଂ ଫେରାଇଥାଏ \/\/\/ >>> multiply(148, 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(19, 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(2020, 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(14, -15)\n\/\/\/ 20\nfn multiply(a: isize, b: isize) -> isize {\n","canonical_solution":"fn multiply(a: isize, b: isize) -> isize {\n    let unit_digit_a = (a % 10).abs();\n    let unit_digit_b = (b % 10).abs();\n    unit_digit_a * unit_digit_b\n}","tests":"}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"},{"task_id":"HumanEval_98","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଗୋଟିଏ ଧାଡ଼ି s ଦିଆଗଲା, ସମ ସୂଚକାଙ୍କରେ ଥିବା ବଡ଼ ଅକ୍ଷର ସ୍ୱରଗୁଡ଼ିକର ସଂଖ୍ୟା ଗଣନା କରନ୍ତୁ. \/\/\/ >>> count_upper(String::from(\"aBCdEf\"))\n\/\/\/ 1\n\/\/\/ >>> count_upper(String::from(\"abcdefg\"))\n\/\/\/ 0\n\/\/\/ >>> count_upper(String::from(\"dBBE\"))\n\/\/\/ 0\nfn count_upper(s: String) -> isize {\n","canonical_solution":"fn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(i, c)| {\n        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')\n    }).count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"},{"task_id":"HumanEval_99","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଦୁଇଟି ସମୁଦାୟ ସଂଖ୍ୟାରୁ, ଏହାକୁ ଶୂନରୁ ଦୂର କରି ଘୋଡ଼ାଇ ଦିଅନ୍ତୁ.\/\/\/ ଏବଂ ଏହା ନିକଟତମ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାକୁ ଫେରାଇଥାଏ. ଯଦି ସଂଖ୍ୟା ସମାନ ଦୂରତା \/\/\/ ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ସଂଖ୍ୟାକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ମୂଲ୍ୟ (ଷ୍ଟ୍ରିଙ୍ଗ) ଗ୍ରହଣ କରିଥାଏ \/\/\/ >>> closest_integer(String::from(\"10\"))\n\/\/\/ 10\n\/\/\/ >>> closest_integer(String::from(\"15.3\"))\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n","canonical_solution":"fn closest_integer(value: String) -> isize {\n    let num: f64 = value.parse().expect(\"Invalid number format\");\n    if num.fract().abs() == 0.5 {\n        if num.is_sign_positive() {\n            num.ceil() as isize\n        } else {\n            num.floor() as isize\n        }\n    } else {\n        num.round() as isize\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", closest_integer(String::from(\"10\")));   \/\/ Output: 10\n    println!(\"{}\", closest_integer(String::from(\"15.3\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"14.5\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"-14.5\"))); \/\/ Output: -15\n}","tests":"}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"},{"task_id":"HumanEval_100","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ i ସ୍ତରରେ ପଥର ସଂଖ୍ୟାକୁ ଦର୍ଶାଏ (i+1) ।\/\/\/ ଏକ ଭେକ୍ଟରରେ ପ୍ରତ୍ୟେକ ସ୍ତରରେ ପଥର ସଂଖ୍ୟା ଫେରାଇଥାଏ, ଯେଉଁଠାରେ ସୂଚକାଙ୍କରେ ଉପାଦାନ \/\/\/ - ପରବର୍ତ୍ତୀ ଯୁଗ୍ମ ସଂଖ୍ୟା ଯଦି n ଯୁଗ୍ମ ଅଟେ ।\/\/\/ - ପରବର୍ତ୍ତୀ ଅଙ୍କ ଯଦି n ଅଙ୍କ ଅଙ୍କ ଅଟେ ।\/\/ପରବର୍ତ୍ତୀ ସ୍ତରରେ ପଥର ସଂଖ୍ୟା ହେଉଛି:\/\/ପ୍ରଥମ ସ୍ତରରେ n ଟି ପଥର ଅଛି ।\/\/\/ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ଆପଣଙ୍କୁ ପଥରର n ସ୍ତରର ଏକ ଗଦା ତିଆରି କରିବାକୁ ହେବ. \/\/\/ >>> make_a_pile(3)\n\/\/\/ vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n","canonical_solution":"fn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n    let mut current = n;\n    \n    for _ in 0..n {\n        pile.push(current);\n        current = if n % 2 == 1 {\n            current + 2\n        } else {\n            current + 2\n        };\n    }\n    \n    pile\n}\n\nfn main() {\n    let level = make_a_pile(3);\n    println!(\"{:?}\", level);\n}","tests":"}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"},{"task_id":"HumanEval_101","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଶବ୍ଦକୁ ବାକ୍ୟରେ ବିଭକ୍ତ କରିବା ପାଇଁ ଏବଂ ଶବ୍ଦଗୁଡ଼ିକର ଏକ ଭେକ୍ଟର ଫେରାଇବ _\/\/ଆପଣଙ୍କୁ ଏକ ଶବ୍ଦ ଶୃଙ୍ଖଳ ଦିଆଯିବ, ଯାହାକୁ କମା କିମ୍ବା ସ୍ପେସ୍ ଦ୍ୱାରା ପୃଥକ କରାଯିବ । ଆପଣଙ୍କ କାର୍ଯ୍ୟ ହେଉଛି \/\/\/ >>> words_string(String::from(\"Hi, my name is John\"))\n\/\/\/ vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n\/\/\/ >>> words_string(String::from(\"One, two, three, four, five, six\"))\n\/\/\/ vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n","canonical_solution":"fn words_string(s: String) -> Vec<String> {\n    s.split(|c: char| c.is_whitespace() || c == ',')\n        .filter(|word| !word.is_empty())\n        .map(String::from)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = words_string;\n    assert_eq!(candidate(String::from(\"Hi, my name is John\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]);\n    assert_eq!(candidate(String::from(\"One, two, three, four, five, six\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"Hi, my name\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\")]);\n    assert_eq!(candidate(String::from(\"One,, two, three, four, five, six,\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"ahmed     , gamal\")), vec![String::from(\"ahmed\"), String::from(\"gamal\")]);\n}\n"},{"task_id":"HumanEval_102","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଯଦି ସେପରି କୌଣସି ସଂଖ୍ୟା ନଥାଏ, ତେବେ ଫଳନ -1 ଫେରାଇବ _\/\/\/ ସବୁଠାରୁ ବଡ ଯୁଗ୍ମ ସଂଖ୍ଯା ଯାହା [x, y] ଅନ୍ତର୍ଭୁକ୍ତ ରେ ଅଛି. ଯଦି \/\/\/ ଏହି ଫଳନ ଦୁଇଟି ସକାରାତ୍ମକ ସଂଖ୍ୟା x ଓ y ନେଇଥାଏ ଏବଂ  କୁ ଫେରାଇଥାଏ\/\/\/ >>> choose_num(12, 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(13, 12)\n\/\/\/ -1\nfn choose_num(x: isize, y: isize) -> isize {\n","canonical_solution":"fn choose_num(x: isize, y: isize) -> isize {\n    let (start, end) = if x < y { (x, y) } else { (y, x) };\n    for n in (start..=end).rev() {\n        if n % 2 == 0 {\n            return n;\n        }\n    }\n    -1\n}\n\nfn main() {\n    println!(\"{}\", choose_num(12, 15)); \/\/ 14\n    println!(\"{}\", choose_num(13, 12)); \/\/ -1\n}","tests":"}\n\nfn main() {\n    let candidate = choose_num;\n    assert_eq!(candidate(12, 15), 14);\n    assert_eq!(candidate(13, 12), -1);\n    assert_eq!(candidate(33, 12354), 12354);\n    assert_eq!(candidate(5234, 5233), -1);\n    assert_eq!(candidate(6, 29), 28);\n    assert_eq!(candidate(27, 10), -1);\n    assert_eq!(candidate(7, 7), -1);\n    assert_eq!(candidate(546, 546), 546);\n}\n"},{"task_id":"HumanEval_104","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଟିପ୍ପଣୀ: ଫେରସ୍ତ ଭେକ୍ଟରକୁ ବୃଦ୍ଧି କ୍ରମରେ ସର୍ଟ କରାଯିବା ଉଚିତ ।\/\/\/ ଉପାଦାନ ଯାହା କୌଣସି ଯୁଗ୍ମ ଅଙ୍କ ନଥାଏ. \/\/\/ ଧନାତ୍ମକ ସମୁଦାୟ ସଂଖ୍ଯା x ର ଏକ ଭେକ୍ଟର ଦିଆୟାଇଥାଏ , ସମସ୍ତ  ର ଏକ ସର୍ଟ ଭେକ୍ଟର ଫେରାଇଥାଏ\/\/\/ >>> unique_digits(vec![15, 33, 1422, 1])\n\/\/\/ vec![1, 15, 33]\n\/\/\/ >>> unique_digits(vec![152, 323, 1422, 10])\n\/\/\/ Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = x.into_iter()\n        .filter(|&num| {\n            num.to_string().chars().all(|c| {\n                match c {\n                    '0' | '2' | '4' | '6' | '8' => false,\n                    _ => true,\n                }\n            })\n        })\n        .collect();\n    result.sort();\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = unique_digits;\n    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);\n    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());\n    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);\n    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);\n}\n"},{"task_id":"HumanEval_105","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ \"ଏକ\", \"ଦୁଇ\", \"ତିନି\", \"ଚାରି\", \"ପାଞ୍ଚ\", \"ଷ, \"ସାତ\", \"ଆଠ\", \"ନଅ\" \/\/\/ ଫଳସ୍ୱରୂପ ଭେକ୍ଟରକୁ ଓଲଟାଇ, ଏବଂ ତାପରେ ପ୍ରତ୍ୟେକ ଅଙ୍କକୁ ଏହାର ଅନୁରୂପ ନାମ ସହିତ  ରୁ ବଦଳାନ୍ତୁ\/\/\/ ଏକ ଭେକ୍ଟର ଦିଆଯାଇଥିବା ସମୁଦାୟ ସଂଖ୍ୟାକୁ 1 ରୁ 9 ସମେତ ସମୁଦାୟ ସଂଖ୍ୟାକୁ ସର୍ଟ କରନ୍ତୁ, \/\/\/ >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n\/\/\/ If the vector is empty, return an empty vector:\n\/\/\/ >>> by_length(vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ If the vector has any strange number ignore it:\n\/\/\/ >>> by_length(vec![1, -1, 55])\n\/\/\/ vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n","canonical_solution":"fn by_length(arr: Vec<isize>) -> Vec<String> {\n    let digit_names = [\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \n        \"Six\", \"Seven\", \"Eight\", \"Nine\",\n    ];\n\n    let mut filtered: Vec<isize> = arr.into_iter()\n        .filter(|&x| x >= 1 && x <= 9)\n        .collect();\n\n    filtered.sort();\n    filtered.reverse();\n\n    filtered.into_iter()\n        .map(|x| String::from(digit_names[(x - 1) as usize]))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"},{"task_id":"HumanEval_106","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ i ର କାରକ ହେଉଛି 1 ରୁ i ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ଯାଗୁଡ଼ିକର ଗୁଣନ (1 * 2 * ... * i) ।\/\/\/i 1 ରୁ ଆରମ୍ଭ ହୋଇଥାଏ ।\/\/\/ କିମ୍ବା 1 ରୁ i ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ୟାର ସମୁଦାୟ ଅନ୍ୟଥା ।\/\/\/ ଏବଂ n ଆକାରର ଏକ ଭେକ୍ଟର ଫେରାଇଥାଏ, ଯେପରିକି ସୂଚକାଙ୍କ i ରେ ଥିବା ଉପାଦାନର ମୂଲ୍ୟ i ର କାରକ ଅଟେ ଯଦି i ଯୁଗ୍ମ \/\/\/ f ଫଳନକୁ କାର୍ଯ୍ୟକାରୀ କରନ୍ତୁ ଯାହା n କୁ ଏକ ପାରାମିଟର ଭାବରେ ଗ୍ରହଣ କରେ, \/\/\/ >>> f(5)\n\/\/\/ vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n","canonical_solution":"fn f(n: isize) -> Vec<isize> {\n    fn factorial(x: isize) -> isize {\n        (1..=x).product()\n    }\n\n    fn sum_up_to(x: isize) -> isize {\n        (1..=x).sum()\n    }\n\n    (1..=n)\n        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);\n    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);\n    assert_eq!(candidate(1), vec![1]);\n    assert_eq!(candidate(3), vec![1, 2, 6]);\n}\n"},{"task_id":"HumanEval_107","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ 1: \/\/\/ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ପଲିଣ୍ଡ୍ରୋମ ଯାହା ଅନ୍ତର୍ଗତ ଆସେ ({1, n), ଅନ୍ତର୍ଭୁକ୍ତ) ।\/\/\/ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ଏକ ଟାପଲ୍ ଫେରାଇ ଦିଅନ୍ତୁ ଯାହାର ସମ ଓ ଅଙ୍କ ସଂଖ୍ୟା ଅଛି \/\/\/ >>> even_odd_palindrome(3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n","canonical_solution":"fn is_palindrome(x: isize) -> bool {\n    let s = x.to_string();\n    s == s.chars().rev().collect::<String>()\n}\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    \n    for i in 1..=n {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_palindrome;\n    assert_eq!(candidate(123), (8, 13));\n    assert_eq!(candidate(12), (4, 6));\n    assert_eq!(candidate(3), (1, 2));\n    assert_eq!(candidate(63), (6, 8));\n    assert_eq!(candidate(25), (5, 6));\n    assert_eq!(candidate(19), (4, 6));\n    assert_eq!(candidate(9), (4, 5));\n    assert_eq!(candidate(1), (0, 1));\n}\n"},{"task_id":"HumanEval_108","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ -123ର ଅଙ୍କ -1, 2 ଏବଂ 3ରେ ହସ୍ତାକ୍ଷର ରହିଛି ।\/\/\/ ଯଦି କୌଣସି ସଂଖ୍ୟା ନକାରାତ୍ମକ ହୋଇଥାଏ, ତେବେ ଏହାର ପ୍ରଥମ ଅଙ୍କ ନକାରାତ୍ମକ ହେବ: \/\/\/ ସେହି ଉପାଦାନର ସଂଖ୍ୟା ଯାହାର ଅଙ୍କ ସମୂହ 0 ରୁ ଅଧିକ ।\/\/\/ ଏକ ଫଙ୍କସନ୍ count_nums ଲେଖନ୍ତୁ ଯାହା ଏକ ଭେକ୍ଟର ନେଇଥାଏ ଏବଂ ଫେରାଇଥାଏ \/\/\/ >>> count_nums(vec![])\n\/\/\/ 0\n\/\/\/ >>> count_nums(vec![-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(vec![1, 1, 2])\n\/\/\/ 3\nfn count_nums(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn count_nums(arr: Vec<isize>) -> isize {\n    arr.into_iter()\n        .filter(|&num| {\n            let mut n = num;\n            let mut sum = 0;\n            let mut is_first_digit = true;\n\n            while n != 0 {\n                let digit = if is_first_digit {\n                    is_first_digit = false;\n                    n % 10\n                } else {\n                    (n % 10).abs()\n                };\n                sum += digit;\n                n \/= 10;\n            }\n            sum > 0\n        })\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n"},{"task_id":"HumanEval_109","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଟିପ୍ପଣୀ: ଦିଆଯାଇଥିବା ଭେକ୍ଟରରେ ଅନନ୍ୟ ଉପାଦାନ ଥିବା ସୁନିଶ୍ଚିତ ।\/\/\/ ଯଦି ଦିଆଯାଇଥିବା ଭେକ୍ଟରଟି ଖାଲି ହୋଇଥାଏ ତେବେ true କୁ ଫେରାଇଦିଏ.\/\/\/ ତାପରେ true କୁ ଫେରାଇଦିଅନ୍ତୁ ନଚେତ୍ false କୁ ଫେରାଇଦିଅନ୍ତୁ.\/\/\/ ଯଦି ଉପରୋକ୍ତ କାର୍ଯ୍ୟ କରି ସର୍ଟ ହୋଇଥିବା ଭେକ୍ଟର ପାଇବା ସମ୍ଭବ ହୁଏ \/\/\/ ଭେକ୍ଟରରେ ଆରମ୍ଭ ସ୍ଥିତି ଅର୍ଥାତ୍ 0th ସୂଚକାଙ୍କ ।\/\/\/ ସଠିକ ଦିଗରେ ସ୍ଥିତିକୁ ନେଇଥାଏ. ଭେକ୍ଟରର ଶେଷ ଉପାଦାନକୁ କୁ ସ୍ଥାନାନ୍ତରିତ କରାଯିବ\/\/\/ ଗୋଟିଏ ଡାହାଣକୁ ଘୁଞ୍ଚିବା କାର୍ଯ୍ୟ ଅର୍ଥାତ୍ ଭେକ୍ଟରର ସମସ୍ତ ଉପାଦାନକୁ ଗୋଟିଏ ଘୁଞ୍ଚାଇବା ।\/\/\/ ଆପଣ ଯେତେଥର ଚାହିଁବେ ଡାହାଣକୁ ଘୁଞ୍ଚାଇ ପାରିବେ ।\/\/\/ ଦିଆଯାଇଥିବା ଭେକ୍ଟର ଉପରେ ନିମ୍ନଲିଖିତ କାର୍ଯ୍ୟାନୁଷ୍ଠାନ: \/\/\/ ଏହା ସମ୍ଭବ ଯେ ଏକ ଭେକ୍ଟରକୁ ଅଣ-କ୍ରମବର୍ଦ୍ଧକ କ୍ରମରେ ସଜାଡ଼ିବା ପାଇଁ \/\/\/ ଭେକ୍ଟରରେ ଥିବା ସଂଖ୍ୟାଗୁଡ଼ିକ ଆକସ୍ମିକ ଭାବରେ ସଜାଡ଼ାଯିବ । ଆପଣଙ୍କର କାର୍ଯ୍ୟ ହେଉଛି ନିର୍ଣ୍ଣୟ କରିବା \/\/\/ ଆମର N ସଂଖ୍ଯା ବିଶିଷ୍ଟ ଏକ ଭେକ୍ଟର 'arr' ଅଛି arr[1], arr[2], ..., arr[N] ।\/\/\/ >>> move_one_ball(vec![3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given vector.\n\/\/\/ >>> move_one_ball(vec![3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n","canonical_solution":"fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.is_empty() {\n        return true; \/\/ An empty array is already considered sorted.\n    }\n    \n    let mut break_point = 0;\n    let mut break_found = false;\n    let len = arr.len();\n\n    for i in 0..len {\n        if arr[i] > arr[(i + 1) % len] {\n            if break_found {\n                return false;  \/\/ Found more than one break point, not possible.\n            }\n            break_point = i + 1;\n            break_found = true;\n        }\n    }\n    \n    \/\/ After finding a single break point, simulate the right shift by 'break_point'\n    for i in 0..len {\n        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {\n            return false; \/\/ Not sorted in non-decreasing order with this shift.\n        }\n    }\n    \n    true\n}\n\n\/\/ Example usages:\n\n\/\/ This will return true, as we can shift twice to sort it.\nassert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);\n\n\/\/ This will return false, as we can't sort this by any number of shifts.\nassert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","tests":"}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"},{"task_id":"HumanEval_110","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ନଚେତ୍ \"ନା\" କୁ ଫେରାଇ ଦିଅନ୍ତୁ.\/\/\/ lst1 ର ସମସ୍ତ ଉପାଦାନ ସମ ସମ ହେବା ପାଇଁ, \"YES\" କୁ ଫେରାଇଦିଅନ୍ତୁ.\/\/\/ ଯଦି ଏହା ସମ୍ଭବ lst1 ଏବଂ lst2 ମଧ୍ୟରେ ଉପାଦାନଗୁଡିକର ବିନିମୟ କରିବା ପାଇଁ \/\/\/ lst1 ଓ lst2 ମଧ୍ୟରେ ଆଦାନପ୍ରଦାନ ହୋଇଥିବା ଉପାଦାନର ସଂଖ୍ୟାରେ କୌଣସି ସୀମା ନାହିଁ ।\/\/\/ ସେମାନଙ୍କ ମଧ୍ୟରେ lst1 କୁ କେବଳ ଯୁଗ୍ମ ସଂଖ୍ୟାର ଭେକ୍ଟର କରିବା ପାଇଁ _\/\/\/ ଏବଂ ଏହା ନିର୍ଣ୍ଣୟ କରେ ଯେ କଣ ଏକ୍ସଚେଞ୍ଜ ଅଫ୍ ଇଲେକ୍ଟ୍ରନ୍ସ୍ କରିବା ସମ୍ଭବ କି ନୁହେଁ ।\/\/\/ ଏହି ସମସ୍ୟା ରେ, ଆପଣ ଏକ ଫଙ୍କସନ କୁ କାର୍ଯ୍ୟକାରୀ କରିବେ ଯାହା ଦୁଇଟା ସଂଖ୍ୟା ଭେକ୍ଟର ନେଇଥାଏ, \/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n\/\/\/ String::from(\"YES\")\n\/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n\/\/\/ String::from(\"NO\")\n\/\/\/ It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n","canonical_solution":"fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut even_in_lst2 = false;\n    for &num in &lst2 {\n        if num % 2 == 0 {\n            even_in_lst2 = true;\n            break;\n        }\n    }\n\n    if even_in_lst2 {\n        for &num in &lst1 {\n            if num % 2 != 0 {\n                return String::from(\"YES\");\n            }\n        }\n        return String::from(\"YES\");\n    }\n\n    String::from(\"NO\")\n}\n\nfn main() {\n    \/\/ Example cases\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); \/\/ \"YES\"\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); \/\/ \"NO\"\n}","tests":"}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(\"YES\"));\n}\n"},{"task_id":"HumanEval_111","nl":"ory_Orya","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ ଉଦାହରଣ: \/\/ଯଦି ଏକାଧିକ ଅକ୍ଷର ସମାନ ଭାବରେ ଦେଖାଯାଏ, ତେବେ ସେଗୁଡ଼ିକୁ ଫେରାଇ ଦିଅନ୍ତୁ ।\/\/\/ ଅକ୍ଷରଟି ଅଧିକ ଥର ପୁନରାବୃତ୍ତି ହୋଇଥାଏ ଏବଂ ଏଥିରେ ସେହି ଅକ୍ଷରର ସଂଖ୍ୟା ଥାଏ ।\/\/\/ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଗଲା ଯାହାକି ସ୍ପେସ୍ ପୃଥକ ଛୋଟ ଅକ୍ଷରକୁ ଦର୍ଶାଏ, ଏକ ହ୍ୟାସମ୍ୟାପ୍ ଫେରାଇଥାଏ \/\/\/ >>> histogram(String::from(\"a b c\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\/\/\/ >>> histogram(String::from(\"a b b a\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"a b c a b\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"b b b b a\"))\n\/\/\/ HashMap::from([(String::from(\"b\"), 4)])\n\/\/\/ >>> histogram(String::from(\"\"))\n\/\/\/ HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut counts: HashMap<String, isize> = HashMap::new();\n    let mut max_count = 0;\n\n    for letter in test.split_whitespace() {\n        let count = counts.entry(letter.to_string()).or_insert(0);\n        *count += 1;\n        if *count > max_count {\n            max_count = *count;\n        }\n    }\n\n    counts.retain(|_, &mut val| val == max_count);\n    counts\n}\n\nfn main() {\n    let result = histogram(String::from(\"a b c\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\n    let result = histogram(String::from(\"a b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"a b c a b\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"b b b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"b\"), 4)])\n\n    let result = histogram(String::from(\"\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([])\n}","tests":"}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")), HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"a\"), 1)]));\n}\n"},{"task_id":"HumanEval_112","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଆପଣ ଏକ ଟାପଲ୍ ଫେରାଇବେ ଯେଉଁଥିରେ ପରିଣାମ ଷ୍ଟ୍ରିଙ୍ଗ୍ ଏବଂ ଯାଞ୍ଚ ପାଇଁ ସତ୍ୟ\/ମିଥ୍ୟା ଅଛି \/\/\/ ଯଦି ଗୋଟିଏ ବାକ୍ୟଖଣ୍ଡ ପଛକୁ ଓ ଆଗକୁ ସମାନ ଭାବରେ ପଢ଼ାଯାଏ ତେବେ ତାହାକୁ ପାଲିଣ୍ଡ୍ରୋମ କୁହାଯାଏ ।\/\/\/ ତାପରେ ଯାଞ୍ଚ କରନ୍ତୁ ଯେ ଫଳାଫଳ ଷ୍ଟ୍ରିଙ୍ଗ୍ ପାଲିଣ୍ଡ୍ରୋମ୍ ଅଟେ କି ନାହିଁ. \/\/\/ ଆମକୁ ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗ s ଏବଂ c ଦିଆଯାଇଛି, ଆପଣଙ୍କୁ s ରେ ଥିବା ସମସ୍ତ ଅକ୍ଷରକୁ କାଢ଼ିବାକୁ ହେବ ଯାହା c ରେ ଥିବା କୌଣସି ଅକ୍ଷର ସହିତ ସମାନ \/\/\/ କାର୍ଯ୍ୟ \/\/\/ >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n\/\/\/ (String::from(\"bcd\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n\/\/\/ (String::from(\"acdef\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n\/\/\/ (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n","canonical_solution":"fn reverse_delete(s: String, c: String) -> (String, bool) {\n    \/\/ Create a set of characters to delete for quick lookup\n    let delete_chars: std::collections::HashSet<char> = c.chars().collect();\n    \n    \/\/ Filter the string, keeping only characters not in the delete set\n    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();\n    \n    \/\/ Check if the filtered string is a palindrome\n    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();\n    \n    \/\/ Return the filtered string and whether it's a palindrome\n    (filtered, is_palindrome)\n}","tests":"}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"},{"task_id":"HumanEval_113","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଅଙ୍କଗୁଡ଼ିକର ଏକ ଅଙ୍କ ସୂଚକକୁ ଇନପୁଟ୍ର i'th ଷ୍ଟ୍ରିଙ୍ଗରେ ରଖୁଅଛି.\/\/\" ଯେଉଁଠାରେ ସମସ୍ତ 'i' କୁ ସଂଖ୍ୟା '_' ଦ୍ୱାରା ବଦଳାଯିବା ଉଚିତ ।\/\/\/ ଆଉଟପୁଟର ପ୍ରତ୍ୟେକ ଉପାଦାନ i \"ରେ ଅଜଣା ଉପାଦାନର ସଂଖ୍ୟା ହେବା ଉଚିତ \/\/\/ ଗୋଟିଏ ଷ୍ଟ୍ରିଙ୍ଗ୍ ଭେକ୍ଟର ଦିଆଗଲା, ଯେଉଁଠାରେ ପ୍ରତ୍ୟେକ ଷ୍ଟ୍ରିଙ୍ଗ୍ କେବଳ ଅଙ୍କ ବିଶିଷ୍ଟ, ଏକ ଭେକ୍ଟର ଫେରାଇଦିଅନ୍ତୁ.\/\/\/ >>> odd_count(vec![String::from(\"1234567\")])\n\/\/\/ vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n\/\/\/ >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n\/\/\/ vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn odd_count(lst: Vec<String>) -> Vec<String> {\n    lst.iter()\n        .map(|s| {\n            let odd_count = s.chars().filter(|&c| {\n                match c {\n                    '1' | '3' | '5' | '7' | '9' => true,\n                    _ => false,\n                }\n            }).count();\n            format!(\"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\", odd_count)\n        })\n        .collect()\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = odd_count(vec![String::from(\"1234567\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ \n\/\/     let result = odd_count(vec![String::from(\"3\"), String::from(\"11111111\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = odd_count;\n    assert_eq!(candidate(vec![String::from(\"1234567\")]), vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"3\"), String::from(\"11111111\")]), vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"271\"), String::from(\"137\"), String::from(\"314\")]), vec![String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\"), String::from(\"the number of odd elements 3n the str3ng 3 of the 3nput.\"), String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\")]);\n}\n"},{"task_id":"HumanEval_114","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ସଂଖ୍ୟାର । \/\/\/ ଏକ ଭେକ୍ଟର ସମୁଦାୟ ସଂଖ୍ୟାକୁ ଦେଲେ, କୌଣସି ନନ୍-ଖାଲି ସବ୍-ଭେକ୍ଟରର ସର୍ବନିମ୍ନ ସମୁଦାୟକୁ ଖୋଜନ୍ତୁ \/\/\/ >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(vec![-1, -2, -3])\n\/\/\/ -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut min_sum = nums[0];\n    let mut current_sum = nums[0];\n\n    for &num in nums.iter().skip(1) {\n        current_sum = current_sum.min(current_sum + num);\n        min_sum = min_sum.min(current_sum);\n    }\n\n    min_sum\n}","tests":"}\n\nfn main() {\n    let candidate = minSubArraySum;\n    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);\n    assert_eq!(candidate(vec![-1, -2, -3]), -6);\n    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);\n    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);\n    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);\n    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);\n    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);\n    assert_eq!(candidate(vec![-10]), -10);\n    assert_eq!(candidate(vec![7]), 7);\n    assert_eq!(candidate(vec![1, -1]), -1);\n}\n"},{"task_id":"HumanEval_115","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ 1: \/\/\/ ଆପଣ ବାଲ୍ଟିଗୁଡ଼ିକୁ କେତେଥର ତଳକୁ ଆଣିବାକୁ ଚାହୁଁଛନ୍ତି ତାହା ଆଉଟପୁଟ୍ କରନ୍ତୁ.\/\/\/ ତୁମର କାମ ହେଉଛି କୂଅକୁ ଖାଲି କରିବା ପାଇଁ ଡବା ବ୍ୟବହାର କରିବା.\/\/\/ ଏବଂ ସମସ୍ତ ବାଲ୍ଟିରେ ସମାନ କ୍ଷମତା ଅଛି. \/\/ପ୍ରତ୍ୟେକ କୂଅରେ ଏକ ବାଡ଼ୀ ରହିଛି, ଯାହାଦ୍ୱାରା ପାଣି ବାହାର କରାଯାଇପାରିବ ।\/\/\/ ଏବଂ ପ୍ରତ୍ୟେକ 1 ଗୋଟିଏ ଧାଡ଼ିରେ ଗୋଟିଏ ଜଳ ଏକକକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ।\/\/ଆପଣଙ୍କୁ ଏକ ଚତୁର୍ଭୁଜ ଗ୍ରୀଡ ଦିଆଯାଉଛି, ପ୍ରତ୍ୟେକ ଧାଡି ଗୋଟିଏ କୂଅକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ।\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n","canonical_solution":"fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total_water_units = 0;\n\n    for row in grid.iter() {\n        for &unit in row.iter() {\n            total_water_units += unit;\n        }\n    }\n\n    \/\/ Calculate how many times we need to lower the bucket to extract all water units\n    (total_water_units + capacity - 1) \/ capacity\n}\n\nfn main() {\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); \/\/ 6\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); \/\/ 5\n    println!(\"{}\", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"},{"task_id":"HumanEval_116","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଏହାକୁ ନିମ୍ନଲିଖିତ ଢଙ୍ଗରେ କାର୍ଯ୍ୟକାରୀ କରାଯିବା ଉଚିତ: \/\/\/ ସମାନ ସଂଖ୍ୟକ ଏକକ ପାଇଁ, ଦଶମିକ ମୂଲ୍ୟ ଆଧାରରେ ସର୍ଟ କରନ୍ତୁ. \/\/\/ ଏକର ସଂଖ୍ୟା ସେମାନଙ୍କର ବାଇନାରୀ ପ୍ରତିନିଧିତ୍ୱରେ ବୃଦ୍ଧି କ୍ରମରେ _\/\/ଏହି କାଟା ରେ, ଆପଣଙ୍କୁ ଏକ ନନ୍-ନେଗେଟିଭ୍ ଇଣ୍ଟେଜର ଭେକ୍ଟର କୁ ସର୍ଟ କରିବାକୁ ହେବ \/\/\/ >>> sort_array(vec![1, 5, 2, 3, 4])\n\/\/\/ vec![1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![-2, -3, -4, -5, -6])\n\/\/\/ vec![-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(vec![1, 0, 2, 3, 4])\n\/\/\/ vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_by(|&a, &b| {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n        if ones_a == ones_b {\n            a.cmp(&b)\n        } else {\n            ones_a.cmp(&ones_b)\n        }\n    });\n    arr\n}\n\nfn main() {\n    println!(\"{:?}\", sort_array(vec![1, 5, 2, 3, 4])); \/\/ Output: [1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![-2, -3, -4, -5, -6])); \/\/ Output: [-6, -5, -4, -3, -2]\n    println!(\"{:?}\", sort_array(vec![1, 0, 2, 3, 4])); \/\/ Output: [0, 1, 2, 3, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"},{"task_id":"HumanEval_117","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଟିପ୍ପଣୀ: ଆପଣ ଧରିନେବେ ଯେ ଇନପୁଟ୍ ଷ୍ଟ୍ରିଙ୍ଗରେ କେବଳ ଅକ୍ଷର ଏବଂ ସ୍ପେସ୍ ଅଛି.\/\/\/ ଯଦି string s ଖାଲି ହୋଇଥାଏ ତେବେ ଫଳନଟି ଏକ ଖାଲି ଭେକ୍ଟର ଫେରାଇଥାଏ.\/\/\/n ବ୍ୟଞ୍ଜନ, ଏହି ଶବ୍ଦଗୁଡ଼ିକର କ୍ରମରେ s ବାକ୍ୟଖଣ୍ଡରେ ଦେଖାଯାଏ ।\/\/\/ ଏକ ଫଳନ ଯାହା s ସଂଖ୍ୟକ ବାକ୍ୟର ଏକ ଭେକ୍ଟର ଫେରାଇଥାଏ ଯେଉଁଥିରେ \/\/\/ ଗୋଟିଏ ଧାଡ଼ି s ଏବଂ ଗୋଟିଏ ପ୍ରାକୃତିକ ସଂଖ୍ୟା n ଦିଆଗଲା, ଆପଣଙ୍କୁ କାର୍ଯ୍ୟକାରୀ କରିବା ପାଇଁ କୁହାଯାଇଛି \/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\/\/\/ vec![String::from(\"little\")]\n\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n\/\/\/ vec![String::from(\"Mary\"), String::from(\"lamb\")]\n\/\/\/ >>> select_words(String::from(\"simple white space\"), 2)\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> select_words(String::from(\"Hello world\"), 4)\n\/\/\/ vec![String::from(\"world\")]\n\/\/\/ >>> select_words(String::from(\"Uncle sam\"), 3)\n\/\/\/ vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n","canonical_solution":"fn select_words(s: String, n: isize) -> Vec<String> {\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let mut result = Vec::new();\n\n    for word in s.split_whitespace() {\n        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();\n        if consonant_count == n as usize {\n            result.push(word.to_string());\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"},{"task_id":"HumanEval_118","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଆପଣ ଭାବୁଥିବେ ଯେ ଦିଆଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗରେ କେବଳ ଇଂରାଜୀ ଅକ୍ଷର ଅଛି.\/\/\/ ଉପରୋକ୍ତ ସର୍ତ୍ତ ପୂରଣ କରୁଥିବା କୌଣସି ସ୍ୱର ଚିହ୍ନଟ କରନ୍ତୁ. \/\/\/ ଆରମ୍ଭରେ ଥିବା ସ୍ୱର ଏବଂ ଶେଷରେ ଥିବା ସ୍ୱର ଗଣନା କରାଯାଏ ନାହିଁ. ଯଦି ଆପଣ ନକରିଛନ୍ତି ତେବେ ଖାଲି ଷ୍ଟ୍ରିଙ୍ଗ୍ ଫେରାନ୍ତୁ \/\/\/ ଶବ୍ଦଟିର ଡାହାଣ ପଟରୁ ଦୁଇଟି ସ୍ୱରସଙ୍ଗ (ମୌଳିକ ସଂଖ୍ୟାକୁ ଧ୍ୟାନରେ ରଖି) ।\/\/ଆପଣଙ୍କୁ ଗୋଟିଏ ଶବ୍ଦ ଦିଆଯାଇଛି, ଆପଣଙ୍କର କାମ ହେଉଛି, ସେହି ଶବ୍ଦ ମଧ୍ୟରେ ଥିବା ନିକଟତମ ସ୍ୱର ଚିହ୍ନକୁ ଖୋଜିବା ।\/\/\/ >>> get_closest_vowel(String::from(\"yogurt\"))\n\/\/\/ String::from(\"u\")\n\/\/\/ >>> get_closest_vowel(String::from(\"FULL\"))\n\/\/\/ String::from(\"U\")\n\/\/\/ >>> get_closest_vowel(String::from(\"quick\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> get_closest_vowel(String::from(\"ab\"))\n\/\/\/ String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n","canonical_solution":"fn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let chars: Vec<char> = word.chars().collect();\n    if chars.len() < 3 {\n        return String::from(\"\");\n    }\n\n    for i in (1..chars.len() - 1).rev() {\n        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {\n            return chars[i].to_string();\n        }\n    }\n    String::from(\"\")\n}","tests":"}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"},{"task_id":"HumanEval_119","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଯଦି ଭଲ ଷ୍ଟ୍ରିଙ୍ଗ ତିଆରି କରିବାର ଉପାୟ ଅଛି ତେବେ 'ହଁ' ଫେରାଇଦିଅନ୍ତୁ, ଏବଂ ଅନ୍ୟଥା 'ନା' ଫେରାଇଦିଅନ୍ତୁ.\/\/\/ \" (()) \" ନୁହେଁ ।\/\/\/ ସନ୍ତୁଳିତ. ଉଦାହରଣ ସ୍ୱରୂପ: '(())))' ଭଲ, ଯେତେବେଳେକି \/\/\/ ଗୋଟିଏ ଧାଡ଼ି S କୁ ଭଲ ବୋଲି ବିବେଚନା କରାଯାଏ ଯଦି ଏବଂ କେବଳ ଯଦି S ରେ ଥିବା ସମସ୍ତ ବନ୍ଧନୀ \/\/\/ କିଛି ଆଦେଶ, ଯେ ଫଳସ୍ୱରୂପ ବାକ୍ୟଖଣ୍ଡ ଭଲ ହେବ. \/\/\/ ତୁମର କାମ ହେଉଛି ଯାଞ୍ଚ କରିବା ଏହା ସମ୍ଭବ କି ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗକୁ ଯୋଡିବା ସମ୍ଭବ କି ନାହିଁ \/\/\/ କେବଳ \" (_) \" କିମ୍ବା \" (_) \" ପରି parentheses ରେ ବନ୍ଦ କରନ୍ତୁ.\/\/\/ ଆପଣଙ୍କୁ ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗର ଭେକ୍ଟର ଦିଆଗଲା, ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗରେ ଖୋଲା \/\/\/ >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n\/\/\/ String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n","canonical_solution":"fn match_parens(lst: Vec<String>) -> String {\n    fn is_balanced(s: &str) -> bool {\n        let mut balance = 0;\n        for ch in s.chars() {\n            if ch == '(' {\n                balance += 1;\n            } else {\n                balance -= 1;\n            }\n            if balance < 0 {\n                return false;\n            }\n        }\n        balance == 0\n    }\n\n    if lst.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let s1 = &lst[0];\n    let s2 = &lst[1];\n\n    let combined1 = format!(\"{}{}\", s1, s2);\n    let combined2 = format!(\"{}{}\", s2, s1);\n\n    if is_balanced(&combined1) || is_balanced(&combined2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"},{"task_id":"HumanEval_120","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ 1: \/\/\/ ଲମ୍ବ k ର ସର୍ବାଧିକ k ସଂଖ୍ୟା ସହିତ arr ରେ _\/\/\/ ଏକ ଭେକ୍ଟର arr ଦେଇ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଏବଂ ଏକ ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା k, ଏକ ସର୍ଟ ଭେକ୍ଟର ଫେରାଇଥାଏ \/\/\/ >>> maximum(vec![-3, -4, 5], 3)\n\/\/\/ vec![-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(vec![4, -4, 4], 2)\n\/\/\/ vec![4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/\/ vec![2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the vector will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the vector will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_unstable_by(|a, b| b.cmp(a));\n    let k = k as usize;\n    let mut result: Vec<isize> = arr.into_iter().take(k).collect();\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n}","tests":"}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_121","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଏକ ଅସରନ୍ତି ଭେକ୍ଟର ଦିଆଯାଇଥିବା, ସମୁଦାୟ ଅଙ୍କଗୁଡ଼ିକର ସମୁଦାୟକୁ ଫେରାଇବ ଯାହା ସମ ସ୍ଥିତିରେ ଅଛି _\/\/\/ >>> solution(vec![5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(vec![3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(vec![30, 13, 24, 321])\n\/\/\/ 0\nfn solution(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn solution(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)\n        .map(|(_, &x)| x)\n        .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = solution;\n    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);\n    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);\n    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);\n    assert_eq!(candidate(vec![5, 9]), 5);\n    assert_eq!(candidate(vec![2, 4, 8]), 0);\n    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);\n    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);\n}\n"},{"task_id":"HumanEval_122","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ arr ର ପ୍ରଥମ k ଟି ଉପାଦାନରୁ ସର୍ବାଧିକ ଦୁଇଟି ଅଙ୍କ ବିଶିଷ୍ଟ ଉପାଦାନର ସମୁଦାୟ _\/\/\/ ଏକ ଅକ୍ଷର ବିଶିଷ୍ଟ ଭେକ୍ଟର arr ଏବଂ ଏକ ଅକ୍ଷର k ଦିଆଗଲା, ଫେରାଇଦେବେ \/\/\/ >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n","canonical_solution":"fn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    arr.iter()\n        .take(k as usize)\n        .filter(|&&x| x > -100 && x < 100)\n        .sum()\n}\n\nfn main() {\n    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);\n    println!(\"{}\", result);  \/\/ Output: 24\n}","tests":"}\n\nfn main() {\n    let candidate = add_elements;\n    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);\n    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n    assert_eq!(candidate(vec![1], 1), 1);\n}\n"},{"task_id":"HumanEval_123","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ get_odd_collatz(5) [1, 5] # 5 ପାଇଁ କୋଲାଟଜ କ୍ରମାଙ୍କ ହେଉଛି [5, 16, 8, 4, 2, 1], ତେଣୁ ଅଜଣା ସଂଖ୍ୟାଗୁଡ଼ିକ ହେଉଛି କେବଳ 1, ଏବଂ 5 ।\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ 2. ଫେରସ୍ତ ଭେକ୍ଟର ବୃଦ୍ଧି କ୍ରମରେ ସର୍ଟ କରାଯାଇଛି ।\/\/\/ 1. କୋଲାଟଜ (୧) ହେଉଛି [1] ।\/\/\/ ଟିପ୍ପଣୀ: \/\/\/ ପଦ ସହିତ 1 । ଅନୁମାନ ହେଉଛି ଯେ n ର କୌଣସି ମୂଲ୍ୟ ହେଉ ନା କାହିଁକି, କ୍ରମ ସର୍ବଦା 1 କୁ ପହଞ୍ଚିବ ।\/\/\/ ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟଟି. ଯଦି ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟଟି ଅଙ୍କବିଶେଷ, ପରବର୍ତ୍ତୀ ବାକ୍ୟଟି ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟର 3 ଗୁଣିତକ \/\/\/ ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟଟି ଏହିପରି: ଯଦି ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟଟି ଯୁଗ୍ମ, ତେବେ ପରବର୍ତ୍ତୀ ବାକ୍ୟଟି  ର ଅଧା ହେବ\/\/\/ ନିମ୍ନଲିଖିତ ଭାବରେ: ଯେକୌଣସି ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ରୁ ଆରମ୍ଭ କରନ୍ତୁ । ତାପରେ ପ୍ରତ୍ୟେକ ବାକ୍ୟ  ରୁ ପ୍ରାପ୍ତ ହୁଏ ।\/\/କୋଲାଟଜ ଅନୁମାନ ଗଣିତରେ ଏକ ଅନୁମାନ ଯାହା ଏକ ପରିଭାଷିତ କ୍ରମକୁ ନେଇଥାଏ ।\/\/\/ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ଏକ ସର୍ଟ ଭେକ୍ଟର ଫେରାଇ ନିଅନ୍ତୁ ଯେଉଁଥିରେ କୋଲାଟଜ କ୍ରମରେ ଅଜଣା ସଂଖ୍ୟା ଅଛି. \/\/\/ >>> get_odd_collatz(5)\n\/\/\/ vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n","canonical_solution":"fn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut sequence = Vec::new();\n    let mut current = n;\n\n    while current != 1 {\n        if current % 2 != 0 {\n            sequence.push(current);\n        }\n\n        if current % 2 == 0 {\n            current \/= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    \n    \/\/ Add the final odd number 1 if n is 1\n    sequence.push(1);\n\n    sequence.sort();\n    sequence\n}\n\nfn main() {\n    let result = get_odd_collatz(5);\n    println!(\"{:?}\", result); \/\/ Outputs: [1, 5]\n}","tests":"}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"},{"task_id":"HumanEval_124","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ୪. ତାରିଖଟି ଏହି ଫର୍ମାଟରେ ରହିବା ଉଚିତଃ ଏମ୍.ଏମ୍.ଡି.ଡି.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.ଏମ୍.\/\/\/ ୩. ମାସର ସଂଖ୍ୟା ୧ ରୁ କମ କିମ୍ବା ୧୨ ରୁ ଅଧିକ ହେବା ଉଚିତ ନୁହେଁ ।\/\/ମାସ 1,3,5,7,8,10,12 ପାଇଁ ଦିନ ସଂଖ୍ୟା 1 ରୁ କମ କିମ୍ବା 31 ଦିନରୁ ଅଧିକ ନୁହେଁ ଏବଂ ମାସ 4,6,9,11 ପାଇଁ ଦିନ ସଂଖ୍ୟା 1 ରୁ କମ କିମ୍ବା 30 ଦିନରୁ ଅଧିକ ନୁହେଁ ଏବଂ ମାସ 2 ପାଇଁ ଦିନ ସଂଖ୍ୟା 1 ରୁ କମ୍ କିମ୍ବା 29 ଦିନରୁ ଅଧିକ ନୁହେଁ _\/\/\/ 1. ତାରିଖ ଶୃଙ୍ଖଳ ଖାଲି ନୁହେଁ.\/\/\/ ନିମ୍ନଲିଖିତ ସମସ୍ତ ନିୟମ ପୂରଣ ହେଲେ ତାରିଖ ବୈଧ ହେବ: \/\/\/ ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ତାରିଖଟି ବୈଧ ଅନ୍ୟଥା ମିଥ୍ୟା ।\/\/\/ ଆପଣଙ୍କୁ ଏକ ଫଳନ ଲେଖିବାକୁ ହେବ ଯାହାକି ଦିଆଯାଇଥିବା ତାରିଖକୁ ବୈଧ କରିଥାଏ ଏବଂ \/\/\/ >>> valid_date(String::from(\"03-11-2000\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"15-01-2012\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"04-0-2040\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"06-04-2020\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"06\/04\/2020\"))\n\/\/\/ false\nfn valid_date(date: String) -> bool {\n","canonical_solution":"fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return false;\n    }\n\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n\n    let maybe_month = parts[0].parse::<u32>();\n    let maybe_day = parts[1].parse::<u32>();\n    let maybe_year = parts[2].parse::<u32>();\n\n    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {\n        return false;\n    }\n\n    let month = maybe_month.unwrap();\n    let day = maybe_day.unwrap();\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return false;\n            }\n        }\n        2 => {\n            if day < 1 || day > 29 {\n                return false;\n            }\n        }\n        _ => return false, \/\/ This case should never be reached\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"},{"task_id":"HumanEval_126","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ସଂଖ୍ୟା, ମିଥ୍ୟା ଫେରାଇଥାଏ. କୌଣସି ନକାରାତ୍ମକ ସଂଖ୍ୟା ଏବଂ କେବଳ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଧରନ୍ତୁ ନାହିଁ.\/\/\/ ଉଦୟ କ୍ରମରେ. ଯଦି ଭେକ୍ଟର ପାଖରେ ସମାନର 1 ରୁ ଅଧିକ ଡୁପ୍ଲିକେଟ୍ ଅଛି \/\/\/ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ଭେକ୍ଟର ଦିଆଯାଇଥାଏ, ସେମାନେ ସର୍ଟ ହୋଇଥାଉ ବା ନଥାଉ ଫେରାଇଥାଏ \/\/\/ >>> is_sorted(vec![5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfn is_sorted(lst: Vec<isize>) -> bool {\n","canonical_solution":"fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.is_empty() || lst.len() == 1 {\n        return true;\n    }\n    \n    let mut previous = lst[0];\n    let mut repeat_count = 0;\n\n    for &current in &lst[1..] {\n        if current < previous {\n            return false;\n        }\n        if current == previous {\n            repeat_count += 1;\n            if repeat_count >= 2 {\n                return false;\n            }\n        } else {\n            repeat_count = 0;\n        }\n        previous = current;\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n}\n"},{"task_id":"HumanEval_127","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ [ଇନପୁଟ୍\/ଆଉଟପୁଟ୍] ନମୁନା: \/\/\/ ଯଦି ଦୁଇଟି ଅନ୍ତରାଳ ପରସ୍ପର ସହିତ ମିଶି ନଥାଏ, ତେବେ \"ନା\" ଫେରାଇଦେବେ.\/\/\/ ନ ହେଲେ, \"ନା\" ଫେରାଇଦେବେ.\/\/\/ ଯଦି ସଂଯୋଗର ଲମ୍ବ ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା, ତେବେ \"YES\" ଫେରାଇଦେବେ, \/\/\/ ଯାହାର ଲମ୍ବ 1 ଅଟେ, ଯାହାକି କୌଣସି ଅଶୂନ୍ୟ ସଂଖ୍ୟା ନୁହେଁ.\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ, ଅନ୍ତରାଳ (1, 3), (2, 4) ର ଅନ୍ତର ହେଉଛି (2, 3) \/\/\/ ଅନ୍ତରାଳ ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା ଅଟେ ।\/\/\/ ଆପଣଙ୍କର କାମ ହେଉଛି ନିର୍ଣ୍ଣୟ କରିବା ଯେ ଏହି ଦୁଇଟିର ସଂଯୋଗର ଲମ୍ବ \/\/ପ୍ରତ୍ୟେକ ଅନ୍ତରାଳ ପାଇଁ, ଏହା ଧରାଯାଏ ଯେ ଏହାର ଆରମ୍ଭ ଏହାର ଶେଷ ଠାରୁ କମ୍ କିମ୍ବା ସମାନ ।\/\/\/ ଉଭୟ ଆରମ୍ଭ ଓ ସମାପ୍ତିକୁ ଅନ୍ତର୍ଭୁକ୍ତ କରେ ।\/\/\/ ଦିଆଯାଇଥିବା ଅନ୍ତରାଳ ବନ୍ଦ ଅର୍ଥାତ୍ ଅନ୍ତରାଳ (ଆରମ୍ଭ, ଶେଷ) \/\/\/ ଯେଉଁଠାରେ ପ୍ରତ୍ୟେକ ଅନ୍ତରାଳ ହେଉଛି ଏକ ଯୋଡି ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା । ଉଦାହରଣ ସ୍ୱରୂପ, ଅନ୍ତରାଳ = (ଆରମ୍ଭ, ଶେଷ) = (1, 2) ।\/\/\/ ଆପଣଙ୍କୁ ଦୁଇଟି ଅନ୍ତରାଳ ଦିଆଯାଇଛି, \/\/\/ >>> intersection((1, 2), (2, 3))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-1, 1), (0, 4))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-3, -1), (-5, 5))\n\/\/\/ String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start_intersection = std::cmp::max(start1, start2);\n    let end_intersection = std::cmp::min(end1, end2);\n\n    if start_intersection <= end_intersection {\n        let length = (end_intersection - start_intersection + 1) as usize;\n        if is_prime(length) {\n            return String::from(\"YES\");\n        }\n    }\n    String::from(\"NO\")\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", intersection((1, 2), (2, 3))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-1, 1), (0, 4))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-3, -1), (-5, 5))); \/\/ \"YES\"\n}","tests":"}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"},{"task_id":"HumanEval_128","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଟିପ୍ପଣୀ: ଖାଲି arr ପାଇଁ None ଫେରାଇଥାଏ. \/\/\/ ଭେକ୍ଟରରେ ଥିବା ପ୍ରତ୍ୟେକ ସଂଖ୍ୟାକୁ 1, -1 କିମ୍ବା 0 ଦ୍ବାରା ପ୍ରତିନିଧିତ୍ୱ କରାଯାଏ ।\/\/\/ ସମୁଦାୟ ପରିମାଣର ସଂଖ୍ଯା ଗୁଡିକୁ ଗୁଣନ କରି ସମସ୍ତ ଚିହ୍ନର ଗୁଣନ କରା ଯାଇଥାଏ \/\/\/ ଆପଣଙ୍କୁ ଏକ ଭେକ୍ଟର ଦିଆ ଯାଇଛି ଏବଂ ଆପଣଙ୍କୁ ଫେରିବାକୁ ପଡିବ \/\/\/ >>> prod_signs(vec![1, 2, 2, -4])\n\/\/\/ Some(9)\n\/\/\/ >>> prod_signs(vec![0, 1])\n\/\/\/ Some(0)\n\/\/\/ >>> prod_signs(vec![])\n\/\/\/ None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut sum_of_magnitudes = 0;\n    let mut product_of_signs = 1;\n\n    for &num in &arr {\n        sum_of_magnitudes += num.abs();\n        if num == 0 {\n            product_of_signs = 0;\n            break;\n        } else if num > 0 {\n            product_of_signs *= 1;\n        } else {\n            product_of_signs *= -1;\n        }\n    }\n\n    Some(sum_of_magnitudes * product_of_signs)\n}","tests":"}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n}\n"},{"task_id":"HumanEval_129","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ସର୍ବନିମ୍ନ ପଥ ଦେଇ ଯାଉଥିବା କୋଷଗୁଡ଼ିକର ମୂଲ୍ୟର ଏକ ଅର୍ଡର ଭେକ୍ଟର ଫେରାଇଥାଏ _\/\/ଏହାର ଉତ୍ତର ନିଶ୍ଚିତ ଭାବେ ଅନନ୍ୟ ।\/\/\/ lst_A[j] = lst_B[j]  ଏହା ହେଉଛି\/\/\/ ଯେପରିକି lst_A[i] < lst_B[i] ଏବଂ ଯେକୌଣସି j (1 <= j < i) ପାଇଁ ଆମର \/\/\/ ଠାରୁ lst_B, ଅନ୍ୟ ଶବ୍ଦରେ, ସେଠାରେ ଏକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ସୂଚକାଙ୍କ i (1 <= i <= k)  ଅଛି\/\/\/ ମାଧ୍ୟମରେ (ଆସନ୍ତୁ ସେମାନଙ୍କୁ lst_A ଏବଂ lst_B କହିବା), lst_A ଶବ୍ଦକୋଷିକ ଦୃଷ୍ଟିରୁ କମ୍ \/\/\/ A ଓ B କୁ ଯାଇଥିବା ସେଲ୍ ଗୁଡିକର ମୂଲ୍ୟର ଅର୍ଡର ଭେକ୍ଟର ତିଆରି କରିବା ପରେ \/\/\/ ଏକ ପଥ A (ଲମ୍ବ k) କୁ ପଥ B (ଲମ୍ବ k) ଠାରୁ ଛୋଟ ବୋଲି ଧରାଯାଏ ଯଦି \/\/\/ ତୁମେ ଗ୍ରୀଡରୁ ବାହାରି ପାରିବ ନାହିଁ. \/\/\/ ଆବଶ୍ୟକତଃ ଭିନ୍ନ) ।\/\/\/ ଦୟାକରି ଧ୍ୟାନ ଦିଅନ୍ତୁ ଯେ k ଲମ୍ବ ପଥ ଅର୍ଥାତ୍ k ଟି ସେଲ୍ ପରିଦର୍ଶନ କରିବା (ନକଲି ନୁହେଁ)\/\/\/ ସେଲ୍ । \/\/ଅନ୍ୟ ଶବ୍ଦରେ, ଆପଣ ସେହି କୋଷକୁ ଯାଇପାରିବେ ଯାହା ଆପଣଙ୍କ ସହିତ ଏକ ପ୍ରବାହକୁ ଭାଗ କରେ _\/\/ଯେକୌଣସି କୋଷରୁ, ଏବଂ ପ୍ରତ୍ୟେକ ପାଦରେ ଆପଣ ଯେକୌଣସି ପଡୋଶୀ କୋଷକୁ ଯାଇପାରିବେ, \/\/ଆପଣଙ୍କୁ ଗ୍ରୀଡରେ k ଲମ୍ବର ସର୍ବନିମ୍ନ ପଥ ଖୋଜିବାକୁ ପଡିବ । ଆପଣ ଆରମ୍ଭ କରିପାରିବେ \/\/\/ ସମେତ ଗ୍ରୀଡର କୋଷିକାରେ ଠିକ ଥରେ ଦେଖାଯାଏ ।\/\/\/ ଗ୍ରୀଡର ପ୍ରତ୍ୟେକ କୋଷରେ ଏକ ମୂଲ୍ୟ ଅଛି. [୧, N * N] ରେ ଥିବା ପ୍ରତ୍ୟେକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା \/\/\/ N ଧାଡି ଏବଂ N ସ୍ତମ୍ଭ (N >= 2) ଏବଂ ଏକ ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା k,  ସହିତ ଏକ ଗ୍ରୀଡ୍ ଦିଆଯାଇଥାଏ,\/\/\/ >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n\/\/\/ vec![1, 2, 1]\n\/\/\/ >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n\/\/\/ vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let n = grid.len();\n    let mut best_path = vec![];\n    let mut best_values = vec![isize::MAX; k as usize];\n    \n    fn dfs(\n        grid: &Vec<Vec<isize>>, \n        row: usize, \n        col: usize, \n        path: &mut Vec<(usize, usize)>, \n        values: &mut Vec<isize>, \n        k: isize, \n        best_values: &mut Vec<isize>\n    ) {\n        if path.len() == k as usize {\n            if values < best_values {\n                best_values.clone_from(values);\n            }\n            return;\n        }\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n        for &(dr, dc) in directions.iter() {\n            let new_row = row as isize + dr;\n            let new_col = col as isize + dc;\n            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {\n                path.push((new_row as usize, new_col as usize));\n                values.push(grid[new_row as usize][new_col as usize]);\n                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);\n                values.pop();\n                path.pop();\n            }\n        }\n    }\n\n    for r in 0..n {\n        for c in 0..n {\n            let mut path = vec![(r, c)];\n            let mut values = vec![grid[r][c]];\n            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);\n        }\n    }\n\n    best_values\n}","tests":"}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n"},{"task_id":"HumanEval_130","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ପ୍ରଥମ n + 1 ସଂଖ୍ୟାଗୁଡିକର ତ୍ରିବୋନାସୀ କ୍ରମ । \/\/\/ ଆପଣଙ୍କୁ ଏକ ନନ୍-ନଗେଟିଭ୍ ଇଣ୍ଟେଜର ନମ୍ବର n ଦିଆ ଯାଇଛି, ଆପଣଙ୍କୁ a ର ଭେକ୍ଟର ଫେରାଇବାକୁ ପଡିବ \/\/\/ = 2 + 3 + 3 = 8 \/\/\/ ତ୍ରି (୩) = ତ୍ରି (୨) + ତ୍ରି (୧) + ତ୍ରି (୪)\/\/\/ ତ୍ରି () = ୩ \/\/\/ ତ୍ରି (୨) = ୧ + (୨ \/ ୨) = ୨ \/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ତ୍ରି (n) = ତ୍ରି (n - 1) + ତ୍ରି (n - 2) + ତ୍ରି (n + 1), ଯଦି n ଅଙ୍କ ଅଙ୍କ ଅଙ୍କ ।\/\/\/ ତ୍ରି (n) = 1 + n \/ 2, ଯଦି n ଯୁଗ୍ମ ହୋଇଥାଏ ।\/\/\/ ତ୍ରି (୧) = ୩ \/\/\/ ତ୍ରିବୋନାସୀ କ୍ରମାନୁସାରେ ନିମ୍ନଲିଖିତ ବାରମ୍ବାରତା ଅଛି: \/\/କିନ୍ତୁ ଲୋକମାନେ ଟ୍ରିବୋନାସ୍କି କ୍ରମାଙ୍କ ବିଷୟରେ ଜାଣି ନାହାନ୍ତି ।\/\/ଫିବୋନାସୀ କ୍ରମାଙ୍କକୁ ସମସ୍ତେ ଜାଣନ୍ତି, ଏହାକୁ ଗଭୀର ଭାବରେ ଅଧ୍ୟୟନ କରିଥିଲେ ଗଣିତଜ୍ଞମାନେ \/\/\/ >>> tri(3)\n\/\/\/ vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n","canonical_solution":"fn tri(n: isize) -> Vec<isize> {\n    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {\n        if n < memo.len() as isize {\n            return memo[n as usize];\n        }\n\n        let result = if n == 1 {\n            3\n        } else if n % 2 == 0 {\n            1 + n \/ 2\n        } else {\n            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)\n        };\n\n        if n as usize >= memo.len() {\n            memo.resize(n as usize + 1, 0);\n        }\n        memo[n as usize] = result;\n        result\n    }\n\n    let mut sequence = Vec::new();\n    let mut memo = Vec::new();\n\n    for i in 0..=n {\n        sequence.push(tribonacci(i, &mut memo));\n    }\n\n    sequence\n}","tests":"}\n\nfn main() {\n    let candidate = tri;\n    assert_eq!(candidate(3), vec![1, 3, 2, 8]);\n    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);\n    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);\n    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);\n    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);\n    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);\n    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n    assert_eq!(candidate(0), vec![1]);\n    assert_eq!(candidate(1), vec![1, 3]);\n}\n"},{"task_id":"HumanEval_131","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ 0 ଫେରାଇଥାଏ ଯଦି ସମସ୍ତ ଅଙ୍କ ଯୁଗ୍ମ ହୋଇଥାଏ. \/\/\/ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ଅଙ୍କଗୁଡ଼ିକର ଗୁଣନକୁ ଫେରାଇଦେବେ. \/\/\/ >>> digits(1)\n\/\/\/ 1\n\/\/\/ >>> digits(4)\n\/\/\/ 0\n\/\/\/ >>> digits(235)\n\/\/\/ 15\nfn digits(n: isize) -> isize {\n","canonical_solution":"fn digits(n: isize) -> isize {\n    let mut product = 1;\n    let mut has_odd = false;\n    let mut num = n;\n\n    while num > 0 {\n        let digit = num % 10;\n        if digit % 2 != 0 {\n            product *= digit;\n            has_odd = true;\n        }\n        num \/= 10;\n    }\n\n    if has_odd {\n        product\n    } else {\n        0\n    }\n}\n\nfn main() {\n    println!(\"{}\", digits(1));  \/\/ 1\n    println!(\"{}\", digits(4));  \/\/ 0\n    println!(\"{}\", digits(235)); \/\/ 15\n}","tests":"}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5), 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n    assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n    assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n}\n"},{"task_id":"HumanEval_132","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଯେଉଁଠାରେ ଅତି କମରେ ଗୋଟିଏ ବ୍ରାଙ୍କେଟ ଉପକ୍ରମରେ ନିଷ୍ଟେଜ ହୋଇଥାଏ ।\/\/\/ ଫଳନଟି true ଫେରାଇବ ଯଦି ଏବଂ କେବଳ ଯଦି ବ୍ରାଙ୍କେଟ୍ସର ଏକ ବୈଧ ଉପକ୍ରମ ଅଛି \/\/\/ ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହା କେବଳ ବର୍ଗ ବନ୍ଧନୀ ଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗକୁ ଇନପୁଟ୍ ଭାବରେ ଗ୍ରହଣ କରେ _\/\/\/ >>> is_nested(String::from(\"[[]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[][]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[[][]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[[]][[\"))\n\/\/\/ true\nfn is_nested(string: String) -> bool {\n","canonical_solution":"fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let mut nested = false;\n\n    for bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n        } else if bracket == ']' {\n            if let Some(_) = stack.pop() {\n                if !stack.is_empty() {\n                    nested = true;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n\n    nested\n}\n\nfn main() {\n    println!(\"{}\", is_nested(String::from(\"[[]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[]]]]]]][[[[[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[][]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[[][]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[[]][[\"))); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"},{"task_id":"HumanEval_133","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଭେକ୍ଟରରେ ଥିବା ପ୍ରତ୍ୟେକ ଉପାଦାନକୁ ପ୍ରଥମେ ଉପର int (~) ଉପର ପର୍ଯ୍ୟନ୍ତ ଘୋଡ଼ାଇ ଦିଅନ୍ତୁ ।\/\/\/ ଆପଣଙ୍କୁ ଦିଆଯାଇଥିବା ଭେକ୍ଟରରେ ଥିବା ବର୍ଗର ସଂଖ୍ୟାର ସମୁଦାୟ ଫେରାଇବାକୁ ହେବ, \/\/\/ ଆପଣଙ୍କୁ ଏକ ସଂଖ୍ୟାର ଭେକ୍ଟର ଦିଆଯାଉଛି.\/\/\/ >>> lst(vec![1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> lst(vec![1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> lst(vec![1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> lst(vec![-2.4, 1.0, 1.0])\n\/\/\/ 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .map(|&x| x.ceil() as isize)  \/\/ Round each element to the nearest upper integer\n        .map(|x| x * x)               \/\/ Square each element\n        .sum()                        \/\/ Sum all the squared elements\n}\n\nfn main() {\n    println!(\"{}\", sum_squares(vec![1.0, 2.0, 3.0])); \/\/ 14\n    println!(\"{}\", sum_squares(vec![1.0, 4.0, 9.0])); \/\/ 98\n    println!(\"{}\", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); \/\/ 84\n    println!(\"{}\", sum_squares(vec![1.4, 4.2, 0.0])); \/\/ 29\n    println!(\"{}\", sum_squares(vec![-2.4, 1.0, 1.0])); \/\/ 6\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);\n    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);\n    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);\n    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);\n    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);\n    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);\n    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n    assert_eq!(candidate(vec![0.0]), 0);\n    assert_eq!(candidate(vec![-1.0]), 1);\n    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);\n}\n"},{"task_id":"HumanEval_134","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଟିପ୍ପଣୀ: \"ୱାର୍ଡ\" ହେଉଛି ସ୍ପେସ୍ ଦ୍ୱାରା ପୃଥକ ହୋଇଥିବା ଅକ୍ଷରମାନଙ୍କର ଏକ ଗୋଷ୍ଠୀ ।\/\/\/ ଏକ ଶବ୍ଦର ଅଂଶ, ଏବଂ ଅନ୍ୟଥା ମିଥ୍ୟା ।\/\/\/ ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ଷ୍ଟ୍ରିଙ୍ଗର ଏକ ଆଲଫାବେଟିକ ଅକ୍ଷର ଅଟେ ଏବଂ ନୁହେଁ \/\/\/ ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି true କୁ ଫେରାଇଥାଏ ଯଦି ଶେଷ ଅକ୍ଷର \/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"\"))\n\/\/\/ false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n","canonical_solution":"fn check_if_last_char_is_a_letter(txt: String) -> bool {\n    if let Some(c) = txt.trim().chars().rev().next() {\n        if c.is_alphabetic() {\n            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {\n                return !prev_char.is_alphabetic();\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pie\")));  \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e\"))); \/\/ true\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e \"))); \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"\")));           \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n"},{"task_id":"HumanEval_135","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଦୋହରା ଯାଇଥିବା ମୂଲ୍ୟ ।\/\/\/ ଏପରି କୌଣସି ଉପାଦାନ ନାହିଁ ତେବେ ଫେରାଇବ -1. ଦିଆଯାଇଥିବା ଭେକ୍ଟର  ଧାରଣ କରିବ ନାହିଁ\/\/\/ ଏହାଠାରୁ ଅଧିକ କିମ୍ବା ସମାନ ନୁହେଁ, ଏହାଠାରୁ ତୁରନ୍ତ ପୂର୍ବବର୍ତ୍ତୀ ଉପାଦାନ ସହିତ ସମାନ ନୁହେଁ ।\/\/\/ ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ଉପାଦାନର ସର୍ବ ବୃହତ ସୂଚକାଙ୍କ ଫେରାଇଥାଏ ଯାହା \/\/\/ >>> can_arrange(vec![1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(vec![1, 2, 3])\n\/\/\/ -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn can_arrange(arr: Vec<isize>) -> isize {\n    for i in (1..arr.len()).rev() {\n        if arr[i] < arr[i - 1] {\n            return i as isize;\n        }\n    }\n    -1\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 4, 3, 5])); \/\/ Outputs: 3\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 3])); \/\/ Outputs: -1\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"},{"task_id":"HumanEval_136","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଯଦି କୌଣସି ନକାରାତ୍ମକ କିମ୍ବା ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ନଥାଏ, ତେବେ ଏହାକୁ None ଭାବରେ ଫେରାଇଦେବେ.\/\/\/ ଏକ ଭେକ୍ଟରରେ ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡ଼ିକର ।\/\/\/ ସବୁଠାରୁ ବଡ ନକାରାତ୍ମକ ସଂଖ୍ଯା, ଏବଂ 'b' ହେଉଛି ସବୁଠାରୁ ଛୋଟ \/\/\/ ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ଟାପଲ୍ (a, b) କୁ ଫେରାଇଥାଏ, ଯେଉଁଠାରେ 'a' ହେଉଛି \/\/\/ >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\/\/\/ (None, Some(1))\n\/\/\/ >>> largest_smallest_integers(vec![])\n\/\/\/ (None, None)\n\/\/\/ >>> largest_smallest_integers(vec![0])\n\/\/\/ (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n","canonical_solution":"fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative: Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\n    for &num in &lst {\n        if num < 0 {\n            largest_negative = match largest_negative {\n                Some(largest) => Some(largest.max(num)),\n                None => Some(num),\n            };\n        } else if num > 0 {\n            smallest_positive = match smallest_positive {\n                Some(smallest) => Some(smallest.min(num)),\n                None => Some(num),\n            };\n        }\n    }\n\n    (largest_negative, smallest_positive)\n}\n\nfn main() {\n    println!(\"{:?}\", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); \/\/ (None, Some(1))\n    println!(\"{:?}\", largest_smallest_integers(vec![])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![0])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); \/\/ (Some(-1), Some(2))\n}","tests":"}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));\n}\n"},{"task_id":"HumanEval_138","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ନିର୍ଦ୍ଦିଷ୍ଟ ସଂଖ୍ୟା n କୁ ସଠିକ ଭାବରେ 4 ଟି ସକାରାତ୍ମକ ଯୁଗ୍ମ ସଂଖ୍ୟାର ସମଷ୍ଟି ଭାବରେ ଲେଖାଯାଇପାରିବ କି ନାହିଁ ଆକଳନ କରନ୍ତୁ \/\/\/ >>> is_equal_to_sum_even(4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(8)\n\/\/\/ true\nfn is_equal_to_sum_even(n: isize) -> bool {\n","canonical_solution":"fn is_equal_to_sum_even(n: isize) -> bool {\n    \/\/ A number n can be expressed as the sum of 4 positive even numbers if and only if\n    \/\/ it is greater than or equal to 8 and even\n    n >= 8 && n % 2 == 0\n}\n\n\/\/ Test cases\nfn main() {\n    println!(\"{}\", is_equal_to_sum_even(4));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(6));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(8));  \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_equal_to_sum_even;\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), true);\n    assert_eq!(candidate(11), false);\n    assert_eq!(candidate(12), true);\n    assert_eq!(candidate(13), false);\n    assert_eq!(candidate(16), true);\n}\n"},{"task_id":"HumanEval_139","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଯେଉଁଠାରେ n > 0 \/\/\/ brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/\/ ବ୍ରାଜିଲୀୟ କାରକକୁ ନିମ୍ନଲିଖିତ ଭାବରେ ବ୍ୟାଖ୍ୟା କରାଯାଇଛି: \/\/\/ >>> special_factorial(4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n","canonical_solution":"fn factorial(n: isize) -> isize {\n    (1..=n).product()\n}\n\nfn special_factorial(n: isize) -> isize {\n    (1..=n).map(factorial).product()\n}\n\nfn main() {\n    let result = special_factorial(4);\n    println!(\"{}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"},{"task_id":"HumanEval_140","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ତାପରେ ସମସ୍ତ କ୍ରମିକ ସ୍ପେସ୍ କୁ -  ରେ ବଦଳାନ୍ତୁ\/\/\/ ଏବଂ ଯଦି ଏକ ଷ୍ଟ୍ରିଙ୍ଗରେ 2 ରୁ ଅଧିକ କ୍ରମିକ ସ୍ପେସ୍ ଅଛି, \/\/\/ ଏକ ପାଠ୍ୟ ଧାଡ଼ି ଦିଆଗଲା, ସେଥିରେ ଥିବା ସମସ୍ତ ସ୍ପେସକୁ ଅଣ୍ଡରସ୍କୋର ସହିତ ବଦଳାନ୍ତୁ, \/\/\/ >>> fix_spaces(String::from(\" Example\"))\n\/\/\/ String::from(\"Example\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 1\"))\n\/\/\/ String::from(\"Example_1\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 2\"))\n\/\/\/ String::from(\"_Example_2\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 3\"))\n\/\/\/ String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n","canonical_solution":"fn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut space_count = 0;\n\n    for c in text.chars() {\n        if c == ' ' {\n            space_count += 1;\n        } else {\n            if space_count > 2 {\n                result.push('-');\n            } else if space_count > 0 {\n                result.push_str(&\"_\".repeat(space_count));\n            }\n            result.push(c);\n            space_count = 0;\n        }\n    }\n\n    if space_count > 2 {\n        result.push('-');\n    } else if space_count > 0 {\n        result.push_str(&\"_\".repeat(space_count));\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = fix_spaces;\n    assert_eq!(candidate(String::from(\"Example\")), String::from(\"Example\"));\n    assert_eq!(candidate(String::from(\"Mudasir Hanif \")), String::from(\"Mudasir_Hanif_\"));\n    assert_eq!(candidate(String::from(\"Yellow Yellow  Dirty  Fellow\")), String::from(\"Yellow_Yellow__Dirty__Fellow\"));\n    assert_eq!(candidate(String::from(\"Exa   mple\")), String::from(\"Exa-mple\"));\n    assert_eq!(candidate(String::from(\"   Exa 1 2 2 mple\")), String::from(\"-Exa_1_2_2_mple\"));\n}\n"},{"task_id":"HumanEval_141","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ - ବିନ୍ଦୁ ପରେ ଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗ ନିମ୍ନଲିଖିତ ମଧ୍ୟରୁ ଗୋଟିଏ ହେବା ଉଚିତ: ['txt', 'exe', 'dll'] \/\/\/ ଲାଟିନ ଅକ୍ଷର ('a'-'z' ଏବଂ 'A'-'Z') ।\/\/\/ - ଡଟ୍ ପୂର୍ବରୁ ଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗ୍ ଖାଲି ହେବା ଉଚିତ ନୁହେଁ, ଏବଂ ଏହା  ରୁ ଏକ ଅକ୍ଷର ସହିତ ଆରମ୍ଭ ହୋଇଥାଏ\/\/\/ - ଫାଇଲ ନାମରେ ଗୋଟିଏ ବିନ୍ଦୁ ଅଛି '.' \/\/\/ - ଫାଇଲ ନାମରେ ତିନିରୁ ଅଧିକ ଅଙ୍କ ('0'-'9') ରହିବା ଉଚିତ ନୁହେଁ ।\/\/\/ ପୂରଣ ହୋଇଛି: \/\/\/ ଏକ ଫାଇଲର ନାମ ବୈଧ ବୋଲି ବିବେଚନା କରାଯାଏ ଯଦି ଏବଂ କେବଳ ଯଦି ନିମ୍ନଲିଖିତ ସମସ୍ତ ସର୍ତ୍ତ ପୂରଣ ହୁଏ \/\/\/ 'ହଁ' ଯଦି ଫାଇଲ ନାମ ବୈଧ, ଏବଂ ଅନ୍ୟଥା 'ନା' ଫେରାଇଥାଏ.\/\/\/ ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ଫାଇଲ ନାମକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ନେଇଥାଏ, ଏବଂ ଫେରାଇଥାଏ \/\/\/ >>> file_name_check(String::from(\"example.txt\"))\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> file_name_check(String::from(\"1example.dll\"))\n\/\/\/ String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n","canonical_solution":"fn file_name_check(file_name: String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n\n    if parts.len() != 2 {\n        return String::from(\"No\");\n    }\n\n    let before_dot = parts[0];\n    let after_dot = parts[1];\n\n    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {\n        return String::from(\"No\");\n    }\n\n    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return String::from(\"No\");\n    }\n\n    match after_dot {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _ => String::from(\"No\"),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\/this_is_valid.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n}\n"},{"task_id":"HumanEval_142","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଭେକ୍ଟରରେ ପ୍ରବେଶକୁ ପରିବର୍ତ୍ତନ କରନ୍ତୁ ଯାହାର ସୂଚକାଙ୍କ 3 କିମ୍ବା 4 ର ଗୁଣନ ନୁହେଁ _ ଫଳନ ତାପରେ ସମସ୍ତ ପ୍ରବେଶର ସମୁଦାୟ ଫେରାଇବ _\/\/\/ ଗୁଣନ 3 ଏବଂ ଏହା ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାକୁ ଘନ କରିବ ଯଦି ଏହାର ସୂଚକାଙ୍କ 4 ର ଗୁଣନ ଏବଂ 3 ର ଗୁଣନ ନୁହେଁ ।\/\/\/ ଏହି ଫଙ୍କସନଟି ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଭେକ୍ଟର ନେବ. ଭେକ୍ଟରରେ ଥିବା ସମସ୍ତ ଏଣ୍ଟ୍ରି ପାଇଁ, ଫଙ୍କସନଟି ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଏଣ୍ଟ୍ରିକୁ ବର୍ଗୀକରଣ କରିବ ଯଦି ଏହାର ଇଣ୍ଡେକ୍ସ ହେଉଛି a \/\/\/ \" \/\/\/ >>> lst\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> lst\n\/\/\/ vec![]\n\/\/\/ >>> lst\n\/\/\/ vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<isize>) -> isize {\n    lst.into_iter()\n        .enumerate()\n        .map(|(i, value)| {\n            if i % 3 == 0 {\n                value * value\n            } else if i % 4 == 0 {\n                value * value * value\n            } else {\n                value\n            }\n        })\n        .sum()\n}\n\nfn main() {\n    let lst = vec![1, 2, 3];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 14\n\n    let lst = vec![];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 0\n\n    let lst = vec![-1, -5, 2, -1, -5];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 112\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1, 2, 3]), 6);\n    assert_eq!(candidate(vec![1, 4, 9]), 14);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n    assert_eq!(candidate(vec![0]), 0);\n    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);\n    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);\n    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);\n    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n}\n"},{"task_id":"HumanEval_143","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ 1: \/\/\/ ନୂତନ ବାକ୍ୟଖଣ୍ଡରେ ଥିବା ଶବ୍ଦଗୁଡ଼ିକର କ୍ରମାଙ୍କ ମୂଳ ବାକ୍ୟଖଣ୍ଡର କ୍ରମାଙ୍କ ସହିତ ସମାନ ହେବା ଉଚିତ ।\/\/\/ ଯାହାର ଲମ୍ବ ଅଶୂନ୍ୟ ସଂଖ୍ୟା, \/\/\/ ଏବଂ ଆପଣଙ୍କୁ ମୂଳ ବାକ୍ୟର ଶବ୍ଦ ଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇବାକୁ ହେବ, \/\/\/ ବାକ୍ୟରେ କିଛି ଶବ୍ଦ ଅନ୍ତରିତ ସ୍ପେସ୍ ଅଛି, \/\/\/ ଆପଣଙ୍କୁ ଏକ ବାକ୍ୟକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଯାଏ, \/\/\/ >>> words_in_sentence(String::from(\"This is a test\"))\n\/\/\/ String::from(\"is\")\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(String::from(\"lets go for swimming\"))\n\/\/\/ String::from(\"go for\")\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n    let prime_length_words: Vec<&str> = words\n        .iter()\n        .filter(|&&word| is_prime(word.len()))\n        .cloned()\n        .collect();\n    prime_length_words.join(\" \")\n}\n\nfn main() {\n    assert_eq!(\n        words_in_sentence(String::from(\"This is a test\")),\n        String::from(\"is\")\n    );\n    assert_eq!(\n        words_in_sentence(String::from(\"lets go for swimming\")),\n        String::from(\"go for\")\n    );\n}","tests":"}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"));\n}\n"},{"task_id":"HumanEval_144","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଆପଣ ମାନିପାରିବେ ଯେ x, ଏବଂ n ହେଉଛି ବୈଧ ଖଣ୍ଡ, ଏବଂ ନାମକର୍ତ୍ତା ଭାବରେ ଶୂନ ନାହିଁ.\/\/\/ <numerator>\/<denominator> ଯେଉଁଠାରେ ଉଭୟ ସଂଖ୍ଯକ ଓ ନାମକ ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ଯା ଅଟେ ।\/\/\/ ଅନ୍ୟଥା. ଉଭୟ x ଏବଂ n, ଏକ ଫ୍ରାକସନ୍ ର ଷ୍ଟ୍ରିଙ୍ଗ୍ ରେପ୍ରେଜେଣ୍ଟେସନ୍, ଏବଂ ନିମ୍ନଲିଖିତ ଫର୍ମାଟ୍ ଅଛି, \/\/\/ x * n. ଯଦି x * n ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାକୁ ମୂଲ୍ୟାଙ୍କନ କରେ ଏବଂ false \/\/\/ ଆପଣଙ୍କର କାମ ହେଉଛି ଏକ ଫଳନକୁ କାର୍ଯ୍ୟକାରୀ କରିବା ଯାହା ଅଭିବ୍ୟକ୍ତିକୁ ସରଳ କରିବ \/\/\/ >>> simplify(String::from(\"1\/5\"), String::from(\"5\/1\"))\n\/\/\/ true\n\/\/\/ >>> simplify(String::from(\"1\/6\"), String::from(\"2\/1\"))\n\/\/\/ false\n\/\/\/ >>> simplify(String::from(\"7\/10\"), String::from(\"10\/2\"))\n\/\/\/ false\nfn simplify(x: String, n: String) -> bool {\n","canonical_solution":"fn gcd(a: u32, b: u32) -> u32 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn simplify(x: String, n: String) -> bool {\n    let x_parts: Vec<&str> = x.split('\/').collect();\n    let n_parts: Vec<&str> = n.split('\/').collect();\n    \n    let x_num: u32 = x_parts[0].parse().unwrap();\n    let x_den: u32 = x_parts[1].parse().unwrap();\n    let n_num: u32 = n_parts[0].parse().unwrap();\n    let n_den: u32 = n_parts[1].parse().unwrap();\n    \n    let result_num = x_num * n_num;\n    let result_den = x_den * n_den;\n    \n    let gcd_value = gcd(result_num, result_den);\n    \n    result_den \/ gcd_value == 1\n}","tests":"}\n\nfn main() {\n    let candidate = simplify;\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/6\"), String::from(\"2\/1\")), false);\n    assert_eq!(candidate(String::from(\"5\/1\"), String::from(\"3\/1\")), true);\n    assert_eq!(candidate(String::from(\"7\/10\"), String::from(\"10\/2\")), false);\n    assert_eq!(candidate(String::from(\"2\/10\"), String::from(\"50\/10\")), true);\n    assert_eq!(candidate(String::from(\"7\/2\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"11\/6\"), String::from(\"6\/1\")), true);\n    assert_eq!(candidate(String::from(\"2\/3\"), String::from(\"5\/2\")), false);\n    assert_eq!(candidate(String::from(\"5\/2\"), String::from(\"3\/5\")), false);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"8\/4\")), true);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"1\/5\")), false);\n}\n"},{"task_id":"HumanEval_145","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ମୂଳ ଭେକ୍ଟରରେ ସେମାନଙ୍କର ସୂଚକାଙ୍କ ଆଧାରରେ ସେମାନଙ୍କୁ ଅର୍ଡର କରନ୍ତୁ ।\/\/\/ ନୋଟ: ଯଦି ଏକାଧିକ ଆଇଟମ୍ ଅଛି ଯାହାର ଅଙ୍କ ସମୂହ ସମାନ, ତେବେ \/\/\/ ସେମାନଙ୍କର ଅଙ୍କ ସମୂହ ଅନୁସାରେ କ୍ରମାନୁସାରେ ।\/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଦିଆଯାଇଥିବା ଭେକ୍ଟରଗୁଡ଼ିକୁ \/\/\/ >>> order_by_points(vec![1, 11, -1, -11, -12])\n\/\/\/ vec![-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(vec![])\n\/\/\/ Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();\n\n    nums_with_indices.sort_by_key(|&(num, index)| {\n        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();\n        (sum_of_digits, index)\n    });\n\n    nums_with_indices.iter().map(|&(num, _)| num).collect()\n}\n\nfn main() {\n    \/\/ Example usage\n    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);\n    println!(\"{:?}\", sorted); \/\/ Output: [-1, -11, 1, -12, 11]\n}","tests":"}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"},{"task_id":"HumanEval_146","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଏକ ସଂଖ୍ୟାର ପ୍ରଥମ ଓ ଶେଷ ଅଙ୍କ ଅଙ୍କ (1, 3, 5, 7, 9) ।\/\/\/ ଭେକ୍ଟରରେ ଥିବା ଉପାଦାନର ସଂଖ୍ୟା 10 ରୁ ଅଧିକ ଏବଂ ଉଭୟ \/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ସଂଖ୍ୟା ଭେକ୍ଟର କୁ ଇନପୁଟ୍ ଭାବରେ ଗ୍ରହଣ କରେ ଏବଂ ଫେରସ୍ତ କରେ \/\/\/ >>> specialFilter(vec![15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn specialFilter(nums: Vec<isize>) -> isize {\n    nums.into_iter().filter(|&num| {\n        let abs_num = num.abs();\n        abs_num > 10 && {\n            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();\n            let first_digit = digits.first().unwrap();\n            let last_digit = digits.last().unwrap();\n            first_digit % 2 == 1 && last_digit % 2 == 1\n        }\n    }).count() as isize\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result1 = specialFilter(vec![15, -73, 14, -15]);\n\/\/     println!(\"{}\", result1); \/\/ Output: 1\n\n\/\/     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);\n\/\/     println!(\"{}\", result2); \/\/ Output: 2\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = specialFilter;\n    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);\n    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);\n    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);\n    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);\n    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n}\n"},{"task_id":"HumanEval_147","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଏବଂ a[i] + a[j] + a[k] ହେଉଛି 3 ର ଗୁଣନ ।\/\/\/ a ର ତ୍ରିଗୁଣ ସଂଖ୍ୟା (a[i], a[j], a[k]) କୁ ଫେରାଇଦିଏ ଯେଉଁଠାରେ i < j < k, \/\/ପ୍ରତ୍ୟେକ i (1 ≤ i ≤ n) ପାଇଁ, a[i] = i * i - i + 1 ର ମୂଲ୍ୟ ।\/\/\/ ଆପଣଙ୍କୁ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆ ଯାଇଛି. ଆପଣଙ୍କୁ ଏକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଭେକ୍ଟର a ର ଲମ୍ବ n ସୃଷ୍ଟି କରିବାକୁ ପଡିବ. \/\/\/ >>> get_max_triples(5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n","canonical_solution":"fn get_max_triples(n: isize) -> isize {\n    let mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    \n    let mut count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    println!(\"{}\", get_max_triples(5)); \/\/ Output: 1\n}","tests":"}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5), 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n    assert_eq!(candidate(100), 53361);\n}\n"},{"task_id":"HumanEval_149","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/ଆପଣମାନେ ଭାବୁଥିବେ ଯେ ସମସ୍ତ ଶବ୍ଦ ସମାନ ଲମ୍ବର ହେବ ।\/\/\/ ଫଳନଟି ଏକ ସର୍ଟ କ୍ରମରେ ଷ୍ଟ୍ରିଙ୍ଗର ଭେକ୍ଟର ଫେରାଇବ \/\/\/ ଯଦି ଦୁଇଟି ଶବ୍ଦର ଲମ୍ବ ସମାନ, ତେବେ ଭେକ୍ଟରକୁ ଆଲଫାବେଟିକ କ୍ରମରେ ସର୍ଟ କରନ୍ତୁ. \/\/\/ ସେହି ନିୟମ ଅନୁସାରେ ସର୍ଟ ହୋଇଥିବା ଭେକ୍ଟର ଫେରାଇବ \/\/\/ ଭେକ୍ଟରର କ୍ରମାଙ୍କ ପ୍ରତ୍ୟେକ ଶବ୍ଦର ଲମ୍ବ ଅନୁସାରେ ବୃଦ୍ଧି ହେବା ଉଚିତ, ଏବଂ ଆପଣ \/\/\/ ଏବଂ ଏଥିରେ ଡୁପ୍ଲିକେଟ୍ ରହିପାରେ ।\/\/\/ ଭେକ୍ଟର ସର୍ବଦା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଭେକ୍ଟର ଅଟେ ଏବଂ କେବେ ବି ସଂଖ୍ୟାର ଭେକ୍ଟର ନୁହେଁ, \/\/\/ ଏବଂ ଫଳାଫଳ ଭେକ୍ଟରକୁ ଏକ ସର୍ଟ କ୍ରମରେ ଫେରାଇଥାଏ, \/\/\/ ସେହି ଷ୍ଟ୍ରିଙ୍ଗକୁ ଡିଲିଟ୍ କରେ ଯାହାର ଅଙ୍କ ଅଙ୍କଠାରୁ ଅଙ୍କ ଲମ୍ବ ଅଙ୍କ ଲମ୍ବ, \/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଭେକ୍ଟରକୁ ପାରାମିଟର ଭାବରେ ଗ୍ରହଣ କରେ, \/\/\/ >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n\/\/\/ vec![String::from(\"aa\")]\n\/\/\/ >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n\/\/\/ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut even_length_strings: Vec<String> = lst\n        .into_iter()\n        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    \n    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    \n    even_length_strings\n}\n\nfn main() {\n    let result = sorted_list_sum(vec![\n        String::from(\"aa\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"aa\"]\n\n    let result = sorted_list_sum(vec![\n        String::from(\"ab\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n        String::from(\"cd\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"ab\", \"cd\"]\n}","tests":"}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")]);\n}\n"},{"task_id":"HumanEval_150","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା ଏବଂ y ର ମୂଲ୍ୟ ଫେରାଇବ _ ଅନ୍ୟଥା _\/\/\/ ଏକ ସରଳ ପ୍ରୋଗ୍ରାମ ଯାହା x ର ମୂଲ୍ୟ ଫେରାଇବ ଯଦି n ହେଉଛି \/\/\/ >>> x_or_y(7, 34, 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(15, 8, 5)\n\/\/\/ 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n","canonical_solution":"fn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        for i in 2..=((num as f64).sqrt() as isize) {\n            if num % i == 0 {\n                return false;\n            }\n        }\n        true\n    }\n    \n    if is_prime(n) {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    println!(\"{}\", x_or_y(7, 34, 12)); \/\/ Output: 34\n    println!(\"{}\", x_or_y(15, 8, 5)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = x_or_y;\n    assert_eq!(candidate(7, 34, 12), 34);\n    assert_eq!(candidate(15, 8, 5), 5);\n    assert_eq!(candidate(3, 33, 5212), 33);\n    assert_eq!(candidate(1259, 3, 52), 3);\n    assert_eq!(candidate(7919, -1, 12), -1);\n    assert_eq!(candidate(3609, 1245, 583), 583);\n    assert_eq!(candidate(91, 56, 129), 129);\n    assert_eq!(candidate(6, 34, 1234), 1234);\n    assert_eq!(candidate(1, 2, 0), 0);\n    assert_eq!(candidate(2, 2, 0), 2);\n}\n"},{"task_id":"HumanEval_151","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଭେକ୍ଟରରେ ଅଙ୍କଗୁଡ଼ିକ ଅଙ୍କ ହୋଇଥିବ, ନକାରାତ୍ମକ ସଂଖ୍ୟାଗୁଡ଼ିକୁ ଅଗ୍ରାହ୍ୟ କରିଦିଆଯିବ, ଅଥବା ଅଙ୍କଗୁଡ଼ିକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ହୋଇନଥିବ ।\/\/\/ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ଭେକ୍ଟର ଦିଆଯାଇ, ସଂଖ୍ୟାଗୁଡ଼ିକର ବର୍ଗର ସମୁଦାୟକୁ ଫେରାଇଦିଅନ୍ତୁ \/\/\/ >>> double_the_difference(vec![1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(vec![-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(vec![9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(vec![0])\n\/\/\/ 0\n\/\/\/ If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn double_the_difference(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)\n        .map(|&x| (x as isize).pow(2))\n        .sum()\n}\n\nfn main() {\n    println!(\"{}\", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); \/\/ 10\n    println!(\"{}\", double_the_difference(vec![-1.0, -2.0, 0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![9.0, -2.0])); \/\/ 81\n    println!(\"{}\", double_the_difference(vec![0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![])); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()), 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"},{"task_id":"HumanEval_152","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ମୂଲ୍ୟ 0 ଅଟେ, ଏବଂ ଯଦି ନାହିଁ, ତେବେ ମୂଲ୍ୟ ହେଉଛି ଅନୁମାନ ଏବଂ ସ୍କୋର ମଧ୍ୟରେ ଥିବା ସମ୍ପୂର୍ଣ୍ଣ ପାର୍ଥକ୍ୟ _\/\/\/ ସମାନ ଲମ୍ବର ଏକ ଭେକ୍ଟର ଫେରାଇ ଦିଅନ୍ତୁ, ପ୍ରତ୍ୟେକ ଅନୁମାନ କେତେ ଦୂର ଥିଲା ତାହା ଦର୍ଶାଇଥାଏ _ ଯଦି ସେମାନେ ସଠିକ୍ ଅନୁମାନ କରିଛନ୍ତି, \/\/ଆପଣଙ୍କୁ ଦୁଇଟା ସ୍କୋର ଓ ଅନୁମାନର ଭେକ୍ଟର ଦିଆଯାଉଛି, ଯାହାର ଲମ୍ବ ସମାନ, ଯେଉଁଠି ପ୍ରତ୍ୟେକ ସୂଚକାଙ୍କରେ ଗୋଟିଏ ମେଳ ଦେଖାଯାଇଥାଏ ।\/\/\/ ଆପଣଙ୍କ କାମ ହେଉଛି ଏହା ଜାଣିବା ଯେ ଜଣେ ବ୍ୟକ୍ତି କେତେଗୁଡ଼ିଏ ମ୍ୟାଚର ଫଳାଫଳକୁ ସଠିକ ଭାବରେ ଅନୁମାନ କରିପାରିଛନ୍ତି କି ନାହିଁ ।\/\/\/ ନିଶ୍ଚିତ ଭାବେ ଉଲ୍ଲେଖ କରିବା ଓ ତୁଳନା କରିବା ଆବଶ୍ୟକ । \/\/ଏହି ଘଟଣାଟି ଶେଷରେ ଜଣା ପଡିଛି । ସେହି ମୁହୂର୍ତ୍ତରେ ଆପଣଙ୍କର ଭାବନା ଓ ଚିନ୍ତାଧାରା ହେଉଛି \/\/ମୁଁ ଭାବୁଛି ଆମେ ସମସ୍ତେ ସେହି ଅନୁଭବକୁ ମନେ ପକାଉଛୁ ଯେତେବେଳେ କୌଣସି ଦୀର୍ଘ ପ୍ରତୀକ୍ଷିତ ଙ୍କର ପରିଣାମ \/\/\/ >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n\/\/\/ vec![0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n\/\/\/ vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    game.iter()\n        .zip(guess.iter())\n        .map(|(g, gss)| (g - gss).abs())\n        .collect()\n}\n\nfn main() {\n    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);\n    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);\n    println!(\"{:?}\", result1); \/\/ Output: [0, 0, 0, 0, 3, 3]\n    println!(\"{:?}\", result2); \/\/ Output: [4, 4, 1, 0, 0, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = compare;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);\n    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);\n    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);\n    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);\n}\n"},{"task_id":"HumanEval_153","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ (ଏହାର ଶକ୍ତି -୧) ।\/\/\/ return 'Slices.SErviNGSliCes' କାରଣ 'SErviNGSliCes' ହେଉଛି ସବୁଠାରୁ ଅଧିକ ଶକ୍ତିଶାଳୀ ସଂପ୍ରସାରଣ \/\/\/ ସଂପ୍ରସାରଣଃ ['ସର୍ଭିଙ୍ଗ୍ ସିଲିସେସ୍', 'ଚିଜ୍', 'ଷ୍ଟୁଫେଡ୍'] ତେବେ ଆପଣ \/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ, ଯଦି ଆପଣଙ୍କୁ \"Slices\" ଦିଆଯାଏ ତେବେ ଏହା ହେଉଛି ଶ୍ରେଣୀ ଏବଂ ଭେକ୍ଟର \/\/\/ ଭେକ୍ଟରରେ ପ୍ରଥମେ ଆସୁଥିବା ଗୋଟିଏକୁ ବାଛନ୍ତୁ.\/\/\/ ଯଦି ଦୁଇଟି କିମ୍ବା ଅଧିକ ସଂପ୍ରସାରଣ ସମାନ ଶକ୍ତି ସହିତ ଅଛି, ତେବେ ଆପଣ \/\/\/ ଶୈଳୀ: ଶ୍ରେଣୀ ନାମ. ଶକ୍ତିଶାଳୀ ଅନୁଲଗ୍ନ ନାମ. \/\/\/ ଆପଣଙ୍କୁ ସବୁଠାରୁ ଅଧିକ ଶକ୍ତିଶାଳୀ ସଂପ୍ରସାରଣ ଖୋଜିବାକୁ ହେବ ଏବଂ ଏଥିରେ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ଫେରାଇବାକୁ ହେବ \/\/\/ ସଂପ୍ରସାରଣ ନାମରେ, ଶକ୍ତି CAP - SM ଅଂଶ ଦ୍ବାରା ଦିଆଯାଇଥାଏ । \/\/\/ ଅକ୍ଷର ସଂପ୍ରସାରଣ ନାମରେ, ଏବଂ SM କୁ ଛୋଟ ଅକ୍ଷର ସଂଖ୍ୟା ଭାବରେ ଗ୍ରହଣ କରନ୍ତୁ \/\/\/ ସଂପ୍ରସାରଣର ଶକ୍ତି ନିମ୍ନଲିଖିତ ଅଟେ: CAP କୁ ବଡ଼ ଅକ୍ଷରର ସଂଖ୍ୟା ବୋଲି ଧରିନେବା \/\/\/ ସମ୍ପ୍ରସାରଣଗୁଡ଼ିକ ଶ୍ରେଣୀକୁ ଅତିରିକ୍ତ ଶ୍ରେଣୀଗୁଡ଼ିକୁ ଲୋଡ୍ କରିବା ପାଇଁ ବ୍ୟବହୃତ ହେବ ।\/\/\/ ଆପଣଙ୍କୁ ଏକ ଶ୍ରେଣୀ ନାମ (ଏକ ଷ୍ଟ୍ରିଙ୍ଗ) ଏବଂ ଏକ୍ସଟେନସନ ଭେକ୍ଟର ଦିଆଯିବ. \/\/\/ >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n\/\/\/ String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n","canonical_solution":"fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut strongest_extension = String::new();\n    let mut max_strength = i32::MIN;\n\n    for extension in extensions {\n        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;\n        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;\n        let strength = cap_count - sm_count;\n\n        if strength > max_strength {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, strongest_extension)\n}","tests":"}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"},{"task_id":"HumanEval_154","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଆପଣଙ୍କୁ 2 ଟି ଶବ୍ଦ ଦିଆଯାଇଛି. ଆପଣଙ୍କୁ ସତ୍ୟ ଫେରାଇବାକୁ ହେବ ଯଦି ଦ୍ୱିତୀୟ ଶବ୍ଦ କିମ୍ବା ଏହାର କୌଣସି ଘୂର୍ଣ୍ଣନ ପ୍ରଥମ ଶବ୍ଦରେ ଏକ ସବଷ୍ଟ୍ରିଙ୍ଗ୍ \/\/\/ >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n\/\/\/ true\nfn cycpattern_check(a: String, b: String) -> bool {\n","canonical_solution":"fn cycpattern_check(a: String, b: String) -> bool {\n    let len_b = b.len();\n    if len_b == 0 {\n        return true;\n    }\n    let doubled_b = b.clone() + &b;\n    for i in 0..len_b {\n        if let Some(sub) = doubled_b.get(i..i + len_b) {\n            if a.contains(sub) {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = cycpattern_check;\n    assert_eq!(candidate(String::from(\"xyzw\"), String::from(\"xyw\")), false);\n    assert_eq!(candidate(String::from(\"yello\"), String::from(\"ell\")), true);\n    assert_eq!(candidate(String::from(\"whattup\"), String::from(\"ptut\")), false);\n    assert_eq!(candidate(String::from(\"efef\"), String::from(\"fee\")), true);\n    assert_eq!(candidate(String::from(\"abab\"), String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"winemtt\"), String::from(\"tinem\")), true);\n}\n"},{"task_id":"HumanEval_155","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଦିଆଗଲା. ଏକ ଟାପଲ୍ ଫେରାଇଥାଏ ଯେଉଁଥିରେ ଯଥାକ୍ରମେ ଯୁଗ୍ମ ଏବଂ ଅଙ୍କ ସଂଖ୍ୟା ଥାଏ. \/\/\/ >>> even_odd_count(-12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(123)\n\/\/\/ (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n","canonical_solution":"fn even_odd_count(num: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    let num_str = num.abs().to_string();\n    \n    for ch in num_str.chars() {\n        if let Some(digit) = ch.to_digit(10) {\n            if digit % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_count;\n    assert_eq!(candidate(7), (0, 1));\n    assert_eq!(candidate(-78), (1, 1));\n    assert_eq!(candidate(3452), (2, 2));\n    assert_eq!(candidate(346211), (3, 3));\n    assert_eq!(candidate(-345821), (3, 3));\n    assert_eq!(candidate(-2), (1, 0));\n    assert_eq!(candidate(-45347), (2, 3));\n    assert_eq!(candidate(0), (1, 0));\n}\n"},{"task_id":"HumanEval_156","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ପ୍ରତିବନ୍ଧକ: 1 <= ସଂଖ୍ୟା <= 1000 \/\/\/ ଏବଂ ଏହାକୁ ଛୋଟ ଅକ୍ଷରରେ ଫେରାଇ ଦିଅନ୍ତୁ. \/\/\/ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଦିଆଗଲା, ଏହାର ରୋମାନ୍ ସଂଖ୍ୟା ସମକକ୍ଷକୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ରୂପରେ ପ୍ରାପ୍ତ କରନ୍ତୁ, \/\/\/ >>> int_to_mini_roman(19)\n\/\/\/ String::from(\"xix\")\n\/\/\/ >>> int_to_mini_roman(152)\n\/\/\/ String::from(\"clii\")\n\/\/\/ >>> int_to_mini_roman(426)\n\/\/\/ String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n","canonical_solution":"fn int_to_mini_roman(mut number: isize) -> String {\n    let roman_numerals = [\n        (1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n        (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n        (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"),\n        (1, \"i\"),\n    ];\n    \n    let mut result = String::new();\n    \n    for &(value, symbol) in roman_numerals.iter() {\n        while number >= value {\n            number -= value;\n            result.push_str(symbol);\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"},{"task_id":"HumanEval_157","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/90 ଡିଗ୍ରୀ ।\/\/\/ ଏକ ସଠିକ କୋଣ ବିଶିଷ୍ଟ ତ୍ରିଭୁଜ ହେଉଛି ଏକ ତ୍ରିଭୁଜ ଯେଉଁଥିରେ ଗୋଟିଏ କୋଣ ସଠିକ କୋଣ ବା \/\/\/ ପାର୍ଶ୍ବଗୁଡ଼ିକ ଏକ ସଠିକ କୋଣ ବିଶିଷ୍ଟ ତ୍ରିଭୁଜ ଗଠନ କରେ, ଅନ୍ୟଥା ଏହା ମିଥ୍ୟା ଅଟେ ।\/\/\/ ତ୍ରିଭୁଜର ତିନୋଟି ପାର୍ଶ୍ବ ର ଲମ୍ବ ଦିଆଗଲା.\/\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/\/ false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n","canonical_solution":"fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let mut sides = [a, b, c];\n    sides.sort_unstable();\n\n    let [x, y, z] = sides;\n    x * x + y * y == z * z\n}","tests":"}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3, 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10, 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7, 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5, 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48, 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2, 2, 10), false);\n}\n"},{"task_id":"HumanEval_158","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଅକ୍ଷର, ଶବ୍ଦକୋଷିକ କ୍ରମରେ ପ୍ରଥମେ ଆସୁଥିବା ଅକ୍ଷରକୁ ଫେରାଇଥାଏ ।\/\/\/ ଅଦ୍ଭୁତ ଅକ୍ଷର ର. ଯଦି ଏକାଧିକ ଶୃଙ୍ଖଳାରେ ସର୍ବାଧିକ ଅଦ୍ଭୁତ ଅକ୍ଷର  ଅଛି\/\/\/ ଭେକ୍ଟରରେ ଭିନ୍ନ ଭିନ୍ନ ଶବ୍ଦ ଅଛି. ସର୍ବାଧିକ ସଂଖ୍ୟକ ସହିତ ଶବ୍ଦକୁ ଫେରାନ୍ତୁ \/\/\/ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଷ୍ଟ୍ରିଙ୍ଗର ଭେକ୍ଟର ଗ୍ରହଣ କରେ. \/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n\/\/\/ String::from(\"string\")\n\/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n\/\/\/ String::from(\"enam\")\n\/\/\/ >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n\/\/\/ String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n","canonical_solution":"fn find_max(words: Vec<String>) -> String {\n    fn unique_char_count(s: &str) -> usize {\n        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();\n        for c in s.chars() {\n            chars.insert(c);\n        }\n        chars.len()\n    }\n\n    words\n        .into_iter()\n        .max_by(|a, b| {\n            let count_a = unique_char_count(a);\n            let count_b = unique_char_count(b);\n            count_a.cmp(&count_b).then_with(|| a.cmp(b))\n        })\n        .unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n"},{"task_id":"HumanEval_159","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ: \/\/\/ ଯଦି ସେଠାରେ ଯଥେଷ୍ଟ ପରିମାଣର ଗାଜର ନରହିଲା, ତେବେ ଆପଣ ସମସ୍ତ ଗାଜର ଖାଇଦେବେ, କିନ୍ତୁ ତଥାପି ଭୋକିଲା ରହିବେ ।\/\/\/ ଆପଣଙ୍କ ଭୋଜନ ପରେ ବାକିଥିବା ଗାଜରର ସଂଖ୍ୟା ] \/\/\/ ଆପଣ ଏକ ଭେକ୍ଟର ଫେରାଇବେ [ ଭୋଜନ ପରେ ଖାଇଥିବା ଗାଜରର ମୋଟ ସଂଖ୍ୟା, \/\/କିନ୍ତୁ ବର୍ତ୍ତମାନ ଆପଣଙ୍କୁ ଅଧିକ ଗାଜର ଖାଇବା ଆବଶ୍ୟକ, ଯାହା ଦିନର ଭୋଜନକୁ ସମ୍ପୂର୍ଣ୍ଣ କରିବ ।\/\/ତୁମେ ଭୋକିଲା ବିଲେଇ, ଏବଂ ତୁମେ ପୂର୍ବରୁ କିଛି ଗାଜର ଖାଇ ସାରିଛ,\/\/\/ >>> eat(5, 6, 10)\n\/\/\/ vec![11, 4]\n\/\/\/ >>> eat(4, 8, 9)\n\/\/\/ vec![12, 1]\n\/\/\/ >>> eat(1, 10, 10)\n\/\/\/ vec![11, 0]\n\/\/\/ >>> eat(2, 11, 5)\n\/\/\/ vec![7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n","canonical_solution":"fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let to_eat = if need <= remaining { need } else { remaining };\n    vec![number + to_eat, remaining - to_eat]\n}","tests":"}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"},{"task_id":"HumanEval_160","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଅପରେଟର ଭେକ୍ଟରରେ ଅତି କମରେ ଗୋଟିଏ ଅପରେଟର ଥାଏ, ଏବଂ ଅପରେଣ୍ଡ ଭେକ୍ଟରରେ ଅତି କମରେ ଦୁଇଟି ଅପରେଣ୍ଡ ଥାଏ ।\/\/\/ ଅପରେଣ୍ଡ ହେଉଛି ଏକ ଭେକ୍ଟର, ନନ୍-ନେଗେଟିଭ୍ ଇଣ୍ଟେଜର ।\/\/\/ ଅପରେଟର ଭେକ୍ଟରର ଲମ୍ବ ଅପରେଣ୍ଡ ଭେକ୍ଟର ଲମ୍ବ ଏକରୁ କମ୍ ।\/\/\/ ଟିପ୍ପଣୀ: \/\/\/ => ଫଳାଫଳ = 9 \/\/\/ ଫଳ = 2 + 3 * 4 - 5 \/\/\/ ଭେକ୍ଟର = [2, 3, 4, 5] \/\/\/ ଅପରେଟର ['+', '*', '-'] \/\/\/ ଉଦାହରଣ: \/\/\/ ବିସ୍ତାରିତ (**) \/\/\/ ତଳ ବିଭାଗ ( \/\/ ) \/\/\/ ଗୁଣନ (*) \/\/\/ ହଟାଇବା (- ) \/\/\/ ଯୋଗ କରିବା (+) \/\/ମୌଳିକ ବୀଜାଣୁ କ୍ରିୟା:\/\/\/ ଅଭିବ୍ୟକ୍ତି ଏବଂ ଏହି ଅଭିବ୍ୟକ୍ତିର ମୂଲ୍ୟାଙ୍କନ ଫେରାଇଥାଏ.\/\/\/ ଦ୍ବିତୀୟ ଭେକ୍ଟର ହେଉଛି ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଭେକ୍ଟର. ଆଲଜେବ୍ରିକ ନିର୍ମାଣ ପାଇଁ ଦୁଇଟି ଦିଆଯାଇଥିବା ଭେକ୍ଟର ବ୍ୟବହାର କରନ୍ତୁ \/\/\/ ଦୁଇଟି ଭେକ୍ଟର ଅପରେଟର ଏବଂ ଅପରେଣ୍ଡ ଦିଆଗଲା । ପ୍ରଥମ ଭେକ୍ଟରରେ ମୌଳିକ ଆଲଜେବ୍ରିକ କାର୍ଯ୍ୟ ଅଛି, ଏବଂ fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n","canonical_solution":"fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = operand[0];\n    \n    for i in 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i+1],\n            \"-\" => result -= operand[i+1],\n            \"*\" => result *= operand[i+1],\n            \"\/\/\" => result \/= operand[i+1],\n            \"**\" => result = result.pow(operand[i+1] as u32),\n            _ => panic!(\"Unexpected operator\"),\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    let operators = vec![\"+\",\"*\",\"-\"].iter().map(|s| s.to_string()).collect();\n    let operands = vec![2, 3, 4, 5];\n    let result = do_algebra(operators, operands);\n    println!(\"Result: {}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"**\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"+\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\/\/\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"},{"task_id":"HumanEval_161","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ \/\/\/ ଫଳନଟି ଫଳାଫଳ ବାକ୍ୟଖଣ୍ଡକୁ ଫେରାଇବ. \/\/\/ ଯଦି ଶୃଙ୍ଖଳରେ କୌଣସି ଅକ୍ଷର ନଥାଏ, ତେବେ ଶୃଙ୍ଖଳକୁ ଓଲଟାଇ ଦିଅନ୍ତୁ.\/\/\/ ନଚେତ ସେମିତି ରଖ ।\/\/\/ ଯଦି s[i] ଏକ ଅକ୍ଷର, ତେବେ ଏହାର କେସ୍ କୁ ନିମ୍ନରୁ ଉପର କିମ୍ବା ବାମକୁ ଓଲଟାଇ ଦିଅନ୍ତୁ, \/\/\/ ଆପଣଙ୍କୁ ଏକ କ୍ରମ s ଦିଆଯାଉଛି. \/\/\/ >>> solve(String::from(\"1234\"))\n\/\/\/ String::from(\"4321\")\n\/\/\/ >>> solve(String::from(\"ab\"))\n\/\/\/ String::from(\"AB\")\n\/\/\/ >>> solve(String::from(\"#a@C\"))\n\/\/\/ String::from(\"#A@c\")\nfn solve(s: String) -> String {\n","canonical_solution":"fn solve(s: String) -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n        s.chars()\n            .map(|c| {\n                if c.is_lowercase() {\n                    c.to_ascii_uppercase()\n                } else if c.is_uppercase() {\n                    c.to_ascii_lowercase()\n                } else {\n                    c\n                }\n            })\n            .collect()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"},{"task_id":"HumanEval_162","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଯଦି 'text' ଏକ ଖାଲି ଷ୍ଟ୍ରିଙ୍ଗ, ତେବେ None କୁ ଫେରାଇଥାଏ.\/\/\/ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ 'ଟେକ୍ସଟ' ଦିଆଗଲା, ଏହାର md5 ହ୍ୟାଶ ସମକକ୍ଷ ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇଦେବେ. \/\/\/ >>> string_to_md5(String::from(\"Hello world\"))\n\/\/\/ Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n","canonical_solution":"use md5;\n\nfn string_to_md5(text: String) -> Option<String> {\n    if text.is_empty() {\n        return None;\n    }\n    let digest = md5::compute(text);\n    Some(format!(\"{:x}\", digest))\n}","tests":"}\n\nfn main() {\n    let candidate = string_to_md5;\n    assert_eq!(candidate(String::from(\"Hello world\")), Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert_eq!(candidate(String::from(\"\")), None);\n    assert_eq!(candidate(String::from(\"A B C\")), Some(String::from(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert_eq!(candidate(String::from(\"password\")), Some(String::from(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n}\n"},{"task_id":"HumanEval_163","nl":"ory_Orya","pl":"rs","prompt":"\/\/\/ ଉଦାହରଣ ସ୍ୱରୂପ: \/\/\/ ଏବଂ b, କ୍ରମାନୁସାରେ ।\/\/\/ ଦୁଇଟି ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା a ଏବଂ b ଦିଆଗଲା, a  ମଧ୍ୟରେ ଥିବା ଯୁଗ୍ମ ଅଙ୍କକୁ ଫେରାଇଦେବେ\/\/\/ >>> generate_integers(2, 8)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(8, 2)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(10, 14)\n\/\/\/ Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n","canonical_solution":"fn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let (start, end) = if a < b { (a, b) } else { (b, a) };\n    (start..=end).filter(|&x| x % 2 == 0).collect()\n}\n\nfn main() {\n    let result1 = generate_integers(2, 8);\n    println!(\"{:?}\", result1); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result2 = generate_integers(8, 2);\n    println!(\"{:?}\", result2); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result3 = generate_integers(10, 14);\n    println!(\"{:?}\", result3); \/\/ Output: vec![10, 12, 14]\n}","tests":"}\n\nfn main() {\n    let candidate = generate_integers;\n    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(17, 89), Vec::<isize>::new());\n}\n"}]