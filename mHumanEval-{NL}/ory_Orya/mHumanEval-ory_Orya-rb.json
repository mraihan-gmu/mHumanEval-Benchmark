[{"task_id":"HumanEval_0","nl":"ory_Orya","pl":"rb","prompt":"ଏହି ତ୍ରୟୋଦଶ ବର୍ଷରେଯାଞ୍ଚ କରନ୍ତୁ ଯେ, କୌଣସି ଦୁଇଟି ସଂଖ୍ୟା  ଠାରୁ ପରସ୍ପରର ନିକଟତର କି ନୁହେଁ ।# >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# true\ndef has_close_elements(numbers, threshold)\n","canonical_solution":"def has_close_elements(numbers, threshold)\n  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n  end\nend\n"},{"task_id":"HumanEval_1","nl":"ory_Orya","pl":"rb","prompt":"ପ୍ରବେଶ ସଂକେତରେ ଥିବା ସମସ୍ତ ସ୍ପେସକୁ ଅଣଦେଖା କରନ୍ତୁ.ଅଲଗା ଅଲଗା ଗୋଷ୍ଠୀ ସନ୍ତୁଳିତ (ପ୍ରତ୍ୟେକ ଖୋଲା କଣ୍ଟା ସଠିକ ଭାବରେ ବନ୍ଦ) ଏବଂ ପରସ୍ପର ମଧ୍ୟରେ ନାଇଷ୍ଟ୍ ହୋଇନଥାଏ _ସେହି ସମୂହକୁ ପୃଥକ ଧାଡ଼ିରେ ଅଲଗା କରନ୍ତୁ ଏବଂ ସେହିଗୁଡ଼ିକର ସରଳୀକରଣ ଫେରାନ୍ତୁ.ଏହି ଫଳନକୁ ଇନପୁଟ୍ କରିବା ପାଇଁ ଗୋଟିଏ ଷ୍ଟ୍ରିଙ୍ଗ ଅଛି ଯେଉଁଥିରେ ନେଷ୍ଟ୍ ବାକ୍ୟଖଣ୍ଡର ଏକାଧିକ ଗୋଷ୍ଠୀ ଅଛି. ଆପଣଙ୍କର ଲକ୍ଷ୍ୟ ହେଉଛି # >>> separate_paren_groups.call(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\ndef separate_paren_groups(paren_string)\n","canonical_solution":"def separate_paren_groups(paren_string)\n  # Remove spaces from the string\n  paren_string = paren_string.gsub(\" \", \"\")\n  \n  result = []\n  current_group = \"\"\n  balance = 0\n\n  paren_string.each_char do |char|\n    current_group += char\n    balance += 1 if char == '('\n    balance -= 1 if char == ')'\n\n    if balance == 0 && !current_group.empty?\n      result << current_group\n      current_group = \"\"\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_separate_paren_groups\n    candidate = method(:separate_paren_groups)\n    assert_equal([\"(()())\", \"((()))\", \"()\", \"((())()())\"], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([\"()\", \"(())\", \"((()))\", \"(((())))\"], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([\"(()(())((())))\"], candidate.call(\"(()(())((())))\"))\n    assert_equal([\"()\", \"(())\", \"(()())\"], candidate.call(\"( ) (( )) (( )( ))\"))\n  end\nend\n"},{"task_id":"HumanEval_2","nl":"ory_Orya","pl":"rb","prompt":"ସଂଖ୍ୟାର ଦଶମିକ ଅଂଶକୁ ଫେରାଇଦିଅନ୍ତୁ.(ବଳକା ଅଂଶ ସବୁବେଳେ ୧ ରୁ କମ୍) ।ଏବଂ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଅଂଶ (ଦତ୍ତ ସଂଖ୍ୟା ଠାରୁ ବଡ଼ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା) ଏବଂ ଦଶମିକ ସଂଖ୍ୟା ଏକ ସକାରାତ୍ମକ ଭାସମାନ ବିନ୍ଦୁ ସଂଖ୍ୟା ଦିଆଗଲା, ଏହାକୁ  ରେ ବିଭକ୍ତ କରାଯାଇପାରିବ# >>> truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n","canonical_solution":"def truncate_number(number)\n  number - number.to_i\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n  end\nend\n"},{"task_id":"HumanEval_3","nl":"ory_Orya","pl":"rb","prompt":"ସେହି ସମୟରେ ଫଳନଟି true ଫେରାଇବ । ଅନ୍ୟଥା ଏହା false ଫେରାଇବ ।ଶୂନ ସନ୍ତୁଳନ. ଆପଣଙ୍କର କାମ ହେଉଛି ଯେ କୌଣସି ସମୟରେ ଖାତାର ସନ୍ତୁଳନ ଶୂନ ତଳକୁ ଖସିଗଲେ, ଏବଂ ଆପଣଙ୍କୁ ଏକ ବ୍ୟାଙ୍କ ଖାତାରେ ଜମା ଓ ଉଠାଣର ଏକ ଶୃଙ୍ଖଳ ଦିଆଯାଇଛି ଯାହା  ସହିତ ଆରମ୍ଭ ହୋଇଥାଏ# >>> below_zero.call([1, 2, 3])\n# false\n# >>> below_zero.call([1, 2, -4, 5])\n# true\ndef below_zero(operations)\n","canonical_solution":"def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_zero\n    candidate = method(:below_zero)\n    assert_equal(false, candidate.call([]))\n    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))\n    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))\n    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))\n    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))\n    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))\n  end\nend\n"},{"task_id":"HumanEval_4","nl":"ory_Orya","pl":"rb","prompt":"MAD = ହାରାହାରି  x - x_mean ଉପାଦାନ ଏବଂ ଏକ କେନ୍ଦ୍ର ବିନ୍ଦୁ (ଏହି କ୍ଷେତ୍ରରେ ମଧ୍ୟମ):ମଝି ଅବଲମ୍ବନ ବିଚ୍ୟୁତି ହେଉଛି ଉଭୟର ହାରାହାରି ଅବଲମ୍ବନ ବିଚ୍ୟୁତି ।ଏହି ଡାଟାସେଟର ହାରାହାରି ପାଖାପାଖି ।ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ଆରେରେ ନିବେଶ ସଂଖ୍ୟା ପାଇଁ, ମିଆଁନ ଅବ୍ ସଲ୍ୟୁଟ ଡିଭାଇଏସନ ଗଣନା କରନ୍ତୁ # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n# 1.0\ndef mean_absolute_deviation(numbers)\n","canonical_solution":"def mean_absolute_deviation(numbers)\n  mean = numbers.sum.to_f \/ numbers.size\n  deviations = numbers.map { |num| (num - mean).abs }\n  deviations.sum \/ numbers.size\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0, 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"},{"task_id":"HumanEval_5","nl":"ory_Orya","pl":"rb","prompt":"ପ୍ରତ୍ୟେକ ଦୁଇ କ୍ରମିକ ଉପାଦାନ ମଧ୍ୟରେ ଏକ ସଂଖ୍ୟା 'ବ୍ୟାପକ' ଭର୍ତ୍ତି କରନ୍ତୁ _# >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n","canonical_solution":"def intersperse(numbers, delimeter)\n  return numbers if numbers.empty?\n  result = []\n  numbers.each_with_index do |num, index|\n    result << num\n    result << delimeter unless index == numbers.size - 1\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"},{"task_id":"HumanEval_6","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ (() (()) ରେ ସର୍ବାଧିକ ଦୁଇଟି ସ୍ତର ଥିବା ବେଳେ ((())) ରେ ତିନୋଟି ସ୍ତର ରହିଛି ।ପ୍ରତ୍ୟେକ ଗୋଷ୍ଠୀ ପାଇଁ, ବ୍ରେକହୋଲଗୁଡ଼ିକର ଗଣ୍ଠିକରଣର ଗଭୀରତମ ସ୍ତରକୁ ବାହାର କରନ୍ତୁ.ଏହି ଫଳନକୁ ଇନପୁଟ୍ ହେଉଛି ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଯାହାକି ଅନ୍ତଃସ୍ଥଳ ବନ୍ଧନୀ ପାଇଁ ସ୍ପେସ୍ ଦ୍ୱାରା ପୃଥକ ହୋଇଥିବା ଏକାଧିକ ଗୋଷ୍ଠୀକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ।# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n","canonical_solution":"def parse_nested_parens(paren_string)\n  paren_string.split.map do |group|\n    max_depth = current_depth = 0\n    group.chars.each do |char|\n      if char == '('\n        current_depth += 1\n        max_depth = [max_depth, current_depth].max\n      elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"))\n  end\nend\n"},{"task_id":"HumanEval_7","nl":"ory_Orya","pl":"rb","prompt":"କେବଳ ସେହିଗୁଡ଼ିକ ପାଇଁ ନିବେଶ ଶୃଙ୍ଖଳାର ଏକ ମାପଦଣ୍ଡକୁ ଫିଲ୍ଟର୍ କରନ୍ତୁ ଯେଉଁଥିରେ ଦିଆଯାଇଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗ ଅଛି # >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\ndef filter_by_substring(strings, substring)\n","canonical_solution":"def filter_by_substring(strings, substring)\n  strings.select { |string| string.include?(substring) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"))\n  end\nend\n"},{"task_id":"HumanEval_8","nl":"ory_Orya","pl":"rb","prompt":"ଶୂନ୍ୟ ସମୂହ ଶୂନ ହେବା ଉଚିତ ଏବଂ ଶୂନ୍ୟ ଗୁଣନ ୧ ହେବା ଉଚିତ ।ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ପାଇଁ, ଏକ ସମୁଦାୟ ଏବଂ ଏକ ସମୁଦାୟରେ ସମସ୍ତ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡ଼ିକର ଉତ୍ପାଦିତ ଏକ ସରଳୀକରଣ ଫେରାନ୍ତୁ.# >>> sum_product.call([])\n# [0, 1]\n# >>> sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n","canonical_solution":"def sum_product(numbers)\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0], candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"},{"task_id":"HumanEval_9","nl":"ory_Orya","pl":"rb","prompt":"କ୍ରମରେ ।ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ସମୁଦାୟ ସଂଖ୍ୟାରୁ, ନିର୍ଦ୍ଦିଷ୍ଟ ମୁହୂର୍ତ୍ତ ପର୍ଯ୍ୟନ୍ତ ମିଳିଥିବା ସର୍ବାଧିକ ଉପାଦାନର ଏକ ସମୂହ ସୃଷ୍ଟି କରନ୍ତୁ # >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n","canonical_solution":"def rolling_max(numbers)\n  max_so_far = numbers.first\n  numbers.map do |num|\n    max_so_far = [max_so_far, num].max\n  end\nend\n\n# Example usage:\n# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"},{"task_id":"HumanEval_10","nl":"ory_Orya","pl":"rb","prompt":"- ସ୍ଟ୍ରିଙ୍ଗର ଶେଷ ଭାଗରେ ଏକ ସ୍ଟ୍ରିଙ୍ଗ୍ ପ୍ରିଫିକ୍ସ ଯୋଡନ୍ତୁ ଯାହା ପାଲିଣ୍ଡ୍ରୋମିକ୍ ସଫିକ୍ସ ପୂର୍ବରୁ ଆସେ ।- ପ୍ରଦାନ କରାଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗର ସବୁଠାରୁ ଲମ୍ବା ପୋଷ୍ଟଫିକ୍ସ ଖୋଜନ୍ତୁ ଯାହା ଏକ ପାଲିଣ୍ଡ୍ରୋମ ଅଟେ ।ଆଲଗୋରିଦମ ଧାରଣା ସରଳ: ସବୁଠାରୁ ଛୋଟ ପାଲିଣ୍ଡ୍ରୋମ ଖୋଜନ୍ତୁ ଯାହା ଏକ ସରଞ୍ଜାମରେ ଆରମ୍ଭ ହୋଇଥାଏ।# >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n","canonical_solution":"def make_palindrome(string)\n  return string if string.empty?\n\n  def is_palindrome?(s)\n    s == s.reverse\n  end\n\n  (0...string.length).reverse_each do |i|\n    if is_palindrome?(string[i..-1])\n      return string + string[0...i].reverse\n    end\n  end\n\n  string\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\", candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"},{"task_id":"HumanEval_11","nl":"ory_Orya","pl":"rb","prompt":"ଏହି ଇନପୁଟଗୁଡ଼ିକ ଉପରେ ବାଇନାରୀ XOR କରନ୍ତୁ ଏବଂ ଫଳାଫଳକୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଭାବରେ ଫେରାନ୍ତୁ.ଇନପୁଟ୍ ହେଉଛି ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗ୍ a ଏବଂ b ଯାହା କେବଳ 1s ଏବଂ 0s ରେ ଗଠିତ ।# >>> string_xor.call(\"010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n","canonical_solution":"def string_xor(a, b)\n  result = \"\"\n  a.length.times do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"},{"task_id":"HumanEval_12","nl":"ory_Orya","pl":"rb","prompt":"ସମାନ ଲମ୍ବର ଶୃଙ୍ଖଳାଗୁଡିକ. ଯଦି ନିବେଶ ମାଲିକାନା ଖାଲି ଥାଏ ତେବେ ଶୂନ୍ୟକୁ ଫେରାଇଥାଏ.ସରଳୀକରଣର ସରଳୀକରଣରୁ, ଦୀର୍ଘତମକୁ ଫେରାଇଥାଏ. ଏକାଧିକ  କ୍ଷେତ୍ରରେ ପ୍ରଥମକୁ ଫେରାଇଥାଏ.# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n","canonical_solution":"def longest(strings)\n  return nil if strings.empty?\n  strings.max_by(&:length)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n    assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n  end\nend\n"},{"task_id":"HumanEval_13","nl":"ory_Orya","pl":"rb","prompt":"ଦୁଇଟି ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା a ଓ b ର ସର୍ବ ବୃହତ ସାଧାରଣ ବିଭାଜକକୁ ଫେରାଇଥାଏ # >>> greatest_common_divisor.call(3, 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a, b)\n","canonical_solution":"def greatest_common_divisor(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3, 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49, 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"},{"task_id":"HumanEval_14","nl":"ory_Orya","pl":"rb","prompt":"ପ୍ରବେଶ ସଂକେତର ସର୍ବୋଚ୍ଚରୁ ସର୍ବୋଚ୍ଚ ପର୍ଯ୍ୟନ୍ତ ସମସ୍ତ ଉପସର୍ଗର ଏକ ସରଳୀକରଣ ଫେରାଇଥାଏ # >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n","canonical_solution":"def all_prefixes(string)\n  (1..string.length).map { |i| string[0, i] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"], candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"WWW\"))\n  end\nend\n"},{"task_id":"HumanEval_15","nl":"ory_Orya","pl":"rb","prompt":"0 ରୁ n ସମେତ ଅନ୍ତରୀଣ ସଂଖ୍ୟା ବିଶିଷ୍ଟ ଏକ ଷ୍ଟ୍ରିଙ୍ଗକୁ ଫେରାଇଥାଏ।# >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n# \"0 1 2 3 4 5\"\ndef string_sequence(n)\n","canonical_solution":"def string_sequence(n)\n  (0..n).to_a.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_16","nl":"ory_Orya","pl":"rb","prompt":"ଗୋଟିଏ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଗଲା, କେତେ ଅଲଗା ଅକ୍ଷର (କେସକୁ ନେଇ) ଅଛି ତାହା ଖୋଜନ୍ତୁ # >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n","canonical_solution":"def count_distinct_characters(string)\n  string.downcase.chars.uniq.count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5, candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"},{"task_id":"HumanEval_17","nl":"ory_Orya","pl":"rb","prompt":"'କକହ' - କ୍ୱାର୍ଟର ନୋଟ୍, ଗୋଟିଏ ବିଟ୍ ପର୍ଯ୍ୟନ୍ତ ରହିଥାଏ 'ଓ' କହିଲେ ଅଧା ନୋଟ୍, ଦୁଇଟା ବିଟ୍ ଯାଏଁ ।'ଓ' - ପୁରା ନୋଟ୍, ଚାରିଟି ବିଟ୍ ପର୍ଯ୍ୟନ୍ତ ରହିଥାଏ ଏଠାରେ ଏକ କିମ୍ବଦନ୍ତୀ ରହିଛି:ଶେଷ ନୁହେଁ ।ଆପଣଙ୍କର କାମ ହେଉଛି ଏହି ଷ୍ଟ୍ରିଙ୍ଗକୁ ବିଶ୍ଳେଷଣ କରିବା ଏବଂ ପ୍ରତ୍ୟେକ କେତେ ବିଟ୍ କରେ ତାହା ସହିତ ସମାନ ସଂଖ୍ୟକ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ଧାଡି ଫେରାଇବା ଏହି ଫଳନକୁ ଇନପୁଟ୍ ହେଉଛି ଏକ ସ୍ୱତନ୍ତ୍ର ASCII ଫର୍ମାଟରେ ମ୍ୟୁଜିକାଲ୍ ନୋଟ୍ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ।# >>> parse_music.call(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n","canonical_solution":"def parse_music(music_string)\n  # Split the input string into individual notes.\n  notes = music_string.split\n\n  # Map each note to its corresponding number of beats.\n  notes.map do |note|\n    case note\n    when 'o'\n      4\n    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1, 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"},{"task_id":"HumanEval_18","nl":"ory_Orya","pl":"rb","prompt":"ମୂଳ ଷ୍ଟ୍ରିଙ୍ଗରେ କେତେଥର ଦିଆଯାଇଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗ୍ ମିଳିପାରିବ ତାହା ଖୋଜ _ ଆଲଟପଲ୍ଲଟ କେସ୍ ଗୁଡିକୁ ଗଣନା କର _# >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring)\n","canonical_solution":"def how_many_times(string, substring)\n  return 0 if substring.empty?\n  count = 0\n  i = 0\n  while i <= string.length - substring.length\n    if string[i, substring.length] == substring\n      count += 1\n    end\n    i += 1\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\", \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4, candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"john doe\", \"john\"))\n  end\nend\n"},{"task_id":"HumanEval_19","nl":"ory_Orya","pl":"rb","prompt":"ଛୋଟରୁ ବଡ଼ ପର୍ଯ୍ୟନ୍ତ ସର୍ଟ ହୋଇଥିବା ସଂଖ୍ୟା ସହିତ ଶୃଙ୍ଖଳାକୁ ଫେରାଇଥାଏ ବୈଧ ବିକଳ୍ପଗୁଡ଼ିକ ହେଉଛି 'ଶୂନ', 'ଏକ', 'ଦୁଇ', 'ତିନି', 'ଚାରି', 'ପାଞ୍ଚ', 'ଛଅ', 'ସାତ', 'ଆଠ' ଏବଂ 'ନଅ'।ଇନପୁଟ୍ ହେଉଛି 'ଶୂନ'ରୁ 'ନଅ' ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ସ୍ପେସ୍-ସୀମିତ ଷ୍ଟ୍ରିଙ୍ଗ୍ ।# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef sort_numbers(numbers)\n","canonical_solution":"def sort_numbers(numbers)\n  numeral_map = {\n    'zero' => 0,\n    'one' => 1,\n    'two' => 2,\n    'three' => 3,\n    'four' => 4,\n    'five' => 5,\n    'six' => 6,\n    'seven' => 7,\n    'eight' => 8,\n    'nine' => 9\n  }\n\n  number_words = numbers.split\n  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }\n  sorted_numbers.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six five four three two one zero\"))\n  end\nend\n"},{"task_id":"HumanEval_20","nl":"ory_Orya","pl":"rb","prompt":"ଅନ୍ୟକୁ କ୍ରମ ଅନୁସାରେ ଫେରାଇ ଦିଅନ୍ତୁ (ଅଧିକ ସଂଖ୍ୟା, କମ୍ ସଂଖ୍ୟା) ।ଯୋଗାଣ କରାଯାଇଥିବା ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ଆରେ (ଅତିକମରେ ଦୁଇଟି ଲମ୍ବ) ରୁ ପ୍ରତ୍ୟେକକୁ ନିକଟତମ ଥିବା ଦୁଇଟିକୁ ବାଛନ୍ତୁ ଏବଂ ଫେରାନ୍ତୁ # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n","canonical_solution":"def find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs\n\n  (1...(sorted_numbers.length - 1)).each do |i|\n    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs\n    if current_difference < min_difference\n      min_difference = current_difference\n      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    end\n  end\n\n  closest_pair\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n"},{"task_id":"HumanEval_21","nl":"ory_Orya","pl":"rb","prompt":"ତେଣୁ ଛୋଟ ସଂଖ୍ୟାଟି 0 ହେବ ଏବଂ ବଡ ସଂଖ୍ୟାଟି 1 ହେବ ।ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ସରଳୀକୃତ ଧାରା (ଅତିକମରେ ଦୁଇଟି ଉପାଦାନର), ସେହି ସରଳୀକୃତ ଧାରାକୁ ଏକ ସରଳ ପରିବର୍ତ୍ତନ ପ୍ରୟୋଗ କରନ୍ତୁ, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n","canonical_solution":"def rescale_to_unit(numbers)\n  min = numbers.min\n  max = numbers.max\n  range = max - min\n  return numbers.map { |num| (num - min) \/ range.to_f }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\nend\n"},{"task_id":"HumanEval_22","nl":"ory_Orya","pl":"rb","prompt":"କେବଳ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡିକ ପାଇଁ କୌଣସି rbthon ମୂଲ୍ୟର ଦିଆଯାଇଥିବା ମାପଦଣ୍ଡକୁ ଫିଲ୍ଟର୍ କରନ୍ତୁ # >>> filter_integers.call([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\ndef filter_integers(values)\n","canonical_solution":"def filter_integers(values)\n  values.select { |value| value.is_a?(Integer) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n    assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\nend\n"},{"task_id":"HumanEval_23","nl":"ory_Orya","pl":"rb","prompt":"ଦିଆଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗର ରିଟର୍ଣ୍ଣ ଲମ୍ବ # >>> strlen.call(\"\")\n# 0\n# >>> strlen.call(\"abc\")\n# 3\ndef strlen(string)\n","canonical_solution":"strlen = lambda do |string|\n  string.length\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"asdasnakj\"))\n  end\nend\n"},{"task_id":"HumanEval_24","nl":"ory_Orya","pl":"rb","prompt":"କୌଣସି ଏକ n ସଂଖ୍ୟା ପାଇଁ, n ଠାରୁ ଛୋଟ, ସବୁଠାରୁ ବଡ ସଂଖ୍ୟା ଖୋଜନ୍ତୁ ଯାହା n କୁ ସମାନ ଭାବରେ ଭାଗ କରେ # >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n","canonical_solution":"def largest_divisor(n)\n  (n - 1).downto(1) do |i|\n    return i if n % i == 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n  end\nend\n"},{"task_id":"HumanEval_25","nl":"ory_Orya","pl":"rb","prompt":"ଇନପୁଟ୍ ସଂଖ୍ୟା ସବୁ ଗୁଣକର ଗୁଣନ ସହିତ ସମାନ ହେବା ଉଚିତ ପ୍ରତ୍ୟେକ ଗୁଣକକୁ କେତେଥର ବିଭାଜନରେ ଦେଖାଯାଏ ତାହା ସହିତ ସମାନ ଭାବରେ ଆରେ କରାଯିବ _ଛୋଟରୁ ବଡ଼ ପର୍ଯ୍ୟନ୍ତ ନିର୍ଦ୍ଦିଷ୍ଟ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଅଶେଷ ଗୁଣକମାନଙ୍କର ଏକ ସରଳୀକରଣ ଫେରାଇଥାଏ ।# >>> factorize.call(8)\n# [2, 2, 2]\n# >>> factorize.call(25)\n# [5, 5]\n# >>> factorize.call(70)\n# [2, 5, 7]\ndef factorize(n)\n","canonical_solution":"def factorize(n)\n  factors = []\n  divisor = 2\n  while n > 1\n    while n % divisor == 0\n      factors << divisor\n      n \/= divisor\n    end\n    divisor += 1\n  end\n  factors\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_factorize\n    candidate = method(:factorize)\n    assert_equal([2], candidate.call(2))\n    assert_equal([2, 2], candidate.call(4))\n    assert_equal([2, 2, 2], candidate.call(8))\n    assert_equal([3, 19], candidate.call(57))\n    assert_equal([3, 3, 19, 19], candidate.call(3249))\n    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))\n    assert_equal([3, 19, 19, 19], candidate.call(20577))\n    assert_equal([2, 3, 3], candidate.call(18))\n  end\nend\n"},{"task_id":"HumanEval_26","nl":"ory_Orya","pl":"rb","prompt":"ଉପାଦାନଗୁଡ଼ିକର କ୍ରମାଙ୍କକୁ ଇନପୁଟରେ ଥିବା କ୍ରମାଙ୍କ ସହିତ ସମାନ ରଖନ୍ତୁ ।ଏକ ସମୁଦାୟ ସଂଖ୍ୟାର ଏକ ସରଳୀକୃତ ଧାରାରୁ, ସମସ୍ତ ଉପାଦାନଗୁଡ଼ିକୁ କାଢ଼ି ଦିଅନ୍ତୁ ଯାହା ଥରେରୁ ଅଧିକ ଥର ଘଟେ ।# >>> remove_duplicates.call([1, 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n","canonical_solution":"def remove_duplicates(numbers)\n  numbers.select { |num| numbers.count(num) == 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"},{"task_id":"HumanEval_27","nl":"ory_Orya","pl":"rb","prompt":"କୌଣସି ଏକ ଧାଡ଼ି ପାଇଁ, ଛୋଟ ଅକ୍ଷରକୁ ବଡ଼ ଅକ୍ଷର ଓ ବଡ଼ ଅକ୍ଷରକୁ ଛୋଟ ଅକ୍ଷର ଭାବରେ ବଦଳାନ୍ତୁ.# >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n","canonical_solution":"def flip_case(string)\n  string.swapcase\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights have violent ends\"))\n  end\nend\n"},{"task_id":"HumanEval_28","nl":"ory_Orya","pl":"rb","prompt":"ଗୋଟିଏ ଧାଡ଼ିରେ ଶୃଙ୍ଖଳାର ଏକତ୍ରିତ ଧାଡ଼ି # >>> concatenate.call([])\n# \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n","canonical_solution":"def concatenate(strings)\n  strings.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"},{"task_id":"HumanEval_29","nl":"ory_Orya","pl":"rb","prompt":"କେବଳ ସେହିଗୁଡ଼ିକ ପାଇଁ ଏକ ଇନପୁଟ୍ ଆରେ ଫିଲ୍ଟର୍ କରନ୍ତୁ ଯାହା ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ଉପସର୍ଗ ସହିତ ଆରମ୍ଭ ହୋଇଥାଏ.# >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings, prefix)\n","canonical_solution":"def filter_by_prefix(strings, prefix)\n  strings.select { |string| string.start_with?(prefix) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\nend\n"},{"task_id":"HumanEval_30","nl":"ory_Orya","pl":"rb","prompt":"କେବଳ ଧନାତ୍ମକ ସଂଖ୍ୟାଗୁଡ଼ିକୁ ମାପଦଣ୍ଡରେ ଫେରାଇଥାଏ.# >>> get_positive.call([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n","canonical_solution":"get_positive = lambda do |l|\n  l.select { |num| num > 0 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1, -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_31","nl":"ory_Orya","pl":"rb","prompt":"ଯଦି କୌଣସି ସଂଖ୍ୟା ଅଶୂନ୍ୟ ହୋଇଥାଏ ତେବେ ଏହା ସତ୍ୟ ଫେରାଇଥାଏ, ଅନ୍ୟଥା ଏହା ମିଥ୍ୟା ହୋଇଥାଏ ।# >>> is_prime.call(6)\n# false\n# >>> is_prime.call(101)\n# true\n# >>> is_prime.call(11)\n# true\n# >>> is_prime.call(13441)\n# true\n# >>> is_prime.call(61)\n# true\n# >>> is_prime.call(4)\n# false\n# >>> is_prime.call(1)\n# false\ndef is_prime(n)\n","canonical_solution":"is_prime = lambda do |n|\n  return false if n <= 1\n  return true if n == 2\n  return false if n.even?\n\n  max_divisor = Math.sqrt(n).to_i\n  (3..max_divisor).step(2).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_prime\n    candidate = method(:is_prime)\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(101))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(13441))\n    assert_equal(true, candidate.call(61))\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(1))\n    assert_equal(true, candidate.call(5))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(17))\n    assert_equal(false, candidate.call(85))\n    assert_equal(false, candidate.call(77))\n    assert_equal(false, candidate.call(255379))\n  end\nend\n"},{"task_id":"HumanEval_33","nl":"ory_Orya","pl":"rb","prompt":"କିନ୍ତୁ ଏହା ସର୍ଟ କରାଯାଇଛି ।l' ହେଉଛି l ସହିତ ସମାନ, ଯେଉଁ ସୂଚକାଙ୍କଗୁଡ଼ିକ ତିନି ଭାଗରେ ବିଭକ୍ତ ହୋଇନଥାଏ, କିନ୍ତୁ ଏହାର ମୂଲ୍ୟଗୁଡ଼ିକ ସେହି ସୂଚକାଙ୍କଗୁଡ଼ିକରେ ସମାନ ହୋଇଥାଏ, ଯାହା ତିନି ଭାଗରେ ବିଭକ୍ତ ହୋଇଥାଏ ।ଏହି ଫଳନ ଏକ ସରଳୀକୃତ l କୁ ନେଇଥାଏ ଏବଂ ଏକ ସରଳୀକୃତ l' କୁ ଫେରାଇଥାଏ ଯେପରିକି # >>> sort_third.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n","canonical_solution":"def sort_third(l)\n  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort\n  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"},{"task_id":"HumanEval_34","nl":"ory_Orya","pl":"rb","prompt":"ଗୋଟିଏ ଧାଡ଼ିରେ ସଜାଡ଼ାଯାଇଥିବା ଅନନ୍ୟ ଉପାଦାନଗୁଡ଼ିକୁ ଫେରାଇଥାଏ# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n","canonical_solution":"def unique(l)\n  l.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_35","nl":"ory_Orya","pl":"rb","prompt":"ଆରେରେ ସର୍ବାଧିକ ଉପାଦାନକୁ ଫେରାଇଥାଏ. # >>> max_element.call([1, 2, 3])\n# 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n","canonical_solution":"def max_element(l)\n  l.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2, 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))\n  end\nend\n"},{"task_id":"HumanEval_36","nl":"ory_Orya","pl":"rb","prompt":"11 କିମ୍ବା 13 ଦ୍ୱାରା ବିଭାଜନ ହେଉଥିବା n ରୁ କମ୍ ସଂଖ୍ୟାରେ 7 ସଂଖ୍ୟା କେତେ ଥର ଦେଖାଯାଏ ତାହା ଫେରାଇଥାଏ ।# >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n# 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n","canonical_solution":"def fizz_buzz(n)\n  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 || i % 13 == 0\n      count += i.to_s.count('7')\n    end\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n    assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n    assert_equal(8026, candidate.call(100000))\n  end\nend\n"},{"task_id":"HumanEval_37","nl":"ory_Orya","pl":"rb","prompt":"କିନ୍ତୁ ସର୍ଟ କରାଯାଇଛି ।l' ଅଙ୍କରେ l ସହିତ ସମାନ, କିନ୍ତୁ ସମାନ ଅଙ୍କରେ l ସମାନ ।ଏହି ଫଳନ ଏକ ସରଳୀକୃତ l କୁ ନେଇଥାଏ ଏବଂ ଏକ ସରଳୀକୃତ l' କୁ ଫେରାଇଥାଏ ଯେପରିକି # >>> sort_even.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n","canonical_solution":"def sort_even(l)\n  even_indices = l.each_index.select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  \n  even_index = 0\n  l.each_with_index.map do |value, index|\n    if index.even?\n      even_values[even_index].tap { even_index += 1 }\n    else\n      value\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\nend\n"},{"task_id":"HumanEval_39","nl":"ory_Orya","pl":"rb","prompt":"prime_fib n-th ସଂଖ୍ୟାକୁ ଫେରାଇଥାଏ ଯାହାକି ଏକ ଫାଇବୋନ୍ୟାଚି ସଂଖ୍ୟା ଅଟେ ଏବଂ ଏହା ମଧ୍ୟ ଅଶୂର ଅଟେ ।# >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n# 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n","canonical_solution":"def prime_fib(n)\n  require 'prime'\n  \n  fibs = Enumerator.new do |y|\n    a, b = 0, 1\n    loop do\n      a, b = b, a + b\n      y << b\n    end\n  end\n  \n  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }\n  prime_fibs.first(n).last\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n    assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n    assert_equal(433494437, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_40","nl":"ory_Orya","pl":"rb","prompt":"ସମୂହ ଶୂନ୍ୟ, ଅନ୍ୟଥା ମିଥ୍ୟା ।ଏହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଆରେରେ ତିନୋଟି ଭିନ୍ନ ଉପାଦାନ ଅଛି ଯାହା triples_sum_to_zero ଏକ ଇଣ୍ଟେଜର ଆରେକୁ ଇନପୁଟ ଭାବରେ ଗ୍ରହଣ କରିଥାଏ ।# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n# >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n","canonical_solution":"def triples_sum_to_zero(l)\n  n = l.length\n  (0...n-2).each do |i|\n    ((i+1)...n-1).each do |j|\n      ((j+1)...n).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false, candidate.call([100, 3, 5, -100]))\n  end\nend\n"},{"task_id":"HumanEval_41","nl":"ory_Orya","pl":"rb","prompt":"ଏହି ଫଙ୍କସନ ସେହି ଧକ୍କାର ସଂଖ୍ୟାକୁ ଆଉଟପୁଟ କରିଥାଏ ।ସେମାନଙ୍କ ଗତିପଥରେ ଏପରି ଭାବେ ଗତି କରୁଛି ଯେପରି ସେମାନେ ପରସ୍ପର ସହ ଧକ୍କା ହୋଇନାହାନ୍ତି ।କିନ୍ତୁ ଏହି କାରଗୁଡିକ ଅକଳନୀୟ ଦୃଢ଼ ଓ ଶକ୍ତିଶାଳୀ, ତେଣୁ ସେମାନେ ଆଗକୁ ବଢ଼ି ଚାଲିଥାନ୍ତି ।ଯେତେବେଳେ ବାମରୁ ଡାହାଣକୁ ଯାଉଥିବା ଏକ କାର ବାମରୁ ଡାହାଣକୁ ଯାଉଥିବା ଏକ କାରକୁ ଧକ୍କା ଦେଇଥାଏ ।ପରସ୍ପରକୁ. ସବୁ ଗାଡି ସମାନ ବେଗରେ ଗତି କରୁଛି. ଦୁଇଟି ଗାଡି ଧକ୍କା ହେବା କଥା କୁହାଯାଉଛି.ଦୁଇଟି ଯାକ ଗାଡ଼ିର ଆରମ୍ଭ ବହୁତ ଦୂରରେ ଥିଲା ।nଟି କାର ବାମରୁ ଡାହାଣକୁ ଯାଉଛନ୍ତି; ଏକା ସମୟରେ, nଟି କାରର ଭିନ୍ନ ସେଟ୍ ଏକ ସଡ଼କ କଳ୍ପନା କରନ୍ତୁ ଯାହା ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସିଧା ଅସୀମ ଦୀର୍ଘ ରେଖା ଅଟେ ।def car_race_collision(n)\n","canonical_solution":"def car_race_collision(n)\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_42","nl":"ory_Orya","pl":"rb","prompt":"1 ଦ୍ବାରା ବୃଦ୍ଧି କରାଯାଇଥିବା ଉପାଦାନ ସହିତ ଆରେ ଫେରାଇଥାଏ ।# >>> incr_list.call([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n","canonical_solution":"def incr_list(l)\n  l.map { |x| x + 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_43","nl":"ory_Orya","pl":"rb","prompt":"ସମୂହ ଶୂନ୍ୟ, ଅନ୍ୟଥା ମିଥ୍ୟା ।ଏହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଆରେରେ ଦୁଇଟି ଭିନ୍ନ ଉପାଦାନ ଅଛି ଯାହା pairs_sum_to_zero ଏକ ଇଣ୍ଟେଜର ଆରେକୁ ଇନପୁଟ ଭାବରେ ଗ୍ରହଣ କରିଥାଏ ।# >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1, 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n# false\ndef pairs_sum_to_zero(l)\n","canonical_solution":"def pairs_sum_to_zero(l)\n  num_set = l.to_set\n  l.each do |num|\n    return true if num != 0 && num_set.include?(-num)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"},{"task_id":"HumanEval_44","nl":"ory_Orya","pl":"rb","prompt":"ଆଧାର ସଂଖ୍ୟା ୧୦ରୁ କମ୍ ।ପରିବର୍ତ୍ତନ ପରେ ଶୃଙ୍ଖଳ ପ୍ରତିନିଧିତ୍ୱକୁ ଫେରାଇଥାଏ ।ନିବେଶ ସଂଖ୍ୟା x ର ସଂଖ୍ୟାଗତ ଆଧାରକୁ ଆଧାରରେ ପରିବର୍ତ୍ତନ କରନ୍ତୁ.# >>> change_base.call(8, 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7, 2)\n# \"111\"\ndef change_base(x, base)\n","canonical_solution":"def change_base(x, base)\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits << (x % base).to_s\n    x \/= base\n  end\n  digits.reverse.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8, 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\", candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7, 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3, 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5, 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7, 8))\n  end\nend\n"},{"task_id":"HumanEval_45","nl":"ory_Orya","pl":"rb","prompt":"ଏକ ତ୍ରିଭୁଜ ପାଇଁ ଏକ ପାର୍ଶ୍ବ ଓ ଉଚ୍ଚ ରିଟର୍ଣ୍ଣ କ୍ଷେତ୍ରର ଲମ୍ବ ଦିଆଗଲା ।# >>> triangle_area.call(5, 3)\n# 7.5\ndef triangle_area(a, h)\n","canonical_solution":"def triangle_area(a, h)\n  (a * h) \/ 2.0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(7.5, candidate.call(5, 3))\n    assert_equal(2.0, candidate.call(2, 2))\n    assert_equal(40.0, candidate.call(10, 8))\n  end\nend\n"},{"task_id":"HumanEval_46","nl":"ory_Orya","pl":"rb","prompt":"ଦୟାକରି fib4 ସଂଖ୍ଯା କ୍ରମର n-ତମ ଉପାଦାନକୁ ଦକ୍ଷତାର ସହିତ ଗଣନା କରିବା ପାଇଁ ଏକ ଫଳନ ଲେଖନ୍ତୁ. ପୁନଃପୌନିକତା ବ୍ୟବହାର କରନ୍ତୁ ନାହିଁ.ଫିବରୋମାଇନ୍ (ଏନ) -> ଫିବରୋମାଇନ୍ (ଏନ -1) + ଫିବରୋମାଇନ୍ (ଏନ -2) + ଫିବରୋମାଇନ୍ (ଏନ -3) + ଫିବରୋମାଇନ୍ (ଏନ -4) ।ଫିବ୍ର 4 ({3) -> 0 ଫିବ୍ର 4 ({2) -> 2 fib4 ((1) -> 0 fib4 ((0) -> 0 Fib4 ସଂଖ୍ଯା କ୍ରମ ହେଉଛି Fibbonacci କ୍ରମ ପରି ଏକ କ୍ରମ ଯାହାକି ନିମ୍ନଲିଖିତ ପରିଭାଷିତ:# >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>> fib4.call(7)\n# 14\ndef fib4(n)\n","canonical_solution":"def fib4(n)\n  return 0 if n == 0 || n == 1 || n == 3\n  return 2 if n == 2\n\n  fib4_seq = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n  end\n  fib4_seq[n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28, candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_47","nl":"ory_Orya","pl":"rb","prompt":"ମାପଦଣ୍ଡରେ ଥିବା ଉପାଦାନଗୁଡ଼ିକର ମଧ୍ୟମାଂଶକୁ ଫେରାଇଥାଏ l. # >>> median.call([3, 1, 2, 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n","canonical_solution":"def median(l)\n  sorted = l.sort\n  len = sorted.length\n  if len.odd?\n    sorted[len \/ 2]\n  else\n    (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2.0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5, candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"},{"task_id":"HumanEval_48","nl":"ory_Orya","pl":"rb","prompt":"ଦିଆଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗ୍ ଏକ ପାଲିଣ୍ଡ୍ରୋମ୍ କି ନୁହେଁ ଯାଞ୍ଚ କରେ # >>> is_palindrome.call(\"\")\n# true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\")\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n","canonical_solution":"is_palindrome = lambda do |text|\n  text == text.reverse\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true, candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"},{"task_id":"HumanEval_49","nl":"ory_Orya","pl":"rb","prompt":"2^n ମଡୁଲୋ p କୁ ଫେରାଇଦିଅନ୍ତୁ (ସଂଖ୍ୟାନ ବିଷୟରେ ସଚେତନ ରୁହନ୍ତୁ) ।# >>> modp.call(3, 5)\n# 3\n# >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3, 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n","canonical_solution":"def modp(n, p)\n  return 1 if p == 1\n  2.pow(n, p)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"},{"task_id":"HumanEval_51","nl":"ory_Orya","pl":"rb","prompt":"remove_vowels ହେଉଛି ଏକ ଫଙ୍କସନ୍ ଯାହାକି ସ୍ୱରଗୁଡ଼ିକ ବିନା string କୁ ନେଇଥାଏ ଏବଂ ଫେରାଇଥାଏ ।# >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n","canonical_solution":"def remove_vowels(text)\n  text.delete('aeiouAEIOU')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\", candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\", candidate.call(\"ybcd\"))\n  end\nend\n"},{"task_id":"HumanEval_52","nl":"ory_Orya","pl":"rb","prompt":"ଯଦି ସରଳରେଖା l ର ସମସ୍ତ ସଂଖ୍ୟା ସୀମା t ତଳେ ଥାଏ ତେବେ true କୁ ଫେରାଇଥାଏ ।# >>> below_threshold.call([1, 2, 4, 10], 100)\n# true\n# >>> below_threshold.call([1, 20, 4, 10], 5)\n# false\ndef below_threshold(l, t)\n","canonical_solution":"def below_threshold(l, t)\n  l.all? { |num| num < t }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_threshold\n    candidate = method(:below_threshold)\n    assert_equal(true, candidate.call([1, 2, 4, 10], 100))\n    assert_equal(false, candidate.call([1, 20, 4, 10], 5))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 21))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 22))\n    assert_equal(true, candidate.call([1, 8, 4, 10], 11))\n    assert_equal(false, candidate.call([1, 8, 4, 10], 10))\n  end\nend\n"},{"task_id":"HumanEval_53","nl":"ory_Orya","pl":"rb","prompt":"ଦୁଇଟି ସଂଖ୍ୟା x ଓ y କୁ ମିଶାନ୍ତୁ # >>> add.call(2, 3)\n# 5\n# >>> add.call(5, 7)\n# 12\ndef add(x, y)\n","canonical_solution":"add = ->(x, y) { x + y }","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(1, candidate.call(0, 1))\n    assert_equal(1, candidate.call(1, 0))\n    assert_equal(5, candidate.call(2, 3))\n    assert_equal(12, candidate.call(5, 7))\n    assert_equal(12, candidate.call(7, 5))\n  end\nend\n"},{"task_id":"HumanEval_54","nl":"ory_Orya","pl":"rb","prompt":"ଦୁଇଟି ଶବ୍ଦର ଅକ୍ଷର ସମାନ କି ନାହିଁ ଦେଖନ୍ତୁ ।# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n# >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# false\ndef same_chars(s0, s1)\n","canonical_solution":"def same_chars(s0, s1)\n  s0.chars.uniq.all? { |char| s1.include?(char) } &&\n  s1.chars.uniq.all? { |char| s0.include?(char) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false, candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"))\n  end\nend\n"},{"task_id":"HumanEval_55","nl":"ory_Orya","pl":"rb","prompt":"n-ତମ ଫିବୋନାସୀ ସଂଖ୍ୟାକୁ ଫେରାଇଦେବେ. # >>> fib.call(10)\n# 55\n# >>> fib.call(1)\n# 1\n# >>> fib.call(8)\n# 21\ndef fib(n)\n","canonical_solution":"def fib(n)\n  return n if n <= 1\n  fib(n - 1) + fib(n - 2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89, candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_56","nl":"ory_Orya","pl":"rb","prompt":"ଯଦି ପ୍ରତ୍ୟେକ ଖୋଲିବା ବ୍ରାକେଟରେ ସମାନ ବନ୍ଦ ବ୍ରାକେଟ ଥାଏ ତେବେ true ଫେରାଇଦେବେbrackets ହେଉଛି \"<\" ଏବଂ \">\" ର ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍.# >>> correct_bracketing.call(\"<\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"<<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.chars.each do |char|\n    if char == '<'\n      balance += 1\n    elsif char == '>'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"<>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true, candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false, candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n    assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\">\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>>><>\"))\n  end\nend\n"},{"task_id":"HumanEval_57","nl":"ory_Orya","pl":"rb","prompt":"true କୁ ଫେରାଇଦିଏ, ଯଦି ଆରେ ଉପାଦାନଗୁଡ଼ିକ ଏକକ ଭାବରେ ବୃଦ୍ଧି କିମ୍ବା ହ୍ରାସ ହୁଏ ।# >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n# false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n","canonical_solution":"def monotonic(l)\n  increasing = true\n  decreasing = true\n\n  (0...l.length - 1).each do |i|\n    if l[i] < l[i + 1]\n      decreasing = false\n    elsif l[i] > l[i + 1]\n      increasing = false\n    end\n  end\n\n  increasing || decreasing\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2, 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false, candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1, 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\nend\n"},{"task_id":"HumanEval_58","nl":"ory_Orya","pl":"rb","prompt":"ଦୁଇଟି ସରଳୀକରଣ ପାଇଁ ସର୍ଟ ହୋଇଥିବା ଅନନ୍ୟ ସାଧାରଣ ଉପାଦାନଗୁଡ଼ିକୁ ଫେରାଇଥାଏ.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n","canonical_solution":"def common(l1, l2)\n  (l1 & l2).uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"},{"task_id":"HumanEval_59","nl":"ory_Orya","pl":"rb","prompt":"n ର ସବୁଠାରୁ ବଡ ଅକ୍ଷର ଫ୍ୟାକ୍ଟର ଫେରାଇ ଦିଅନ୍ତୁ _ n > 1 କୁ ଧରି ନିଅନ୍ତୁ ଏବଂ ଅକ୍ଷର ନୁହେଁ _# >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n# 2\ndef largest_prime_factor(n)\n","canonical_solution":"def largest_prime_factor(n)\n  factor = 2\n  while factor * factor <= n\n    if n % factor == 0\n      n \/= factor\n    else\n      factor += 1\n    end\n  end\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n  end\nend\n"},{"task_id":"HumanEval_60","nl":"ory_Orya","pl":"rb","prompt":"sum_to_n ହେଉଛି ଏକ ଫଙ୍କସନ୍ ଯାହା 1 ରୁ n ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ୟାଗୁଡିକୁ ଯୋଗ କରିଥାଏ ।# >>> sum_to_n.call(30)\n# 465\n# >>> sum_to_n.call(100)\n# 5050\n# >>> sum_to_n.call(5)\n# 15\n# >>> sum_to_n.call(10)\n# 55\n# >>> sum_to_n.call(1)\n# 1\ndef sum_to_n(n)\n","canonical_solution":"def sum_to_n(n)\n  (1..n).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_61","nl":"ory_Orya","pl":"rb","prompt":"ଯଦି ପ୍ରତ୍ୟେକ ଖୋଲିବା ବ୍ରାକେଟରେ ସମାନ ବନ୍ଦ ବ୍ରାକେଟ ଥାଏ ତେବେ true ଫେରାଇଦେବେbrackets ହେଉଛି \"(\" ଏବଂ \"\") ର ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍.# >>> correct_bracketing.call(\"(\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"(()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.each_char do |char|\n    if char == '('\n      balance += 1\n    elsif char == ')'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true, candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false, candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n    assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\")\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false, candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"()()(()())()))()\"))\n  end\nend\n"},{"task_id":"HumanEval_62","nl":"ory_Orya","pl":"rb","prompt":"ଏହି ବହୁପଦଟିର ସମକକ୍ଷକୁ ସେହି ସମାନ ରୂପରେ ଫେରାଇଦିଅନ୍ତୁ.xs[0] + xs[1] * x + xs[2] * x^2 + ....  ଏହା ଏକ ବର୍ଗର ଏକକ ଅଟେ ।xs ଏକ ବହୁପଦ ର ଗୁଣକ କୁ ଦର୍ଶାଏ.# >>> derivative.call([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative.call([1, 2, 3])\n# [2, 6]\ndef derivative(xs)\n","canonical_solution":"def derivative(xs)\n  return [] if xs.length < 2\n  xs.each_with_index.map { |coef, index| coef * index }[1..-1]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2, 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_63","nl":"ory_Orya","pl":"rb","prompt":"ଦୟାକରି ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଦ୍ବାରା ଫିବିବ ସଂଖ୍ଯା କ୍ରମର n-ତମ ଉପାଦାନକୁ ସଠିକ ଭାବରେ ଗଣନା କରିହେବ ।ଫିବିବ (n) == ଫିବିବ (n-1) + ଫିବିବ (n-2) + ଫିବିବ (n-3) ।ଫିବିବ (୨) == ୧ ଫିବିବ (୧) == ୦ ଫିବିବ (୦) == ୦ ଫିବୋନାଚି କ୍ରମରେ ସମାନ କ୍ରମରେ ଫିବୋନାଚି କ୍ରମରେ ସମାନ କ୍ରମରେ ନିମ୍ନଲିଖିତ ପରିଭାଷା ଅଛି:# >>> fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef fibfib(n)\n","canonical_solution":"def fibfib(n)\n  return 0 if n == 0 || n == 1\n  return 1 if n == 2\n\n  a, b, c = 0, 0, 1\n  (3..n).each do\n    a, b, c = b, c, a + b + c\n  end\n  c\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0, candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24, candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274, candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"},{"task_id":"HumanEval_64","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ସ୍ୱର, କିନ୍ତୁ କେବଳ ଯେତେବେଳେ ଏହା ଦିଆଯାଇଥିବା ଶବ୍ଦର ଶେଷରେ ଥାଏ ।ଏହି କ୍ଷେତ୍ରରେ ସ୍ୱରଗୁଡ଼ିକ ହେଉଛି 'a', 'e', 'i', 'o', 'u' । ଏଠାରେ 'y' ମଧ୍ୟ ଏକ ଗୋଟିଏ ଶବ୍ଦକୁ ଇନପୁଟ୍ ଭାବରେ ବ୍ୟବହାର କରି, ସେହି ବାକ୍ୟଖଣ୍ଡରେ ଥିବା ସ୍ୱରଗୁଡ଼ିକର ସଂଖ୍ୟାକୁ ଫେରାଇଥାଏ.ଏକ ଫଙ୍କସନ ଲେଖନ୍ତୁ, ଯେଉଁଥିରେ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ଅଛି, ଯାହା # >>> vowels_count.call(\"abcde\")\n# 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n","canonical_solution":"def vowels_count(s)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  \n  s.chars.each_with_index do |char, index|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif char.downcase == 'y' && index == s.length - 1\n      count += 1\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"ACEDY\"))\n  end\nend\n"},{"task_id":"HumanEval_65","nl":"ory_Orya","pl":"rb","prompt":"ଯଦି shift > ଅଙ୍କ ସଂଖ୍ୟା, ତେବେ ଅଙ୍କ ସଂଖ୍ୟାକୁ ଫେରାଇଦେବେ ।ଏବଂ ଫଳାଫଳକୁ ଗୋଟିଏ ଧାଡ଼ି ଭାବରେ ଫେରାଇଥାଏ.ସର୍କୁଲାର ଭାବରେ x ର ଅଙ୍କକୁ ଘୁଞ୍ଚାଇ, ଅଙ୍କକୁ ଘୁଞ୍ଚାଇ # >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12, 2)\n# \"12\"\ndef circular_shift(x, shift)\n","canonical_solution":"def circular_shift(x, shift)\n  digits = x.to_s.chars\n  num_digits = digits.length\n\n  if shift > num_digits\n    return digits.reverse.join\n  else\n    shift = shift % num_digits\n    shifted_digits = digits.rotate(-shift)\n    return shifted_digits.join\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100, 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\", candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"11\", candidate.call(11, 101))\n  end\nend\n"},{"task_id":"HumanEval_66","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏଏସସିଆଇଆଇ କୋଡ ।ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗକୁ ଇନପୁଟ ଭାବରେ ଗ୍ରହଣ କରେ ଏବଂ କେବଳ ଉପର ଅକ୍ଷରର ସମୁଦାୟ ଫେରାଇଥାଏ' କାର୍ଯ୍ୟ # >>> digitSum.call(\"\")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n# 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n# 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n","canonical_solution":"def digitSum(s)\n  s.chars.select { |char| char =~ \/[A-Z]\/ }.map(&:ord).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131, candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327, candidate.call(\"You arE Very Smart\"))\n  end\nend\n"},{"task_id":"HumanEval_67","nl":"ory_Orya","pl":"rb","prompt":"ଏକ୍ସାମ୍ବଲ ପାଇଁ: ବାସ୍କେଟରେ ଥିବା ଆମ୍ବ ଫଳର ସଂଖ୍ୟାକୁ ଫେରାଇବ ।ଆଳୁ ଓ ଆପଲ୍ ଏବଂ ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଯାହା ଫଳଗୁଡ଼ିକର ସମୁଦାୟ ସଂଖ୍ୟାକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ _ଆପଲ୍, କମଳା, ଏବଂ ଆମ୍ବ ଫଳ.ଫଳ ବାସ୍କେଟରେ ବଣ୍ଟନ କରା ଯାଇଥିବା ଫଳ ଏହି ବାସ୍କେଟରେ ଅଛି ।ଏହି କାମରେ, ଆପଣଙ୍କୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଯିବ ଯାହା ଆପଲ୍ ଓ କମଳା ସଂଖ୍ୟାକୁ ପ୍ରତିନିଧିତ୍ୱ କରିବ # >>> fruit_distribution.call(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution.call(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution.call(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution.call(\"100 apples and 1 oranges\", 120)\n# 19\ndef fruit_distribution(s, n)\n","canonical_solution":"def fruit_distribution(s, n)\n  numbers = s.scan(\/\\d+\/).map(&:to_i)\n  apples = numbers[0]\n  oranges = numbers[1]\n  total_fruits = n\n  mangos = total_fruits - (apples + oranges)\n  mangos\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fruit_distribution\n    candidate = method(:fruit_distribution)\n    assert_equal(8, candidate.call(\"5 apples and 6 oranges\", 19))\n    assert_equal(10, candidate.call(\"5 apples and 6 oranges\", 21))\n    assert_equal(2, candidate.call(\"0 apples and 1 oranges\", 3))\n    assert_equal(2, candidate.call(\"1 apples and 0 oranges\", 3))\n    assert_equal(95, candidate.call(\"2 apples and 3 oranges\", 100))\n    assert_equal(0, candidate.call(\"2 apples and 3 oranges\", 5))\n    assert_equal(19, candidate.call(\"1 apples and 100 oranges\", 120))\n  end\nend\n"},{"task_id":"HumanEval_68","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ 1: ଯଦି କୌଣସି ଯୁଗ୍ମ ମୂଲ୍ୟ ନଥାଏ କିମ୍ବା ଦିଆଯାଇଥିବା ସରଳୀକୃତ ଶୂନ୍ୟ ହୋଇଥାଏ, ତେବେ ଫେରାଇଦେବେ [].ଚୋରି ହୋଇଥିବା ନୋଡକୁ ଏକ ଆରେରେ ଫେରାଇଦିଆଯିବ, [ smalest_value, ଏହାର ସୂଚକାଙ୍କ ], ଯଦି ଏକାଧିକ ନୋଡ ସମାନ ସର୍ବନିମ୍ନ ଯୁଗ୍ମ ମୂଲ୍ୟ ସହିତ ମିଳିଥାଏ ତେବେ ନୋଡକୁ ଫେରାଇଥାଏ ଯାହାର ସର୍ବନିମ୍ନ ସୂଚକାଙ୍କ ଅଛି ।ଚୋରା ନୋଡଟି ସବୁଠାରୁ ଛୋଟ ଯୁଗ୍ମ ମୂଲ୍ୟର ନୋଡ ହେବା ଉଚିତ ।ଆପଣଙ୍କର କାମ ହେଉଛି ଗୋଟିଏ ନୋଡକୁ କାଢ଼ି ତାକୁ ଫେରାଇ ଦେବା ।\"ଏକ ବୃକ୍ଷର ଶାଖାକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ସରଳୀକରଣ ଦିଆଯାଇଥାଏ ଯାହାର ନନ୍-ନଗେଟିଭ୍ ଇଣ୍ଟେଜର ନୋଡ ଅଛି # >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>> pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n","canonical_solution":"def pluck(arr)\n  smallest_even = nil\n  smallest_index = nil\n  \n  arr.each_with_index do |value, index|\n    if value.even?\n      if smallest_even.nil? || value < smallest_even\n        smallest_even = value\n        smallest_index = index\n      end\n    end\n  end\n\n  smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"},{"task_id":"HumanEval_69","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଯଦି ଏପରି କୌଣସି ମୂଲ୍ୟ ନଥାଏ, ତେବେ -1 ଫେରାଇଦେବେ.ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ବାରମ୍ବାରତା ହେଉଛି ଏହା ଧାଡ଼ିରେ ଦେଖାଯାଉଥିବା ସମୟର ସଂଖ୍ୟା ।ଶୂନ, ଏବଂ ଏହାର ଫ୍ରିକ୍ୱେନ୍ସି ନିଜେ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ମୂଲ୍ୟ ଠାରୁ ଅଧିକ କିମ୍ବା ସମାନ ।ଆପଣଙ୍କୁ ଧନାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଏକ ଅଣ-ଖାଲି ଧାରା ଦିଆ ଯାଇଛି. ସବୁଠାରୁ ବଡ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଫେରାଇ ଦିଅନ୍ତୁ ଯାହା  ଠାରୁ ବଡ# >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n","canonical_solution":"def search(lst)\n  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys\n  valid_numbers.empty? ? -1 : valid_numbers.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1, candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1, candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"},{"task_id":"HumanEval_70","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ତାପରେ ବାକି ସଂଖ୍ୟାର ସର୍ବାଧିକ, ତାପରେ ସର୍ବନିମ୍ନ, ଏବଂ ଏହିପରି ଭାବରେ _ଅଜବ ସର୍ଟ କରିବା, ଯେତେବେଳେ ଆପଣ ସର୍ବନିମ୍ନ ମୂଲ୍ୟ ସହିତ ଆରମ୍ଭ କରନ୍ତି, ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ସରଳୀକୃତ ଧାରାକୁ ଦେଇ, ଅଜବ କ୍ରମରେ ସରଳୀକୃତ ଧାରାକୁ ଫେରାଇବ.# >>> strange_sort_list.call([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n","canonical_solution":"def strange_sort_list(lst)\n  result = []\n  lst.sort!\n  until lst.empty?\n    result << lst.shift\n    result << lst.pop unless lst.empty?\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\nend\n"},{"task_id":"HumanEval_71","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ତୃତୀୟ ପକ୍ଷ ଅପେକ୍ଷା ଅଧିକ ।ତିନୋଟି ପାର୍ଶ୍ବ ଏକ ବୈଧ ତ୍ରିଭୁଜ ସୃଷ୍ଟି କରେ ଯେତେବେଳେ କୌଣସି ଦୁଇଟି ପାର୍ଶ୍ବ ର ସମୁଦାୟ ଅଧିକ ହୋଇଥାଏ ଅନ୍ୟଥା ଫେରସ୍ତ -1 ତ୍ରିଭୁଜକୁ ଦୁଇ ଦଶମିକ ବିନ୍ଦୁରେ ଗୋଲ କରନ୍ତୁ ଯଦି ତିନୋଟି ପାର୍ଶ୍ବ ଏକ ବୈଧ ତ୍ରିଭୁଜ ଗଠନ କରନ୍ତି ।ଏକ ତ୍ରିଭୁଜର ତିନି ପାର୍ଶ୍ବ ର ଲମ୍ବ ଦିଆଗଲା.  ର କ୍ଷେତ୍ରଫଳ ଫେରେଇ ନିଅନ୍ତୁ.# >>> triangle_area.call(3, 4, 5)\n# 6.0\n# >>> triangle_area.call(1, 2, 10)\n# -1\ndef triangle_area(a, b, c)\n","canonical_solution":"def triangle_area(a, b, c)\n  # Check for valid triangle\n  if a + b > c && a + c > b && b + c > a\n    # Calculate the semi-perimeter\n    s = (a + b + c) \/ 2.0\n    # Calculate the area using Heron's formula\n    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Round to 2 decimal points\n    return area.round(2)\n  else\n    return -1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(6.0, candidate.call(3, 4, 5))\n    assert_equal(-1, candidate.call(1, 2, 10))\n    assert_equal(8.18, candidate.call(4, 8, 5))\n    assert_equal(1.73, candidate.call(2, 2, 2))\n    assert_equal(-1, candidate.call(1, 2, 3))\n    assert_equal(16.25, candidate.call(10, 5, 7))\n    assert_equal(-1, candidate.call(2, 6, 3))\n    assert_equal(0.43, candidate.call(1, 1, 1))\n    assert_equal(-1, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_72","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ବସ୍ତୁ q ଉଡିଯିବ ଯଦି ଏହା ସନ୍ତୁଳିତ (ଏହା ଏକ ପାଲିଣ୍ଡ୍ରୋମିକ ଆରେ) ଏବଂ ଏହାର ଉପାଦାନଗୁଡ଼ିକର ସମୁଦାୟ ସର୍ବାଧିକ ସମ୍ଭାବ୍ୟ ଓଜନ w ଠାରୁ କମ୍ କିମ୍ବା ସମାନ ହୋଇଥାଏ ।ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ବସ୍ତୁ q ଉଡିଯିବ, ଏବଂ ଅନ୍ୟଥା ମିଥ୍ୟା _# >>> will_it_fly.call([1, 2], 5)\n# false\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly.call([3, 2, 3], 1)\n# false\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly.call([3, 2, 3], 9)\n# true\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly.call([3], 5)\n# true\n# # 3 is less than the maximum possible weight, and it's balanced.\ndef will_it_fly(q, w)\n","canonical_solution":"def will_it_fly(q, w)\n  is_palindrome = q == q.reverse\n  total_weight = q.sum\n  is_balanced_and_under_weight = is_palindrome && total_weight <= w\n  is_balanced_and_under_weight\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_will_it_fly\n    candidate = method(:will_it_fly)\n    assert_equal(true, candidate.call([3, 2, 3], 9))\n    assert_equal(false, candidate.call([1, 2], 5))\n    assert_equal(true, candidate.call([3], 5))\n    assert_equal(false, candidate.call([3, 2, 3], 1))\n    assert_equal(false, candidate.call([1, 2, 3], 6))\n    assert_equal(true, candidate.call([5], 5))\n  end\nend\n"},{"task_id":"HumanEval_73","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଗୋଟିଏ ପରିବର୍ତ୍ତନରେ ଆପଣ ଗୋଟିଏ ଉପାଦାନକୁ ଅନ୍ୟ କୌଣସି ଉପାଦାନରେ ବଦଳାଇ ପାରିବେ ।ଏକ ପାଲିଣ୍ଡ୍ରୋମିକ ଆରେ ହେଉଛି ଏକ ଆରେ ଯାହା ଏକ ସରଳୀକୃତ ସମୁଦାୟ ସଂଖ୍ୟା arr ଦିଆଗଲା, ସର୍ବନିମ୍ନ ଉପାଦାନ ସଂଖ୍ୟା ଖୋଜନ୍ତୁ ଯାହା # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change.call([1, 2, 3, 2, 1])\n# 0\ndef smallest_change(arr)\n","canonical_solution":"def smallest_change(arr)\n  changes = 0\n  left = 0\n  right = arr.length - 1\n\n  while left < right\n    if arr[left] != arr[right]\n      changes += 1\n    end\n    left += 1\n    right -= 1\n  end\n\n  changes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_smallest_change\n    candidate = method(:smallest_change)\n    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))\n    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))\n    assert_equal(1, candidate.call([1, 4, 2]))\n    assert_equal(1, candidate.call([1, 4, 4, 2]))\n    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))\n    assert_equal(0, candidate.call([3, 1, 1, 3]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(1, candidate.call([0, 1]))\n  end\nend\n"},{"task_id":"HumanEval_74","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଯଦି ଦୁଇଟି ସରଳରେଖାରେ ସମାନ ସଂଖ୍ୟକ ଅକ୍ଷର ଥାଏ, ତେବେ ପ୍ରଥମ ସରଳୀକୁ ଫେରାଇଦିଅନ୍ତୁ.ଅନ୍ୟ ଆରେରେ ଥିବା ସମସ୍ତ ଷ୍ଟ୍ରିଙ୍ଗରେ ଥିବା ଚାରର ମୋଟ ସଂଖ୍ୟା ଅନ୍ୟ ଆରେରେ ଥିବା ଚାର ଠାରୁ କମ୍ ।ଗୋଟିଏ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଦୁଇଟି ଧାଡିର ଧାଡି ଗ୍ରହଣ କରେ ଏବଂ ଧାଡିକୁ ଫେରାଇଥାଏ ଯାହାର # >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n","canonical_solution":"def total_match(lst1, lst2)\n  total_chars1 = lst1.map(&:length).sum\n  total_chars2 = lst2.map(&:length).sum\n\n  if total_chars1 < total_chars2\n    lst1\n  elsif total_chars2 < total_chars1\n    lst2\n  else\n    lst1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\", \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n    assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"},{"task_id":"HumanEval_75","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଜାଣିଛୁ ଯେ (a) 100 ରୁ କମ ଅଟେ ।ଏବଂ ଅନ୍ୟଥା ମିଥ୍ୟା ।ଗୋଟିଏ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ସତ୍ୟ ଫେରାଇବ ଯଦି ଦିଆଯାଇଥିବା ସଂଖ୍ୟାଟି 3ଟି ଅଶୂର ସଂଖ୍ୟା ଗୁଡ଼ିକର ଗୁଣନ # >>> is_multiply_prime.call(30)\n# true\n# 30 = 2 * 3 * 5\ndef is_multiply_prime(a)\n","canonical_solution":"require 'prime'\n\ndef is_multiply_prime(a)\n  return false if a >= 100\n  prime_factors = a.prime_division\n  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_multiply_prime\n    candidate = method(:is_multiply_prime)\n    assert_equal(false, candidate.call(5))\n    assert_equal(true, candidate.call(30))\n    assert_equal(true, candidate.call(8))\n    assert_equal(false, candidate.call(10))\n    assert_equal(true, candidate.call(125))\n    assert_equal(true, candidate.call(105))\n    assert_equal(false, candidate.call(126))\n    assert_equal(false, candidate.call(729))\n    assert_equal(false, candidate.call(891))\n    assert_equal(true, candidate.call(1001))\n  end\nend\n"},{"task_id":"HumanEval_76","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: x ହେଉଛି n ର ଏକ ସରଳ ଶକ୍ତି ଯଦି n**int=x ଅନ୍ୟ କ୍ଷେତ୍ରରେ n ର ଶକ୍ତି ଏବଂ ମିଥ୍ୟା ।ଆପଣଙ୍କର କାମ ହେଉଛି ଏକ ଫଳନ ଲେଖିବା ଯାହା ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଏକ ସଂଖ୍ୟା x ଏକ ସରଳ # >>> is_simple_power.call(1, 4)\n# true\n# >>> is_simple_power.call(2, 2)\n# true\n# >>> is_simple_power.call(8, 2)\n# true\n# >>> is_simple_power.call(3, 2)\n# false\n# >>> is_simple_power.call(3, 1)\n# false\n# >>> is_simple_power.call(5, 3)\n# false\ndef is_simple_power(x, n)\n","canonical_solution":"def is_simple_power(x, n)\n  return false if x <= 0 || n <= 1\n  return true if x == 1\n\n  power = n\n  while power <= x\n    return true if power == x\n    power *= n\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_simple_power\n    candidate = method(:is_simple_power)\n    assert_equal(true, candidate.call(16, 2))\n    assert_equal(false, candidate.call(143214, 16))\n    assert_equal(true, candidate.call(4, 2))\n    assert_equal(true, candidate.call(9, 3))\n    assert_equal(true, candidate.call(16, 4))\n    assert_equal(false, candidate.call(24, 2))\n    assert_equal(false, candidate.call(128, 4))\n    assert_equal(false, candidate.call(12, 6))\n    assert_equal(true, candidate.call(1, 1))\n    assert_equal(true, candidate.call(1, 12))\n  end\nend\n"},{"task_id":"HumanEval_77","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଟିପ୍ପଣୀ: ଆପଣ ଭାବୁଥିବେ ଇନପୁଟ୍ ସବୁବେଳେ ବୈଧ ।ଯଦି ଏହି ଇନଗେଜର କୌଣସି ସଂଖ୍ୟାର ଘନକ ଅଟେ ।ଗୋଟିଏ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା a କୁ ନେଇଥାଏ ଏବଂ true କୁ ଫେରାଇଥାଏ ।# >>> iscube.call(1)\n# true\n# >>> iscube.call(2)\n# false\n# >>> iscube.call(-1)\n# true\n# >>> iscube.call(64)\n# true\n# >>> iscube.call(0)\n# true\n# >>> iscube.call(180)\n# false\ndef iscube(a)\n","canonical_solution":"def iscube(a)\n  cube_root = a.abs**(1.0\/3)\n  cube_root.round**3 == a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_iscube\n    candidate = method(:iscube)\n    assert_equal(true, candidate.call(1))\n    assert_equal(false, candidate.call(2))\n    assert_equal(true, candidate.call(-1))\n    assert_equal(true, candidate.call(64))\n    assert_equal(false, candidate.call(180))\n    assert_equal(true, candidate.call(1000))\n    assert_equal(true, candidate.call(0))\n    assert_equal(false, candidate.call(1729))\n  end\nend\n"},{"task_id":"HumanEval_78","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏବଂ A,B,C,D,E,F ଚିହ୍ନ ସବୁ ବେଳେ ବଡ଼ ଅକ୍ଷରରେ ଲେଖା ହୋଇଥାଏ ।ଟିପ୍ପଣୀ: ଆପଣ ଅନୁମାନ କରିପାରନ୍ତି ଯେ ନିବେଶ ସର୍ବଦା ସଠିକ କିମ୍ବା ଖାଲି ବାକ୍ୟଖଣ୍ଡ, ବି (= ଦଶମିକ 11), ଡି (= ଦଶମିକ 13) ।ତେଣୁ ଆପଣଙ୍କୁ ନିମ୍ନଲିଖିତ ଅଙ୍କ ମଧ୍ୟରୁ ଏକ ସଂଖ୍ୟା ନିର୍ଣ୍ଣୟ କରିବାକୁ ହେବ: 2, 3, 5, 7, ମୂଳ ସଂଖ୍ୟା ଗୁଡିକ ହେଉଛି 2, 3, 5, 7, 11, 13, 17,...ହେକ୍ସାଡେସିମାଲ ଅଙ୍କ ହେଉଛି 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. 1 ରୁ ବଡ, ଯାହାକି ଦୁଇଟି ଛୋଟ ପ୍ରାକୃତିକ ସଂଖ୍ଯାର ଗୁଣନ ନୁହେଁ) ।ଅକ୍ଷର ଗୁଡିକ ଅକ୍ଷର ସଂଖ୍ୟା (ଅକ୍ଷର ସଂଖ୍ୟା, କିମ୍ବା ଏକ ଅକ୍ଷର, ଏକ ପ୍ରାକୃତିକ ସଂଖ୍ୟା ଏକ ହେକ୍ସାଡେସିମାଲ୍ ସଂଖ୍ୟାକୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ଭାବରେ ଗଣନା କରେ ଏବଂ ହେକ୍ସାଡେସିମାଲ୍ ସଂଖ୍ୟା ଗଣନା କରେ ଆପଣଙ୍କୁ ଏକ ଫଳନ ଲେଖିବା ପାଇଁ କୁହାଯାଇଥିଲା ଯାହା ଗ୍ରହଣ କରିଥାଏ ।# >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n# >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n","canonical_solution":"def hex_key(num)\n  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n  num.chars.count { |digit| prime_hex_digits.include?(digit) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6, candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"},{"task_id":"HumanEval_79","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏହି ଅତିରିକ୍ତ ଅକ୍ଷରଗୁଡ଼ିକ ଫର୍ମାଟ ପାଇଁ ସାହାଯ୍ୟକାରୀ ।ଷ୍ଟ୍ରିଙ୍ଗର ଆରମ୍ଭ ଏବଂ ଶେଷରେ ଅତିରିକ୍ତ କିଛି ଅକ୍ଷର 'db' ରହିବ ।ସଂଖ୍ଯା. ଶୃଙ୍ଖଳାରେ ଥିବା ପ୍ରତ୍ୟେକ ଅକ୍ଷର '0' କିମ୍ବା '1' ହେବ.ବାଇନାରୀ ଫର୍ମାଟ. ଫଳନଟି ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇବ, ଯେଉଁଥିରେ ପ୍ରତ୍ୟେକ ଅକ୍ଷର ଏକ ବାଇନାରୀ କୁ ପ୍ରତିନିଧିତ୍ୱ କରିବ.ଆପଣଙ୍କୁ ଏକ ଦଶମିକ ସଂଖ୍ୟା ଦିଆଯିବ ଏବଂ ଆପଣଙ୍କର କାମ ହେଉଛି ଏହାକୁ  କୁ ପରିବର୍ତ୍ତନ କରିବା# >>> decimal_to_binary.call(15)\n# \"db1111db\"\n# >>> decimal_to_binary.call(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal)\n","canonical_solution":"def decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"db\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_decimal_to_binary\n    candidate = method(:decimal_to_binary)\n    assert_equal(\"db0db\", candidate.call(0))\n    assert_equal(\"db100000db\", candidate.call(32))\n    assert_equal(\"db1100111db\", candidate.call(103))\n    assert_equal(\"db1111db\", candidate.call(15))\n  end\nend\n"},{"task_id":"HumanEval_80","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଗୋଟିଏ ଧାଡ଼ି haprb ହୋଇଥାଏ ଯଦି ଏହାର ଲମ୍ବ ଅତିକମରେ 3 ହୋଇଥାଏ ଏବଂ ପ୍ରତ୍ୟେକ 3ଟି କ୍ରମିକ ଅକ୍ଷର ଅଲଗା ହୋଇଥାଏ ଆପଣଙ୍କର କାମ ହେଉଛି ଯାଞ୍ଚ କରିବା କି ଏହି ଷ୍ଟ୍ରିଙ୍ଗଟି ଠିକ ଅଛି କି ନାହିଁ ।ଆପଣଙ୍କୁ ଗୋଟିଏ string s ଦିଆଗଲା.# >>> is_happy.call(\"a\")\n# false\n# >>> is_happy.call(\"aa\")\n# false\n# >>> is_happy.call(\"abcd\")\n# true\n# >>> is_happy.call(\"aabb\")\n# false\n# >>> is_happy.call(\"adb\")\n# true\n# >>> is_happy.call(\"xyy\")\n# false\ndef is_happy(s)\n","canonical_solution":"def is_happy(s)\n  return false if s.length < 3\n  \n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  \n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true, candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n    assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"iopaxioi\"))\n  end\nend\n"},{"task_id":"HumanEval_81","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:୦.୦ ଇ > ୦.୦ ଡି- > ୦.୭ ଡି > ୧.୦ ଡି+ > ୧.୩ ସି- > ୧.୭ ଡିଗ୍ରୀ ସେଲସିୟସ> ୨.୦ ସି+ > 2.3 ବି- > ୨.୭ ବି > 3.0 ବି+ > 3.3 A- > ୩.୭ ଏ 4.0 ଏ+ GPA. ଅକ୍ଷର ଗ୍ରେଡ୍.ଏକ ଫଳନ ଯାହା ନିମ୍ନଲିଖିତ ସାରଣୀ ବ୍ୟବହାର କରି ଅକ୍ଷର ମାନର ଏକ ସରଳୀକୃତ ଶୃଙ୍ଖଳାକୁ ବାହାର କରିପାରିବ: ସେ ଆପଣଙ୍କୁ କିଛି ଛାତ୍ରଙ୍କ ପାଇଁ ଗ୍ରେଡ ରେଟ୍ ଦେଇଛନ୍ତି ଏବଂ ଆପଣଙ୍କୁ ଲେଖିବାକୁ ପଡିବ ।କେବଳ ଗୋଟିଏ ସମସ୍ୟା ହେଉଛି, ସେ ଗ୍ରେଡିଂ ପାଇଁ ବ୍ୟବହାର କରୁଥିବା କୋଡ୍ ହଜିଯାଇଛି ।ଶିକ୍ଷୟତ୍ରୀମାନେ ନିଜସ୍ୱ ଗ୍ରେଡିଂ ଆଲଗୋରିଦମ ପ୍ରସ୍ତୁତ କରୁଛନ୍ତି ।ସେମିଷ୍ଟରର ଶେଷ ସପ୍ତାହରେ ଶିକ୍ଷକମାନଙ୍କୁ ମାର୍କ ଦେବାକୁ ହେବ ।# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\ndef numerical_letter_grade(grades)\n","canonical_solution":"def numerical_letter_grade(grades)\n  grades.map do |gpa|\n    case \n    when gpa == 4.0\n      \"A+\"\n    when gpa > 3.7\n      \"A\"\n    when gpa > 3.3\n      \"A-\"\n    when gpa > 3.0\n      \"B+\"\n    when gpa > 2.7\n      \"B\"\n    when gpa > 2.3\n      \"B-\"\n    when gpa > 2.0\n      \"C+\"\n    when gpa > 1.7\n      \"C\"\n    when gpa > 1.3\n      \"C-\"\n    when gpa > 1.0\n      \"D+\"\n    when gpa > 0.7\n      \"D\"\n    when gpa > 0.0\n      \"D-\"\n    else\n      \"E\"\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_numerical_letter_grade\n    candidate = method(:numerical_letter_grade)\n    assert_equal([\"A+\", \"B\", \"C-\", \"C\", \"A-\"], candidate.call([4.0, 3, 1.7, 2, 3.5]))\n    assert_equal([\"D+\"], candidate.call([1.2]))\n    assert_equal([\"D-\"], candidate.call([0.5]))\n    assert_equal([\"E\"], candidate.call([0.0]))\n    assert_equal([\"D\", \"D-\", \"C-\", \"B\", \"B+\"], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))\n    assert_equal([\"E\", \"D-\"], candidate.call([0.0, 0.7]))\n  end\nend\n"},{"task_id":"HumanEval_82","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ length ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା କିମ୍ବା ଅନ୍ୟଥା ମିଥ୍ୟା ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ନେଇଥାଏ ଏବଂ ସତ୍ୟ ଫେରାଇଥାଏ ଯଦି ଷ୍ଟ୍ରିଙ୍ଗ # >>> prime_length.call(\"Hello\")\n# true\n# >>> prime_length.call(\"abcdcba\")\n# true\n# >>> prime_length.call(\"kittens\")\n# true\n# >>> prime_length.call(\"orange\")\n# false\ndef prime_length(string)\n","canonical_solution":"def prime_length(string)\n  length = string.length\n  return false if length < 2\n\n  (2..Math.sqrt(length)).each do |i|\n    return false if length % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_length\n    candidate = method(:prime_length)\n    assert_equal(true, candidate.call(\"Hello\"))\n    assert_equal(true, candidate.call(\"abcdcba\"))\n    assert_equal(true, candidate.call(\"kittens\"))\n    assert_equal(false, candidate.call(\"orange\"))\n    assert_equal(true, candidate.call(\"wow\"))\n    assert_equal(true, candidate.call(\"world\"))\n    assert_equal(true, candidate.call(\"MadaM\"))\n    assert_equal(true, candidate.call(\"Wow\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"HI\"))\n    assert_equal(true, candidate.call(\"go\"))\n    assert_equal(false, candidate.call(\"gogo\"))\n    assert_equal(false, candidate.call(\"aaaaaaaaaaaaaaa\"))\n    assert_equal(true, candidate.call(\"Madam\"))\n    assert_equal(false, candidate.call(\"M\"))\n    assert_equal(false, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_83","nl":"ory_Orya","pl":"rb","prompt":"ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଯାହା 1 ରୁ ଆରମ୍ଭ କିମ୍ବା ଶେଷ ହୁଏ ।ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, n-ଅଙ୍କ ବିଶିଷ୍ଟ ସଂଖ୍ୟାର ଗଣନା ଫେରାଇଦେବେ def starts_one_ends(n)\n","canonical_solution":"def starts_one_ends(n)\n  return 0 if n <= 0\n\n  # Count numbers starting with 1\n  start_with_1 = 9 ** (n - 1)\n\n  # Count numbers ending with 1\n  end_with_1 = 9 ** (n - 1)\n\n  # Adjust for double counting the number that both starts and ends with 1\n  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1\n  \n  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n  end\nend\n"},{"task_id":"HumanEval_84","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା N ଦିଆଗଲା, ଏହାର ଅଙ୍କଗୁଡ଼ିକର ସମୁଦାୟ ସମୁଦାୟକୁ ବାଇନାରୀରେ ଫେରାଇଦିଅନ୍ତୁ. # >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n# >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n","canonical_solution":"def solve(n)\n  sum_of_digits = n.to_s.chars.map(&:to_i).sum\n  sum_of_digits.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n  end\nend\n"},{"task_id":"HumanEval_85","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏକ ଅସରନ୍ତି ସମୁଦାୟ ସଂଖ୍ୟାକୁ ଦେଇ lst. ଅଙ୍କକୋଷରେ ଥିବା ଯୁଗ୍ମ ଉପାଦାନଗୁଡ଼ିକୁ ଯୋଗ କରନ୍ତୁ.. # >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n","canonical_solution":"def add(lst)\n  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0, candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n  end\nend\n"},{"task_id":"HumanEval_86","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଟିପ୍ପଣୀ: ଆପଣ ବାକ୍ୟର କ୍ରମରେ ଏବଂ ବାକ୍ୟରେ ଖାଲି ସ୍ଥାନକୁ ରଖିବା ଉଚିତ ।ଏସସିଆଇ ମୂଲ୍ୟ ଆଧାରରେ କ୍ରମାନୁସାରେ ।ଏକ ନୂତନ ଶବ୍ଦ ସହିତ ବଦଳାଯିବ ଯେଉଁଠାରେ ସମସ୍ତ ଅକ୍ଷର \"ଷ୍ଟ୍ରିଙ୍ଗର ଅର୍ଡରଡ ଭର୍ସନ, ହେଉଛି ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଯେଉଁଠାରେ ସମସ୍ତ ଶବ୍ଦ (ସ୍ପେସ ଦ୍ୱାରା ପୃଥକ) ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ନେଇଥାଏ ଏବଂ ଏହାର ଏକ ଅର୍ଡର ହୋଇଥିବା ସଂସ୍କରଣ ଫେରାଇଥାଏ।# >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n","canonical_solution":"def anti_shuffle(s)\n  s.split(\/(\\s+)\/).map { |word| word.chars.sort.join }.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot. How are you?\"))\n  end\nend\n"},{"task_id":"HumanEval_87","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏହା ସହିତ, ଧାଡ଼ିର କୋଅର୍ଡିନେଟଗୁଡ଼ିକୁ କ୍ରମବର୍ଦ୍ଧିଷ୍ଣୁ କ୍ରମରେ ସ୍ତମ୍ଭ ଅନୁସାରେ ସର୍ଟ କରନ୍ତୁ.ପ୍ରଥମେ କୋର୍ଡିନେଟକୁ କ୍ରମାନୁସାରେ ଧାଡ଼ି ଅନୁସାରେ ସର୍ଟ କରନ୍ତୁ ।ପ୍ରତ୍ୟେକ ଆରେ ହେଉଛି ଏକ କୋର୍ଡିନେଟ - (ଶୃଙ୍ଖଳା, ସ୍ତମ୍ଭ), 0 ରୁ ଆରମ୍ଭ ।ଏବଂ arrays ର arrays, [(x1, y1), (x2, y2) ...] କୁ ଫେରାଇଥାଏ ଯେପରିକି lst, ଏବଂ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା x ଦିଆଗଲା, ଆରେରେ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା x ଖୋଜନ୍ତୁ, ପ୍ରତ୍ୟେକ ଧାଡ଼ିରେ ଭିନ୍ନ ଭିନ୍ନ ସଂଖ୍ୟକ ସ୍ତମ୍ଭ ରହିପାରେ ।ଯାହା ମାଟ୍ରିକ୍ସ ସହିତ ସମାନ, କିନ୍ତୁ ମାଟ୍ରିକ୍ସ ପରି ନୁହେଁ,ଆପଣଙ୍କୁ ଏକ 2D ତଥ୍ୟ ଦିଆଯାଉଛି, ଏକ ନେଷ୍ଟେଡ୍ ଆରେ ଭାବରେ, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([], 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst, x)\n","canonical_solution":"def get_row(lst, x)\n  result = []\n\n  lst.each_with_index do |row, i|\n    row.each_with_index do |value, j|\n      result << [i, j] if value == x\n    end\n  end\n\n  result.sort_by { |coord| [coord[0], -coord[1]] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"},{"task_id":"HumanEval_88","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:* ଦିଆଯାଇଥିବା ଆରେକୁ ପରିବର୍ତ୍ତନ କରନ୍ତୁ ନାହିଁ. ନୋଟ: ଅଥବା ଏହାକୁ କ୍ରମାନୁସାରେ ସର୍ଟ କରନ୍ତୁ ଯଦି ସମୁଦାୟ (ପ୍ରଥମ ଇଣ୍ଡେକ୍ସ ମୂଲ୍ୟ, ଶେଷ ଇଣ୍ଡେକ୍ସ ମୂଲ୍ୟ) ଯୁଗ୍ମ ହୋଇଥାଏ ।ଆପଣ ଦିଆଯାଇଥିବା ଆରେକୁ ଉର୍ଦ୍ଧ୍ୱଗାମୀ କ୍ରମରେ ସର୍ଟ କରିବେ ଯଦି ସମୁଦାୟ (ପ୍ରଥମ ଇଣ୍ଡେକ୍ସ ମୂଲ୍ୟ, ଶେଷ ଇଣ୍ଡେକ୍ସ ମୂଲ୍ୟ) ଅଙ୍କ ବିଶିଷ୍ଟ, ଅଣ-ନକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ସରଳୀକରଣ ଦିଆଯାଇଥାଏ, ସର୍ଟ କରିବା ପରେ ଦିଆଯାଇଥିବା ସରଳୀକରଣର ଏକ କୋର୍ବ ଫେରାଇଥାଏ, # >>> sort_array.call([])\n# []\n# >>> sort_array.call([5])\n# [5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n","canonical_solution":"def sort_array(array)\n  return array if array.empty? || array.size == 1\n\n  if (array.first + array.last).odd?\n    array.sort\n  else\n    array.sort.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"},{"task_id":"HumanEval_89","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଦୁଇଗୁଣିତ କରି ଦୁଇ ସ୍ଥାନକୁ ଘୁଞ୍ଚାଇବେ ।ଅକ୍ଷରଗୁଡ଼ିକର ଆକାର ଏପରି ଭାବରେ ଘୁଞ୍ଚାଯିବା ଉଚିତ ଯେ ଅକ୍ଷରଗୁଡ଼ିକ ଆଲଫାବେଟକୁ ଘୂରାଇ ଏକ ଏନକ୍ରିପ୍ଟ ହୋଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇଥାଏ.ଏକ ଫଳନ ଏନକ୍ରିପ୍ଟ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ବାକ୍ୟଖଣ୍ଡକୁ ଏକ ତର୍କ ଭାବରେ ଗ୍ରହଣ କରିଥାଏ ଏବଂ # >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"et\")\n# \"ix\"\ndef encrypt(s)\n","canonical_solution":"def encrypt(s)\n  s.chars.map do |char|\n    if char =~ \/[a-z]\/\n      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr\n    elsif char =~ \/[A-Z]\/\n      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr\n    else\n      char\n    end\n  end.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"e\", candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_90","nl":"ory_Orya","pl":"rb","prompt":"ଯଦି ଏପରି କୌଣସି ଉପାଦାନ ନଥାଏ ତେବେ ଶୂନକୁ ଫେରାଇଥାଏ ।ଏକ ଫଙ୍କସନ next_smallest ଲେଖନ୍ତୁ ଯାହା ଆରେର ଦ୍ବିତୀୟ କ୍ଷୁଦ୍ରତମ ଉପାଦାନକୁ ଫେରାଇଥାଏ ।ଆପଣଙ୍କୁ ଏକ ସଂଖ୍ଯା ନିର୍ଣ୍ଣଯକ ଦିଆୟାଇଛି.# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1, 1])\n# nil\ndef next_smallest(lst)\n","canonical_solution":"def next_smallest(lst)\n  unique_sorted = lst.uniq.sort\n  unique_sorted.length >= 2 ? unique_sorted[1] : nil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"},{"task_id":"HumanEval_91","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ବାକ୍ୟ ଗୁଡିକରେ '', '?' କିମ୍ବା '!' ଲଗା ଯାଇଥାଏ.ଏକ ବିରକ୍ତି ହେଉଛି ଏକ ବାକ୍ୟ ଯାହା \"ମୁଁ\" ଶବ୍ଦ ସହିତ ଆରମ୍ଭ ହୁଏ ।ଆପଣଙ୍କୁ ଏକ ଶୃଙ୍ଖଳାର ଶବ୍ଦ ଦିଆଯିବ, ଏବଂ ଆପଣଙ୍କର କାମ ହେଉଛି ସଂଖ୍ୟା ଗଣନା କରିବା # >>> is_bored.call(\"Hello world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\ndef is_bored(s)\n","canonical_solution":"def is_bored(s)\n  sentences = s.split(\/(?<=[.?!])\/)\n  sentences.count { |sentence| sentence.strip.start_with?('I') }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1, candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"))\n  end\nend\n"},{"task_id":"HumanEval_92","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଅନ୍ୟ କୌଣସି କ୍ଷେତ୍ରରେ ମିଥ୍ୟା ଫେରାଇଥାଏ ।ଯଦି ଗୋଟିଏ ସଂଖ୍ୟା ଅନ୍ୟ ଦୁଇଟି ସଂଖ୍ୟାର ସମୁଦାୟ ସହିତ ସମାନ ଏବଂ ସମସ୍ତ ସଂଖ୍ୟା ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ହୋଇଥାଏ ତେବେ ଏହା ସତ୍ୟ ହୋଇଥାଏ ।ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହା 3ଟି ସଂଖ୍ୟା ଗ୍ରହଣ କରେ.# >>> any_int.call(5, 2, 7)\n# true\n# >>> any_int.call(3, 2, 2)\n# false\n# >>> any_int.call(3, -2, 1)\n# true\n# >>> any_int.call(3.6, -2.2, 2)\n# false\ndef any_int(x, y, z)\n","canonical_solution":"def any_int(x, y, z)\n  if [x, y, z].all? { |n| n.is_a?(Integer) }\n    x == y + z || y == x + z || z == x + y\n  else\n    false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_any_int\n    candidate = method(:any_int)\n    assert_equal(true, candidate.call(2, 3, 1))\n    assert_equal(false, candidate.call(2.5, 2, 3))\n    assert_equal(false, candidate.call(1.5, 5, 3.5))\n    assert_equal(false, candidate.call(2, 6, 2))\n    assert_equal(true, candidate.call(4, 2, 2))\n    assert_equal(false, candidate.call(2.2, 2.2, 2.2))\n    assert_equal(true, candidate.call(-4, 6, 2))\n    assert_equal(true, candidate.call(2, 1, 1))\n    assert_equal(true, candidate.call(3, 4, 7))\n    assert_equal(false, candidate.call(3.0, 4, 7))\n  end\nend\n"},{"task_id":"HumanEval_93","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:କେବଳ ଅକ୍ଷର ମାନି ନିଅନ୍ତୁ ।ଇଂରାଜୀ ଅକ୍ଷର ଅକ୍ଷରରେ ସ୍ୱର ।ସେହି ଅକ୍ଷର ସହିତ ବାର୍ତ୍ତା ଯାହା 2 ଟି ସ୍ଥାନ ପୂର୍ବରୁ ଦେଖାଯାଏ _ଏହିପରି ଭାବରେ ଏହା ସମସ୍ତ ଅକ୍ଷରର କେସ୍ ବଦଳାଇଥାଏ,  ରେ ସମସ୍ତ ସ୍ୱର ବଦଳାଇଥାଏଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ସନ୍ଦେଶ ନେଇଥାଏ, ଏବଂ ଏପରି ଏକ # >>> encode.call(\"test\")\n# \"TGST\"\n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n","canonical_solution":"def encode(message)\n  vowels = 'aeiou'\n  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}\n  \n  encoded_message = message.chars.map do |char|\n    if vowels.include?(char.downcase)\n      new_char = swap_vowels[char.downcase]\n      char == char.upcase ? new_char.upcase : new_char.downcase\n    else\n      char == char.upcase ? char.downcase : char.upcase\n    end\n  end\n\n  encoded_message.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"},{"task_id":"HumanEval_94","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଆପଣଙ୍କୁ ସବୁଠାରୁ ବଡ ଅକ୍ଷର ମୂଲ୍ୟ ଖୋଜିବାକୁ ହେବ ଏବଂ ଏହାର ଅଙ୍କଗୁଡିକର ସମୁଦାୟ ଫେରାଇବାକୁ ହେବ.ଆପଣଙ୍କୁ ଏକ ସଂଖ୍ଯା ନିର୍ଣ୍ଣଯକ ଦିଆୟାଇଛି.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])\n# 7\ndef skjkasdkd(lst)\n","canonical_solution":"def skjkasdkd(lst)\n  require 'prime'\n\n  # Find the largest prime number in the array\n  largest_prime = lst.select { |num| Prime.prime?(num) }.max\n  \n  # Return 0 if no prime number is found\n  return 0 if largest_prime.nil?\n\n  # Calculate the sum of digits of the largest prime number\n  largest_prime.to_s.chars.map(&:to_i).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_skjkasdkd\n    candidate = method(:skjkasdkd)\n    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))\n    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))\n    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))\n    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))\n    assert_equal(19, candidate.call([8191]))\n    assert_equal(19, candidate.call([8191, 123456, 127, 7]))\n    assert_equal(10, candidate.call([127, 97, 8192]))\n  end\nend\n"},{"task_id":"HumanEval_95","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଫଳନଟି false ଫେରାଇବ ଯଦି ଦିଆଯାଇଥିବା ହ୍ୟାସଟି ଖାଲି ଥାଏ ।case କିମ୍ବା ସମସ୍ତ କିଗୁଡ଼ିକ ବଡ଼ ଅକ୍ଷରରେ ଥିବା ବାକ୍ୟଖଣ୍ଡ, ନଚେତ୍ false ଫେରାଇଥାଏ.ଏକ ହ୍ୟାସ ଦିଆଯାଇଥିବା, ଯଦି ସମସ୍ତ କି ଗୁଡିକ lower  ରେ ଥିବା string ହୋଇଥାଏ ତେବେ true କୁ ଫେରାଇଥାଏ# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n","canonical_solution":"def check_dict_case(dict)\n  return false if dict.empty?\n\n  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }\n  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }\n\n  lowercase_keys || uppercase_keys\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n"},{"task_id":"HumanEval_96","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଅଶୂନ୍ୟ ସଂଖ୍ୟା ଏବଂ n ରୁ ଛୋଟ ।ଗୋଟିଏ ଫଳନକୁ କାର୍ଯ୍ୟକାରୀ କରନ୍ତୁ ଯାହାକି ଏକ ନନ୍-ନଗେଟିଭ୍ ଇଣ୍ଟେଜର ନେଇଥାଏ ଏବଂ ପ୍ରଥମ n ର ଏକ ଆରେ ଫେରାଇଥାଏ # >>> count_up_to.call(5)\n# [2, 3]\n# >>> count_up_to.call(11)\n# [2, 3, 5, 7]\n# >>> count_up_to.call(0)\n# []\n# >>> count_up_to.call(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to.call(1)\n# []\n# >>> count_up_to.call(18)\n# [2, 3, 5, 7, 11, 13, 17]\ndef count_up_to(n)\n","canonical_solution":"def count_up_to(n)\n  return [] if n <= 2\n  primes = []\n  (2...n).each do |num|\n    is_prime = true\n    (2..Math.sqrt(num)).each do |i|\n      if num % i == 0\n        is_prime = false\n        break\n      end\n    end\n    primes << num if is_prime\n  end\n  primes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([], candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"},{"task_id":"HumanEval_97","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଧରନ୍ତୁ ଯେ ଇନପୁଟ୍ ସର୍ବଦା ବୈଧ ଅଟେ ।ସେମାନଙ୍କର ଏକକ ଅଙ୍କ ଗୁଡ଼ିକର ଗୁଣନ ।ଫଳନକୁ ପୂର୍ଣ୍ଣ କରନ୍ତୁ ଯାହାକି ଦୁଇଟି ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ନେଇଥାଏ ଏବଂ ଫେରାଇଥାଏ # >>> multiply.call(148, 412)\n# 16\n# >>> multiply.call(19, 28)\n# 72\n# >>> multiply.call(2020, 1851)\n# 0\n# >>> multiply.call(14, -15)\n# 20\ndef multiply(a, b)\n","canonical_solution":"def multiply(a, b)\n  a_unit_digit = a.abs % 10\n  b_unit_digit = b.abs % 10\n  a_unit_digit * b_unit_digit\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_multiply\n    candidate = method(:multiply)\n    assert_equal(16, candidate.call(148, 412))\n    assert_equal(72, candidate.call(19, 28))\n    assert_equal(0, candidate.call(2020, 1851))\n    assert_equal(20, candidate.call(14, -15))\n    assert_equal(42, candidate.call(76, 67))\n    assert_equal(49, candidate.call(17, 27))\n    assert_equal(0, candidate.call(0, 1))\n    assert_equal(0, candidate.call(0, 0))\n  end\nend\n"},{"task_id":"HumanEval_98","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଗୋଟିଏ ଧାଡ଼ି s ଦିଆଗଲା, ସମ ସୂଚକାଙ୍କରେ ଥିବା ବଡ଼ ଅକ୍ଷର ସ୍ୱରଗୁଡ଼ିକର ସଂଖ୍ୟା ଗଣନା କରନ୍ତୁ ।# >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n","canonical_solution":"def count_upper(s)\n  vowels = ['A', 'E', 'I', 'O', 'U']\n  count = 0\n\n  s.chars.each_with_index do |char, index|\n    if index.even? && vowels.include?(char)\n      count += 1\n    end\n  end\n\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"EEEE\"))\n  end\nend\n"},{"task_id":"HumanEval_99","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଦୁଇଟି ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାରୁ, ଏହାକୁ ଶୂନରୁ ଦୂର କରି ଘୋଡ଼ାଇ ଦିଅନ୍ତୁ.ଏବଂ ଏହା ନିକଟତମ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାକୁ ଫେରାଇଥାଏ. ଯଦି ସଂଖ୍ୟା ସମାନ ଦୂରତା ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ସଂଖ୍ୟାକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ମୂଲ୍ୟ (ଷ୍ଟ୍ରିଙ୍ଗ) ଗ୍ରହଣ କରିଥାଏ ।# >>> closest_integer.call(\"10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\ndef closest_integer(value)\n","canonical_solution":"def closest_integer(value)\n  number = value.to_f\n  if number > 0\n    (number + 0.5).floor\n  else\n    (number - 0.5).ceil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_100","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:i ହେଉଛି ସ୍ତରରେ ପଥର ସଂଖ୍ୟା (i+1) ।ଗୋଟିଏ ଧାଡ଼ିରେ ପ୍ରତ୍ୟେକ ସ୍ତରରେ ପଥର ସଂଖ୍ୟା ଫେରାଇଥାଏ, ଯେଉଁଠାରେ ସୂଚକାଙ୍କରେ ଉପାଦାନ - ପରବର୍ତ୍ତୀ ଯୁଗ୍ମ ସଂଖ୍ୟା ଯଦି n ଯୁଗ୍ମ ଅଟେ ।- ପରବର୍ତ୍ତୀ ଅଙ୍କ ଯଦି n ଅଙ୍କ ଅଙ୍କ ଅଟେ ।ପରବର୍ତ୍ତୀ ସ୍ତରରେ ପଥରର ସଂଖ୍ୟା ହେଉଛି: ପ୍ରଥମ ସ୍ତରରେ n ପଥର ଅଛି ।ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ଆପଣଙ୍କୁ ପଥରର n ସ୍ତରର ଏକ ଗଦା ତିଆରି କରିବାକୁ ହେବ ।# >>> make_a_pile.call(3)\n# [3, 5, 7]\ndef make_a_pile(n)\n","canonical_solution":"def make_a_pile(n)\n  result = []\n  current_stones = n\n  n.times do\n    result << current_stones\n    current_stones += 2\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9, 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"},{"task_id":"HumanEval_101","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଶବ୍ଦକୁ ବାକ୍ୟରେ ବିଭକ୍ତ କରିବା ଏବଂ ଶବ୍ଦଗୁଡ଼ିକର ଏକ ସରଳୀକରଣ ଫେରାଇବ.ଆପଣଙ୍କୁ ଏକ ଶବ୍ଦ ଶୃଙ୍ଖଳ ଦିଆଯିବ, ଯାହାକୁ କମା କିମ୍ବା ସ୍ପେସ୍ ଦ୍ୱାରା ପୃଥକ କରାଯିବ । ଆପଣଙ୍କ କାମ ହେଉଛି # >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n","canonical_solution":"def words_string(s)\n  s.split(\/[\\s,]+\/)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\", \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two, three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"ahmed     , gamal\"))\n  end\nend\n"},{"task_id":"HumanEval_102","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଯଦି ସେପରି କୌଣସି ସଂଖ୍ୟା ନାହିଁ, ତେବେ ଫଳନ -1 ଫେରାଇବ _ସବୁଠାରୁ ବଡ ଯୁଗ୍ମ ସଂଖ୍ଯା ଯାହା [x, y] ଅନ୍ତର୍ଭୁକ୍ତ ରେ ଅଛି. ଯଦି ଏହି ଫଙ୍କସନ ଦୁଇଟି ସକାରାତ୍ମକ ସଂଖ୍ୟା x ଓ y କୁ ନେଇଥାଏ ଏବଂ  କୁ ଫେରାଇଥାଏ# >>> choose_num.call(12, 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n","canonical_solution":"def choose_num(x, y)\n  return -1 if x > y\n  # Start looking from the largest number\n  max_even = y.even? ? y : y - 1\n  # Iterate downwards to find the biggest even number\n  max_even.downto(x) do |n|\n    return n if n.even?\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33, 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28, candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1, candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\nend\n"},{"task_id":"HumanEval_103","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଯଦି n, m ଠାରୁ ବଡ଼, ତେବେ -1 ଫେରାଇବ.ଉତ୍ତରକୁ ନିକଟତମ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାକୁ ଘୋଡ଼ାଇ ଏହାକୁ ବାଇନାରୀକୁ ପରିବର୍ତ୍ତନ କରନ୍ତୁ.n ରୁ m ପର୍ଯ୍ୟନ୍ତ (n ଓ m କୁ ମିଶାଇ) ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ହାରାହାରି ।ଆପଣଙ୍କୁ ଦୁଇଟି ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଏବଂ m ଦିଆ ଯାଇଛି, ଏବଂ ଆପଣଙ୍କର କାମ ହେଉଛି # >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>> rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n# >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n","canonical_solution":"def rounded_avg(n, m)\n  return -1 if n > m\n\n  sum = (n..m).reduce(:+)\n  count = m - n + 1\n  average = (sum.to_f \/ count).round\n  \"0b\" + average.to_i.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1, 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996, 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362, 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7, 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5, 5))\n  end\nend\n"},{"task_id":"HumanEval_104","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଟିପ୍ପଣୀ: ଫେରାଇଥିବା ଆରେକୁ ବୃଦ୍ଧି କ୍ରମରେ ସର୍ଟ କରାଯିବା ଉଚିତ ।ସେହି ଉପାଦାନ ଯାହା ପାଖରେ କୌଣସି ଯୁଗ୍ମ ଅଙ୍କ ନଥାଏ ।ଧନାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ଯା x ର ଏକ ସରଳୀକୃତ ସରଳୀକୃତ ସମୁଦାୟ # >>> unique_digits.call([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n","canonical_solution":"def unique_digits(x)\n  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31, 135], candidate.call([135, 103, 31]))\n  end\nend\n"},{"task_id":"HumanEval_105","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଏକ, ଦୁଇ, ତିନି, ଚାରି, ପାଞ୍ଚ, ଛଅ, ସାତ, ଆଠ, ନଅ ।ଫଳାଫଳ ଆରେକୁ ଓଲଟାଇ, ଏବଂ ତାପରେ ପ୍ରତ୍ୟେକ ଅଙ୍କକୁ ଏହାର ଅନୁରୂପ ନାମ ସହିତ  ରୁ ବଦଳାନ୍ତୁ1 ରୁ 9 ସମେତ ଥିବା ସଂଖ୍ଯାଗୁଡିକୁ ସର୍ଟ କର,# >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length.call([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n","canonical_solution":"def by_length(arr)\n  number_names = {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\"\n  }\n\n  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse\n  filtered_sorted_reversed.map { |num| number_names[num] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"], candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"], candidate.call([9, 4, 8]))\n  end\nend\n"},{"task_id":"HumanEval_106","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:i ର ଉପାଦାନ ହେଉଛି 1 ରୁ i ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ୟାର ଗୁଣନ (1 * 2 * ... * i) ।i 1 ରୁ ଆରମ୍ଭ ହୋଇଥାଏ ।କିମ୍ବା 1ରୁ i ପର୍ଯ୍ୟନ୍ତ ସଂଖ୍ୟା ସମୂହ ।ଏବଂ n ଆକାରର ଏକ ସରଳୀକୃତ ସୂଚକ ଫେରାଇଥାଏ, ଯେପରିକି ସୂଚକ i ରେ ଥିବା ଉପାଦାନର ମୂଲ୍ୟ i ର କାରକ ଅଟେ ଯଦି i ଯୁଗ୍ମ କାର୍ଯ୍ୟକାରିତା f କୁ କାର୍ଯ୍ୟକାରୀ କର ଯାହା n କୁ ଏକ ପାରାମିଟର ଭାବରେ ଗ୍ରହଣ କରେ, # >>> f.call(5)\n# [1, 2, 6, 24, 15]\ndef f(n)\n","canonical_solution":"def f(n)\n  (1..n).map do |i|\n    if i.even?\n      (1..i).inject(:*) || 1\n    else\n      (1..i).inject(:+)\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([1, 2, 6, 24, 15], candidate.call(5))\n    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))\n    assert_equal([1], candidate.call(1))\n    assert_equal([1, 2, 6], candidate.call(3))\n  end\nend\n"},{"task_id":"HumanEval_107","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ 1: ସମୁଦାୟ {1, n} ପରିସର ମଧ୍ୟରେ ଥିବା ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ପାଲିଣ୍ଡ୍ରୋମ ।ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ଏକ ସରଳୀକରଣ ଫେରାଇ ନିଅନ୍ତୁ ଯେଉଁଥିରେ ଯୁଗ୍ମ ଏବଂ ଅଙ୍କ ସଂଖ୍ୟା ଅଛି # >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\ndef even_odd_palindrome(n)\n","canonical_solution":"def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n\n  [even_count, odd_count]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_108","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ -123ର ଅଙ୍କ -1, 2 ଏବଂ 3ରେ ହସ୍ତାକ୍ଷର ରହିଛି ।ଯଦି କୌଣସି ସଂଖ୍ୟା ହେଉଛି ନକାରାତ୍ମକ, ତେବେ ତାର ପ୍ରଥମ ଅଙ୍କ ନକାରାତ୍ମକ ହେବ:ଯେଉଁ ତତ୍ତ୍ବଗୁଡ଼ିକର ଅଙ୍କ ସମୂହ 0ରୁ ଅଧିକ ହୋଇଥାଏ ।ଏକ ଫଙ୍କସନ୍ count_nums ଲେଖନ୍ତୁ ଯାହା ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଧାରା ନେଇଥାଏ ଏବଂ ଫେରାଇଥାଏ # >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n# 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n","canonical_solution":"def count_nums(arr)\n  arr.count do |num|\n    num.to_s.chars.map(&:to_i).sum > 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0, 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_109","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଟିପ୍ପଣୀ: ଦିଆଯାଇଥିବା ଆରେରେ ଅନନ୍ୟ ଉପାଦାନ ଥିବା ସୁନିଶ୍ଚିତ ।ଯଦି ଦିଆଯାଇଥିବା ସରଳୀକୃତ ଶୂନ୍ୟ ହୋଇଥାଏ ତେବେ true କୁ ଫେରାଇଥାଏ.ତାପରେ true କୁ ଫେରାଇଦିଅନ୍ତୁ ନଚେତ୍ false କୁ ଫେରାଇଦିଅନ୍ତୁ.ଉପରୋକ୍ତ କାର୍ଯ୍ୟ କରି ସର୍ଟ କରାଯାଇଥିବା ଆରେ ପାଇବା ସମ୍ଭବ ହେଲେ ମାର୍ଜିନରେ ପ୍ରାରମ୍ଭିକ ସ୍ଥିତି ଅର୍ଥାତ୍ ୦ମ ସୂଚକାଙ୍କ ।ସଠିକ ଦିଗରେ ସ୍ଥିତି. ଆରେର ଶେଷ ଉପାଦାନକୁ ସ୍ଥାନାନ୍ତରିତ କରାଯିବ ଗୋଟିଏ ଡାହାଣକୁ ଘୁଞ୍ଚିବା କାର୍ଯ୍ୟ ଅର୍ଥାତ୍ ଆରେର ସମସ୍ତ ଉପାଦାନକୁ ଗୋଟିଏ ଘୁଞ୍ଚାଇବା ।ଆପଣ ଯେତେଥର ଚାହିଁବେ ଡାହାଣକୁ ଘୁଞ୍ଚାଇ ପାରିବେ ।ନିମ୍ନଲିଖିତ କାର୍ଯ୍ୟଟିକୁ ଦିଆଯାଇଥିବା ଆରେରେ କର:  କରି ଏକ ଆରେକୁ ଅଣ-କ୍ରମବର୍ଦ୍ଧକ କ୍ରମରେ ସର୍ଟ କରିବା ସମ୍ଭବ ଅଟେ ।ଆରେରେ ଥିବା ସଂଖ୍ୟାଗୁଡ଼ିକ ଆକସ୍ମିକ ଭାବରେ ସଜାଡ଼ାଯିବ । ଆପଣଙ୍କର କାର୍ଯ୍ୟ ହେଉଛି ନିର୍ଣ୍ଣୟ କରିବା ଆମର N ସଂଖ୍ୟକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ଏକ 'arr' ଅଛି arr[1], arr[2], ..., arr[N] ।# >>> move_one_ball.call([3, 4, 5, 1, 2])\n# true\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball.call([3, 5, 4, 1, 2])\n# false\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\ndef move_one_ball(arr)\n","canonical_solution":"def move_one_ball(arr)\n  return true if arr.empty?\n\n  n = arr.size\n  count_rotation_point = 0\n  rotation_index = -1\n\n  (0...n).each do |i|\n    next_index = (i + 1) % n\n    if arr[i] > arr[next_index]\n      count_rotation_point += 1\n      rotation_index = next_index\n    end\n  end\n\n  count_rotation_point <= 1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_move_one_ball\n    candidate = method(:move_one_ball)\n    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))\n    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))\n    assert_equal(false, candidate.call([4, 3, 1, 2]))\n    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))\n    assert_equal(true, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_110","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଅନ୍ୟଥା, \"ନା\"କୁ ଫେରାଇଦେବେlst1 ର ସମସ୍ତ ଉପାଦାନ ସମ ସମ ହେବା ପାଇଁ, \"YES\" କୁ ଫେରାଇଦିଅନ୍ତୁ.ଯଦି ଏହା ସମ୍ଭବ lst1 ଏବଂ lst2 ମଧ୍ୟରେ ଉପାଦାନଗୁଡିକର ବିନିମୟ କରିବା ପାଇଁ lst1 ଏବଂ lst2 ମଧ୍ୟରେ ବିନିମୟ ହୋଇଥିବା ଉପାଦାନର ସଂଖ୍ୟାରେ କୌଣସି ସୀମା ନାହିଁ ।lst1 କୁ କେବଳ ଯୁଗ୍ମ ସଂଖ୍ୟାର ଏକ ସରଳୀକରଣ କରିବା ପାଇଁ _ଏବଂ ଏହା ନିର୍ଣ୍ଣୟ କରେ ଯେ କଣ ଏକ୍ସଚେଞ୍ଜ ଅଫ୍ ଇଲେକ୍ଟ୍ରନ୍ସ୍ ସମ୍ଭବ କି ନୁହେଁ ।ଏହି ସମସ୍ୟା ରେ, ଆପଣ ଏକ ଫଙ୍କସନ କୁ କାର୍ଯ୍ୟକାରୀ କରିବେ ଯାହା ଦୁଇଟା ସଂଖ୍ୟା ର ଆରେ କୁ ନେଇଥାଏ, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\ndef exchange(lst1, lst2)\n","canonical_solution":"def exchange(lst1, lst2)\n  # Check if lst1 already consists solely of even numbers\n  return \"YES\" if lst1.all?(&:even?)\n\n  # Check if there are at least as many even numbers in lst2\n  # as there are odd numbers in lst1\n  odd_count_lst1 = lst1.count(&:odd?)\n  even_count_lst2 = lst2.count(&:even?)\n\n  odd_count_lst1 <= even_count_lst2 ? \"YES\" : \"NO\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_exchange\n    candidate = method(:exchange)\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))\n    assert_equal(\"NO\", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))\n    assert_equal(\"YES\", candidate.call([5, 7, 3], [2, 6, 4]))\n    assert_equal(\"NO\", candidate.call([5, 7, 3], [2, 6, 3]))\n    assert_equal(\"NO\", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\n    assert_equal(\"YES\", candidate.call([100, 200], [200, 200]))\n  end\nend\n"},{"task_id":"HumanEval_111","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଯଦି ଏକାଧିକ ଅକ୍ଷର ସମାନ ଭାବରେ ଦେଖାଯାଏ, ତେବେ ସେଗୁଡ଼ିକୁ ଫେରାଇ ଦିଅନ୍ତୁ ।ଏହି ଅକ୍ଷରଟି ସବୁଠାରୁ ଅଧିକ ଥର ପୁନରାବୃତ୍ତି ହୋଇଥାଏ ଏବଂ ଏଥିରେ ସେହି ଅକ୍ଷରର ସଂଖ୍ୟା ଥାଏ ।ଏକ ସ୍ପେସ୍ ପୃଥକ ଛୋଟ ଅକ୍ଷରକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଯାଇଥିବା ହେଶ୍ ଫେରାଇଥାଏ # >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n","canonical_solution":"def histogram(test)\n  return {} if test.empty?\n\n  count = Hash.new(0)\n\n  test.split.each do |char|\n    count[char] += 1\n  end\n\n  max_count = count.values.max\n  count.select { |_, value| value == max_count }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4}, candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_112","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଆପଣ ଗୋଟିଏ ଆରେ ଫେରାଇବେ ଯେଉଁଥିରେ ପରିଣାମ ଷ୍ଟ୍ରିଙ୍ଗ ଏବଂ ଯାଞ୍ଚ ପାଇଁ ସତ୍ୟ\/ମିଥ୍ୟା ଅଛି.ଗୋଟିଏ ଧାଡ଼ିକୁ ପାଲିଣ୍ଡ୍ରୋମ କୁହାଯାଏ ଯଦି ଏହା ପଛକୁ ଆଗକୁ ସମାନ ଭାବରେ ପଢ଼ାଯାଏ ।ତାପରେ ଯାଞ୍ଚ କରନ୍ତୁ ଯେ ଫଳାଫଳ ଶୃଙ୍ଖଳଟି ପାଲିଣ୍ଡ୍ରୋମ ଅଟେ କି ନାହିଁ ।ଆମକୁ ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗ s ଏବଂ c ଦିଆଯାଇଛି, ଆପଣଙ୍କୁ s ରେ ଥିବା ସମସ୍ତ ଅକ୍ଷରକୁ କାଢ଼ିବାକୁ ହେବ ଯାହା c ରେ ଥିବା କୌଣସି ଅକ୍ଷର ସହିତ ସମାନ କାର୍ଯ୍ୟ # >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n# >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s, c)\n","canonical_solution":"def reverse_delete(s, c)\n  # Remove all characters in c from s\n  filtered_string = s.delete(c)\n  \n  # Check if the filtered string is a palindrome\n  is_palindrome = filtered_string == filtered_string.reverse\n  \n  # Return the result array\n  [filtered_string, is_palindrome]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\", \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n    assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true], candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"mamma\", \"mia\"))\n  end\nend\n"},{"task_id":"HumanEval_113","nl":"ory_Orya","pl":"rb","prompt":" ଇନପୁଟ୍ର i'th ଷ୍ଟ୍ରିଙ୍ଗରେ ଅଜଣା ଅଙ୍କ ଅଛି\" ଯେଉଁଠାରେ ସମସ୍ତ 'i' କୁ ସଂଖ୍ୟା  ଦ୍ୱାରା ବଦଳାଯିବା ଉଚିତଆଉଟପୁଟର ପ୍ରତ୍ୟେକ ଉପାଦାନ i, ରେ ଥିବା ଅଜଣା ଉପାଦାନର ସଂଖ୍ୟା ହେବା ଉଚିତ ।ଗୋଟିଏ ଧାଡ଼ିର ଏକ ସରଳୀକରଣ ଦିଆଗଲା, ଯେଉଁଠାରେ ପ୍ରତ୍ୟେକ ସରଳୀକରଣ କେବଳ ଅଙ୍କଗୁଡ଼ିକର ସମଷ୍ଟି, ଏକ ସରଳୀକରଣ ଫେରାଇଥାଏ.# >>> odd_count.call([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n","canonical_solution":"def odd_count(lst)\n  lst.map do |num_str|\n    count = num_str.count('13579')\n    \"the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\", \"314\"]))\n  end\nend\n"},{"task_id":"HumanEval_114","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ା ା ା ା ାଏକ ସମୁଦାୟ ସଂଖ୍ୟା n ର ଏକ ସରଳୀକରଣ ଦିଆଯାଇ, କୌଣସି ଅଣ-ଖାଲି ଉପ-ସାରୀର ସର୍ବନିମ୍ନ ସମୁଦାୟକୁ ଖୋଜନ୍ତୁ # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n","canonical_solution":"def minSubArraySum(nums)\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    if current_sum > 0\n      current_sum = num\n    else\n      current_sum += num\n    end\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10, candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1, candidate.call([1, -1]))\n  end\nend\n"},{"task_id":"HumanEval_115","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ 1: ଆପଣ କେତେଥର ବାଲ୍ଟିକୁ ତଳକୁ ଆଣିବାକୁ ଚାହୁଁଛନ୍ତି ତାହା ଲେଖନ୍ତୁ ।ଆପଣଙ୍କ କାମ ହେଉଛି କୂଅକୁ ଖାଲି କରିବା ପାଇଁ ଡବା ବ୍ୟବହାର କରିବା ।ଏବଂ ସମସ୍ତ ବାଲ୍ଟିରେ ସମାନ କ୍ଷମତା ରହିଛି ।ପ୍ରତ୍ୟେକ କୂଅରେ ଏକ ବାଡ଼ୀ ରହିଛି, ଯାହାଦ୍ୱାରା ପାଣି ବାହାର କରାଯାଇପାରିବ ।ଏବଂ ପ୍ରତ୍ୟେକ 1 ଗୋଟିଏ ଧାଡ଼ିରେ ଗୋଟିଏ ଜଳ ଏକକକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ।ଆପଣଙ୍କୁ ଏକ ଚତୁର୍ଭୁଜ ଗ୍ରୀଡ ଦିଆଯାଉଛି, ପ୍ରତ୍ୟେକ ଧାଡି ଗୋଟିଏ କୂଅକୁ ପ୍ରତିନିଧିତ୍ୱ କରେ ।# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n","canonical_solution":"def max_fill(grid, capacity)\n  total_water_units = grid.flatten.sum\n  (total_water_units.to_f \/ capacity).ceil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))\n  end\nend\n"},{"task_id":"HumanEval_116","nl":"ory_Orya","pl":"rb","prompt":"ଏହାକୁ ନିମ୍ନଲିଖିତ ଢଙ୍ଗରେ କାର୍ଯ୍ୟକାରୀ କରାଯିବା ଉଚିତ:ସମାନ ସଂଖ୍ୟକ ଏକକ ପାଇଁ, ଦଶମିକ ମୂଲ୍ୟ ଆଧାରରେ ସର୍ଟ କରନ୍ତୁ.ଏକକଗୁଡ଼ିକର ସଂଖ୍ୟା ସେମାନଙ୍କର ବାଇନାରୀ ପ୍ରତିନିଧିତ୍ୱରେ ବୃଦ୍ଧି କ୍ରମରେ _ଏହି କଟା ରେ, ଆପଣଙ୍କୁ ଏକ ନନ୍-ନେଗେଟିଭ୍ ଇଣ୍ଟେଜର ଆରେକୁ ସର୍ଟ କରିବାକୁ ହେବ # >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\ndef sort_array(arr)\n","canonical_solution":"def sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"},{"task_id":"HumanEval_117","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଟିପ୍ପଣୀ: ଆପଣ ଧରିନେବେ ଯେ ଇନପୁଟ୍ ଷ୍ଟ୍ରିଙ୍ଗରେ କେବଳ ଅକ୍ଷର ଏବଂ ସ୍ପେସ୍ ଅଛି ।ଯଦି string s ଖାଲି ହୋଇଥାଏ ତେବେ ଫଳନଟି ଏକ ଖାଲି ଆରେ ଫେରାଇଥାଏ.n ବ୍ୟଞ୍ଜନ, ଏହି ଶବ୍ଦଗୁଡ଼ିକର କ୍ରମରେ s ବାକ୍ୟଖଣ୍ଡରେ ଦେଖାଯାଏ ।ଗୋଟିଏ ଫଳନ ଯାହା s ସଂଖ୍ୟକ ବାକ୍ୟଖଣ୍ଡରୁ ସମସ୍ତ ଶବ୍ଦକୁ ଏକ ସରଳୀକୃତ ସୂଚକ ଭାବରେ ଫେରାଇଥାଏ ।ଗୋଟିଏ ଧାଡ଼ି s ଏବଂ ଗୋଟିଏ ପ୍ରାକୃତିକ ସଂଖ୍ୟା n ଦିଆଗଲା, ଆପଣଙ୍କୁ କାର୍ଯ୍ୟକାରୀ କରିବା ପାଇଁ କୁହାଯାଇଛି # >>> select_words.call(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words.call(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words.call(\"simple white space\", 2)\n# []\n# >>> select_words.call(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words.call(\"Uncle sam\", 3)\n# [\"Uncle\"]\ndef select_words(s, n)\n","canonical_solution":"def select_words(s, n)\n  vowels = \"aeiouAEIOU\"\n  words = s.split\n  words.select do |word|\n    consonant_count = word.chars.count { |char| !vowels.include?(char) }\n    consonant_count == n\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([], candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"a b c d e f\", 1))\n  end\nend\n"},{"task_id":"HumanEval_118","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଆପଣ ଭାବୁଥିବେ ଯେ ଦିଆଯାଇଥିବା ଷ୍ଟ୍ରିଙ୍ଗରେ କେବଳ ଇଂରାଜୀ ଅକ୍ଷର ଅଛି.ଉପରୋକ୍ତ ସର୍ତ୍ତ ପୂରଣ କରୁଥିବା କୌଣସି ସ୍ୱରବର୍ଣ୍ଣ ଖୋଜନ୍ତୁ ।ଆରମ୍ଭ ଏବଂ ସମାପ୍ତିରେ ସ୍ୱରଗୁଡ଼ିକ ଗଣନା କରାଯାଏ ନାହିଁ. ଯଦି ଆପଣ ନକରିଛନ୍ତି ତେବେ ଖାଲି ଷ୍ଟ୍ରିଙ୍ଗ୍ ଫେରାନ୍ତୁ ଦୁଇଟି ବର୍ଣ୍ଣମାଳା ଶବ୍ଦଟିର ଡାହାଣ ପାର୍ଶ୍ବରୁ (ମୌଳିକ ବର୍ଣ୍ଣମାଳା ସମ୍ବେଦନଶୀଳ) ।ଆପଣଙ୍କୁ ଗୋଟିଏ ଶବ୍ଦ ଦିଆଯାଉଛି, ଆପଣଙ୍କ କାମ ହେଉଛି, ସେହି ଶବ୍ଦ ମଧ୍ୟରେ ଥିବା ନିକଟତମ ସ୍ୱର ଚିହ୍ନକୁ ଖୋଜିବା ।# >>> get_closest_vowel.call(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n","canonical_solution":"def get_closest_vowel(word)\n  vowels = \"aeiouAEIOU\"\n  (1...word.length - 1).reverse_each do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n      return word[i]\n    end\n  end\n  return \"\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\", candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"Above\"))\n  end\nend\n"},{"task_id":"HumanEval_119","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:'ହଁ' ଫେରାଇଦିଅନ୍ତୁ ଯଦି ଭଲ ଷ୍ଟ୍ରିଙ୍ଗ ତିଆରି କରିବାର କୌଣସି ଉପାୟ ଅଛି, ଏବଂ ଅନ୍ୟଥା 'ନା' ଫେରାଇଦିଅନ୍ତୁ.\" (()) \" ନୁହେଁ ।ସନ୍ତୁଳିତ. ଉଦାହରଣ ସ୍ୱରୂପ: '(((() ' ବାକ୍ୟଖଣ୍ଡ ଭଲ, ଯେତେବେଳେ କି  ବାକ୍ୟଖଣ୍ଡ ଗୋଟିଏ ଧାଡ଼ି S କୁ ଭଲ ବୋଲି ବିବେଚନା କରାଯାଏ ଯଦି ଏବଂ କେବଳ ଯଦି S ରେ ଥିବା ସମସ୍ତ ବନ୍ଧନୀ କିଛି କ୍ରମ, ଯେ ଫଳସ୍ୱରୂପ ବାକ୍ୟଖଣ୍ଡ ଭଲ ହେବ.ଆପଣଙ୍କର କାମ ହେଉଛି ଯାଞ୍ଚ କରିବା ଏହା ସମ୍ଭବ କି ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗକୁ ଯୋଡିବା ସମ୍ଭବ କି ନୁହେଁ କେବଳ \" (~) \" କିମ୍ବା \" (~) \" କୁଣ୍ଡଳୀରେ ଲେଖାଥିବା ବାକ୍ୟ ।ଆପଣଙ୍କୁ ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗର ଏକ ଆରେ ଦିଆଗଲା, ଦୁଇଟି ଷ୍ଟ୍ରିଙ୍ଗରେ ଖୋଲା ଅଛି # >>> match_parens.call([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n","canonical_solution":"def match_parens(lst)\n  a, b = lst\n\n  # Define a helper method to check if a string is balanced\n  def balanced?(s)\n    count = 0\n    s.each_char do |c|\n      count += 1 if c == '('\n      count -= 1 if c == ')'\n      return false if count < 0\n    end\n    count == 0\n  end\n\n  # Check if either concatenation forms a good string\n  if balanced?(a + b) || balanced?(b + a)\n    \"Yes\"\n  else\n    \"No\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\")())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"(()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n    assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\")(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"},{"task_id":"HumanEval_120","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ 1: ଲମ୍ବ k ର ସର୍ବାଧିକ k ସଂଖ୍ୟା ସହିତ arr ରେ _ଏକ ଧନାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା k ସହିତ ଏକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା arr ଦିଆଗଲା, ଏକ ସର୍ଟ ହୋଇଥିବା ଆରେ ଫେରାଇଥାଏ # >>> maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n","canonical_solution":"def maximum(arr, k)\n  arr.sort.last(k).sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n    assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10], candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))\n  end\nend\n"},{"task_id":"HumanEval_121","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଏକ ଅଣ-ଖାଲି ସଂଖ୍ୟାର ଧାରା ଦେଇ, ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ ସମ# >>> solution.call([5, 8, 7, 1])\n# 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24, 321])\n# 0\ndef solution(lst)\n","canonical_solution":"def solution(lst)\n  lst.each_with_index.reduce(0) do |sum, (val, idx)|\n    (idx.even? && val.odd?) ? sum + val : sum\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7, 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0, candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30, 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"},{"task_id":"HumanEval_122","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏହା ହେଉଛି ସେହି ଉପାଦାନର ସମଷ୍ଟି ଯାହାର ପ୍ରଥମ k ଉପାଦାନର ସଂଖ୍ୟାରୁ ସର୍ବାଧିକ ଦୁଇଟି ଅଙ୍କ ଅଛି ।ଏକ ଅସରନ୍ତି ସମୁଦାୟ ସଂଖ୍ୟା arr ଏବଂ ଏକ ସମୁଦାୟ ସଂଖ୍ୟା k ଦିଆଗଲା, ଫେରାଇ # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k)\n","canonical_solution":"def add_elements(arr, k)\n  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"},{"task_id":"HumanEval_123","nl":"ory_Orya","pl":"rb","prompt":"get_odd_collatz(5) ଫେରାଇଥାଏ [1, 5] # 5 ପାଇଁ କୋଲାଟଜ କ୍ରମ ହେଉଛି [5, 16, 8, 4, 2, 1], ତେଣୁ ଅଜଣା ସଂଖ୍ୟାଗୁଡ଼ିକ ହେଉଛି କେବଳ 1, ଏବଂ 5 । ଉଦାହରଣ ସ୍ୱରୂପ: 2. ଫେରସ୍ତ ହୋଇଥିବା ଆରେକୁ ବୃଦ୍ଧି କ୍ରମରେ ସର୍ଟ କରାଯାଇଛି ।1. କୋଲାଟଜ (୧) ହେଉଛି [1] ।ନୋଟ: ଅନୁମାନ ହେଉଛି ଯେ n ର କୌଣସି ମୂଲ୍ୟ ନଥାଇ ମଧ୍ୟ, କ୍ରମ ସର୍ବଦା 1 କୁ ପହଞ୍ଚିବ.ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟଟି ଅଙ୍କକୋଷୀୟ ହେଲେ ପରବର୍ତ୍ତୀ ବାକ୍ୟଟି ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟର 3 ଗୁଣନ ହେବପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟଟି ଏହିପରି: ଯଦି ପୂର୍ବବର୍ତ୍ତୀ ବାକ୍ୟଟି ଯୁଗ୍ମ, ତେବେ ପରବର୍ତ୍ତୀ ବାକ୍ୟଟି  ର ଅଧା ହେବନିମ୍ନଲିଖିତ ଭାବରେ: ଯେକୌଣସି ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ରୁ ଆରମ୍ଭ କରନ୍ତୁ । ତାପରେ ପ୍ରତ୍ୟେକ ବାକ୍ୟ  ରୁ ପ୍ରାପ୍ତ ହୁଏ ।କୋଲାଟଜ ଅନୁମାନ ହେଉଛି ଗଣିତରେ ଏକ ଅନୁମାନ ଯାହାକି ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ କ୍ରମ ସମ୍ବନ୍ଧରେ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ଏକ ସର୍ଟ ଆରେ ଫେରାଇଥାଏ ଯେଉଁଥିରେ କୋଲାଟଜ କ୍ରମରେ ଅଜଣା ସଂଖ୍ୟା ଥାଏ ।# >>> get_odd_collatz.call(5)\n# [1, 5]\ndef get_odd_collatz(n)\n","canonical_solution":"def get_odd_collatz(n)\n  collatz_sequence = []\n  while n != 1\n    collatz_sequence << n if n.odd?\n    if n.even?\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n  end\n  collatz_sequence << 1 if n == 1\n\n  collatz_sequence.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_odd_collatz\n    candidate = method(:get_odd_collatz)\n    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))\n    assert_equal([1, 5], candidate.call(5))\n    assert_equal([1, 3, 5], candidate.call(12))\n    assert_equal([1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_124","nl":"ory_Orya","pl":"rb","prompt":"4. ତାରିଖକୁ ଏମ୍ଏମ୍-ଡିଡି-ୟେୟେୟେ ଫର୍ମାଟରେ ଲେଖିବା ଉଚିତ ।3. ମାସର ସଂଖ୍ୟା 1 ରୁ କମ କିମ୍ବା 12 ରୁ ଅଧିକ ହେବା ଉଚିତ ନୁହେଁ ।ମାସ 1,3,5,7,8,10,12 ପାଇଁ ଦିନ ସଂଖ୍ୟା 1 ରୁ କମ କିମ୍ବା 31 ଦିନରୁ ଅଧିକ ନୁହେଁ ଏବଂ ମାସ 4,6,9,11 ପାଇଁ ଦିନ ସଂଖ୍ୟା 1 ରୁ କମ କିମ୍ବା 30 ଦିନରୁ ଅଧିକ ନୁହେଁ ଏବଂ ମାସ 2 ପାଇଁ ଦିନ ସଂଖ୍ୟା 1 ରୁ କମ୍ କିମ୍ବା 29 ଦିନରୁ ଅଧିକ ନୁହେଁ ।1. ତାରିଖ ଶୃଙ୍ଖଳ ଖାଲି ନୁହେଁ ।ନିମ୍ନଲିଖିତ ସମସ୍ତ ନିୟମ ପୂରଣ ହେଲେ ତାରିଖ ବୈଧ ହେବ:ଯଦି ତାରିଖଟି ବୈଧ, ତେବେ ଏହା ସତ୍ୟ ଫେରାଇଥାଏ ଅନ୍ୟଥା ମିଥ୍ୟା ।ଆପଣଙ୍କୁ ଏକ ଫଙ୍କସନ ଲେଖିବାକୁ ହେବ ଯାହା ଦିଆଯାଇଥିବା ତାରିଖ ଷ୍ଟ୍ରିଙ୍ଗକୁ ବୈଧ କରିଥାଏ ଏବଂ # >>> valid_date.call(\"03-11-2000\")\n# true\n# >>> valid_date.call(\"15-01-2012\")\n# false\n# >>> valid_date.call(\"04-0-2040\")\n# false\n# >>> valid_date.call(\"06-04-2020\")\n# true\n# >>> valid_date.call(\"06\/04\/2020\")\n# false\ndef valid_date(date)\n","canonical_solution":"def valid_date(date)\n  return false if date.nil? || date.empty?\n  \n  # Check if the date format is correct\n  match = date.match(\/^(\\d{2})-(\\d{2})-(\\d{4})$\/)\n  return false unless match\n  \n  month, day, year = match.captures.map(&:to_i)\n  \n  # Check if month is valid\n  return false if month < 1 || month > 12\n  \n  # Check if day is valid according to the month\n  case month\n  when 1, 3, 5, 7, 8, 10, 12\n    return day >= 1 && day <= 31\n  when 4, 6, 9, 11\n    return day >= 1 && day <= 30\n  when 2\n    return day >= 1 && day <= 29\n  else\n    return false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_valid_date\n    candidate = method(:valid_date)\n    assert_equal(true, candidate.call(\"03-11-2000\"))\n    assert_equal(false, candidate.call(\"15-01-2012\"))\n    assert_equal(false, candidate.call(\"04-0-2040\"))\n    assert_equal(true, candidate.call(\"06-04-2020\"))\n    assert_equal(true, candidate.call(\"01-01-2007\"))\n    assert_equal(false, candidate.call(\"03-32-2011\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"04-31-3000\"))\n    assert_equal(true, candidate.call(\"06-06-2005\"))\n    assert_equal(false, candidate.call(\"21-31-2000\"))\n    assert_equal(true, candidate.call(\"04-12-2003\"))\n    assert_equal(false, candidate.call(\"04122003\"))\n    assert_equal(false, candidate.call(\"20030412\"))\n    assert_equal(false, candidate.call(\"2003-04\"))\n    assert_equal(false, candidate.call(\"2003-04-12\"))\n    assert_equal(false, candidate.call(\"04-2003\"))\n  end\nend\n"},{"task_id":"HumanEval_125","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଅକ୍ଷର, ଅକ୍ଷର (a) = 0, ଅକ୍ଷର (b) = 1, ... ଅକ୍ଷର (z) = 25 ଯଦି କୌଣସି କମାସ୍ ନଥାଏ ତେବେ ଆପଣଙ୍କୁ ଅଙ୍କରେ ଛୋଟ ଅକ୍ଷର ସଂଖ୍ୟାକୁ ଅଙ୍କ କ୍ରମ ଅନୁସାରେ ଫେରାଇଦେବା ଉଚିତ ।ଶବ୍ଦଗୁଡ଼ିକର ଏକ ଧାଡ଼ି ଦିଆଯାଇ, ଯଦି ଆପଣ ଚାହୁଁଥିବା ପାଠରେ କୌଣସି ଶ୍ବେତସ୍ଥାନ ନଥାଏ, ତେବେ ଶ୍ବେତସ୍ଥାନରେ ବିଭକ୍ତ ଶବ୍ଦଗୁଡ଼ିକର ଏକ ସରଳୀକରଣ ଫେରାଇବ # >>> split_words.call(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n","canonical_solution":"def split_words(txt)\n  if txt.include?(' ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }\n    return odd_count\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2, candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n    assert_equal(0, candidate.call(\"\"))\n  end\nend\n"},{"task_id":"HumanEval_126","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସଂଖ୍ୟା, ମିଥ୍ୟା ଫେରାଇବ. କୌଣସି ନକାରାତ୍ମକ ସଂଖ୍ୟା ଗ୍ରହଣ କର ନାହିଁ ଏବଂ କେବଳ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଗ୍ରହଣ କର ।ଯଦି ଆରେରେ ସମାନର 1 ରୁ ଅଧିକ ଡୁପ୍ଲିକେଟ୍ ଅଛି ଏକ ସଂଖ୍ୟାର ଧାରାକୁ ଦେଇ, ସେମାନେ ସର୍ଟ ହୋଇଥାଉ କି ନଥାଉ, ଫେରାଇଥାଏ # >>> is_sorted.call([5])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>> is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n","canonical_solution":"def is_sorted(lst)\n  lst.each_cons(2).with_index do |(a, b), index|\n    return false if a > b\n    return false if index < lst.length - 2 && a == b && lst[index + 2] == b\n  end\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true, candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false, candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_127","nl":"ory_Orya","pl":"rb","prompt":"[ଇନପୁଟ୍\/ଆଉଟପୁଟ୍] ନମୁନା: ଯଦି ଦୁଇଟି ଅନ୍ତରାଳ ପରସ୍ପର ସହିତ ମିଶି ନଥାଏ, ତେବେ \"ନା\" ଫେରାଇଦେବେ.ଅନ୍ୟଥା, \"ନା\" ଫେରାଇଦେବେଯଦି ସଂଯୋଗର ଲମ୍ବ ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା, ତେବେ \"YES\" ଫେରାଇଦେବେ, ଯାହାର ଲମ୍ବ 1 ଅଟେ, ଯାହାକି ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା ନୁହେଁ.ଉଦାହରଣ ସ୍ୱରୂପ, ଅନ୍ତରାଳ (1, 3), (2, 4) ର ଅନ୍ତର ହେଉଛି (2, 3) ଅନ୍ତରାଳ ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା ।ଆପଣଙ୍କର କାମ ହେଉଛି ନିର୍ଣ୍ଣୟ କରିବା ଯେ ଏହି ଦୁଇଟିର ସଂଯୋଗର ଲମ୍ବ ପ୍ରତ୍ୟେକ ଅନ୍ତରାଳ ପାଇଁ, ଏହା ଧରାଯାଏ ଯେ ଏହାର ଆରମ୍ଭ ଏହାର ଶେଷ ଠାରୁ କମ୍ କିମ୍ବା ସମାନ ।ଆରମ୍ଭ ଓ ସମାପ୍ତି ଉଭୟକୁ ଅନ୍ତର୍ଭୁକ୍ତ କରେ ।ଏହି ଅନ୍ତରାଳ ବନ୍ଦ ଅର୍ଥାତ୍ ଅନ୍ତରାଳ (ଆରମ୍ଭ, ଶେଷ) ଯେଉଁଠାରେ ପ୍ରତ୍ୟେକ ଅନ୍ତରାଳ ହେଉଛି ଏକ ଯୋଡି ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା । ଉଦାହରଣ ସ୍ୱରୂପ, ଅନ୍ତରାଳ = (ଆରମ୍ଭ, ଶେଷ) = (1, 2) ।ଆପଣଙ୍କୁ ଦୁଇଟି ଅନ୍ତରାଳ ଦିଆଯାଉଛି, # >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\ndef intersection(interval1, interval2)\n","canonical_solution":"def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n\n  if intersection_start > intersection_end\n    return \"NO\"\n  end\n\n  intersection_length = intersection_end - intersection_start + 1\n\n  return \"YES\" if prime?(intersection_length)\n\n  \"NO\"\nend\n\ndef prime?(n)\n  return false if n <= 1\n  return true if n == 2 || n == 3\n\n  (2..Math.sqrt(n).to_i).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1, 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2, 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\", candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2, -2], [-3, -2]))\n  end\nend\n"},{"task_id":"HumanEval_128","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଟିପ୍ପଣୀ: ଖାଲି arr ପାଇଁ ଶୂନ୍ୟ ଫେରାଇଥାଏ ପ୍ରତ୍ୟେକ ସଂଖ୍ୟାର ଆରେରେ, 1, -1 କିମ୍ବା 0 ଦ୍ୱାରା ପ୍ରତିନିଧିତ୍ୱ କରାଯାଇଛି ।ସଂପୂର୍ଣ୍ଣ ସଂଖ୍ୟାର ପରିମାଣର ସମୁଦାୟ ଗୁଣିତ ସମସ୍ତ ଚିହ୍ନର ଗୁଣନ ଦ୍ବାରା ଆପଣଙ୍କୁ ଏକ ସଂଖ୍ଯା ନିର୍ଣ୍ଣୟକ ଦିଆଗଲା ଏବଂ ଆପଣଙ୍କୁ ଫେରିବାକୁ ପଡିବ# >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n# >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n","canonical_solution":"def prod_signs(arr)\n  return nil if arr.empty?\n  \n  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }\n  sum_magnitudes = arr.map(&:abs).sum\n  \n  product_signs * sum_magnitudes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"},{"task_id":"HumanEval_129","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ସର୍ବନିମ୍ନ ପଥ ଦେଇ ଯାଉଥିବା କୋଷଗୁଡ଼ିକ ଉପରେ ମୂଲ୍ୟଗୁଡ଼ିକର ଏକ ଅର୍ଡରଯୁକ୍ତ ଆରେ ଫେରାଇଥାଏ।ଏହାର ଉତ୍ତର ନିଶ୍ଚିତ ଭାବେ ଅନନ୍ୟ ।lst_A[j] = lst_B[j]  ଏହା ହେଉଛିଯେପରିକି lst_A[i] < lst_B[i] ଏବଂ ଯେକୌଣସି j (1 <= j < i) ପାଇଁ ଆମର lst_B ଠାରୁ, ଅନ୍ୟ ଶବ୍ଦରେ, ସେଠାରେ ଏକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ସୂଚକାଙ୍କ i (1 <= i <= k)  ଅଛି(ଆମେ ସେମାନଙ୍କୁ lst_A ଏବଂ lst_B କହିବା), lst_A ଶବ୍ଦକୋଷିକ ଦୃଷ୍ଟିରୁ କମ୍ ।A ଏବଂ B କୁ ଯାଇଥିବା ସେଲ୍ ଗୁଡିକରେ ଥିବା ମୂଲ୍ୟର ଅର୍ଡର ଆରେ ତିଆରି କରିବା ପରେ ଏକ ପଥ A (ଲମ୍ବ k) କୁ ପଥ B (ଲମ୍ବ k) ଠାରୁ ଛୋଟ ବୋଲି ଧରାଯାଏ ଯଦି ଆପଣ ଗ୍ରୀଡରୁ ବାହାରକୁ ଯାଇପାରିବେ ନାହିଁ ।ଏହା ନିଶ୍ଚିତ ଭାବେ ଭିନ୍ନ) ।ଦୟାକରି ଧ୍ୟାନ ଦିଅନ୍ତୁ ଯେ k ଲମ୍ବ ପଥ ଅର୍ଥାତ୍ k ଟି ସେଲ୍ ପରିଦର୍ଶନ କରିବା (ନକଲି ନୁହେଁ)ଅନ୍ୟ ଶବ୍ଦରେ, ଆପଣ ସେହି କୋଷକୁ ଯାଇପାରିବେ ଯାହା ଆପଣଙ୍କ ସହିତ ଏକ କଡ଼କୁ ଭାଗ କରେ ।ଯେକୌଣସି କୋଷରୁ, ଏବଂ ପ୍ରତ୍ୟେକ ପାଦରେ ଆପଣ ଯେକୌଣସି ପଡୋଶୀ କୋଷକୁ ଯାଇପାରିବେ, ଆପଣଙ୍କୁ ଗ୍ରୀଡରେ k ଲମ୍ବର ସର୍ବନିମ୍ନ ପଥ ଖୋଜିବାକୁ ପଡିବ । ଆପଣ ଆରମ୍ଭ କରିପାରିବେ ଗ୍ରୀଡର କୋଷଗୁଡ଼ିକରେ ସମେତ ଠିକ ଗୋଟିଏ ଥର ଦେଖାଯାଏ ।ଗ୍ରୀଡର ପ୍ରତ୍ୟେକ କୋଷରେ ଏକ ମୂଲ୍ୟ ଅଛି । [୧, N * N] ରେ ଥିବା ପ୍ରତ୍ୟେକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା N ଧାଡି ଏବଂ N ସ୍ତମ୍ଭ (N >= 2) ଏବଂ ଏକ ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା k,  ସହିତ ଏକ ଗ୍ରୀଡ୍ ଦିଆଗଲା ।# >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid, k)\n","canonical_solution":"def minPath(grid, k)\n  n = grid.size\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  min_path = nil\n\n  n.times do |i|\n    n.times do |j|\n      queue = [[[i, j], [grid[i][j]]]]\n      until queue.empty?\n        position, path = queue.shift\n        if path.size == k\n          min_path = path if min_path.nil? || path < min_path\n          next\n        end\n        directions.each do |dx, dy|\n          x, y = position[0] + dx, position[1] + dy\n          if x.between?(0, n-1) && y.between?(0, n-1)\n            queue.push([[x, y], path + [grid[x][y]]])\n          end\n        end\n      end\n    end\n  end\n  min_path\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"},{"task_id":"HumanEval_130","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ପ୍ରଥମ n + 1 ସଂଖ୍ୟାଗୁଡିକର ତ୍ରିବୋନାସୀ କ୍ରମ ।ଆପଣଙ୍କୁ ଏକ ନନ୍-ନଗେଟିଭ୍ ଇଣ୍ଟେଜର ନମ୍ବର n ଦିଆ ଯାଇଛି, ଆପଣଙ୍କୁ a ର ଏକ ଆରେ ରିଟର୍ନ କରିବାକୁ ହେବ = 2 + 3 + 3 = 8 ତ୍ରିଶୂଳ (3) = ତ୍ରିଶୂଳ (2) + ତ୍ରିଶୂଳ (1) + ତ୍ରିଶୂଳ (4)ତ୍ରିଶୂଳ (4) = 3 ତ୍ରିଶୂନ୍ୟ 2 = 1 + (2 \/ 2) = 2 ଉଦାହରଣ ସ୍ୱରୂପ: ତ୍ରିଗୁଣ (n) = ତ୍ରିଗୁଣ (n - 1) + ତ୍ରିଗୁଣ (n - 2) + ତ୍ରିଗୁଣ (n + 1), ଯଦି n ଅଙ୍କ ଅଙ୍କ ଅଙ୍କ ।tri (n) = 1 + n \/ 2, ଯଦି n ଯୁଗ୍ମ ହୋଇଥାଏ ।ତ୍ରିଶୂଳ (୧) = ୩ଟ୍ରିବୋନାସ୍କି କ୍ରମାଙ୍କ ନିମ୍ନଲିଖିତ ପୁନଃ ଘଟଣାର ପରିଭାଷା ରହିଛି:କିନ୍ତୁ ଲୋକମାନେ ଯାହା ଜାଣି ନାହାନ୍ତି ତାହା ହେଉଛି ଟ୍ରିବୋନାସ୍କି କ୍ରମାଙ୍କ ।ସମସ୍ତେ ଫିବୋନାସୀ କ୍ରମାଙ୍କ ଜାଣନ୍ତି, ଏହାକୁ ଗଭୀର ଭାବରେ ଅଧ୍ୟୟନ କରିଥିଲେ ଗଣିତଜ୍ଞମାନେ # >>> tri.call(3)\n# [1, 3, 2, 8]\ndef tri(n)\n","canonical_solution":"def tri(n)\n  sequence = [1, 3]\n  \n  (2..n).each do |i|\n    if i.even?\n      sequence[i] = 1 + i \/ 2\n    else\n      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0\n    end\n  end\n  \n  sequence[0..n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n    assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_131","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: 0 ଫେରାଇଥାଏ ଯଦି ସମସ୍ତ ଅଙ୍କ ଯୁଗ୍ମ ହୋଇଥାଏ.ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆଗଲା, ସେହି ଅଙ୍କଗୁଡ଼ିକର ଗୁଣନକୁ ଫେରାଇଦେବେ.# >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n# 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n","canonical_solution":"def digits(n)\n  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }\n  return 0 if odd_digits.empty?\n  odd_digits.reduce(:*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5, candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5, candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625, candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"},{"task_id":"HumanEval_132","nl":"ory_Orya","pl":"rb","prompt":"ଯେଉଁଠାରେ ଅତି କମରେ ଗୋଟିଏ ବ୍ରାଙ୍କେଟ ଉପସର୍ଗରେ ନେଷ୍ଟ ହୋଇଛି ।ଫଳନଟି true ଫେରାଇବ ଯଦି ଏବଂ କେବଳ ଯଦି ବ୍ରାଙ୍କେଟ୍ସର ଏକ ବୈଧ ଉପକ୍ରମ ଅଛି ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହା କେବଳ ବର୍ଗ ବନ୍ଧନୀ ଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗକୁ ଇନପୁଟ୍ ଭାବରେ ଗ୍ରହଣ କରେ.# >>> is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n# false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n# false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\")\n# true\ndef is_nested(string)\n","canonical_solution":"def is_nested(string)\n  stack = []\n  has_nested = false\n\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n    elsif char == ']'\n      if stack.empty?\n        return false\n      end\n      stack.pop\n      has_nested = true if stack.any?\n    end\n  end\n\n  has_nested\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false, candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n    assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false, candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n    assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"[[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"))\n  end\nend\n"},{"task_id":"HumanEval_133","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ପ୍ରତ୍ୟେକ ଉପାଦାନକୁ ପ୍ରଥମେ ଉପର int{} (ସୀମା) କୁ ଘୋଡାଇ ଦିଅନ୍ତୁ ।ଆପଣଙ୍କୁ ଦିଆଯାଇଥିବା ଆରେରେ ଥିବା ବର୍ଗର ସଂଖ୍ୟାର ସମୁଦାୟ ଫେରାଇବାକୁ ହେବ, ଆପଣଙ୍କୁ ଏକ ସଂଖ୍ୟାର ଏକ ସରଳୀକୃତ ଧାରା ଦିଆଯାଏ ।# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0, 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4, 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map { |num| (num.ceil)**2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0, 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))\n  end\nend\n"},{"task_id":"HumanEval_134","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ନୋଟ: \"ୱାର୍ଡ\" ହେଉଛି ସ୍ପେସ୍ ଦ୍ୱାରା ପୃଥକ ହୋଇଥିବା ଅକ୍ଷରମାନଙ୍କର ଏକ ଗୋଷ୍ଠୀ ।ଏକ ଶବ୍ଦର ଅଂଶ, ଏବଂ ଅନ୍ୟଥା ମିଥ୍ୟା ।ଏକ ନିର୍ଦ୍ଦିଷ୍ଟ ଷ୍ଟ୍ରିଙ୍ଗର ଏକ ଆଲଫାବେଟିକ ଅକ୍ଷର ଅଟେ ଏବଂ ନୁହେଁ ଗୋଟିଏ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି true କୁ ଫେରାଇଥାଏ ଯଦି ଶେଷ ଅକ୍ଷର # >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n","canonical_solution":"check_if_last_char_is_a_letter = ->(txt) {\n  return false if txt.strip.empty?\n  words = txt.strip.split(' ')\n  last_word = words.last\n  return false if last_word.empty?\n  last_char = last_word[-1]\n\n  last_char =~ \/[a-zA-Z]\/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')\n}","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false, candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false, candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false, candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple pi e \"))\n  end\nend\n"},{"task_id":"HumanEval_135","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଦୋହରା ଯାଇଥିବା ମୂଲ୍ୟ ।ଏପରି କୌଣସି ଉପାଦାନ ନାହିଁ ତେବେ ଫେରାଇଦିଅନ୍ତୁ -1. ଦିଆଯାଇଥିବା ଧାଡ଼ିରେ ରହିବ ନାହିଁ ଏହାଠାରୁ ଅଧିକ କିମ୍ବା ସମାନ ନୁହେଁ, ଏହାଠାରୁ ତୁରନ୍ତ ପୂର୍ବବର୍ତ୍ତୀ ଉପାଦାନ ସହିତ ସମାନ ନୁହେଁ ।ଗୋଟିଏ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ଉପାଦାନର ସର୍ବ ବୃହତ ସୂଚକାଙ୍କ ଫେରାଇଥାଏ ଯାହା # >>> can_arrange.call([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange.call([1, 2, 3])\n# -1\ndef can_arrange(arr)\n","canonical_solution":"def can_arrange(arr)\n  (1...arr.length).reverse_each do |i|\n    return i if arr[i] < arr[i - 1]\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_can_arrange\n    candidate = method(:can_arrange)\n    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))\n    assert_equal(-1, candidate.call([1, 2, 4, 5]))\n    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))\n    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))\n    assert_equal(-1, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_136","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଯଦି କୌଣସି ନକାରାତ୍ମକ କିମ୍ବା ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ନଥାଏ, ତେବେ ସେଗୁଡ଼ିକୁ ଶୂନ ଭାବରେ ଫେରାଇଦେବେ. ଧନାତ୍ମକ ସଂଖ୍ଯାମାନଙ୍କର ଏକ ମାର୍ଜିତସବୁଠାରୁ ବଡ ନକାରାତ୍ମକ ସଂଖ୍ଯା, ଏବଂ 'b' ହେଉଛି ସବୁଠାରୁ ଛୋଟଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ (a, b) ଧାରା ଫେରାଇଥାଏ, ଯେଉଁଠାରେ 'a' ହେଉଛି # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n# [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n","canonical_solution":"def largest_smallest_integers(lst)\n  largest_negative = nil\n  smallest_positive = nil\n  \n  lst.each do |num|\n    if num < 0\n      largest_negative = num if largest_negative.nil? || num > largest_negative\n    elsif num > 0\n      smallest_positive = num if smallest_positive.nil? || num < smallest_positive\n    end\n  end\n  \n  [largest_negative, smallest_positive]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil, nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))\n  end\nend\n"},{"task_id":"HumanEval_137","nl":"ory_Orya","pl":"rb","prompt":"ନୋଟ: ଯଦି କୌଣସି ବାସ୍ତବ ସଂଖ୍ୟାକୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଭାବରେ ଦର୍ଶାଯାଏ, ତେବେ ଫ୍ଲୋଟିଂ ପଏଣ୍ଟଟି . କିମ୍ବା ,  ହୋଇପାରେ ।ଯଦି ମୂଲ୍ୟ ସମାନ ହୁଏ ତେବେ ଶୂନକୁ ଫେରାଇଥାଏ ।ପ୍ରକୃତ ସଂଖ୍ୟା, ଏବଂ ଏହାର ଦିଆଯାଇଥିବା ପରିବର୍ତ୍ତନଶୀଳ ପ୍ରକାରରେ ବଡ଼ ପରିବର୍ତ୍ତନଶୀଳକୁ ଫେରାଇଥାଏ ।ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହା ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା, ଫ୍ଲୋଟ୍, କିମ୍ବା ଙ୍କୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଷ୍ଟ୍ରିଙ୍ଗ ଗ୍ରହଣ କରେ# >>> compare_one.call(1, 2.5)\n# 2.5\n# >>> compare_one.call(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one.call(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one.call(\"1\", 1)\n# nil\ndef compare_one(a, b)\n","canonical_solution":"def compare_one(a, b)\n  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')\n  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')\n\n  if a.is_a?(String) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Float)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Float)\n    a = a.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Integer)\n    b = b.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Float)\n    b = b.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(String)\n    a = a.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  else\n    return nil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare_one\n    candidate = method(:compare_one)\n    assert_equal(2, candidate.call(1, 2))\n    assert_equal(2.5, candidate.call(1, 2.5))\n    assert_equal(3, candidate.call(2, 3))\n    assert_equal(6, candidate.call(5, 6))\n    assert_equal(\"2,3\", candidate.call(1, \"2,3\"))\n    assert_equal(\"6\", candidate.call(\"5,1\", \"6\"))\n    assert_equal(\"2\", candidate.call(\"1\", \"2\"))\n    assert_equal(nil, candidate.call(\"1\", 1))\n  end\nend\n"},{"task_id":"HumanEval_138","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ନିର୍ଦ୍ଦିଷ୍ଟ ସଂଖ୍ୟା n କୁ ସଠିକ ଭାବରେ 4 ଟି ସକାରାତ୍ମକ ଯୁଗ୍ମ ସଂଖ୍ୟାର ସମଷ୍ଟି ଭାବରେ ଲେଖାଯାଇପାରିବ କି ନାହିଁ ଆକଳନ କରନ୍ତୁ # >>> is_equal_to_sum_even.call(4)\n# false\n# >>> is_equal_to_sum_even.call(6)\n# false\n# >>> is_equal_to_sum_even.call(8)\n# true\ndef is_equal_to_sum_even(n)\n","canonical_solution":"def is_equal_to_sum_even(n)\n  return false if n < 8\n  n.even?\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_equal_to_sum_even\n    candidate = method(:is_equal_to_sum_even)\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(8))\n    assert_equal(true, candidate.call(10))\n    assert_equal(false, candidate.call(11))\n    assert_equal(true, candidate.call(12))\n    assert_equal(false, candidate.call(13))\n    assert_equal(true, candidate.call(16))\n  end\nend\n"},{"task_id":"HumanEval_139","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଯେଉଁଠାରେ n > 0 ବ୍ରାଜିଲୀୟ_କାରକୀୟ (n) = n! * (n-1)! * (n-2)! * ... * 1! ବ୍ରାଜିଲୀୟ କାରକକୁ ନିମ୍ନଲିଖିତ ଭାବରେ ବ୍ୟାଖ୍ୟା କରାଯାଇଛି: # >>> special_factorial.call(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\ndef special_factorial(n)\n","canonical_solution":"def special_factorial(n)\n  return 1 if n <= 1\n  (1..n).inject(1) { |product, i| product * factorial(i) }\nend\n\ndef factorial(num)\n  return 1 if num <= 1\n  (2..num).inject(1, :*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n    assert_equal(1, candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_140","nl":"ory_Orya","pl":"rb","prompt":"ତାପରେ ସମସ୍ତ କ୍ରମିକ ସ୍ପେସକୁ -  ସହିତ ବଦଳାନ୍ତୁଏବଂ ଯଦି ଗୋଟିଏ ଷ୍ଟ୍ରିଙ୍ଗରେ ଦୁଇରୁ ଅଧିକ କ୍ରମିକ ସ୍ପେସ୍ ଥାଏ, ଏକ ପାଠ୍ୟ ଧାଡ଼ି ଦିଆଯାଇଥିବା, ଏହାର ସମସ୍ତ ସ୍ପେସ୍ ଅଣ୍ଡରସ୍କୋର ସହିତ ବଦଳାନ୍ତୁ, # >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n","canonical_solution":"def fix_spaces(text)\n  text.strip.gsub(\/\\s{3,}\/, '-').gsub(' ', '_')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2 2 mple\"))\n  end\nend\n"},{"task_id":"HumanEval_141","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:- ବିନ୍ଦୁ ପରେ ଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗଟି ଏହି ମଧ୍ୟରୁ ଗୋଟିଏ ହେବା ଉଚିତ: ['txt', 'exe', 'dll'] ଲାଟିନ ଅକ୍ଷର (ଏ-ଜେଡ ଏବଂ ଏ-ଜେଡ) ।- ଡଟ୍ ପୂର୍ବରୁ ଥିବା ସବଷ୍ଟ୍ରିଙ୍ଗ ଖାଲି ହେବା ଉଚିତ ନୁହେଁ, ଏବଂ ଏହା  ଠାରୁ ଏକ ଅକ୍ଷର ସହିତ ଆରମ୍ଭ ହୋଇଥାଏ- ଫାଇଲ ନାମରେ ଗୋଟିଏ ବିନ୍ଦୁ ଅଛି '.' - ଫାଇଲ ନାମରେ ତିନିରୁ ଅଧିକ ଅଙ୍କ ('0'-'9') ରହିବା ଉଚିତ ନୁହେଁ ।ପୂରଣ ହୋଇଛି:ଏକ ଫାଇଲ ନାମ ବୈଧ ବୋଲି ବିବେଚନା କରାଯାଏ ଯଦି ଏବଂ କେବଳ ଯଦି ନିମ୍ନଲିଖିତ ସମସ୍ତ ସର୍ତ୍ତ ପୂରଣ ହୁଏ _'ହଁ' ଯଦି ଫାଇଲ ନାମ ବୈଧ, ଏବଂ ଅନ୍ୟଥା 'ନା' ଫେରାଇଥାଏ.ଏକ ଫଳନ ସୃଷ୍ଟି କରନ୍ତୁ ଯାହାକି ଏକ ଫାଇଲ ନାମକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ନେଇଥାଏ, ଏବଂ ଫେରାଇଥାଏ # >>> file_name_check.call(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check.call(\"1example.dll\")\n# \"No\"\ndef file_name_check(file_name)\n","canonical_solution":"def file_name_check(file_name)\n  # Check if there's exactly one dot in the filename\n  return 'No' unless file_name.count('.') == 1\n  \n  # Split the filename into the name and extension\n  name, extension = file_name.split('.')\n  \n  # Check if the name part starts with a letter\n  return 'No' if name.empty? || !name[0].match?(\/[a-zA-Z]\/)\n  \n  # Check if the extension is valid\n  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)\n  \n  # Count digits in the file name\n  digit_count = file_name.count(\"0-9\")\n  \n  # Check if digits are more than three\n  return 'No' if digit_count > 3\n  \n  'Yes'\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_file_name_check\n    candidate = method(:file_name_check)\n    assert_equal(\"Yes\", candidate.call(\"example.txt\"))\n    assert_equal(\"No\", candidate.call(\"1example.dll\"))\n    assert_equal(\"No\", candidate.call(\"s1sdf3.asd\"))\n    assert_equal(\"Yes\", candidate.call(\"K.dll\"))\n    assert_equal(\"Yes\", candidate.call(\"MY16FILE3.exe\"))\n    assert_equal(\"No\", candidate.call(\"His12FILE94.exe\"))\n    assert_equal(\"No\", candidate.call(\"_Y.txt\"))\n    assert_equal(\"No\", candidate.call(\"?aREYA.exe\"))\n    assert_equal(\"No\", candidate.call(\"\/this_is_valid.dll\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.wow\"))\n    assert_equal(\"Yes\", candidate.call(\"this_is_valid.txt\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.txtexe\"))\n    assert_equal(\"No\", candidate.call(\"#this2_i4s_5valid.ten\"))\n    assert_equal(\"No\", candidate.call(\"@this1_is6_valid.exe\"))\n    assert_equal(\"No\", candidate.call(\"this_is_12valid.6exe4.txt\"))\n    assert_equal(\"No\", candidate.call(\"all.exe.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"I563_No.exe\"))\n    assert_equal(\"Yes\", candidate.call(\"Is3youfault.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"no_one#knows.dll\"))\n    assert_equal(\"No\", candidate.call(\"1I563_Yes3.exe\"))\n    assert_equal(\"No\", candidate.call(\"I563_Yes3.txtt\"))\n    assert_equal(\"No\", candidate.call(\"final..txt\"))\n    assert_equal(\"No\", candidate.call(\"final132\"))\n    assert_equal(\"No\", candidate.call(\"_f4indsartal132.\"))\n    assert_equal(\"No\", candidate.call(\".txt\"))\n    assert_equal(\"No\", candidate.call(\"s.\"))\n  end\nend\n"},{"task_id":"HumanEval_142","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ସେହି ଆରେରେ ଥିବା ଏଣ୍ଟ୍ରିଗୁଡ଼ିକୁ ପରିବର୍ତ୍ତନ କରନ୍ତୁ ଯାହାର ସୂଚକାଙ୍କ 3 କିମ୍ବା 4 ର ଗୁଣନ ନୁହେଁ _ ଫଳନଟି ସମସ୍ତ ଏଣ୍ଟ୍ରିଗୁଡିକର ସମୁଦାୟ ଫେରାଇବ _3 ର ଗୁଣକ ଏବଂ ସଂଖ୍ଯାଟି 3 ର ଗୁଣକ ନୁହେଁ, ଯଦି ତାହାର ସୂଚକାଙ୍କ 4 ର ଗୁଣକ ହୁଏ ତେବେ ଏହା ସଂଖ୍ଯାଟି କୁୟବ କରିବଏହି ଫଳନଟି ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡ଼ିକର ଏକ ସରଳୀକରଣ ଗ୍ରହଣ କରିବ । ସରଳୀକରଣରେ ଥିବା ସମସ୍ତ ଏଣ୍ଟ୍ରି ପାଇଁ, ଯଦି ଏହାର ସୂଚକାଙ୍କ a  ହୁଏ ତେବେ ଫଳନଟି ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଏଣ୍ଟ୍ରିକୁ ବର୍ଗୀକରଣ କରିବ ।\" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map.with_index do |num, index|\n    if index % 3 == 0\n      num ** 2\n    elsif index % 4 == 0\n      num ** 3\n    else\n      num\n    end\n  end.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(6, candidate.call([1, 2, 3]))\n    assert_equal(14, candidate.call([1, 4, 9]))\n    assert_equal(0, candidate.call([]))\n    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n    assert_equal(0, candidate.call([0]))\n    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))\n    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))\n    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))\n    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))\n    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))\n  end\nend\n"},{"task_id":"HumanEval_143","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ 1: ନୂତନ ବାକ୍ୟଖଣ୍ଡରେ ଥିବା ଶବ୍ଦଗୁଡ଼ିକର କ୍ରମାଙ୍କ ମୂଳ ବାକ୍ୟଖଣ୍ଡର କ୍ରମାଙ୍କ ସହିତ ସମାନ ହେବା ଉଚିତ ।ଯାହାର ଲମ୍ବ ଅଶୂନ୍ୟ ସଂଖ୍ୟା, ଏବଂ ଆପଣଙ୍କୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇବାକୁ ହେବ ଯେଉଁଥିରେ ମୂଳ ବାକ୍ୟର ଶବ୍ଦ ଅଛି, ବାକ୍ୟରେ କିଛି ଶବ୍ଦ ଅଛି, ଯାହା ସ୍ପେସ୍ ଦ୍ବାରା ପୃଥକ ହୋଇଛି,ଆପଣଙ୍କୁ ଏକ ବାକ୍ୟକୁ ପ୍ରତିନିଧିତ୍ୱ କରୁଥିବା ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଦିଆଯାଏ, # >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n","canonical_solution":"def words_in_sentence(sentence)\n  def is_prime?(num)\n    return false if num <= 1\n    (2..Math.sqrt(num)).none? { |i| num % i == 0 }\n  end\n  \n  words = sentence.split(\" \")\n  prime_length_words = words.select { |word| is_prime?(word.length) }\n  prime_length_words.join(\" \")\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"))\n  end\nend\n"},{"task_id":"HumanEval_144","nl":"ory_Orya","pl":"rb","prompt":"ଆପଣ ମାନିପାରିବେ ଯେ x, ଏବଂ n ହେଉଛି ବୈଧ ଖଣ୍ଡ, ଏବଂ ଶୂନ ନାମକର୍ତ୍ତା ଭାବରେ ନାହିଁ.<numerator>\/<denominator> ଯେଉଁଠାରେ ଉଭୟ ସଂଖ୍ଯକ ଓ ନାମକ ସକାରାତ୍ମକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ଯା ହୋଇଥାଏ ।ଅନ୍ୟଥା, ଉଭୟ x ଏବଂ n, ଏକ ଫ୍ରାକସନ୍ ର ଷ୍ଟ୍ରିଙ୍ଗ୍ ପ୍ରତିନିଧିତ୍ୱ, ଏବଂ ନିମ୍ନଲିଖିତ ଫର୍ମାଟ୍ ଅଛି, x * n. ଯଦି x * n ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାକୁ ମୂଲ୍ୟାଙ୍କନ କରେ ଏବଂ false ଆପଣଙ୍କର କାମ ହେଉଛି ଏକ ଫଳନକୁ କାର୍ଯ୍ୟକାରୀ କରିବା ଯାହା ଅଭିବ୍ୟକ୍ତିକୁ ସରଳ କରିବ # >>> simplify.call(\"1\/5\", \"5\/1\")\n# true\n# >>> simplify.call(\"1\/6\", \"2\/1\")\n# false\n# >>> simplify.call(\"7\/10\", \"10\/2\")\n# false\ndef simplify(x, n)\n","canonical_solution":"def simplify(x, n)\n  # Convert x and n to numerators and denominators\n  num_x, den_x = x.split('\/').map(&:to_i)\n  num_n, den_n = n.split('\/').map(&:to_i)\n\n  # Multiply fractions: (num_x * num_n) \/ (den_x * den_n)\n  numerator = num_x * num_n\n  denominator = den_x * den_n\n\n  # Check if the result is a whole number\n  numerator % denominator == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_simplify\n    candidate = method(:simplify)\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/6\", \"2\/1\"))\n    assert_equal(true, candidate.call(\"5\/1\", \"3\/1\"))\n    assert_equal(false, candidate.call(\"7\/10\", \"10\/2\"))\n    assert_equal(true, candidate.call(\"2\/10\", \"50\/10\"))\n    assert_equal(true, candidate.call(\"7\/2\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"11\/6\", \"6\/1\"))\n    assert_equal(false, candidate.call(\"2\/3\", \"5\/2\"))\n    assert_equal(false, candidate.call(\"5\/2\", \"3\/5\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"8\/4\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/5\", \"1\/5\"))\n  end\nend\n"},{"task_id":"HumanEval_145","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ମୂଳ ଧାଡ଼ିରେ ଥିବା ସୂଚକାଙ୍କ ଆଧାରରେ ସେମାନଙ୍କୁ କ୍ରମାନୁସାରେ ରଖନ୍ତୁ ।ନୋଟ: ଯଦି ଏକାଧିକ ଆଇଟମ ଅଛି ଯାହାର ଅଙ୍କ ସମୂହ ସମାନ, ତେବେ ଅଙ୍କ ସମୂହ ଅନୁସାରେ କ୍ରମାନୁସାରେ ।ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଦିଆଯାଇଥିବା ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡ଼ିକର ସରଳୀକରଣ କରେ ।# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n","canonical_solution":"def order_by_points(nums)\n  nums.sort_by.with_index do |num, index|\n    [num.to_s.chars.map(&:to_i).sum.abs, index]\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"},{"task_id":"HumanEval_146","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଏକ ସଂଖ୍ୟାର ପ୍ରଥମ ଓ ଶେଷ ଅଙ୍କ ଅଙ୍କ (1, 3, 5, 7, 9) ।10 ରୁ ଅଧିକ ଏବଂ ଉଭୟ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ସଂଖ୍ୟାର ସରଳୀକୃତକୁ ଇନପୁଟ୍ ଭାବରେ ଗ୍ରହଣ କରେ ଏବଂ ଫେରସ୍ତ କରେ # >>> specialFilter.call([15, -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\ndef specialFilter(nums)\n","canonical_solution":"def specialFilter(nums)\n  nums.count do |num|\n    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5, -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_147","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏବଂ a[i] + a[j] + a[k] ହେଉଛି 3 ର ଗୁଣନ ।a ର ତ୍ରିଗୁଣ ସଂଖ୍ୟା (a[i], a[j], a[k]) କୁ ଫେରାଇଦିଏ ଯେଉଁଠାରେ i < j < k, ପ୍ରତ୍ୟେକ i (1 ≤ i ≤ n) ପାଇଁ, a[i] = i * i - i + 1 ର ମୂଲ୍ୟ ।ଆପଣଙ୍କୁ ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା n ଦିଆ ଯାଇଛି. ଆପଣଙ୍କୁ ଏକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ସରଳୀକୃତ କରିବା ପାଇଁ ହେବ ଯାହାର ଲମ୍ବ n # >>> get_max_triples.call(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\ndef get_max_triples(n)\n","canonical_solution":"def get_max_triples(n)\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  count = 0\n  \n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      (j+1...n).each do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n    assert_equal(53361, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_148","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଗ୍ରହ ନାମ ଠିକ୍ ନୁହେଁ ।ଫଳନଟି ଏକ ଖାଲି ଆରେ ଫେରାଇଥାଏ ଯଦି ଗ୍ରହ1 କିମ୍ବା ଗ୍ରହ2 ସୂର୍ଯ୍ୟର ନିକଟତା ।ଗ୍ରହ ୧ ଓ ଗ୍ରହ ୨ର କକ୍ଷପଥ ମଧ୍ୟରେ ଅବସ୍ଥିତ, ଏହି ଫଳନ ଏକ ଆରେ ଫେରାଇବ ଯେଉଁଥିରେ ସମସ୍ତ ଗ୍ରହ ଅଛି ଯାହାର କକ୍ଷପଥ ହେଉଛି ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଦୁଇଟି ଗ୍ରହ ନାମକୁ \"planet1\" ଏବଂ \"planet2\" ପରି ଧାଡ଼ି ଭାବରେ ଗ୍ରହଣ କରେ ।ୟୁରେନସ୍, ନେପଚୁନ ।ମଙ୍ଗଳ ଗ୍ରହ, ପରବର୍ତ୍ତୀ ଗ୍ରହ ହେଉଛି ଶୁକ୍ର, ତାପରେ ପୃଥିବୀ, ମଙ୍ଗଳ, ବୃହସ୍ପତି, ଶନି,ଆମ ସୌରମଣ୍ଡଳରେ ଆଠଟି ଗ୍ରହ ଅଛି: ସୂର୍ଯ୍ୟଙ୍କ ନିକଟତମ ।# >>> bf.call(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf.call(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf.call(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\ndef bf(planet1, planet2)\n","canonical_solution":"def bf(planet1, planet2)\n  planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \n  idx1 = planets.index(planet1)\n  idx2 = planets.index(planet2)\n  \n  return [] if idx1.nil? || idx2.nil?\n\n  start_idx, end_idx = [idx1, idx2].sort\n  \n  planets[(start_idx + 1)...end_idx]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_bf\n    candidate = method(:bf)\n    assert_equal([\"Saturn\", \"Uranus\"], candidate.call(\"Jupiter\", \"Neptune\"))\n    assert_equal([\"Venus\"], candidate.call(\"Earth\", \"Mercury\"))\n    assert_equal([\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], candidate.call(\"Mercury\", \"Uranus\"))\n    assert_equal([\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], candidate.call(\"Neptune\", \"Venus\"))\n    assert_equal([], candidate.call(\"Earth\", \"Earth\"))\n    assert_equal([], candidate.call(\"Mars\", \"Earth\"))\n    assert_equal([], candidate.call(\"Jupiter\", \"Makemake\"))\n  end\nend\n"},{"task_id":"HumanEval_149","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଆପଣ ଭାବୁଥିବେ ସବୁ ଶବ୍ଦ ସମାନ ଲମ୍ବର ହେବ ।ଫଳନଟି ଏକ ସର୍ଟ କ୍ରମରେ ଏକ ଶୃଙ୍ଖଳା ଶୃଙ୍ଖଳା ଫେରାଇବ.ଯଦି ଦୁଇଟି ଶବ୍ଦର ଲମ୍ବ ସମାନ, ତେବେ ଆଲଫାବେଟିକ କ୍ରମରେ ସର୍ଟ କରନ୍ତୁ.ସେହି ନିୟମ ଦ୍ୱାରା ସଜାଡ଼ାଯାଇଥିବା ଆରେ ଫେରାଇବ.ଆରେର କ୍ରମାଙ୍କ ପ୍ରତ୍ୟେକ ଶବ୍ଦର ଲମ୍ବ ଅନୁସାରେ ବୃଦ୍ଧି ହେବା ଉଚିତ, ଏବଂ ଆପଣ ଏବଂ ଏଥିରେ ଡୁପ୍ଲିକେଟ୍ ମଧ୍ୟ ରହିପାରେ ।ଏକ ସରଳୀକରଣ ସର୍ବଦା ଏକ ସରଳୀକରଣ ଅଟେ ଏବଂ କେବେ ବି ଏକ ସଂଖ୍ୟାର ସରଳୀକରଣ ନୁହେଁ, ଏବଂ ଫଳାଫଳ ଆରେକୁ ଏକ ସର୍ଟ ହୋଇଥିବା କ୍ରମରେ ଫେରାଇଥାଏ,  ଏହାଠାରୁ ଅଜଣା ଲମ୍ବ ଥିବା ଷ୍ଟ୍ରିଙ୍ଗକୁ ଲିଭାଇଥାଏ,ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ସରଳୀକୃତ ଧାଡ଼ିଗୁଡ଼ିକୁ ଏକ ପାରାମିଟର ଭାବରେ ଗ୍ରହଣ କରିଥାଏ, # >>> list_sort.call([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n","canonical_solution":"def list_sort(arr)\n  arr.select { |s| s.length.even? }\n     .sort_by { |s| [s.length, s] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\", \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"], candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"},{"task_id":"HumanEval_150","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏକ ଅଶୂନ୍ୟ ସଂଖ୍ୟା ଏବଂ y ର ମୂଲ୍ୟ ଫେରାଇବ _ଗୋଟିଏ ସରଳ ପ୍ରୋଗ୍ରାମ ଯାହା x ର ମୂଲ୍ୟ ଫେରାଇବ ଯଦି n ହେଉଛି # >>> x_or_y.call(7, 34, 12)\n# 34\n# >>> x_or_y.call(15, 8, 5)\n# 5\ndef x_or_y(n, x, y)\n","canonical_solution":"def x_or_y(n, x, y)\n  require 'prime'\n  n.prime? ? x : y\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_x_or_y\n    candidate = method(:x_or_y)\n    assert_equal(34, candidate.call(7, 34, 12))\n    assert_equal(5, candidate.call(15, 8, 5))\n    assert_equal(33, candidate.call(3, 33, 5212))\n    assert_equal(3, candidate.call(1259, 3, 52))\n    assert_equal(-1, candidate.call(7919, -1, 12))\n    assert_equal(583, candidate.call(3609, 1245, 583))\n    assert_equal(129, candidate.call(91, 56, 129))\n    assert_equal(1234, candidate.call(6, 34, 1234))\n    assert_equal(0, candidate.call(1, 2, 0))\n    assert_equal(2, candidate.call(2, 2, 0))\n  end\nend\n"},{"task_id":"HumanEval_151","nl":"ory_Orya","pl":"rb","prompt":"ସେହି ସଂଖ୍ୟାଗୁଡ଼ିକୁ ଅଣଦେଖା କରନ୍ତୁ ଯାହା ନକାରାତ୍ମକ କିମ୍ବା ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାଗୁଡିକ ନୁହେଁ ।ଏକ ସଂଖ୍ୟାର ସରଳୀକୃତ, ସଂଖ୍ୟାର ବର୍ଗର ସମୁଦାୟକୁ ଫେରାଇଦିଅନ୍ତୁ # >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1, -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n# 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n","canonical_solution":"def double_the_difference(lst)\n  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }\n     .map { |n| n ** 2 }\n     .sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"},{"task_id":"HumanEval_152","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ: ଯଦି 0 ନ ହୁଏ, ତେବେ ମୂଲ୍ୟାଙ୍କନ ହେଉଛି ଅନୁମାନ ଓ ସ୍କୋର ମଧ୍ୟରେ ଥିବା ଅସୀମ ପାର୍ଥକ୍ୟ ।ସମାନ ଲମ୍ବର ଏକ ଆରେ ଫେରାଇଥାଏ, ପ୍ରତ୍ୟେକ ଅନୁମାନ କେତେ ଦୂର ଥିଲା ତାହା ଦର୍ଶାଇଥାଏ। ଯଦି ସେମାନେ ସଠିକ୍ ଅନୁମାନ କରିଛନ୍ତି, ଆପଣଙ୍କୁ ସମାନ ଲମ୍ବର ଦୁଇଟି ସ୍କୋର ଏବଂ ଅନୁମାନର ଆରେ ଦିଆଯାଏ, ଯେଉଁଠାରେ ପ୍ରତ୍ୟେକ ସୂଚକାଙ୍କ ଏକ ମେଳ ଦେଖାଏ _ଆପଣଙ୍କ କାମ ହେଉଛି ଏହା ଜାଣିବା ଯେ ଜଣେ ବ୍ୟକ୍ତି କେତେଗୁଡ଼ିଏ ମ୍ୟାଚର ଫଳାଫଳକୁ ସଠିକ ଭାବରେ ଅନୁମାନ କରିପାରିଛନ୍ତି କି ନାହିଁ ।ଏହା ନିଶ୍ଚିତ ଭାବେ ଉଲ୍ଲେଖନୀୟ ଏବଂ ତୁଳନାତ୍ମକ ।ଏହି ଘଟଣାଟି ଶେଷରେ ଜଣା ପଡିଛି । ସେହି ମୁହୂର୍ତ୍ତରେ ଆପଣଙ୍କର ଭାବନା ଏବଂ ଚିନ୍ତାଧାରା ହେଉଛି ମୁଁ ଭାବୁଛି ଆମେ ସମସ୍ତେ ସେହି ଅନୁଭବକୁ ମନେ ପକାଉଛୁ ଯେତେବେଳେ ଦୀର୍ଘ ପ୍ରତୀକ୍ଷିତ # >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\ndef compare(game, guess)\n","canonical_solution":"def compare(game, guess)\n  game.zip(guess).map { |score, prediction| (score - prediction).abs }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_153","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:(ଏହାର ଶକ୍ତି -୧) ।'Slices.SERVINGSliCes' କୁ ଫେରାଇଥାଏ କାରଣ 'SERVINGSliCes' ହେଉଛି ସବୁଠାରୁ ଶକ୍ତିଶାଳୀ ସଂପ୍ରସାରଣ ['ସର୍ଭିଙ୍ଗ୍ ସିଲିସ୍', 'ଚିଜ୍', 'ଷ୍ଟୁଫେଡ୍'] ତେବେ ଆପଣ ଉଦାହରଣ ସ୍ୱରୂପ, ଯଦି ଆପଣଙ୍କୁ \"Slices\" ଦିଆଯାଏ ତେବେ ଏହା ହେଉଛି ଶ୍ରେଣୀ ଏବଂ  ର ଏକ ସରଳୀକରଣଆରେରେ ପ୍ରଥମେ ଆସୁଥିବା ଗୋଟିଏକୁ ବାଛନ୍ତୁ.ଯଦି ଦୁଇଟି କିମ୍ବା ଅଧିକ ସଂପ୍ରସାରଣ ସମାନ ଶକ୍ତି ସହିତ ଅଛି, ତେବେ ଆପଣ ଶୈଳୀ: ଶ୍ରେଣୀ ନାମ. ଶକ୍ତିଶାଳୀ ଅନୁଲଗ୍ନ ନାମ. ଆପଣଙ୍କୁ ସବୁଠାରୁ ଅଧିକ ଶକ୍ତିଶାଳୀ ସଂପ୍ରସାରଣ ଖୋଜିବାକୁ ହେବ ଏବଂ ଏଥିରେ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ଫେରାଇବାକୁ ହେବସଂପ୍ରସାରଣର ନାମରେ, ଶକ୍ତି CAP - SM ଫ୍ରାକସନ୍ ଦ୍ୱାରା ଦିଆଯାଇଥାଏ ।ସଂପ୍ରସାରଣର ନାମରେ ଥିବା ଅକ୍ଷର, ଏବଂ SM କୁ ଛୋଟ ଅକ୍ଷର ସଂଖ୍ୟା ଭାବରେ ଗ୍ରହଣ କରନ୍ତୁ ସଂପ୍ରସାରଣର ଶକ୍ତି ନିମ୍ନଲିଖିତ ଅଟେ: CAP କୁ ବଡ଼ ଅକ୍ଷରର ସଂଖ୍ୟା ବୋଲି ଧରିନେବା ସେହି ସମ୍ପ୍ରସାରଣଗୁଡ଼ିକ ଶ୍ରେଣୀକୁ ଅତିରିକ୍ତ ଶ୍ରେଣୀଗୁଡ଼ିକୁ ଲୋଡ୍ କରିବା ପାଇଁ ବ୍ୟବହାର କରାଯିବ ।ଆପଣଙ୍କୁ ଏକ ଶ୍ରେଣୀ ନାମ (ଏକ ବାକ୍ୟଖଣ୍ଡ) ଏବଂ ଏକ ସଂପ୍ରସାରଣର ଏକ ସରଳୀକୃତ ଦିଆଯିବ.# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n","canonical_solution":"def Strongest_Extension(class_name, extensions)\n  strongest_extension = extensions.max_by do |extension|\n    cap_count = extension.count('A-Z')\n    sm_count = extension.count('a-z')\n    cap_count - sm_count\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\", candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\", candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"_\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\", [\"671235\", \"Bb\"]))\n  end\nend\n"},{"task_id":"HumanEval_154","nl":"ory_Orya","pl":"rb","prompt":"ଆପଣଙ୍କୁ ୨ଟି ଶବ୍ଦ ଦିଆଯାଇଛି. ଆପଣଙ୍କୁ ସତ୍ୟ ଫେରାଇବାକୁ ହେବ ଯଦି ଦ୍ୱିତୀୟ ଶବ୍ଦ କିମ୍ବା ଏହାର କୌଣସି ଘୂର୍ଣ୍ଣନ ପ୍ରଥମ ଶବ୍ଦରେ ଏକ ସବଷ୍ଟ୍ରିଙ୍ଗ୍ # >>> cycpattern_check.call(\"abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n# >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n# >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a, b)\n","canonical_solution":"def cycpattern_check(a, b)\n  (0...b.length).each do |i|\n    rotated_b = b[i..-1] + b[0...i]\n    return true if a.include?(rotated_b)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true, candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"))\n  end\nend\n"},{"task_id":"HumanEval_155","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଏକ ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଦିଆଗଲା, ଏକ ସରଳୀକରଣ ଫେରାଇଥାଏ ଯେଉଁଥିରେ ଯଥାକ୍ରମେ ଯୁଗ୍ମ ଏବଂ ଅଙ୍କ ସଂଖ୍ୟା ଥାଏ ।# >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n# [1, 2]\ndef even_odd_count(num)\n","canonical_solution":"def even_odd_count(num)\n  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"},{"task_id":"HumanEval_156","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ପ୍ରତିବନ୍ଧକ: 1 <= ସଂଖ୍ୟା <= 1000 ଏବଂ ଏହାକୁ ଛୋଟ ଅକ୍ଷରରେ ଲେଖନ୍ତୁ ।ଏକ ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା ଦିଆଗଲା, ଏହାର ରୋମାନ୍ ସଂଖ୍ୟା ସମକକ୍ଷକୁ ଏକ ଷ୍ଟ୍ରିଙ୍ଗ ଭାବରେ ପ୍ରାପ୍ତ କରନ୍ତୁ, # >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n# \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n","canonical_solution":"def int_to_mini_roman(number)\n  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n  result = ''\n  values.each_with_index do |value, index|\n    while number >= value\n      number -= value\n      result += numerals[index]\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"},{"task_id":"HumanEval_157","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:90 ଡିଗ୍ରୀ ।ଏକ ସଠିକ କୋଣ ବିଶିଷ୍ଟ ତ୍ରିଭୁଜ ହେଉଛି ଏକ ତ୍ରିଭୁଜ ଯେଉଁଥିରେ ଗୋଟିଏ କୋଣ ସଠିକ କୋଣ ବା ପାର୍ଶ୍ବଗୁଡ଼ିକ ଏକ ସଠିକ କୋଣ ବିଶିଷ୍ଟ ତ୍ରିଭୁଜ ଗଠନ କରେ, ଅନ୍ୟଥା ଏହା ମିଥ୍ୟା ।ତ୍ରିଭୁଜର ତିନି ପାର୍ଶ୍ବ ର ଲମ୍ବ ଦିଆଗଲା.# >>> right_angle_triangle.call(3, 4, 5)\n# true\n# >>> right_angle_triangle.call(1, 2, 3)\n# false\ndef right_angle_triangle(a, b, c)\n","canonical_solution":"def right_angle_triangle(a, b, c)\n  sides = [a, b, c].sort\n  sides[0]**2 + sides[1]**2 == sides[2]**2\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_right_angle_triangle\n    candidate = method(:right_angle_triangle)\n    assert_equal(true, candidate.call(3, 4, 5))\n    assert_equal(false, candidate.call(1, 2, 3))\n    assert_equal(true, candidate.call(10, 6, 8))\n    assert_equal(false, candidate.call(2, 2, 2))\n    assert_equal(true, candidate.call(7, 24, 25))\n    assert_equal(false, candidate.call(10, 5, 7))\n    assert_equal(true, candidate.call(5, 12, 13))\n    assert_equal(true, candidate.call(15, 8, 17))\n    assert_equal(true, candidate.call(48, 55, 73))\n    assert_equal(false, candidate.call(1, 1, 1))\n    assert_equal(false, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_158","nl":"ory_Orya","pl":"rb","prompt":"ଅକ୍ଷରଗୁଡ଼ିକର ତାଲିକାକୁ ବଦଳାଇ, ଶବ୍ଦକୋଷିକ କ୍ରମରେ ପ୍ରଥମେ ଆସୁଥିବା ଅକ୍ଷରକୁ ଫେରାଇବ ।ଯଦି ଏକାଧିକ ଷ୍ଟ୍ରିଙ୍ଗ୍ ରେ ସର୍ବାଧିକ ସଂଖ୍ୟକ ଅନନ୍ୟ ଅକ୍ଷର ଅଛି ଏହି ଧାଡ଼ିରେ ଭିନ୍ନ ଭିନ୍ନ ଶବ୍ଦ ଅଛି. ସର୍ବାଧିକ ସଂଖ୍ୟକ ସହିତ ଶବ୍ଦକୁ ଫେରାଇଦିଅନ୍ତୁ ଏକ ଫଳନ ଲେଖନ୍ତୁ ଯାହା ଏକ ଶୃଙ୍ଖଳାକୁ ଗ୍ରହଣ କରେ _# >>> find_max.call([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n","canonical_solution":"def find_max(words)\n  # Helper function to count unique characters\n  def unique_char_count(word)\n    word.chars.uniq.size\n  end\n\n  words.max_by { |word| [unique_char_count(word), -word] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n  end\nend\n"},{"task_id":"HumanEval_159","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ:ଯଦି ବାକି ଥିବା ଗାଜର ଯଥେଷ୍ଟ ନଥାଏ, ତେବେ ଆପଣ ବାକି ଥିବା ଗାଜର ସବୁ ଖାଇଦେବେ, କିନ୍ତୁ ତଥାପି ଆପଣଙ୍କୁ ଭୋକ ଲାଗିବ ।ଖାଦ୍ୟ ଖାଇବା ପରେ କେତେ ଗାଜର ବାକି ଅଛି ] ଆପଣ ଖାଦ୍ୟ ଖାଇବା ପରେ ଖାଇଥିବା ଗାଜରର ମୋଟ ସଂଖ୍ୟାକୁ ଫେରାଇବେ ।କିନ୍ତୁ ଏବେ ଆପଣଙ୍କୁ ଅଧିକ ଗାଜର ଖାଇବା ଆବଶ୍ୟକ, ଯାହାଦ୍ୱାରା ଆପଣ ଦିନର ଖାଦ୍ୟକୁ ସଂପୂର୍ଣ୍ଣ କରିପାରିବେ ।ତୁମେ ଭୋକିଲା ବିଲେଇ, ଏବଂ ତୁମେ ପୂର୍ବରୁ କିଛି ଗାଜର ଖାଇ ସାରିଛ,# >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1, 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number, need, remaining)\n","canonical_solution":"def eat(number, need, remaining)\n  total_eaten = number + [need, remaining].min\n  carrots_left = [remaining - need, 0].max\n  [total_eaten, carrots_left]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1, 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9, 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n  end\nend\n"},{"task_id":"HumanEval_160","nl":"ory_Orya","pl":"rb","prompt":"ଅପରେଟର ମାର୍ଜୀରେ ଅତି କମରେ ଗୋଟିଏ ଅପରେଟର ଥାଏ, ଏବଂ ଅପରେଣ୍ଡ ମାର୍ଜୀରେ ଅତି କମରେ ଦୁଇଟି ଅପରେଣ୍ଡ ଥାଏ ।ଅପରେଣ୍ଡ ହେଉଛି ଏକ ନନ୍-ନଗେଟିଭ୍ ଇଣ୍ଟେଜର ଆରେ ।ଅପରେଟର ଆରେର ଲମ୍ବ ଅପରେଣ୍ଡ ଆରେର ଲମ୍ବ ଏକରୁ କମ୍ ।ନୋଟ: => ଫଳ = 9 ଫଳ = 2 + 3 * 4 - 5 ଆରେ = [2, 3, 4, 5] ଅପରେଟର ['+', '*', '-'] ଉଦାହରଣ:ବିସ୍ତାରିତ (**) ମହଲା ବିଭାଜନ ( \/\/) ଗୁଣନ (*) କାଟିବା (- ) ଯୋଗ କରିବା (+) ମୌଳିକ ବୀଜାଣୁ କ୍ରିୟା:expression କୁ ପୁନଃସ୍ଥାପନ କରି expression ର ମୂଲ୍ୟାଙ୍କନକୁ ଫେରାଇଥାଏ.ଦ୍ବିତୀୟ ଧାଡି ହେଉଛି ସମ୍ପୂର୍ଣ୍ଣ ସଂଖ୍ୟାମାନଙ୍କର ଧାଡି ।ଦୁଇଟି ଆରେ ଅପରେଟର ଏବଂ ଅପରେଣ୍ଡ ଦିଆଗଲା। ପ୍ରଥମ ଆରେରେ ମୌଳିକ ଆଲଜେବ୍ରିକ କାର୍ଯ୍ୟ ଅଛି, ଏବଂ def do_algebra(operator, operand)\n","canonical_solution":"def do_algebra(operator, operand)\n  expression = operand[0].to_s\n  operator.each_with_index do |op, index|\n    if op == '\/\/'\n      expression += ' \/ ' + operand[index + 1].to_s\n    else\n      expression += ' ' + op + ' ' + operand[index + 1].to_s\n    end\n  end\n  eval(expression)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\", \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\", \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"\/\/\", \"*\"], [7, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_161","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ଫଳନଟି ଫଳାଫଳ ବାକ୍ୟଖଣ୍ଡକୁ ଫେରାଇବ.ଯଦି string ରେ କୌଣସି ଅକ୍ଷର ନଥାଏ, ତେବେ string କୁ ଓଲଟାଇ ଦିଅନ୍ତୁ.ନଚେତ ସେମିତି ରଖ ।ଯଦି s[i] ଏକ ଅକ୍ଷର, ତେବେ ଏହାର କେସକୁ ନିମ୍ନରୁ ଉପର କିମ୍ବା ବାମରୁ ବାମକୁ ଓଲଟାଇ ଦିଅନ୍ତୁ, ଆପଣଙ୍କୁ ଗୋଟିଏ string s ଦିଆଗଲା.# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n","canonical_solution":"def solve(s)\n  if s =~ \/[a-zA-Z]\/\n    s.chars.map { |char| char =~ \/[a-zA-Z]\/ ? char.swapcase : char }.join\n  else\n    s.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\", candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"#$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"},{"task_id":"HumanEval_162","nl":"ory_Orya","pl":"rb","prompt":"ଯଦି 'text' ଏକ ଖାଲି ଷ୍ଟ୍ରିଙ୍ଗ, ତେବେ nil ଫେରାଇଦେବେ.ଏକ ଷ୍ଟ୍ରିଙ୍ଗ 'ଟେକ୍ସଟ' ଦିଆଗଲା, ଏହାର md5 ହ୍ୟାଶ ସମକକ୍ଷ ଷ୍ଟ୍ରିଙ୍ଗ ଫେରାଇଦେବେ.# >>> string_to_md5.call(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n","canonical_solution":"require 'digest'\n\ndef string_to_md5(text)\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\", candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"))\n  end\nend\n"},{"task_id":"HumanEval_163","nl":"ory_Orya","pl":"rb","prompt":"ଉଦାହରଣ ସ୍ୱରୂପ: ଏବଂ b, କ୍ରମାନୁସାରେ ।ଦୁଇଟି ସକାରାତ୍ମକ ପୂର୍ଣ୍ଣ ସଂଖ୍ୟା a ଏବଂ b ଦିଆଗଲା, a  ମଧ୍ୟରେ ଥିବା ଯୁଗ୍ମ ଅଙ୍କକୁ ଫେରାଇବ# >>> generate_integers.call(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10, 14)\n# []\ndef generate_integers(a, b)\n","canonical_solution":"def generate_integers(a, b)\n  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2, 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2, 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n  end\nend\n"}]