[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verilmi\u015f n\u00f6mr\u0259 siyah\u0131s\u0131nda h\u0259r hans\u0131 iki n\u00f6mr\u0259nin bir-birin\u0259 veril\u0259n h\u0259dd\u0259 nisb\u0259t\u0259n daha yax\u0131n olub olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131n.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu funksiyan\u0131n giri\u015find\u0259 bir \u00e7ox qrup yuva qapa\u011f\u0131 olan bir simdir. M\u0259qs\u0259diniz bu qruplar\u0131 ayr\u0131 siml\u0259r\u0259 ay\u0131rmaq v\u0259 onlar\u0131n siyah\u0131s\u0131n\u0131 qaytarmaqd\u0131r. Ayr\u0131-ayr\u0131 qruplar balansla\u015fd\u0131r\u0131lm\u0131\u015fd\u0131r (h\u0259r bir a\u00e7\u0131q qapaq d\u00fczg\u00fcn ba\u011flanm\u0131\u015fd\u0131r) v\u0259 bir-birinin i\u00e7\u0259risind\u0259 yuvala\u015fd\u0131r\u0131lmam\u0131\u015fd\u0131r. Giri\u015f simind\u0259ki bo\u015fluqlar\u0131 n\u0259z\u0259r\u0259 almamaq. M\u0259lum:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" M\u00fcsb\u0259t bir \u00fcz\u0259n n\u00f6qt\u0259 n\u00f6mr\u0259si verildikd\u0259, tam \u0259d\u0259d hiss\u0259sin\u0259 (\u0259ld\u0259 olunan saydan ki\u00e7ik olan \u0259n b\u00f6y\u00fck tam \u0259d\u0259d) v\u0259 onluqlara (qalan hiss\u0259 h\u0259mi\u015f\u0259 1-d\u0259n ki\u00e7ikdir) par\u00e7alana bil\u0259r.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Siz\u0259 s\u0131f\u0131r balansla ba\u015flayan bank hesab\u0131nda depozit v\u0259 pul \u00e7\u0259km\u0259 \u0259m\u0259liyyatlar\u0131n\u0131n siyah\u0131s\u0131 verilir. Sizin v\u0259zif\u0259niz hesab\u0131n balans\u0131n\u0131n h\u0259r hans\u0131 bir n\u00f6qt\u0259d\u0259 s\u0131f\u0131rdan a\u015fa\u011f\u0131 d\u00fc\u015fd\u00fcy\u00fcn\u00fc a\u015fkar etm\u0259kdir v\u0259 bu n\u00f6qt\u0259d\u0259 funksiya True qaytarmal\u0131d\u0131r. \u018fks t\u0259qdird\u0259 False qaytarmal\u0131d\u0131r. M\u0259lum:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Veril\u0259n giri\u015f n\u00f6mr\u0259l\u0259ri siyah\u0131s\u0131 \u00fc\u00e7\u00fcn, bu m\u0259lumat d\u0259stinin ortalamas\u0131 \u0259traf\u0131nda Orta M\u00fctl\u0259q \u00c7\u00f6km\u0259ni hesablay\u0131n. Orta M\u00fctl\u0259q \u00c7\u00f6km\u0259 h\u0259r element v\u0259 bir m\u0259rk\u0259z n\u00f6qt\u0259si aras\u0131ndak\u0131 orta m\u00fctl\u0259q f\u0259rqdir (bu v\u0259ziyy\u0259td\u0259 orta): MAD = ortalama. x - x_mean. Misal:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Giri\u015f siyah\u0131s\u0131n\u0131n h\u0259r iki ard\u0131c\u0131l elementi aras\u0131nda bir \"delimiter\" n\u00f6mr\u0259si daxil edin `n\u00f6mr\u0259l\u0259r\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Bu funksiyan\u0131n giri\u015find\u0259 bo\u015fluqlarla ayr\u0131lm\u0131\u015f yuva qapa\u011f\u0131 \u00fc\u00e7\u00fcn \u00e7oxsayl\u0131 qruplar\u0131 t\u0259msil ed\u0259n bir simdir. H\u0259r bir qrup \u00fc\u00e7\u00fcn qapa\u011f\u0131n yuvalar\u0131n\u0131n \u0259n d\u0259rin s\u0259viyy\u0259sini \u00e7\u0131xart\u0131n. M\u0259s\u0259l\u0259n (() (()) yuvalar\u0131n maksimum iki s\u0259viyy\u0259si var, ((())) is\u0259 \u00fc\u00e7d\u00fcr.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Yaln\u0131z veril\u0259n alt simli olan simli giri\u015f siyah\u0131s\u0131n\u0131 s\u00fczm\u0259k\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Verilmi\u015f tamsay\u0131lar siyah\u0131s\u0131 \u00fc\u00e7\u00fcn, bir siyah\u0131dak\u0131 b\u00fct\u00fcn tamsay\u0131lar\u0131n c\u0259mi v\u0259 bir m\u0259hsulundan ibar\u0259t bir tuple qaytar\u0131n. Bo\u015f c\u0259mi 0-a b\u0259rab\u0259r olmal\u0131d\u0131r v\u0259 bo\u015f m\u0259hsul 1 -\u0259 b\u0259rab\u0259r olmal\u0131d\u0131r.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Verilmi\u015f tamsayl\u0131 siyah\u0131dan, ard\u0131c\u0131ll\u0131qdak\u0131 m\u00fc\u0259yy\u0259n bir anad\u0259k tap\u0131lan yuvarlanan maksimum elementl\u0259rin siyah\u0131s\u0131n\u0131 yarad\u0131n.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Verilmi\u015f simli palindrom olub olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131n \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Giri\u015f yaln\u0131z 1 v\u0259 0-dan ibar\u0259t olan a v\u0259 b iki simlidir. Bu giri\u015fl\u0259rd\u0259 ikili XOR yerin\u0259 yetirin v\u0259 n\u0259tic\u0259ni d\u0259 bir simli olaraq qaytar\u0131n.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Siyah\u0131dak\u0131 siml\u0259rd\u0259n \u0259n uzununu qaytar\u0131n. Eyni uzunluqda bir ne\u00e7\u0259 sim varsa, birinci simini qaytar\u0131n. Giri\u015f siyah\u0131s\u0131 bo\u015fdursa, he\u00e7 birini qaytar\u0131n.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \u0130ki tam \u0259d\u0259din a v\u0259 b \u0259n b\u00f6y\u00fck ortaq b\u00f6lm\u0259sini qaytar\u0131n\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Giri\u015f simli \u0259n q\u0131sa il\u0259 \u0259n uzununa q\u0259d\u0259r b\u00fct\u00fcn prefiksl\u0259rin siyah\u0131s\u0131n\u0131 qaytar\u0131r\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" 0-dan n-a q\u0259d\u0259r olan bo\u015fluqla m\u0259hdudla\u015fd\u0131r\u0131lm\u0131\u015f n\u00f6mr\u0259l\u0259rd\u0259n ibar\u0259t bir simli qaytar\u0131r.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Bir simli verildikd\u0259, ne\u00e7\u0259 f\u0259rqli simli (kif\u0259sind\u0259n as\u0131l\u0131 olmayaraq) tap\u0131n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Bu funksiyan\u0131n giri\u015f x\u00fcsusi ASCII format\u0131nda musiqi notlar\u0131 t\u0259msil bir simlidir. Sizin v\u0259zif\u0259si bu simli t\u0259hlil v\u0259 h\u0259r ne\u00e7\u0259 z\u0259rb\u0259 davam etm\u0259y\u0259n m\u00fcvafiq tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131 qaytarmaqd\u0131r. Burada bir \u0259fsan\u0259 var: 'o' - b\u00fct\u00fcn qeyd, d\u00f6rd z\u0259rb\u0259 davam 'o\" - yar\u0131m qeyd, iki z\u0259rb\u0259 davam '. \" \" - Quater qeyd, bir z\u0259rb\u0259 davam\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" M\u00fc\u0259yy\u0259n bir alt simli orijinal simli ne\u00e7\u0259 d\u0259f\u0259 tapa bil\u0259c\u0259yini tap\u0131n. \u00dcst-\u00fcst\u0259 d\u00fc\u015f\u0259n hallar\u0131 say\u0131n.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Giri\u015f's\u0131f\u0131rdan' 'doqquza' q\u0259d\u0259r olan r\u0259q\u0259ml\u0259rin bo\u015fluqla m\u0259hdudla\u015fd\u0131r\u0131lm\u0131\u015f bir s\u0259tiridir. M\u00fcvafiq se\u00e7iml\u0259r's\u0131f\u0131r', 'bir', 'iki', '\u00fc\u00e7', 'd\u00f6rd', 'be\u015f', 'alt\u0131', 'yeddi','s\u0259kkiz' v\u0259 'doqquzdur'. \u018fn ki\u00e7ikd\u0259n \u0259n b\u00f6y\u00fck\u0259 q\u0259d\u0259r s\u0131ralanm\u0131\u015f n\u00f6mr\u0259l\u0259rl\u0259 s\u0259tir qaytar\u0131n\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" T\u0259qdim olunan n\u00f6mr\u0259l\u0259r siyah\u0131s\u0131ndan (\u0259n az\u0131 iki uzunlu\u011funda) bir-birin\u0259 \u0259n yax\u0131n olan iki n\u00f6mr\u0259ni se\u00e7in v\u0259 qaytar\u0131n v\u0259 onlar\u0131 s\u0131rayla qaytar\u0131n (daha ki\u00e7ik say\u0131, daha b\u00f6y\u00fck say\u0131).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" N\u00f6mr\u0259l\u0259r siyah\u0131s\u0131 verilmi\u015fdir (\u0259n az\u0131 iki elementd\u0259n), \u0259n ki\u00e7ik n\u00f6mr\u0259 0, \u0259n b\u00f6y\u00fck n\u00f6mr\u0259 is\u0259 1 olacaq \u015f\u0259kild\u0259 bu siyah\u0131ya x\u0259tti transformasiya t\u0259tbiq edin\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Python d\u0259y\u0259rl\u0259rinin veril\u0259n siyah\u0131s\u0131n\u0131 yaln\u0131z tam \u0259d\u0259dl\u0259r \u00fc\u00e7\u00fcn s\u00fcz\u00fcn\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Verilmi\u015f simli geri qaytarma uzunlu\u011fu\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Verilmi\u015f n n say\u0131nda n-d\u0259n ki\u00e7ik olan n-i b\u0259rab\u0259r b\u00f6l\u0259n \u0259n b\u00f6y\u00fck n\u00f6mr\u0259ni tap\u0131n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Verilmi\u015f tamsay\u0131n\u0131n ilkin faktorlar\u0131n\u0131n siyah\u0131s\u0131n\u0131 \u0259n ki\u00e7ikd\u0259n \u0259n b\u00f6y\u00fck\u0259 q\u0259d\u0259r s\u0131rayla qaytar\u0131n. H\u0259r bir faktorun faktorla\u015fd\u0131rmada ne\u00e7\u0259 d\u0259f\u0259 g\u00f6r\u00fcnd\u00fcy\u00fcn\u0259 uy\u011fun bir sayda sayda sayda qeyd edilm\u0259lidir. Giri\u015f say\u0131 b\u00fct\u00fcn faktorlar\u0131n m\u0259hsuluna b\u0259rab\u0259r olmal\u0131d\u0131r\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131ndan bird\u0259n \u00e7ox d\u0259f\u0259 meydana g\u0259l\u0259n b\u00fct\u00fcn elementl\u0259ri \u00e7\u0131xar\u0131n. Elementl\u0259rin s\u0131ras\u0131n\u0131 giri\u015fd\u0259ki kimi saxlay\u0131n.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Verilmi\u015f bir simli \u00fc\u00e7\u00fcn ki\u00e7ik h\u0259rfl\u0259ri b\u00f6y\u00fck h\u0259rfl\u0259r\u0259 v\u0259 b\u00f6y\u00fck h\u0259rfl\u0259ri ki\u00e7ik h\u0259rfl\u0259r\u0259 \u00e7evirin.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Silinmi\u015f siml\u0259ri bir silin\u0259 birl\u0259\u015fdirm\u0259k\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Yaln\u0131z veril\u0259n prefiksl\u0259 ba\u015flayanlar \u00fc\u00e7\u00fcn giri\u015f simli siyah\u0131s\u0131n\u0131 filtrl\u0259yin.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Yaln\u0131z siyah\u0131dak\u0131 m\u00fcsb\u0259t \u0259d\u0259dl\u0259ri qaytar\u0131n.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Verilmi\u015f bir n\u00f6mr\u0259 birincidirs\u0259, do\u011fru, \u0259ks halda is\u0259 yalan qaytar\u0131r.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    X n\u00f6qt\u0259sind\u0259 xs \u0259msallar\u0131 olan \u00e7oxh\u00fcceyr\u0259ni qiym\u0259tl\u0259ndirir. xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n qaytar\u0131r\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Bu funksiya l siyah\u0131s\u0131n\u0131 al\u0131r v\u0259 l' il\u0259 \u00fc\u00e7l\u0259 b\u00f6l\u00fcnm\u0259y\u0259n indeksl\u0259rd\u0259 l' il\u0259 eyni oldu\u011fu, \u00fc\u00e7l\u0259 b\u00f6l\u00fcn\u0259n indeksl\u0259rd\u0259ki d\u0259y\u0259rl\u0259ri l-in m\u00fcvafiq indeksl\u0259rinin d\u0259y\u0259rl\u0259rin\u0259 b\u0259rab\u0259r oldu\u011fu, lakin s\u0131ralanm\u0131\u015f bir l' siyah\u0131s\u0131n\u0131 qaytar\u0131r.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Sifari\u015f edilmi\u015f unikal elementl\u0259ri siyah\u0131da qaytar\u0131r\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Siyah\u0131dak\u0131 \u0259n \u00e7ox elementi qaytar\u0131r.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Say\u0131 n-d\u0259n az olan tam \u0259d\u0259dl\u0259rd\u0259 7 r\u0259q\u0259minin 11 v\u0259 ya 13-\u0259 b\u00f6l\u00fcnm\u0259sinin say\u0131n\u0131 qaytar\u0131n.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Bu funksiya bir siyah\u0131 al\u0131r l v\u0259 bir siyah\u0131 qaytar\u0131r l'bel\u0259 ki, l' c\u00fct indeksl\u0259rd\u0259 l il\u0259 eynidir, c\u00fct indeksl\u0259rd\u0259ki d\u0259y\u0259rl\u0259ri is\u0259 l-in c\u00fct indeksl\u0259rinin d\u0259y\u0259rl\u0259rin\u0259 b\u0259rab\u0259rdir, lakin s\u0131ralanm\u0131\u015fd\u0131r.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    \u00dc\u00e7 simvoldan ibar\u0259t d\u00f6vr\u0259 qruplar\u0131 il\u0259 kodla\u015fd\u0131r\u0131lm\u0131\u015f simli qaytar\u0131r.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib n-ci r\u0259q\u0259mi qaytar\u0131r ki, bu da bir Fibona\u00e7\u00e7i n\u00f6mr\u0259sidir v\u0259 eyni zamanda birincidir.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131n\u0131 giri\u015f kimi q\u0259bul edir. siyah\u0131da s\u0131f\u0131ra b\u0259rab\u0259r olan \u00fc\u00e7 f\u0259rqli element varsa True, \u0259ks halda False qaytar\u0131r.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Tam d\u00fcz, sonsuz uzun bir x\u0259tt olan bir yol t\u0259s\u0259vv\u00fcr edin. n avtomobil sola sola h\u0259r\u0259k\u0259t edir; eyni zamanda, n f\u0259rqli avtomobilin bir d\u0259sti sa\u011fa sola h\u0259r\u0259k\u0259t edir. \u0130ki avtomobil d\u0259sti bir-birind\u0259n \u00e7ox uzaqdan ba\u015flay\u0131r. B\u00fct\u00fcn avtomobill\u0259r eyni s\u00fcr\u0259tl\u0259 h\u0259r\u0259k\u0259t edir. Soldan sa\u011fa h\u0259r\u0259k\u0259t ed\u0259n bir avtomobil sa\u011fdan sola h\u0259r\u0259k\u0259t ed\u0259n bir avtomobil\u0259 \u00e7\u0131rp\u0131ld\u0131qda iki avtomobilin toqqu\u015fdu\u011funu s\u00f6yl\u0259yirl\u0259r. Bununla birlikd\u0259, avtomobill\u0259r sonsuz d\u0259r\u0259c\u0259d\u0259 m\u00f6hk\u0259m v\u0259 g\u00fccl\u00fcd\u00fcr; n\u0259tic\u0259d\u0259, toqqu\u015fmad\u0131qlar\u0131 kimi \u00f6z trajektorisind\u0259 h\u0259r\u0259k\u0259t etm\u0259y\u0259 davam edirl\u0259r. Bu funksiya bu c\u00fcr toqqu\u015fmalar\u0131n say\u0131n\u0131 \u00e7\u0131xard\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"1 art\u0131ml\u0131 elementl\u0259rl\u0259 geri qay\u0131d\u0131\u015f siyah\u0131s\u0131.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131n\u0131 giri\u015f kimi q\u0259bul edir. \u018fg\u0259r siyah\u0131da s\u0131f\u0131ra b\u0259rab\u0259r olan iki f\u0259rqli element varsa True, \u0259ks halda False verir.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Giri\u015f n\u00f6mr\u0259si x-in r\u0259q\u0259m bazas\u0131n\u0131 bazaya d\u0259yi\u015fdirin. d\u00f6n\u00fc\u015f\u00fcmd\u0259n sonra simli simli t\u0259msil\u00e7iliyi qaytar\u0131n. baza n\u00f6mr\u0259l\u0259ri 10-dan azd\u0131r.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"\u00dc\u00e7bucaq \u00fc\u00e7\u00fcn bir t\u0259r\u0259fin uzunlu\u011fu v\u0259 y\u00fcks\u0259k geri d\u00f6n\u00fc\u015f sah\u0259si verilmi\u015fdir.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 say s\u0131ralar\u0131 Fibbonacci ard\u0131c\u0131ll\u0131\u011f\u0131na b\u0259nz\u0259r ard\u0131c\u0131ll\u0131qd\u0131r ki, a\u015fa\u011f\u0131dak\u0131 kimi m\u00fc\u0259yy\u0259n edilir: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Z\u0259hm\u0259t olmasa fib4 say s\u0131ralar\u0131n\u0131n n-ci elementini s\u0259m\u0259r\u0259li hesablamaq \u00fc\u00e7\u00fcn bir funksiya yaz\u0131n. Rekursiyan\u0131 istifad\u0259 etm\u0259yin.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"l siyah\u0131s\u0131ndak\u0131 elementl\u0259rin geri qaytarma medianas\u0131.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Verilmi\u015f simli palindrom olub olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131r\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"2 ^ n modulo p qaytar\u0131n (n\u00f6mr\u0259l\u0259ri unutmay\u0131n).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    h\u0259r bir simvolu 5 il\u0259 d\u0259yi\u015fdir\u0259r\u0259k kodla\u015fd\u0131r\u0131lm\u0131\u015f simli qaytar\u0131r.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels, s\u0259tir g\u00f6t\u00fcr\u0259n v\u0259 s\u0259tirsiz s\u0259tir qaytaran bir funksiyad\u0131r.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"\u018fg\u0259r siyah\u0131dak\u0131 b\u00fct\u00fcn n\u00f6mr\u0259l\u0259r h\u0259dd\u0259n a\u015fa\u011f\u0131d\u0131rsa, True qaytar\u0131n.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u0130ki n\u00f6mr\u0259 x v\u0259 y \u0259lav\u0259 edin\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u0130ki s\u00f6z\u00fcn eyni simvollar\u0131 olub olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131n.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"n-ci Fibona\u00e7\u00e7i n\u00f6mr\u0259sini qaytar\u0131n.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \"<\" v\u0259 \">\" simlidir. H\u0259r a\u00e7\u0131l\u0131\u015f qapa\u011f\u0131nda m\u00fcvafiq bir ba\u011flama qapa\u011f\u0131 varsa True qaytar\u0131n.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True siyah\u0131 elementl\u0259rinin monoton \u015f\u0259kild\u0259 artmas\u0131 v\u0259 ya azalmas\u0131d\u0131r.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u0130ki siyah\u0131 \u00fc\u00e7\u00fcn s\u0131ralanm\u0131\u015f unikal ortaq elementl\u0259ri qaytar\u0131r.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"\u018fn b\u00f6y\u00fck n \u0259d\u0259dinin ilkin faktorunu qaytar\u0131n.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 1 - n aras\u0131 n\u00f6mr\u0259l\u0259rin c\u0259min\u0259 cavab ver\u0259n funksiyad\u0131r.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets \"(\" v\u0259 \"\") simli bir simdir. H\u0259r a\u00e7\u0131l\u0131\u015f qapa\u011f\u0131n\u0131n m\u00fcvafiq bir ba\u011flama qapa\u011f\u0131 varsa True qaytar\u0131n.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs bir \u00e7oxl\u00fcy\u00fcn \u0259msallar\u0131n\u0131 t\u0259msil edir. xs[0] + xs[1] * x + xs[2] * x^2 +.... Bu \u00e7oxl\u00fcy\u00fcn t\u00f6r\u0259m\u0259sini eyni formada qaytar\u0131n.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"FibFib n\u00f6mr\u0259 ard\u0131c\u0131ll\u0131\u011f\u0131 Fibbonacci ard\u0131c\u0131ll\u0131\u011f\u0131na b\u0259nz\u0259r bir ard\u0131c\u0131ll\u0131qd\u0131r ki, a\u015fa\u011f\u0131dak\u0131 kimi m\u00fc\u0259yy\u0259n edilir: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fib ((n-1) + fibfib ((n-2) + fibfib ((n-3).\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nDaha \u00e7ox test hadis\u0259si \u0259lav\u0259 edin.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Dair\u0259 x tamsay\u0131n\u0131n r\u0259q\u0259ml\u0259rini d\u0259yi\u015fdirir, r\u0259q\u0259ml\u0259ri d\u0259yi\u015fdir\u0259r\u0259k sa\u011fa do\u011fru d\u0259yi\u015fdirir v\u0259 n\u0259tic\u0259ni bir simli olaraq qaytar\u0131r. \u018fg\u0259r d\u0259yi\u015fiklik > r\u0259q\u0259ml\u0259rin say\u0131, r\u0259q\u0259ml\u0259ri geri qaytar\u0131n.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Tap\u015f\u0131r\u0131q Bir simli giri\u015f kimi q\u0259bul ed\u0259n v\u0259 yaln\u0131z yuxar\u0131 siml\u0259rin c\u0259mi ASCII kodlar\u0131n\u0131 qaytaran bir funksiya yaz\u0131n. N\u00fcmun\u0259l\u0259r: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Bu tap\u015f\u0131r\u0131qda siz\u0259 bir s\u0259b\u0259td\u0259 paylanan alma v\u0259 porta\u011fallar\u0131n say\u0131n\u0131 t\u0259msil ed\u0259n bir simli veril\u0259c\u0259k. Bu s\u0259b\u0259td\u0259 alma, porta\u011fal v\u0259 manqo meyv\u0259l\u0259ri var. S\u0259b\u0259td\u0259ki meyv\u0259l\u0259rin \u00fcmumi say\u0131n\u0131 t\u0259msil ed\u0259n simli v\u0259 s\u0259b\u0259td\u0259ki meyv\u0259l\u0259rin \u00fcmumi say\u0131n\u0131 t\u0259msil ed\u0259n tam \u0259d\u0259di verildikd\u0259, s\u0259b\u0259td\u0259ki manqo meyv\u0259l\u0259rinin say\u0131n\u0131 qaytar\u0131n. m\u0259s\u0259l\u0259n: fruit_distribution \"5 ((alma v\u0259 6 porta\u011fal\", 19) -> 19 - 5 - 6 = 8 fruit_distribution \"0 alma v\u0259 1 porta\u011fal\", 3) -> 3 - 0 - 1 = 2 fruit_distribution \"2 alma v\u0259 3 porta\u011fal\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\" 100 alma v\u0259 120) \", 1 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Negativ olmayan tamsayl\u0131 d\u00fcy\u00fcnl\u0259ri olan bir a\u011fac\u0131n bir filial\u0131n\u0131 t\u0259msil ed\u0259n bir s\u0131ra verildiyi t\u0259qdird\u0259, v\u0259zif\u0259niz d\u00fcy\u00fcnl\u0259rd\u0259n birini se\u00e7ib qaytarmaqd\u0131r. Se\u00e7ilmi\u015f qov\u015faq \u0259n ki\u00e7ik c\u00fct d\u0259y\u0259ri olan qov\u015faq olmal\u0131d\u0131r. Bird\u0259n \u00e7ox \u0259n ki\u00e7ik c\u00fct d\u0259y\u0259ri olan qov\u015faq tap\u0131lsa, \u0259n ki\u00e7ik indeksi olan qov\u015faq qaytar\u0131n. Se\u00e7ilmi\u015f qov\u015faq bir siyah\u0131da qaytar\u0131lmal\u0131d\u0131r, [small_value, onun indeksi ], C\u00fct d\u0259y\u0259ri yoxdursa v\u0259 ya veril\u0259n s\u0131ra bo\u015fdursa, qaytar\u0131n [].M\u0259s\u0259l\u0259n: 1: Giri\u015f: [4,2,3] \u00c7\u0131x\u0131\u015f: [2, 1] A\u00e7\u0131qlama: 2 \u0259n ki\u00e7ik c\u00fct d\u0259y\u0259ri var v\u0259 2 \u0259n ki\u00e7ik indeksi var. M\u0259s\u0259l\u0259n: Giri\u015f: [1,2,3] \u00c7\u0131x\u0131\u015f: [2, 1]\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Bir s\u0131ra b\u00fct\u00fcn \u0259d\u0259dl\u0259r verilmi\u015fdirs\u0259, s\u0131ra palindromik olmaq \u00fc\u00e7\u00fcn d\u0259yi\u015fdirilm\u0259li olan minimum element say\u0131n\u0131 tap\u0131n. Palindromik s\u0131ra, geri v\u0259 ir\u0259li eyni oxunan bir s\u0131rad\u0131r. Bir d\u0259yi\u015fiklikd\u0259 bir elementi h\u0259r hans\u0131 bir dig\u0259r element\u0259 d\u0259yi\u015fdir\u0259 bil\u0259rsiniz. M\u0259s\u0259l\u0259n: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Verilmi\u015f \u0259d\u0259d 3 \u0259d\u0259d \u0259d\u0259din \u00e7arpan\u0131 v\u0259 ba\u015fqa halda yalan olan do\u011fru qaytaracaq bir funksiya yaz\u0131n. (a) 100 -d\u0259n az oldu\u011funu bilm\u0259k.M\u0259s\u0259l\u0259n: is_multiply_prime ((30) == True 30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"X, n-in sad\u0259 bir q\u00fcvv\u0259si olduqda sad\u0259 bir q\u00fcvv\u0259dir. x, n-in sad\u0259 bir q\u00fcvv\u0259sidir. M\u0259s\u0259l\u0259n: is_simple_power (n_1, 4) => true is_simple_power (n_2, 2) => true is_simple_power (n_8, 2) => true is_simple_power (n_3, 2) => false is_simple_power (n_3, 1) => false is_simple_power (n_5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Sizd\u0259n onalt\u0131 \u0259d\u0259dli \u0259d\u0259di simvol kimi q\u0259bul ed\u0259n v\u0259 onalt\u0131 \u0259d\u0259dli r\u0259q\u0259ml\u0259rin say\u0131n\u0131 hesablayan bir funksiya yazmaq tap\u015f\u0131r\u0131l\u0131b. Onalt\u0131 \u0259d\u0259dli r\u0259q\u0259ml\u0259r 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Onalt\u0131 \u0259d\u0259dli r\u0259q\u0259ml\u0259r 2, 3, 5, 7, 11, 13, 17,... Bel\u0259likl\u0259, a\u015fa\u011f\u0131dak\u0131 r\u0259q\u0259ml\u0259rin say\u0131n\u0131 t\u0259yin etm\u0259lisiniz: 2, 3, 5, 7, B (= onalt\u0131 \u0259d\u0259dli 11), D (= onalt\u0131 \u0259d\u0259dli 13) Qeyd: giri\u015f h\u0259mi\u015f\u0259 d\u00fczg\u00fcn v\u0259 ya bo\u015f oldu\u011funu v\u0259 A,B,C,D,E,F simvollar\u0131n\u0131n h\u0259mi\u015f\u0259 b\u00f6y\u00fck h\u0259rfl\u0259rl\u0259 oldu\u011funu d\u00fc\u015f\u00fcn\u0259 bil\u0259rsiniz. Misallar: \"AB\" \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f n\u00f6mr\u0259si 1. olmal\u0131d\u0131r \"AB\" \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f n\u00f6mr\u0259si 1. olmal\u0131d\u0131r \"1077E\"\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Siz onluq \u015f\u0259klind\u0259 bir r\u0259q\u0259m veril\u0259c\u0259k v\u0259 sizin v\u0259zif\u0259si ikili formatda \u00e7evirm\u0259kdir. funksiya bir simli qaytarmal\u0131d\u0131r, h\u0259r simli ikili r\u0259q\u0259m t\u0259msil edir. simli h\u0259r simli '0' v\u0259 ya '1' olacaq. simli ba\u015flan\u011f\u0131c\u0131nda v\u0259 sonunda \u0259lav\u0259 bir ne\u00e7\u0259 simli 'db' olacaq. \u0259lav\u0259 simvollar formatda k\u00f6m\u0259k etm\u0259k \u00fc\u00e7\u00fcn var. Misallar: onluq_ikili_\u0259_(15) # \"db1111db\" onluq_ikili_\u0259_binary32) # \"db100000db\" qaytar\u0131r\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Siz\u0259 bir simli verilir. Sizin v\u0259zif\u0259niz simlin xo\u015fb\u0259xt olub olmad\u0131\u011f\u0131n\u0131 yoxlamaqd\u0131r. Bir simli xo\u015fb\u0259xtdirs\u0259, onun uzunlu\u011fu \u0259n az\u0131 3 v\u0259 h\u0259r 3 ard\u0131c\u0131l h\u0259rf f\u0259rqlidir. M\u0259s\u0259l\u0259n: is_happy (a) => False is_happy (a) => False is_happy (b) => True is_happy (a) => False is_happy (b) => False is_happy (c) => False is_happy (d) => False is_happy (e) => False is_happy (f) => False is_happy (x) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Bu semestr son h\u0259ft\u0259sidir v\u0259 m\u00fc\u0259llim \u015fagirdl\u0259r\u0259 qiym\u0259tl\u0259r verm\u0259lidir. M\u00fc\u0259llim qiym\u0259tl\u0259ndirm\u0259 \u00fc\u00e7\u00fcn \u00f6z alqoritmini haz\u0131rlay\u0131r. Yegan\u0259 problem, qiym\u0259tl\u0259ndirm\u0259 \u00fc\u00e7\u00fcn istifad\u0259 etdiyi kodu itirm\u0259sidir. O, siz\u0259 b\u0259zi \u015fagirdl\u0259r \u00fc\u00e7\u00fcn GPA siyah\u0131s\u0131n\u0131 vermi\u015fdir v\u0259 a\u015fa\u011f\u0131dak\u0131 c\u0259dv\u0259ld\u0259n istifad\u0259 ed\u0259r\u0259k h\u0259rf qiym\u0259tl\u0259rinin siyah\u0131s\u0131n\u0131 \u00e7\u0131xara bil\u0259n bir funksiya yazmal\u0131s\u0131n\u0131z: GPA. Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Bir simli g\u00f6t\u00fcr\u0259n v\u0259 simli uzunlu\u011fu bir \u0259d\u0259d olsa True v\u0259 ya False qaytaran bir funksiya yaz\u0131n. Misal prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Bir m\u00fcsb\u0259t tam n verilmi\u015f, 1 il\u0259 ba\u015flayan v\u0259 ya bit\u0259n n r\u0259q\u0259mli m\u00fcsb\u0259t tam saylar\u0131n\u0131n say\u0131n\u0131 qaytar\u0131n.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"m\u00fcsb\u0259t tam n\u00f6mr\u0259 verilmi\u015fs\u0259, ikili n\u00f6mr\u0259l\u0259rin \u00fcmumi c\u0259mi qaytar\u0131n. N = 1000 \u00fc\u00e7\u00fcn n\u00f6mr\u0259l\u0259rin c\u0259mi 1 olacaq, \u00e7\u0131x\u0131\u015f\u0131 \"1\" olmal\u0131d\u0131r. N = 150 \u00fc\u00e7\u00fcn n\u00f6mr\u0259l\u0259rin c\u0259mi 6 olacaq, \u00e7\u0131x\u0131\u015f\u0131 \"110\" olmal\u0131d\u0131r. N = 147 \u00fc\u00e7\u00fcn n\u00f6mr\u0259l\u0259rin c\u0259mi 12 olacaq, \u00e7\u0131x\u0131\u015f\u0131 \"1100\" olmal\u0131d\u0131r. D\u0259yi\u015f\u0259nl\u0259r: @N tam n\u00f6mr\u0259 m\u0259hdudiyy\u0259tl\u0259ri: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. \u00c7\u0131x\u0131\u015f: ikili say\u0131n bir s\u0259tir\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Bo\u015f olmayan tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131 verildikd\u0259 lst. c\u00fct elementl\u0259ri c\u00fct indeksl\u0259rd\u0259 \u0259lav\u0259 edin..M\u0259s\u0259l\u0259n: \u0259lav\u0259 edin (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Bir simli g\u00f6t\u00fcr\u0259n v\u0259 onun nizaml\u0131 versiyas\u0131n\u0131 qaytaran bir funksiya yaz\u0131n. Simlin nizaml\u0131 versiyas\u0131, b\u00fct\u00fcn s\u00f6zl\u0259rin (bo\u015fluqla ayr\u0131lm\u0131\u015f) ascii d\u0259y\u0259rin\u0259 \u0259sas\u0259n y\u00fcks\u0259l\u0259n s\u0131rada yerl\u0259\u015fdirilmi\u015f b\u00fct\u00fcn siml\u0259rin yerl\u0259\u015fdirildiyi yeni bir s\u00f6zl\u0259 \u0259v\u0259z olunan bir simlidir. Qeyd: S\u00f6zl\u0259rin v\u0259 bo\u015fluqlar\u0131n s\u0131ras\u0131n\u0131 c\u00fcml\u0259d\u0259 saxlamal\u0131s\u0131n\u0131z. M\u0259s\u0259l\u0259n: anti_shuffle ((('Hi') 'Hi' anti_shuffle (('hello') qaytar\u0131r 'ehllo' anti_shuffle (('Hello World!!!') qaytar\u0131r 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Siz\u0259 matris\u0259 b\u0259nz\u0259r, lakin matrisl\u0259rd\u0259n f\u0259rqli olaraq, h\u0259r sat\u0131rda f\u0259rqli sayda s\u00fctun ola bil\u0259c\u0259k bir yuvalanm\u0131\u015f siyah\u0131 kimi 2 \u00f6l\u00e7\u00fcl\u00fc bir m\u0259lumat verilir. lst v\u0259 tam \u0259d\u0259d x verildikd\u0259, siyah\u0131da tam \u0259d\u0259dl\u0259r x tap\u0131n v\u0259 tuples siyah\u0131s\u0131n\u0131 qaytar\u0131n, [(x1, y1), (x2, y2)...] bel\u0259 ki, h\u0259r tuple bir koordinatd\u0131r - (sat\u0131r, s\u00fctunlar), 0 il\u0259 ba\u015flayaraq. Koordinatlar\u0131 \u0259vv\u0259lc\u0259 s\u0131ralar \u00fczr\u0259 y\u00fcks\u0259l\u0259n s\u0131rada s\u0131ralay\u0131n. H\u0259m\u00e7inin, s\u0131ra koordinatlar\u0131n\u0131 s\u00fctunlar \u00fczr\u0259 en\u0259n s\u0131rada s\u0131ralay\u0131n. N\u00fcmun\u0259l\u0259r: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0, 0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(],\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Qeyri-m\u0259nfi \u0259d\u0259dl\u0259r dizini verildikd\u0259, s\u0131ralama i\u015find\u0259n sonra veril\u0259n dizinin bir n\u00fcsx\u0259sini qaytar\u0131n, \u0259g\u0259r c\u0259mi ((birinci indeks d\u0259y\u0259ri, son indeks d\u0259y\u0259ri) c\u00fcts\u0259, veril\u0259n dizini y\u00fcks\u0259l\u0259n s\u0131rada s\u0131ralayacaqs\u0131n\u0131z v\u0259 ya \u0259g\u0259r c\u0259mi ((birinci indeks d\u0259y\u0259ri, son indeks d\u0259y\u0259ri) c\u00fcts\u0259, onu a\u015fa\u011f\u0131 s\u0131rada s\u0131ralayacaqs\u0131n\u0131z. Qeyd: * veril\u0259n dizini d\u0259yi\u015fdirm\u0259yin. N\u00fcmun\u0259l\u0259r: * sort_array[(]) => [] * sort_array[]] => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Bir simli bir arqument olaraq g\u00f6t\u00fcr\u0259n v\u0259 \u0259lifban\u0131n d\u00f6nd\u00fcr\u00fclm\u0259si il\u0259 \u015fifr\u0259l\u0259nmi\u015f bir simli geri qaytaran bir funksiyan\u0131 \u015fifr\u0259l\u0259yin. \u018flifba h\u0259rfl\u0259rin iki yer\u0259 iki d\u0259f\u0259 a\u015fa\u011f\u0131 do\u011fru h\u0259r\u0259k\u0259t etm\u0259si \u00fc\u00e7\u00fcn bel\u0259 bir \u015f\u0259kild\u0259 d\u00f6nd\u00fcr\u00fclm\u0259lidir. M\u0259s\u0259l\u0259n: encrypt (('hi') 'lm' encrypt (('asdfghjkl') 'ewhjklnop' encrypt (('gf') 'kj' encrypt (('et') 'ix' qaytar\u0131r\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Siz\u0259 tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131 verilir. siyah\u0131n\u0131n 2-ci \u0259n ki\u00e7ik elementini qaytaran next_smallest () funksiyas\u0131 yaz\u0131n. Bel\u0259 bir element yoxdursa, None qaytar\u0131n. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == None next_smallest () [1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Siz\u0259 bir s\u00f6zl\u0259r dizisi veril\u0259c\u0259k v\u0259 sizin v\u0259zif\u0259niz dar\u0131xmalar\u0131n say\u0131n\u0131 saymaqd\u0131r. Dar\u0131xma \"I\" s\u00f6z\u00fc il\u0259 ba\u015flayan bir c\u00fcml\u0259dir. C\u00fcml\u0259l\u0259r '.', '?' v\u0259 ya '!'il\u0259 m\u0259hdudla\u015fd\u0131r\u0131l\u0131r. M\u0259s\u0259l\u0259n:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Bir mesaj alan v\u0259 b\u00fct\u00fcn h\u0259rfl\u0259rin h\u0259rfi d\u0259yi\u015fdirdiyi, mesajdak\u0131 b\u00fct\u00fcn vokallar\u0131 ingilis \u0259lifbas\u0131nda bu vokal\u0131n 2 yeri \u00f6n\u00fcnd\u0259 g\u00f6r\u00fcn\u0259n h\u0259rfl\u0259 \u0259v\u0259z ed\u0259n bir funksiya yaz\u0131n. Yaln\u0131z h\u0259rfl\u0259r q\u0259bul edin. N\u00fcmun\u0259l\u0259r:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Siz\u0259 tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131 verilir. \u018fn b\u00f6y\u00fck birinci d\u0259y\u0259rini tapmal\u0131 v\u0259 r\u0259q\u0259ml\u0259rinin c\u0259minin c\u0259minin qaytar\u0131lmas\u0131n\u0131 t\u0259l\u0259b edirsiniz. M\u0259lum oldu\u011fu kimi: lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 10 olmal\u0131d\u0131r lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 25 olmal\u0131d\u0131r lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 13 olmal\u0131d\u0131r lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 11 olmal\u0131d\u0131r lst = [0,81,12,3,21,1] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 3 olmal\u0131d\u0131r lst = [0,8,1,2,1,7] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Bir l\u00fc\u011f\u0259t verilmi\u015fs\u0259, b\u00fct\u00fcn d\u00fcym\u0259l\u0259r ki\u00e7ik h\u0259rfl\u0259rl\u0259 v\u0259 ya b\u00fct\u00fcn d\u00fcym\u0259l\u0259r b\u00f6y\u00fck h\u0259rfl\u0259rl\u0259 silsil\u0259l\u0259rdirs\u0259 True qaytar\u0131n, \u0259ks halda False qaytar\u0131n. Funksiya False qaytarmal\u0131d\u0131r. Veril\u0259n l\u00fc\u011f\u0259t bo\u015fdur. N\u00fcmun\u0259l\u0259r: check_dict_case ((({\"a\":\"apple\", \"b\":\"banana\"}) True qaytarmal\u0131d\u0131r. check_dict_case ((({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) False qaytarmal\u0131d\u0131r. check_dict_case ((({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) False qaytarmal\u0131d\u0131r. check_dict_case ((({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"M\u0259nfi olmayan tam \u0259d\u0259d g\u00f6t\u00fcr\u0259n v\u0259 n-d\u0259n ki\u00e7ik olan ilk n tam \u0259d\u0259dd\u0259n ibar\u0259t bir s\u0131ra qaytaran bir funksiya t\u0259tbiq edin. M\u0259s\u0259l\u0259n: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"\u0130ki tam \u0259d\u0259di g\u00f6t\u00fcr\u0259n v\u0259 onlar\u0131n vahid r\u0259q\u0259ml\u0259rinin m\u0259hsulunu qaytaran funksiyan\u0131 tamamlay\u0131n. Giri\u015fin h\u0259mi\u015f\u0259 etibarl\u0131 oldu\u011funu d\u00fc\u015f\u00fcn\u00fcn. N\u00fcmun\u0259l\u0259r: multiply ((148, 412) 16 qaytarmal\u0131d\u0131r multiply ((19, 28) 72. multiply ((2020, 1851) 0 qaytarmal\u0131d\u0131r multiply ((14,-15) 20 qaytarmal\u0131d\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    S s\u0259tirini ver\u0259rk\u0259n, c\u00fct indeksl\u0259rd\u0259ki b\u00f6y\u00fck h\u0259rfli vokallar\u0131n say\u0131n\u0131 say\u0131n. M\u0259s\u0259l\u0259n: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 qaytar\u0131r\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Bir m\u00fcsb\u0259t tam n verilmi\u015f, n s\u0259viyy\u0259li da\u015flardan ibar\u0259t bir y\u0131\u011f\u0131n haz\u0131rlamal\u0131s\u0131n\u0131z. Birinci s\u0259viyy\u0259d\u0259 n da\u015f var. N\u00f6vb\u0259ti s\u0259viyy\u0259d\u0259ki da\u015flar\u0131n say\u0131: - n n\u0259rdifdirs\u0259, n\u00f6vb\u0259ti c\u00fct r\u0259q\u0259mdir. - n c\u00fctd\u00fcrs\u0259, n\u00f6vb\u0259ti c\u00fct r\u0259q\u0259mdir. H\u0259r s\u0259viyy\u0259d\u0259ki da\u015flar\u0131n say\u0131n\u0131 bir siyah\u0131da qaytar\u0131n, burada indeksd\u0259ki element i s\u0259viyy\u0259d\u0259ki da\u015flar\u0131n say\u0131n\u0131 t\u0259msil edir (i + 1). N\u00fcmun\u0259l\u0259r:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Siz\u0259 virg\u00fcl v\u0259 ya bo\u015fluqlarla ayr\u0131lm\u0131\u015f s\u00f6zl\u0259r verilir. Sizin v\u0259zif\u0259niz bu s\u0259tirl\u0259ri s\u00f6zl\u0259r\u0259 b\u00f6lm\u0259k v\u0259 s\u00f6zl\u0259rin bir s\u0131ralar\u0131n\u0131 qaytarmaqd\u0131r. M\u0259s\u0259l\u0259n: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Bu funksiya iki m\u00fcsb\u0259t \u0259d\u0259d x v\u0259 y al\u0131r v\u0259 \u0259n b\u00f6y\u00fck c\u00fct tam \u0259d\u0259di qaytar\u0131r [x, y] daxil olmaqla. Bel\u0259 bir \u0259d\u0259d yoxdursa, onda funksiya -1 qaytarmal\u0131d\u0131r. M\u0259s\u0259l\u0259n: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Siz\u0259 n v\u0259 m \u0259d\u0259dl\u0259ri verilir v\u0259 sizin v\u0259zif\u0259niz n-d\u0259n m-\u0259 q\u0259d\u0259r olan \u0259d\u0259dl\u0259rin orta hesab\u0131n\u0131 hesablamaqd\u0131r. Cavab\u0131 \u0259n yax\u0131n tam \u0259d\u0259d\u0259 yuvarlay\u0131n v\u0259 ikili \u0259d\u0259dl\u0259r\u0259 \u00e7evirin. \u018fg\u0259r n m-d\u0259n b\u00f6y\u00fckd\u00fcrs\u0259, -1 qaytar\u0131n.\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"m\u00fcsb\u0259t tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131 verilmi\u015f x. he\u00e7 bir c\u00fct r\u0259q\u0259m olmayan b\u00fct\u00fcn elementl\u0259rin s\u0131ralanm\u0131\u015f siyah\u0131s\u0131n\u0131 qaytar\u0131n. Qeyd: Geri qaytar\u0131lan siyah\u0131 artan qaydada s\u0131ralanmal\u0131d\u0131r. M\u0259s\u0259l\u0259n:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Bir tam \u0259d\u0259dl\u0259r dizisi verildikd\u0259, 1 il\u0259 9 aras\u0131nda olan tam \u0259d\u0259dl\u0259ri s\u0131ralay\u0131n, n\u0259tic\u0259 dizisini t\u0259rs edin, sonra h\u0259r r\u0259q\u0259mi \"Bir\", \"\u0130ki\", \"\u00dc\u00e7\", \"D\u00f6rd\", \"Be\u015f\", \"Alt\u0131\", \"Yeddi\", \"S\u0259kkiz\", \"Doqquz\" dan m\u00fcvafiq ad\u0131 il\u0259 \u0259v\u0259z edin. M\u0259s\u0259l\u0259n: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> s\u0131ra arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> \u0259ks arr -> [8, 5, 4, 3, 2, 2, 1, 1] qaytar\u0131n [\"S\u0259kkiz\", \"D\u00f6rd\", \"\u00dc\u00e7\", \"\u0130ki\", \"\u0130ki\", \"Bir\", \"Bir\"] \u018fg\u0259r s\u0131ra bo\u015fdursa, bo\u015f bir s\u0131ra qaytar\u0131n: arr = [] array [] arrayda h\u0259r hans\u0131 bir q\u0259rib\u0259 r\u0259q\u0259m varsa, onu g\u00f6rm\u0259d\u0259n ke\u00e7in: arr = [1,\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" F funksiyalar\u0131n\u0131 t\u0259tbiq edin ki, n-i parametr kimi q\u0259bul edir v\u0259 n \u00f6l\u00e7\u00fcl\u00fc bir siyah\u0131 qaytar\u0131r, bel\u0259 ki, indeksd\u0259ki elementin d\u0259y\u0259ri i c\u00fctd\u00fcrs\u0259 i-nin faktorilinin v\u0259 ya 1 il\u0259 i aras\u0131ndak\u0131 \u0259d\u0259dl\u0259rin c\u0259mi. i 1-d\u0259n ba\u015flay\u0131r. i-nin faktorili 1 il\u0259 i aras\u0131ndak\u0131 \u0259d\u0259dl\u0259rin \u00e7arpan\u0131d\u0131r (1 * 2 *... * i). M\u0259lum: f ((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    m\u00fcsb\u0259t n tam \u0259d\u0259d verildikd\u0259, daxil olmaqla aral\u0131qdak\u0131 c\u00fct v\u0259 c\u00fct tam \u0259d\u0259d palindromlar\u0131n\u0131n say\u0131na malik bir tuple qaytar\u0131n. M\u0259lumat: Giri\u015f: 3 \u00c7\u0131x\u0131\u015f: (1, 2) A\u00e7\u0131qlama: Tam \u0259d\u0259d palindromlar\u0131 bunlardan biri c\u00fct, ikisi is\u0259 c\u00fctd\u00fcr. M\u0259lumat: Giri\u015f: 12 \u00c7\u0131x\u0131\u015f: (4, 6) A\u00e7\u0131qlama: Tam \u0259d\u0259d palindromlar\u0131 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. bunlardan d\u00f6rd\u00fc c\u00fct, onlardan 6-s\u0131 is\u0259 c\u00fctd\u00fcr. Qeyd: 1. 1 <= n <= 10 ^ 3 2. tuple s\u0131ras\u0131yla c\u00fct v\u0259 c\u00fct tam \u0259d\u0259d palindromlar\u0131n\u0131n say\u0131n\u0131 qaytarm\u0131\u015fd\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Bir say m\u0259nfi olarsa, ilk imzalanm\u0131\u015f r\u0259q\u0259m m\u0259nfi olacaq: m\u0259s\u0259l\u0259n, -123 r\u0259q\u0259ml\u0259ri -1, 2 v\u0259 3 il\u0259 imzalanm\u0131\u015fd\u0131r.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"N tam \u0259d\u0259dd\u0259n ibar\u0259t bir s\u0131ra 'arr' var arr[1], arr[2],..., arr[N].Arraydak\u0131 \u0259d\u0259dl\u0259r t\u0259sad\u00fcfi qaydada s\u0131ralan\u0131r. Sizin v\u0259zif\u0259niz veril\u0259n s\u0131ra \u00fcz\u0259rind\u0259 a\u015fa\u011f\u0131dak\u0131 \u0259m\u0259liyyat\u0131 yerin\u0259 yetirm\u0259kl\u0259 s\u0131ralamay\u0131 azalma s\u0131ras\u0131na salmaq m\u00fcmk\u00fcn olub olmad\u0131\u011f\u0131n\u0131 m\u00fc\u0259yy\u0259n etm\u0259kdir: Siz\u0259 h\u0259r hans\u0131 bir sayda sa\u011f h\u0259r\u0259k\u0259t \u0259m\u0259liyyat\u0131 yerin\u0259 yetirm\u0259k icaz\u0259si verilir. Bir sa\u011f h\u0259r\u0259k\u0259t \u0259m\u0259liyyat\u0131, s\u0131ra b\u00fct\u00fcn elementl\u0259rinin sa\u011f istiqam\u0259td\u0259 bir m\u00f6vqed\u0259 h\u0259r\u0259k\u0259t etm\u0259si dem\u0259kdir. Array\u0131n son elementi s\u0131ralamada ba\u015flan\u011f\u0131c m\u00f6vqey\u0259, y\u0259ni 0-c\u0131 indeksiy\u0259 k\u00f6\u00e7\u00fcr\u00fcl\u0259c\u0259k. Yuxar\u0131dak\u0131 \u0259m\u0259liyyat\u0131 yerin\u0259 yetirm\u0259kl\u0259 s\u0131ralanm\u0131\u015f s\u0131ra \u0259ld\u0259 etm\u0259k m\u00fcmk\u00fcnd\u00fcrs\u0259, onda True qaytar\u0131n, ba\u015fqa False qaytar\u0131n. Veril\u0259n s\u0131ra bo\u015fdursa, False qaytar\u0131n. Qeyd: Veril\u0259n siyah\u0131da unikal\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Bu problemd\u0259, iki n\u00f6mr\u0259li siyah\u0131 g\u00f6t\u00fcr\u0259n v\u0259 lst1-i yaln\u0131z c\u00fct n\u00f6mr\u0259l\u0259rd\u0259n ibar\u0259t bir siyah\u0131 etm\u0259k \u00fc\u00e7\u00fcn onlar aras\u0131nda elementl\u0259rin m\u00fcbadil\u0259si apar\u0131lmas\u0131n\u0131n m\u00fcmk\u00fcn olub olmad\u0131\u011f\u0131n\u0131 t\u0259yin ed\u0259n bir funksiya t\u0259tbiq ed\u0259c\u0259ksiniz. Lst1 v\u0259 lst2 aras\u0131nda m\u00fcbadil\u0259 edil\u0259n elementl\u0259rin say\u0131na m\u0259hdudiyy\u0259t yoxdur. Lst1 v\u0259 lst2 aras\u0131nda b\u00fct\u00fcn elementl\u0259rin c\u00fct olmas\u0131 \u00fc\u00e7\u00fcn elementl\u0259rin m\u00fcbadil\u0259si m\u00fcmk\u00fcnd\u00fcrs\u0259, \"B\u018fY\" qaytaracaqs\u0131n\u0131z. \u018fks t\u0259qdird\u0259, \"Yox\" qaytaracaqs\u0131n\u0131z. M\u0259s\u0259l\u0259n: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"B\u018fY\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"Yox\" Giri\u015f siyah\u0131lar\u0131n\u0131n bo\u015f olmayaca\u011f\u0131 g\u00fcman edilir.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Bir s\u0131ra bo\u015fluqlarla ayr\u0131lm\u0131\u015f ki\u00e7ik h\u0259rfl\u0259ri t\u0259msil ed\u0259n bir simli verildikd\u0259, \u0259n \u00e7ox t\u0259krarlanan v\u0259 m\u00fcvafiq say\u0131n\u0131 ehtiva ed\u0259n h\u0259rfin bir l\u00fc\u011f\u0259tini qaytar\u0131n. Bir ne\u00e7\u0259 h\u0259rfin eyni olmas\u0131 hal\u0131nda, ham\u0131s\u0131n\u0131 qaytar\u0131n. M\u0259lum: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4}: histogram'(((') == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"G\u00f6rev S v\u0259 c iki simli verilir, s-d\u0259ki h\u0259r hans\u0131 bir simaya b\u0259rab\u0259r olan b\u00fct\u00fcn siml\u0259ri silm\u0259lisiniz, sonra n\u0259tic\u0259 simli palindrom olub olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131n. Bir simli, ir\u0259li v\u0259 geriy\u0259 oxudu\u011fu t\u0259qdird\u0259 palindrom adlan\u0131r. N\u0259tic\u0259 simli v\u0259 True \/ False olan bir tuple qaytarmal\u0131s\u0131n\u0131z. M\u0259s\u0259l\u0259n, s = \"abcde\", c = \"ae\" \u00fc\u00e7\u00fcn n\u0259tic\u0259 ('bcd', False) olmal\u0131d\u0131r. S = \"abcdef\", c = \"b\" \u00fc\u00e7\u00fcn n\u0259tic\u0259 ('acdef', False) olmal\u0131d\u0131r. S = \"abcdedcba\", c = \"ab\", n\u0259tic\u0259 ('cdedc', True) olmal\u0131d\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"H\u0259r bir simli yaln\u0131z r\u0259q\u0259ml\u0259rd\u0259n ibar\u0259t olan simli siyah\u0131s\u0131 verildikd\u0259, bir siyah\u0131 qaytar\u0131n. \u00c7\u0131x\u0131\u015f\u0131n h\u0259r bir elementi i, giri\u015f simli i-d\u0259ki c\u00fct elementl\u0259rin say\u0131 olmal\u0131d\u0131r. Burada b\u00fct\u00fcn i-l\u0259r giri\u015f simli i-ci simli c\u00fct r\u0259q\u0259ml\u0259rin say\u0131 il\u0259 \u0259v\u0259z edilm\u0259lidir.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Tam \u0259d\u0259dl\u0259rin n-d\u0259n ibar\u0259t bir s\u0131ra verilmi\u015fdir, bo\u015f olmayan n-in h\u0259r hans\u0131 bir alt s\u0131ralar\u0131n\u0131n minimum c\u0259minin tap\u0131lmas\u0131n\u0131 t\u0259yin edin. Misal minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Siz\u0259 quyudan ibar\u0259t d\u00fczbucaql\u0131 bir \u015f\u0259b\u0259k\u0259 verilir. H\u0259r bir s\u0131ra bir quyunu t\u0259msil edir v\u0259 h\u0259r bir s\u0131ra 1 vahid su vahidini t\u0259msil edir. H\u0259r quyunun ondan su \u00e7\u0131xarmaq \u00fc\u00e7\u00fcn istifad\u0259 edil\u0259 bil\u0259n m\u00fcvafiq bir kovas\u0131 var v\u0259 b\u00fct\u00fcn kovlar\u0131n eyni tutumu var. Sizin v\u0259zif\u0259niz kovlar\u0131 bo\u015faltmaq \u00fc\u00e7\u00fcn kovadan istifad\u0259 etm\u0259kdir. Kovalar\u0131 a\u015fa\u011f\u0131 salmaq \u00fc\u00e7\u00fcn laz\u0131m olan say\u0131 \u00e7\u0131xar\u0131n. M\u0259lum: Giri\u015f: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 \u00c7\u0131x\u0131\u015f: 6 \u00c7\u0131x\u0131\u015f: Input: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 \u00c7\u0131x\u0131\u015f: 5 \u00c7\u0131x\u0131\u015f: [[0,0,0], [\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Bu Kata, m\u0259nfi olmayan tam saylar\u0131n dizini ikili n\u00fcmayi\u015find\u0259ki birl\u0259rin say\u0131na g\u00f6r\u0259 y\u00fcks\u0259l\u0259n s\u0131rada s\u0131ralamal\u0131d\u0131r. ox\u015far birl\u0259r \u00fc\u00e7\u00fcn onluq d\u0259y\u0259rin\u0259 \u0259saslanaraq s\u0131ralay\u0131n. Bu, bel\u0259 h\u0259yata ke\u00e7irilm\u0259lidir:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Bir string s v\u0259 t\u0259bii n say\u0131n\u0131 n\u0259z\u0259r\u0259 alaraq, bu s\u00f6zl\u0259rin string s-d\u0259 g\u00f6r\u00fcnm\u0259si \u00fc\u00e7\u00fcn tam n h\u0259rfd\u0259n ibar\u0259t olan string s-d\u0259n b\u00fct\u00fcn s\u00f6zl\u0259rin siyah\u0131s\u0131n\u0131 qaytaran bir funksiya t\u0259tbiq etm\u0259k tap\u015f\u0131r\u0131l\u0131b. \u018fg\u0259r string s bo\u015fdursa, onda funksiya bo\u015f bir siyah\u0131 qaytarmal\u0131d\u0131r. Qeyd: giri\u015f simli yaln\u0131z h\u0259rfl\u0259r v\u0259 bo\u015fluqlar ehtiva edir. N\u00fcmun\u0259l\u0259r: select_words (\"Mary had a little lamb\", 4) ==> [\"little\"] select_words (\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words \"simple white space\", 2) ==> [] select_words (\"Hello world\", 4) ==> [\"world\"] select_words (\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Siz\u0259 bir s\u00f6z verilir. Sizin v\u0259zif\u0259niz s\u00f6z\u00fcn sa\u011f t\u0259r\u0259find\u0259ki iki h\u0259rf aras\u0131nda duran \u0259n yax\u0131n s\u0259sl\u0259n\u0259n s\u0259si tapmaqd\u0131r (qeyri-h\u0259ssas). Ba\u015flan\u011f\u0131c v\u0259 sonuncu s\u0259sl\u0259n\u0259n s\u0259si saym\u0131r. Yuxar\u0131dak\u0131 \u015f\u0259rti yerin\u0259 yetir\u0259n h\u0259r hans\u0131 bir s\u0259sl\u0259n\u0259n s\u0259si tapmad\u0131\u011f\u0131n\u0131z t\u0259qdird\u0259 bo\u015f s\u0259tir qaytar\u0131n. Veril\u0259n s\u0259tirin yaln\u0131z ingilis h\u0259rfi oldu\u011funu d\u00fc\u015f\u00fcn\u0259 bil\u0259rsiniz. M\u0259s\u0259l\u0259n: get_closest_vowel ((\"yogurt\") ==> \"u\" get_closest_vowel ((\"F\") ==> \"U\" get_closest_vowel ((\"quick\") ==> \"\" get_closest_vowel\" ((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Bir s\u0131ra b\u00fct\u00fcn \u0259d\u0259dl\u0259r v\u0259 m\u00fcsb\u0259t tam \u0259d\u0259d k verilmi\u015fdir, uzunlu\u011fu k olan, maksimum k \u0259d\u0259dl\u0259ri olan s\u0131ralanm\u0131\u015f bir siyah\u0131 qaytar\u0131n.M\u0259s\u0259l\u0259n1: Giri\u015f: arr = [-3, -4, 5], k = 3 \u00c7\u0131x\u0131\u015f: [-4, -3, 5]M\u0259s\u0259l\u0259n2: Giri\u015f: arr = [4, -4, 4], k = 2 \u00c7\u0131x\u0131\u015f: [4, 4]M\u0259s\u0259l\u0259n3: Giri\u015f: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 \u00c7\u0131x\u0131\u015f: [2] Qeyd: 1. Array\u0131n uzunlu\u011fu [1, 1000] aral\u0131\u011f\u0131nda olacaq. 2. Arraydak\u0131 elementl\u0259r [-1000, 1000] aral\u0131\u011f\u0131nda olacaq.\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Bo\u015f olmayan tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131 verildikd\u0259, c\u00fct m\u00f6vqel\u0259rd\u0259 olan b\u00fct\u00fcn c\u00fct elementl\u0259rin c\u0259minin c\u0259minini qaytar\u0131n.\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Bo\u015f olmayan arr tam \u0259d\u0259dl\u0259ri v\u0259 k tam \u0259d\u0259dl\u0259ri olan bir s\u0131ra verilmi\u015fdir, arr\u0131n ilk k elementl\u0259rind\u0259n \u0259n \u00e7ox iki r\u0259q\u0259m olan elementl\u0259rin c\u0259minin c\u0259minini qaytar\u0131n. M\u0259lum: Giri\u015f: arr = [111,21,3,4000,5,6,7,8,9], k = 4 \u00c7\u0131x\u0131\u015f: 24 # 21 + 3 c\u0259mi M\u0259hdl\u0259r: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Bir m\u00fcsb\u0259t tam n verilmi\u015f, s\u0131ralanm\u0131\u015f siyah\u0131n\u0131 qaytar\u0131n ki, onda c\u00fct \u0259d\u0259dl\u0259r var. Collatz f\u0259rziyy\u0259si a\u015fa\u011f\u0131dak\u0131 kimi m\u00fc\u0259yy\u0259n edilmi\u015f ard\u0131c\u0131ll\u0131qla \u0259laq\u0259li riyazi bir f\u0259rziyy\u0259dir: h\u0259r hans\u0131 bir m\u00fcsb\u0259t tam n il\u0259 ba\u015flay\u0131n. Sonra h\u0259r bir m\u00fcdd\u0259t \u0259vv\u0259lki m\u00fcdd\u0259td\u0259n a\u015fa\u011f\u0131dak\u0131 kimi al\u0131n\u0131r: \u0259g\u0259r \u0259vv\u0259lki m\u00fcdd\u0259t c\u00fctdirs\u0259, n\u00f6vb\u0259ti m\u00fcdd\u0259t \u0259vv\u0259lki m\u00fcdd\u0259tin yar\u0131s\u0131d\u0131r. \u018fg\u0259r \u0259vv\u0259lki m\u00fcdd\u0259t c\u00fctdirs\u0259, n\u00f6vb\u0259ti m\u00fcdd\u0259t \u0259vv\u0259lki m\u00fcdd\u0259tin 3 qat\u0131d\u0131r art\u0131 1. F\u0259rziyy\u0259 budur ki, n-in hans\u0131 d\u0259y\u0259ri olursa olsun, ard\u0131c\u0131ll\u0131q h\u0259mi\u015f\u0259 1-\u0259 \u00e7atacaq. Qeyd: 1. Collatz ((1) [1] 2. Geri qaytar\u0131lan siyah\u0131 artan qaydada s\u0131ralan\u0131r. M\u0259s\u0259l\u0259n: get_odd_collatz ((5) [1, 5] qaytar\u0131r. 5 \u00fc\u00e7\u00fcn Collatz ard\u0131c\u0131ll\u0131\u011f\u0131 [5,\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Bir tarix silsil\u0259sini t\u0259sdiql\u0259y\u0259n v\u0259 tarix etibarl\u0131sa True, \u0259ks halda False funksiyas\u0131n\u0131 yazmal\u0131s\u0131n\u0131z. Tarix a\u015fa\u011f\u0131dak\u0131 qaydalar\u0131n ham\u0131s\u0131 yerin\u0259 yetirilmi\u015fs\u0259 etibarl\u0131d\u0131r: 1. Tarix silsilesi bo\u015f deyil. 2. G\u00fcnl\u0259rin say\u0131 aylar \u00fc\u00e7\u00fcn 1 v\u0259 ya daha \u00e7ox 31 g\u00fcnd\u0259n az deyil. 4.6,9,11 aylar \u00fc\u00e7\u00fcn g\u00fcnl\u0259rin say\u0131 1 v\u0259 ya daha \u00e7ox 30 g\u00fcnd\u0259n az deyil. Aylar 1 v\u0259 ya daha \u00e7ox 29 ay \u00fc\u00e7\u00fcn 2 v\u0259 ya daha az olmamal\u0131d\u0131r. Aylar 1 v\u0259 ya daha \u00e7ox olmamal\u0131d\u0131r. 4. Tarix format\u0131nda olmal\u0131d\u0131r: mm-dd-yyyy m\u0259s\u0259l\u0259n: valid_date (('03-11-2000') => valid_date (('15-01-2012') => False valid_date (('04-040') => False_date (('06-04-2020') => valid_date (('06\/04\/2020') => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Siz\u0259 h\u0259r bir interval\u0131n bir c\u00fct tam \u0259d\u0259d oldu\u011fu iki interval verilir. M\u0259s\u0259l\u0259n, interval = (ba\u015f, son) = (1, 2). Veril\u0259n intervallar qapal\u0131d\u0131r, y\u0259ni interval (ba\u015f, son) h\u0259m ba\u015flan\u011f\u0131c, h\u0259m d\u0259 sonun daxil oldu\u011fu dem\u0259kdir. H\u0259r bir interval \u00fc\u00e7\u00fcn ba\u015flan\u011f\u0131c\u0131n\u0131n sonuna az v\u0259 ya b\u0259rab\u0259r oldu\u011fu f\u0259rz edilir. Sizin v\u0259zif\u0259niz bu iki interval\u0131n k\u0259si\u015fm\u0259sinin uzunlu\u011funun bir \u0259d\u0259d olub olmad\u0131\u011f\u0131n\u0131 m\u00fc\u0259yy\u0259n etm\u0259kdir. M\u0259s\u0259l\u0259n, intervallar\u0131n k\u0259si\u015fm\u0259sinin uzunlu\u011fu 1, hans\u0131 ki, \u0259d\u0259d say\u0131 deyil. \u018fg\u0259r k\u0259si\u015fm\u0259 uzunlu\u011fu \u0259d\u0259d say\u0131d\u0131rsa, \"B\u018f\" qaytar\u0131n, \u0259ks halda \"Y\u018f\" qaytar\u0131n. \u018fg\u0259r iki interval k\u0259si\u015fmirs\u0259, \"Y\u018f\" qaytar\u0131n. [input\/output] n\u00fcmun\u0259l\u0259ri: k\u0259si\u015fm\u0259 (((1, 2), (2,\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Siz\u0259 tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t bir s\u0131ra verilir v\u0259 tam \u0259d\u0259dl\u0259rin b\u00f6y\u00fckl\u00fcy\u00fcn\u00fcn c\u0259mi il\u0259 1, -1 v\u0259 ya 0 il\u0259 t\u0259msil olunan s\u0131radak\u0131 h\u0259r bir r\u0259q\u0259min b\u00fct\u00fcn \u0259lam\u0259tl\u0259rinin m\u0259hsulu il\u0259 \u00e7arp\u0131lmal\u0131d\u0131r. Qeyd: bo\u015f s\u0131ra \u00fc\u00e7\u00fcn he\u00e7 bir \u015fey qaytarmay\u0131n.\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    N s\u0131ra v\u0259 N s\u00fctun (N > = 2) v\u0259 m\u00fcsb\u0259t k tam \u0259d\u0259dli bir \u015f\u0259b\u0259k\u0259 verildikd\u0259, \u015f\u0259b\u0259k\u0259nin h\u0259r h\u00fcceyr\u0259si bir d\u0259y\u0259r ehtiva edir. [1, N * N] daxil olmaqla aral\u0131qdak\u0131 h\u0259r tam \u0259d\u0259d \u015f\u0259b\u0259k\u0259nin h\u00fcceyr\u0259l\u0259rind\u0259 tam bir d\u0259f\u0259 g\u00f6r\u00fcn\u00fcr. K uzunlu\u011funda minimum yolu tapmal\u0131s\u0131n\u0131z. H\u0259r hans\u0131 bir h\u00fcceyr\u0259d\u0259n ba\u015flaya bil\u0259rsiniz v\u0259 h\u0259r add\u0131mda qon\u015fu h\u00fcceyr\u0259l\u0259rd\u0259n h\u0259r hans\u0131 birin\u0259 ke\u00e7\u0259 bil\u0259rsiniz, ba\u015fqa s\u00f6zl\u0259, sizinl\u0259 bir k\u0259nar payla\u015fan h\u00fcceyr\u0259l\u0259r\u0259 ged\u0259 bil\u0259rsiniz. L\u00fctf\u0259n qeyd edin ki, k uzunlu\u011funda bir yol tam k h\u00fcceyr\u0259ni ziyar\u0259t etm\u0259k dem\u0259kdir (m\u00fcmk\u00fcn deyil ki, f\u0259rqli). \u015e\u0259b\u0259k\u0259d\u0259n \u00e7\u0131xa bilm\u0259zsiniz. A yolu (k uzunlu\u011fu) A v\u0259 B h\u00fcceyr\u0259l\u0259rind\u0259ki d\u0259y\u0259rl\u0259rin sifari\u015fli\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"H\u0259r k\u0259s Fibona\u00e7\u00e7i ard\u0131c\u0131ll\u0131\u011f\u0131n\u0131 bilir, son iki \u0259srd\u0259 riyaziyyat\u00e7\u0131lar t\u0259r\u0259find\u0259n d\u0259rind\u0259n \u00f6yr\u0259nilmi\u015fdir. Bununla birlikd\u0259, insanlar\u0131n bilm\u0259dikl\u0259ri Tribonacci ard\u0131c\u0131ll\u0131\u011f\u0131d\u0131r. Tribonacci ard\u0131c\u0131ll\u0131\u011f\u0131 t\u0259krarlanma il\u0259 m\u00fc\u0259yy\u0259n edilir: tri(1) = 3 tri(n) = 1 + n \/ 2, \u0259g\u0259r n c\u00fctdirs\u0259. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), \u0259g\u0259r n c\u00fctd\u00fcrs\u0259. M\u0259s\u0259l\u0259n: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Siz\u0259 m\u0259nfi olmayan tam n\u00f6mr\u0259 verilir, Tribonacci ard\u0131c\u0131ll\u0131\u011f\u0131n\u0131n ilk n + 1 n\u00f6mr\u0259l\u0259rinin siyah\u0131s\u0131n\u0131 qaytarmal\u0131s\u0131n\u0131z. N\u00fcmun\u0259l\u0259r: tri(3) = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Bir m\u00fcsb\u0259t tam n verilmi\u015fs\u0259, t\u0259k r\u0259q\u0259ml\u0259rin m\u0259hsulunu qaytar\u0131n. B\u00fct\u00fcn r\u0259q\u0259ml\u0259r c\u00fctd\u00fcrs\u0259 0 qaytar\u0131n. M\u0259s\u0259l\u0259n: r\u0259q\u0259ml\u0259r ((1) == 1 r\u0259q\u0259m ((4) == 0 r\u0259q\u0259m ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Siz\u0259 n\u00f6mr\u0259l\u0259r siyah\u0131s\u0131 verilir. Veril\u0259n siyah\u0131dak\u0131 n\u00f6mr\u0259l\u0259rin kvadrat\u0131n\u0131n c\u0259minin qaytar\u0131lmas\u0131, siyah\u0131dak\u0131 h\u0259r bir elementi ilk n\u00f6vb\u0259d\u0259 yuxar\u0131 int (~) il\u0259 yuvarlamaq laz\u0131md\u0131r. N\u00fcmun\u0259l\u0259r: lst = [1,2,3] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 14 olmal\u0131d\u0131r lst = [1,4,9] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 98 olmal\u0131d\u0131r lst = [1,3,5,7] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 84 olmal\u0131d\u0131r lst = [1.4,4.2,0] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 29 olmal\u0131d\u0131r lst = [-2.4,1,1] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 6 olmal\u0131d\u0131r\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Bir elementin \u0259n b\u00f6y\u00fck indeksini geri qaytaran bir funksiya yarad\u0131n. Bu elementin d\u0259rhal \u0259vv\u0259lki elementd\u0259n b\u00f6y\u00fck v\u0259 ya b\u0259rab\u0259r olmad\u0131\u011f\u0131 halda geri qaytar\u0131n -1. Veril\u0259n s\u0131ra t\u0259krarlanan d\u0259y\u0259rl\u0259ri ehtiva etm\u0259y\u0259c\u0259kdir. N\u00fcmun\u0259l\u0259r: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Real \u0259d\u0259dl\u0259ri t\u0259msil ed\u0259n tam \u0259d\u0259dl\u0259ri, \u00fcz\u0259n \u0259d\u0259dl\u0259ri v\u0259 ya simli \u0259d\u0259dl\u0259ri q\u0259bul ed\u0259n v\u0259 veril\u0259n d\u0259yi\u015f\u0259n n\u00f6v\u00fcnd\u0259 daha b\u00f6y\u00fck d\u0259yi\u015f\u0259nl\u0259ri geri qaytaran bir funksiya yarad\u0131n. D\u0259y\u0259rl\u0259r b\u0259rab\u0259rdirs\u0259, He\u00e7 bir \u015fey qaytar\u0131n. Qeyd: \u018fg\u0259r real \u0259d\u0259d simli kimi t\u0259msil olunursa, \u00fcz\u0259n n\u00f6qt\u0259 ola bil\u0259r. v\u0259 ya, compare_one{1, 2.5) \u00e2 -> 2.5 compare_one{1, \"2,3\") \u00e2 -> \"2,3\" compare_one{5,1\", \"6\") \u00e2 -> \"6\" compare_one{1\", 1) \u00e2 -> He\u00e7 bir \u015fey\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Verilmi\u015f n say\u0131n\u0131n tam olaraq 4 m\u00fcsb\u0259t c\u00fct say\u0131n c\u0259mi olaraq yaz\u0131la bil\u0259c\u0259yini qiym\u0259tl\u0259ndirin. Misal: c\u00fct say\u0131n c\u0259mi il\u0259 b\u0259rab\u0259rdir.\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Braziliya faktoriali bel\u0259 t\u0259yin olunur: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! harada n > 0 M\u0259s\u0259l\u0259n:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Bir simli m\u0259tn verilirs\u0259, b\u00fct\u00fcn bo\u015fluqlar\u0131 alt i\u015far\u0259l\u0259rl\u0259 \u0259v\u0259z edin v\u0259 bir simlin ard\u0131c\u0131l 2 bo\u015fluqdan \u00e7oxdursa, sonra b\u00fct\u00fcn ard\u0131c\u0131l bo\u015fluqlar\u0131 - fix_spaces il\u0259 \u0259v\u0259z edin ({{MediaWiki:Login-sysop}}) == \"M\u0259s\u0259l\u0259n\" fix_spaces ({{MediaWiki:Login-sysop}}) == \"M\u0259s\u0259l\u0259n1\" fix_spaces ({{MediaWiki:Login-sysop}}) == \"M\u0259s\u0259l\u0259n2\") == \"_M\u0259s\u0259l\u0259n2\" fix_spaces ({{MediaWiki:Login-sysop}}) == \"_M\u0259s\u0259l\u0259n-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Bir fayl\u0131n ad\u0131n\u0131 t\u0259msil ed\u0259n bir simli g\u00f6t\u00fcr\u0259n v\u0259 fayl\u0131n ad\u0131 etibarl\u0131 olduqda 'B\u0259li' qaytaran v\u0259 \u0259ks halda 'Xeyr' qaytaran bir funksiya yarad\u0131n. Bir fayl\u0131n ad\u0131 etibarl\u0131 say\u0131l\u0131r v\u0259 yaln\u0131z a\u015fa\u011f\u0131dak\u0131 \u015f\u0259rtl\u0259rin ham\u0131s\u0131 yerin\u0259 yetirilmi\u015fs\u0259: - Fayl\u0131n ad\u0131nda \u00fc\u00e7d\u0259n \u00e7ox r\u0259q\u0259m ('0'-'9') olmamal\u0131d\u0131r. - Fayl\u0131n ad\u0131nda tam olaraq bir n\u00f6qt\u0259'var. - N\u00f6qt\u0259d\u0259n \u0259vv\u0259lki alt simli bo\u015f olmamal\u0131d\u0131r v\u0259 lat\u0131n alfabetinin h\u0259rfi il\u0259 ba\u015flamal\u0131d\u0131r ('a'-'z' v\u0259 'A'Z'). - N\u00f6qt\u0259d\u0259n sonra alt simli bunlardan biri olmal\u0131d\u0131r: ['txt', 'exe', 'll'] N\u00fcmun\u0259l\u0259r: file_name_check\"(example.txt\") # => 'B\u0259li' file_name_\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" Bu funksiya tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131n\u0131 g\u00f6t\u00fcr\u0259c\u0259k. Siyah\u0131dak\u0131 b\u00fct\u00fcn giri\u015fl\u0259r \u00fc\u00e7\u00fcn, funksiyan\u0131n indeksi 3 qat\u0131 olsa tam \u0259d\u0259d giri\u015fini kvadratla\u015fd\u0131rmal\u0131d\u0131r v\u0259 indeksi 3 qat\u0131 olmasa 4 qat\u0131 olsa tam \u0259d\u0259d giri\u015fini kubla\u015fd\u0131r\u0131r. Funksiya indeksi 3 v\u0259 ya 4 qat\u0131 olmayan siyah\u0131dak\u0131 giri\u015fl\u0259ri d\u0259yi\u015fdirm\u0259y\u0259c\u0259k. Funksiya sonra b\u00fct\u00fcn giri\u015fl\u0259rin c\u0259minin n\u0259tic\u0259sini qaytarmal\u0131d\u0131r. N\u00fcmun\u0259l\u0259r: lst = [1,2,3] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 6 olmal\u0131d\u0131r lst = [] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 0 olmal\u0131d\u0131r lst = [-1,-5,2,-1,-5] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f -126 olmal\u0131d\u0131r\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Bir c\u00fcml\u0259ni t\u0259msil ed\u0259n bir simli verilir, c\u00fcml\u0259d\u0259 bo\u015fluqla ayr\u0131lm\u0131\u015f b\u0259zi s\u00f6zl\u0259r var v\u0259 uzunlu\u011fu ilkin c\u00fcml\u0259d\u0259n olan s\u00f6zl\u0259ri ehtiva ed\u0259n bir simli qaytarmal\u0131s\u0131n\u0131z, yeni simlid\u0259ki s\u00f6zl\u0259rin s\u0131ras\u0131 orijinal\u0131nki il\u0259 eyni olmal\u0131d\u0131r.M\u0259s\u0259l\u0259n1: Giri\u015f: c\u00fcml\u0259 = \"Bu bir testdir\" \u00c7\u0131x\u0131\u015f: \"dir\"M\u0259s\u0259l\u0259n2: Giri\u015f: c\u00fcml\u0259 = \"g\u0259l \u00fczm\u0259y\u0259 ged\u0259k\" \u00c7\u0131x\u0131\u015f: \"get\" M\u0259hdudla\u015fd\u0131rmalar: * 1 <= len(sentence) <= 100 * c\u00fcml\u0259 yaln\u0131z h\u0259rfl\u0259ri ehtiva edir\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Sizin v\u0259zif\u0259niz x * n ifad\u0259sini sad\u0259l\u0259\u015fdir\u0259c\u0259k bir funksiya t\u0259tbiq etm\u0259kdir. X * n tam bir \u0259d\u0259d qiym\u0259tl\u0259ndirirs\u0259 v\u0259 \u0259ks halda False funksiyas\u0131 True qaytar\u0131r. H\u0259m x, h\u0259m d\u0259 n, bir hiss\u0259nin simli t\u0259msilidir v\u0259 a\u015fa\u011f\u0131dak\u0131 format\u0131 var, <say\u0131c\u0131> \/ <n\u00fcminator> burada h\u0259m say\u0131c\u0131, h\u0259m d\u0259 m\u0259na\u00e7\u0131 m\u00fcsb\u0259t tam \u0259d\u0259dl\u0259rdir. x v\u0259 n-in etibarl\u0131 qrupu oldu\u011funu v\u0259 s\u0131f\u0131r\u0131n m\u0259na kimi olmad\u0131\u011f\u0131n\u0131 f\u0259rz ed\u0259 bil\u0259rsiniz. sad\u0259l\u0259\u015fdirm\u0259k: \"1\/ 5\", \"5\/1\") = True sad\u0259l\u0259\u015fdirm\u0259k: \"1\/ 6\", \"2\/1\") = False sad\u0259l\u0259\u015fdirm\u0259k: \"7\/ 10\", \"10\/2\") = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Veril\u0259n tamsayl\u0131lar\u0131n siyah\u0131s\u0131n\u0131 r\u0259q\u0259ml\u0259rinin c\u0259min\u0259 g\u00f6r\u0259 y\u00fcks\u0259l\u0259n qaydada s\u0131ralayan bir funksiya yaz\u0131n. Qeyd: r\u0259q\u0259ml\u0259rinin ox\u015far c\u0259mi olan bir ne\u00e7\u0259 madd\u0259 varsa, onlar\u0131 orijinal siyah\u0131dak\u0131 indeksl\u0259rin\u0259 \u0259sas\u0259n s\u0131ralay\u0131n. M\u0259s\u0259l\u0259n:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Bir s\u0131ra n\u00f6mr\u0259l\u0259rd\u0259n ibar\u0259t bir s\u0131ra daxil ed\u0259n v\u0259 10 -dan b\u00f6y\u00fck olan s\u0131ra elementl\u0259rinin say\u0131n\u0131 qaytaran bir funksiya yaz\u0131n v\u0259 bir n\u00f6mr\u0259nin h\u0259m ilk, h\u0259m d\u0259 son r\u0259q\u0259ml\u0259ri c\u00fctd\u00fcr (1, 3, 5, 7, 9). M\u0259s\u0259l\u0259n: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Siz\u0259 m\u00fcsb\u0259t tam n \u0259d\u0259d verilir. Siz uzunlu\u011fu n olan tam \u0259d\u0259dl\u0259r dizisi yaratmal\u0131s\u0131n\u0131z. H\u0259r i (1 \u2030\u00a4 i \u2030\u00a4 n) \u00fc\u00e7\u00fcn a[i] = i * i - i + 1 d\u0259y\u0259ri. a-n\u0131n \u00fc\u00e7l\u00fcy\u00fcn\u00fcn (a[i], a[j], a[k]) say\u0131n\u0131 qaytar\u0131n, burada i < j < k, v\u0259 a[i] + a[j] + a[k] 3-\u00fcn qat\u0131d\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Bir funksiya yaz\u0131n ki, bu funksiya simli silinm\u0259l\u0259ri q\u0259bul edir. Bu funksiya simli silinm\u0259l\u0259ri sil\u0259r v\u0259 n\u0259tic\u0259d\u0259 silinm\u0259l\u0259ri s\u0131ralanm\u0131\u015f qaydada qaytar\u0131r. Siyah\u0131 h\u0259mi\u015f\u0259 simli silinm\u0259l\u0259r siyah\u0131s\u0131d\u0131r v\u0259 he\u00e7 vaxt n\u00f6mr\u0259l\u0259r dizisi deyil. Bu funksiya h\u0259r bir s\u00f6z\u00fcn uzunlu\u011funa g\u00f6r\u0259 y\u00fcks\u0259l\u0259n olmal\u0131d\u0131r v\u0259 siz bu qaydaya uy\u011fun olaraq s\u0131ralanm\u0131\u015f siyah\u0131n\u0131 qaytarmal\u0131s\u0131n\u0131z. \u018fg\u0259r iki s\u00f6z eyni uzunlu\u011fa malikdirs\u0259, siyah\u0131n\u0131 \u0259lifba s\u0131ras\u0131 il\u0259 s\u0131raland\u0131r\u0131n. Funksiya simli silinm\u0259l\u0259rin siyah\u0131s\u0131n\u0131 s\u0131ralanm\u0131\u015f qaydada qaytarmal\u0131d\u0131r. B\u00fct\u00fcn s\u00f6zl\u0259rin eyni uzunlu\u011fa sahib olaca\u011f\u0131n\u0131 d\u00fc\u015f\u00fcn\u0259 bil\u0259rsiniz. M\u0259s\u0259l\u0259n: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"n bir \u0259d\u0259d olsa x-in d\u0259y\u0259rini qaytarmal\u0131 v\u0259 \u0259ks halda y-in d\u0259y\u0259rini qaytarmal\u0131 olan sad\u0259 bir proqram. N\u00fcmun\u0259l\u0259r: x_or_y ((7, 34, 12) \u00fc\u00e7\u00fcn == 34 x_or_y ((15, 8, 5) \u00fc\u00e7\u00fcn == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Bu, bir \u00e7ox insan\u0131n bir s\u0131ra uy\u011funluqlar\u0131n n\u0259tic\u0259l\u0259rini d\u00fczg\u00fcn t\u0259xmin etdiyini m\u00fc\u0259yy\u0259n etm\u0259kdir. Siz\u0259 h\u0259r bir indeksin uy\u011funlu\u011funu g\u00f6st\u0259rdiyi eyni uzunluqda iki s\u0131ra bal v\u0259 t\u0259xmin verilir. H\u0259r bir t\u0259xminin n\u0259 q\u0259d\u0259r uzaq oldu\u011funu g\u00f6st\u0259r\u0259n eyni uzunluqda bir s\u0131ra qay\u0131d\u0131r. \u018fg\u0259r d\u00fczg\u00fcn t\u0259xmin ets\u0259l\u0259r, d\u0259y\u0259r 0-dur, \u0259g\u0259r yoxsa, d\u0259y\u0259r t\u0259xmin v\u0259 n\u0259tic\u0259 aras\u0131ndak\u0131 m\u00fctl\u0259q f\u0259rqdir. misal: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4],[4,1,0,-2]) -> [4,4,0,1,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Siz\u0259 bir sinif ad\u0131 (bir simli) v\u0259 uzant\u0131lar\u0131n siyah\u0131s\u0131 veril\u0259c\u0259k. Uzant\u0131lar sinif\u0259 \u0259lav\u0259 sinifl\u0259r y\u00fckl\u0259m\u0259k \u00fc\u00e7\u00fcn istifad\u0259 edil\u0259c\u0259kdir. Uzant\u0131n\u0131n g\u00fcc\u00fc a\u015fa\u011f\u0131dak\u0131 kimidir: CAP uzant\u0131n\u0131n ad\u0131nda b\u00f6y\u00fck h\u0259rfl\u0259rin say\u0131 olsun, SM is\u0259 uzant\u0131n\u0131n ad\u0131nda ki\u00e7ik h\u0259rfl\u0259rin say\u0131 olsun, g\u00fcc CAP - SM \u0259d\u0259di il\u0259 verilir. \u018fn g\u00fccl\u00fc uzant\u0131n\u0131 tapmal\u0131 v\u0259 bu formatda bir simli qaytarmal\u0131s\u0131n\u0131z: ClassName.StrongestExtensionName. \u018fg\u0259r eyni g\u00fccl\u0259 iki v\u0259 ya daha \u00e7ox uzant\u0131 varsa, siyah\u0131da ilk g\u0259l\u0259nini se\u00e7m\u0259lisiniz. M\u0259s\u0259l\u0259n, siz\u0259 sinif v\u0259 uzant\u0131lar\u0131n siyah\u0131s\u0131 kimi \"Slices\" verilirs\u0259: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] sonra 'Slices.SEviRNGSliCes' 'S\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Siz\u0259 2 s\u00f6z verilir. \u0130kinci s\u00f6z v\u0259 ya onun h\u0259r hans\u0131 bir d\u00f6nm\u0259sinin birinci s\u00f6z\u00fcn alt simli olmas\u0131 hal\u0131nda True qaytarmal\u0131s\u0131n\u0131z cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Bir tam \u0259d\u0259d verildiyi t\u0259qdird\u0259, m\u00fcvafiq olaraq c\u00fct v\u0259 c\u00fct r\u0259q\u0259ml\u0259rin say\u0131na malik bir tuple qaytar\u0131n. M\u0259lum: c\u00fct_c\u00fct_say ((-12) ==> (1, 1) c\u00fct_c\u00fct_say ((123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    M\u00fcsb\u0259t bir tam \u0259d\u0259d verildikd\u0259, onun roman r\u0259q\u0259ml\u0259rin\u0259 ekvivalentini bir simli olaraq \u0259ld\u0259 edin v\u0259 ki\u00e7ik h\u0259rfl\u0259rl\u0259 qaytar\u0131n.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Bir s\u0131ra simli q\u0259bul ed\u0259n bir funksiya yaz\u0131n. Siyah\u0131 m\u00fcxt\u0259lif s\u00f6zl\u0259r ehtiva edir. \u018fn \u00e7ox unikal simli olan s\u00f6z\u00fc qaytar\u0131n. Bird\u0259n \u00e7ox simli \u0259n \u00e7ox unikal simli olan varsa, leksikografik s\u0131rada ilk g\u0259l\u0259nini qaytar\u0131n.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Ac bir dov\u015fans\u0131n\u0131z v\u0259 art\u0131q m\u00fc\u0259yy\u0259n sayda havu\u00e7 yediniz, amma indi g\u00fcn\u00fcn yem\u0259kl\u0259rini tamamlamaq \u00fc\u00e7\u00fcn daha \u00e7ox havu\u00e7 yem\u0259lisiniz. bir s\u0131ra qaytarmal\u0131s\u0131n\u0131z [ yem\u0259kd\u0259n sonra yeyil\u0259n havu\u00e7lar\u0131n \u00fcmumi say\u0131, yem\u0259kd\u0259n sonra qalan havu\u00e7lar\u0131n say\u0131 ] kifay\u0259t q\u0259d\u0259r havu\u00e7 qalmasa, qalan havu\u00e7lar\u0131 yey\u0259c\u0259ksiniz, amma yen\u0259 d\u0259 ac olacaqs\u0131n\u0131z. M\u0259lum: * yeyin ((5, 6, 10) -> [11, 4] * yeyin ((4, 8, 9) -> [12, 1] * yeyin ((1, 10, 10) -> [11, 0] * yeyin ((2, 11, 5) -> [7, 0] D\u0259yi\u015f\u0259nl\u0259r: @number: yediyiniz havu\u00e7lar\u0131n tam say\u0131n\u0131. @need: yem\u0259 ehtiyac\u0131n\u0131z olan havu\u00e7lar\u0131n tam say\u0131n\u0131. @remaining: ehtiyatda qalan havu\u00e7lar\u0131n tam say\u0131n\u0131 t\u0259yin edin: * 0 = <\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Operator v\u0259 operand iki siyah\u0131 verilir. Birinci siyah\u0131da \u0259sas c\u0259br \u0259m\u0259liyyatlar\u0131 var, ikinci siyah\u0131da is\u0259 tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131 var. Veril\u0259n iki siyah\u0131dan istifad\u0259 ed\u0259r\u0259k c\u0259br ifad\u0259si qurun v\u0259 bu ifad\u0259ni qiym\u0259tl\u0259ndirm\u0259sini qaytar\u0131n. \u018fsas c\u0259br \u0259m\u0259liyyatlar\u0131: \u018flav\u0259 (+) S\u0131\u011forta (- ) \u00c7oxalma (*) D\u00f6\u015f\u0259m\u0259 b\u00f6lm\u0259 ( \/\/) Eksponentasiya ( ** Misal) Operator['+', '*', '-'] s\u0131ra = [2, 3, 4, 5] n\u0259tic\u0259 = 2 + 3 * 4 - 5 => n\u0259tic\u0259 = 9 Qeyd: Operator siyah\u0131s\u0131n\u0131n uzunlu\u011fu operand siyah\u0131s\u0131n\u0131n uzunlu\u011funa b\u0259rab\u0259rdir. Operand m\u0259nfi olmayan tam \u0259d\u0259dl\u0259rin siyah\u0131s\u0131d\u0131r. Operator siyah\u0131s\u0131nda \u0259n az\u0131 bir operator var, operand siyah\u0131s\u0131nda is\u0259 \u0259n az\u0131 iki operand\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"S[i] h\u0259rfdirs\u0259, onun ba\u015f\u0131n\u0131 a\u015fa\u011f\u0131dan yuxar\u0131ya v\u0259 ya \u0259ksin\u0259 \u00e7evirin, \u0259ks halda oldu\u011fu kimi saxlay\u0131n. \u018fg\u0259r s\u0259tird\u0259 h\u0259rfl\u0259r yoxdursa, s\u0259tirni \u00e7evirin. Funksiya n\u0259tic\u0259 s\u0259tirini qaytarmal\u0131d\u0131r. N\u00fcmun\u0259l\u0259r h\u0259ll etm\u0259k ((\"1234\") = \"4321\" h\u0259ll etm\u0259k ((\"ab\") = \"AB\" h\u0259ll etm\u0259k ((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Bir simli'm\u0259tn' verilmi\u015fs\u0259, onun md5 hash ekvivalent simlini qaytar\u0131n. \u018fg\u0259r'm\u0259tn' bo\u015f simlidirs\u0259, None qaytar\u0131n.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    \u0130ki m\u00fcsb\u0259t tam \u0259d\u0259d a v\u0259 b verildikd\u0259, a v\u0259 b aras\u0131ndak\u0131 c\u00fct r\u0259q\u0259ml\u0259ri y\u00fcks\u0259l\u0259n qaydada qaytar\u0131n. M\u0259s\u0259l\u0259n: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]