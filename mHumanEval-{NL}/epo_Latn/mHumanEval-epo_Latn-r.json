[{"task_id":"HumanEval_0","nl":"epo_Latn","pl":"r","prompt":"la antaŭfiksita sojlo.Kontrolu, ĉu en la donita listo de nombroj, estas du nombroj pli proksimaj unu al la alia ol # >>> has_close_elements(c(1.0, 2.0, 3.0), 0.5)\n# FALSE\n# >>> has_close_elements(c(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n# TRUE\nhas_close_elements <- function(numbers, threshold) {","canonical_solution":"has_close_elements <- function(numbers, threshold) {\n  for (i in seq_along(numbers)) {\n    for (j in seq_along(numbers)) {\n      if (i != j && abs(numbers[i] - numbers[j]) < threshold) {\n        return(TRUE)\n      }\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- has_close_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.95), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.8), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 1.0), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1), 0.5), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_1","nl":"epo_Latn","pl":"r","prompt":"Ignoru iujn ajn spacojn en la eniga ŝnuro.Aliaj grupoj estas ekvilibraj (ĉiu malfermita brako estas konvene fermita) kaj ne nestitaj ene de unu la alian.disigi ilin en sekretajn partojn kaj liveru la liston de tiuj.Enigu ĉi tiun funkcion en ĉenon enhavanta multoblajn grupojn de nestitaj krampoj.# >>> separate_paren_groups('( ) (( )) (( )( ))')\n# c('()', '(())', '(()())')\nseparate_paren_groups <- function(paren_string) {","canonical_solution":"separate_paren_groups <- function(paren_string) {\n  # Remove spaces from the input string\n  paren_string <- gsub(\" \", \"\", paren_string)\n  \n  # Initialize variables for processing\n  result <- c()\n  current_group <- \"\"\n  balance <- 0\n  \n  # Iterate through each character in the string\n  for (char in strsplit(paren_string, \"\")[[1]]) {\n    current_group <- paste0(current_group, char)\n    if (char == \"(\") {\n      balance <- balance + 1\n    } else if (char == \")\") {\n      balance <- balance - 1\n    }\n    \n    # If balance is zero, we found a complete group\n    if (balance == 0 && nchar(current_group) > 0) {\n      result <- c(result, current_group)\n      current_group <- \"\"\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- separate_paren_groups\n    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c('(()())', '((()))', '()', '((())()())'))))\n    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c('()', '(())', '((()))', '(((())))'))))\n    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c('(()(())((())))'))))\n    stopifnot(isTRUE(all.equal(candidate('( ) (( )) (( )( ))'), c('()', '(())', '(()())'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_2","nl":"epo_Latn","pl":"r","prompt":"Redonu la dekuman parton de la nombro. (la restanta parto ĉiam estas pli malgranda ol 1).kaj entjera parto (plej granda entjero pli malgranda ol donita nombro) kaj decimaloj Donita pozitiva nombro de flosanta punkto, ĝi povas esti malkonstruita en # >>> truncate_number(3.5)\n# 0.5\ntruncate_number <- function(number) {","canonical_solution":"truncate_number <- function(number) {\n  return(number - floor(number))\n}","tests":"test_humaneval <- function() {\n    candidate <- truncate_number\n    stopifnot(isTRUE(all.equal(candidate(3.5), 0.5)))\n    stopifnot(isTRUE(all.equal(candidate(1.25), 0.25)))\n    stopifnot(isTRUE(all.equal(candidate(123.0), 0.0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_3","nl":"epo_Latn","pl":"r","prompt":"en tiu punkto funkcio devus resendi TRUE. Alie ĝi devus resendi FALSE. Via tasko estas detekti se iam la ekvilibro de konto falas sub nul, kaj Oni donas al vi liston de la agadoj pri retiro kaj depono en la banko, kiu komenciĝas per # >>> below_zero(c(1, 2, 3))\n# FALSE\n# >>> below_zero(c(1, 2, -4, 5))\n# TRUE\nbelow_zero <- function(operations) {","canonical_solution":"below_zero <- function(operations) {\n  balance <- 0\n  for (op in operations) {\n    balance <- balance + op\n    if (balance < 0) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- below_zero\n    stopifnot(isTRUE(all.equal(candidate(c()), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -3, 1, 2, -3)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, -4, 5, 6)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 2, -2, 5, -5, 4, -5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -2, 2, -2, 5, -5, 4, -4)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_4","nl":"epo_Latn","pl":"r","prompt":"MAD = averaĝo. x - x_ averaĝo.elemento kaj centro (meznombro en tiu kazo): Mean Absolute Deviation estas la averaĝa absoluta diferenco inter ĉiu ĉirkaŭ la mezumo de tiu datumo. Por donita listo de enigaj nombroj, kalkulu Mean Absolute Deviation # >>> mean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))\n# 1.0\nmean_absolute_deviation <- function(numbers) {","canonical_solution":"mean_absolute_deviation <- function(numbers) {\n  x_mean <- mean(numbers)\n  mad <- mean(abs(numbers - x_mean))\n  return(mad)\n}\n\n# Example usage\nmean_absolute_deviation(c(1.0, 2.0, 3.0, 4.0))","tests":"test_humaneval <- function() {\n    candidate <- mean_absolute_deviation\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0)), 0.5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0)), 1.0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), 1.2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_5","nl":"epo_Latn","pl":"r","prompt":"Enmetu nombron \"limigilo\" inter ĉiu du sinsekvaj elementoj de eniga listo `numeroj\" # >>> intersperse(c(), 4)\n# c()\n# >>> intersperse(c(1, 2, 3), 4)\n# c(1, 4, 2, 4, 3)\nintersperse <- function(numbers, delimeter) {","canonical_solution":"intersperse <- function(numbers, delimeter) {\n  if (length(numbers) <= 1) {\n    return(numbers)\n  }\n  result <- c()\n  for (i in 1:(length(numbers) - 1)) {\n    result <- c(result, numbers[i], delimeter)\n  }\n  result <- c(result, numbers[length(numbers)])\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- intersperse\n    stopifnot(isTRUE(all.equal(candidate(c(), 7), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 2), 8), c(5, 8, 6, 8, 3, 8, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 2, 2), 2), c(2, 2, 2, 2, 2))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_6","nl":"epo_Latn","pl":"r","prompt":"Ekz. (() (()) havas maksimume du nivelojn de nestado dum ((())) havas tri. Por ĉiu el la grupo, elŝutu la plej profundan nivelon de nestado de krampoj. Enigo al tiu funkcio estas ŝnuro reprezentita multoblaj grupoj por nestitaj krampoj apartigitaj de spacoj.# >>> parse_nested_parens('(()()) ((())) () ((())()())')\n# c(2, 3, 1, 3)\nparse_nested_parens <- function(paren_string) {","canonical_solution":"parse_nested_parens <- function(paren_string) {\n  sapply(strsplit(paren_string, \" \")[[1]], function(group) {\n    max_nesting <- 0\n    current_nesting <- 0\n    for (char in strsplit(group, \"\")[[1]]) {\n      if (char == \"(\") {\n        current_nesting <- current_nesting + 1\n        max_nesting <- max(max_nesting, current_nesting)\n      } else if (char == \")\") {\n        current_nesting <- current_nesting - 1\n      }\n    }\n    return(max_nesting)\n  })\n}","tests":"test_humaneval <- function() {\n    candidate <- parse_nested_parens\n    stopifnot(isTRUE(all.equal(candidate('(()()) ((())) () ((())()())'), c(2, 3, 1, 3))))\n    stopifnot(isTRUE(all.equal(candidate('() (()) ((())) (((())))'), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate('(()(())((())))'), c(4))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_7","nl":"epo_Latn","pl":"r","prompt":"Filtru enir-liston de ĉenetoj nur por tiuj, kiuj enhavas la donitan subĉenon # >>> filter_by_substring(c(), 'a')\n# c()\n# >>> filter_by_substring(c('abc', 'bacd', 'cde', 'array'), 'a')\n# c('abc', 'bacd', 'array')\nfilter_by_substring <- function(strings, substring) {","canonical_solution":"filter_by_substring <- function(strings, substring) {\n  return(strings[grepl(substring, strings)])\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_by_substring\n    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'), 'xx'), c('xxx', 'aaaxxy', 'xxxAAA', 'xxx'))))\n    stopifnot(isTRUE(all.equal(candidate(c('grunt', 'trumpet', 'prune', 'gruesome'), 'run'), c('grunt', 'prune'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_8","nl":"epo_Latn","pl":"r","prompt":"Malplena sumo devas egali al 0 kaj malplena produkto devas egali al 1. Por donita listo de entjeroj, redonu liston konsistantan el sumo kaj produkto de ĉiuj entjeroj en listo. # >>> sum_product(c())\n# c(0, 1)\n# >>> sum_product(c(1, 2, 3, 4))\n# c(10, 24)\nsum_product <- function(numbers) {","canonical_solution":"sum_product <- function(numbers) {\n  sum_val <- sum(numbers)\n  prod_val <- ifelse(length(numbers) == 0, 1, prod(numbers))\n  return(c(sum_val, prod_val))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_product\n    stopifnot(isTRUE(all.equal(candidate(c()), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1)), c(3, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 0)), c(100, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 7)), c(15, 105))))\n    stopifnot(isTRUE(all.equal(candidate(c(10)), c(10, 10))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_9","nl":"epo_Latn","pl":"r","prompt":"en la sekvenco.El donita listo de entjeroj, generu liston de ruliĝantaj maksimumaj elementoj trovitaj ĝis donita momento # >>> rolling_max(c(1, 2, 3, 2, 3, 4, 2))\n# c(1, 2, 3, 3, 3, 4, 4)\nrolling_max <- function(numbers) {","canonical_solution":"rolling_max <- function(numbers) {\n  max_list <- c()\n  current_max <- -Inf\n  for (number in numbers) {\n    current_max <- max(current_max, number)\n    max_list <- c(max_list, current_max)\n  }\n  return(max_list)\n}","tests":"test_humaneval <- function() {\n    candidate <- rolling_max\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 1)), c(4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3, 100, 3)), c(3, 3, 3, 100, 100))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_10","nl":"epo_Latn","pl":"r","prompt":"- Aldonu al la fino de la ŝnuro inversan de ŝnuro prefikso kiu venas antaŭ la palindroma sufikso.- Trovu la plej longan postfikson de provizita ŝnuro, kiu estas palindromo. La ideo de la algoritmo estas simpla: Trovu la plej mallongan palindron kiu komenciĝas per la provizita kordo.# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n# 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\nmake_palindrome <- function(string) {","canonical_solution":"make_palindrome <- function(string) {\n  is_palindrome <- function(s) {\n    return(s == stringi::stri_reverse(s))\n  }\n  \n  n <- nchar(string)\n  \n  for (i in seq(n, 0, by = -1)) {\n    suffix <- substr(string, i, n)\n    if (is_palindrome(suffix)) {\n      prefix <- substr(string, 1, i - 1)\n      return(paste0(string, stringi::stri_reverse(prefix)))\n    }\n  }\n  \n  return(string) # for the empty string case\n}","tests":"test_humaneval <- function() {\n    candidate <- make_palindrome\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('x'), 'x')))\n    stopifnot(isTRUE(all.equal(candidate('xyz'), 'xyzyx')))\n    stopifnot(isTRUE(all.equal(candidate('xyx'), 'xyx')))\n    stopifnot(isTRUE(all.equal(candidate('jerry'), 'jerryrrej')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_11","nl":"epo_Latn","pl":"r","prompt":"Plenumu binaran XOR sur tiuj enigaĵoj kaj resendu rezulton ankaŭ kiel ŝnuro.Enputo estas du kodoj a kaj b kiuj konsistas nur el 1oj kaj 0oj.# >>> string_xor('010', '110')\n# '100'\nstring_xor <- function(a, b) {","canonical_solution":"string_xor <- function(a, b) {\n  xor_result <- mapply(function(x, y) { \n    ifelse(x == y, 0, 1) \n  }, strsplit(a, NULL)[[1]], strsplit(b, NULL)[[1]])\n  return(paste(xor_result, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- string_xor\n    stopifnot(isTRUE(all.equal(candidate('111000', '101010'), '010010')))\n    stopifnot(isTRUE(all.equal(candidate('1', '1'), '0')))\n    stopifnot(isTRUE(all.equal(candidate('0101', '0000'), '0101')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_12","nl":"epo_Latn","pl":"r","prompt":"Return NULL en kazo la eniga listo estas malplena. El la listo de ŝnuroj, redonu la plej longan. Redonu la unuan en kazo de multobla # >>> longest(c())\n# NULL\n# >>> longest(c('a', 'b', 'c'))\n# 'a'\n# >>> longest(c('a', 'bb', 'ccc'))\n# 'ccc'\nlongest <- function(strings) {","canonical_solution":"longest <- function(strings) {\n  if (length(strings) == 0) return(NULL)\n  longest_string <- strings[1]\n  for (s in strings) {\n    if (nchar(s) > nchar(longest_string)) {\n      longest_string <- s\n    }\n  }\n  return(longest_string)\n}","tests":"test_humaneval <- function() {\n    candidate <- longest\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'x')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc')), 'zzzz')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_13","nl":"epo_Latn","pl":"r","prompt":"Redonu la plej grandan komunan dividanton de du entjeroj a kaj b # >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\ngreatest_common_divisor <- function(a, b) {","canonical_solution":"greatest_common_divisor <- function(a, b) {\n  while (b != 0) {\n    temp <- b\n    b <- a %% b\n    a <- temp\n  }\n  return(abs(a))\n}","tests":"test_humaneval <- function() {\n    candidate <- greatest_common_divisor\n    stopifnot(isTRUE(all.equal(candidate(3, 7), 1)))\n    stopifnot(isTRUE(all.equal(candidate(10, 15), 5)))\n    stopifnot(isTRUE(all.equal(candidate(49, 14), 7)))\n    stopifnot(isTRUE(all.equal(candidate(144, 60), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_14","nl":"epo_Latn","pl":"r","prompt":"Revenigas liston de ĉiuj prefiksoj de plej mallonga ĝis plej longa de la eniga ŝnuro # >>> all_prefixes('abc')\n# c('a', 'ab', 'abc')\nall_prefixes <- function(string) {","canonical_solution":"all_prefixes <- function(string) {\n  prefixes <- character(nchar(string))\n  for (i in seq_along(prefixes)) {\n    prefixes[i] <- substr(string, 1, i)\n  }\n  return(prefixes)\n}","tests":"test_humaneval <- function() {\n    candidate <- all_prefixes\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('asdfgh'), c('a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'))))\n    stopifnot(isTRUE(all.equal(candidate('WWW'), c('W', 'WW', 'WWW'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_15","nl":"epo_Latn","pl":"r","prompt":"Redonu ŝnuron enhavanta spac-limigitajn nombrojn komencantajn de 0 ĝis n inkluzive. # >>> string_sequence(0)\n# '0'\n# >>> string_sequence(5)\n# '0 1 2 3 4 5'\nstring_sequence <- function(n) {","canonical_solution":"string_sequence <- function(n) {\n  return(paste(0:n, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- string_sequence\n    stopifnot(isTRUE(all.equal(candidate(0), '0')))\n    stopifnot(isTRUE(all.equal(candidate(3), '0 1 2 3')))\n    stopifnot(isTRUE(all.equal(candidate(10), '0 1 2 3 4 5 6 7 8 9 10')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_16","nl":"epo_Latn","pl":"r","prompt":"Se oni donas al vi ĉenon, trovu kiom da apartajn signojn ĝi havas (senkonsidere la ĉefsignon).# >>> count_distinct_characters('xyzXYZ')\n# 3\n# >>> count_distinct_characters('Jerry')\n# 4\ncount_distinct_characters <- function(string) {","canonical_solution":"count_distinct_characters <- function(string) {\n  # Convert the string to lowercase to handle case insensitivity\n  lower_string <- tolower(string)\n  # Split the string into individual characters\n  chars <- strsplit(lower_string, NULL)[[1]]\n  # Find the unique characters and count them\n  distinct_count <- length(unique(chars))\n  return(distinct_count)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_distinct_characters\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('abcde'), 5)))\n    stopifnot(isTRUE(all.equal(candidate('abcdecadeCADE'), 5)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaAAAAaaaa'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('Jerry jERRY JeRRRY'), 5)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_17","nl":"epo_Latn","pl":"r","prompt":"\"Hej, vi estas mojosa\". \"Mia konjekto estas, ke ĉiu kvara noto estas tre grava.\"O\" estas duonnota kaj daŭras du taktojn.'O' - tuta noto, daŭras kvar taktojn Jen legendo:Ne la lasta.Via tasko estas analizi ĉi tiun ŝnuron kaj resendi liston de entjeroj, kiuj respondas al kiom da taktoj ĉiu havas.Enigo al tiu funkcio estas kordo reprezentanta muzikajn notojn en speciala ASCII-formato.# >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)\nparse_music <- function(music_string) {","canonical_solution":"parse_music <- function(music_string) {\n  # Split the input string by spaces to get individual notes\n  notes <- strsplit(music_string, \" \")[[1]]\n  \n  # Map each note to its corresponding beat duration\n  beats <- sapply(notes, function(note) {\n    if (note == 'o') {\n      return(4)\n    } else if (note == 'o|') {\n      return(2)\n    } else if (note == '.|') {\n      return(1)\n    } else {\n      stop(\"Invalid note\")\n    }\n  })\n  \n  return(beats)\n}\n\n# Example usage:\n# parse_music('o o| .| o| o| .| .| .| .| o o')\n# c(4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4)","tests":"test_humaneval <- function() {\n    candidate <- parse_music\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('o o o o'), c(4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate('.| .| .| .|'), c(1, 1, 1, 1))))\n    stopifnot(isTRUE(all.equal(candidate('o| o| .| .| o o o o'), c(2, 2, 1, 1, 4, 4, 4, 4))))\n    stopifnot(isTRUE(all.equal(candidate('o| .| o| .| o o| o o|'), c(2, 1, 2, 1, 4, 2, 4, 2))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_18","nl":"epo_Latn","pl":"r","prompt":"Trovu kiom da fojoj donita subĉeno povas esti trovita en la origina ĉeno. Kalkulu interkovrantajn kazojn. # >>> how_many_times('', 'a')\n# 0\n# >>> how_many_times('aaa', 'a')\n# 3\n# >>> how_many_times('aaaa', 'aa')\n# 3\nhow_many_times <- function(string, substring) {","canonical_solution":"how_many_times <- function(string, substring) {\n  if (nchar(substring) == 0) {\n    return(0)\n  }\n  \n  count <- 0\n  for (i in seq(nchar(string) - nchar(substring) + 1)) {\n    if (substr(string, i, i + nchar(substring) - 1) == substring) {\n      count <- count + 1\n    }\n  }\n  \n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- how_many_times\n    stopifnot(isTRUE(all.equal(candidate('', 'x'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('xyxyxyx', 'x'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('cacacacac', 'cac'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('john doe', 'john'), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_19","nl":"epo_Latn","pl":"r","prompt":"La nombro de la ĉeno estas aranĝita de la plej malgranda ĝis la plej granda.Validaj elektoj estas 'nulo', 'unu', 'du', 'tri', 'kvar', 'kvin', 'ses', 'sep', 'ok' kaj 'naŭ'. Enigo estas spac-difinita ŝnuro de numeraloj de \"nulo\" ĝis \"naŭ\".# >>> sort_numbers('three one five')\n# 'one three five'\nsort_numbers <- function(numbers) {","canonical_solution":"sort_numbers <- function(numbers) {\n  words_to_numbers <- c(\n    \"zero\" = 0, \"one\" = 1, \"two\" = 2, \"three\" = 3, \"four\" = 4, \n    \"five\" = 5, \"six\" = 6, \"seven\" = 7, \"eight\" = 8, \"nine\" = 9\n  )\n  \n  number_list <- strsplit(numbers, \" \")[[1]]\n  sorted_numbers <- number_list[order(sapply(number_list, function(word) words_to_numbers[word]))]\n  return(paste(sorted_numbers, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_numbers\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('three'), 'three')))\n    stopifnot(isTRUE(all.equal(candidate('three five nine'), 'three five nine')))\n    stopifnot(isTRUE(all.equal(candidate('five zero four seven nine eight'), 'zero four five seven eight nine')))\n    stopifnot(isTRUE(all.equal(candidate('six five four three two one zero'), 'zero one two three four five six')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_20","nl":"epo_Latn","pl":"r","prompt":"aliajn kaj redonu ilin en ordo (pli malgranda nombro, pli granda nombro).El la provizita listo de nombroj (de longo almenaŭ du) elektu kaj redonu du, kiuj estas la plej proksimaj al ĉiu # >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n# c(2.0, 2.2)\n# >>> find_closest_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n# c(2.0, 2.0)\nfind_closest_elements <- function(numbers) {","canonical_solution":"find_closest_elements <- function(numbers) {\n  sorted_numbers <- sort(numbers)\n  min_diff <- Inf\n  closest_pair <- c()\n\n  for (i in 1:(length(sorted_numbers) - 1)) {\n    diff <- sorted_numbers[i + 1] - sorted_numbers[i]\n    if (diff < min_diff) {\n      min_diff <- diff\n      closest_pair <- c(sorted_numbers[i], sorted_numbers[i + 1])\n    }\n  }\n\n  return(closest_pair)\n}","tests":"test_humaneval <- function() {\n    candidate <- find_closest_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), c(3.9, 4.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 5.9, 4.0, 5.0)), c(5.0, 5.9))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)), c(2.0, 2.2))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), c(2.0, 2.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.1, 2.2, 3.1, 4.1, 5.1)), c(2.2, 3.1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_21","nl":"epo_Latn","pl":"r","prompt":"la plej malgranda numero fariĝos 0 kaj la plej granda nombro estos 1.Donita listo de nombroj (de almenaŭ du elementoj), apliki linian transformon al tiu listo, # >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n# c(0.0, 0.25, 0.5, 0.75, 1.0)\nrescale_to_unit <- function(numbers) {","canonical_solution":"rescale_to_unit <- function(numbers) {\n  min_val <- min(numbers)\n  max_val <- max(numbers)\n  (numbers - min_val) \/ (max_val - min_val)\n}","tests":"test_humaneval <- function() {\n    candidate <- rescale_to_unit\n    stopifnot(isTRUE(all.equal(candidate(c(2.0, 49.9)), c(0.0, 1.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(100.0, 49.9)), c(1.0, 0.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0, 4.0, 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))))\n    stopifnot(isTRUE(all.equal(candidate(c(2.0, 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))\n    stopifnot(isTRUE(all.equal(candidate(c(12.0, 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_22","nl":"epo_Latn","pl":"r","prompt":"Filtru donitan liston de ajnaj rthon valoroj nur por entjeroj # >>> filter_integers(list('a', 3.14, 5))\n# c(5)\n# >>> filter_integers(list(1, 2, 3, 'abc', list(), c()))\n# c(1, 2, 3)\nfilter_integers <- function(values) {","canonical_solution":"filter_integers <- function(values) {\n  return(unlist(Filter(is.integer, values)))\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_integers\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(4, list(), c(), 23.2, 9, 'adasd')), c(4, 9))))\n    stopifnot(isTRUE(all.equal(candidate(list(3, 'c', 3, 3, 'a', 'b')), c(3, 3, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_23","nl":"epo_Latn","pl":"r","prompt":"Revenigu longon de donita ŝnuro # >>> strlen('')\n# 0\n# >>> strlen('abc')\n# 3\nstrlen <- function(string) {","canonical_solution":"strlen <- function(string) {\n  return(nchar(string))\n}","tests":"test_humaneval <- function() {\n    candidate <- strlen\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('x'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('asdasnakj'), 9)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_24","nl":"epo_Latn","pl":"r","prompt":"Por iu n-nombro, ni serĉu la plej grandan nombron kiu dividas n egale, pli malgrandan ol n.# >>> largest_divisor(15)\n# 5\nlargest_divisor <- function(n) {","canonical_solution":"largest_divisor <- function(n) {\n  for (i in (n-1):1) {\n    if (n %% i == 0) {\n      return(i)\n    }\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_divisor\n    stopifnot(isTRUE(all.equal(candidate(3), 1)))\n    stopifnot(isTRUE(all.equal(candidate(7), 1)))\n    stopifnot(isTRUE(all.equal(candidate(10), 5)))\n    stopifnot(isTRUE(all.equal(candidate(100), 50)))\n    stopifnot(isTRUE(all.equal(candidate(49), 7)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_25","nl":"epo_Latn","pl":"r","prompt":"La eniga nombro devas egali la produkton de ĉiuj faktoroj.Ĉiu el la faktoroj devas esti listigita nombro da fojoj, kiuj respondas al kiom da fojoj ĝi aperas en faktorigo.Revenigas liston de primoj de donita entjero en la ordo de plej malgranda ĝis plej granda.# >>> factorize(8)\n# c(2, 2, 2)\n# >>> factorize(25)\n# c(5, 5)\n# >>> factorize(70)\n# c(2, 5, 7)\nfactorize <- function(n) {","canonical_solution":"factorize <- function(n) {\n  if (n < 2) {\n    return(c())\n  }\n  factors <- c()\n  divisor <- 2\n  \n  while (n > 1) {\n    while (n %% divisor == 0) {\n      factors <- c(factors, divisor)\n      n <- n \/ divisor\n    }\n    divisor <- divisor + 1\n  }\n  \n  return(factors)\n}","tests":"test_humaneval <- function() {\n    candidate <- factorize\n    stopifnot(isTRUE(all.equal(candidate(2), c(2))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(2, 2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(57), c(3, 19))))\n    stopifnot(isTRUE(all.equal(candidate(3249), c(3, 3, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(185193), c(3, 3, 3, 19, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(20577), c(3, 19, 19, 19))))\n    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_26","nl":"epo_Latn","pl":"r","prompt":"Konservu ordo de elementoj lasita la sama kiel en la enigaĵo.El listo de entjeroj, forigu ĉiujn elementojn, kiuj aperas pli ol unufoje.# >>> remove_duplicates(c(1, 2, 3, 2, 4))\n# c(1, 3, 4)\nremove_duplicates <- function(numbers) {","canonical_solution":"remove_duplicates <- function(numbers) {\n  unique_numbers <- numbers[!duplicated(numbers) & !duplicated(numbers, fromLast = TRUE)]\n  return(unique_numbers)\n}","tests":"test_humaneval <- function() {\n    candidate <- remove_duplicates\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 4, 3, 5)), c(1, 4, 5))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_27","nl":"epo_Latn","pl":"r","prompt":"Por donita ŝnuro, turnu minusklojn al ĉeflitero kaj ĉeflitero al minusklo. # >>> flip_case('Hello')\n# 'hELLO'\nflip_case <- function(string) {","canonical_solution":"flip_case <- function(string) {\n  chars <- strsplit(string, NULL)[[1]]\n  flipped_chars <- sapply(chars, function(c) {\n    if (grepl(\"[a-z]\", c)) {\n      return(toupper(c))\n    } else if (grepl(\"[A-Z]\", c)) {\n      return(tolower(c))\n    } else {\n      return(c)\n    }\n  })\n  return(paste(flipped_chars, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- flip_case\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('Hello!'), 'hELLO!')))\n    stopifnot(isTRUE(all.equal(candidate('These violent delights have violent ends'), 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_28","nl":"epo_Latn","pl":"r","prompt":"Konektigi liston de strekoj en unu simplan ŝnuron# >>> concatenate(c())\n# ''\n# >>> concatenate(c('a', 'b', 'c'))\n# 'abc'\nconcatenate <- function(strings) {","canonical_solution":"concatenate <- function(strings) {\n  paste(strings, collapse = \"\")\n}","tests":"test_humaneval <- function() {\n    candidate <- concatenate\n    stopifnot(isTRUE(all.equal(candidate(c()), '')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z')), 'xyz')))\n    stopifnot(isTRUE(all.equal(candidate(c('x', 'y', 'z', 'w', 'k')), 'xyzwk')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_29","nl":"epo_Latn","pl":"r","prompt":"Filtru enir-liston de ŝnuroj nur por tiuj, kiuj komenciĝas per antaŭfikso.# >>> filter_by_prefix(c(), 'a')\n# c()\n# >>> filter_by_prefix(c('abc', 'bcd', 'cde', 'array'), 'a')\n# c('abc', 'array')\nfilter_by_prefix <- function(strings, prefix) {","canonical_solution":"filter_by_prefix <- function(strings, prefix) {\n  return(strings[startsWith(strings, prefix)])\n}","tests":"test_humaneval <- function() {\n    candidate <- filter_by_prefix\n    stopifnot(isTRUE(all.equal(candidate(c(), 'john'), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'), 'xxx'), c('xxx', 'xxxAAA', 'xxx'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_30","nl":"epo_Latn","pl":"r","prompt":"Redonu nur pozitivajn nombrojn en la listo.# >>> get_positive(c(-1, 2, -4, 5, 6))\n# c(2, 5, 6)\n# >>> get_positive(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n# c(5, 3, 2, 3, 9, 123, 1)\nget_positive <- function(l) {","canonical_solution":"get_positive <- function(l) {\n  return(l[l > 0])\n}","tests":"test_humaneval <- function() {\n    candidate <- get_positive\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 4, 5, 6)), c(4, 5, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10)), c(5, 3, 2, 3, 3, 9, 123, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2)), c())))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_31","nl":"epo_Latn","pl":"r","prompt":"Redonu veran se donita nombro estas primo, kaj malvera alie. # >>> is_prime(6)\n# FALSE\n# >>> is_prime(101)\n# TRUE\n# >>> is_prime(11)\n# TRUE\n# >>> is_prime(13441)\n# TRUE\n# >>> is_prime(61)\n# TRUE\n# >>> is_prime(4)\n# FALSE\n# >>> is_prime(1)\n# FALSE\nis_prime <- function(n) {","canonical_solution":"is_prime <- function(n) {\n  if (n <= 1) {\n    return(FALSE)\n  }\n  if (n <= 3) {\n    return(TRUE)\n  }\n  if (n %% 2 == 0 || n %% 3 == 0) {\n    return(FALSE)\n  }\n  i <- 5\n  while (i * i <= n) {\n    if (n %% i == 0 || n %% (i + 2) == 0) {\n      return(FALSE)\n    }\n    i <- i + 6\n  }\n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_prime\n    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(101), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(13441), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(61), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(17), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(85), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(77), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(255379), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_33","nl":"epo_Latn","pl":"r","prompt":"al la valoroj de la ekvivalentaj indeksoj de l, sed ordigitaj.l' estas identa al l en la indeksoj kiuj ne estas divideblaj per tri, dum ĝiaj valoroj ĉe la indeksoj kiuj estas divideblaj per tri estas egalaj Tiu funkcio prenas liston l kaj resendas liston l' tia ke # >>> sort_third(c(1, 2, 3))\n# c(1, 2, 3)\n# >>> sort_third(c(5, 6, 3, 4, 8, 9, 2))\n# c(2, 6, 3, 4, 8, 9, 5)\nsort_third <- function(l) {","canonical_solution":"sort_third <- function(l) {\n  # Find the indices that are divisible by three\n  indices_div_by_3 <- seq(3, length(l), by = 3)\n  \n  # Extract the elements at those indices and sort them\n  elements_to_sort <- l[indices_div_by_3]\n  sorted_elements <- sort(elements_to_sort)\n  \n  # Replace the original elements at those indices with sorted ones\n  l[indices_div_by_3] <- sorted_elements\n  \n  return(l)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_third\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2)), c(2, 6, 3, 4, 8, 9, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 3, 4, 6, 9, 2)), c(2, 8, 3, 4, 6, 9, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 9, 4, 8, 3, 2)), c(2, 6, 9, 4, 8, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 3, 4, 8, 9, 2, 1)), c(2, 6, 3, 4, 8, 9, 5, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_34","nl":"epo_Latn","pl":"r","prompt":"Ĝi resendas ordigitajn unikajn elementojn en listo # >>> unique(c(5, 3, 5, 2, 3, 3, 9, 0, 123))\n# c(0, 2, 3, 5, 9, 123)\nunique <- function(l) {","canonical_solution":"unique <- function(l) {\n  return(sort(unique(l)))\n}","tests":"test_humaneval <- function() {\n    candidate <- unique\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 5, 2, 3, 3, 9, 0, 123)), c(0, 2, 3, 5, 9, 123))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_35","nl":"epo_Latn","pl":"r","prompt":"Redonu la maksimuman elementon en la listo.# >>> max_element(c(1, 2, 3))\n# 3\n# >>> max_element(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n# 123\nmax_element <- function(l) {","canonical_solution":"max_element <- function(l) {\n  return(max(l))\n}","tests":"test_humaneval <- function() {\n    candidate <- max_element\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10)), 124)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_36","nl":"epo_Latn","pl":"r","prompt":"Redonu la nombron de fojoj, kiam la cifero 7 aperas en entjeroj malpli ol n, kiuj estas divideblaj per 11 aŭ 13. # >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n# 2\n# >>> fizz_buzz(79)\n# 3\nfizz_buzz <- function(n) {","canonical_solution":"fizz_buzz <- function(n) {\n  count <- 0\n  for (i in 1:(n-1)) {\n    if (i %% 11 == 0 || i %% 13 == 0) {\n      count <- count + sum(unlist(strsplit(as.character(i), \"\")) == \"7\")\n    }\n  }\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- fizz_buzz\n    stopifnot(isTRUE(all.equal(candidate(50), 0)))\n    stopifnot(isTRUE(all.equal(candidate(78), 2)))\n    stopifnot(isTRUE(all.equal(candidate(79), 3)))\n    stopifnot(isTRUE(all.equal(candidate(100), 3)))\n    stopifnot(isTRUE(all.equal(candidate(200), 6)))\n    stopifnot(isTRUE(all.equal(candidate(4000), 192)))\n    stopifnot(isTRUE(all.equal(candidate(10000), 639)))\n    stopifnot(isTRUE(all.equal(candidate(100000), 8026)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_37","nl":"epo_Latn","pl":"r","prompt":"al la valoroj de la eĉ indicoj de l, sed ordigita. l' estas identa al l en la neparaj indeksoj, dum ĝiaj valoroj ĉe la paraj indeksoj estas egalaj Tiu funkcio prenas liston l kaj resendas liston l' tia ke # >>> sort_even(c(1, 2, 3))\n# c(1, 2, 3)\n# >>> sort_even(c(5, 6, 3, 4))\n# c(3, 6, 5, 4)\nsort_even <- function(l) {","canonical_solution":"sort_even <- function(l) {\n  even_indices <- seq(2, length(l), by=2)\n  l[even_indices] <- sort(l[even_indices])\n  return(l)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_even\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(1, 2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)), c(-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, -12, 4, 23, 2, 3, 11, 12, -10)), c(-12, 8, 3, 4, 5, 2, 12, 11, 23, -10))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_39","nl":"epo_Latn","pl":"r","prompt":"prime_fib donas la n-an nombron kiu estas Fibonacci-nombro kaj ankaŭ estas primo. # >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n# 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\nprime_fib <- function(n) {","canonical_solution":"prime_fib <- function(n) {\n  is_prime <- function(num) {\n    if (num < 2) return(FALSE)\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  fibonacci <- function() {\n    a <- 0\n    b <- 1\n    while (TRUE) {\n      yield <- a + b\n      a <<- b\n      b <<- yield\n      yield\n    }\n  }\n  \n  fib_gen <- fibonacci()\n  count <- 0\n  repeat {\n    current_fib <- fib_gen()\n    if (is_prime(current_fib)) {\n      count <- count + 1\n      if (count == n) return(current_fib)\n    }\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- prime_fib\n    stopifnot(isTRUE(all.equal(candidate(1), 2)))\n    stopifnot(isTRUE(all.equal(candidate(2), 3)))\n    stopifnot(isTRUE(all.equal(candidate(3), 5)))\n    stopifnot(isTRUE(all.equal(candidate(4), 13)))\n    stopifnot(isTRUE(all.equal(candidate(5), 89)))\n    stopifnot(isTRUE(all.equal(candidate(6), 233)))\n    stopifnot(isTRUE(all.equal(candidate(7), 1597)))\n    stopifnot(isTRUE(all.equal(candidate(8), 28657)))\n    stopifnot(isTRUE(all.equal(candidate(9), 514229)))\n    stopifnot(isTRUE(all.equal(candidate(10), 433494437)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_40","nl":"epo_Latn","pl":"r","prompt":"sumo al nulo, kaj FALSO alie. ĝi resendas TRUE se estas tri apartaj elementoj en la listo kiuj triples_sum_to_zero prenas liston de entjeroj kiel enigaĵon.# >>> triples_sum_to_zero(c(1, 3, 5, 0))\n# FALSE\n# >>> triples_sum_to_zero(c(1, 3, -2, 1))\n# TRUE\n# >>> triples_sum_to_zero(c(1, 2, 3, 7))\n# FALSE\n# >>> triples_sum_to_zero(c(2, 4, -5, 3, 9, 7))\n# TRUE\n# >>> triples_sum_to_zero(c(1))\n# FALSE\ntriples_sum_to_zero <- function(l) {","canonical_solution":"triples_sum_to_zero <- function(l) {\n  n <- length(l)\n  if (n < 3) {\n    return(FALSE)\n  }\n  for (i in 1:(n - 2)) {\n    for (j in (i + 1):(n - 1)) {\n      for (k in (j + 1):n) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return(TRUE)\n        }\n      }\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- triples_sum_to_zero\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 5, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 9, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, -100)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 3, 5, -100)), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_41","nl":"epo_Latn","pl":"r","prompt":"Tiu funkcio produktas la nombron de tiaj kolizioj. en ilia trajektorio, kvazaŭ ili ne kolizius.Sed la aŭto estas tre forta. Ĝi estas tre forta. Sekve, ĝi ne ĉesas moviĝi.kiam la aŭto movas de dekstre al dekstre kaj ĝi koliziigas la aŭton de dekstre al maldekstre.Ĉiuj aŭtoj moviĝas kun la sama rapido. Oni diras, ke du aŭtoj kolizias.La du apartaj veturiloj komenciĝas tre malproksime de lan aŭtoj moviĝas de maldekstre al dekstre; samtempe, malsama aro de n aŭtoj Imagu straton perfekte rektan, senliman linion.car_race_collision <- function(n) {","canonical_solution":"car_race_collision <- function(n) {\n  # Each car moving left to right will eventually collide with each car moving right to left\n  return(n)\n}","tests":"test_humaneval <- function() {\n    candidate <- car_race_collision\n    stopifnot(isTRUE(all.equal(candidate(2), 4)))\n    stopifnot(isTRUE(all.equal(candidate(3), 9)))\n    stopifnot(isTRUE(all.equal(candidate(4), 16)))\n    stopifnot(isTRUE(all.equal(candidate(8), 64)))\n    stopifnot(isTRUE(all.equal(candidate(10), 100)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_42","nl":"epo_Latn","pl":"r","prompt":"Revenanta listo kun elementoj pliigitaj je 1.# >>> incr_list(c(1, 2, 3))\n# c(2, 3, 4)\n# >>> incr_list(c(5, 3, 5, 2, 3, 3, 9, 0, 123))\n# c(6, 4, 6, 3, 4, 4, 10, 1, 124)\nincr_list <- function(l) {","canonical_solution":"incr_list <- function(l) {\n  return(l + 1)\n}","tests":"test_humaneval <- function() {\n    candidate <- incr_list\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(4, 3, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 2, 5, 2, 3, 3, 9, 0, 123)), c(6, 3, 6, 3, 4, 4, 10, 1, 124))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_43","nl":"epo_Latn","pl":"r","prompt":"sumo al nulo, kaj FALSO alie. ĝi resendas TRUE se estas du apartaj elementoj en la listo kiuj pairs_sum_to_zero prenas liston de entjeroj kiel enigaĵon. # >>> pairs_sum_to_zero(c(1, 3, 5, 0))\n# FALSE\n# >>> pairs_sum_to_zero(c(1, 3, -2, 1))\n# FALSE\n# >>> pairs_sum_to_zero(c(1, 2, 3, 7))\n# FALSE\n# >>> pairs_sum_to_zero(c(2, 4, -5, 3, 5, 7))\n# TRUE\n# >>> pairs_sum_to_zero(c(1))\n# FALSE\npairs_sum_to_zero <- function(l) {","canonical_solution":"pairs_sum_to_zero <- function(l) {\n  n <- length(l)\n  if (n < 2) return(FALSE)\n  \n  for (i in 1:(n-1)) {\n    for (j in (i+1):n) {\n      if (l[i] + l[j] == 0) {\n        return(TRUE)\n      }\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- pairs_sum_to_zero\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 5, 0)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, -2, 1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, -5, 3, 5, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 30)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 3, 2, 31)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 30)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 9, -1, 4, 2, 31)), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_44","nl":"epo_Latn","pl":"r","prompt":"la nombro da bazaj eroj estas malpli ol 10.return ŝnuro reprezentado post la konvertiĝo. Ŝanĝu la nombran bazon de la eniga nombro x al la bazo.# >>> change_base(8, 3)\n# '22'\n# >>> change_base(8, 2)\n# '1000'\n# >>> change_base(7, 2)\n# '111'\nchange_base <- function(x, base) {","canonical_solution":"change_base <- function(x, base) {\n  if (x == 0) return('0')\n  result <- ''\n  while (x > 0) {\n    remainder <- x %% base\n    result <- paste0(remainder, result)\n    x <- x %\/% base\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- change_base\n    stopifnot(isTRUE(all.equal(candidate(8, 3), '22')))\n    stopifnot(isTRUE(all.equal(candidate(9, 3), '100')))\n    stopifnot(isTRUE(all.equal(candidate(234, 2), '11101010')))\n    stopifnot(isTRUE(all.equal(candidate(16, 2), '10000')))\n    stopifnot(isTRUE(all.equal(candidate(8, 2), '1000')))\n    stopifnot(isTRUE(all.equal(candidate(7, 2), '111')))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), '2')))\n    stopifnot(isTRUE(all.equal(candidate(3, 4), '3')))\n    stopifnot(isTRUE(all.equal(candidate(4, 5), '4')))\n    stopifnot(isTRUE(all.equal(candidate(5, 6), '5')))\n    stopifnot(isTRUE(all.equal(candidate(6, 7), '6')))\n    stopifnot(isTRUE(all.equal(candidate(7, 8), '7')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_45","nl":"epo_Latn","pl":"r","prompt":"Laŭ la longo de la latero kaj alta reveno areo por triangulo.# >>> triangle_area(5, 3)\n# 7.5\ntriangle_area <- function(a, h) {","canonical_solution":"triangle_area <- function(a, h) {\n  return(0.5 * a * h)\n}","tests":"test_humaneval <- function() {\n    candidate <- triangle_area\n    stopifnot(isTRUE(all.equal(candidate(5, 3), 7.5)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2), 2.0)))\n    stopifnot(isTRUE(all.equal(candidate(10, 8), 40.0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_46","nl":"epo_Latn","pl":"r","prompt":"Bonvolu skribi funkcion por efike kalkuli la n-an elementon de la fib4-numera sekvenco. Ne uzu rekursion. fib4{\\displaystyle \\mathbb {f} } n) -> fib4{\\displaystyle \\mathbb {n} } n-1) + fib4{\\displaystyle \\mathbb {n} } n-2) + fib4{\\displaystyle \\mathbb {n} } n-3) + fib4{\\displaystyle \\mathbb {n} } n-4).fib4{\\ 3} -> 0 fib4{\\ pos (2,}) -> 2 fib4{\\displaystyle fib_{4}} 1) -> 0 fib4{\\displaystyle fib_{\\text{4}}} -> 0 La sekvenco de nombroj Fib4 estas sekvenco simila al la sekvenco de Fibbonacci kiu estas difinita jene: # >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n# 14\nfib4 <- function(n) {","canonical_solution":"fib4 <- function(n) {\n  if (n == 0) return(0)\n  if (n == 1) return(0)\n  if (n == 2) return(2)\n  if (n == 3) return(0)\n  \n  fib_seq <- c(0, 0, 2, 0) # Initialize with base cases\n  for (i in 4:n) {\n    fib_seq[i] <- fib_seq[i-1] + fib_seq[i-2] + fib_seq[i-3] + fib_seq[i-4]\n  }\n  return(fib_seq[n])\n}","tests":"test_humaneval <- function() {\n    candidate <- fib4\n    stopifnot(isTRUE(all.equal(candidate(5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(8), 28)))\n    stopifnot(isTRUE(all.equal(candidate(10), 104)))\n    stopifnot(isTRUE(all.equal(candidate(12), 386)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_47","nl":"epo_Latn","pl":"r","prompt":"Revendigu medianon de elementoj en la listo l. # >>> median(c(3, 1, 2, 4, 5))\n# 3\n# >>> median(c(-10, 4, 6, 1000, 10, 20))\n# 15.0\nmedian <- function(l) {","canonical_solution":"median <- function(l) {\n  return(median(l))\n}","tests":"test_humaneval <- function() {\n    candidate <- median\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10, 4, 6, 1000, 10, 20)), 8.0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 5)), 5.5)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 1, 3, 9, 9, 2, 7)), 7)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_48","nl":"epo_Latn","pl":"r","prompt":"Kontrolu, ĉu la donita ŝnuro estas palindromo # >>> is_palindrome('')\n# TRUE\n# >>> is_palindrome('aba')\n# TRUE\n# >>> is_palindrome('aaaaa')\n# TRUE\n# >>> is_palindrome('zbcd')\n# FALSE\nis_palindrome <- function(text) {","canonical_solution":"is_palindrome <- function(text) {\n  return(text == paste(rev(unlist(strsplit(text, NULL))), collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- is_palindrome\n    stopifnot(isTRUE(all.equal(candidate(''), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aba'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaa'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('zbcd'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('xywyx'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('xywyz'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('xywzx'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_49","nl":"epo_Latn","pl":"r","prompt":"Redonu 2^n modulo p (konsciu pri numerikoj).# >>> modp(3, 5)\n# 3\n# >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100, 101)\n# 1\nmodp <- function(n, p) {","canonical_solution":"modp <- function(n, p) {\n  result <- 1\n  base <- 2\n  \n  while (n > 0) {\n    if (n %% 2 == 1) {\n      result <- (result * base) %% p\n    }\n    base <- (base * base) %% p\n    n <- n %\/% 2\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- modp\n    stopifnot(isTRUE(all.equal(candidate(3, 5), 3)))\n    stopifnot(isTRUE(all.equal(candidate(1101, 101), 2)))\n    stopifnot(isTRUE(all.equal(candidate(0, 101), 1)))\n    stopifnot(isTRUE(all.equal(candidate(3, 11), 8)))\n    stopifnot(isTRUE(all.equal(candidate(100, 101), 1)))\n    stopifnot(isTRUE(all.equal(candidate(30, 5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(31, 5), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_51","nl":"epo_Latn","pl":"r","prompt":"remove_vowels estas funkcio kiu prenas ŝnuron kaj resendas ŝnuron sen vokaloj. # >>> remove_vowels('')\n# ''\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n# >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n# 'zbcd'\nremove_vowels <- function(text) {","canonical_solution":"remove_vowels <- function(text) {\n  gsub(\"[aeiouAEIOU]\", \"\", text)\n}","tests":"test_humaneval <- function() {\n    candidate <- remove_vowels\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('abcdef\\nghijklm'), 'bcdf\\nghjklm')))\n    stopifnot(isTRUE(all.equal(candidate('fedcba'), 'fdcb')))\n    stopifnot(isTRUE(all.equal(candidate('eeeee'), '')))\n    stopifnot(isTRUE(all.equal(candidate('acBAA'), 'cB')))\n    stopifnot(isTRUE(all.equal(candidate('EcBOO'), 'cB')))\n    stopifnot(isTRUE(all.equal(candidate('ybcd'), 'ybcd')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_52","nl":"epo_Latn","pl":"r","prompt":"Redonu TRUE se ĉiuj nombroj en la listo l estas sub la sojlo t. # >>> below_threshold(c(1, 2, 4, 10), 100)\n# TRUE\n# >>> below_threshold(c(1, 20, 4, 10), 5)\n# FALSE\nbelow_threshold <- function(l, t) {","canonical_solution":"below_threshold <- function(l, t) {\n  return(all(l < t))\n}","tests":"test_humaneval <- function() {\n    candidate <- below_threshold\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10), 100), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 21), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10), 22), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 11), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 8, 4, 10), 10), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_53","nl":"epo_Latn","pl":"r","prompt":"Adiciu du nombrojn, x kaj y.# >>> add(2, 3)\n# 5\n# >>> add(5, 7)\n# 12\nadd <- function(x, y) {","canonical_solution":"add <- function(x, y) {\n  return(x + y)\n}","tests":"test_humaneval <- function() {\n    candidate <- add\n    stopifnot(isTRUE(all.equal(candidate(0, 1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(1, 0), 1)))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), 5)))\n    stopifnot(isTRUE(all.equal(candidate(5, 7), 12)))\n    stopifnot(isTRUE(all.equal(candidate(7, 5), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_54","nl":"epo_Latn","pl":"r","prompt":"Kontrolu, ĉu du vortoj havas la samajn signojn.# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n# TRUE\n# >>> same_chars('abcd', 'dddddddabc')\n# TRUE\n# >>> same_chars('dddddddabc', 'abcd')\n# TRUE\n# >>> same_chars('eabcd', 'dddddddabc')\n# FALSE\n# >>> same_chars('abcd', 'dddddddabce')\n# FALSE\n# >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n# FALSE\nsame_chars <- function(s0, s1) {","canonical_solution":"same_chars <- function(s0, s1) {\n  return(identical(sort(unique(unlist(strsplit(s0, \"\")))), sort(unique(unlist(strsplit(s1, \"\"))))))\n}","tests":"test_humaneval <- function() {\n    candidate <- same_chars\n    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabc'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('dddddddabc', 'abcd'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('eabcd', 'dddddddabc'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd', 'dddddddabcf'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aabb', 'aaccc'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_55","nl":"epo_Latn","pl":"r","prompt":"Redonu la n-an nombron de Fibonacci. # >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n# >>> fib(8)\n# 21\nfib <- function(n) {","canonical_solution":"fib <- function(n) {\n  if (n <= 1) {\n    return(n)\n  }\n  a <- 0\n  b <- 1\n  for (i in 2:n) {\n    temp <- b\n    b <- a + b\n    a <- temp\n  }\n  return(b)\n}","tests":"test_humaneval <- function() {\n    candidate <- fib\n    stopifnot(isTRUE(all.equal(candidate(10), 55)))\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(8), 21)))\n    stopifnot(isTRUE(all.equal(candidate(11), 89)))\n    stopifnot(isTRUE(all.equal(candidate(12), 144)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_56","nl":"epo_Latn","pl":"r","prompt":"return TRUE se ĉiu malferma krampo havas korespondan ferman krampon. kurtenoj estas ĉeno de \"<\" kaj \">\". # >>> correct_bracketing('<')\n# FALSE\n# >>> correct_bracketing('<>')\n# TRUE\n# >>> correct_bracketing('<<><>>')\n# TRUE\n# >>> correct_bracketing('><<>')\n# FALSE\ncorrect_bracketing <- function(brackets) {","canonical_solution":"correct_bracketing <- function(brackets) {\n  count <- 0\n  for (char in strsplit(brackets, NULL)[[1]]) {\n    if (char == \"<\") {\n      count <- count + 1\n    } else if (char == \">\") {\n      count <- count - 1\n    }\n    if (count < 0) {\n      return(FALSE)\n    }\n  }\n  return(count == 0)\n}","tests":"test_humaneval <- function() {\n    candidate <- correct_bracketing\n    stopifnot(isTRUE(all.equal(candidate('<>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<<><>>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<<><><>><>><<><><<>>>'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('<<<><>>>>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('><<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<<<<'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>><<>'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('<><><<><>><>>><>'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_57","nl":"epo_Latn","pl":"r","prompt":"Return TRUE estas listo elementoj estas monotone kreskanta aŭ malpliiĝanta.# >>> monotonic(c(1, 2, 4, 20))\n# TRUE\n# >>> monotonic(c(1, 20, 4, 10))\n# FALSE\n# >>> monotonic(c(4, 1, 0, -10))\n# TRUE\nmonotonic <- function(l) {","canonical_solution":"monotonic <- function(l) {\n  is_increasing <- all(diff(l) >= 0)\n  is_decreasing <- all(diff(l) <= 0)\n  return(is_increasing || is_decreasing)\n}","tests":"test_humaneval <- function() {\n    candidate <- monotonic\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 10)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 20)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 20, 4, 10)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 0, -10)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 1, 0)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 5, 60)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 60)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 9, 9, 9)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_58","nl":"epo_Latn","pl":"r","prompt":"Revenigas ordigitajn unikajn komunajn elementojn por du listoj.# >>> common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n# c(1, 5, 653)\n# >>> common(c(5, 3, 2, 8), c(3, 2))\n# c(2, 3)\ncommon <- function(l1, l2) {","canonical_solution":"common <- function(l1, l2) {\n  common_elements <- intersect(l1, l2)\n  sorted_unique_common <- sort(unique(common_elements))\n  return(sorted_unique_common)\n}","tests":"test_humaneval <- function() {\n    candidate <- common\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), c(1, 5, 653))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 3, 2, 8), c(3, 2)), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c(3, 2, 4)), c(2, 3, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 2, 8), c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_59","nl":"epo_Latn","pl":"r","prompt":"Redonu la plej grandan priman faktoron de n. Supozu, ke n > 1 kaj ne estas primo. # >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\nlargest_prime_factor <- function(n) {","canonical_solution":"largest_prime_factor <- function(n) {\n  # Initialize the largest prime factor\n  largest_prime <- -1\n  \n  # Remove factors of 2\n  while (n %% 2 == 0) {\n    largest_prime <- 2\n    n <- n \/ 2\n  }\n  \n  # Try odd factors from 3 upwards\n  factor <- 3\n  while (factor * factor <= n) {\n    while (n %% factor == 0) {\n      largest_prime <- factor\n      n <- n \/ factor\n    }\n    factor <- factor + 2\n  }\n  \n  # If n is a prime number greater than 2\n  if (n > 2) {\n    largest_prime <- n\n  }\n  \n  # Return the largest prime factor found\n  return(largest_prime)\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_prime_factor\n    stopifnot(isTRUE(all.equal(candidate(15), 5)))\n    stopifnot(isTRUE(all.equal(candidate(27), 3)))\n    stopifnot(isTRUE(all.equal(candidate(63), 7)))\n    stopifnot(isTRUE(all.equal(candidate(330), 11)))\n    stopifnot(isTRUE(all.equal(candidate(13195), 29)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_60","nl":"epo_Latn","pl":"r","prompt":"sum_to_n estas funkcio, kiu sumigas nombrojn de 1 ĝis n. # >>> sum_to_n(30)\n# 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n# 55\n# >>> sum_to_n(1)\n# 1\nsum_to_n <- function(n) {","canonical_solution":"sum_to_n <- function(n) {\n  return(sum(1:n))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_to_n\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(6), 21)))\n    stopifnot(isTRUE(all.equal(candidate(11), 66)))\n    stopifnot(isTRUE(all.equal(candidate(30), 465)))\n    stopifnot(isTRUE(all.equal(candidate(100), 5050)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_61","nl":"epo_Latn","pl":"r","prompt":"return TRUE se ĉiu malferma krampo havas korespondan ferman krampon. krampoj estas ĉeno de \"(\" kaj \")\". # >>> correct_bracketing('(')\n# FALSE\n# >>> correct_bracketing('()')\n# TRUE\n# >>> correct_bracketing('(()())')\n# TRUE\n# >>> correct_bracketing(')(()')\n# FALSE\ncorrect_bracketing <- function(brackets) {","canonical_solution":"correct_bracketing <- function(brackets) {\n  balance <- 0\n  for (char in strsplit(brackets, NULL)[[1]]) {\n    if (char == \"(\") {\n      balance <- balance + 1\n    } else if (char == \")\") {\n      balance <- balance - 1\n    }\n    if (balance < 0) {\n      return(FALSE)\n    }\n  }\n  return(balance == 0)\n}","tests":"test_humaneval <- function() {\n    candidate <- correct_bracketing\n    stopifnot(isTRUE(all.equal(candidate('()'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('(()())'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())()'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('()()((()()())())(()()(()))'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('((()())))'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(')(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('('), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('(((('), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(')'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())())(()'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('()()(()())()))()'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_62","nl":"epo_Latn","pl":"r","prompt":"Redonu la derivon de ĉi tiu polinomo en la sama formo. xs[0] + xs[1] * x + xs[2] * x^2 + .... x reprezentas la koeficientojn de polinomo.# >>> derivative(c(3, 1, 2, 4, 5))\n# c(1, 4, 12, 20)\n# >>> derivative(c(1, 2, 3))\n# c(2, 6)\nderivative <- function(xs) {","canonical_solution":"derivative <- function(xs) {\n  n <- length(xs)\n  if (n <= 1) return(numeric(0))  # Derivative of a constant is zero\n  \n  deriv <- numeric(n - 1)\n  for (i in 2:n) {\n    deriv[i - 1] <- xs[i] * (i - 1)\n  }\n  return(deriv)\n}","tests":"test_humaneval <- function() {\n    candidate <- derivative\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 2, 4, 5)), c(1, 4, 12, 20))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1, 0, 4)), c(2, 2, 0, 16))))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_63","nl":"epo_Latn","pl":"r","prompt":"Bonvolu skribi funkcion por efike kalkuli la n-an elementon de la nombra sekvenco fibfib. fibfib{n} == fibfib{n-1) + fibfib{n-2) + fibfib{n-3). fibfib(2) == 1 fibfib{}1) == 0 fibfib{}0) == 0 La nombra sekvenco FibFib estas sekvenco simila al la sekvenco de Fibbonacci kiu estas difinita jene: # >>> fibfib(1)\n# 0\n# >>> fibfib(5)\n# 4\n# >>> fibfib(8)\n# 24\nfibfib <- function(n) {","canonical_solution":"fibfib <- function(n) {\n  # Base cases\n  if (n == 0) return(0)\n  if (n == 1) return(0)\n  if (n == 2) return(1)\n\n  # Initialize the first three values\n  fibfib_values <- c(0, 0, 1)\n  \n  # Compute fibfib for the rest using iteration\n  for (i in 3:n) {\n    fibfib_values[i + 1] <- fibfib_values[i] + fibfib_values[i - 1] + fibfib_values[i - 2]\n  }\n  # Return the nth value\n  return(fibfib_values[n + 1])\n}","tests":"test_humaneval <- function() {\n    candidate <- fibfib\n    stopifnot(isTRUE(all.equal(candidate(2), 1)))\n    stopifnot(isTRUE(all.equal(candidate(1), 0)))\n    stopifnot(isTRUE(all.equal(candidate(5), 4)))\n    stopifnot(isTRUE(all.equal(candidate(8), 24)))\n    stopifnot(isTRUE(all.equal(candidate(10), 81)))\n    stopifnot(isTRUE(all.equal(candidate(12), 274)))\n    stopifnot(isTRUE(all.equal(candidate(14), 927)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_64","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: vokalo, sed nur kiam ĝi estas ĉe la fino de la donita vorto.La vokaloj en tiu ĉi kazo estas \"a\", \"e\", \"i\", \"o\", \"u\". Ĉi tie, \"y\" estas ankaŭ \"a\".vorto kiel enigaĵo kaj revenas la nombron de vokaloj en la ŝnuro. Skribu funkcion vowels_count kiu prenas ĉenon reprezentantan # >>> vowels_count('abcde')\n# 2\n# >>> vowels_count('ACEDY')\n# 3\nvowels_count <- function(s) {","canonical_solution":"vowels_count <- function(s) {\n  s <- tolower(s)\n  n <- nchar(s)\n  count <- sum(unlist(strsplit(s, NULL)) %in% c('a', 'e', 'i', 'o', 'u'))\n  if (n > 0 && substr(s, n, n) == 'y') {\n    count <- count + 1\n  }\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- vowels_count\n    stopifnot(isTRUE(all.equal(candidate('abcde'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('Alone'), 3)))\n    stopifnot(isTRUE(all.equal(candidate('key'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('bye'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('keY'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('bYe'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('ACEDY'), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_65","nl":"epo_Latn","pl":"r","prompt":"Se ŝanĝo > nombro de ciferoj, revenigu ciferojn inversigitajn.kaj redonu la rezulton kiel ŝnuron. Cirkla transiro kun la ciferoj de la entjero x, ŝanĝo de cifero al dekstra por ŝanĝi ilin al la maldekstra.# >>> circular_shift(12, 1)\n# '21'\n# >>> circular_shift(12, 2)\n# '12'\ncircular_shift <- function(x, shift) {","canonical_solution":"circular_shift <- function(x, shift) {\n  digits <- as.character(x)\n  n <- nchar(digits)\n  \n  if (shift > n) {\n    return(paste0(rev(unlist(strsplit(digits, \"\"))), collapse = \"\"))\n  }\n  \n  shift <- shift %% n\n  if (shift == 0) {\n    return(digits)\n  }\n  \n  right_part <- substr(digits, n - shift + 1, n)\n  left_part <- substr(digits, 1, n - shift)\n  result <- paste0(right_part, left_part)\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- circular_shift\n    stopifnot(isTRUE(all.equal(candidate(100, 2), '001')))\n    stopifnot(isTRUE(all.equal(candidate(12, 2), '12')))\n    stopifnot(isTRUE(all.equal(candidate(97, 8), '79')))\n    stopifnot(isTRUE(all.equal(candidate(12, 1), '21')))\n    stopifnot(isTRUE(all.equal(candidate(11, 101), '11')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_66","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: ASCII-kodoj. Skribu funkcion kiu prenas ŝnuron kiel enigaĵon kaj resendas la sumon de la supraj karakteroj nur' Tasko # >>> digitSum('')\n# 0\n# >>> digitSum('abAB')\n# 131\n# >>> digitSum('abcCd')\n# 67\n# >>> digitSum('helloE')\n# 69\n# >>> digitSum('woArBld')\n# 131\n# >>> digitSum('aAaaaXa')\n# 153\ndigitSum <- function(s) {","canonical_solution":"digitSum <- function(s) {\n  sum(sapply(unlist(strsplit(s, \"\")), function(x) {\n    if (grepl(\"[A-Z]\", x)) {\n      return(as.integer(charToRaw(x)))\n    } else {\n      return(0)\n    }\n  }))\n}","tests":"test_humaneval <- function() {\n    candidate <- digitSum\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('abAB'), 131)))\n    stopifnot(isTRUE(all.equal(candidate('abcCd'), 67)))\n    stopifnot(isTRUE(all.equal(candidate('helloE'), 69)))\n    stopifnot(isTRUE(all.equal(candidate('woArBld'), 131)))\n    stopifnot(isTRUE(all.equal(candidate('aAaaaXa'), 153)))\n    stopifnot(isTRUE(all.equal(candidate(' How are yOu?'), 151)))\n    stopifnot(isTRUE(all.equal(candidate('You arE Very Smart'), 327)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_67","nl":"epo_Latn","pl":"r","prompt":"por eksamblo: en la korbo redonu la nombron de la mangofruktoj en la korbo. la oranĝoj kaj pomoj kaj entjero kiu reprezentas la tutan nombron de la fruktoj la pomojn, la oranĝojn kaj la mangojn. La streko reprezentas la nombron kiuj estas distribuitaj en korbo de fruktoj enhavanta tiun korbon En tiu ĉi tasko, vi ricevos la nombron da pomoj kaj oranĝoj per ĉiu enhavo.# >>> fruit_distribution('5 apples and 6 oranges', 19)\n# 8\n# >>> fruit_distribution('0 apples and 1 oranges', 3)\n# 2\n# >>> fruit_distribution('2 apples and 3 oranges', 100)\n# 95\n# >>> fruit_distribution('100 apples and 1 oranges', 120)\n# 19\nfruit_distribution <- function(s, n) {","canonical_solution":"fruit_distribution <- function(s, n) {\n  # Extract numbers using regular expressions\n  matches <- regmatches(s, gregexpr(\"\\\\d+\", s))\n  # Convert extracted number strings to integers\n  fruits_count <- as.integer(unlist(matches))\n  # Total fruits described in the string\n  total_apples_oranges <- sum(fruits_count)\n  # Calculate mangoes\n  mangoes <- n - total_apples_oranges\n  return(mangoes)\n}","tests":"test_humaneval <- function() {\n    candidate <- fruit_distribution\n    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 19), 8)))\n    stopifnot(isTRUE(all.equal(candidate('5 apples and 6 oranges', 21), 10)))\n    stopifnot(isTRUE(all.equal(candidate('0 apples and 1 oranges', 3), 2)))\n    stopifnot(isTRUE(all.equal(candidate('1 apples and 0 oranges', 3), 2)))\n    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 100), 95)))\n    stopifnot(isTRUE(all.equal(candidate('2 apples and 3 oranges', 5), 0)))\n    stopifnot(isTRUE(all.equal(candidate('1 apples and 100 oranges', 120), 19)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_68","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo 1: Se ne estas eĉ valoroj aŭ la donita vektoro estas malplena, redonu []. La plukita nodo devus esti resendita en listo, [small_value, ĝia indekso], Se pluraj nodoj kun la sama plej malgranda eĉ valoro estas trovita, redonu la nodo kiu havas plej malgrandan indekson. La plukita nodo devas esti la nodo kun la plej malgranda para valoro.Via tasko estas preni unu el la nodoj kaj resendi ĝin.\"Dante al ni vektoron reprezentantan branĉon de arbo kiu havas ne-negativajn entjerajn nodojn\"# >>> pluck(c(4, 2, 3))\n# c(2, 1)\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck(c(1, 2, 3))\n# c(2, 1)\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck(c())\n# c()\n# Example 4:\n# >>> pluck(c(5, 0, 3, 0, 4, 2))\n# c(0, 1)\n# Explanation: 0 is the smallest value, but  there are two zeros,\n#              so we will choose the first zero, which has the smallest index.\n# Constraints:\n#     * 1 <= nodes.length <= 10000\n#     * 0 <= node.value\npluck <- function(arr) {","canonical_solution":"pluck <- function(arr) {\n  # Find indices for even numbers in the array\n  even_indices <- which(arr %% 2 == 0)\n  \n  # If no even numbers are found, return an empty list\n  if (length(even_indices) == 0) {\n    return(c())\n  }\n  \n  # Extract even numbers\n  even_values <- arr[even_indices]\n  \n  # Find the smallest even value\n  min_even_value <- min(even_values)\n  \n  # Find the index of the first occurrence of the smallest even value\n  min_index <- even_indices[which.min(even_values)]\n  \n  # Return the smallest even value and its index (0-based index)\n  return(c(min_even_value, min_index - 1))\n}","tests":"test_humaneval <- function() {\n    candidate <- pluck\n    stopifnot(isTRUE(all.equal(candidate(c(4, 2, 3)), c(2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), c(2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 0, 3, 0, 4, 2)), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 0, 5, 3)), c(0, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 8, 4, 8)), c(4, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 6, 7, 1)), c(6, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 7, 1)), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_69","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Se tia valoro ne ekzistas, redonu -1.La ofteco de entjero estas la nombro da fojoj, kiam ĝi aperas en la listo.Nulo, kaj havas frekvencon pli grandan ol aŭ egala al la valoro de la entjero mem.Vi ricevas ne-malplenan liston de pozitivaj entjeroj. Redonu la plej grandan entjeron, kiu estas pli granda ol # >>> search(c(4, 1, 2, 2, 3, 1))\n# 2\n# >>> search(c(1, 2, 2, 3, 3, 3, 4, 4, 4))\n# 3\n# >>> search(c(5, 5, 4, 4, 4))\n# -1\nsearch <- function(lst) {","canonical_solution":"search <- function(lst) {\n  # Calculate the frequency table\n  freq_table <- table(lst)\n  \n  # Convert to a data frame for easier processing\n  freq_df <- as.data.frame(freq_table)\n  \n  # Rename columns for convenience\n  names(freq_df) <- c(\"value\", \"frequency\")\n  \n  # Filter the values where the frequency is greater than or equal to the value itself\n  valid_values <- freq_df[freq_df$value <= freq_df$frequency, \"value\"]\n  \n  # If no valid values exist, return -1\n  if (length(valid_values) == 0) {\n    return(-1)\n  }\n  \n  # Otherwise, return the greatest valid value\n  return(max(valid_values))\n}","tests":"test_humaneval <- function() {\n    candidate <- search\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 1, 4, 1, 4, 4)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 3)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 8, 8, 8, 8, 8, 8)), 8)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 3, 2, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 8, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 3, 6, 5, 6, 4)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 9, 10, 1, 3)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(10)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 10, 10, 9, 2)), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_70","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: tiam maksimumo de la ceteraj entjeroj, tiam minimumo kaj tiel plu.Stranga gamo de valoroj, kiam vi komencas kun la minimuma valoro, Se ni havas liston de entjeroj, ni ricevas liston de malsamaj numeroj en stranga sinsekvo.# >>> strange_sort_list(c(1, 2, 3, 4))\n# c(1, 4, 2, 3)\n# >>> strange_sort_list(c(5, 5, 5, 5))\n# c(5, 5, 5, 5)\n# >>> strange_sort_list(c())\n# c()\nstrange_sort_list <- function(lst) {","canonical_solution":"strange_sort_list <- function(lst) {\n  result <- c()\n  while (length(lst) > 0) {\n    # Find and append the minimum of the list\n    min_val <- min(lst)\n    result <- c(result, min_val)\n    lst <- lst[lst != min_val]\n    \n    # Check if list is not empty before finding maximum\n    if (length(lst) > 0) {\n      # Find and append the maximum of the list\n      max_val <- max(lst)\n      result <- c(result, max_val)\n      lst <- lst[lst != max_val]\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- strange_sort_list\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), c(1, 4, 2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9)), c(5, 9, 6, 8, 7))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), c(1, 5, 2, 4, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 6, 7, 8, 9, 1)), c(1, 9, 5, 8, 6, 7))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 5, 5, 5)), c(5, 5, 5, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8)), c(1, 8, 2, 7, 3, 6, 4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 2, 2, 2, 5, 5, -5, -5)), c(-5, 5, -5, 5, 0, 2, 2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(111111)), c(111111))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_71","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: Do, la tria parto estas la plej grava.Tri lateroj formas triangulon, se la sumo de ambaŭ lateroj estas pli granda.Alie reveno -1 la triangulo rondeta al 2 dekumaj punktoj se la tri flankoj formas validan triangulon. Donita la longo de la tri flankoj de triangulo. Redonu la areon de # >>> triangle_area(3, 4, 5)\n# 6.0\n# >>> triangle_area(1, 2, 10)\n# -1\ntriangle_area <- function(a, b, c) {","canonical_solution":"triangle_area <- function(a, b, c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    # Using Heron's formula\n    s <- (a + b + c) \/ 2\n    area <- sqrt(s * (s - a) * (s - b) * (s - c))\n    return(round(area, 2))\n  } else {\n    return(-1)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- triangle_area\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), 6.0)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 10), -1)))\n    stopifnot(isTRUE(all.equal(candidate(4, 8, 5), 8.18)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), 1.73)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), -1)))\n    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), 16.25)))\n    stopifnot(isTRUE(all.equal(candidate(2, 6, 3), -1)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), 0.43)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_72","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: La objekto q flugos se ĝi estas ekvilibra (ĝi estas palindroma listo) kaj la sumo de ĝiaj elementoj estas malpli ol aŭ egala al la maksimuma ebla pezo w.Skribu funkcion kiu resendas VERE se la objekto q flugos, kaj FALSE alie. # >>> will_it_fly(c(1, 2), 5)\n# FALSE\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly(c(3, 2, 3), 1)\n# FALSE\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly(c(3, 2, 3), 9)\n# TRUE\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly(c(3), 5)\n# TRUE\n# # 3 is less than the maximum possible weight, and it's balanced.\nwill_it_fly <- function(q, w) {","canonical_solution":"will_it_fly <- function(q, w) {\n  is_palindromic <- function(lst) {\n    return(all(lst == rev(lst)))\n  }\n  \n  is_balanced <- is_palindromic(q)\n  sum_elements <- sum(q)\n  \n  return(is_balanced && (sum_elements <= w))\n}","tests":"test_humaneval <- function() {\n    candidate <- will_it_fly\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 9), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), 5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3), 5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 3), 1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), 6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(5), 5), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_73","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: En unu ŝanĝo, vi povas ŝanĝi unu elementon al iu alia elemento.necesas ŝanĝi por fari la vektoron palindromia. Palindromia vektoro estas vektoro kiu Surbaze de vektoro arr de entjeroj, trovu la minimuman nombron de elementoj, kiuj # >>> smallest_change(c(1, 2, 3, 5, 4, 7, 9, 6))\n# 4\n# >>> smallest_change(c(1, 2, 3, 4, 3, 2, 2))\n# 1\n# >>> smallest_change(c(1, 2, 3, 2, 1))\n# 0\nsmallest_change <- function(arr) {","canonical_solution":"smallest_change <- function(arr) {\n  n <- length(arr)\n  changes <- 0\n  \n  for (i in 1:(n %\/% 2)) {\n    if (arr[i] != arr[n - i + 1]) {\n      changes <- changes + 1\n    }\n  }\n  \n  return(changes)\n}","tests":"test_humaneval <- function() {\n    candidate <- smallest_change\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5, 4, 7, 9, 6)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 3, 2, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 4, 2)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 2, 1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 1, 1, 3)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_74","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj se la du listoj havas la saman nombron da karakteroj, redonu la unuan liston.la tuta nombro de karoj en la ĉiuj ĉenoj de la listo malpli ol la alia listo. Skribu funkcion kiu akceptas du listojn de ŝnuroj kaj redonas la liston kiu havas # >>> total_match(c(), c())\n# c()\n# >>> total_match(c('hi', 'admin'), c('hI', 'Hi'))\n# c('hI', 'Hi')\n# >>> total_match(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project'))\n# c('hi', 'admin')\n# >>> total_match(c('hi', 'admin'), c('hI', 'hi', 'hi'))\n# c('hI', 'hi', 'hi')\n# >>> total_match(c('4'), c('1', '2', '3', '4', '5'))\n# c('4')\ntotal_match <- function(lst1, lst2) {","canonical_solution":"total_match <- function(lst1, lst2) {\n  chars_count <- function(lst) {\n    sum(nchar(lst))\n  }\n  \n  count1 <- chars_count(lst1)\n  count2 <- chars_count(lst2)\n  \n  if (count1 < count2) {\n    return(lst1)\n  } else if (count1 > count2) {\n    return(lst2)\n  } else {\n    return(lst1)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- total_match\n    stopifnot(isTRUE(all.equal(candidate(c(), c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi')), c('hi', 'hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hi', 'hi', 'admin', 'project')), c('hi', 'admin'))))\n    stopifnot(isTRUE(all.equal(candidate(c('4'), c('1', '2', '3', '4', '5')), c('4'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'Hi')), c('hI', 'Hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hi')), c('hI', 'hi', 'hi'))))\n    stopifnot(isTRUE(all.equal(candidate(c('hi', 'admin'), c('hI', 'hi', 'hii')), c('hi', 'admin'))))\n    stopifnot(isTRUE(all.equal(candidate(c(), c('this')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('this'), c()), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_75","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: Sciante ke (a) estas malpli ol 100.kaj malvera alirilate.Skribu funkcion kiu resendas la valoron TRUE se la donita nombro estas la multipliko de 3 primoj # >>> is_multiply_prime(30)\n# TRUE\n# 30 = 2 * 3 * 5\nis_multiply_prime <- function(a) {","canonical_solution":"is_multiply_prime <- function(a) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n <= 3) return(TRUE)\n    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)\n    i <- 5\n    while (i * i <= n) {\n      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)\n      i <- i + 6\n    }\n    return(TRUE)\n  }\n\n  if (a >= 100) return(FALSE)\n  \n  primes <- c()\n  for (i in 2:a) {\n    if (is_prime(i)) {\n      primes <- c(primes, i)\n    }\n  }\n  \n  for (i in 1:length(primes)) {\n    for (j in i:length(primes)) {\n      for (k in j:length(primes)) {\n        if (primes[i] * primes[j] * primes[k] == a) {\n          return(TRUE)\n        }\n      }\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_multiply_prime\n    stopifnot(isTRUE(all.equal(candidate(5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(30), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(125), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(105), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(126), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(729), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(891), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1001), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_76","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: x estas simpla potenco de n se n**int=x potenco de n kaj malvera en aliaj kazoj.Via tasko estas skribi funkcion kiu resendas la valoron veras se la nombro x estas simpla # >>> is_simple_power(1, 4)\n# TRUE\n# >>> is_simple_power(2, 2)\n# TRUE\n# >>> is_simple_power(8, 2)\n# TRUE\n# >>> is_simple_power(3, 2)\n# FALSE\n# >>> is_simple_power(3, 1)\n# FALSE\n# >>> is_simple_power(5, 3)\n# FALSE\nis_simple_power <- function(x, n) {","canonical_solution":"is_simple_power <- function(x, n) {\n  if (x == 1) return(TRUE)\n  power <- 1\n  while (power < x) {\n    power <- power * n\n    if (power == x) return(TRUE)\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_simple_power\n    stopifnot(isTRUE(all.equal(candidate(16, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(143214, 16), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(4, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(9, 3), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(16, 4), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(24, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(128, 4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(12, 6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 12), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_77","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Noto: Vi povas supozi, ke la enigaĵo ĉiam validas.se tiu ĉi estas la kubo de iu entjero.Skribu funkcion kiu prenas entjero a kaj resendas VERE # >>> iscube(1)\n# TRUE\n# >>> iscube(2)\n# FALSE\n# >>> iscube(-1)\n# TRUE\n# >>> iscube(64)\n# TRUE\n# >>> iscube(0)\n# TRUE\n# >>> iscube(180)\n# FALSE\niscube <- function(a) {","canonical_solution":"iscube <- function(a) {\n  if (a == 0) return(TRUE)\n  root <- round(abs(a)^(1\/3))\n  return(root^3 == abs(a))\n}","tests":"test_humaneval <- function() {\n    candidate <- iscube\n    stopifnot(isTRUE(all.equal(candidate(1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(-1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(64), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(180), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1000), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(0), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1729), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_78","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: kaj simboloj A,B,C,D,E,F estas ĉiam majuskloj.Noto: vi povas supozi la enigaĵo estas ĉiam ĝusta aŭ malplena ŝnuro, B (= dekuma 11), D (= dekuma 13). Do, vi devas taksi viajn poentojn tiel ĉi: 2, 3, 5, 7, 8...La primoj estas 2, 3, 5, 7, 11, 13, 17...La dek-sesaj ciferoj estas 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.pli granda ol 1 kiu ne estas produkto de du pli malgrandaj naturaj nombroj).ciferoj kiuj estas primoj (prima nombro, aŭ primo, estas natura nombro la nombro de la dekokaj punktoj en la ŝildo kaj kalkulas la nombron de la dekokaj punktoj Vi estis komisiita skribi funkcion kiu ricevas # >>> hex_key('AB')\n# 1\n# >>> hex_key('1077E')\n# 2\n# >>> hex_key('ABED1A33')\n# 4\n# >>> hex_key('123456789ABCDEF0')\n# 6\n# >>> hex_key('2020')\n# 2\nhex_key <- function(num) {","canonical_solution":"hex_key <- function(num) {\n  # Define the set of prime hexadecimal digits\n  prime_hex_digits <- c('2', '3', '5', '7', 'B', 'D')\n  \n  # Initialize a counter\n  count <- 0\n  \n  # Convert the input string to a list of characters\n  chars <- strsplit(num, NULL)[[1]]\n  \n  # Loop over each character in the list\n  for (char in chars) {\n    # Check if the character is in the list of prime hexadecimal digits\n    if (char %in% prime_hex_digits) {\n      # Increment the count\n      count <- count + 1\n    }\n  }\n  \n  # Return the count\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- hex_key\n    stopifnot(isTRUE(all.equal(candidate('AB'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('1077E'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('ABED1A33'), 4)))\n    stopifnot(isTRUE(all.equal(candidate('2020'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('123456789ABCDEF0'), 6)))\n    stopifnot(isTRUE(all.equal(candidate('112233445566778899AABBCCDDEEFF00'), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_79","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: La ekstraj karakteroj estas tie por helpi kun la formato.Estos ekstra paro de karakteroj \"db\" komence kaj fine de la ŝnuro.Ĉiu signo en la ŝnuro estos '0' aŭ '1'.La funkcio devas redoni ŝnuron, kie ĉiu karaktero reprezentas binaran Vi ricevos ciferon en cifereca formo kaj via tasko estas transformi ĝin al # >>> decimal_to_binary(15)\n# 'db1111db'\n# >>> decimal_to_binary(32)\n# 'db100000db'\ndecimal_to_binary <- function(decimal) {","canonical_solution":"decimal_to_binary <- function(decimal) {\n  binary_string <- as.character(intToBits(decimal))\n  binary_clean <- paste0(rev(binary_string), collapse = \"\")\n  binary_trimmed <- sub(\"^0+\", \"\", binary_clean)\n  return(paste0(\"db\", binary_trimmed, \"db\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- decimal_to_binary\n    stopifnot(isTRUE(all.equal(candidate(0), 'db0db')))\n    stopifnot(isTRUE(all.equal(candidate(32), 'db100000db')))\n    stopifnot(isTRUE(all.equal(candidate(103), 'db1100111db')))\n    stopifnot(isTRUE(all.equal(candidate(15), 'db1111db')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_80","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: La ŝnuro estas hapr se ĝia longo estas almenaŭ 3 kaj ĉiu 3 sinsekvaj literoj estas apartaj Via tasko estas kontroli ĉu la ŝnuro estas ĝusta aŭ ne.Vi ricevas stringon s. # >>> is_happy('a')\n# FALSE\n# >>> is_happy('aa')\n# FALSE\n# >>> is_happy('abcd')\n# TRUE\n# >>> is_happy('aabb')\n# FALSE\n# >>> is_happy('adb')\n# TRUE\n# >>> is_happy('xyy')\n# FALSE\nis_happy <- function(s) {","canonical_solution":"is_happy <- function(s) {\n  n <- nchar(s)\n  if (n < 3) {\n    return(FALSE)\n  }\n  for (i in 1:(n - 2)) {\n    if (length(unique(substring(s, i, i + 2))) != 3) {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_happy\n    stopifnot(isTRUE(all.equal(candidate('a'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aa'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('abcd'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('aabb'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('adb'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('xyy'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('iopaxpoi'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('iopaxioi'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_81","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: 0.0 E > 0.0 D- > 0,7 D > 1,0 D+ > 1.3 C- > 1,7 C > 2.0 C+ > 2.3 B- > 2.7 B > 3.0 B+ > 3.3 A- > 3.7 A 4.0 A+ Interesa mezumo.funkcio kiu povas produkti liston de literoklasoj uzante la sekvan tabelon: Ŝi donis al vi liston de notoj por kelkaj lernantoj kaj vi devas skribi ilin.La sola problemo estas, ke ŝi perdis la kodon, kiun ŝi uzis por la notado.La instruisto kreis sian propran algoritmon por la notado.Estas la lasta semajno de la semestro kaj la instruisto devas doni la notojn.# >>> grade_equation(c(4.0, 3, 1.7, 2, 3.5))\n# c('A+', 'B', 'C-', 'C', 'A-')\nnumerical_letter_grade <- function(grades) {","canonical_solution":"numerical_letter_grade <- function(grades) {\n  letter_grades <- sapply(grades, function(gpa) {\n    if (gpa == 4.0) {\n      \"A+\"\n    } else if (gpa > 3.7) {\n      \"A\"\n    } else if (gpa > 3.3) {\n      \"A-\"\n    } else if (gpa > 3.0) {\n      \"B+\"\n    } else if (gpa > 2.7) {\n      \"B\"\n    } else if (gpa > 2.3) {\n      \"B-\"\n    } else if (gpa > 2.0) {\n      \"C+\"\n    } else if (gpa > 1.7) {\n      \"C\"\n    } else if (gpa > 1.3) {\n      \"C-\"\n    } else if (gpa > 1.0) {\n      \"D+\"\n    } else if (gpa > 0.7) {\n      \"D\"\n    } else if (gpa > 0.0) {\n      \"D-\"\n    } else {\n      \"E\"\n    }\n  })\n  return(letter_grades)\n}","tests":"test_humaneval <- function() {\n    candidate <- numerical_letter_grade\n    stopifnot(isTRUE(all.equal(candidate(c(4.0, 3, 1.7, 2, 3.5)), c('A+', 'B', 'C-', 'C', 'A-'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.2)), c('D+'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.5)), c('D-'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0)), c('E'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 0.3, 1.5, 2.8, 3.3)), c('D', 'D-', 'C-', 'B', 'B+'))))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0, 0.7)), c('E', 'D-'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_82","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj longo estas primo aŭ malvera alie Skribu funkcion kiu prenas ĉenon kaj resendas VERE se la ĉeno # >>> prime_length('Hello')\n# TRUE\n# >>> prime_length('abcdcba')\n# TRUE\n# >>> prime_length('kittens')\n# TRUE\n# >>> prime_length('orange')\n# FALSE\nprime_length <- function(string) {","canonical_solution":"prime_length <- function(string) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n <= 3) return(TRUE)\n    if (n %% 2 == 0 || n %% 3 == 0) return(FALSE)\n    \n    i <- 5\n    while (i * i <= n) {\n      if (n %% i == 0 || n %% (i + 2) == 0) return(FALSE)\n      i <- i + 6\n    }\n    \n    return(TRUE)\n  }\n  \n  string_length <- nchar(string)\n  return(is_prime(string_length))\n}","tests":"test_humaneval <- function() {\n    candidate <- prime_length\n    stopifnot(isTRUE(all.equal(candidate('Hello'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abcdcba'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('kittens'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('orange'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('wow'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('world'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('MadaM'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('Wow'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('HI'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('go'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('gogo'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('aaaaaaaaaaaaaaa'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('Madam'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('M'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('0'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_83","nl":"epo_Latn","pl":"r","prompt":"pozitivaj entjeroj kiuj komenciĝas aŭ finiĝas per 1. Donita pozitiva entjero n, redonu la nombron de la nombroj de n-ciferoj starts_one_ends <- function(n) {","canonical_solution":"starts_one_ends <- function(n) {\n  if (n == 1) {\n    return(1)\n  } else {\n    return(9 * (10^(n-2)) * 2)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- starts_one_ends\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n    stopifnot(isTRUE(all.equal(candidate(2), 18)))\n    stopifnot(isTRUE(all.equal(candidate(3), 180)))\n    stopifnot(isTRUE(all.equal(candidate(4), 1800)))\n    stopifnot(isTRUE(all.equal(candidate(5), 18000)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_84","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo Donita pozitiva entjero N, redonu la sumon de ĝiaj ciferoj en binara. # >>> solve(1000)\n# '1'\n# >>> solve(150)\n# '110'\n# >>> solve(147)\n# '1100'\n# Variables:\n#     @N integer\n#          Constraints: 0 ≤ N ≤ 10000.\n# Output:\n#      a string of binary number\nsolve <- function(N) {","canonical_solution":"solve <- function(N) {\n  # Sum the digits of the number\n  digit_sum <- sum(as.numeric(unlist(strsplit(as.character(N), \"\"))))\n  # Convert the sum to binary and return as a string\n  return(as.character(as.binary(digit_sum)))\n}\n\n# Helper function to convert number to binary\nas.binary <- function(number) {\n  if (number == 0) return(\"0\")\n  binary <- \"\"\n  while (number > 0) {\n    binary <- paste0(number %% 2, binary)\n    number <- number %\/% 2\n  }\n  return(binary)\n}","tests":"test_humaneval <- function() {\n    candidate <- solve\n    stopifnot(isTRUE(all.equal(candidate(1000), '1')))\n    stopifnot(isTRUE(all.equal(candidate(150), '110')))\n    stopifnot(isTRUE(all.equal(candidate(147), '1100')))\n    stopifnot(isTRUE(all.equal(candidate(333), '1001')))\n    stopifnot(isTRUE(all.equal(candidate(963), '10010')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_85","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Donita ne-malplena listo de entjeroj lst. aldonu la parajn elementojn kiuj estas en neparaj indeksoj .. # >>> add(c(4, 2, 6, 7))\n# 2\nadd <- function(lst) {","canonical_solution":"add <- function(lst) {\n  # Select elements at odd indices (which are even positions)\n  elements_at_odd_indices <- lst[seq(2, length(lst), by=2)]\n  # Keep only the even elements\n  even_elements <- elements_at_odd_indices[elements_at_odd_indices %% 2 == 0]\n  # Sum the even elements\n  sum(even_elements)\n}","tests":"test_humaneval <- function() {\n    candidate <- add\n    stopifnot(isTRUE(all.equal(candidate(c(4, 88)), 88)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 6, 7, 2, 122)), 122)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 0, 6, 7)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 4, 6, 8)), 12)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_86","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Noto: Vi devas konservi la ordon de la vortoj kaj la blankajn spacojn en la frazo.laŭ kreskanta ordo bazita sur la ascii-valoro.estas anstataŭigitaj per nova vorto, kie ĉiuj signoj aranĝitaj en Ordigita versio de ŝnuro, estas ŝnuro kie ĉiuj vortoj (apartigitaj per spaco) Skribu funkcion kiu prenas ĉenon kaj redonas ordonitan version de ĝi.# >>> anti_shuffle('Hi')\n# 'Hi'\n# >>> anti_shuffle('hello')\n# 'ehllo'\n# >>> anti_shuffle('Hello World!!!')\n# 'Hello !!!Wdlor'\nanti_shuffle <- function(s) {","canonical_solution":"anti_shuffle <- function(s) {\n  words <- strsplit(s, \"(\\\\s+)\", perl = TRUE)[[1]]\n  sorted_words <- sapply(words, function(word) {\n    if (word == \"\") return(word)\n    chars <- unlist(strsplit(word, split = \"\"))\n    return(paste0(sort(chars), collapse = \"\"))\n  })\n  return(paste0(sorted_words, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- anti_shuffle\n    stopifnot(isTRUE(all.equal(candidate('Hi'), 'Hi')))\n    stopifnot(isTRUE(all.equal(candidate('hello'), 'ehllo')))\n    stopifnot(isTRUE(all.equal(candidate('number'), 'bemnru')))\n    stopifnot(isTRUE(all.equal(candidate('abcd'), 'abcd')))\n    stopifnot(isTRUE(all.equal(candidate('Hello World!!!'), 'Hello !!!Wdlor')))\n    stopifnot(isTRUE(all.equal(candidate(''), '')))\n    stopifnot(isTRUE(all.equal(candidate('Hi. My name is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_87","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Ankaŭ, ordigu la koordinatojn de la vico laŭ kolumnoj laŭ malkreskanta ordo.Sortu la koordinatojn komence laŭ vicoj laŭ kreskanta ordo.ĉiu listo estas koordinato - (vico, kolumnoj), komenciĝante per 0. kaj revenas liston de listoj, [(x1, y1), (x2, y2) ...] tia ke Donita lst, kaj entjero x, trovi la entjerojn x en la listo, ĉiu vico povas enhavi malsaman nombron da kolumnoj.kiu estas simila al matrico, tamen, male al matricoj, Oni donas al vi du-dimensiajn datumojn, kiel nestitajn listojn, # >>> get_row(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1)\n# list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0))\n# >>> get_row(c(), 1)\n# c()\n# >>> get_row(list(c(), c(1), c(1, 2, 3)), 3)\n# list(c(2, 2))\nget_row <- function(lst, x) {","canonical_solution":"get_row <- function(lst, x) {\n  result <- list()\n  for (i in seq_along(lst)) {\n    row <- lst[[i]]\n    cols <- which(row == x)\n    for (col in rev(sort(cols - 1))) {\n      result <- append(result, list(c(i - 1, col)))\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- get_row\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 4), c(1, 0), c(2, 5), c(2, 0)))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6)), 2), list(c(0, 1), c(1, 1), c(2, 1), c(3, 1), c(4, 1), c(5, 1)))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4, 5, 6), c(1, 2, 3, 4, 5, 6), c(1, 1, 3, 4, 5, 6), c(1, 2, 1, 4, 5, 6), c(1, 2, 3, 1, 5, 6), c(1, 2, 3, 4, 1, 6), c(1, 2, 3, 4, 5, 1)), 1), list(c(0, 0), c(1, 0), c(2, 1), c(2, 0), c(3, 2), c(3, 0), c(4, 3), c(4, 0), c(5, 4), c(5, 0), c(6, 5), c(6, 0)))))\n    stopifnot(isTRUE(all.equal(candidate(c(), 1), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1)), 2), c())))\n    stopifnot(isTRUE(all.equal(candidate(list(c(), c(1), c(1, 2, 3)), 3), list(c(2, 2)))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_88","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: * ne ŝanĝu la donitan vektoro. Noto: aŭ ordigu ĝin laŭ malkreskanta ordo se la sumo ((unua indeksa valoro, lasta indeksa valoro) estas para. vi ordigos la donitajn vektorojn laŭ kreskanta ordo se la sumo de la (unua indekso valoro, lasta indekso valoro) estas nepara, Donita vektoro de ne-negativaj entjeroj, redonu koron de la donita vektoro post ordigo, # >>> sort_array(c())\n# c()\n# >>> sort_array(c(5))\n# c(5)\n# >>> sort_array(c(2, 4, 3, 0, 1, 5))\n# c(0, 1, 2, 3, 4, 5)\n# >>> sort_array(c(2, 4, 3, 0, 1, 5, 6))\n# c(6, 5, 4, 3, 2, 1, 0)\nsort_array <- function(array) {","canonical_solution":"sort_array <- function(array) {\n  if (length(array) <= 1) {\n    return(array)\n  }\n  \n  first_value <- array[1]\n  last_value <- array[length(array)]\n  sum_values <- first_value + last_value\n  \n  if (sum_values %% 2 == 1) {\n    return(sort(array))\n  } else {\n    return(sort(array, decreasing = TRUE))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_array\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(5)), c(5))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5)), c(0, 1, 2, 3, 4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 3, 0, 1, 5, 6)), c(6, 5, 4, 3, 2, 1, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 1)), c(1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(15, 42, 87, 32, 11, 0)), c(0, 11, 15, 32, 42, 87))))\n    stopifnot(isTRUE(all.equal(candidate(c(21, 14, 23, 11)), c(23, 21, 14, 11))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_89","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: la nombron plialtigi per duoble ĝis ĝi atingas la duan pozicion laŭ la efektiva ordo de la vorto.La alfabeto devas esti rotaciita tiel ke la literoj returnas ŝildon ĉifritan per la alfabeto rotaciita. Krei funkcian ĉifradon kiu prenas ĉenon kiel argumenton kaj # >>> encrypt('hi')\n# 'lm'\n# >>> encrypt('asdfghjkl')\n# 'ewhjklnop'\n# >>> encrypt('gf')\n# 'kj'\n# >>> encrypt('et')\n# 'ix'\nencrypt <- function(s) {","canonical_solution":"encrypt <- function(s) {\n  alphabet <- letters\n  shift <- 2 * 2\n  encrypted <- sapply(strsplit(s, NULL)[[1]], function(char) {\n    if (char %in% alphabet) {\n      new_index <- (match(char, alphabet) + shift - 1) %% 26 + 1\n      alphabet[new_index]\n    } else {\n      char\n    }\n  })\n  paste(encrypted, collapse = \"\")\n}","tests":"test_humaneval <- function() {\n    candidate <- encrypt\n    stopifnot(isTRUE(all.equal(candidate('hi'), 'lm')))\n    stopifnot(isTRUE(all.equal(candidate('asdfghjkl'), 'ewhjklnop')))\n    stopifnot(isTRUE(all.equal(candidate('gf'), 'kj')))\n    stopifnot(isTRUE(all.equal(candidate('et'), 'ix')))\n    stopifnot(isTRUE(all.equal(candidate('faewfawefaewg'), 'jeiajeaijeiak')))\n    stopifnot(isTRUE(all.equal(candidate('hellomyfriend'), 'lippsqcjvmirh')))\n    stopifnot(isTRUE(all.equal(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'), 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')))\n    stopifnot(isTRUE(all.equal(candidate('a'), 'e')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_90","nl":"epo_Latn","pl":"r","prompt":"Redonu NULL se ne ekzistas tia elemento. Skribu funkcion next_smallest (next_smallest) kiu redonas la duan plej malgrandan elementon de la listo. Vi ricevas liston de entjeroj.# >>> next_smallest(c(1, 2, 3, 4, 5))\n# 2\n# >>> next_smallest(c(5, 1, 4, 3, 2))\n# 2\n# >>> next_smallest(c())\n# NULL\n# >>> next_smallest(c(1, 1))\n# NULL\nnext_smallest <- function(lst) {","canonical_solution":"next_smallest <- function(lst) {\n  # Sort the list and remove duplicates\n  unique_sorted_lst <- sort(unique(lst))\n  \n  # Check if list contains at least two distinct elements\n  if (length(unique_sorted_lst) < 2) {\n    return(NULL)\n  }\n  \n  # Return the second smallest element\n  return(unique_sorted_lst[2])\n}","tests":"test_humaneval <- function() {\n    candidate <- next_smallest\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 1, 4, 3, 2)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 0)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1)), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(-35, 34, 12, -45)), -35)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_91","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Frazoj estas limigitaj per \"\", \"?\" aŭ \"! \". Enuo estas frazo, kiu komenciĝas per la vorto \"mi\".Oni donas al vi parolrekonton kaj vi devas nombri la nombron.# >>> is_bored('Hello world')\n# 0\n# >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n# 1\nis_bored <- function(S) {","canonical_solution":"is_bored <- function(S) {\n  # Split the string into sentences using '.', '?', and '!' as delimiters\n  sentences <- unlist(strsplit(S, split = \"[.?!]\"))\n  \n  # Trim leading and trailing whitespace from each sentence\n  sentences <- trimws(sentences)\n  \n  # Count the number of sentences that start with \"I\"\n  boredom_count <- sum(startsWith(sentences, \"I\"))\n  \n  return(boredom_count)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_bored\n    stopifnot(isTRUE(all.equal(candidate('Hello world'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('Is the sky blue?'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('I love It !'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('bIt'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('I feel good today. I will be productive. will kill It'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('You and I are going for a walk'), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_92","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj Revenas malvera en iuj aliaj kazoj.Revenas vera se unu el la nombroj estas egala al la sumo de la aliaj du, kaj ĉiuj nombroj estas entjeroj. Krei funkciojn, kiuj prenas 3 nombrojn.# >>> any_int(5, 2, 7)\n# TRUE\n# >>> any_int(3, 2, 2)\n# FALSE\n# >>> any_int(3, -2, 1)\n# TRUE\n# >>> any_int(3.6, -2.2, 2)\n# FALSE\nany_int <- function(x, y, z) {","canonical_solution":"any_int <- function(x, y, z) {\n  if (is.integer(x) && is.integer(y) && is.integer(z)) {\n    return(x == y + z || y == x + z || z == x + y)\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- any_int\n    stopifnot(isTRUE(all.equal(candidate(2, 3, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2.5, 2, 3), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(1.5, 5, 3.5), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 6, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(4, 2, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2.2, 2.2, 2.2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(-4, 6, 2), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 1, 1), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 7), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(3.0, 4, 7), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_93","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Supozu nur literojn.vokalo en la angla alfabeto.la mesaĝon kun la litero kiu aperas 2 lokoj antaŭ tiu Ĝi ŝanĝas la literojn de la vorto \"voĉ\", de la vorto \"voĉ\".Skribu funkcion kiu prenas mesaĝon, kaj ĉifras en tia # >>> encode('test')\n# 'TGST'\n# >>> encode('This is a message')\n# 'tHKS KS C MGSSCGG'\nencode <- function(message) {","canonical_solution":"encode <- function(message) {\n  # Function to swap case of letters\n  swap_case <- function(char) {\n    if (grepl(\"[A-Za-z]\", char)) {\n      if (char %in% LETTERS) {\n        return(tolower(char))\n      } else {\n        return(toupper(char))\n      }\n    } else {\n      return(char)\n    }\n  }\n  \n  # Vowel replacement rules\n  vowel_replacement <- function(char) {\n    vowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n    replacements <- c(\"c\", \"g\", \"k\", \"q\", \"w\", \"C\", \"G\", \"K\", \"Q\", \"W\")\n    if (char %in% vowels) {\n      index <- match(char, vowels)\n      return(replacements[index])\n    } else {\n      return(char)\n    }\n  }\n  \n  # Splitting the message into its characters\n  message_chars <- strsplit(message, \"\")[[1]]\n  \n  # Apply swap case and vowel replacement\n  encoded_chars <- sapply(message_chars, function(x) vowel_replacement(swap_case(x)))\n  \n  # Combine the characters back into a single string\n  return(paste(encoded_chars, collapse = \"\"))\n}","tests":"test_humaneval <- function() {\n    candidate <- encode\n    stopifnot(isTRUE(all.equal(candidate('TEST'), 'tgst')))\n    stopifnot(isTRUE(all.equal(candidate('Mudasir'), 'mWDCSKR')))\n    stopifnot(isTRUE(all.equal(candidate('YES'), 'ygs')))\n    stopifnot(isTRUE(all.equal(candidate('This is a message'), 'tHKS KS C MGSSCGG')))\n    stopifnot(isTRUE(all.equal(candidate('I DoNt KnOw WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_94","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Ni devas trovi la plej grandan priman valoron kaj resendi la sumon de ĝiaj ciferoj.Vi ricevas liston de entjeroj.# >>> skjkasdkd(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))\n# 10\n# >>> skjkasdkd(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))\n# 25\n# >>> skjkasdkd(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))\n# 13\n# >>> skjkasdkd(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))\n# 11\n# >>> skjkasdkd(c(0, 81, 12, 3, 1, 21))\n# 3\n# >>> skjkasdkd(c(0, 8, 1, 2, 1, 7))\n# 7\nskjkasdkd <- function(lst) {","canonical_solution":"skjkasdkd <- function(lst) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n == 2) return(TRUE)\n    if (n %% 2 == 0) return(FALSE)\n    for (i in 3:sqrt(n)) {\n      if (n %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  prime_values <- lst[sapply(lst, is_prime)]\n  if (length(prime_values) == 0) return(0)\n  \n  largest_prime <- max(prime_values)\n  \n  sum_of_digits <- function(n) {\n    sum(as.numeric(unlist(strsplit(as.character(n), \"\"))))\n  }\n  \n  return(sum_of_digits(largest_prime))\n}","tests":"test_humaneval <- function() {\n    candidate <- skjkasdkd\n    stopifnot(isTRUE(all.equal(candidate(c(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)), 10)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)), 25)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)), 13)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)), 11)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 81, 12, 3, 1, 21)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 8, 1, 2, 1, 7)), 7)))\n    stopifnot(isTRUE(all.equal(candidate(c(8191)), 19)))\n    stopifnot(isTRUE(all.equal(candidate(c(8191, 123456, 127, 7)), 19)))\n    stopifnot(isTRUE(all.equal(candidate(c(127, 97, 8192)), 10)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_95","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: La funkcio devus resendi malvera estas la donita nomita listo estas malplena. case aŭ ĉiuj ŝlosiloj estas ĉenoj en majusklo, alie returnas FALSE. Donita nomita listo, returnas TRUE se ĉiuj ŝlosiloj estas ŝnuroj en pli malalta # >>> check_dict_case(list('a' = 'apple', 'b' = 'banana'))\n# TRUE\n# >>> check_dict_case(list('a' = 'apple', 'A' = 'banana', 'B' = 'banana'))\n# FALSE\n# >>> check_dict_case(list('a' = 'apple', 8 = 'banana', 'a' = 'apple'))\n# FALSE\n# >>> check_dict_case(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston'))\n# FALSE\n# >>> check_dict_case(list('STATE' = 'NC', 'ZIP' = '12345'))\n# TRUE\ncheck_dict_case <- function(dict) {","canonical_solution":"check_dict_case <- function(dict) {\n  if (length(dict) == 0) return(FALSE)\n  \n  keys <- names(dict)\n  \n  all_lower <- all(keys == tolower(keys))\n  all_upper <- all(keys == toupper(keys))\n  \n  return(all_lower || all_upper)\n}","tests":"test_humaneval <- function() {\n    candidate <- check_dict_case\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'b' = 'banana')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', 'A' = 'banana', 'B' = 'banana')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('p' = 'pineapple', '5' = 'banana', 'a' = 'apple')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('Name' = 'John', 'Age' = '36', 'City' = 'Houston')), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(list('STATE' = 'NC', 'ZIP' = '12345')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list('fruit' = 'Orange', 'taste' = 'Sweet')), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(list()), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_96","nl":"epo_Latn","pl":"r","prompt":"ekzemple: entjeroj kiuj estas primoj kaj malpli ol n. Funkcio kiu prenas ne-negativan entjero kaj resendas vektoron de la unua n # >>> count_up_to(5)\n# c(2, 3)\n# >>> count_up_to(11)\n# c(2, 3, 5, 7)\n# >>> count_up_to(0)\n# c()\n# >>> count_up_to(20)\n# c(2, 3, 5, 7, 11, 13, 17, 19)\n# >>> count_up_to(1)\n# c()\n# >>> count_up_to(18)\n# c(2, 3, 5, 7, 11, 13, 17)\ncount_up_to <- function(n) {","canonical_solution":"count_up_to <- function(n) {\n  is_prime <- function(num) {\n    if (num <= 1) return(FALSE)\n    if (num == 2) return(TRUE)\n    if (num %% 2 == 0) return(FALSE)\n    for (i in 3:sqrt(num)) {\n      if (num %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  primes_below_n <- c()\n  for (i in 2:(n-1)) {\n    if (is_prime(i)) {\n      primes_below_n <- c(primes_below_n, i)\n    }\n  }\n  \n  return(primes_below_n)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_up_to\n    stopifnot(isTRUE(all.equal(candidate(5), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(2, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(2, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(10), c(2, 3, 5, 7))))\n    stopifnot(isTRUE(all.equal(candidate(0), c())))\n    stopifnot(isTRUE(all.equal(candidate(22), c(2, 3, 5, 7, 11, 13, 17, 19))))\n    stopifnot(isTRUE(all.equal(candidate(1), c())))\n    stopifnot(isTRUE(all.equal(candidate(18), c(2, 3, 5, 7, 11, 13, 17))))\n    stopifnot(isTRUE(all.equal(candidate(47), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43))))\n    stopifnot(isTRUE(all.equal(candidate(101), c(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_97","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Supozu, ke la enigaĵo ĉiam validas.la produkto de iliaj unuocitroj. Kompletigu la funkcion kiu prenas du entjerojn kaj resendas # >>> multiply(148, 412)\n# 16\n# >>> multiply(19, 28)\n# 72\n# >>> multiply(2020, 1851)\n# 0\n# >>> multiply(14, -15)\n# 20\nmultiply <- function(a, b) {","canonical_solution":"multiply <- function(a, b) {\n  unit_digit_a <- abs(a) %% 10\n  unit_digit_b <- abs(b) %% 10\n  return(unit_digit_a * unit_digit_b)\n}","tests":"test_humaneval <- function() {\n    candidate <- multiply\n    stopifnot(isTRUE(all.equal(candidate(148, 412), 16)))\n    stopifnot(isTRUE(all.equal(candidate(19, 28), 72)))\n    stopifnot(isTRUE(all.equal(candidate(2020, 1851), 0)))\n    stopifnot(isTRUE(all.equal(candidate(14, -15), 20)))\n    stopifnot(isTRUE(all.equal(candidate(76, 67), 42)))\n    stopifnot(isTRUE(all.equal(candidate(17, 27), 49)))\n    stopifnot(isTRUE(all.equal(candidate(0, 1), 0)))\n    stopifnot(isTRUE(all.equal(candidate(0, 0), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_98","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Sur donita ŝnuro s, kalkulu la nombron de majusklaj vokaloj en paraj indeksoj. # >>> count_upper('aBCdEf')\n# 1\n# >>> count_upper('abcdefg')\n# 0\n# >>> count_upper('dBBE')\n# 0\ncount_upper <- function(s) {","canonical_solution":"count_upper <- function(s) {\n  # Define uppercase vowels\n  uppercase_vowels <- c('A', 'E', 'I', 'O', 'U')\n  \n  # Initialize counter\n  count <- 0\n  \n  # Iterate over string indices\n  for (i in seq(1, nchar(s), by=2)) {\n    # Check if character at even index is an uppercase vowel\n    if (substr(s, i, i) %in% uppercase_vowels) {\n      count <- count + 1\n    }\n  }\n  \n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- count_upper\n    stopifnot(isTRUE(all.equal(candidate('aBCdEf'), 1)))\n    stopifnot(isTRUE(all.equal(candidate('abcdefg'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('dBBE'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('B'), 0)))\n    stopifnot(isTRUE(all.equal(candidate('U'), 1)))\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n    stopifnot(isTRUE(all.equal(candidate('EEEE'), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_99","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj de du entjeroj, ĝi deturniĝas de nul.kaj ĝi donas la nombron, kiu plej proksimas al ĝi, egalrilatas al ĝiKrei funkcion kiu prenas valoron (ĉenon) reprezentantan nombron # >>> closest_integer('10')\n# 10\n# >>> closest_integer('15.3')\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\nclosest_integer <- function(value) {","canonical_solution":"closest_integer <- function(value) {\n  num <- as.numeric(value)\n  if (num %% 1 == 0.5 || num %% 1 == -0.5) {\n    return(ifelse(num > 0, ceiling(num), floor(num)))\n  } else {\n    return(round(num))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- closest_integer\n    stopifnot(isTRUE(all.equal(candidate('10'), 10)))\n    stopifnot(isTRUE(all.equal(candidate('14.5'), 15)))\n    stopifnot(isTRUE(all.equal(candidate('-15.5'), -16)))\n    stopifnot(isTRUE(all.equal(candidate('15.3'), 15)))\n    stopifnot(isTRUE(all.equal(candidate('0'), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_100","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: i reprezentas la nombron de ŝtonoj en la nivelo (i+1). Redonu la nombron da ŝtonoj en ĉiu nivelo en listo, kie elemento ĉe indekso - la sekvan parnombron se n estas para. - la sekva nepara nombro se n estas nepara. La nombro de ŝtonoj en la sekva nivelo estas: La unua nivelo havas n ŝtonojn.Donita pozitiva entjero n, vi devas fari stakon de n niveloj de ŝtonoj.# >>> make_a_pile(3)\n# c(3, 5, 7)\nmake_a_pile <- function(n) {","canonical_solution":"make_a_pile <- function(n) {\n  stones <- numeric(n)\n  stones[1] <- n\n  for (i in 2:n) {\n    if (n %% 2 == 0) {\n      stones[i] <- stones[i - 1] + 2\n    } else {\n      stones[i] <- stones[i - 1] + 2\n    }\n  }\n  return(stones)\n}","tests":"test_humaneval <- function() {\n    candidate <- make_a_pile\n    stopifnot(isTRUE(all.equal(candidate(3), c(3, 5, 7))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(4, 6, 8, 10))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(5, 7, 9, 11, 13))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(6, 8, 10, 12, 14, 16))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(8, 10, 12, 14, 16, 18, 20, 22))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_101","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: por dividi la ŝnuron en vortojn kaj resendi vektoron de la vortoj.Vi ricevos ĉenon de vortoj apartigitaj per komo aŭ spacoj.# >>> words_string('Hi, my name is John')\n# c('Hi', 'my', 'name', 'is', 'John')\n# >>> words_string('One, two, three, four, five, six')\n# c('One', 'two', 'three', 'four', 'five', 'six')\nwords_string <- function(s) {","canonical_solution":"words_string <- function(s) {\n  s <- gsub(\",\", \" \", s)\n  words <- unlist(strsplit(s, \"\\\\s+\"))\n  words <- words[words != \"\"]\n  return(words)\n}","tests":"test_humaneval <- function() {\n    candidate <- words_string\n    stopifnot(isTRUE(all.equal(candidate('Hi, my name is John'), c('Hi', 'my', 'name', 'is', 'John'))))\n    stopifnot(isTRUE(all.equal(candidate('One, two, three, four, five, six'), c('One', 'two', 'three', 'four', 'five', 'six'))))\n    stopifnot(isTRUE(all.equal(candidate('Hi, my name'), c('Hi', 'my', 'name'))))\n    stopifnot(isTRUE(all.equal(candidate('One,, two, three, four, five, six,'), c('One', 'two', 'three', 'four', 'five', 'six'))))\n    stopifnot(isTRUE(all.equal(candidate(''), c())))\n    stopifnot(isTRUE(all.equal(candidate('ahmed     , gamal'), c('ahmed', 'gamal'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_102","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: se tio ne estas la ĝusta nombro, ĝi returnos 1.la plej granda ĝusta entjero en la intervalo [x, y] inkluzive.Tiu funkcio prenas du pozitivajn nombrojn x kaj y kaj redonas la # >>> choose_num(12, 15)\n# 14\n# >>> choose_num(13, 12)\n# -1\nchoose_num <- function(x, y) {","canonical_solution":"choose_num <- function(x, y) {\n  if (x > y) {\n    return(-1)\n  }\n  \n  for (num in seq(y, x, by = -1)) {\n    if (num %% 2 == 0) {\n      return(num)\n    }\n  }\n  \n  return(-1)\n}","tests":"test_humaneval <- function() {\n    candidate <- choose_num\n    stopifnot(isTRUE(all.equal(candidate(12, 15), 14)))\n    stopifnot(isTRUE(all.equal(candidate(13, 12), -1)))\n    stopifnot(isTRUE(all.equal(candidate(33, 12354), 12354)))\n    stopifnot(isTRUE(all.equal(candidate(5234, 5233), -1)))\n    stopifnot(isTRUE(all.equal(candidate(6, 29), 28)))\n    stopifnot(isTRUE(all.equal(candidate(27, 10), -1)))\n    stopifnot(isTRUE(all.equal(candidate(7, 7), -1)))\n    stopifnot(isTRUE(all.equal(candidate(546, 546), 546)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_103","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: Se n estas pli granda ol m, redonu -1. Prenu la rezultan nombron kaj ĝin miksu en la binaran nombron.mezumo de la entjeroj de n ĝis m (inkluzive de n kaj m).Vi ricevas du pozitivajn entjerojn n kaj m, kaj via tasko estas kalkuli la # >>> rounded_avg(1, 5)\n# '0b11'\n# >>> rounded_avg(7, 5)\n# -1\n# >>> rounded_avg(10, 20)\n# '0b1111'\n# >>> rounded_avg(20, 33)\n# '0b11010'\nrounded_avg <- function(n, m) {","canonical_solution":"rounded_avg <- function(n, m) {\n  if (n > m) {\n    return(-1)\n  }\n  avg <- mean(n:m)\n  rounded_avg <- round(avg)\n  binary_avg <- as.character(as.binary(rounded_avg))\n  return(paste0(\"0b\", binary_avg))\n}\n\nas.binary <- function(num) {\n  if (num == 0) {\n    return(\"0\")\n  }\n  binary <- \"\"\n  while (num > 0) {\n    binary <- paste0(num %% 2, binary)\n    num <- num %\/% 2\n  }\n  return(binary)\n}","tests":"test_humaneval <- function() {\n    candidate <- rounded_avg\n    stopifnot(isTRUE(all.equal(candidate(1, 5), '0b11')))\n    stopifnot(isTRUE(all.equal(candidate(7, 13), '0b1010')))\n    stopifnot(isTRUE(all.equal(candidate(964, 977), '0b1111001010')))\n    stopifnot(isTRUE(all.equal(candidate(996, 997), '0b1111100100')))\n    stopifnot(isTRUE(all.equal(candidate(560, 851), '0b1011000010')))\n    stopifnot(isTRUE(all.equal(candidate(185, 546), '0b101101110')))\n    stopifnot(isTRUE(all.equal(candidate(362, 496), '0b110101101')))\n    stopifnot(isTRUE(all.equal(candidate(350, 902), '0b1001110010')))\n    stopifnot(isTRUE(all.equal(candidate(197, 233), '0b11010111')))\n    stopifnot(isTRUE(all.equal(candidate(7, 5), -1)))\n    stopifnot(isTRUE(all.equal(candidate(5, 1), -1)))\n    stopifnot(isTRUE(all.equal(candidate(5, 5), '0b101')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_104","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Noto: La reveninta listo devas esti ordigita laŭ kreskanta ordo.elementoj, kiuj ne havas iujn ajn parajn ciferojn.Donita listo de pozitivaj entjeroj x. redonu ordigitan liston de ĉiuj # >>> unique_digits(c(15, 33, 1422, 1))\n# c(1, 15, 33)\n# >>> unique_digits(c(152, 323, 1422, 10))\n# c()\nunique_digits <- function(x) {","canonical_solution":"unique_digits <- function(x) {\n  has_no_even_digit <- function(num) {\n    digits <- as.numeric(strsplit(as.character(num), \"\")[[1]])\n    return(all(digits %% 2 != 0))\n  }\n  \n  result <- Filter(has_no_even_digit, x)\n  return(sort(result))\n}","tests":"test_humaneval <- function() {\n    candidate <- unique_digits\n    stopifnot(isTRUE(all.equal(candidate(c(15, 33, 1422, 1)), c(1, 15, 33))))\n    stopifnot(isTRUE(all.equal(candidate(c(152, 323, 1422, 10)), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(12345, 2033, 111, 151)), c(111, 151))))\n    stopifnot(isTRUE(all.equal(candidate(c(135, 103, 31)), c(31, 135))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_105","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Unu, du, tri, kvar, kvin, ses, sep, ok, naŭ.inversigas la rezultantan vektoron, kaj poste anstataŭigas ĉiun ciferon per ĝia ekvivalenta nomo de Donita vektoro de entjeroj, ordigu la entjerojn kiuj estas inter 1 kaj 9 inkluzive, # >>> by_length(c(2, 1, 1, 4, 5, 8, 2, 3))\n# c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One')\n#   If the vector is empty, return an empty vector:\n# >>> by_length(c())\n# c()\n#   If the vector has any strange number ignore it:\n# >>> by_length(c(1, -1, 55))\n# c('One')\nby_length <- function(arr) {","canonical_solution":"by_length <- function(arr) {\n  # Filter numbers between 1 and 9\n  valid_nums <- arr[arr >= 1 & arr <= 9]\n  # Sort the numbers\n  sorted_nums <- sort(valid_nums, decreasing = TRUE)\n  # Map numbers to their names\n  num_to_name <- c(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n  result <- num_to_name[sorted_nums]\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- by_length\n    stopifnot(isTRUE(all.equal(candidate(c(2, 1, 1, 4, 5, 8, 2, 3)), c('Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 55)), c('One'))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1, 3, 2)), c('Three', 'Two', 'One'))))\n    stopifnot(isTRUE(all.equal(candidate(c(9, 4, 8)), c('Nine', 'Eight', 'Four'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_106","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: la faktoriala de mi estas la multipliko de la nombroj de 1 ĝis mi (1 * 2 * ... * mi).Mi komencas de la unua.aŭ la sumo de la nombroj de 1 ĝis i alie. kaj redonas liston de grandeco n, tia ke la valoro de la elemento ĉe indekso i estas la faktorilo de i se i estas para Implementigu la funkcion f kiu prenas n kiel parametron, # >>> f(5)\n# c(1, 2, 6, 24, 15)\nf <- function(n) {","canonical_solution":"f <- function(n) {\n  result <- numeric(n)  # Initialize a numeric vector of length n\n  for (i in 1:n) {\n    if (i %% 2 == 0) {  # Check if i is even\n      result[i] <- factorial(i)\n    } else {\n      result[i] <- sum(1:i)\n    }\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- f\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 2, 6, 24, 15))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(1, 2, 6, 24, 15, 720, 28))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2, 6))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_107","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo 1: entjeroj palindromoj kiuj falas ene de la intervalo ((1, n), inkluzive. Donita pozitiva entjero n, redonu liston kiu havas la nombron de egalaj kaj neparaj # >>> even_odd_palindrome(3)\n# c(1, 2)\n#     Explanation:\n#     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome(12)\n# c(4, 6)\n#     Explanation:\n#     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n#     1. 1 <= n <= 10^3\n#     2. returned list has the number of even and odd integer palindromes respectively.\neven_odd_palindrome <- function(n) {","canonical_solution":"even_odd_palindrome <- function(n) {\n  is_palindrome <- function(x) {\n    str_x <- as.character(x)\n    return(str_x == paste(rev(unlist(strsplit(str_x, \"\"))), collapse = \"\"))\n  }\n  \n  even_count <- 0\n  odd_count <- 0\n  \n  for (i in 1:n) {\n    if (is_palindrome(i)) {\n      if (i %% 2 == 0) {\n        even_count <- even_count + 1\n      } else {\n        odd_count <- odd_count + 1\n      }\n    }\n  }\n  \n  return(c(even_count, odd_count))\n}","tests":"test_humaneval <- function() {\n    candidate <- even_odd_palindrome\n    stopifnot(isTRUE(all.equal(candidate(123), c(8, 13))))\n    stopifnot(isTRUE(all.equal(candidate(12), c(4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(63), c(6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(25), c(5, 6))))\n    stopifnot(isTRUE(all.equal(candidate(19), c(4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(9), c(4, 5))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(0, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_108","nl":"epo_Latn","pl":"r","prompt":"Ekzemple, -123 havas subskribojn -1, 2 kaj 3.Se la nombro estas negativa, tiam ĝia unua signo estos negativa: la nombro de elementoj, kies cifera sumo estas > 0. Skribu funkcion count_nums kiu prenas vektoro de entjeroj kaj resendas # >>> count_nums(c())\n# 0\n# >>> count_nums(c(-1, 11, -11))\n# 1\n# >>> count_nums(c(1, 1, 2))\n# 3\ncount_nums <- function(arr) {","canonical_solution":"count_nums <- function(arr) {\n  # Helper function to calculate sum of digits\n  sum_of_digits <- function(num) {\n    digits <- as.numeric(unlist(strsplit(as.character(num), \"\")))\n    return(sum(digits, na.rm = TRUE))\n  }\n  \n  # Apply the sum_of_digits function and count numbers with sum > 0\n  return(sum(sapply(arr, sum_of_digits) > 0))\n}","tests":"test_humaneval <- function() {\n    candidate <- count_nums\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, 0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 2, -2, 3, 4, 5)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 6, 9, -6, 0, 1, 5)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 100, 98, -7, 1, -1)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(12, 23, 34, -45, -56, 0)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_109","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Noto: La donita listo estas garantiita havi unikajn elementojn.Se la donita vektoro estas malplena tiam revenas TRUE. tiam return TRUE alie return FALSE. Se eblas akiri la ordigitan vektoro farante la suprajn operaciojn la komenca pozicio en la vektoro t.e. 0-a indekso.La lasta elemento de la vektoro estos movita al Unu dekstrospaca operacio signifas, ke ĉiuj elementoj de la vektoro estas ŝanĝitaj je unu.Vi rajtas plenumi dekstruman ŝanĝoperacion kiom ajn da fojoj.la sekva operacio sur la donita vektoro: Eblas akiri vektoron ordigitan en ne-malkreskanta ordo per la agado la nombroj en la vektoro estos hazarde ordigitaj. Via tasko estas determini ĉu Ni havas vektoron 'arr' de N entjeroj arr[1], arr[2], ..., arr[N]. La # >>> move_one_ball(c(3, 4, 5, 1, 2))\n# TRUE\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n#              be achieved for the given vector.\n# >>> move_one_ball(c(3, 5, 4, 1, 2))\n# FALSE\n# Explanation:It is not possible to get non-decreasing order for the given\n#             vector by performing any number of right shift operations.\nmove_one_ball <- function(arr) {","canonical_solution":"move_one_ball <- function(arr) {\n  if (length(arr) == 0) {\n    return(TRUE)\n  }\n  \n  n <- length(arr)\n  for (i in 1:n) {\n    shifted_arr <- c(tail(arr, n - i), head(arr, i))\n    if (all(diff(shifted_arr) >= 0)) {\n      return(TRUE)\n    }\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- move_one_ball\n    stopifnot(isTRUE(all.equal(candidate(c(3, 4, 5, 1, 2)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 10, 1, 2)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 3, 1, 2)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 5, 4, 1, 2)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_110","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Alie, redonu \"NE\". por ke ĉiuj elementoj de lst1 estu paraj, redonu \"YES\". Se eblas interŝanĝi elementojn inter la LST1 kaj LST2 por fari Ne estas limo por la nombro de elementoj interŝanĝitaj inter lst1 kaj lst2.inter ili por fari lst1 listo de nur eĉ nombroj. kaj determinas ĉu eblas fari interŝanĝon de elementoj En tiu ĉi problemo, vi efektivigos funkcion kiu prenas du listojn de nombroj, # >>> exchange(c(1, 2, 3, 4), c(1, 2, 3, 4))\n# 'YES'\n# >>> exchange(c(1, 2, 3, 4), c(1, 5, 3, 4))\n# 'NO'\n# It is assumed that the input lists will be non-empty.\nexchange <- function(lst1, lst2) {","canonical_solution":"exchange <- function(lst1, lst2) {\n  # Identify even and odd numbers in lst1\n  lst1_even <- lst1[lst1 %% 2 == 0]\n  lst1_odd <- lst1[lst1 %% 2 != 0]\n  \n  # Identify even numbers in lst2\n  lst2_even <- lst2[lst2 %% 2 == 0]\n  \n  # Check if the number of odd elements in lst1 can be replaced with even elements from lst2\n  if (length(lst1_odd) <= length(lst2_even)) {\n    return(\"YES\")\n  } else {\n    return(\"NO\")\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- exchange\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 2, 3, 4)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(1, 5, 3, 4)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4), c(2, 1, 4, 3)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 4)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 7, 3), c(2, 6, 3)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 6, 1, 8, 9), c(3, 5, 5, 1, 1, 1)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(100, 200), c(200, 200)), 'YES')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_111","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: Se pluraj literoj havas la saman okazon, redonu ĉiujn el ili.de la letero kun la plej granda ripeto kaj enhavanta la korespondan nombron. Donita ŝnuro reprezentanta spaco apartigita malgrandaj literoj, redonu nomitan liston # >>> histogram('a b c')\n# list('a' = 1, 'b' = 1, 'c' = 1)\n# >>> histogram('a b b a')\n# list('a' = 2, 'b' = 2)\n# >>> histogram('a b c a b')\n# list('a' = 2, 'b' = 2)\n# >>> histogram('b b b b a')\n# list('b' = 4)\n# >>> histogram('')\n# list()\nhistogram <- function(test) {","canonical_solution":"histogram <- function(test) {\n  # Split the string into individual letters.\n  letters <- unlist(strsplit(test, \" \"))\n  \n  # Create a table to count the occurrences of each letter.\n  count_table <- table(letters)\n  \n  # Find the maximum frequency of occurrences.\n  max_count <- max(count_table, na.rm = TRUE)\n  \n  # Find all letters that have the maximum frequency.\n  max_letters <- names(count_table[count_table == max_count])\n  \n  # Create a named list with letters as names and their max occurrences as values.\n  result <- setNames(as.list(rep(max_count, length(max_letters))), max_letters)\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- histogram\n    stopifnot(isTRUE(all.equal(candidate('a b b a'), list('a' = 2, 'b' = 2))))\n    stopifnot(isTRUE(all.equal(candidate('a b c a b'), list('a' = 2, 'b' = 2))))\n    stopifnot(isTRUE(all.equal(candidate('a b c d g'), list('a' = 1, 'b' = 1, 'c' = 1, 'd' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate('b b b b a'), list('b' = 4))))\n    stopifnot(isTRUE(all.equal(candidate('r t g'), list('r' = 1, 't' = 1, 'g' = 1))))\n    stopifnot(isTRUE(all.equal(candidate(''), list())))\n    stopifnot(isTRUE(all.equal(candidate('a'), list('a' = 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_112","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo Vi devas resendi liston enhavanta la rezultan ŝnuron kaj TRUE\/FALSE por la kontrolo. Ŝnuro nomiĝas palindromo se ĝi legas la saman malantaŭen kiel antaŭen.tiam kontrolu ĉu la rezulta ŝnuro estas palindroma. Ni havas du malsamajn karakterojn, s kaj c, do vi devas forigi ĉiun literon de s, kiu egalas al ĉiu alia en c.Tasko # >>> reverse_delete('abcde', 'ae')\n# list('bcd', FALSE)\n# >>> reverse_delete('abcdef', 'b')\n# list('acdef', FALSE)\n# >>> reverse_delete('abcdedcba', 'ab')\n# list('cdedc', TRUE)\nreverse_delete <- function(s, c) {","canonical_solution":"reverse_delete <- function(s, c) {\n  # Remove characters in 'c' from 's'\n  for (char in strsplit(c, '')[[1]]) {\n    s <- gsub(char, \"\", s)\n  }\n  \n  # Check if the resultant string is a palindrome\n  is_palindrome <- s == paste(rev(strsplit(s, NULL)[[1]]), collapse = \"\")\n  \n  # Return the resultant string and the palindrome check result\n  return(list(s, is_palindrome))\n}","tests":"test_humaneval <- function() {\n    candidate <- reverse_delete\n    stopifnot(isTRUE(all.equal(candidate('abcde', 'ae'), list('bcd', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdef', 'b'), list('acdef', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'ab'), list('cdedc', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('dwik', 'w'), list('dik', FALSE))))\n    stopifnot(isTRUE(all.equal(candidate('a', 'a'), list('', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', ''), list('abcdedcba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('abcdedcba', 'v'), list('abcdedcba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('vabba', 'v'), list('abba', TRUE))))\n    stopifnot(isTRUE(all.equal(candidate('mamma', 'mia'), list('', TRUE))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_113","nl":"epo_Latn","pl":"r","prompt":"de malpara ciferoj en la i'th ŝnuro de la enigaĵo. \" kie ĉiuj i'oj devas esti anstataŭigitaj per la nombro Ĉiu elemento i de la produktaĵo devus esti \"la nombro da neparaj elementoj en la Donita listo de ŝnuroj, kie ĉiu ŝnuro konsistas nur el ciferoj, redonu liston.# >>> odd_count(c('1234567'))\n# c('the number of odd elements 4n the str4ng 4 of the 4nput.')\n# >>> odd_count(c('3', '11111111'))\n# c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.')\nodd_count <- function(lst) {","canonical_solution":"odd_count <- function(lst) {\n  sapply(lst, function(x) {\n    odd_digits <- sum(as.numeric(unlist(strsplit(x, \"\"))) %% 2 == 1)\n    sprintf(\"the number of odd elements %dn the str%2$sing %1$d of the %3$nput.\", odd_digits, odd_digits, odd_digits)\n  })\n}\n\n# Example usage\nprint(odd_count(c('1234567')))\nprint(odd_count(c('3', '11111111')))","tests":"test_humaneval <- function() {\n    candidate <- odd_count\n    stopifnot(isTRUE(all.equal(candidate(c('1234567')), c('the number of odd elements 4n the str4ng 4 of the 4nput.'))))\n    stopifnot(isTRUE(all.equal(candidate(c('3', '11111111')), c('the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'))))\n    stopifnot(isTRUE(all.equal(candidate(c('271', '137', '314')), c('the number of odd elements 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2n the str2ng 2 of the 2nput.'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_114","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo de nombroj.Donita vektoro de entjeroj n, trovu la minimuman sumon de ajna ne-malplena sub-vektoron # >>> minSubArraySum(c(2, 3, 4, 1, 2, 4))\n# 1\n# >>> minSubArraySum(c(-1, -2, -3))\n# -6\nminSubArraySum <- function(nums) {","canonical_solution":"minSubArraySum <- function(nums) {\n  min_sum <- nums[1]\n  current_sum <- 0\n  \n  for (num in nums) {\n    if (current_sum > 0) {\n      current_sum <- 0\n    }\n    current_sum <- current_sum + num\n    if (current_sum < min_sum) {\n      min_sum <- current_sum\n    }\n  }\n  \n  return(min_sum)\n}","tests":"test_humaneval <- function() {\n    candidate <- minSubArraySum\n    stopifnot(isTRUE(all.equal(candidate(c(2, 3, 4, 1, 2, 4)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 2, -10)), -14)))\n    stopifnot(isTRUE(all.equal(candidate(c(-9999999999999999)), -9999999999999999)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 10, 20, 1000000)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -2, -3, 10, -5)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, -1, -2, -3, 10, -5)), -6)))\n    stopifnot(isTRUE(all.equal(candidate(c(10, 11, 13, 8, 3, 4)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(100, -33, 32, -1, 0, -2)), -33)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10)), -10)))\n    stopifnot(isTRUE(all.equal(candidate(c(7)), 7)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -1)), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_115","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo 1: Elsendi la nombron da fojoj vi bezonas malaltigi la siteloj.Via tasko estas uzi la sitelojn por malplenigi la putojn.Kaj ĉiuj siteloj havas la saman kapaciton.Ĉiu puto havas korespondan sitelon, kiu povas esti uzata por eltiri akvon el ĝi, kaj po 1 por arbo estas 1 por akvo.Vi ricevas rektangulan kradon de putoj. Ĉiu vico reprezentas unu puton, # >>> max_fill(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1)\n# 6\n# Example 2:\n# >>> max_fill(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2)\n# 5\n# Example 3:\n# >>> max_fill(list(c(0, 0, 0), c(0, 0, 0)), 5)\n# 0\n# Constraints:\n#     * all wells have the same length\n#     * 1 <= grid.length <= 10^2\n#     * 1 <= grid[:,1].length <= 10^2\n#     * grid[i][j] -> 0 | 1\n#     * 1 <= capacity <= 10\nmax_fill <- function(grid, capacity) {","canonical_solution":"max_fill <- function(grid, capacity) {\n  total_water <- sum(unlist(grid))\n  num_buckets_needed <- ceiling(total_water \/ capacity)\n  return(num_buckets_needed)\n}","tests":"test_humaneval <- function() {\n    candidate <- max_fill\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 0), c(0, 1, 0, 0), c(1, 1, 1, 1)), 1), 6)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 1, 1), c(0, 0, 0, 0), c(1, 1, 1, 1), c(0, 1, 1, 1)), 2), 5)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(0, 0, 0), c(0, 0, 0)), 5), 0)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 2), 4)))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 1, 1, 1), c(1, 1, 1, 1)), 9), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_116","nl":"epo_Latn","pl":"r","prompt":"Ĝi devas esti efektivigita jene: Por simila nombro da unuoj, ordigu laŭ decimala valoro.nombro de unuoj en ilia binara reprezentado en kreskanta sinsekvo. En tiu Kata, vi devas ordigi vektoron de ne-negativaj entjeroj laŭ # >>> sort_array(c(1, 5, 2, 3, 4))\n# c(1, 2, 3, 4, 5)\n# >>> sort_array(c(-2, -3, -4, -5, -6))\n# c(-6, -5, -4, -3, -2)\n# >>> sort_array(c(1, 0, 2, 3, 4))\n# c(0, 1, 2, 3, 4)\nsort_array <- function(arr) {","canonical_solution":"sort_array <- function(arr) {\n  # Filter out negative numbers and sort them directly\n  negative_numbers <- sort(arr[arr < 0])\n  \n  # Process non-negative numbers\n  non_negative_numbers <- arr[arr >= 0]\n  \n  # Sort non-negative numbers based on number of 1s in binary representation, then by decimal value\n  sorted_non_negative_numbers <- non_negative_numbers[order(sapply(non_negative_numbers, function(x) {\n    sum(as.integer(intToBits(x)))\n  }), non_negative_numbers)]\n  \n  # Combine sorted negative and non-negative numbers\n  c(negative_numbers, sorted_non_negative_numbers)\n}","tests":"test_humaneval <- function() {\n    candidate <- sort_array\n    stopifnot(isTRUE(all.equal(candidate(c(1, 5, 2, 3, 4)), c(1, 2, 4, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, -3, -4, -5, -6)), c(-4, -2, -6, -5, -3))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 2, 3, 4)), c(0, 1, 2, 4, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4)), c(2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77))))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 6, 44, 12, 32, 5)), c(32, 3, 5, 6, 12, 44))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8, 16, 32)), c(2, 4, 8, 16, 32))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_117","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Noto: Vi povas supozi la eniga ŝnuro enhavas nur literoj kaj spacoj.Se la ŝnuro s estas malplena tiam la funkcio devas resendi malplenan liston. n konsonantoj, por ke tiuj vortoj aperu en la ŝnuro s. funkcio kiu resendas liston de ĉiuj vortoj el ŝnuro s, kiuj enhavas precize Donita ŝnuro s kaj natura nombro n, vi estis taskita por efektivigi # >>> select_words('Mary had a little lamb', 4)\n# c('little')\n# >>> select_words('Mary had a little lamb', 3)\n# c('Mary', 'lamb')\n# >>> select_words('simple white space', 2)\n# c()\n# >>> select_words('Hello world', 4)\n# c('world')\n# >>> select_words('Uncle sam', 3)\n# c('Uncle')\nselect_words <- function(s, n) {","canonical_solution":"select_words <- function(s, n) {\n  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n  words <- strsplit(s, \" \")[[1]]\n  result <- sapply(words, function(word) {\n    consonants_count <- nchar(gsub(paste(vowels, collapse = \"|\"), \"\", word))\n    if (consonants_count == n) return(word)\n    else return(NULL)\n  })\n  result <- result[!sapply(result, is.null)]\n  unname(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- select_words\n    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 4), c('little'))))\n    stopifnot(isTRUE(all.equal(candidate('Mary had a little lamb', 3), c('Mary', 'lamb'))))\n    stopifnot(isTRUE(all.equal(candidate('simple white space', 2), c())))\n    stopifnot(isTRUE(all.equal(candidate('Hello world', 4), c('world'))))\n    stopifnot(isTRUE(all.equal(candidate('Uncle sam', 3), c('Uncle'))))\n    stopifnot(isTRUE(all.equal(candidate('', 4), c())))\n    stopifnot(isTRUE(all.equal(candidate('a b c d e f', 1), c('b', 'c', 'd', 'f'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_118","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: Vi povas supozi ke la donita ŝnuro enhavas nur angla litero.trovi iun vokalon, kiu plenumas ĉi-supran kondiĉon.Vokaloj en la komenco kaj fino ne estas kalkulitaj. Redonu malplenan ŝnuron se vi ne faris tion.du konsonantoj de la dekstra flanko de la vorto (kazo sentema). Vi ricevas vorton. Via tasko estas trovi la plej proksiman vokalon, kiu staras inter # >>> get_closest_vowel('yogurt')\n# 'u'\n# >>> get_closest_vowel('FULL')\n# 'U'\n# >>> get_closest_vowel('quick')\n# ''\n# >>> get_closest_vowel('ab')\n# ''\nget_closest_vowel <- function(word) {","canonical_solution":"get_closest_vowel <- function(word) {\n  vowels <- c('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n  n <- nchar(word)\n  \n  # Iterate from the second to last position to the second position\n  for (i in (n-1):2) {\n    if (substr(word, i, i) %in% vowels) {\n      if (!substr(word, i-1, i-1) %in% vowels && !substr(word, i+1, i+1) %in% vowels) {\n        return(substr(word, i, i))\n      }\n    }\n  }\n  \n  # Return empty string if no vowel is found\n  return('')\n}","tests":"test_humaneval <- function() {\n    candidate <- get_closest_vowel\n    stopifnot(isTRUE(all.equal(candidate('yogurt'), 'u')))\n    stopifnot(isTRUE(all.equal(candidate('full'), 'u')))\n    stopifnot(isTRUE(all.equal(candidate('easy'), '')))\n    stopifnot(isTRUE(all.equal(candidate('eAsy'), '')))\n    stopifnot(isTRUE(all.equal(candidate('ali'), '')))\n    stopifnot(isTRUE(all.equal(candidate('bad'), 'a')))\n    stopifnot(isTRUE(all.equal(candidate('most'), 'o')))\n    stopifnot(isTRUE(all.equal(candidate('ab'), '')))\n    stopifnot(isTRUE(all.equal(candidate('ba'), '')))\n    stopifnot(isTRUE(all.equal(candidate('quick'), '')))\n    stopifnot(isTRUE(all.equal(candidate('anime'), 'i')))\n    stopifnot(isTRUE(all.equal(candidate('Asia'), '')))\n    stopifnot(isTRUE(all.equal(candidate('Above'), 'o')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_119","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Se ekzistas maniero fari bonan ŝnuron, ĝi resendas \"Jes\", kaj se ne, ĝi resendas \"Ne\".\" (()) \" ne estas. Ekzemple: la ŝnuro '(())))' estas bona, dum la ŝnuro Ŝnuro S estas konsiderata bona se kaj nur se ĉiuj krampoj en S la rezulta ŝnuro estos bona.Via tasko estas kontroli ĉu eblas kunigi la du ŝnurojn en nur parentezojn \" ((\") aŭ proksimajn parentezojn \") \".Vi ricevas liston de du ŝnuroj, ambaŭ ŝnuroj konsistas el malfermaj # >>> match_parens(c('()(', ')'))\n# 'Yes'\n# >>> match_parens(c(')', ')'))\n# 'No'\nmatch_parens <- function(lst) {","canonical_solution":"match_parens <- function(lst) {\n  is_balanced <- function(s) {\n    balance <- 0\n    for (ch in strsplit(s, \"\")[[1]]) {\n      if (ch == '(') {\n        balance <- balance + 1\n      } else {\n        balance <- balance - 1\n      }\n      if (balance < 0) return(FALSE)\n    }\n    return(balance == 0)\n  }\n  \n  s1 <- lst[1]\n  s2 <- lst[2]\n  \n  if (is_balanced(paste0(s1, s2)) || is_balanced(paste0(s2, s1))) {\n    return('Yes')\n  } else {\n    return('No')\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- match_parens\n    stopifnot(isTRUE(all.equal(candidate(c('()(', ')')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c(')', ')')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(()(())', '())())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')())', '(()()(')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('(())))', '(()())((')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('()', '())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(()(', '()))()')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c('((((', '((())')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')(()', '(()(')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c(')(', ')(')), 'No')))\n    stopifnot(isTRUE(all.equal(candidate(c('(', ')')), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate(c(')', '(')), 'Yes')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_120","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo 1: de longo k kun la maksimumaj k nombroj en arr. Donita vektoro arr de entjeroj kaj pozitiva entjero k, redonu ordigitan liston # >>> maximum(c(-3, -4, 5), 3)\n# c(-4, -3, 5)\n# Example 2:\n# >>> maximum(c(4, -4, 4), 2)\n# c(4, 4)\n# Example 3:\n# >>> maximum(c(-3, 2, 1, 2, -1, -2, 1), 1)\n# c(2)\n# Note:\n#     1. The length of the vector will be in the range of [1, 1000].\n#     2. The elements in the vector will be in the range of [-1000, 1000].\n#     3. 0 <= k <= len(arr)\nmaximum <- function(arr, k) {","canonical_solution":"maximum <- function(arr, k) {\n  return(sort(tail(sort(arr), k)))\n}","tests":"test_humaneval <- function() {\n    candidate <- maximum\n    stopifnot(isTRUE(all.equal(candidate(c(-3, -4, 5), 3), c(-4, -3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, -4, 4), 2), c(4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, 2, 1, 2, -1, -2, 1), 1), c(2))))\n    stopifnot(isTRUE(all.equal(candidate(c(123, -123, 20, 0, 1, 2, -3), 3), c(2, 20, 123))))\n    stopifnot(isTRUE(all.equal(candidate(c(-123, 20, 0, 1, 2, -3), 4), c(0, 1, 2, 20))))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 15, 0, 3, -13, -8, 0), 7), c(-13, -8, 0, 0, 3, 5, 15))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 2, 5, 3, -10), 2), c(3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 0, 5, -7), 1), c(5))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, -4), 2), c(-4, 4))))\n    stopifnot(isTRUE(all.equal(candidate(c(-10, 10), 2), c(-10, 10))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, -23, 243, -400, 0), 0), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_121","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj Donita ne-malplena listo de entjeroj, redonu la sumon de ĉiuj neparaj elementoj, kiuj estas en paraj pozicioj. # >>> solution(c(5, 8, 7, 1))\n# 12\n# >>> solution(c(3, 3, 3, 3, 3))\n# 9\n# >>> solution(c(30, 13, 24, 321))\n# 0\nsolution <- function(lst) {","canonical_solution":"solution <- function(lst) {\n  sum(lst[seq(2, length(lst), by = 2)][lst[seq(2, length(lst), by = 2)] %% 2 != 0])\n}","tests":"test_humaneval <- function() {\n    candidate <- solution\n    stopifnot(isTRUE(all.equal(candidate(c(5, 8, 7, 1)), 12)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 3, 3, 3, 3)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 24, 321)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5, 9)), 5)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 8)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(30, 13, 23, 32)), 23)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 13, 2, 9)), 3)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_122","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: la sumo de la elementoj kun maksimume du ciferoj de la unuaj k elementoj de arr. Donita ne-malplena vektoro de entjeroj arr kaj entjero k, redonu # >>> add_elements(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4)\n# 24\n# Constraints:\n#     1. 1 <= len(arr) <= 100\n#     2. 1 <= k <= len(arr)\nadd_elements <- function(arr, k) {","canonical_solution":"add_elements <- function(arr, k) {\n  sum(arr[1:k][nchar(abs(arr[1:k])) <= 2])\n}","tests":"test_humaneval <- function() {\n    candidate <- add_elements\n    stopifnot(isTRUE(all.equal(candidate(c(1, -2, -3, 41, 57, 76, 87, 88, 99), 3), -4)))\n    stopifnot(isTRUE(all.equal(candidate(c(111, 121, 3, 4000, 5, 6), 2), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(11, 21, 3, 90, 5, 6, 7, 8, 9), 4), 125)))\n    stopifnot(isTRUE(all.equal(candidate(c(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4), 24)))\n    stopifnot(isTRUE(all.equal(candidate(c(1), 1), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_123","nl":"epo_Latn","pl":"r","prompt":"get_odd_collatz(5) redonas [1, 5] # La kollata sekvenco por 5 estas [5, 16, 8, 4, 2, 1], do la neparaj nombroj estas nur 1, kaj 5. Ekzemple: 2. resendita listo ordigita laŭ kreskanta ordo. 1. Collatz ((1) estas [1]. Noto: La konjekto estas ke, sendepende de la valoro de n, la sekvenco ĉiam atingos 1.Se la antaŭa estas nepara, la sekva estas 3 obligita de la antaŭa.antaŭa termino kiel sekvas: se la antaŭa termino estas para, la sekva termino estas duono de kiel sekvas: komenci kun iu ajn pozitiva entjero n. Tiam ĉiu esprimo estas akirita de la La supozo de Collatz estas supozo en matematiko kiu koncernas sekvencon difinitan Donita pozitiva entjero n, redonu ordigitan liston kiu havas la neparajn nombrojn en la kollatz-sekvenco.# >>> get_odd_collatz(5)\n# c(1, 5)\nget_odd_collatz <- function(n) {","canonical_solution":"get_odd_collatz <- function(n) {\n  collatz_sequence <- function(n) {\n    sequence <- c(n)\n    while (n != 1) {\n      if (n %% 2 == 0) {\n        n <- n \/ 2\n      } else {\n        n <- 3 * n + 1\n      }\n      sequence <- c(sequence, n)\n    }\n    return(sequence)\n  }\n  \n  sequence <- collatz_sequence(n)\n  odd_numbers <- unique(sequence[sequence %% 2 != 0])\n  return(sort(odd_numbers))\n}","tests":"test_humaneval <- function() {\n    candidate <- get_odd_collatz\n    stopifnot(isTRUE(all.equal(candidate(14), c(1, 5, 7, 11, 13, 17))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 5))))\n    stopifnot(isTRUE(all.equal(candidate(12), c(1, 3, 5))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_124","nl":"epo_Latn","pl":"r","prompt":"4. La dato estu en la formato: mm-dd-yyyy La monatoj ne estu malpli ol 1 aŭ pli ol 12.La nombro de tagoj ne estas malpli ol 1 aŭ pli alta ol 31 tagoj por monatoj 1,3,5,7,8,10,12. Kaj la nombro de tagoj ne estas malpli ol 1 aŭ pli alta ol 30 tagoj por monatoj 4,6,9,11. Kaj, la nombro de tagoj ne estas malpli ol 1 aŭ pli alta ol 29 por la monato 2.1. La datenĉeno ne estas malplena.La dato validas se ĉiuj el la sekvaj reguloj estas plenumitaj: returnas TRUE se la dato estas valida alie FALSE. Vi devas skribi funkcion kiu validas donita datumo ŝnuro kaj # >>> valid_date('03-11-2000')\n# TRUE\n# >>> valid_date('15-01-2012')\n# FALSE\n# >>> valid_date('04-0-2040')\n# FALSE\n# >>> valid_date('06-04-2020')\n# TRUE\n# >>> valid_date('06\/04\/2020')\n# FALSE\nvalid_date <- function(date) {","canonical_solution":"valid_date <- function(date) {\n  # Check if the date is not empty\n  if (date == \"\") {\n    return(FALSE)\n  }\n  \n  # Check the format of the date\n  if (!grepl(\"^\\\\d{2}-\\\\d{2}-\\\\d{4}$\", date)) {\n    return(FALSE)\n  }\n  \n  # Extract the month, day, and year\n  parts <- unlist(strsplit(date, \"-\"))\n  month <- as.numeric(parts[1])\n  day <- as.numeric(parts[2])\n  year <- as.numeric(parts[3])\n  \n  # Check if the month is valid\n  if (month < 1 || month > 12) {\n    return(FALSE)\n  }\n  \n  # Check if the day is valid\n  if (month %in% c(1, 3, 5, 7, 8, 10, 12) && (day < 1 || day > 31)) {\n    return(FALSE)\n  }\n  \n  if (month %in% c(4, 6, 9, 11) && (day < 1 || day > 30)) {\n    return(FALSE)\n  }\n  \n  if (month == 2 && (day < 1 || day > 29)) {\n    return(FALSE)\n  }\n  \n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- valid_date\n    stopifnot(isTRUE(all.equal(candidate('03-11-2000'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('15-01-2012'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-0-2040'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('06-04-2020'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('01-01-2007'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('03-32-2011'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-31-3000'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('06-06-2005'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('21-31-2000'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-12-2003'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('04122003'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('20030412'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2003-04'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2003-04-12'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('04-2003'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_125","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj alfabeto, ord{\"a\") = 0, ord{\"b\") = 1, ... ord{\"z\") = 25 devus disigi sur komojn ',' se neniu komo ekzistas vi devus resendi la nombron de minuskloj kun nepara ordo en la Donita ŝnuro de vortoj, redonu liston de vortoj dividita sur blanka spaco, se neniu blanka spaco ekzistas en la teksto vi # >>> split_words('Hello world!')\n# c('Hello', 'world!')\n# >>> split_words('Hello,world!')\n# c('Hello', 'world!')\n# >>> split_words('abcdef')\n# 3\nsplit_words <- function(txt) {","canonical_solution":"split_words <- function(txt) {\n  if (grepl(\"\\\\s\", txt)) {\n    return(strsplit(txt, \"\\\\s+\")[[1]])\n  } else if (grepl(\",\", txt)) {\n    return(strsplit(txt, \",\")[[1]])\n  } else {\n    odd_order_count <- sum(\n      sapply(unlist(strsplit(txt, \"\")), function(x) {\n        ord <- utf8ToInt(tolower(x)) - utf8ToInt(\"a\")\n        ord %% 2 == 1\n      })\n    )\n    return(odd_order_count)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- split_words\n    stopifnot(isTRUE(all.equal(candidate('Hello world!'), c('Hello', 'world!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello,world!'), c('Hello', 'world!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello world,!'), c('Hello', 'world,!'))))\n    stopifnot(isTRUE(all.equal(candidate('Hello,Hello,world !'), c('Hello,Hello,world', '!'))))\n    stopifnot(isTRUE(all.equal(candidate('abcdef'), 3)))\n    stopifnot(isTRUE(all.equal(candidate('aaabb'), 2)))\n    stopifnot(isTRUE(all.equal(candidate('aaaBb'), 1)))\n    stopifnot(isTRUE(all.equal(candidate(''), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_126","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj nombro, redonu FALSO. Supozu neniujn negativajn nombrojn kaj nur entjerojn. Se listo havas pli ol 1 duplikato de la sama Donita listo de nombroj, redonu ĉu ili estas ordigitaj aŭ ne.# >>> is_sorted(c(5))\n# TRUE\n# >>> is_sorted(c(1, 2, 3, 4, 5))\n# TRUE\n# >>> is_sorted(c(1, 3, 2, 4, 5))\n# FALSE\n# >>> is_sorted(c(1, 2, 3, 4, 5, 6))\n# TRUE\n# >>> is_sorted(c(1, 2, 3, 4, 5, 6, 7))\n# TRUE\n# >>> is_sorted(c(1, 3, 2, 4, 5, 6, 7))\n# FALSE\n# >>> is_sorted(c(1, 2, 2, 3, 3, 4))\n# TRUE\n# >>> is_sorted(c(1, 2, 2, 2, 3, 4))\n# FALSE\nis_sorted <- function(lst) {","canonical_solution":"is_sorted <- function(lst) {\n  if (length(lst) <= 1) {\n    return(TRUE)\n  }\n  \n  # Check for duplicates more than once\n  tbl <- table(lst)\n  if (any(tbl > 2)) {\n    return(FALSE)\n  }\n  \n  # Check if the list is sorted in ascending order\n  for (i in 2:length(lst)) {\n    if (lst[i] < lst[i - 1]) {\n      return(FALSE)\n    }\n  }\n  \n  return(TRUE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_sorted\n    stopifnot(isTRUE(all.equal(candidate(c(5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, 7)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c()), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(3, 2, 1)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 2, 3, 4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 3, 3, 4)), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, 3, 3, 4)), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4)), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_127","nl":"epo_Latn","pl":"r","prompt":"[enir-\/eliro] specimenoj: Se la du intervaloj ne intersekcas, redonu \"NE\".alie, redonu \"NE\". Se la longo de la intersekciĝo estas primo, redonu \"ES\", kiu havas 1 kaj ne estas primo.Ekzemplo, la intersekciĝo de la intervaloj (1, 3), (2, 4) estas (2, 3) intervaloj estas primo. Via tasko estas determini ĉu la longo de la intersekciĝo de tiuj du Por ĉiu intervalo, oni supozas, ke ĝia komenco estas malpli ol aŭ egala al ĝia fino.inkluzivas kaj komencon kaj finon.La donitaj intervaloj estas fermitaj kio signifas ke la intervalo (komenco, fino) kie ĉiu intervalo estas paro de entjeroj. Ekzemple, intervalo = (komenco, fino) = (1, 2).Vi havas du intervalojn,# >>> intersection(c(1, 2), c(2, 3))\n# 'NO'\n# >>> intersection(c(-1, 1), c(0, 4))\n# 'NO'\n# >>> intersection(c(-3, -1), c(-5, 5))\n# 'YES'\nintersection <- function(interval1, interval2) {","canonical_solution":"intersection <- function(interval1, interval2) {\n  start1 <- interval1[1]\n  end1 <- interval1[2]\n  start2 <- interval2[1]\n  end2 <- interval2[2]\n  \n  # Determine the start and end of the intersection\n  intersection_start <- max(start1, start2)\n  intersection_end <- min(end1, end2)\n  \n  # Calculate the length of the intersection\n  length_of_intersection <- intersection_end - intersection_start\n  \n  # If there's no intersection, return \"NO\"\n  if (length_of_intersection < 0) {\n    return('NO')\n  }\n  \n  # Check if the length is a prime number\n  is_prime <- function(num) {\n    if (num <= 1) {\n      return(FALSE)\n    }\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  \n  # Return \"YES\" if the length is prime, otherwise \"NO\"\n  if (is_prime(length_of_intersection)) {\n    return('YES')\n  } else {\n    return('NO')\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- intersection\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(2, 3)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1), c(0, 4)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-3, -1), c(-5, 5)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, 2), c(-4, 0)), 'YES')))\n    stopifnot(isTRUE(all.equal(candidate(c(-11, 2), c(-1, -1)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(3, 5)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2), c(1, 2)), 'NO')))\n    stopifnot(isTRUE(all.equal(candidate(c(-2, -2), c(-3, -2)), 'NO')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_128","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: Noto: return NULL for empty arr. de ĉiu nombro en la vektoro, reprezentita per 1, -1 aŭ 0. sumo de grandecoj de entjeroj multiplikita per produkto de ĉiuj signoj Vi ricevas vectoron kun nombro da entjeroj kaj vi devas respondi por ĝi.# >>> prod_signs(c(1, 2, 2, -4))\n# 9\n# >>> prod_signs(c(0, 1))\n# 0\n# >>> prod_signs(c())\n# NULL\nprod_signs <- function(arr) {","canonical_solution":"prod_signs <- function(arr) {\n  if (length(arr) == 0) {\n    return(NULL)\n  }\n  magnitude_sum <- sum(abs(arr))\n  sign_product <- prod(sign(arr))\n  return(magnitude_sum * sign_product)\n}","tests":"test_humaneval <- function() {\n    candidate <- prod_signs\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 2, -4)), -9)))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 2, 3, -1, 1)), -10)))\n    stopifnot(isTRUE(all.equal(candidate(c()), NULL)))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 2, -1, -1, 9)), 20)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, -1, 1)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 1)), -4)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 1, 1, 0)), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_129","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Redonu ordigitan liston de la valoroj sur la ĉeloj, kiujn trairas la minimuma vojo.Estas garantiite ke la respondo estas unika. lst_A[j] = lst_B[j].tia ke lst_A[i] < lst_B[i] kaj por iu j (1 <= j < i) ni havas ol lst_B, en aliaj vortoj, ekzistas entjera indekso i (1 <= i <= k) tra (ni nomu ilin lst_A kaj lst_B), lst_A estas leksikografe malpli Post fari la ordigitajn listojn de la valoroj sur la ĉeloj, kiujn A kaj B iras Pado A (de longo k) estas konsiderata malpli ol pado B (de longo k) se Vi NE PEUS foriri el la reto.nepre distingaj).Bonvolu noti, ke vojo de longo k signifas viziti ekzakte k ĉelojn (ne Alivorte, vi povas iri al ĉeloj kiuj dividas randon kun vi nun.de ajna ĉelo, kaj en ajna paŝo vi povas moviĝi al ajna najbara ĉelo,Vi devas trovi la minimuman longecon de la vojo de la linio k.inkluziva aperas precize unufoje en la ĉeloj de la krado. ĉiu ĉelo de la krado enhavas valoron. Ĉiu entjero en la intervalo [1, N * N] Surbaze de krado kun N vicoj kaj N kolumnoj (N >= 2) kaj pozitiva entjero k, # >>> minPath(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3)\n# c(1, 2, 1)\n# >>> minPath(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1)\n# c(1)\nminPath <- function(grid, k) {","canonical_solution":"minPath <- function(grid, k) {\n  N <- length(grid)\n  directions <- list(c(0, 1), c(1, 0), c(0, -1), c(-1, 0))\n  \n  is_valid <- function(x, y) {\n    return(x >= 1 && x <= N && y >= 1 && y <= N)\n  }\n  \n  # DFS to find all paths\n  dfs <- function(x, y, path) {\n    if (length(path) == k) {\n      paths <<- append(paths, list(path))\n      return()\n    }\n    \n    for (direction in directions) {\n      nx <- x + direction[1]\n      ny <- y + direction[2]\n      if (is_valid(nx, ny)) {\n        dfs(nx, ny, c(path, grid[[nx]][[ny]]))\n      }\n    }\n  }\n  \n  paths <- list()\n  \n  # Start from every cell\n  for (i in 1:N) {\n    for (j in 1:N) {\n      dfs(i, j, c(grid[[i]][[j]]))\n    }\n  }\n  \n  # Find and return the lexicographically smallest path\n  min_path <- paths[[1]]\n  for (path in paths) {\n    if (path < min_path) {\n      min_path <- path\n    }\n  }\n  \n  return(min_path)\n}","tests":"test_humaneval <- function() {\n    candidate <- minPath\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), 3), c(1, 2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(5, 9, 3), c(4, 1, 6), c(7, 8, 2)), 1), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2, 3, 4), c(5, 6, 7, 8), c(9, 10, 11, 12), c(13, 14, 15, 16)), 4), c(1, 2, 1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(6, 4, 13, 10), c(5, 7, 12, 1), c(3, 16, 11, 15), c(8, 14, 9, 2)), 7), c(1, 10, 1, 10, 1, 10, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(8, 14, 9, 2), c(6, 4, 13, 15), c(5, 7, 1, 12), c(3, 10, 11, 16)), 5), c(1, 7, 1, 7, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(11, 8, 7, 2), c(5, 16, 14, 4), c(9, 3, 15, 6), c(12, 13, 10, 1)), 9), c(1, 6, 1, 6, 1, 6, 1, 6, 1))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(12, 13, 10, 1), c(9, 3, 15, 6), c(5, 16, 14, 4), c(11, 8, 7, 2)), 12), c(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(2, 7, 4), c(3, 1, 5), c(6, 8, 9)), 8), c(1, 3, 1, 3, 1, 3, 1, 3))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(6, 1, 5), c(3, 8, 9), c(2, 7, 4)), 8), c(1, 5, 1, 5, 1, 5, 1, 5))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 2), c(3, 4)), 10), c(1, 2, 1, 2, 1, 2, 1, 2, 1, 2))))\n    stopifnot(isTRUE(all.equal(candidate(list(c(1, 3), c(3, 2)), 10), c(1, 3, 1, 3, 1, 3, 1, 3, 1, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_130","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: la unuaj n + 1 nombroj de la sekvenco de Tribonacci. Se ni havas la nombron n, ni havas la obligon x plus x plus x plus x plus x plus x plus x plus x - do se tio ne funkcias, ni havas nur la obligon x plus x plus x plus x plus x plus x plus x plus x plus y plus x plus x plus x plus y plus x plus x plus y plus x plus y plus x plus y plus x plus y plus x plus y plus y plus y plus y plus y plus y plus y plus y plus y plus y plus y= 2 + 3 + 3 = 8 tri(3) = tri(2) + tri(1) + tri(4) tri(4) = 3 tri(2) = 1 + (2 \/ 2) = 2 Ekzemple: tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), se n estas nepara. tri (n) = 1 + n \/ 2, se n estas para. tri(1) = 3 La sekvenco de Tribonacci estas difinita per la ripetiĝo: Tamen, kio homoj ne scias estas la sekvenco de Tribonacci.Ĉiuj konas la sekvencon de Fibonacci, ĝi estis studita de matematikistoj en # >>> tri(3)\n# c(1, 3, 2, 8)\ntri <- function(n) {","canonical_solution":"tri <- function(n) {\n  if (n == 0) return(c(3))\n  \n  tribonacci <- numeric(n + 1)\n  tribonacci[1] <- 3\n  \n  for (i in 2:(n + 1)) {\n    if (i %% 2 == 0) {\n      tribonacci[i] <- 1 + i \/ 2\n    } else {\n      if (i == 3) {\n        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1]  # tri(3) requires tri(4)\n      } else {\n        # When i > 3 and i is odd, dependencies are always available\n        tribonacci[i] <- tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3 + 2]  # i + 1 becomes i - 3 + 2\n      }\n    }\n  }\n  \n  return(tribonacci)\n}","tests":"test_humaneval <- function() {\n    candidate <- tri\n    stopifnot(isTRUE(all.equal(candidate(3), c(1, 3, 2, 8))))\n    stopifnot(isTRUE(all.equal(candidate(4), c(1, 3, 2, 8, 3))))\n    stopifnot(isTRUE(all.equal(candidate(5), c(1, 3, 2, 8, 3, 15))))\n    stopifnot(isTRUE(all.equal(candidate(6), c(1, 3, 2, 8, 3, 15, 4))))\n    stopifnot(isTRUE(all.equal(candidate(7), c(1, 3, 2, 8, 3, 15, 4, 24))))\n    stopifnot(isTRUE(all.equal(candidate(8), c(1, 3, 2, 8, 3, 15, 4, 24, 5))))\n    stopifnot(isTRUE(all.equal(candidate(9), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35))))\n    stopifnot(isTRUE(all.equal(candidate(20), c(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11))))\n    stopifnot(isTRUE(all.equal(candidate(0), c(1))))\n    stopifnot(isTRUE(all.equal(candidate(1), c(1, 3))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_131","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Redonu 0 se ĉiuj ciferoj estas paraj. Donita pozitiva entjero n, redonu la produktadon de la neparaj ciferoj. # >>> digits(1)\n# 1\n# >>> digits(4)\n# 0\n# >>> digits(235)\n# 15\ndigits <- function(n) {","canonical_solution":"digits <- function(n) {\n  # Convert the number to a character vector\n  digits_vector <- unlist(strsplit(as.character(n), \"\"))\n  \n  # Convert the character vector back to numeric\n  digits_vector <- as.numeric(digits_vector)\n  \n  # Filter out the odd digits\n  odd_digits <- digits_vector[digits_vector %% 2 != 0]\n  \n  # If all digits are even, return 0\n  if (length(odd_digits) == 0) {\n    return(0)\n  }\n  \n  # Calculate and return the product of odd digits\n  return(prod(odd_digits))\n}","tests":"test_humaneval <- function() {\n    candidate <- digits\n    stopifnot(isTRUE(all.equal(candidate(5), 5)))\n    stopifnot(isTRUE(all.equal(candidate(54), 5)))\n    stopifnot(isTRUE(all.equal(candidate(120), 1)))\n    stopifnot(isTRUE(all.equal(candidate(5014), 5)))\n    stopifnot(isTRUE(all.equal(candidate(98765), 315)))\n    stopifnot(isTRUE(all.equal(candidate(5576543), 2625)))\n    stopifnot(isTRUE(all.equal(candidate(2468), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_132","nl":"epo_Latn","pl":"r","prompt":"kie almenaŭ unu krampo en la subsekvenco estas nestita. La funkcio devas resendi TRUE se kaj nur se ekzistas valida subsekvenco de krampoj Krei funkcio kiu prenas ŝnuron kiel enigaĵo kiu enhavas nur kvadratajn kramfilojn.# >>> is_nested('[[]]')\n# TRUE\n# >>> is_nested('[]]]]]]][[[[[]')\n# FALSE\n# >>> is_nested('[][]')\n# FALSE\n# >>> is_nested('[]')\n# FALSE\n# >>> is_nested('[[][]]')\n# TRUE\n# >>> is_nested('[[]][[')\n# TRUE\nis_nested <- function(string) {","canonical_solution":"is_nested <- function(string) {\n  open_count <- 0\n  for (char in unlist(strsplit(string, \"\"))) {\n    if (char == \"[\") {\n      open_count <- open_count + 1\n    } else if (char == \"]\") {\n      if (open_count > 1) {\n        return(TRUE)\n      }\n      open_count <- open_count - 1\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- is_nested\n    stopifnot(isTRUE(all.equal(candidate('[[]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]]]]]][[[[[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[][]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[[[]]]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]]]]]]]]]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[][][[]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[[]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[]]'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[]][['), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('[[][]]'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('[[[[[[[['), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(']]]]]]]]'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_133","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Ĉiu elemento en la listo estas ĉirkaŭirita al la supra int (Taks) unue.Vi devas respondi la kvadraton de la nombroj en la listo, Vi ricevas liston de numeroj.# >>> lst(c(1.0, 2.0, 3.0))\n# 14\n# >>> lst(c(1.0, 4.0, 9.0))\n# 98\n# >>> lst(c(1.0, 3.0, 5.0, 7.0))\n# 84\n# >>> lst(c(1.4, 4.2, 0.0))\n# 29\n# >>> lst(c(-2.4, 1.0, 1.0))\n# 6\nsum_squares <- function(lst) {","canonical_solution":"sum_squares <- function(lst) {\n  sum(ceiling(lst)^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_squares\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 2.0, 3.0)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.0, 3.0, 5.0, 7.0)), 84)))\n    stopifnot(isTRUE(all.equal(candidate(c(1.4, 4.2, 0.0)), 29)))\n    stopifnot(isTRUE(all.equal(candidate(c(-2.4, 1.0, 1.0)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(100.0, 1.0, 15.0, 2.0)), 10230)))\n    stopifnot(isTRUE(all.equal(candidate(c(10000.0, 10000.0)), 200000000)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 4.6, 6.3)), 75)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.4, 17.9, 18.9, 19.9)), 1086)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0, 1.0, 0.0)), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_134","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Noto: \"vorto\" estas grupo de signoj apartigitaj per spaco.parto de vorto, kaj FALSA alie. de donita ŝnuro estas alfabeta signo kaj ne estas Krei funkcion kiu resendas VERA se la lasta signo # >>> check_if_last_char_is_a_letter('apple pie')\n# FALSE\n# >>> check_if_last_char_is_a_letter('apple pi e')\n# TRUE\n# >>> check_if_last_char_is_a_letter('apple pi e ')\n# FALSE\n# >>> check_if_last_char_is_a_letter('')\n# FALSE\ncheck_if_last_char_is_a_letter <- function(txt) {","canonical_solution":"check_if_last_char_is_a_letter <- function(txt) {\n  # Trim any trailing whitespace\n  trimmed_txt <- trimws(txt, which = \"right\")\n  \n  # If the trimmed text is empty, return FALSE\n  if (nchar(trimmed_txt) == 0) {\n    return(FALSE)\n  }\n  \n  # Get the last character\n  last_char <- substr(trimmed_txt, nchar(trimmed_txt), nchar(trimmed_txt))\n  \n  # Check if the last character is an alphabetical character\n  if (grepl(\"[a-zA-Z]\", last_char)) {\n    # Split the text by spaces\n    words <- strsplit(trimmed_txt, \" \")[[1]]\n    # Get the last word\n    last_word <- tail(words, n = 1)\n    # If last character is the only character in the last \"word\", return TRUE\n    # Otherwise, it is part of a word, return FALSE\n    return(nchar(last_word) == 1)\n  }\n  \n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- check_if_last_char_is_a_letter\n    stopifnot(isTRUE(all.equal(candidate('apple'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pi e'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('eeeee'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('A'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie '), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('Pumpkin pie 1'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(''), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('eeeee e '), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pie'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('apple pi e '), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_135","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: duoblaj valoroj.neniu tia elemento ekzistas tiam revenas -1. La donita vektoro ne enhavos ne estas pli granda ol aŭ egala al la elemento tuj antaŭ ĝi. Se Krei funkcion kiu resendas la plej grandan indekson de elemento kiu # >>> can_arrange(c(1, 2, 4, 3, 5))\n# 3\n# >>> can_arrange(c(1, 2, 3))\n# -1\ncan_arrange <- function(arr) {","canonical_solution":"can_arrange <- function(arr) {\n  for (i in seq(length(arr) - 1, 1)) {\n    if (arr[i] > arr[i + 1]) {\n      return(i)\n    }\n  }\n  return(-1)\n}","tests":"test_humaneval <- function() {\n    candidate <- can_arrange\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 3, 5)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 4, 5)), -1)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 2, 5, 6, 7, 8, 9, 10)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 8, 5, 7, 3)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c()), -1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_136","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Se ne estas negativaj aŭ pozitivaj entjeroj, redonu ilin kiel NULL.de pozitivaj entjeroj en listo.la plej granda de ĉiuj negativaj nombroj kaj b estas la plej malgranda de ĉiuj negativaj nombroj Krei funkcio kiu resendas liston (a, b), kie 'a' estas # >>> largest_smallest_integers(c(2, 4, 1, 3, 5, 7))\n# list(NULL, 1)\n# >>> largest_smallest_integers(c())\n# list(NULL, NULL)\n# >>> largest_smallest_integers(c(0))\n# list(NULL, NULL)\nlargest_smallest_integers <- function(lst) {","canonical_solution":"largest_smallest_integers <- function(lst) {\n  negatives <- lst[lst < 0]\n  positives <- lst[lst > 0]\n  \n  largest_negative <- if(length(negatives) > 0) max(negatives) else NULL\n  smallest_positive <- if(length(positives) > 0) min(positives) else NULL\n  \n  list(largest_negative, smallest_positive)\n}","tests":"test_humaneval <- function() {\n    candidate <- largest_smallest_integers\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7)), list(NULL, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(2, 4, 1, 3, 5, 7, 0)), list(NULL, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 3, 2, 4, 5, 6, -2)), c(-2, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(4, 5, 3, 6, 2, 7, -7)), c(-7, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c(7, 3, 8, 4, 9, 2, 5, -9)), c(-9, 2))))\n    stopifnot(isTRUE(all.equal(candidate(c()), list(NULL, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(0)), list(NULL, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6)), list(-1, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, -5, -6, 0)), list(-1, NULL))))\n    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, 1)), c(-3, 1))))\n    stopifnot(isTRUE(all.equal(candidate(c(-6, -4, -4, -3, -100, 1)), c(-3, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_137","nl":"epo_Latn","pl":"r","prompt":"Noto: Se reala nombro estas reprezentita kiel ŝnuro, la flosanta punkto povus esti . aŭ , Redonu NULL se la valoroj estas egalaj. realaj nombroj, kaj resendas la pli grandan variablon en ĝia donita variabla tipo. Krei funkcio kiu prenas entjerojn, flosas, aŭ ŝnuroj reprezentantaj # >>> compare_one(1, 2.5)\n# 2.5\n# >>> compare_one(1, '2,3')\n# '2,3'\n# >>> compare_one('5,1', '6')\n# '6'\n# >>> compare_one('1', 1)\n# NULL\ncompare_one <- function(a, b) {","canonical_solution":"compare_one <- function(a, b) {\n  to_number <- function(x) {\n    if (is.character(x)) {\n      x <- gsub(\",\", \".\", x)\n      as.numeric(x)\n    } else {\n      as.numeric(x)\n    }\n  }\n  \n  a_num <- to_number(a)\n  b_num <- to_number(b)\n  \n  if (a_num == b_num) {\n    return(NULL)\n  } else if (a_num > b_num) {\n    return(a)\n  } else {\n    return(b)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- compare_one\n    stopifnot(isTRUE(all.equal(candidate(1, 2), 2)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2.5), 2.5)))\n    stopifnot(isTRUE(all.equal(candidate(2, 3), 3)))\n    stopifnot(isTRUE(all.equal(candidate(5, 6), 6)))\n    stopifnot(isTRUE(all.equal(candidate(1, '2,3'), '2,3')))\n    stopifnot(isTRUE(all.equal(candidate('5,1', '6'), '6')))\n    stopifnot(isTRUE(all.equal(candidate('1', '2'), '2')))\n    stopifnot(isTRUE(all.equal(candidate('1', 1), NULL)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_138","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo Evaluu ĉu la donita nombro n povas esti skribita kiel la sumo de precize 4 pozitivaj paraj nombroj # >>> is_equal_to_sum_even(4)\n# FALSE\n# >>> is_equal_to_sum_even(6)\n# FALSE\n# >>> is_equal_to_sum_even(8)\n# TRUE\nis_equal_to_sum_even <- function(n) {","canonical_solution":"is_equal_to_sum_even <- function(n) {\n  if (n <= 0 || n %% 2 != 0 || n < 8) {\n    return(FALSE)\n  }\n  remaining_sum <- n\n  count <- 0\n  for (i in seq(2, n, by = 2)) {\n    if (remaining_sum - i >= 2 * (4 - count - 1)) {\n      remaining_sum <- remaining_sum - i\n      count <- count + 1\n    }\n    if (count == 4) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}\n\n# Examples\nis_equal_to_sum_even(4)   # FALSE\nis_equal_to_sum_even(6)   # FALSE\nis_equal_to_sum_even(8)   # TRUE","tests":"test_humaneval <- function() {\n    candidate <- is_equal_to_sum_even\n    stopifnot(isTRUE(all.equal(candidate(4), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(6), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(11), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(12), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(13), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(16), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_139","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: kie n > 0 brazilan_faktorialo (n) = n! * (n-1)! * (n-2)! * ... * 1! La brazila faktoriala estas difinita kiel: # >>> special_factorial(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\nspecial_factorial <- function(n) {","canonical_solution":"special_factorial <- function(n) {\n  result <- 1\n  for (i in 1:n) {\n    result <- result * factorial(i)\n  }\n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- special_factorial\n    stopifnot(isTRUE(all.equal(candidate(4), 288)))\n    stopifnot(isTRUE(all.equal(candidate(5), 34560)))\n    stopifnot(isTRUE(all.equal(candidate(7), 125411328000)))\n    stopifnot(isTRUE(all.equal(candidate(1), 1)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_140","nl":"epo_Latn","pl":"r","prompt":"Poste, anstataŭigu ĉiujn rekte antaŭajn literojn per - kaj se ŝnuro havas pli ol 2 sinsekvaj spacoj, Donita tekstkordo, anstataŭigu ĉiujn spacojn en ĝi per substrekoj, # >>> fix_spaces(' Example')\n# 'Example'\n# >>> fix_spaces(' Example 1')\n# 'Example_1'\n# >>> fix_spaces(' Example 2')\n# '_Example_2'\n# >>> fix_spaces(' Example 3')\n# '_Example-3'\nfix_spaces <- function(text) {","canonical_solution":"fix_spaces <- function(text) {\n  # Trim leading and trailing spaces\n  text <- trimws(text)\n  # Replace 3 or more consecutive spaces with a dash\n  text <- gsub(\" {3,}\", \"-\", text)\n  # Replace remaining spaces with underscores\n  text <- gsub(\" \", \"_\", text)\n  return(text)\n}","tests":"test_humaneval <- function() {\n    candidate <- fix_spaces\n    stopifnot(isTRUE(all.equal(candidate('Example'), 'Example')))\n    stopifnot(isTRUE(all.equal(candidate('Mudasir Hanif '), 'Mudasir_Hanif_')))\n    stopifnot(isTRUE(all.equal(candidate('Yellow Yellow  Dirty  Fellow'), 'Yellow_Yellow__Dirty__Fellow')))\n    stopifnot(isTRUE(all.equal(candidate('Exa   mple'), 'Exa-mple')))\n    stopifnot(isTRUE(all.equal(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_141","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: - La subĉeno post la punkto devus esti unu el tiuj: ['txt', 'exe', 'dll'] la latina alfabeto ('a'-'z' kaj 'A'-'Z'). - La subĉeno antaŭ la punkto ne devas esti malplena, kaj ĝi komenciĝas per letero de - La nomo de la dosiero enhavas precize unu punkton '.' - La nomo de la dosiero ne devas havi pli ol tri ciferojn ('0'-'9'). estas plenumitaj: Nomo de dosiero estas konsiderata valida se kaj nur se ĉiuj sekvaj kondiĉoj \"Jes\" se la nomo de la dosiero estas valida, kaj resendas \"Ne\" alie. Krei funkcio kiu prenas ŝnuron reprezentantan la nomon de dosiero, kaj resendas # >>> file_name_check('example.txt')\n# 'Yes'\n# >>> file_name_check('1example.dll')\n# 'No'\nfile_name_check <- function(file_name) {","canonical_solution":"file_name_check <- function(file_name) {\n  # Split the file name into the name part and the extension part\n  parts <- strsplit(file_name, \"\\\\.\", fixed = TRUE)[[1]]\n  \n  # Check there is exactly one dot\n  if (length(parts) != 2) {\n    return('No')\n  }\n  \n  # Extract the name and extension\n  name_part <- parts[1]\n  ext_part <- parts[2]\n  \n  # Check the extension is valid\n  if (!(ext_part %in% c('txt', 'exe', 'dll'))) {\n    return('No')\n  }\n  \n  # Check the name part is not empty and starts with a letter\n  if (nchar(name_part) == 0 || !grepl(\"^[A-Za-z]\", name_part)) {\n    return('No')\n  }\n  \n  # Count digits in the name part\n  digit_count <- nchar(gsub(\"[^0-9]\", \"\", name_part))\n  \n  # Check there are no more than three digits\n  if (digit_count > 3) {\n    return('No')\n  }\n  \n  return('Yes')\n}","tests":"test_humaneval <- function() {\n    candidate <- file_name_check\n    stopifnot(isTRUE(all.equal(candidate('example.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('1example.dll'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('s1sdf3.asd'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('K.dll'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('MY16FILE3.exe'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('His12FILE94.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('_Y.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('?aREYA.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('\/this_is_valid.dll'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.wow'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_valid.txtexe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('#this2_i4s_5valid.ten'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('@this1_is6_valid.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('this_is_12valid.6exe4.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('all.exe.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('I563_No.exe'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('Is3youfault.txt'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('no_one#knows.dll'), 'Yes')))\n    stopifnot(isTRUE(all.equal(candidate('1I563_Yes3.exe'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('I563_Yes3.txtt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('final..txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('final132'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('_f4indsartal132.'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('.txt'), 'No')))\n    stopifnot(isTRUE(all.equal(candidate('s.'), 'No')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_142","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: ŝanĝas la enirojn en la listo kies indeksoj ne estas multoblo de 3 aŭ 4. La funkcio tiam resendas la sumon de ĉiuj eniroj. Multobla de 3 kaj kubos la entjero-eniron se ĝia indekso estas multobla de 4 kaj ne multobla de 3. La funkcio ne Tiu funkcio prenas liston de entjeroj. Por ĉiuj kontribuoj en la listo, la funkcio kvadratigas la entjeran kontribuon se ĝia indekso estas \" # >>> lst\n# c(1, 2, 3)\n# >>> lst\n# c()\n# >>> lst\n# c(-1, -5, 2, -1, -5)\nsum_squares <- function(lst) {","canonical_solution":"sum_squares <- function(lst) {\n  lst <- sapply(seq_along(lst), function(i) {\n    if (i %% 3 == 0) {\n      return(lst[i]^2)\n    } else if (i %% 4 == 0) {\n      return(lst[i]^3)\n    } else {\n      return(lst[i])\n    }\n  })\n  return(sum(lst))\n}","tests":"test_humaneval <- function() {\n    candidate <- sum_squares\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3)), 6)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 4, 9)), 14)))\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 1, 1, 1, 1, 1, 1, 1, 1)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -1, -1, -1, -1, -1, -1, -1, -1)), -3)))\n    stopifnot(isTRUE(all.equal(candidate(c(0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -5, 2, -1, -5)), -126)))\n    stopifnot(isTRUE(all.equal(candidate(c(-56, -99, 1, 0, -2)), 3030)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, 0, 0, 0, 0, 0, 0, 0, -1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37)), -14196)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10)), -1448)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_143","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo 1: la ordo de la vortoj en la nova ŝnuro devas esti la sama kiel la originala.kies longo estas primoj, Kaj vi devas liveri la veran frazon de la vorto \"eo\" al la fonto de la vorto \"eo\"la frazo enhavas kelkajn vortojn apartigitajn per spaco, Oni donas al vi ĉenon, kiu reprezentas frazon, # >>> words_in_sentence('This is a test')\n# 'is'\n# Example 2:\n# >>> words_in_sentence('lets go for swimming')\n# 'go for'\n# Constraints:\n#     * 1 <= len(sentence) <= 100\n#     * sentence contains only letters\nwords_in_sentence <- function(sentence) {","canonical_solution":"words_in_sentence <- function(sentence) {\n  is_prime <- function(n) {\n    if (n <= 1) return(FALSE)\n    if (n == 2) return(TRUE)\n    for (i in 2:sqrt(n)) {\n      if (n %% i == 0) return(FALSE)\n    }\n    return(TRUE)\n  }\n  \n  words <- strsplit(sentence, \" \")[[1]]\n  prime_words <- words[sapply(words, function(word) is_prime(nchar(word)))]\n  return(paste(prime_words, collapse = \" \"))\n}","tests":"test_humaneval <- function() {\n    candidate <- words_in_sentence\n    stopifnot(isTRUE(all.equal(candidate('This is a test'), 'is')))\n    stopifnot(isTRUE(all.equal(candidate('lets go for swimming'), 'go for')))\n    stopifnot(isTRUE(all.equal(candidate('there is no place available here'), 'there is no place')))\n    stopifnot(isTRUE(all.equal(candidate('Hi I am Hussein'), 'Hi am Hussein')))\n    stopifnot(isTRUE(all.equal(candidate('go for it'), 'go for it')))\n    stopifnot(isTRUE(all.equal(candidate('here'), '')))\n    stopifnot(isTRUE(all.equal(candidate('here is'), 'is')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_144","nl":"epo_Latn","pl":"r","prompt":"Vi povas supozi ke x, kaj n estas ĝustaj frakcioj, kaj ke n havas nul kiel denominatoron.<numerator>\/<denominator> kie kaj numeratoro kaj denominatoro estas pozitivaj entjeroj. kaj x kaj n, estas ŝnuro reprezentanta frakcion, kaj havas la sekvan formaton, x * n. La funkcio resendas VERA se x * n valoras al entjero kaj FALSA Via tasko estas efektivigi funkcion kiu simpligos la esprimon # >>> simplify('1\/5', '5\/1')\n# TRUE\n# >>> simplify('1\/6', '2\/1')\n# FALSE\n# >>> simplify('7\/10', '10\/2')\n# FALSE\nsimplify <- function(x, n) {","canonical_solution":"simplify <- function(x, n) {\n  parse_fraction <- function(fraction) {\n    parts <- strsplit(fraction, \"\/\")[[1]]\n    return(as.numeric(parts[1]) \/ as.numeric(parts[2]))\n  }\n  \n  x_value <- parse_fraction(x)\n  n_value <- parse_fraction(n)\n  \n  product <- x_value * n_value\n  \n  # Check if the product is a whole number\n  return(product == floor(product))\n}","tests":"test_humaneval <- function() {\n    candidate <- simplify\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '5\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/6', '2\/1'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('5\/1', '3\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('7\/10', '10\/2'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/10', '50\/10'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('7\/2', '4\/2'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('11\/6', '6\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/3', '5\/2'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('5\/2', '3\/5'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/4', '8\/4'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('2\/4', '4\/2'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '5\/1'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('1\/5', '1\/5'), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_145","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: ordigi ilin laŭ ilia indekso en la origina listo.Noto: se estas pluraj eroj kun simila sumo de iliaj ciferoj, laŭ la sumo de iliaj ciferoj.Skribu funkcion, kiu ordigas la donitan liston de entjeroj # >>> order_by_points(c(1, 11, -1, -11, -12))\n# c(-1, -11, 1, -12, 11)\n# >>> order_by_points(c())\n# c()\norder_by_points <- function(nums) {","canonical_solution":"order_by_points <- function(nums) {\n  # Helper function to calculate the sum of digits\n  sum_of_digits <- function(n) {\n    sum(as.integer(unlist(strsplit(as.character(abs(n)), \"\"))))\n  }\n  \n  # Order the numbers based on the sum of their digits first, \n  # and then by their original index\n  indices <- seq_along(nums)\n  nums[order(sapply(nums, sum_of_digits), indices)]\n}","tests":"test_humaneval <- function() {\n    candidate <- order_by_points\n    stopifnot(isTRUE(all.equal(candidate(c(1, 11, -1, -11, -12)), c(-1, -11, 1, -12, 11))))\n    stopifnot(isTRUE(all.equal(candidate(c(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46)), c(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457))))\n    stopifnot(isTRUE(all.equal(candidate(c()), c())))\n    stopifnot(isTRUE(all.equal(candidate(c(1, -11, -32, 43, 54, -98, 2, -3)), c(-3, -32, -98, -11, 1, 2, 43, 54))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), c(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 6, 6, -76, -21, 23, 4)), c(-76, -21, 0, 4, 23, 6, 6))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_146","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: la unua kaj lasta ciferoj de nombro estas neparaj (1, 3, 5, 7, 9).la nombro da elementoj en la vektoro estas pli granda ol 10 kaj ambaŭ Skribu funkcion, kiu prenas vektoron de nombroj kiel enigaĵon kaj redonas # >>> specialFilter(c(15, -73, 14, -15))\n# 1\n# >>> specialFilter(c(33, -2, -3, 45, 21, 109))\n# 2\nspecialFilter <- function(nums) {","canonical_solution":"specialFilter <- function(nums) {\n  # Helper function to check if both first and last digits are odd\n  are_first_last_digits_odd <- function(x) {\n    str_num <- as.character(abs(x))\n    first_digit <- as.numeric(substr(str_num, 1, 1))\n    last_digit <- as.numeric(substr(str_num, nchar(str_num), nchar(str_num)))\n    first_digit %% 2 == 1 && last_digit %% 2 == 1\n  }\n\n  # Filter numbers greater than 10 with both first and last digits odd\n  filtered_nums <- nums[nums > 10 & sapply(nums, are_first_last_digits_odd)]\n  \n  # Return the count of such numbers\n  length(filtered_nums)\n}","tests":"test_humaneval <- function() {\n    candidate <- specialFilter\n    stopifnot(isTRUE(all.equal(candidate(c(5, -2, 1, -5)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(15, -73, 14, -15)), 1)))\n    stopifnot(isTRUE(all.equal(candidate(c(33, -2, -3, 45, 21, 109)), 2)))\n    stopifnot(isTRUE(all.equal(candidate(c(43, -12, 93, 125, 121, 109)), 4)))\n    stopifnot(isTRUE(all.equal(candidate(c(71, -2, -33, 75, 21, 19)), 3)))\n    stopifnot(isTRUE(all.equal(candidate(c(1)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_147","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: kaj a[i] + a[j] + a[k] estas multiplo de 3. Redonu la nombron da triobloj (a[i], a[j], a[k]) de a kie i < j < k, Por ĉiu i (1 ≤ i ≤ n), la valoro de a[i] = i * i - i + 1. Vi ricevas pozitivan entjero n. Vi devas krei entjeran vektoron a de longo n. #     >>> get_max_triples(5)\n#     1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\nget_max_triples <- function(n) {","canonical_solution":"get_max_triples <- function(n) {\n  # Create the vector a according to the given rule\n  a <- sapply(1:n, function(i) i * i - i + 1)\n  \n  # Initialize the count of valid triples\n  count <- 0\n  \n  # Iterate over all possible triples (i, j, k) with i < j < k\n  for (i in 1:(n-2)) {\n    for (j in (i+1):(n-1)) {\n      for (k in (j+1):n) {\n        # Check if the sum of the selected triple is a multiple of 3\n        if ((a[i] + a[j] + a[k]) %% 3 == 0) {\n          count <- count + 1\n        }\n      }\n    }\n  }\n  \n  # Return the count of valid triples\n  return(count)\n}","tests":"test_humaneval <- function() {\n    candidate <- get_max_triples\n    stopifnot(isTRUE(all.equal(candidate(5), 1)))\n    stopifnot(isTRUE(all.equal(candidate(6), 4)))\n    stopifnot(isTRUE(all.equal(candidate(10), 36)))\n    stopifnot(isTRUE(all.equal(candidate(100), 53361)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_148","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj ne estas ĝustaj nomoj de planedoj.La funkcio devas resendi malplenan liston se planedo1 aŭ planedo2 la proksimeco al la suno.situanta inter la orbito de planedo 1 kaj la orbito de planedo 2, ordigita laŭ La funkcio devas redoni liston enhavantaj ĉiujn planedojn kies orbitoj estas Skribu funkcion kiu prenas du planednomojn kiel ŝnurojn planedo1 kaj planedo2.Urano, Neptuno.Jen Merkuro, Venuso, Tero, Marso, Jupitero, Saturno,Estas ok planedoj en nia sunsistemo: la plej proksimaj al la suno.# >>> bf('Jupiter', 'Neptune')\n# c('Saturn', 'Uranus')\n# >>> bf('Earth', 'Mercury')\n# 'Venus'\n# >>> bf('Mercury', 'Uranus')\n# c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\nbf <- function(planet1, planet2) {","canonical_solution":"bf <- function(planet1, planet2) {\n  planets <- c('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n  if (!(planet1 %in% planets) || !(planet2 %in% planets)) {\n    return(c())\n  }\n  \n  index1 <- which(planets == planet1)\n  index2 <- which(planets == planet2)\n  \n  if (index1 < index2) {\n    return(planets[(index1 + 1):(index2 - 1)])\n  } else if (index2 < index1) {\n    return(planets[(index2 + 1):(index1 - 1)])\n  } else {\n    return(c())\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- bf\n    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Neptune'), c('Saturn', 'Uranus'))))\n    stopifnot(isTRUE(all.equal(candidate('Earth', 'Mercury'), c('Venus'))))\n    stopifnot(isTRUE(all.equal(candidate('Mercury', 'Uranus'), c('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'))))\n    stopifnot(isTRUE(all.equal(candidate('Neptune', 'Venus'), c('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'))))\n    stopifnot(isTRUE(all.equal(candidate('Earth', 'Earth'), c())))\n    stopifnot(isTRUE(all.equal(candidate('Mars', 'Earth'), c())))\n    stopifnot(isTRUE(all.equal(candidate('Jupiter', 'Makemake'), c())))\n}\ntest_humaneval()"},{"task_id":"HumanEval_149","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: Vi povas supozi, ke ĉiuj vortoj havos la saman longon.La funkcio devas redoni liston de ŝnuroj ordigitaj. Se du vortoj havas la saman longon, ordigu la liston alfabete. devus resendi la liston ordigita laŭ tiu regulo. La ordo de la listo devus esti supreniranta laŭ longo de ĉiu vorto, kaj vi kaj ĝi povas enhavi duplikatojn.La listo estas ĉiam listo de ŝnuroj kaj neniam vektoro de nombroj, kaj resendas la rezultan liston kun ordigita ordo, forigas la stringojn, kiuj havas neparan longecon de ĝi, Skribu funkcion kiu akceptas liston de ŝnuroj kiel parametron, # >>> list_sort(c('aa', 'a', 'aaa'))\n# c('aa')\n# >>> list_sort(c('ab', 'a', 'aaa', 'cd'))\n# c('ab', 'cd')\nsorted_list_sum <- function(lst) {","canonical_solution":"list_sort <- function(lst) {\n  # Filter out strings with odd lengths\n  filtered_list <- lst[nchar(lst) %% 2 == 0]\n  \n  # Sort the list first by length, then alphabetically\n  sorted_list <- filtered_list[order(nchar(filtered_list), filtered_list)]\n  \n  return(sorted_list)\n}","tests":"test_humaneval <- function() {\n    candidate <- sorted_list_sum\n    stopifnot(isTRUE(all.equal(candidate(c('aa', 'a', 'aaa')), c('aa'))))\n    stopifnot(isTRUE(all.equal(candidate(c('school', 'AI', 'asdf', 'b')), c('AI', 'asdf', 'school'))))\n    stopifnot(isTRUE(all.equal(candidate(c('d', 'b', 'c', 'a')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('d', 'dcba', 'abcd', 'a')), c('abcd', 'dcba'))))\n    stopifnot(isTRUE(all.equal(candidate(c('AI', 'ai', 'au')), c('AI', 'ai', 'au'))))\n    stopifnot(isTRUE(all.equal(candidate(c('a', 'b', 'b', 'c', 'c', 'a')), c())))\n    stopifnot(isTRUE(all.equal(candidate(c('aaaa', 'bbbb', 'dd', 'cc')), c('cc', 'dd', 'aaaa', 'bbbb'))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_150","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: estas primo kaj devas redoni la valoron de y alie. Simpla programo kiu devas redoni la valoron de x se n estas # >>> x_or_y(7, 34, 12)\n# 34\n# >>> x_or_y(15, 8, 5)\n# 5\nx_or_y <- function(n, x, y) {","canonical_solution":"x_or_y <- function(n, x, y) {\n  is_prime <- function(num) {\n    if (num <= 1) {\n      return(FALSE)\n    }\n    for (i in 2:sqrt(num)) {\n      if (num %% i == 0) {\n        return(FALSE)\n      }\n    }\n    return(TRUE)\n  }\n  \n  if (is_prime(n)) {\n    return(x)\n  } else {\n    return(y)\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- x_or_y\n    stopifnot(isTRUE(all.equal(candidate(7, 34, 12), 34)))\n    stopifnot(isTRUE(all.equal(candidate(15, 8, 5), 5)))\n    stopifnot(isTRUE(all.equal(candidate(3, 33, 5212), 33)))\n    stopifnot(isTRUE(all.equal(candidate(1259, 3, 52), 3)))\n    stopifnot(isTRUE(all.equal(candidate(7919, -1, 12), -1)))\n    stopifnot(isTRUE(all.equal(candidate(3609, 1245, 583), 583)))\n    stopifnot(isTRUE(all.equal(candidate(91, 56, 129), 129)))\n    stopifnot(isTRUE(all.equal(candidate(6, 34, 1234), 1234)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 0), 0)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 0), 2)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_151","nl":"epo_Latn","pl":"r","prompt":"Ignoru la nombrojn, kiuj estas negativaj aŭ ne.Donita listo de nombroj, redonu la sumon de la kvadratoj de la nombroj # >>> double_the_difference(c(1, 3, 2, 0))\n# 10\n# >>> double_the_difference(c(-1, -2, 0))\n# 0\n# >>> double_the_difference(c(9, -2))\n# 81\n# >>> double_the_difference(c(0))\n# 0\n# If the input list is empty, return 0.\ndouble_the_difference <- function(lst) {","canonical_solution":"double_the_difference <- function(lst) {\n  # Filter out non-positive, non-integer, and non-odd numbers\n  lst <- lst[lst > 0 & lst %% 1 == 0 & lst %% 2 == 1]\n  # Calculate the sum of squares of remaining numbers\n  sum(lst^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- double_the_difference\n    stopifnot(isTRUE(all.equal(candidate(c()), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(5.0, 4.0)), 25)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.1, 0.2, 0.3)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-10.0, -20.0, -30.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(-1.0, -2.0, 8.0)), 0)))\n    stopifnot(isTRUE(all.equal(candidate(c(0.2, 3.0, 5.0)), 34)))\n    stopifnot(isTRUE(all.equal(candidate(c(-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0)), 165)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_152","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: la valoro estas 0, kaj se ne, la valoro estas la absoluta diferenco inter la supozo kaj la poentaro. Se ili divenis ĝuste, Vi ricevas du vektorojn de poentaro kaj konjektoj de egala longo, kie ĉiu indekso montras matĉon.Via tasko estas determini ĉu persono ĝuste divenis la rezultojn de kelkaj matĉoj.Certe indas noti kaj kompari.La sentoj kaj pensoj, kiujn vi havas en tiu momento, estas la plej bonaj.Mi pensas, ke ni ĉiuj memoras tiun senton kiam la rezulto de iu tre longa atendado# >>> compare(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2))\n# c(0, 0, 0, 0, 3, 3)\n# >>> compare(c(0, 5, 0, 0, 0, 4), c(4, 1, 1, 0, 0, -2))\n# c(4, 4, 1, 0, 0, 6)\ncompare <- function(game, guess) {","canonical_solution":"compare <- function(game, guess) {\n  abs(game - guess)\n}","tests":"test_humaneval <- function() {\n    candidate <- compare\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 4, 5, 1), c(1, 2, 3, 4, 2, -2)), c(0, 0, 0, 0, 3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(c(0, 0, 0, 0, 0, 0), c(0, 0, 0, 0, 0, 0)), c(0, 0, 0, 0, 0, 0))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3), c(-1, -2, -3)), c(2, 4, 6))))\n    stopifnot(isTRUE(all.equal(candidate(c(1, 2, 3, 5), c(-1, 2, 3, 4)), c(2, 0, 0, 1))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_153","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: (Ĝia forto estas -1).return \"Slices.SErviNGSliCes\" ĉar \"SErviNGSliCes\" estas la plej forta etendaĵo la nomojn de la britaj lingvoj: ['SERVINGSliCes', 'Cheese', 'StuFfed'], vi devus Ekzemple, se vi ricevas \"Frazoj\" kiel la klaso kaj listo de la elektu la unuan en la listo.Se estas du aŭ pli da plilongigoj kun la sama forto, vi devas formato: ClassName.StrongestExtensionName. Vi devas trovi la plej fortan etendaĵon kaj resendi la ĉenon en ĝi.en la nomo de la etendaĵo, la forto estas donita per la frakcio CAP - SM. literoj en la nomo de la etendaĵo, kaj lasu SM esti la nombro de minuskloj la forto de la etendaĵo estas kiel sekvas: Lasu CAP esti la nombro de la majusklo La etendaĵoj estas uzataj por ŝarĝi pliajn klasojn al la klaso.Vi ricevos la nomon de klaso (ĉenon) kaj liston de etendaĵoj.# >>> Strongest_Extension('my_class', c('AA', 'Be', 'CC'))\n# 'my_class.AA'\nStrongest_Extension <- function(class_name, extensions) {","canonical_solution":"Strongest_Extension <- function(class_name, extensions) {\n  # Function to calculate the strength of an extension\n  extension_strength <- function(ext) {\n    cap_count <- sum(grepl(\"[A-Z]\", strsplit(ext, \"\")[[1]]))\n    sm_count <- sum(grepl(\"[a-z]\", strsplit(ext, \"\")[[1]]))\n    return(cap_count - sm_count)\n  }\n  \n  # Calculate strength for each extension and find the strongest one\n  strengths <- sapply(extensions, extension_strength)\n  max_strength_index <- which.max(strengths)\n  \n  # Construct the result string\n  return(paste0(class_name, \".\", extensions[max_strength_index]))\n}","tests":"test_humaneval <- function() {\n    candidate <- Strongest_Extension\n    stopifnot(isTRUE(all.equal(candidate('Watashi', c('tEN', 'niNE', 'eIGHt8OKe')), 'Watashi.eIGHt8OKe')))\n    stopifnot(isTRUE(all.equal(candidate('Boku123', c('nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg')), 'Boku123.YEs.WeCaNe')))\n    stopifnot(isTRUE(all.equal(candidate('__YESIMHERE', c('t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321')), '__YESIMHERE.NuLl__')))\n    stopifnot(isTRUE(all.equal(candidate('K', c('Ta', 'TAR', 't234An', 'cosSo')), 'K.TAR')))\n    stopifnot(isTRUE(all.equal(candidate('__HAHA', c('Tab', '123', '781345', '-_-')), '__HAHA.123')))\n    stopifnot(isTRUE(all.equal(candidate('YameRore', c('HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-')), 'YameRore.okIWILL123')))\n    stopifnot(isTRUE(all.equal(candidate('finNNalLLly', c('Die', 'NowW', 'Wow', 'WoW')), 'finNNalLLly.WoW')))\n    stopifnot(isTRUE(all.equal(candidate('_', c('Bb', '91245')), '_.Bb')))\n    stopifnot(isTRUE(all.equal(candidate('Sp', c('671235', 'Bb')), 'Sp.671235')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_154","nl":"epo_Latn","pl":"r","prompt":"Vi ricevas 2 vortojn. Vi devas redoni VERA se la dua vorto aŭ iu el ĝiaj rotacioj estas subĉeneto en la unua vorto.# >>> cycpattern_check('abcd', 'abd')\n# FALSE\n# >>> cycpattern_check('hello', 'ell')\n# TRUE\n# >>> cycpattern_check('whassup', 'psus')\n# FALSE\n# >>> cycpattern_check('abab', 'baa')\n# TRUE\n# >>> cycpattern_check('efef', 'eeff')\n# FALSE\n# >>> cycpattern_check('himenss', 'simen')\n# TRUE\ncycpattern_check <- function(a, b) {","canonical_solution":"cycpattern_check <- function(a, b) {\n  n <- nchar(b)\n  # Check all rotations of b\n  for (i in 0:(n-1)) {\n    # Rotate the string b by i characters\n    rotated_b <- substring(b, i+1, n) %\/% substring(b, 1, i)\n    # Check if the rotated string is a substring of a\n    if (grepl(rotated_b, a)) {\n      return(TRUE)\n    }\n  }\n  return(FALSE)\n}","tests":"test_humaneval <- function() {\n    candidate <- cycpattern_check\n    stopifnot(isTRUE(all.equal(candidate('xyzw', 'xyw'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('yello', 'ell'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('whattup', 'ptut'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('efef', 'fee'), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate('abab', 'aabb'), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate('winemtt', 'tinem'), TRUE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_155","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: Donita entjero. redonas liston kiu havas la nombron de paraj kaj neparaj ciferoj respektive. #     >>> even_odd_count(-12)\n#     c(1, 1)\n#     >>> even_odd_count(123)\n#     c(1, 2)\neven_odd_count <- function(num) {","canonical_solution":"even_odd_count <- function(num) {\n  # Handle negative numbers by taking the absolute value\n  num <- abs(num)\n  \n  # Convert the number to a character vector to access digits\n  digits <- unlist(strsplit(as.character(num), \"\"))\n  \n  # Convert character vector back to integer\n  digits <- as.integer(digits)\n  \n  # Count even digits\n  even_count <- sum(digits %% 2 == 0)\n  \n  # Count odd digits\n  odd_count <- length(digits) - even_count\n  \n  # Return a vector with even and odd counts\n  return(c(even_count, odd_count))\n}","tests":"test_humaneval <- function() {\n    candidate <- even_odd_count\n    stopifnot(isTRUE(all.equal(candidate(7), c(0, 1))))\n    stopifnot(isTRUE(all.equal(candidate(-78), c(1, 1))))\n    stopifnot(isTRUE(all.equal(candidate(3452), c(2, 2))))\n    stopifnot(isTRUE(all.equal(candidate(346211), c(3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(-345821), c(3, 3))))\n    stopifnot(isTRUE(all.equal(candidate(-2), c(1, 0))))\n    stopifnot(isTRUE(all.equal(candidate(-45347), c(2, 3))))\n    stopifnot(isTRUE(all.equal(candidate(0), c(1, 0))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_156","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj: Limigoj: 1 <= num <= 1000 kaj resendu ĝin per malgrandaj literoj.Donita pozitiva entjero, ricevu ĝian romian numeran ekvivalenton kiel ŝnuro, # >>> int_to_mini_roman(19)\n# 'xix'\n# >>> int_to_mini_roman(152)\n# 'clii'\n# >>> int_to_mini_roman(426)\n# 'cdxxvi'\nint_to_mini_roman <- function(number) {","canonical_solution":"int_to_mini_roman <- function(number) {\n  values <- c(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n  numerals <- c(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n  \n  result <- \"\"\n  remainder <- number\n  \n  for (i in seq_along(values)) {\n    while (remainder >= values[i]) {\n      result <- paste0(result, numerals[i])\n      remainder <- remainder - values[i]\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- int_to_mini_roman\n    stopifnot(isTRUE(all.equal(candidate(19), 'xix')))\n    stopifnot(isTRUE(all.equal(candidate(152), 'clii')))\n    stopifnot(isTRUE(all.equal(candidate(251), 'ccli')))\n    stopifnot(isTRUE(all.equal(candidate(426), 'cdxxvi')))\n    stopifnot(isTRUE(all.equal(candidate(500), 'd')))\n    stopifnot(isTRUE(all.equal(candidate(1), 'i')))\n    stopifnot(isTRUE(all.equal(candidate(4), 'iv')))\n    stopifnot(isTRUE(all.equal(candidate(43), 'xliii')))\n    stopifnot(isTRUE(all.equal(candidate(90), 'xc')))\n    stopifnot(isTRUE(all.equal(candidate(94), 'xciv')))\n    stopifnot(isTRUE(all.equal(candidate(532), 'dxxxii')))\n    stopifnot(isTRUE(all.equal(candidate(900), 'cm')))\n    stopifnot(isTRUE(all.equal(candidate(994), 'cmxciv')))\n    stopifnot(isTRUE(all.equal(candidate(1000), 'm')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_157","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: 90 gradoj.Rekta triangulo estas triangulo, en kiu unu angulo estas rekta angulo aŭ la flankoj formas rektangulan triangulon, alie malvera.Donita la longoj de la tri flankoj de triangulo. Redonu VERE se la tri # >>> right_angle_triangle(3, 4, 5)\n# TRUE\n# >>> right_angle_triangle(1, 2, 3)\n# FALSE\nright_angle_triangle <- function(a, b, c) {","canonical_solution":"right_angle_triangle <- function(a, b, c) {\n  # Sort the sides to easily compare the largest side\n  sides <- sort(c(a, b, c))\n  \n  # Check if the sum of squares of the two smaller sides equals the square of the largest side\n  return(sides[1]^2 + sides[2]^2 == sides[3]^2)\n}","tests":"test_humaneval <- function() {\n    candidate <- right_angle_triangle\n    stopifnot(isTRUE(all.equal(candidate(3, 4, 5), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 2, 3), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(10, 6, 8), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 2), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(7, 24, 25), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(10, 5, 7), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(5, 12, 13), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(15, 8, 17), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(48, 55, 73), TRUE)))\n    stopifnot(isTRUE(all.equal(candidate(1, 1, 1), FALSE)))\n    stopifnot(isTRUE(all.equal(candidate(2, 2, 10), FALSE)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_158","nl":"epo_Latn","pl":"r","prompt":"la unua en la leksikografia ordo. Se multoblaj ŝnuroj havas maksimuman nombron da unikaj La listo enhavas malsamajn vortojn. Redonu la vorton kun maksimuma nombro Skribu funkcion, kiu akceptas liston de ŝnuroj.# >>> find_max(c('name', 'of', 'string'))\n# 'string'\n# >>> find_max(c('name', 'enam', 'game'))\n# 'enam'\n# >>> find_max(c('aaaaaaa', 'bb', 'cc'))\n# 'aaaaaaa'\nfind_max <- function(words) {","canonical_solution":"find_max <- function(words) {\n  max_unique_chars <- 0\n  result <- \"\"\n  \n  for (word in words) {\n    unique_chars_count <- length(unique(strsplit(word, NULL)[[1]]))\n    \n    if (unique_chars_count > max_unique_chars ||\n       (unique_chars_count == max_unique_chars && word < result)) {\n      max_unique_chars <- unique_chars_count\n      result <- word\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- find_max\n    stopifnot(isTRUE(all.equal(candidate(c('name', 'of', 'string')), 'string')))\n    stopifnot(isTRUE(all.equal(candidate(c('name', 'enam', 'game')), 'enam')))\n    stopifnot(isTRUE(all.equal(candidate(c('aaaaaaa', 'bb', 'cc')), 'aaaaaaa')))\n    stopifnot(isTRUE(all.equal(candidate(c('abc', 'cba')), 'abc')))\n    stopifnot(isTRUE(all.equal(candidate(c('play', 'this', 'game', 'of', 'footbott')), 'footbott')))\n    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'gonna', 'rock')), 'gonna')))\n    stopifnot(isTRUE(all.equal(candidate(c('we', 'are', 'a', 'mad', 'nation')), 'nation')))\n    stopifnot(isTRUE(all.equal(candidate(c('this', 'is', 'a', 'prrk')), 'this')))\n    stopifnot(isTRUE(all.equal(candidate(c('b')), 'b')))\n    stopifnot(isTRUE(all.equal(candidate(c('play', 'play', 'play')), 'play')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_159","nl":"epo_Latn","pl":"r","prompt":"Ekzemplo: se restas ne sufiĉe da karotoj, vi manĝos ĉiujn ceterajn karotojn, sed vi ankoraŭ malsatos.la nombron da karotoj, kiujn vi manĝas post via manĝo] vi devas redoni vektoron de [totalo de la manĝitaj karotoj post la manĝoj, Sed nun vi devas manĝi pli da karotoj por kompletigi la tagmanĝojn.Vi estas malsata kuniklo, kaj vi jam manĝis certan nombron da karotoj, # >>> eat(5, 6, 10)\n# c(11, 4)\n# >>> eat(4, 8, 9)\n# c(12, 1)\n# >>> eat(1, 10, 10)\n# c(11, 0)\n# >>> eat(2, 11, 5)\n# c(7, 0)\n# Variables:\n# @number : integer\n#     the number of carrots that you have eaten.\n# @need : integer\n#     the number of carrots that you need to eat.\n# @remaining : integer\n#     the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\neat <- function(number, need, remaining) {","canonical_solution":"eat <- function(number, need, remaining) {\n  total_eaten <- number + min(need, remaining)\n  remaining_carrots <- max(0, remaining - need)\n  return(c(total_eaten, remaining_carrots))\n}","tests":"test_humaneval <- function() {\n    candidate <- eat\n    stopifnot(isTRUE(all.equal(candidate(5, 6, 10), c(11, 4))))\n    stopifnot(isTRUE(all.equal(candidate(4, 8, 9), c(12, 1))))\n    stopifnot(isTRUE(all.equal(candidate(1, 10, 10), c(11, 0))))\n    stopifnot(isTRUE(all.equal(candidate(2, 11, 5), c(7, 0))))\n    stopifnot(isTRUE(all.equal(candidate(4, 5, 7), c(9, 2))))\n    stopifnot(isTRUE(all.equal(candidate(4, 5, 1), c(5, 0))))\n}\ntest_humaneval()"},{"task_id":"HumanEval_160","nl":"epo_Latn","pl":"r","prompt":"La listo de la operatoroj havas almenaŭ unu operatoron, kaj la listo de la operandoj havas almenaŭ du operandojn.La operando estas listo de ne-negativaj entjeroj.La longo de la listo de la operatoroj egalas al la longo de la listo de la operandoj minus unu.Noto: => rezulto = 9 rezulto = 2 + 3 * 4 - 5 vektoro = [2, 3, 4, 5] la operatoro ['+', '*', '-'] Ekzemplo: Eksponentigo (**) Etaĝdividado ( \/\/) Multipliko ( *) Subtraho ( - ) Aldono (+) La bazaj algebraj operacioj: esprimo kaj redoni la takson de tiu esprimo. la dua listo estas listo de entjeroj. Uzu la du donitajn listojn por konstrui la algebron La unua listo enhavas bazajn algebrajn operaciojn, kaj do_algebra <- function(operator, operand) {","canonical_solution":"do_algebra <- function(operator, operand) {\n  if (length(operator) != length(operand) - 1) {\n    stop(\"The length of operator list must be equal to the length of operand list minus one.\")\n  }\n  \n  # Initialize the result with the first operand\n  result <- operand[1]\n  \n  # Iterate through the operators and operands\n  for (i in 1:length(operator)) {\n    op <- operator[i]\n    num <- operand[i + 1]\n    \n    # Apply the appropriate operation\n    if (op == '+') {\n      result <- result + num\n    } else if (op == '-') {\n      result <- result - num\n    } else if (op == '*') {\n      result <- result * num\n    } else if (op == '\/\/') {\n      result <- result %\/% num\n    } else if (op == '**') {\n      result <- result ^ num\n    } else {\n      stop(\"Unsupported operation\")\n    }\n  }\n  \n  return(result)\n}","tests":"test_humaneval <- function() {\n    candidate <- do_algebra\n    stopifnot(isTRUE(all.equal(candidate(c('**', '*', '+'), c(2, 3, 4, 5)), 37)))\n    stopifnot(isTRUE(all.equal(candidate(c('+', '*', '-'), c(2, 3, 4, 5)), 9)))\n    stopifnot(isTRUE(all.equal(candidate(c('\/\/', '*'), c(7, 3, 4)), 8)))\n}\ntest_humaneval()"},{"task_id":"HumanEval_161","nl":"epo_Latn","pl":"r","prompt":"Ekzemploj La funkcio devas redoni la rezultan ŝnuron.Se la ŝnuro enhavas neniujn literojn, inversu la ŝnuron.Alie, restu, kia vi estas.se s[i] estas litero, inversigas ĝian kazon de malsupre al supre aŭ inverse, Vi ricevas stringon s. # >>> solve('1234')\n# '4321'\n# >>> solve('ab')\n# 'AB'\n# >>> solve('#a@C')\n# '#A@c'\nsolve <- function(s) {","canonical_solution":"solve <- function(s) {\n  if (grepl(\"[a-zA-Z]\", s)) {\n    return(chartr(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n                  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", s))\n  } else {\n    return(intToUtf8(rev(utf8ToInt(s))))\n  }\n}","tests":"test_humaneval <- function() {\n    candidate <- solve\n    stopifnot(isTRUE(all.equal(candidate('AsDf'), 'aSdF')))\n    stopifnot(isTRUE(all.equal(candidate('1234'), '4321')))\n    stopifnot(isTRUE(all.equal(candidate('ab'), 'AB')))\n    stopifnot(isTRUE(all.equal(candidate('#a@C'), '#A@c')))\n    stopifnot(isTRUE(all.equal(candidate('#AsdfW^45'), '#aSDFw^45')))\n    stopifnot(isTRUE(all.equal(candidate('#6@2'), '2@6#')))\n    stopifnot(isTRUE(all.equal(candidate('#$a^D'), '#$A^d')))\n    stopifnot(isTRUE(all.equal(candidate('#ccc'), '#CCC')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_162","nl":"epo_Latn","pl":"r","prompt":"Se 'teksto' estas malplena ŝnuro, redonu NULL. Surbaze de ŝnuro 'teksto', redonu ĝian md5-haŝan ekvivalentan ŝnuron. # >>> string_to_md5('Hello world')\n# '3e25960a79dbc69b674cd4ec67a72c62'\nstring_to_md5 <- function(text) {","canonical_solution":"string_to_md5 <- function(text) {\n  if (text == \"\") {\n    return(NULL)\n  } else {\n    return(digest::digest(text, algo = \"md5\", serialize = FALSE))\n  }\n}\n\n# Ensure the required library is loaded\nif(!requireNamespace(\"digest\", quietly = TRUE)) {\n  install.packages(\"digest\")\n}\n\n# Load the digest library\nlibrary(digest)","tests":"test_humaneval <- function() {\n    candidate <- string_to_md5\n    stopifnot(isTRUE(all.equal(candidate('Hello world'), '3e25960a79dbc69b674cd4ec67a72c62')))\n    stopifnot(isTRUE(all.equal(candidate(''), NULL)))\n    stopifnot(isTRUE(all.equal(candidate('A B C'), '0ef78513b0cb8cef12743f5aeb35f888')))\n    stopifnot(isTRUE(all.equal(candidate('password'), '5f4dcc3b5aa765d61d8327deb882cf99')))\n}\ntest_humaneval()"},{"task_id":"HumanEval_163","nl":"epo_Latn","pl":"r","prompt":"Ekzemple: kaj b, laŭ kreskanta sinsekvo.Donita du pozitiva entjeroj a kaj b, redonu la eĉ ciferoj inter a # >>> generate_integers(2, 8)\n# c(2, 4, 6, 8)\n# >>> generate_integers(8, 2)\n# c(2, 4, 6, 8)\n# >>> generate_integers(10, 14)\n# c()\ngenerate_integers <- function(a, b) {","canonical_solution":"generate_integers <- function(a, b) {\n  start <- min(a, b)\n  end <- max(a, b)\n  even_digits <- seq(start, end)[seq(start, end) %% 2 == 0 & seq(start, end) <= 8]\n  return(even_digits)\n}","tests":"test_humaneval <- function() {\n    candidate <- generate_integers\n    stopifnot(isTRUE(all.equal(candidate(2, 10), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(10, 2), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(132, 2), c(2, 4, 6, 8))))\n    stopifnot(isTRUE(all.equal(candidate(17, 89), c())))\n}\ntest_humaneval()"}]