task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു നിശ്ചിത തുക.    // എന്നതിനേക്കാൾ അടുത്തുള്ള സംഖ്യകളുണ്ടോ എന്ന് പരിശോധിക്കുക.    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))
    // (false)
    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))
    // (true)
    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {
","def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {
      val sortedNumbers = numbers.sorted
      for (i <- 1 until sortedNumbers.length) {
        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {
          return true
        }
      }
      false
    }
}","    }
    def main(args: Array[String]) = {
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));
    }

}
"
HumanEval_1,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഇൻപുട്ട് സ്ട്രിങ്ങിലെ സ്പെയ്സുകളെ അവഗണിക്കുക.    //പ്രത്യേക ഗ്രൂപ്പുകള് സന്തുലിതമാണ് (ഓരോ തുറന്ന ബ്രേസും ശരിയായി അടച്ചിരിക്കുന്നു) പരസ്പരം കൂടിച്ചേർന്നിട്ടില്ല.    //ആ ഗ്രൂപ്പുകളെ പ്രത്യേക സ്ട്രിങ്ങുകളാക്കി വേർതിരിച്ച് അവയുടെ ലിസ്റ്റ് തിരികെ നൽകുക.    //ഈ ഫങ്ഷന് നല് കുന്ന ഇൻപുട്ട് ഒരു സ്ട്രിംഗ് ആണ്, അതിൽ ഒന്നിലധികം കൂട്ടം നെസ്റ്റഡ് പരാൻതീസിസ് അടങ്ങിയിരിക്കുന്നു. നിങ്ങളുടെ ലക്ഷ്യം     // >>> separateParenGroups((""( ) (( )) (( )( ))""))
    // (List[String](""()"", ""(())"", ""(()())""))
    def separateParenGroups(paren_string : String) : List[String] = {
","def separateParenGroups(paren_string: String): List[String] = {
    val result = ListBuffer[String]()
    val sanitizedInput = paren_string.replaceAll(""\\s"", """")
    var balance = 0
    var currentGroup = new StringBuilder()

    for (char <- sanitizedInput) {
        currentGroup.append(char)
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1

        if (balance == 0 && currentGroup.nonEmpty) {
            result += currentGroup.toString()
            currentGroup = new StringBuilder()
        }
    }

    result.toList
}","    }
    def main(args: Array[String]) = {
    assert(separateParenGroups((""(()()) ((())) () ((())()())"")).equals((List[String](""(()())"", ""((()))"", ""()"", ""((())()())""))));
    assert(separateParenGroups((""() (()) ((())) (((())))"")).equals((List[String](""()"", ""(())"", ""((()))"", ""(((())))""))));
    assert(separateParenGroups((""(()(())((())))"")).equals((List[String](""(()(())((())))""))));
    assert(separateParenGroups((""( ) (( )) (( )( ))"")).equals((List[String](""()"", ""(())"", ""(()())""))));
    }

}
"
HumanEval_2,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //സംഖ്യയുടെ ദശാംശ ഭാഗം തിരികെ നൽകുക.    //(അവശേഷിക്കുന്ന ഭാഗം എല്ലായ്പ്പോഴും 1 ന് താഴെയാണ്).    //യും ഇന്റര് ഭാഗവും (നൽകിയ സംഖ്യയേക്കാൾ ചെറുതാണ് ഏറ്റവും വലിയ ഇന്റര്) ദശാംശവും    //ഒരു പോസിറ്റീവ് ഫ്ലോട്ടിംഗ് പോയിന്റ് നമ്പർ കൊടുത്താൽ, അതിനെ  ആയി വിഭജിക്കാം.    // >>> truncateNumber((3.5f))
    // (0.5f)
    def truncateNumber(number : Float) : Float = {
","val integerPart = number.floor
        val decimalPart = number - integerPart
        decimalPart.toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(truncateNumber((3.5f)) == (0.5f));
    assert(truncateNumber((1.25f)) == (0.25f));
    assert(truncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ആ ഘട്ടത്തിൽ ഫംഗ്ഷൻ true ആയി തിരിച്ചു വരും. അല്ലാത്തപക്ഷം false ആയി തിരിച്ചു വരും.    //നിങ്ങളുടെ ജോലി അക്കൌണ്ട് ബാലൻസ് പൂജ്യത്തിന് താഴെയായി എന്ന് കണ്ടെത്തുക എന്നതാണ്.    //ഒരു ബാങ്ക് അക്കൌണ്ടിലെ നിക്ഷേപങ്ങളുടെയും പിൻവലിക്കലുകളുടെയും ലിസ്റ്റ് നിങ്ങൾക്ക് ലഭിക്കും അത് തുടങ്ങുന്നത്     // >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (false)
    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))
    // (true)
    def belowZero(operations : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def belowZero(operations: List[Long]): Boolean = {
    var balance: Long = 0
    for (operation <- operations) {
      balance += operation
      if (balance < 0) {
        return true
      }
    }
    false
  }

  def main(args: Array[String]): Unit = {
    println(belowZero(List(1L, 2L, 3L)))         // false
    println(belowZero(List(1L, 2L, -4L, 5L)))    // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowZero((List[Long]())) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));
    }

}
"
HumanEval_4,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //MAD = ശരാശരി. x - x_mean.     //ഒരു ഘടകവും ഒരു കേന്ദ്രബിന്ദുവും (ഈ കേസിൽ ശരാശരി):    //ശരാശരി അബ്സലൂട്ട് ഡീവിയേഷൻ എന്നത് ഓരോ യും തമ്മിലുള്ള ശരാശരി അബ്സലൂട്ട് വ്യത്യാസമാണ്.    //ഈ ഡാറ്റാ സെറ്റിന്റെ ശരാശരിയിൽ.    //ഒരു നിശ്ചിത എണ്ണം ഇൻപുട്ട് നമ്പറുകളുടെ ലിസ്റ്റിനായി, ശരാശരി അബ്സലൂട്ട് ഡീവിയേഷൻ കണക്കുകൂട്ടുക.    // >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))
    // (1.0f)
    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {
","val mean = numbers.sum / numbers.size
    val deviations = numbers.map(num => math.abs(num - mean))
    val mad = deviations.sum / deviations.size
    mad
  }
}","    }
    def main(args: Array[String]) = {
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));
    }

}
"
HumanEval_5,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഓരോ രണ്ട് തുടർച്ചയായ ഘടകങ്ങൾക്കും ഇടയിൽ ഒരു 'ഡിലിമിറ്റർ' ചേർക്കുക.    // >>> intersperse((List[Long]()), (4l))
    // (List[Long]())
    // >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))
    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {
","if (numbers.isEmpty) {
        List()
      } else {
        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last
      }
    }
}","    }
    def main(args: Array[String]) = {
    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));
    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));
    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    }

}
"
HumanEval_6,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്, (() (()) ന് പരമാവധി രണ്ട് നെസ്റ്റിംഗ് ലെവലുകൾ ഉണ്ട്, അതേസമയം ((())) ന് മൂന്ന് ഉണ്ട്.     //ഓരോ ഗ്രൂപ്പിനും പരേതന്മാരുടെ ഏറ്റവും ആഴത്തിലുള്ള തലത്തിലുള്ള നെസ്റ്റിംഗ് നൽകുക.    //ഈ ഫങ്ഷന് ഒരു സ്ട്രിംഗ് ആണ്. സ്പെയ്സുകളാൽ വേർതിരിക്കപ്പെട്ട, കൂട്ടിയിണക്കിയ പരാൻതീസിനു വേണ്ടി ഒന്നിലധികം ഗ്രൂപ്പുകളെ പ്രതിനിധീകരിക്കുന്നു.    // >>> parseNestedParens((""(()()) ((())) () ((())()())""))
    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))
    def parseNestedParens(paren_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseNestedParens(paren_string: String): List[Long] = {
    paren_string.split("" "").toList.map { group =>
      var maxDepth = 0
      var currentDepth = 0
      group.foreach {
        case '(' => 
          currentDepth += 1
          maxDepth = max(maxDepth, currentDepth)
        case ')' => 
          currentDepth -= 1
      }
      maxDepth.toLong
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    val result = parseNestedParens(""(()()) ((())) () ((())()())"")
    println(s""Result: ${result.mkString("", "")}"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseNestedParens((""(()()) ((())) () ((())()())"")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(parseNestedParens((""() (()) ((())) (((())))"")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(parseNestedParens((""(()(())((())))"")).equals((List[Long](4l.toLong))));
    }

}
"
HumanEval_7,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //സ്ട്രിങ്ങുകളുടെ ഒരു ഇൻപുട്ട് ലിസ്റ്റ് ഫിൽട്ടർ ചെയ്യുക, അതിൽ സബ്സ്ട്രിങ് അടങ്ങിയിരിക്കുന്നവ മാത്രം ഫിൽട്ടർ ചെയ്യുക.    // >>> filterBySubstring((List[String]()), (""a""))
    // (List[String]())
    // >>> filterBySubstring((List[String](""abc"", ""bacd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""bacd"", ""array""))
    def filterBySubstring(strings : List[String], substring : String) : List[String] = {
","strings.filter(_.contains(substring))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterBySubstring((List[String]()), (""john"")).equals((List[String]())));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xx"")).equals((List[String](""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""grunt"", ""trumpet"", ""prune"", ""gruesome"")), (""run"")).equals((List[String](""grunt"", ""prune""))));
    }

}
"
HumanEval_8,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ശൂന്യ സംഖ്യ 0 ഉം ശൂന്യ ഉൽപ്പന്നം 1 ഉം ആയിരിക്കണം.    //ഒരു നിശ്ചിത സംഖ്യകളുടെ പട്ടികയിൽ, ഒരു പട്ടികയിലെ എല്ലാ സംഖ്യകളുടെയും തുകയും ഗുണനവും അടങ്ങിയ ഒരു ട്യൂപ്പിൾ നൽകുക.    // >>> sumProduct((List[Long]()))
    // ((0l, 1l))
    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // ((10l, 24l))
    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {
","def sumProduct(numbers: List[Long]): (Long, Long) = {
        val sum = numbers.sum
        val product = numbers.foldLeft(1L)(_ * _)
        (sum, product)
    }

    def main(args: Array[String]): Unit = {
        // Test examples
        println(sumProduct(List[Long]())) // (0L, 1L)
        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) // (10L, 24L)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumProduct((List[Long]())).equals(((0l, 1l))));
    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));
    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));
    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));
    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));
    }

}
"
HumanEval_9,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //യില് തന്നെ.    //ഒരു നിശ്ചിത പട്ടികയിൽ നിന്നും, ഒരു നിശ്ചിത നിമിഷം വരെ കണ്ടെത്തിയ പരമാവധി ഘടകങ്ങളുടെ പട്ടിക ഉണ്ടാക്കുക.    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))
    def rollingMax(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def rollingMax(numbers: List[Long]): List[Long] = {
        var maxSoFar = Long.MinValue
        numbers.map { num =>
            maxSoFar = max(maxSoFar, num)
            maxSoFar
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(rollingMax((List[Long]())).equals((List[Long]())));
    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));
    }

}
"
HumanEval_10,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //- സ്ട്രിംഗ് റിവേഴ്സ് അവസാനിക്കുന്നതിനു മുമ്പ് ഒരു സ്ട്രിംഗ് പ്രിഫിക്സ് ചേർക്കുക.    //- ഒരു പാലിൻഡ്രോം ആയ സ്ട്രിംഗിന്റെ ഏറ്റവും നീളം കൂടിയ പോസ്റ്റ്ഫിക്സ് കണ്ടെത്തുക.    //അല് ഗോരിതം ആശയം ലളിതമാണ്:    //ഒരു സ്ട്രിങ്ങിൽ തുടങ്ങുന്ന ഏറ്റവും ചെറിയ പാലിൻഡ്രോം കണ്ടെത്തുക.    // >>> makePalindrome((""""))
    // ("""")
    // >>> makePalindrome((""cat""))
    // (""catac"")
    // >>> makePalindrome((""cata""))
    // (""catac"")
    def makePalindrome(string : String) : String = {
","def makePalindrome(string: String): String = {
    // Helper function to check if a string is a palindrome
    def isPalindrome(s: String): Boolean = s == s.reverse

    // Find the longest palindromic suffix
    var endIndex = string.length
    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {
      endIndex -= 1
    }

    // Extract the non-palindromic prefix
    val prefix = string.substring(0, endIndex - 1)

    // Append the reverse of the prefix to form the shortest palindrome
    string + prefix.reverse
  }
}","    }
    def main(args: Array[String]) = {
    assert(makePalindrome(("""")).equals(("""")));
    assert(makePalindrome((""x"")).equals((""x"")));
    assert(makePalindrome((""xyz"")).equals((""xyzyx"")));
    assert(makePalindrome((""xyx"")).equals((""xyx"")));
    assert(makePalindrome((""jerry"")).equals((""jerryrrej"")));
    }

}
"
HumanEval_11,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഈ ഇൻപുട്ടുകളിൽ ബൈനറി XOR നടത്തുകയും ഫലം ഒരു സ്ട്രിംഗായി നൽകുകയും ചെയ്യുക.    //ഇൻപുട്ട് എന്നത് 1 ഉം 0 ഉം മാത്രമുള്ള a, b എന്നീ രണ്ട് സ്ട്രിങ്ങുകൾ ആണ്.    // >>> stringXor((""010""), (""110""))
    // (""100"")
    def stringXor(a : String, b : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringXor(a: String, b: String): String = {
    (a zip b).map { case (charA, charB) => 
      if (charA == charB) '0' else '1'
    }.mkString
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringXor((""111000""), (""101010"")).equals((""010010"")));
    assert(stringXor((""1""), (""1"")).equals((""0"")));
    assert(stringXor((""0101""), (""0000"")).equals((""0101"")));
    }

}
"
HumanEval_12,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരേ നീളമുള്ള സ്ട്രിങ്ങുകൾ. ഇൻപുട്ട് ലിസ്റ്റ് ശൂന്യമാണെങ്കിൽ ഒന്നും നൽകരുത്.    //ന്റെ ലിസ്റ്റിൽ നിന്നും ഏറ്റവും നീളം കൂടിയത് തിരികെ നൽകുക. ഒന്നിലധികം  ന്റെ കാര്യത്തിൽ ആദ്യത്തേത് തിരികെ നൽകുക.    // >>> longest((List[String]()))
    // None
    // >>> longest((List[String](""a"", ""b"", ""c"")))
    // Some(""a"")
    // >>> longest((List[String](""a"", ""bb"", ""ccc"")))
    // Some(""ccc"")
    def longest(strings : List[String]) : Option[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Out of list of strings, return the longest one. Return the first one in case of multiple
    // strings of the same length. Return None in case the input list is empty.
    def longest(strings: List[String]): Option[String] = {
        if (strings.isEmpty) None
        else Some(strings.maxBy(_.length))
    }
}","    }
    def main(args: Array[String]) = {
    assert(longest((List[String]())).equals(None));
    assert(longest((List[String](""x"", ""y"", ""z""))).equals(Some(""x"")));
    assert(longest((List[String](""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""))).equals(Some(""zzzz"")));
    }

}
"
HumanEval_13,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //a, b എന്നീ രണ്ടു സംഖ്യകളുടെ ഏറ്റവും വലിയ പൊതുവിഭജനം തിരികെ നല് കുക.    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return a greatest common divisor of two integers a and b
    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a: Long, b: Long): Long = {
        if (b == 0) a else greatestCommonDivisor(b, a % b)
    }
}","    }
    def main(args: Array[String]) = {
    assert(greatestCommonDivisor((3l), (7l)) == (1l));
    assert(greatestCommonDivisor((10l), (15l)) == (5l));
    assert(greatestCommonDivisor((49l), (14l)) == (7l));
    assert(greatestCommonDivisor((144l), (60l)) == (12l));
    }

}
"
HumanEval_14,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //എല്ലാ പ്രിഫിക്സുകളുടെയും പട്ടിക ഏറ്റവും ചെറുത് മുതൽ ഏറ്റവും നീളം കൂടിയത് വരെ നൽകുന്നു.    // >>> allPrefixes((""abc""))
    // (List[String](""a"", ""ab"", ""abc""))
    def allPrefixes(string : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return list of all prefixes from shortest to longest of the input string
  // >>> allPrefixes((""abc""))
  // (List[String](""a"", ""ab"", ""abc""))
  def allPrefixes(string: String): List[String] = {
    (1 to string.length).map(i => string.substring(0, i)).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(allPrefixes(("""")).equals((List[String]())));
    assert(allPrefixes((""asdfgh"")).equals((List[String](""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""))));
    assert(allPrefixes((""WWW"")).equals((List[String](""W"", ""WW"", ""WWW""))));
    }

}
"
HumanEval_15,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //0 മുതൽ n വരെയുള്ള സംഖ്യകളുടെ ഒരു സ്ട്രിംഗ് നൽകുന്നു.    // >>> stringSequence((0l))
    // (""0"")
    // >>> stringSequence((5l))
    // (""0 1 2 3 4 5"")
    def stringSequence(n : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringSequence(n: Long): String = {
    (0L to n).mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringSequence((0l)).equals((""0"")));
    assert(stringSequence((3l)).equals((""0 1 2 3"")));
    assert(stringSequence((10l)).equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു സ്ട്രിംഗ് തന്നാൽ, എത്ര വ്യത്യസ്ത പ്രതീകങ്ങൾ (കേസ് പരിഗണിക്കാതെ) അതിൽ ഉണ്ടെന്ന് കണ്ടെത്തുക     // >>> countDistinctCharacters((""xyzXYZ""))
    // (3l)
    // >>> countDistinctCharacters((""Jerry""))
    // (4l)
    def countDistinctCharacters(string : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a string, find out how many distinct characters (regardless of case) does it consist of
  // >>> countDistinctCharacters((""xyzXYZ""))
  // (3l)
  // >>> countDistinctCharacters((""Jerry""))
  // (4l)
  def countDistinctCharacters(string: String): Long = {
    string.toLowerCase.toSet.size.toLong
  }
}","    }
    def main(args: Array[String]) = {
    assert(countDistinctCharacters(("""")) == (0l));
    assert(countDistinctCharacters((""abcde"")) == (5l));
    assert(countDistinctCharacters((""abcdecadeCADE"")) == (5l));
    assert(countDistinctCharacters((""aaaaAAAAaaaa"")) == (1l));
    assert(countDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5l));
    }

}
"
HumanEval_17,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //'ഹാച്ചാ' - ഒരു ക്വാർട്ടർ നോട്ട്, ഒരു ബീറ്റ് നീണ്ടുനിൽക്കും.    //'ഒ ശെരി' - പാതി നോട്ട്, രണ്ടു ബീറ്റ് നീണ്ടുനിൽക്കും.    //'ഒ' - മുഴുവൻ നോട്ടും, നാലു താളം നീണ്ടുനിൽക്കും.    //ഇതാ ഒരു ഇതിഹാസം:    //അവസാനത്തേത് അല്ല.    //നിങ്ങളുടെ ജോലി ഈ സ്ട്രിംഗ് പാഴ്സ് ചെയ്ത് ഓരോന്നും എത്ര തവണ ആവർത്തിക്കുന്നു എന്നതിന് അനുസൃതമായി പൂർണ്ണസംഖ്യകളുടെ ഒരു ലിസ്റ്റ് തിരികെ നൽകുക എന്നതാണ്.    //ഈ ഫങ്ഷന് ഒരു പ്രത്യേക ASCII ഫോർമാറ്റിലുള്ള സംഗീത കുറിപ്പുകളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് ആണ്.    // >>> parseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))
    def parseMusic(music_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseMusic(music_string: String): List[Long] = {
    val noteMap = Map(""o"" -> 4L, ""o|"" -> 2L, "".|"" -> 1L)
    val notes = music_string.split("" "")
    notes.toList.map(note => noteMap(note))
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseMusic(("""")).equals((List[Long]())));
    assert(parseMusic((""o o o o"")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic(("".| .| .| .|"")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));
    assert(parseMusic((""o| o| .| .| o o o o"")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic((""o| .| o| .| o o| o o|"")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));
    }

}
"
HumanEval_18,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു സബ് സ്ട്രിംഗ് എത്ര തവണ ഒറിജിനൽ സ്ട്രിംഗിൽ കാണാനാകും എന്ന് കണ്ടെത്തുക.    // >>> howManyTimes((""""), (""a""))
    // (0l)
    // >>> howManyTimes((""aaa""), (""a""))
    // (3l)
    // >>> howManyTimes((""aaaa""), (""aa""))
    // (3l)
    def howManyTimes(string : String, substring : String) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def howManyTimes(string: String, substring: String): Long = {
        if (substring.isEmpty || string.isEmpty) return 0L
        var count: Long = 0L
        for (i <- 0 to (string.length - substring.length)) {
            if (string.substring(i, i + substring.length) == substring) {
                count += 1
            }
        }
        count
    }

    // Test cases
    def main(args: Array[String]): Unit = {
        println(howManyTimes("""", ""a""))    // Output: 0
        println(howManyTimes(""aaa"", ""a"")) // Output: 3
        println(howManyTimes(""aaaa"", ""aa"")) // Output: 3
    }
}","    }
    def main(args: Array[String]) = {
    assert(howManyTimes((""""), (""x"")) == (0l));
    assert(howManyTimes((""xyxyxyx""), (""x"")) == (4l));
    assert(howManyTimes((""cacacacac""), (""cac"")) == (4l));
    assert(howManyTimes((""john doe""), (""john"")) == (1l));
    }

}
"
HumanEval_19,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഏറ്റവും ചെറിയ സംഖ്യ മുതൽ ഏറ്റവും വലിയ സംഖ്യ വരെ ക്രമീകരിച്ചിരിക്കുന്ന സ്ട്രിംഗ് തിരികെ നൽകുന്നു.    //സാധുവായ തിരഞ്ഞെടുപ്പുകൾ 'പൂജ്യം', 'ഒന്ന്', 'രണ്ട്', 'മൂന്ന്', 'നാല്', 'അഞ്ച്', 'ആറ്', 'ഏഴ്', 'എട്ട്' എന്നിവയാണ്.  എട്ട്, ഒമ്പത് എന്നിങ്ങനെ നിരവധി പേരുകൾ ഇതിൽ ഉൾപ്പെടുന്നു.    //'0' മുതൽ '9' വരെയുള്ള സംഖ്യകളുടെ ഒരു സ്പേസ് ഡെലിമെന്റ് ചെയ്ത സ്ട്രിംഗ് ആണ് ഇൻപുട്ട്.    // >>> sortNumbers((""three one five""))
    // (""one three five"")
    def sortNumbers(numbers : String) : String = {
","def sortNumbers(numbers: String): String = {
    val numberWords = Map(
      ""zero"" -> 0,
      ""one"" -> 1,
      ""two"" -> 2,
      ""three"" -> 3,
      ""four"" -> 4,
      ""five"" -> 5,
      ""six"" -> 6,
      ""seven"" -> 7,
      ""eight"" -> 8,
      ""nine"" -> 9
    )
    
    numbers.split("" "")
      .sortBy(word => numberWords(word))
      .mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortNumbers(("""")).equals(("""")));
    assert(sortNumbers((""three"")).equals((""three"")));
    assert(sortNumbers((""three five nine"")).equals((""three five nine"")));
    assert(sortNumbers((""five zero four seven nine eight"")).equals((""zero four five seven eight nine"")));
    assert(sortNumbers((""six five four three two one zero"")).equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //മറ്റു് നമ്പറുകള് ക്രമം അനുസരിച്ച് തിരിച്ചു് തരിക (കുറഞ്ഞ എണ്ണം, വലിയ എണ്ണം).    //ഒരു ലിസ്റ്റിൽ നിന്നും (കുറഞ്ഞത് 2 എണ്ണം) ഓരോന്നിനും ഏറ്റവും അടുത്തുള്ള 2 എണ്ണം തിരഞ്ഞെടുക്കുക.    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))
    // ((2.0f, 2.2f))
    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))
    // ((2.0f, 2.0f))
    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findClosestElements(numbers: List[Float]): (Float, Float) = {
    require(numbers.length >= 2, ""List must contain at least two elements"")
    val sortedNumbers = numbers.sorted

    var minDiff = Float.MaxValue
    var closestPair = (0.0f, 0.0f)

    for(i <- 0 until sortedNumbers.length - 1) {
      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))
      if(currentDiff < minDiff) {
        minDiff = currentDiff
        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))
      }
    }
    
    closestPair
  }
}","    }
    def main(args: Array[String]) = {
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));
    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));
    }

}
"
HumanEval_21,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഏറ്റവും ചെറിയ സംഖ്യ 0 ആയിത്തീരും, ഏറ്റവും വലിയ സംഖ്യ 1 ആയിത്തീരും.    //ഒരു സംഖ്യകളുടെ പട്ടിക (കുറഞ്ഞത് രണ്ട് മൂലകങ്ങളുടെ), ആ പട്ടികയിലേക്ക് ഒരു ലീനിയർ ട്രാൻസ്ഫോർമേഷൻ പ്രയോഗിക്കുക,    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))
    // (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))
    def rescaleToUnit(numbers : List[Float]) : List[Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given list of numbers (of at least two elements), apply a linear transform to that list,
  // such that the smallest number will become 0 and the largest will become 1
  def rescaleToUnit(numbers: List[Float]): List[Float] = {
    val minVal = numbers.min
    val maxVal = numbers.max
    numbers.map(num => (num - minVal) / (maxVal - minVal))
  }
}

// Usage example
object Main extends App {
  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)
  val rescaledNumbers = Problem.rescaleToUnit(numbers)
  println(rescaledNumbers) // Output: List(0.0, 0.25, 0.5, 0.75, 1.0)
}","    }
    def main(args: Array[String]) = {
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));
    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    }

}
"
HumanEval_22,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഏതെങ്കിലും സ്കാൽപാത്ത് മൂല്യങ്ങളുടെ ലിസ്റ്റ് പൂർണ്ണസംഖ്യകൾക്ക് മാത്രം ഫിൽട്ടർ ചെയ്യുക    // >>> filterIntegers((List[Any](""a"", 3.14f, 5l)))
    // (List[Long](5l.toLong))
    // >>> filterIntegers((List[Any](1l, 2l, 3l, ""abc"", Map[Long,Long](), List[Long]())))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    def filterIntegers(values : List[Any]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def filterIntegers(values: List[Any]): List[Long] = {
    values.collect {
      case l: Long => l
    }
  }

  def main(args: Array[String]): Unit = {
    println(filterIntegers(List[Any](""a"", 3.14f, 5l))) // List(5)
    println(filterIntegers(List[Any](1l, 2l, 3l, ""abc"", Map[Long, Long](), List[Long]()))) // List(1, 2, 3)
  }
}","    }
    def main(args: Array[String]) = {
    assert(filterIntegers((List[Any]())).equals((List[Long]())));
    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, ""adasd""))).equals((List[Long](4l.toLong, 9l.toLong))));
    assert(filterIntegers((List[Any](3l, ""c"", 3l, 3l, ""a"", ""b""))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_23,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //തന്നിരിക്കുന്ന സ്ട്രിങ്ങിന്റെ നീളം തിരികെ നൽകുക     // >>> stringLength((""""))
    // (0l)
    // >>> stringLength((""abc""))
    // (3l)
    def strlen(string : String) : Long = {
","def strlen(string: String): Long = {
        string.length.toLong
    }
}","    }
    def main(args: Array[String]) = {
    assert(strlen(("""")) == (0l));
    assert(strlen((""x"")) == (1l));
    assert(strlen((""asdasnakj"")) == (9l));
    }

}
"
HumanEval_24,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു നിശ്ചിത സംഖ്യ n ന്, n നെ തുല്യമായി വിഭജിക്കുന്ന ഏറ്റവും വലിയ സംഖ്യ കണ്ടെത്തുക, n യിൽ ചെറുത്     // >>> largestDivisor((15l))
    // (5l)
    def largestDivisor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // For a given number n, find the largest number that divides n evenly, smaller than n
    // >>> largestDivisor(15l)
    // (5l)
    def largestDivisor(n: Long): Long = {
        for (i <- (n / 2) to 1 by -1) {
            if (n % i == 0) return i
        }
        1L  // if no divisor found, return 1 (since 1 divides any number)
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestDivisor((3l)) == (1l));
    assert(largestDivisor((7l)) == (1l));
    assert(largestDivisor((10l)) == (5l));
    assert(largestDivisor((100l)) == (50l));
    assert(largestDivisor((49l)) == (7l));
    }

}
"
HumanEval_25,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //എല്ലാ ഘടകങ്ങളുടെയും ഗുണനത്തിന് തുല്യമാണ് ഈ സംഖ്യ.    //ഓരോ ഘടകങ്ങളും ഘടക വിഭജനത്തിൽ എത്ര തവണ പ്രത്യക്ഷപ്പെടുന്നു എന്നതിന് അനുസൃതമായി എത്ര തവണ ലിസ്റ്റ് ചെയ്യണം.    //ഒരു നിശ്ചിത സംഖ്യയുടെ പ്രൈം ഫാക്ടറുകളുടെ പട്ടിക ഏറ്റവും ചെറിയതിൽ നിന്നും ഏറ്റവും വലിയതിലേക്കുള്ള ക്രമത്തിൽ നൽകുക.    // >>> factorize((8l))
    // (List[Long](2l.toLong, 2l.toLong, 2l.toLong))
    // >>> factorize((25l))
    // (List[Long](5l.toLong, 5l.toLong))
    // >>> factorize((70l))
    // (List[Long](2l.toLong, 5l.toLong, 7l.toLong))
    def factorize(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def factorize(n: Long): List[Long] = {
    var num = n
    val factors = ListBuffer[Long]()
    
    var i = 2L
    while (i <= sqrt(num).toLong) {
      while (num % i == 0) {
        factors += i
        num /= i
      }
      i += 1
    }
    
    if (num > 1) {
      factors += num
    }
    
    factors.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(factorize((2l)).equals((List[Long](2l.toLong))));
    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));
    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));
    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_26,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഘടകങ്ങളുടെ ക്രമം ഇൻപുട്ടിൽ ഉള്ളതു പോലെ തന്നെ നിലനിർത്തുക.    //ഒരു സംഖ്യകളുടെ പട്ടികയിൽ നിന്നും ഒന്നിലധികം തവണ വരുന്ന എല്ലാ എലമെന്റുകളും നീക്കം ചെയ്യുക.    // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 3l.toLong, 4l.toLong))
    def removeDuplicates(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def removeDuplicates(numbers: List[Long]): List[Long] = {
    val elementCount = numbers.groupBy(identity).mapValues(_.size)
    numbers.filter(num => elementCount(num) == 1)
  }

  def main(args: Array[String]): Unit = {
    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)
    println(removeDuplicates(numbers)) // Output: List(1, 3, 4)
  }
}","    }
    def main(args: Array[String]) = {
    assert(removeDuplicates((List[Long]())).equals((List[Long]())));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));
    }

}
"
HumanEval_27,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു സ്ട്രിങിന്, ചെറിയ അക്ഷരങ്ങളെ വലിയ അക്ഷരങ്ങളാക്കി മാറ്റുക.    // >>> flipCase((""Hello""))
    // (""hELLO"")
    def flipCase(string : String) : String = {
","def flipCase(string: String): String = {
    string.map {
      case c if c.isLower => c.toUpper
      case c if c.isUpper => c.toLower
      case c => c
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(flipCase(("""")).equals(("""")));
    assert(flipCase((""Hello!"")).equals((""hELLO!"")));
    assert(flipCase((""These violent delights have violent ends"")).equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //സ്ട്രിങ്ങുകളുടെ ലിസ്റ്റ് ഒരൊറ്റ സ്ട്രിങ്ങിൽ കൂട്ടിച്ചേര് ക്കുക    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Concatenate list of strings into a single string
    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings: List[String]): String = {
        strings.mkString("""")
    }
}","    }
    def main(args: Array[String]) = {
    assert(concatenate((List[String]())).equals(("""")));
    assert(concatenate((List[String](""x"", ""y"", ""z""))).equals((""xyz"")));
    assert(concatenate((List[String](""x"", ""y"", ""z"", ""w"", ""k""))).equals((""xyzwk"")));
    }

}
"
HumanEval_29,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു നിശ്ചിത പ്രിഫിക്സ് ഉപയോഗിച്ച് ആരംഭിക്കുന്ന സ്ട്രിങ്ങുകൾ മാത്രം ഇൻപുട്ട് ലിസ്റ്റിൽ ഫിൽട്ടർ ചെയ്യുക.    // >>> filterByPrefix((List[String]()), (""a""))
    // (List[String]())
    // >>> filterByPrefix((List[String](""abc"", ""bcd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""array""))
    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {
","strings.filter(_.startsWith(prefix))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterByPrefix((List[String]()), (""john"")).equals((List[String]())));
    assert(filterByPrefix((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    }

}
"
HumanEval_30,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //പട്ടികയിലെ പോസിറ്റീവ് സംഖ്യകൾ മാത്രം തിരികെ നൽകുക.    // >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](2l.toLong, 5l.toLong, 6l.toLong))
    // >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))
    def getPositive(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def getPositive(l: List[Long]): List[Long] = {
        l.filter(_ > 0)
    }
}","    }
    def main(args: Array[String]) = {
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));
    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));
    assert(getPositive((List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_31,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു നിശ്ചിത സംഖ്യ പ്രൈം ആണെങ്കിൽ ശരി, അല്ലെങ്കിൽ തെറ്റായത് എന്ന് റിട്ടേൺ ചെയ്യുക.    // >>> isPrime((6l))
    // (false)
    // >>> isPrime((101l))
    // (true)
    // >>> isPrime((11l))
    // (true)
    // >>> isPrime((13441l))
    // (true)
    // >>> isPrime((61l))
    // (true)
    // >>> isPrime((4l))
    // (false)
    // >>> isPrime((1l))
    // (false)
    def isPrime(n : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if a given number is prime, and false otherwise.
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPrime((6l)) == (false));
    assert(isPrime((101l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((13441l)) == (true));
    assert(isPrime((61l)) == (true));
    assert(isPrime((4l)) == (false));
    assert(isPrime((1l)) == (false));
    assert(isPrime((5l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((17l)) == (true));
    assert(isPrime((85l)) == (false));
    assert(isPrime((77l)) == (false));
    assert(isPrime((255379l)) == (false));
    }

}
"
HumanEval_33,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //l എന്നതിന്റെ അനുബന്ധ സൂചികകളുടെ മൂല്യങ്ങളുമായി താരതമ്യം ചെയ്യുമ്പോൾ, അവയെ തരം തിരിക്കുക.    //l' എന്നത് l ന് തുല്യമാണ്, അത് മൂന്നിൽ ഹരിക്കാത്ത സൂചികകളിൽ, അതിന്റെ മൂല്യങ്ങൾ മൂന്നിൽ ഹരിക്കാവുന്ന സൂചികകളിൽ തുല്യമാണ്.    //ഈ ഫങ്ഷൻ ഒരു ലിസ്റ്റ് l എടുക്കുകയും ഒരു ലിസ്റ്റ് l' തിരിച്ചുനൽകുകയും ചെയ്യുന്നു.    // >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))
    def sortThird(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def sortThird(l: List[Long]): List[Long] = {
    // Get the elements at indices divisible by 3
    val elementsAtThirdIndices = l.zipWithIndex.collect {
      case (value, index) if index % 3 == 0 => value
    }
    
    // Sort the collected elements
    val sortedElements = elementsAtThirdIndices.sorted
    
    // Replace elements at indices divisible by 3 with the sorted ones
    l.zipWithIndex.map {
      case (_, index) if index % 3 == 0 => sortedElements(index / 3)
      case (value, _) => value
    }
  }

  // Example usage:
  def main(args: Array[String]): Unit = {
    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));
    }

}
"
HumanEval_34,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു പട്ടികയിലെ തരം തിരിക്കപ്പെട്ട അദ്വിതീയ ഘടകങ്ങൾ തിരികെ നൽകുന്നു    // >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))
    def unique(l : List[Long]) : List[Long] = {
","def unique(l: List[Long]): List[Long] = {
    l.toSet.toList.sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));
    }

}
"
HumanEval_35,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ലിസ്റ്റിലെ പരമാവധി എലമെന്റ് തിരികെ നൽകുന്നു.    // >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (3l)
    // >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (123l)
    def maxElement(l : List[Long]) : Long = {
","def maxElement(l: List[Long]): Long = {
    l.max
  }
}","    }
    def main(args: Array[String]) = {
    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));
    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));
    }

}
"
HumanEval_36,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //11 നും 13 നും ഭിന്നമാകുന്ന n നേക്കാൾ ചെറു സംഖ്യകളിൽ 7 എന്ന അക്കം എത്ര പ്രാവശ്യം കാണുന്നു എന്ന് തിരികെ നൽകുക.    // >>> fizzBuzz((50l))
    // (0l)
    // >>> fizzBuzz((78l))
    // (2l)
    // >>> fizzBuzz((79l))
    // (3l)
    def fizzBuzz(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fizzBuzz(n: Long): Long = {
    var count = 0L
    for (i <- 1L until n) {
      if (i % 11 == 0 || i % 13 == 0) {
        count += i.toString.count(_ == '7')
      }
    }
    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(fizzBuzz((50l)) == (0l));
    assert(fizzBuzz((78l)) == (2l));
    assert(fizzBuzz((79l)) == (3l));
    assert(fizzBuzz((100l)) == (3l));
    assert(fizzBuzz((200l)) == (6l));
    assert(fizzBuzz((4000l)) == (192l));
    assert(fizzBuzz((10000l)) == (639l));
    assert(fizzBuzz((100000l)) == (8026l));
    }

}
"
HumanEval_37,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //l യുടെ ഇരട്ട സൂചികകളുടെ മൂല്യങ്ങളിലേക്ക്, പക്ഷേ അടുക്കിയിരിക്കുന്നു.    //l' എന്നത് l യ്ക്ക് തുല്യമാണ്, അത് ഇരട്ട സൂചികകളിലാണ്, അതേസമയം അതിന്റെ മൂല്യങ്ങൾ ഇരട്ട സൂചികകളിലാണ്.    //ഈ ഫങ്ഷൻ ഒരു ലിസ്റ്റ് l എടുക്കുകയും ഒരു ലിസ്റ്റ് l' തിരിച്ചുനൽകുകയും ചെയ്യുന്നു.    // >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))
    def sortEven(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // This function takes a list l and returns a list l' such that
  // l' is identical to l in the odd indicies, while its values at the even indicies are equal
  // to the values of the even indicies of l, but sorted.
  def sortEven(l: List[Long]): List[Long] = {
    val evenIndices = l.indices.filter(_ % 2 == 0)
    val sortedEvens = evenIndices.map(l(_)).sorted

    l.indices.map { index =>
      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))
      else l(index)
    }.toList
  }

  // Examples
  def main(args: Array[String]): Unit = {
    println(sortEven(List[Long](1L, 2L, 3L)))
    println(sortEven(List[Long](5L, 6L, 3L, 4L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));
    }

}
"
HumanEval_39,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //prime_fib ഫിബോനാച്ചി സംഖ്യയായ n-ാം സംഖ്യയെ തിരികെ നൽകുന്നു അത് പ്രൈം ആണ്.    // >>> primeFib((1l))
    // (2l)
    // >>> primeFib((2l))
    // (3l)
    // >>> primeFib((3l))
    // (5l)
    // >>> primeFib((4l))
    // (13l)
    // >>> primeFib((5l))
    // (89l)
    def primeFib(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeFib(n: Long): Long = {
    // Function to check if a number is prime
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num == 2) return true
      if (num % 2 == 0) return false
      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {
        if (num % i == 0) return false
      }
      true
    }

    // Function to generate Fibonacci numbers
    def fibonacciStream(): Stream[Long] = {
      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)
      fibs(0, 1)
    }

    // Find the n-th Fibonacci number that is also prime
    val primeFibs = fibonacciStream().filter(isPrime)
    primeFibs.take(n.toInt).last
  }

  // Test the function
  def main(args: Array[String]): Unit = {
    println(primeFib(1L)) // 2
    println(primeFib(2L)) // 3
    println(primeFib(3L)) // 5
    println(primeFib(4L)) // 13
    println(primeFib(5L)) // 89
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeFib((1l)) == (2l));
    assert(primeFib((2l)) == (3l));
    assert(primeFib((3l)) == (5l));
    assert(primeFib((4l)) == (13l));
    assert(primeFib((5l)) == (89l));
    assert(primeFib((6l)) == (233l));
    assert(primeFib((7l)) == (1597l));
    assert(primeFib((8l)) == (28657l));
    assert(primeFib((9l)) == (514229l));
    assert(primeFib((10l)) == (433494437l));
    }

}
"
HumanEval_40,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //പൂജ്യത്തിന് തുല്യമാണ്, അല്ലാത്തപക്ഷം തെറ്റാണ്.    // എന്ന് പറയുന്ന മൂന്ന് വ്യത്യസ്ത ഘടകങ്ങൾ ഉണ്ടെങ്കിൽ അത് true ആയി നൽകുന്നു.    //triples_sum_to_zero ഒരു പൂർണ്ണസംഖ്യകളുടെ പട്ടിക ഒരു ഇൻപുട്ടായി എടുക്കുന്നു.    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong)))
    // (false)
    def triplesSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // triples_sum_to_zero takes a list of integers as an input.
    // it returns true if there are three distinct elements in the list that
    // sum to zero, and false otherwise.
    def triplesSumToZero(l: List[Long]): Boolean = {
        val n = l.length
        if (n < 3) return false

        // Sort the list to use the two-pointer technique
        val sortedList = l.sorted

        // Iterate over the list
        for (i <- 0 until n - 2) {
            var left = i + 1
            var right = n - 1

            // Use two pointers to find the remaining two numbers
            while (left < right) {
                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)
                if (currentSum == 0) {
                    return true
                } else if (currentSum < 0) {
                    left += 1
                } else {
                    right -= 1
                }
            }
        }

        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    }

}
"
HumanEval_41,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഈ ഫങ്ഷൻ ഇത്തരം കൂട്ടിയിടികളുടെ എണ്ണം ഔട്ട്പുട്ട് ചെയ്യുന്നു.    //അവ തമ്മില് കൂട്ടിയിടിച്ച് നോക്കാത്ത പോലെ.    //എന്നിരുന്നാലും, ഈ കാറുകൾ വളരെ കരുത്തുറ്റതും ശക്തവുമാണ്; അതിന്റെ ഫലമായി, അവ തുടർന്നും നീങ്ങുന്നു.    //ഇടത്തു നിന്ന് വലത്തോട്ട് പോകുന്ന ഒരു കാറ് വലത്തു നിന്ന് ഇടത്തോട്ട് പോകുന്ന കാറിനെ തട്ടുമ്പോൾ.    //എല്ലാ കാറുകളും ഒരേ വേഗതയിൽ നീങ്ങുന്നു. രണ്ടു കാറുകൾ കൂട്ടിയിടിക്കപ്പെടുന്നു.    //രണ്ടു കൂട്ടം കാറുകൾ വളരെ അകലെയായി തുടങ്ങുന്നു.    //n കാറുകൾ ഇടത്തുനിന്ന് വലത്തോട്ട് ഓടുന്നു; ഒരേ സമയം, n കാറുകളുടെ മറ്റൊരു കൂട്ടം     //ഒരു റോഡ് സങ്കൽപ്പിക്കുക അത് തികച്ചും നേരായ ഒരു അനന്തമായ നീണ്ട വരിയാണ്.    def carRaceCollision(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Imagine a road that's a perfectly straight infinitely long line.
  // n cars are driving left to right; simultaneously, a different set of n cars
  // are driving right to left. The two sets of cars start out being very far from
  // each other. All cars move at the same speed. Two cars are said to collide
  // when a car that's moving left to right hits a car that's moving right to left.
  // However, the cars are infinitely sturdy and strong; as a result, they continue moving
  // in their trajectory as if they did not collide.
  // This function outputs the number of such collisions.
  def carRaceCollision(n: Long): Long = {
    n
  }
}","    }
    def main(args: Array[String]) = {
    assert(carRaceCollision((2l)) == (4l));
    assert(carRaceCollision((3l)) == (9l));
    assert(carRaceCollision((4l)) == (16l));
    assert(carRaceCollision((8l)) == (64l));
    assert(carRaceCollision((10l)) == (100l));
    }

}
"
HumanEval_42,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //1 കൊണ്ട് വർദ്ധിപ്പിച്ച ഘടകങ്ങളുള്ള ഒരു മടക്ക പട്ടിക.    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))
    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))
    def incrList(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return list with elements incremented by 1.
    def incrList(l: List[Long]): List[Long] = {
        l.map(_ + 1)
    }
}","    }
    def main(args: Array[String]) = {
    assert(incrList((List[Long]())).equals((List[Long]())));
    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));
    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));
    }

}
"
HumanEval_43,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //പൂജ്യത്തിന് തുല്യമാണ്, അല്ലാത്തപക്ഷം തെറ്റാണ്.    // എന്ന് ലിസ്റ്റിൽ രണ്ട് വ്യത്യസ്ത ഘടകങ്ങൾ ഉണ്ടെങ്കിൽ അത് true ആയി നൽകുന്നു.    //pairs_sum_to_zero ഒരു പൂർണ്ണസംഖ്യകളുടെ പട്ടിക ഇൻപുട്ടായി എടുക്കുന്നു.    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (true)
    // >>> pairsSumToZero((List[Long](1l.toLong)))
    // (false)
    def pairsSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def pairsSumToZero(l: List[Long]): Boolean = {
        val seen = HashSet[Long]()
        for (num <- l) {
            if (seen.contains(-num)) {
                return true
            }
            seen.add(num)
        }
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));
    }

}
"
HumanEval_44,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //അടിസ്ഥാന സംഖ്യകൾ 10 ൽ കുറവാണ്.    //പരിവർത്തനത്തിനു ശേഷം സ്ട്രിംഗ് റെപ്രസന്റേഷൻ തിരിച്ചുനൽകുന്നു.    //ഇൻപുട്ട് നമ്പർ x ന്റെ സംഖ്യാ അടിത്തറയെ അടിസ്ഥാനമായി മാറ്റുക.    // >>> changeBase((8l), (3l))
    // (""22"")
    // >>> changeBase((8l), (2l))
    // (""1000"")
    // >>> changeBase((7l), (2l))
    // (""111"")
    def changeBase(x : Long, base : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def changeBase(x: Long, base: Long): String = {
        require(base > 1 && base < 10, ""Base must be between 2 and 9"")
        
        if (x == 0) return ""0""

        val result = new StringBuilder()
        var number = x

        while (number > 0) {
            val remainder = number % base
            result.append(remainder.toString)
            number /= base
        }

        result.reverse.toString()
    }
}","    }
    def main(args: Array[String]) = {
    assert(changeBase((8l), (3l)).equals((""22"")));
    assert(changeBase((9l), (3l)).equals((""100"")));
    assert(changeBase((234l), (2l)).equals((""11101010"")));
    assert(changeBase((16l), (2l)).equals((""10000"")));
    assert(changeBase((8l), (2l)).equals((""1000"")));
    assert(changeBase((7l), (2l)).equals((""111"")));
    assert(changeBase((2l), (3l)).equals((""2"")));
    assert(changeBase((3l), (4l)).equals((""3"")));
    assert(changeBase((4l), (5l)).equals((""4"")));
    assert(changeBase((5l), (6l)).equals((""5"")));
    assert(changeBase((6l), (7l)).equals((""6"")));
    assert(changeBase((7l), (8l)).equals((""7"")));
    }

}
"
HumanEval_45,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഒരു ത്രികോണത്തിന്റെ വശത്തിന്റെ നീളവും ഉയർന്ന മടക്ക പ്രദേശവും കണക്കിലെടുക്കുമ്പോൾ.    // >>> triangleArea((5l), (3l))
    // (7.5f)
    def triangleArea(a : Long, h : Long) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> triangleArea(5l, 3l)
    // (7.5f)
    def triangleArea(a: Long, h: Long): Float = {
        (a * h / 2.0).toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((5l), (3l)) == (7.5f));
    assert(triangleArea((2l), (2l)) == (2.0f));
    assert(triangleArea((10l), (8l)) == (40.0f));
    }

}
"
HumanEval_46,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //fib4 സംഖ്യാ ശ്രേണിയുടെ n-ആം മൂലകം കാര്യക്ഷമമായി കണക്കുകൂട്ടാൻ ഒരു ഫംഗ്ഷൻ എഴുതുക. ആവർത്തനം ഉപയോഗിക്കരുത്.    //ഫിബര് ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു ടു    //fib4(3) -> 0     //fib4(2) -> 2     //fib4(1) -> 0     //fib4(0) -> 0     //ഫിബൊനാച്ചി അനുക്രമത്തിന് സമാനമായ ഒരു അനുക്രമമാണ് ഫിബൊനച്ചി സംഖ്യാ അനുക്രമം, അത് താഴെ പറയുന്ന രീതിയിൽ നിർവചിക്കപ്പെട്ടിരിക്കുന്നു:    // >>> fib4((5l))
    // (4l)
    // >>> fib4((6l))
    // (8l)
    // >>> fib4((7l))
    // (14l)
    def fib4(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fib4(n: Long): Long = {
    if (n == 0 || n == 1) return 0
    if (n == 2) return 2
    if (n == 3) return 0

    var a: Long = 0
    var b: Long = 0
    var c: Long = 2
    var d: Long = 0
    
    var result: Long = 0
    
    for (i <- 4L to n) {
      result = a + b + c + d
      a = b
      b = c
      c = d
      d = result
    }
    
    result
  }
}","    }
    def main(args: Array[String]) = {
    assert(fib4((5l)) == (4l));
    assert(fib4((8l)) == (28l));
    assert(fib4((10l)) == (104l));
    assert(fib4((12l)) == (386l));
    }

}
"
HumanEval_47,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //പട്ടികയിലെ മൂലകങ്ങളുടെ റിട്ടേൺ മീഡിയൻ l.     // >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // 3l
    // >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))
    // (15.0f)
    def median(l : List[Long]) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return median of elements in the list l.
  def median(l: List[Long]): Float = {
    val sortedList = l.sorted
    val n = sortedList.length
    if (n % 2 == 1) {
      sortedList(n / 2).toFloat
    } else {
      (sortedList(n / 2 - 1) + sortedList(n / 2)).toFloat / 2
    }
  }

  def main(args: Array[String]): Unit = {
    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) // 3.0
    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) // 15.0
  }
}","    }
    def main(args: Array[String]) = {
    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);
    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));
    assert(median((List[Long](5l.toLong))) == 5l);
    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));
    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);
    }

}
"
HumanEval_48,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //തന്നിരിക്കുന്ന സ്ട്രിംഗ് ഒരു പാലിൻഡ്രോം ആണോ എന്ന് പരിശോധിക്കുന്നു.    // >>> isPalindrome((""""))
    // (true)
    // >>> isPalindrome((""aba""))
    // (true)
    // >>> isPalindrome((""aaaaa""))
    // (true)
    // >>> isPalindrome((""zbcd""))
    // (false)
    def isPalindrome(text : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Checks if given string is a palindrome
  def isPalindrome(text: String): Boolean = {
    val length = text.length
    for (i <- 0 until length / 2) {
      if (text(i) != text(length - i - 1)) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPalindrome(("""")) == (true));
    assert(isPalindrome((""aba"")) == (true));
    assert(isPalindrome((""aaaaa"")) == (true));
    assert(isPalindrome((""zbcd"")) == (false));
    assert(isPalindrome((""xywyx"")) == (true));
    assert(isPalindrome((""xywyz"")) == (false));
    assert(isPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //2^n മോഡുലോ പി തിരിച്ചുവിടുന്നു (നമ്പറുകളെക്കുറിച്ച് ബോധവാനായിരിക്കുക).    // >>> modp((3l), (5l))
    // (3l)
    // >>> modp((1101l), (101l))
    // (2l)
    // >>> modp((0l), (101l))
    // (1l)
    // >>> modp((3l), (11l))
    // (8l)
    // >>> modp((100l), (101l))
    // (1l)
    def modp(n : Long, p : Long) : Long = {
","def modp(n: Long, p: Long): Long = {
    // Calculate 2^n modulo p using iterative exponentiation by squaring.
    def powMod(base: Long, exp: Long, mod: Long): Long = {
      var result = 1L
      var b = base % mod
      var e = exp
      
      while (e > 0) {
        if ((e & 1) == 1) { // Check if e is odd
          result = (result * b) % mod
        }
        e >>= 1
        b = (b * b) % mod
      }

      result
    }

    powMod(2, n, p)
  }
}","    }
    def main(args: Array[String]) = {
    assert(modp((3l), (5l)) == (3l));
    assert(modp((1101l), (101l)) == (2l));
    assert(modp((0l), (101l)) == (1l));
    assert(modp((3l), (11l)) == (8l));
    assert(modp((100l), (101l)) == (1l));
    assert(modp((30l), (5l)) == (4l));
    assert(modp((31l), (5l)) == (3l));
    }

}
"
HumanEval_51,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //remove_vowels എന്നത് സ്ട്രിംഗ് എടുക്കുകയും സ്വരാക്ഷരങ്ങളില്ലാത്ത സ്ട്രിംഗ് തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷനാണ്.    // >>> removeVowels((""""))
    // ("""")
    // >>> removeVowels((""abcdef""))
    // (""bcdf"")
    // >>> removeVowels((""aaaaa""))
    // ("""")
    // >>> removeVowels((""aaBAA""))
    // (""B"")
    // >>> removeVowels((""zbcd""))
    // (""zbcd"")
    def removeVowels(text : String) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def removeVowels(text: String): String = {
        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        text.filterNot(vowels.contains)
    }
}","    }
    def main(args: Array[String]) = {
    assert(removeVowels(("""")).equals(("""")));
    assert(removeVowels((""abcdef\nghijklm"")).equals((""bcdf\nghjklm"")));
    assert(removeVowels((""fedcba"")).equals((""fdcb"")));
    assert(removeVowels((""eeeee"")).equals(("""")));
    assert(removeVowels((""acBAA"")).equals((""cB"")));
    assert(removeVowels((""EcBOO"")).equals((""cB"")));
    assert(removeVowels((""ybcd"")).equals((""ybcd"")));
    }

}
"
HumanEval_52,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ലിസ്റ്റിലെ എല്ലാ നമ്പറുകളും t എന്ന പരിധിക്കു താഴെയാണെങ്കിൽ true എന്ന് തിരികെ നൽകുന്നു.    // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
    // (true)
    // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
    // (false)
    def belowThreshold(l : List[Long], t : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if all numbers in the list l are below threshold t.
  // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
  // (true)
  // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
  // (false)
  def belowThreshold(l: List[Long], t: Long): Boolean = {
    l.forall(_ < t)
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));
    }

}
"
HumanEval_53,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //x, y എന്നീ രണ്ടു സംഖ്യകളെ കൂട്ടുക.    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Add two numbers x and y
    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x: Long, y: Long): Long = {
        x + y
    }
}","    }
    def main(args: Array[String]) = {
    assert(add((0l), (1l)) == (1l));
    assert(add((1l), (0l)) == (1l));
    assert(add((2l), (3l)) == (5l));
    assert(add((5l), (7l)) == (12l));
    assert(add((7l), (5l)) == (12l));
    }

}
"
HumanEval_54,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //രണ്ട് വാക്കുകളിലും ഒരേ അക്ഷരങ്ങളുണ്ടോ എന്ന് പരിശോധിക്കുക.    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> sameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> sameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> sameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> sameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    def sameChars(s0 : String, s1 : String) : Boolean = {
","import scala.collection.mutable._

object Problem {
  def sameChars(s0: String, s1: String): Boolean = {
    def charSet(s: String): Set[Char] = s.toSet
    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(sameChars((""abcd""), (""dddddddabc"")) == (true));
    assert(sameChars((""dddddddabc""), (""abcd"")) == (true));
    assert(sameChars((""eabcd""), (""dddddddabc"")) == (false));
    assert(sameChars((""abcd""), (""dddddddabcf"")) == (false));
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(sameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //n-ആം ഫിബോനാച്ചി സംഖ്യ തിരികെ നൽകുക.    // >>> fib((10l))
    // (55l)
    // >>> fib((1l))
    // (1l)
    // >>> fib((8l))
    // (21l)
    def fib(n : Long) : Long = {
","def fib(n: Long): Long = {
        if (n <= 1) n
        else {
            var a: Long = 0
            var b: Long = 1
            for (_ <- 2L to n) {
                val temp = a + b
                a = b
                b = temp
            }
            b
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(fib((10l)) == (55l));
    assert(fib((1l)) == (1l));
    assert(fib((8l)) == (21l));
    assert(fib((11l)) == (89l));
    assert(fib((12l)) == (144l));
    }

}
"
HumanEval_56,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഓരോ തുറക്കുന്ന ബ്രാക്കറ്റിനും ഒരു അടയ്ക്കുന്ന ബ്രാക്കറ്റും ഉണ്ടെങ്കിൽ true എന്ന് റിട്ടേൺ ചെയ്യുക.    //ബ്രാക്കറ്റുകളില് ""<"" ഉം "">"" ഉം അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്.    // >>> correctBracketing((""<""))
    // (false)
    // >>> correctBracketing((""<>""))
    // (true)
    // >>> correctBracketing((""<<><>>""))
    // (true)
    // >>> correctBracketing((""><<>""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","import scala.collection.mutable.Stack

object Problem {
  def correctBracketing(brackets: String): Boolean = {
    val stack = new Stack[Char]()
    for (char <- brackets) {
      if (char == '<') {
        stack.push(char)
      } else if (char == '>') {
        if (stack.isEmpty || stack.pop() != '<') {
          return false
        }
      }
    }
    stack.isEmpty
  }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""<>"")) == (true));
    assert(correctBracketing((""<<><>>"")) == (true));
    assert(correctBracketing((""<><><<><>><>"")) == (true));
    assert(correctBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(correctBracketing((""<<<><>>>>"")) == (false));
    assert(correctBracketing((""><<>"")) == (false));
    assert(correctBracketing((""<"")) == (false));
    assert(correctBracketing((""<<<<"")) == (false));
    assert(correctBracketing(("">"")) == (false));
    assert(correctBracketing((""<<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>><<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ലിസ്റ്റ് എലമെന്റുകൾ ഏകതാനമായി വർദ്ധിക്കുകയോ കുറയുകയോ ചെയ്യുന്നുവെങ്കിൽ true തിരികെ നൽകുക.    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
    // (true)
    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
    // (false)
    // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
    // (true)
    def monotonic(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if list elements are monotonically increasing or decreasing.
  // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
  // (true)
  // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
  // (false)
  // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
  // (true)
  def monotonic(l: List[Long]): Boolean = {
    if (l.isEmpty || l.length == 1) return true

    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }
    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }

    increasing || decreasing
  }
}","    }
    def main(args: Array[String]) = {
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));
    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));
    }

}
"
HumanEval_58,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //രണ്ട് ലിസ്റ്റുകൾക്കായുള്ള തരം തിരിക്കപ്പെട്ട സവിശേഷമായ പൊതുവായ ഘടകങ്ങൾ തിരികെ നൽകുന്നു.    // >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))
    // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))
    // >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong))
    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return sorted unique common elements for two lists.
  def common(l1: List[Long], l2: List[Long]): List[Long] = {
    (l1.toSet intersect l2.toSet).toList.sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))
    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));
    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_59,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //n ന്റെ ഏറ്റവും വലിയ പ്രൈം ഫാക്ടർ തിരികെ നൽകുക. n > 1 ആണെന്നും പ്രൈം അല്ലെന്നും കരുതുക.     // >>> largestPrimeFactor((13195l))
    // (29l)
    // >>> largestPrimeFactor((2048l))
    // (2l)
    def largestPrimeFactor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def largestPrimeFactor(n: Long): Long = {
        var number = n
        var largestFactor = 1L

        // Check for number of 2s that divide n
        while (number % 2 == 0) {
            largestFactor = 2L
            number /= 2
        }

        // n must be odd at this point, so a skip of 2 (i = i + 2) can be used
        var i = 3
        while (i <= sqrt(number)) {
            while (number % i == 0) {
                largestFactor = i
                number /= i
            }
            i += 2
        }

        // This condition is to check if number is a prime number greater than 2
        if (number > 2) {
            largestFactor = number
        }

        largestFactor
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestPrimeFactor((15l)) == (5l));
    assert(largestPrimeFactor((27l)) == (3l));
    assert(largestPrimeFactor((63l)) == (7l));
    assert(largestPrimeFactor((330l)) == (11l));
    assert(largestPrimeFactor((13195l)) == (29l));
    }

}
"
HumanEval_60,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //sum_to_n എന്നത് 1 മുതൽ n വരെയുള്ള സംഖ്യകളുടെ സംഖ്യയായി കണക്കാക്കുന്ന ഒരു ഫംഗ്ഷനാണ്.    // >>> sumToN((30l))
    // (465l)
    // >>> sumToN((100l))
    // (5050l)
    // >>> sumToN((5l))
    // (15l)
    // >>> sumToN((10l))
    // (55l)
    // >>> sumToN((1l))
    // (1l)
    def sumToN(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def sumToN(n: Long): Long = {
        (1L to n).sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumToN((1l)) == (1l));
    assert(sumToN((6l)) == (21l));
    assert(sumToN((11l)) == (66l));
    assert(sumToN((30l)) == (465l));
    assert(sumToN((100l)) == (5050l));
    }

}
"
HumanEval_61,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഓരോ തുറക്കുന്ന ബ്രാക്കറ്റിനും ഒരു അടയ്ക്കുന്ന ബ്രാക്കറ്റും ഉണ്ടെങ്കിൽ true എന്ന് റിട്ടേൺ ചെയ്യുക.    //ബ്രാക്കറ്റുകളില് ""("" ഉം """") യും അടങ്ങിയ ഒരു സ്ട്രിംഗ് ആണ്.    // >>> correctBracketing((""(""))
    // (false)
    // >>> correctBracketing((""()""))
    // (true)
    // >>> correctBracketing((""(()())""))
    // (true)
    // >>> correctBracketing(("")(()""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","var balance = 0
        for (ch <- brackets) {
            if (ch == '(') balance += 1
            else if (ch == ')') balance -= 1
            
            if (balance < 0) return false
        }
        balance == 0
    }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""()"")) == (true));
    assert(correctBracketing((""(()())"")) == (true));
    assert(correctBracketing((""()()(()())()"")) == (true));
    assert(correctBracketing((""()()((()()())())(()()(()))"")) == (true));
    assert(correctBracketing((""((()())))"")) == (false));
    assert(correctBracketing(("")(()"")) == (false));
    assert(correctBracketing((""("")) == (false));
    assert(correctBracketing((""(((("")) == (false));
    assert(correctBracketing(("")"")) == (false));
    assert(correctBracketing((""(()"")) == (false));
    assert(correctBracketing((""()()(()())())(()"")) == (false));
    assert(correctBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഈ പോളിനോമിയുടെ ഡെറിവേറ്റീവ് അതേ രൂപത്തിൽ തിരികെ നൽകുക.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....  എന്നിങ്ങനെ ഒരു സംഖ്യയുടെ സംഖ്യകൾ കൂട്ടിച്ചേർക്കുക    //xs ഒരു പോളിനോമിയുടെ ഗുണകങ്ങളെ പ്രതിനിധീകരിക്കുന്നു.    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))
    // >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong))
    def derivative(xs : List[Long]) : List[Long] = {
","import scala.collection.mutable._

object Problem {
  def derivative(xs: List[Long]): List[Long] = {
    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }
  }
}","    }
    def main(args: Array[String]) = {
    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));
    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));
    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_63,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഫിബ്ബി നമ്പർ സീക്വൻസിന്റെ n-ആം എലമെന്റ് കാര്യക്ഷമമായി കണക്കുകൂട്ടാൻ ഒരു ഫംഗ്ഷൻ എഴുതുക.    //ഫിബ്ബി (n) == ഫിബ്ബി (n-1) + ഫിബ്ബി (n-2) + ഫിബ്ബി (n-3).     //ഫിഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്    //ഫിഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്    //ഫിഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്ഫ്    //ഫിബോനാച്ചി അനുക്രമത്തിന് സമാനമായ ഒരു അനുക്രമമാണ് ഫിബോനാച്ചി സംഖ്യാ അനുക്രമം, അത് താഴെ പറയുന്ന രീതിയിൽ നിർവചിക്കപ്പെട്ടിരിക്കുന്നു:    // >>> fibfib((1l))
    // (0l)
    // >>> fibfib((5l))
    // (4l)
    // >>> fibfib((8l))
    // (24l)
    def fibfib(n : Long) : Long = {
","def fibfib(n: Long): Long = {
    if (n == 0) return 0
    if (n == 1) return 0
    if (n == 2) return 1

    var a: Long = 0
    var b: Long = 0
    var c: Long = 1
    var d: Long = 0

    for (_ <- 3L to n) {
      d = a + b + c
      a = b
      b = c
      c = d
    }
    d
  }
}","    }
    def main(args: Array[String]) = {
    assert(fibfib((2l)) == (1l));
    assert(fibfib((1l)) == (0l));
    assert(fibfib((5l)) == (4l));
    assert(fibfib((8l)) == (24l));
    assert(fibfib((10l)) == (81l));
    assert(fibfib((12l)) == (274l));
    assert(fibfib((14l)) == (927l));
    }

}
"
HumanEval_64,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //വോക്കൽ, പക്ഷേ അത് വാക്കിന്റെ അവസാനം ഉള്ളപ്പോൾ മാത്രം.    //ഈ കേസിലെ സ്വരാക്ഷരങ്ങൾ 'a', 'e', 'i', 'o', 'u' ആണ്. ഇവിടെ, 'y' ഒരു യും ആണ്.    //ഒരു വാക്ക് ഇൻപുട്ടായി നല് കുകയും സ്ട്രിങ്ങിലെ സ്വരാക്ഷരങ്ങളുടെ എണ്ണം നല് കുകയും ചെയ്യുന്നു.    // എന്നൊരു സ്ട്രിംഗ് എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ vowels_count എഴുതുക.    // >>> vowelsCount((""abcde""))
    // (2l)
    // >>> vowelsCount((""ACEDY""))
    // (3l)
    def vowelsCount(s : String) : Long = {
","def vowelsCount(s: String): Long = {
    val vowels = Set('a', 'e', 'i', 'o', 'u')
    val lowerCaseWord = s.toLowerCase
    var count = 0L

    for (i <- lowerCaseWord.indices) {
      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(vowelsCount((""abcde"")) == (2l));
    assert(vowelsCount((""Alone"")) == (3l));
    assert(vowelsCount((""key"")) == (2l));
    assert(vowelsCount((""bye"")) == (1l));
    assert(vowelsCount((""keY"")) == (2l));
    assert(vowelsCount((""bYe"")) == (1l));
    assert(vowelsCount((""ACEDY"")) == (3l));
    }

}
"
HumanEval_65,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //shift > അക്കങ്ങളുടെ എണ്ണം എങ്കിൽ, അക്കങ്ങൾ വിപരീതമായി നൽകുക.    //ഫലം ഒരു സ്ട്രിംഗായി റിട്ടേൺ ചെയ്യുക.    //x ന്റെ അക്കം വലത്തോട്ട് നീക്കുക, വലത്തോട്ട് നീക്കുക    // >>> circularShift((12l), (1l))
    // (""21"")
    // >>> circularShift((12l), (2l))
    // (""12"")
    def circularShift(x : Long, shift : Long) : String = {
","def circularShift(x: Long, shift: Long): String = {
  val digits = x.toString
  val length = digits.length
  
  if (shift >= length) {
    digits.reverse
  } else {
    val effectiveShift = (length - shift % length).toInt
    (digits.drop(effectiveShift) + digits.take(effectiveShift))
  }
}","    }
    def main(args: Array[String]) = {
    assert(circularShift((100l), (2l)).equals((""001"")));
    assert(circularShift((12l), (2l)).equals((""12"")));
    assert(circularShift((97l), (8l)).equals((""79"")));
    assert(circularShift((12l), (1l)).equals((""21"")));
    assert(circularShift((11l), (101l)).equals((""11"")));
    }

}
"
HumanEval_66,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ASCII കോഡുകൾ     //ഒരു സ്ട്രിംഗ് ഇൻപുട്ടായി എടുക്കുകയും മുകളിലെ പ്രതീകങ്ങളുടെ തുക മാത്രം നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക'     //ചുമതല     // >>> digitSum((""""))
    // (0l)
    // >>> digitSum((""abAB""))
    // (131l)
    // >>> digitSum((""abcCd""))
    // (67l)
    // >>> digitSum((""helloE""))
    // (69l)
    // >>> digitSum((""woArBld""))
    // (131l)
    // >>> digitSum((""aAaaaXa""))
    // (153l)
    def digitSum(s : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def digitSum(s: String): Long = {
    s.filter(_.isUpper).map(_.toLong).sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(digitSum(("""")) == (0l));
    assert(digitSum((""abAB"")) == (131l));
    assert(digitSum((""abcCd"")) == (67l));
    assert(digitSum((""helloE"")) == (69l));
    assert(digitSum((""woArBld"")) == (131l));
    assert(digitSum((""aAaaaXa"")) == (153l));
    assert(digitSum(("" How are yOu?"")) == (151l));
    assert(digitSum((""You arE Very Smart"")) == (327l));
    }

}
"
HumanEval_67,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //യും    //കൊട്ടയില് , കൊട്ടയില് മാങ്ങയുടെ എണ്ണം തിരിച്ച് കൊടുക്കുക.    //ആപ്പിളും ഓറഞ്ചും, പഴങ്ങളുടെ ആകെ എണ്ണം സൂചിപ്പിക്കുന്ന ഒരു സംഖ്യയും.    //ആപ്പിളും ഓറഞ്ചും മാംഗോയും.    //ഈ കൊട്ടയില് അടങ്ങിയിരിക്കുന്ന പഴങ്ങളുടെ ഒരു കൊട്ടയില് വിതരണം ചെയ്യപ്പെടുന്ന     //ഈ ടാസ്കിൽ, നിങ്ങൾക്ക് ഒരു സ്ട്രിംഗ് ലഭിക്കും അത് ആപ്പിളുകളുടെയും ഓറഞ്ചുകളുടെയും എണ്ണം പ്രതിനിധീകരിക്കും.    // >>> fruitDistribution((""5 apples and 6 oranges""), (19l))
    // (8l)
    // >>> fruitDistribution((""0 apples and 1 oranges""), (3l))
    // (2l)
    // >>> fruitDistribution((""2 apples and 3 oranges""), (100l))
    // (95l)
    // >>> fruitDistribution((""100 apples and 1 oranges""), (120l))
    // (19l)
    def fruitDistribution(s : String, n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fruitDistribution(s: String, n: Long): Long = {
    val fruits = s.split("" and "").map(_.split("" "")(0).toLong)
    val totalApplesAndOranges = fruits.sum
    n - totalApplesAndOranges
  }
}","    }
    def main(args: Array[String]) = {
    assert(fruitDistribution((""5 apples and 6 oranges""), (19l)) == (8l));
    assert(fruitDistribution((""5 apples and 6 oranges""), (21l)) == (10l));
    assert(fruitDistribution((""0 apples and 1 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""1 apples and 0 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (100l)) == (95l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (5l)) == (0l));
    assert(fruitDistribution((""1 apples and 100 oranges""), (120l)) == (19l));
    }

}
"
HumanEval_68,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം 1:    //ഇരട്ട മൂല്യങ്ങളില്ലെങ്കിലോ തന്നിരിക്കുന്ന പട്ടിക ശൂന്യമാണെങ്കിലോ, മടങ്ങുക [].    //പിളര് ന്ന നോഡ് ഒരു ലിസ്റ്റില് തിരിച്ചെത്തണം, [ smalest_value, അതിന്റെ സൂചിക ],     //ഒരേ ചെറിയ ഇരട്ട മൂല്യം ഉള്ള ഒന്നിലധികം നോഡുകൾ കണ്ടെത്തിയാൽ ഏറ്റവും ചെറിയ സൂചികയുള്ള നോഡ് തിരികെ നൽകുക.    //ഈ നോഡിൽ ഏറ്റവും ചെറിയ ഇരട്ട മൂല്യം ഉണ്ടായിരിക്കണം.    //നിങ്ങളുടെ ജോലി ഒരു നോഡിൽ നിന്ന് പിഴുതെടുത്ത് അത് തിരികെ കൊടുക്കുക എന്നതാണ്.    //""നല്ല സംഖ്യകളുള്ള നോഡുകളുള്ള ഒരു വൃക്ഷത്തിന്റെ ശാഖയെ പ്രതിനിധീകരിക്കുന്ന ഒരു പട്ടിക നൽകിയിട്ടുണ്ടെങ്കിൽ     // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> pluck((List[Long]()))
    // (List[Long]())
    // Example 4:
    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    def pluck(arr : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def pluck(arr: List[Long]): List[Long] = {
    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }
    if (evenNodes.isEmpty) {
      List.empty[Long]
    } else {
      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }
      List(smallestValue, index.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long]())).equals((List[Long]())));
    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));
    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_69,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //അത്തരമൊരു മൂല്യം ഇല്ലെങ്കിൽ, -1 തിരികെ നൽകുക.    //ഒരു സംഖ്യയുടെ ആവൃത്തി, അത് പട്ടികയിൽ എത്ര പ്രാവശ്യം പ്രത്യക്ഷപ്പെടുന്നു എന്നതിനെ സൂചിപ്പിക്കുന്നു.    //പൂജ്യമാണ്, കൂടാതെ സംഖ്യയുടെ മൂല്യത്തേക്കാൾ വലുതോ തുല്യമോ ആയ ഒരു ആവൃത്തി ഉണ്ട്.    //പോസിറ്റീവ് സംഖ്യകളുടെ ഒരു പട്ടിക നിങ്ങൾക്ക് ലഭിക്കുന്നു.                                           // >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))
    // (2l)
    // >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (3l)
    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (-1l)
    def search(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def search(lst: List[Long]): Long = {
    val frequencyMap = lst.groupBy(identity).mapValues(_.size)
    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {
      case x :: _ => x
      case Nil => -1L
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));
    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));
    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));
    assert(search((List[Long](1l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));
    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));
    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));
    assert(search((List[Long](10l.toLong))) == (-1l));
    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));
    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));
    }

}
"
HumanEval_70,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //പിന്നെ ബാക്കിയുള്ള സംഖ്യകളുടെ പരമാവധി, പിന്നെ കുറഞ്ഞത്, അങ്ങനെ.    //ഏറ്റവും കുറഞ്ഞ മൂല്യം ഉപയോഗിച്ച് തുടങ്ങുന്നതാണ് വിചിത്രമായ തരംതിരിവ്,    //പൂർണ്ണസംഖ്യകളുടെ പട്ടിക കൊടുത്താൽ, പട്ടിക വിചിത്രമായ ക്രമത്തിൽ തിരിച്ചുനൽകുന്നു.    // >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))
    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))
    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))
    // >>> strangeSortList((List[Long]()))
    // (List[Long]())
    def strangeSortList(lst : List[Long]) : List[Long] = {
","def strangeSortList(lst: List[Long]): List[Long] = {
    val buffer = lst.sorted.toBuffer
    val result = ArrayBuffer[Long]()
    var takeMin = true

    while (buffer.nonEmpty) {
      if (takeMin) {
        result += buffer.remove(0) // take the minimum
      } else {
        result += buffer.remove(buffer.length - 1) // take the maximum of the remaining
      }
      takeMin = !takeMin
    }

    result.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long]())).equals((List[Long]())));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));
    }

}
"
HumanEval_71,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //മൂന്നാം വശത്തേക്കാൾ.    //ഏതെങ്കിലും രണ്ട് വശങ്ങളുടെ സംഖ്യ കൂടുതലാണെങ്കിൽ മൂന്നു വശങ്ങളും ഒരു ത്രികോണത്തെ രൂപപ്പെടുത്തുന്നു.    //ഇല്ലെങ്കിൽ -1  തിരിച്ചു നൽകും.    //ത്രികോണം രണ്ട് ദശാംശസ്ഥാനങ്ങളിലേക്ക് ചുരുക്കിയിട്ടുണ്ടെങ്കിൽ അതിന്റെ മൂന്നു വശങ്ങളും ഒരു സാധുവായ ത്രികോണമായിരിക്കണം.    //ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങളുടെ നീളം കണക്കിലെടുത്താൽ ന്റെ വിസ്തീർണ്ണം തിരികെ കൊടുക്കുക    // >>> triangleArea((3l), (4l), (5l))
    // (6.0f)
    // >>> triangleArea((1l), (2l), (10l))
    // -1l
    def triangleArea(a : Long, b : Long, c : Long) : Float = {
","import scala.math._

object Problem {
  def triangleArea(a: Long, b: Long, c: Long): Float = {
    if (a + b > c && a + c > b && b + c > a) {
      val s = (a + b + c) / 2.0
      val area = sqrt(s * (s - a) * (s - b) * (s - c))
      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat
    } else {
      -1f
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((3l), (4l), (5l)) == (6.0f));
    assert(triangleArea((1l), (2l), (10l)) == -1l);
    assert(triangleArea((4l), (8l), (5l)) == (8.18f));
    assert(triangleArea((2l), (2l), (2l)) == (1.73f));
    assert(triangleArea((1l), (2l), (3l)) == -1l);
    assert(triangleArea((10l), (5l), (7l)) == (16.25f));
    assert(triangleArea((2l), (6l), (3l)) == -1l);
    assert(triangleArea((1l), (1l), (1l)) == (0.43f));
    assert(triangleArea((2l), (2l), (10l)) == -1l);
    }

}
"
HumanEval_72,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //വസ്തു q സന്തുലിതമാണെങ്കിൽ പറക്കും (ഇത് ഒരു പാലിൻഡ്രോമിക് പട്ടികയാണ്) അതിന്റെ ഘടകങ്ങളുടെ ആകെത്തുക പരമാവധി സാധ്യമായ ഭാരത്തേക്കാൾ കുറവോ തുല്യമോ ആണെങ്കിൽ w.    //വസ്തു q പറന്നു പോകുന്നുവെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫങ്ഷൻ എഴുതുക, അല്ലാത്തപക്ഷം false എന്ന് തിരികെ നൽകുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> willItFly((List[Long](3l.toLong)), (5l))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    def willItFly(q : List[Long], w : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def willItFly(q: List[Long], w: Long): Boolean = {
    val isPalindromic = q == q.reverse
    val sumOfElements = q.sum
    isPalindromic && sumOfElements <= w
  }

  def main(args: Array[String]): Unit = {
    println(willItFly(List[Long](1L, 2L), 5L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 1L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 9L)) // true
    println(willItFly(List[Long](3L), 5L)) // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));
    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));
    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));
    }

}
"
HumanEval_73,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //ഒരു മാറ്റം കൊണ്ട്, നിങ്ങൾക്ക് ഒരു മൂലകം മറ്റേതെങ്കിലും മൂലകത്തിലേക്ക് മാറ്റാം.    //പട്ടിക പാലിൻഡ്രോമിക് ആക്കുന്നതിന് മാറ്റം വരുത്തേണ്ടതുണ്ട്. ഒരു പാലിൻഡ്രോമിക് ലിസ്റ്റ് ഒരു പട്ടികയാണ്     //ഒരു സംഖ്യകളുടെ ലിസ്റ്റ് arr കൊടുത്താൽ,  ന്റെ ഏറ്റവും കുറഞ്ഞ എണ്ണം കണ്ടെത്തുക    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))
    // (4l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))
    // (1l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))
    // (0l)
    def smallestChange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a list arr of integers, find the minimum number of elements that
  // need to be changed to make the list palindromic.

  def smallestChange(arr: List[Long]): Long = {
    var changes: Long = 0

    for (i <- 0 until arr.length / 2) {
      if (arr(i) != arr(arr.length - 1 - i)) {
        changes += 1
      }
    }

    changes
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  // Output: 4
    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  // Output: 1
    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  // Output: 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));
    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));
    assert(smallestChange((List[Long](1l.toLong))) == (0l));
    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));
    }

}
"
HumanEval_74,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //രണ്ട് ലിസ്റ്റുകളിലും ഒരേ സംഖ്യ ഉണ്ടെങ്കിൽ, ആദ്യത്തെ ലിസ്റ്റ് തിരികെ നൽകുക.    //ലിസ്റ്റിന്റെ എല്ലാ സ്ട്രിങ്ങുകളിലും ഉള്ള ആകെ അക്ഷരങ്ങളുടെ എണ്ണം മറ്റ് ലിസ്റ്റുകളേക്കാൾ കുറവാണ്.    //രണ്ട് സ്ട്രിങ്ങുകളുടെ ലിസ്റ്റുകൾ സ്വീകരിക്കുകയും  ഉള്ള ലിസ്റ്റ് തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.    // >>> totalMatch((List[String]()), (List[String]()))
    // (List[String]())
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi"")))
    // (List[String](""hI"", ""Hi""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project"")))
    // (List[String](""hi"", ""admin""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi"")))
    // (List[String](""hI"", ""hi"", ""hi""))
    // >>> totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5"")))
    // (List[String](""4""))
    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {
    val sum1 = lst1.map(_.length).sum
    val sum2 = lst2.map(_.length).sum
    if (sum1 <= sum2) lst1 else lst2
  }
}","    }
    def main(args: Array[String]) = {
    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi""))).equals((List[String](""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5""))).equals((List[String](""4""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi""))).equals((List[String](""hI"", ""Hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi""))).equals((List[String](""hI"", ""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hii""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String]()), (List[String](""this""))).equals((List[String]())));
    assert(totalMatch((List[String](""this"")), (List[String]())).equals((List[String]())));
    }

}
"
HumanEval_75,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //(a) 100 ൽ കുറവാണെന്ന് അറിയുന്നത്.    //അല്ലെങ്കിൽ തെറ്റാണ്.    //3 പ്രൈം നമ്പറുകളുടെ ഗുണനമാണെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.    // >>> isMultiplyPrime((30l))
    // (true)
    // 30 = 2 * 3 * 5
    def isMultiplyPrime(a : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isMultiplyPrime(a: Long): Boolean = {
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num <= 3) return true
      if (num % 2 == 0 || num % 3 == 0) return false
      var i = 5
      while (i * i <= num) {
        if (num % i == 0 || num % (i + 2) == 0) return false
        i += 6
      }
      true
    }

    val primes = (2L to 100L).filter(isPrime)
    val primeList = primes.toList

    for {
      i <- primeList.indices
      j <- i until primeList.size
      k <- j until primeList.size
      if primeList(i) * primeList(j) * primeList(k) == a
    } return true

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isMultiplyPrime((5l)) == (false));
    assert(isMultiplyPrime((30l)) == (true));
    assert(isMultiplyPrime((8l)) == (true));
    assert(isMultiplyPrime((10l)) == (false));
    assert(isMultiplyPrime((125l)) == (true));
    assert(isMultiplyPrime((105l)) == (true));
    assert(isMultiplyPrime((126l)) == (false));
    assert(isMultiplyPrime((729l)) == (false));
    assert(isMultiplyPrime((891l)) == (false));
    assert(isMultiplyPrime((1001l)) == (true));
    }

}
"
HumanEval_76,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //x എന്നത് n ന്റെ ഒരു ലളിതമായ പവറാണ്, n**int=x  ആണെങ്കിൽ    //n ന്റെ ശക്തിയും മറ്റു കേസുകളിൽ തെറ്റും.    //നിങ്ങളുടെ ജോലി ഒരു സംഖ്യ x ഒരു ലളിതമായ  ആണെങ്കിൽ true എന്ന് നൽകുന്ന ഒരു ഫങ്ഷൻ എഴുതുക എന്നതാണ്.    // >>> isSimplePower((1l), (4l))
    // (true)
    // >>> isSimplePower((2l), (2l))
    // (true)
    // >>> isSimplePower((8l), (2l))
    // (true)
    // >>> isSimplePower((3l), (2l))
    // (false)
    // >>> isSimplePower((3l), (1l))
    // (false)
    // >>> isSimplePower((5l), (3l))
    // (false)
    def isSimplePower(x : Long, n : Long) : Boolean = {
","def isSimplePower(x: Long, n: Long): Boolean = {
        if (n == 1) {
            return x == 1
        }
        
        var value: Long = n
        while (value <= x) {
            if (value == x) {
                return true
            }
            
            if (value > Long.MaxValue / n) {
                return false
            }
            value *= n
        }
        
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(isSimplePower((16l), (2l)) == (true));
    assert(isSimplePower((143214l), (16l)) == (false));
    assert(isSimplePower((4l), (2l)) == (true));
    assert(isSimplePower((9l), (3l)) == (true));
    assert(isSimplePower((16l), (4l)) == (true));
    assert(isSimplePower((24l), (2l)) == (false));
    assert(isSimplePower((128l), (4l)) == (false));
    assert(isSimplePower((12l), (6l)) == (false));
    assert(isSimplePower((1l), (1l)) == (true));
    assert(isSimplePower((1l), (12l)) == (true));
    }

}
"
HumanEval_77,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //കുറിപ്പ്: ഈ ഇൻപുട്ട് എല്ലായ്പ്പോഴും സാധുവാണെന്ന് കരുതാം.    //ഈ ഇംഗെർ ഏതെങ്കിലുമൊരു പൂർണ്ണസംഖ്യയുടെ ക്യൂബാണെങ്കിൽ.    //ഒരു പൂർണ്ണസംഖ്യ a എടുക്കുകയും true തിരികെ നൽകുകയും ചെയ്യുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.    // >>> iscube((1l))
    // (true)
    // >>> iscube((2l))
    // (false)
    // >>> iscube((-1l))
    // (true)
    // >>> iscube((64l))
    // (true)
    // >>> iscube((0l))
    // (true)
    // >>> iscube((180l))
    // (false)
    def iscube(a : Long) : Boolean = {
","def iscube(a: Long): Boolean = {
  val cubeRoot = math.cbrt(a.toDouble).round
  cubeRoot * cubeRoot * cubeRoot == a
}","    }
    def main(args: Array[String]) = {
    assert(iscube((1l)) == (true));
    assert(iscube((2l)) == (false));
    assert(iscube((-1l)) == (true));
    assert(iscube((64l)) == (true));
    assert(iscube((180l)) == (false));
    assert(iscube((1000l)) == (true));
    assert(iscube((0l)) == (true));
    assert(iscube((1729l)) == (false));
    }

}
"
HumanEval_78,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //A, B, C, D, E, F എന്നീ ചിഹ്നങ്ങള് എല്ലായ്പ്പോഴും വലിയ അക്ഷരങ്ങളായിരിക്കും.    //കുറിപ്പ്: നിങ്ങള് ക്ക് എല്ലായ്പ്പോഴും ശരിയായതോ ശൂന്യമോ ആണെന്ന് കരുതാം.    //ബി (= ദശാംശ 11), ഡി (= ദശാംശ 13).    //ഇനി പറയുന്ന അക്കങ്ങളുടെ എണ്ണം കണ്ടെത്തണം: 2, 3, 5, 7,     //പ്രൈം നമ്പറുകൾ 2, 3, 5, 7, 11, 13, 17,...  എന്നിവയാണ്.    //ഹെക്സാഡെസിമൽ അക്കങ്ങൾ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, എ, ബി, സി, ഡി, ഇ, എഫ് എന്നിവയാണ്.    //1 ന് മുകളിലുള്ളത്, അത് രണ്ട് ചെറിയ സംഖ്യകളുടെ ഗുണനമല്ല).    //പ്രൈം നമ്പറുകളായ അക്കങ്ങൾ (പ്രൈം നമ്പർ, അല്ലെങ്കിൽ ഒരു പ്രൈം, ഒരു സ്വാഭാവിക സംഖ്യയാണ്     //ഒരു ഹെക്സാഡെസിമൽ നമ്പർ ഒരു സ്ട്രിംഗായി എണ്ണുന്നു ഹെക്സാഡെസിമൽ നമ്പറുകളുടെ എണ്ണം     //നിങ്ങള് ക്ക് ഒരു ഫങ്ഷൻ എഴുതാന് നിര് ദ്ദേശമുണ്ട്.    // >>> hexKey((""AB""))
    // (1l)
    // >>> hexKey((""1077E""))
    // (2l)
    // >>> hexKey((""ABED1A33""))
    // (4l)
    // >>> hexKey((""123456789ABCDEF0""))
    // (6l)
    // >>> hexKey((""2020""))
    // (2l)
    def hexKey(num : String) : Long = {
","def hexKey(num: String): Long = {
  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')
  num.count(ch => primeHexDigits.contains(ch)).toLong
}","    }
    def main(args: Array[String]) = {
    assert(hexKey((""AB"")) == (1l));
    assert(hexKey((""1077E"")) == (2l));
    assert(hexKey((""ABED1A33"")) == (4l));
    assert(hexKey((""2020"")) == (2l));
    assert(hexKey((""123456789ABCDEF0"")) == (6l));
    assert(hexKey((""112233445566778899AABBCCDDEEFF00"")) == (12l));
    }

}
"
HumanEval_79,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഫോർമാറ്റിനെ സഹായിക്കുന്നതിനാണ് അധിക അക്ഷരങ്ങൾ.    //സ്ട്രിങ്ങിന്റെ തുടക്കത്തിലും അവസാനത്തിലും ഒരു കൂട്ടം 'db' പ്രതീകങ്ങൾ ഉണ്ടാകും.    //സ്ട്രിംഗിലെ ഓരോ പ്രതീകവും '0' അല്ലെങ്കിൽ '1' ആയിരിക്കും.    //ഫങ്ഷൻ ഒരു സ്ട്രിംഗ് നൽകണം, ഓരോ പ്രതീകവും ഒരു ബൈനറി     //നിങ്ങള് ക്ക് ഒരു സംഖ്യ ദശാംശ രൂപത്തില് ലഭിക്കും. നിങ്ങള് ക്ക് അതിനെ  ആയി പരിവര് ത്തനം ചെയ്യണം.    // >>> decimalToBinary((15l))
    // (""db1111db"")
    // >>> decimalToBinary((32l))
    // (""db100000db"")
    def decimalToBinary(decimal : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def decimalToBinary(decimal: Long): String = {
    ""db"" + decimal.toBinaryString + ""db""
  }
}","    }
    def main(args: Array[String]) = {
    assert(decimalToBinary((0l)).equals((""db0db"")));
    assert(decimalToBinary((32l)).equals((""db100000db"")));
    assert(decimalToBinary((103l)).equals((""db1100111db"")));
    assert(decimalToBinary((15l)).equals((""db1111db"")));
    }

}
"
HumanEval_80,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //ഒരു സ്ട്രിംഗ് ഹാപ്സ്കലാ ആണെങ്കിൽ അതിന്റെ നീളം കുറഞ്ഞത് 3 ആണെങ്കിൽ തുടർച്ചയായ 3 അക്ഷരങ്ങളും വ്യത്യസ്തമായിരിക്കും     //നിങ്ങളുടെ ജോലി സ്ട്രിംഗ് ഹാപ്സ്കല ആണോ അല്ലയോ എന്ന് പരിശോധിക്കുക എന്നതാണ്.    //നിങ്ങള് ക്ക് ഒരു സ്ട്രിംഗ് ലഭിക്കുന്നു.    // >>> isHappy((""a""))
    // (false)
    // >>> isHappy((""aa""))
    // (false)
    // >>> isHappy((""abcd""))
    // (true)
    // >>> isHappy((""aabb""))
    // (false)
    // >>> isHappy((""adb""))
    // (true)
    // >>> isHappy((""xyy""))
    // (false)
    def isHappy(s : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isHappy(s: String): Boolean = {
    if (s.length < 3) return false 

    for (i <- 0 until s.length - 2) {
      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {
        return false
      }
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isHappy((""a"")) == (false));
    assert(isHappy((""aa"")) == (false));
    assert(isHappy((""abcd"")) == (true));
    assert(isHappy((""aabb"")) == (false));
    assert(isHappy((""adb"")) == (true));
    assert(isHappy((""xyy"")) == (false));
    assert(isHappy((""iopaxpoi"")) == (true));
    assert(isHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //0.0 E യും    //> 0.0 ഡി -     //> 0.7 ഡി     //> 1.0 ഡി +     //> 1.3 C- യും    //> 1.7 C യും    //> 2.0 സി +     //> 2.3 ബി -     //> 2.7 ബി     //> 3.0 ബി +     //> 3.3 എ-     //> 3.7 എ     //4.0 എ+     //ജി.പി.എ. . . അക്ഷര ഗ്രേഡ്    //താഴെ പറയുന്ന പട്ടിക ഉപയോഗിച്ച് അക്ഷരങ്ങളുടെ ഗ്രേഡുകളുടെ ഒരു ലിസ്റ്റ് ഔട്ട്പുട്ട് ചെയ്യാൻ കഴിയുന്ന ഒരു ഫംഗ്ഷൻ:     //ചില വിദ്യാര് ഥികളുടെ ജി.പി.എ. പട്ടിക അവൾ തന്നു. നീ എഴുതണം.    //പക്ഷെ, അവൾക്ക് അവളുടെ കോഡ് നഷ്ടപ്പെട്ടു.    //അധ്യാപിക സ്വന്തം അൽഗോരിതം വികസിപ്പിച്ചെടുത്തിട്ടുണ്ട്.    //സെമസ്റ്ററിന്റെ അവസാന ആഴ്ചയാണ്, അധ്യാപകന് ഗ്രേഡുകള് നല് കണം.    // >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))
    // (List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))
    def numericalLetterGrade(grades : List[Float]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def numericalLetterGrade(grades: List[Float]): List[String] = {
    grades.map { gpa =>
      gpa match {
        case g if g == 4.0 => ""A+""
        case g if g > 3.7 => ""A""
        case g if g > 3.3 => ""A-""
        case g if g > 3.0 => ""B+""
        case g if g > 2.7 => ""B""
        case g if g > 2.3 => ""B-""
        case g if g > 2.0 => ""C+""
        case g if g > 1.7 => ""C""
        case g if g > 1.3 => ""C-""
        case g if g > 1.0 => ""D+""
        case g if g > 0.7 => ""D""
        case g if g > 0.0 => ""D-""
        case _ => ""E""
      }
    }
  }

  def main(args: Array[String]): Unit = {
    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)
    println(numericalLetterGrade(grades)) // Output: List(A+, B, C-, C, A-)
  }
}","    }
    def main(args: Array[String]) = {
    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))));
    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](""D+""))));
    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](""D-""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](""E""))));
    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](""D"", ""D-"", ""C-"", ""B"", ""B+""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](""E"", ""D-""))));
    }

}
"
HumanEval_82,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //നീളം ഒരു പ്രൈം നമ്പറാണോ അതോ തെറ്റാണോ?    //ഒരു സ്ട്രിംഗ് എടുത്ത്  സ്ട്രിംഗ്  ആണെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.    // >>> primeLength((""Hello""))
    // (true)
    // >>> primeLength((""abcdcba""))
    // (true)
    // >>> primeLength((""kittens""))
    // (true)
    // >>> primeLength((""orange""))
    // (false)
    def primeLength(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeLength(string: String): Boolean = {
    val length = string.length

    if (length <= 1) return false
    
    for (i <- 2 to sqrt(length).toInt) {
      if (length % i == 0) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeLength((""Hello"")) == (true));
    assert(primeLength((""abcdcba"")) == (true));
    assert(primeLength((""kittens"")) == (true));
    assert(primeLength((""orange"")) == (false));
    assert(primeLength((""wow"")) == (true));
    assert(primeLength((""world"")) == (true));
    assert(primeLength((""MadaM"")) == (true));
    assert(primeLength((""Wow"")) == (true));
    assert(primeLength(("""")) == (false));
    assert(primeLength((""HI"")) == (true));
    assert(primeLength((""go"")) == (true));
    assert(primeLength((""gogo"")) == (false));
    assert(primeLength((""aaaaaaaaaaaaaaa"")) == (false));
    assert(primeLength((""Madam"")) == (true));
    assert(primeLength((""M"")) == (false));
    assert(primeLength((""0"")) == (false));
    }

}
"
HumanEval_83,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //പോസിറ്റീവ് സംഖ്യകളാണ് 1 കൊണ്ട് തുടങ്ങുന്നതും അവസാനിക്കുന്നതും.    //ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n ഉണ്ടെങ്കിൽ, n-അക്ക സംഖ്യകളുടെ എണ്ണം തിരികെ നൽകുക     def startsOneEnds(n : Long) : Long = {
","def startsOneEnds(n: Long): Long = {
        if (n <= 0) return 0
        
        // Calculate numbers starting with 1: 1XX...X (n-1) digits after 1
        val startWithOne: Long = math.pow(10, n - 1).toLong
        
        // Calculate numbers ending with 1: XX...X1 (n-1) digits before 1
        // but without leading zeroes allowed, i.e., the first digit can't be zero
        val endWithOne: Long = math.pow(10, n - 1).toLong
        
        // Reverse counting: numbers starting and ending with 1 (11XX...X)
        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0
        
        // The total numbers starting or ending, or both, with 1
        startWithOne + endWithOne - bothStartAndEndWithOne
    }
}","    }
    def main(args: Array[String]) = {
    assert(startsOneEnds((1l)) == (1l));
    assert(startsOneEnds((2l)) == (18l));
    assert(startsOneEnds((3l)) == (180l));
    assert(startsOneEnds((4l)) == (1800l));
    assert(startsOneEnds((5l)) == (18000l));
    }

}
"
HumanEval_84,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം     //ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ N നൽകിയിട്ടുണ്ടെങ്കിൽ, അതിന്റെ അക്കങ്ങളുടെ ആകെത്തുക ബൈനറിയിൽ നൽകുക.     // >>> solve((1000l))
    // (""1"")
    // >>> solve((150l))
    // (""110"")
    // >>> solve((147l))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    def solve(N : Long) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Given a positive integer N, return the total sum of its digits in binary.
    def solve(N: Long): String = {
        val sumOfDigits = N.toString.map(_.asDigit).sum
        sumOfDigits.toBinaryString
    }

    def main(args: Array[String]): Unit = {
        println(solve(1000L))  // should print ""1""
        println(solve(150L))   // should print ""110""
        println(solve(147L))   // should print ""1100""
    }
}","    }
    def main(args: Array[String]) = {
    assert(solve((1000l)).equals((""1"")));
    assert(solve((150l)).equals((""110"")));
    assert(solve((147l)).equals((""1100"")));
    assert(solve((333l)).equals((""1001"")));
    assert(solve((963l)).equals((""10010"")));
    }

}
"
HumanEval_85,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //പൂര് ണ്ണസംഖ്യകളുടെ ഒരു പട്ടിക നല് കിയിരിക്കുകയാണെങ്കില് ആദ്യം, അസംഖ്യം സൂചികകളിലുള്ള ഇരട്ടസംഖ്യകളെ കൂട്ടിച്ചേര് ക്കുക.    // >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))
    // (2l)
    def add(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a non-empty list of integers lst. add the even elements that are at odd indices.
  def add(lst: List[Long]): Long = {
    lst.zipWithIndex.collect {
      case (value, index) if index % 2 == 1 && value % 2 == 0 => value
    }.sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));
    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));
    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));
    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));
    }

}
"
HumanEval_86,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //കുറിപ്പ്: വാക്യത്തിലെ വാക്കുകളുടെയും ശൂന്യസ്ഥലങ്ങളുടെയും ക്രമം പാലിക്കണം.    //ASCII മൂല്യം അടിസ്ഥാനമാക്കിയുള്ള വർധന ക്രമം.    //യില് ക്രമീകരിച്ചിരിക്കുന്ന എല്ലാ പ്രതീകങ്ങളും അടങ്ങുന്ന പുതിയ വാക്കാണ് പകരം വയ്ക്കുന്നത്.    //സ്ട്രിങ്ങിന്റെ ക്രമപ്പെടുത്തിയ പതിപ്പ്, എല്ലാ വാക്കുകളും (സ്പേസ് ഉപയോഗിച്ച് വേർതിരിച്ച്)     //ഒരു സ്ട്രിംഗ് എടുത്ത് അതിന്റെ ക്രമീകരിച്ച പതിപ്പ് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.    // >>> antiShuffle((""Hi""))
    // (""Hi"")
    // >>> antiShuffle((""hello""))
    // (""ehllo"")
    // >>> antiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    def antiShuffle(s : String) : String = {
","import scala.collection.mutable.ArrayBuffer

object Problem {
  def antiShuffle(s: String): String = {
    val words = s.split(""(?<=\\s)"")
    val sortedWords = words.map(word => {
      val trimmedWord = word.trim
      val sortedChars = trimmedWord.sorted
      word.replace(trimmedWord, sortedChars)
    })
    sortedWords.mkString("""")
  }

  def main(args: Array[String]): Unit = {
    println(antiShuffle(""Hi""))
    println(antiShuffle(""hello""))
    println(antiShuffle(""Hello World!!!""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(antiShuffle((""Hi"")).equals((""Hi"")));
    assert(antiShuffle((""hello"")).equals((""ehllo"")));
    assert(antiShuffle((""number"")).equals((""bemnru"")));
    assert(antiShuffle((""abcd"")).equals((""abcd"")));
    assert(antiShuffle((""Hello World!!!"")).equals((""Hello !!!Wdlor"")));
    assert(antiShuffle(("""")).equals(("""")));
    assert(antiShuffle((""Hi. My name is Mister Robot. How are you?"")).equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //കൂടാതെ, നിരയുടെ കോർഡിനേറ്റുകളെ നിരകളുടെ ക്രമത്തിൽ ക്രമീകരിക്കുക.    //കോർഡിനേറ്റുകളെ ആദ്യം കയറിവരുന്ന ക്രമത്തിൽ വരികളായി അടുക്കുക.    //ഓരോ ട്യൂപ്പലും ഒരു കോർഡിനേറ്റ് ആണ് - (വരി, നിരകൾ), 0 മുതൽ തുടങ്ങുന്നു.    //                                             //lst, x എന്ന സംഖ്യകൾ തന്നാൽ, പട്ടികയിലെ x എന്ന സംഖ്യ കണ്ടെത്തുക,     //ഓരോ വരിയിലും വ്യത്യസ്ത എണ്ണം നിരകളുണ്ടാകാം.    //മാട്രിക്സിനു സമാനമായ, മാട്രിക്സുകൾക്ക് വിപരീതമായി,    //നിങ്ങള് ക്ക് ഒരു 2 ഡി ഡാറ്റ നല് കിയിട്ടുണ്ട്, ഒരു കൂട്ടിയിണക്കിയ ലിസ്റ്റായി,    // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))
    // (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))
    // >>> getRow((List[List[Long]]()), (1l))
    // (List[Tuple2[Long, Long]]())
    // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))
    // (List[Tuple2[Long, Long]]((2l, 2l)))
    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {
    val coordinates = for {
      (row, rowIndex) <- lst.zipWithIndex
      (value, colIndex) <- row.zipWithIndex
      if value == x
    } yield (rowIndex.toLong, colIndex.toLong)

    coordinates
      .groupBy(_._1)
      .toList
      .sortBy(_._1)
      .flatMap { case (rowIndex, coords) =>
        coords.sortBy(-_._2)
      }
  }
}","    }
    def main(args: Array[String]) = {
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));
    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));
    }

}
"
HumanEval_88,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //* തന്നിരിക്കുന്ന ലിസ്റ്റ് മാറ്റരുത്.    //കുറിപ്പ്:    //അല്ലെങ്കിൽ, സംഖ്യ ((ആദ്യ സൂചിക മൂല്യം, അവസാന സൂചിക മൂല്യം) ഇരട്ടയാണെങ്കിൽ, അത് താഴേയ്ക്ക് ക്രമീകരിക്കുക.    //നിങ്ങള് ലിസ്റ്റ് ക്രമീകരിക്കും. ആദ്യം സൂചിക മൂല്യം, അവസാന സൂചിക മൂല്യം)    //നെഗറ്റീവ് അല്ലാത്ത സംഖ്യകളുടെ പട്ടിക കൊടുത്താൽ, ക്രമീകരണത്തിനു ശേഷം നൽകിയ പട്ടികയുടെ കോസ്കല മടക്കി നൽകുക,    // >>> sortArray((List[Long]()))
    // (List[Long]())
    // >>> sortArray((List[Long](5l.toLong)))
    // (List[Long](5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))
    def sortArray(array : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def sortArray(array: List[Long]): List[Long] = {
    if (array.isEmpty) {
      array
    } else {
      val first = array.head
      val last = array.last
      val sum = first + last
      if (sum % 2 == 0) {
        array.sorted(Ordering[Long].reverse)
      } else {
        array.sorted
      }
    }
  }

  def main(args: Array[String]): Unit = {
    println(sortArray(List[Long]())) // (List[Long]())
    println(sortArray(List[Long](5L))) // (List[Long](5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) // (List[Long](0L, 1L, 2L, 3L, 4L, 5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) // (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));
    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));
    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));
    }

}
"
HumanEval_89,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //രണ്ട് സ്ഥലത്ത് നിന്ന് താഴേക്ക് മാറുക.    //അക്ഷരമാലയില് അക്ഷരങ്ങള്     //അക്ഷരമാല തിരിക്കുമ്പോള് ഒരു എൻക്രിപ്റ്റ് ചെയ്ത സ്ട്രിംഗ് തിരിച്ചുനല്കുന്നു.    //ഒരു സ്ട്രിംഗ് ഒരു ആർഗ്യുമെന്റായി എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ എൻക്രിപ്റ്റ് സൃഷ്ടിക്കുക,     // >>> encrypt((""hi""))
    // (""lm"")
    // >>> encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> encrypt((""gf""))
    // (""kj"")
    // >>> encrypt((""et""))
    // (""ix"")
    def encrypt(s : String) : String = {
","def encrypt(s: String): String = {
  s.map(c => {
    val rotatedChar = (c - 'a' + 4) % 26 + 'a'
    rotatedChar.toChar
  })
}","    }
    def main(args: Array[String]) = {
    assert(encrypt((""hi"")).equals((""lm"")));
    assert(encrypt((""asdfghjkl"")).equals((""ewhjklnop"")));
    assert(encrypt((""gf"")).equals((""kj"")));
    assert(encrypt((""et"")).equals((""ix"")));
    assert(encrypt((""faewfawefaewg"")).equals((""jeiajeaijeiak"")));
    assert(encrypt((""hellomyfriend"")).equals((""lippsqcjvmirh"")));
    assert(encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    assert(encrypt((""a"")).equals((""e"")));
    }

}
"
HumanEval_90,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //അത്തരം ഒരു ഘടകം ഇല്ലെങ്കിൽ None തിരികെ നൽകുക.    //ലിസ്റ്റിലെ രണ്ടാമത്തെ ചെറിയ എലമെന്റ് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ next_smallest ().    //നിങ്ങള് ക്ക് ഒരു സംഖ്യകളുടെ പട്ടിക കിട്ടും.    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long]()))
    // None
    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))
    // None
    def nextSmallest(lst : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def nextSmallest(lst: List[Long]): Option[Long] = {
    if (lst.size < 2) return None

    val distinctSorted = lst.distinct.sorted
    if (distinctSorted.size < 2) None
    else Some(distinctSorted(1))
  }
}","    }
    def main(args: Array[String]) = {
    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long]())).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));
    }

}
"
HumanEval_91,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //വാക്യങ്ങള് ക്ക് '', '?' അഥവാ '!' എന്നീ അക്ഷരങ്ങള് ഉപയോഗിച്ച് പരിധിയുണ്ടാക്കും.    //""I"" എന്ന വാക്കിൽ തുടങ്ങുന്ന ഒരു വാക്യമാണ് ബോറടിക്കൽ.    //നിങ്ങള് ക്ക് ഒരു വാക്ക് കിട്ടും, നിങ്ങളുടെ ജോലി അത് എണ്ണുക എന്നതാണ്.    // >>> isBored((""Hello world""))
    // (0l)
    // >>> isBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1l)
    def isBored(S : String) : Long = {
","def isBored(S: String): Long = {
    // Split the input string into sentences using '.', '?' or '!' as delimiters
    val sentences = S.split(""[.!?]"").map(_.trim)

    // Filter sentences that start with 'I' and count them
    sentences.count(sentence => sentence.startsWith(""I""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(isBored((""Hello world"")) == (0l));
    assert(isBored((""Is the sky blue?"")) == (0l));
    assert(isBored((""I love It !"")) == (1l));
    assert(isBored((""bIt"")) == (0l));
    assert(isBored((""I feel good today. I will be productive. will kill It"")) == (2l));
    assert(isBored((""You and I are going for a walk"")) == (0l));
    }

}
"
HumanEval_92,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //എല്ലാ കേസുകളിലും തെറ്റാണ്.    //ഒരു സംഖ്യ മറ്റു രണ്ടിന്റെയും ആകെത്തുകയ്ക്ക് തുല്യമാണെങ്കിൽ, എല്ലാ സംഖ്യകളും പൂർണ്ണസംഖ്യകളാണെങ്കിൽ, ഇത് ശരിയായി നൽകുന്നു.    //3 സംഖ്യകൾ എടുക്കുന്ന ഒരു ഫങ്ഷൻ ഉണ്ടാക്കുക.    // >>> anyInt(5l, 2l, 7l)
    // (true)
    // >>> anyInt(3l, 2l, 2l)
    // (false)
    // >>> anyInt(3l, -2l, 1l)
    // (true)
    // >>> anyInt((3.6f), (-2.2f), 2l)
    // (false)
    def anyInt(x : Float, y : Float, z : Float) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Create a function that takes 3 numbers.
  // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
  // Returns false in any other cases.
  def anyInt(x: Float, y: Float, z: Float): Boolean = {
    val xLong = x.toLong
    val yLong = y.toLong
    val zLong = z.toLong

    // Check if all inputs are actually integers
    if (xLong == x && yLong == y && zLong == z) {
      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong
    }
    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(anyInt(2l, 3l, 1l) == (true));
    assert(anyInt((2.5f), 2l, 3l) == (false));
    assert(anyInt((1.5f), 5l, (3.5f)) == (false));
    assert(anyInt(2l, 6l, 2l) == (false));
    assert(anyInt(4l, 2l, 2l) == (true));
    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));
    assert(anyInt(-4l, 6l, 2l) == (true));
    assert(anyInt(2l, 1l, 1l) == (true));
    assert(anyInt(3l, 4l, 7l) == (true));
    assert(anyInt((3.0f), 4l, 7l) == (false));
    }

}
"
HumanEval_93,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //അക്ഷരങ്ങള് മാത്രം കരുതുക.    //ഇംഗ്ലീഷ് അക്ഷരമാലയിലെ സ്വരാക്ഷരം.    //ആ സന്ദേശത്തിന് മുന്നില് രണ്ടു സ്ഥാനങ്ങളില് വരുന്ന അക്ഷരം ഉപയോഗിച്ച്.    //എല്ലാ അക്ഷരങ്ങളും മാറ്റി,  യിലെ എല്ലാ സ്വരാക്ഷരങ്ങളും മാറ്റി.    //ഒരു സന്ദേശം എടുത്ത്,  എന്ന രീതിയിൽ എൻകോഡ് ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.    // >>> encode((""test""))
    // (""TGST"")
    // >>> encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    def encode(message : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def encode(message: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    val vowelMap = Map(
      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',
      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'
    )
    
    message.map { char =>
      if (vowels.contains(char)) {
        vowelMap(char)
      } else if (char.isLetter) {
        if (char.isLower) char.toUpper else char.toLower
      } else {
        char
      }
    }.mkString
  }

  // Test cases
  def main(args: Array[String]): Unit = {
    println(encode(""test""))            // should print ""TGST""
    println(encode(""This is a message"")) // should print ""tHKS KS C MGSSCGG""
  }
}","    }
    def main(args: Array[String]) = {
    assert(encode((""TEST"")).equals((""tgst"")));
    assert(encode((""Mudasir"")).equals((""mWDCSKR"")));
    assert(encode((""YES"")).equals((""ygs"")));
    assert(encode((""This is a message"")).equals((""tHKS KS C MGSSCGG"")));
    assert(encode((""I DoNt KnOw WhAt tO WrItE"")).equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഏറ്റവും വലിയ പ്രൈം മൂല്യം കണ്ടെത്തി അതിന്റെ അക്കങ്ങളുടെ സംഖ്യ തിരികെ നൽകണം.    //നിങ്ങള് ക്ക് ഒരു സംഖ്യകളുടെ പട്ടിക കിട്ടും.    // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))
    // (10l)
    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))
    // (25l)
    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))
    // (13l)
    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))
    // (11l)
    // >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))
    // (3l)
    // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))
    // (7l)
    def skjkasdkd(lst : List[Long]) : Long = {
","def skjkasdkd(lst: List[Long]): Long = {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) false
    else if (n == 2) true
    else if (n % 2 == 0) false
    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)
  }

  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum

  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)
  sumOfDigits(largestPrime)
}","    }
    def main(args: Array[String]) = {
    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));
    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));
    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));
    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));
    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));
    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));
    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));
    }

}
"
HumanEval_95,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഫങ്ഷൻ false നൽകണം, കാരണം ഈ മാപ്പ് ശൂന്യമാണ്.    //എല്ലാ കീകളും വലിയക്ഷരങ്ങളുള്ള സ്ട്രിങ്ങുകളാണെങ്കിൽ, അല്ലെങ്കിൽ false നൽകുക.    //ഒരു മാപ്പ് കൊടുത്താൽ, എല്ലാ കീകളും താഴത്തെ യിലെ സ്ട്രിങ്ങുകളാണെങ്കിൽ true തിരികെ നൽകുക.    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""b"" -> ""banana"")))
    // (true)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""A"" -> ""banana"", ""B"" -> ""banana"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", 8l -> ""banana"", ""a"" -> ""apple"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345"")))
    // (true)
    def checkDictCase(dict : Map[String,String]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def checkDictCase(dict: Map[String, String]): Boolean = {
    if (dict.isEmpty) return false

    val keys = dict.keys.toList
    val allLowerCase = keys.forall(key => key == key.toLowerCase)
    val allUpperCase = keys.forall(key => key == key.toUpperCase)

    allLowerCase || allUpperCase
  }
}","    }
    def main(args: Array[String]) = {
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""b"" -> ""banana""))) == (true));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""A"" -> ""banana"", ""B"" -> ""banana""))) == (false));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""5"" -> ""banana"", ""a"" -> ""apple""))) == (false));
    assert(checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston""))) == (false));
    assert(checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345""))) == (true));
    assert(checkDictCase((Map[String,String](""fruit"" -> ""Orange"", ""taste"" -> ""Sweet""))) == (true));
    assert(checkDictCase((Map[String,String]())) == (false));
    }

}
"
HumanEval_96,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //യും n യും കുറവുള്ള അസംഖ്യകളാണ്.    //ഒരു നോൺ-നെഗറ്റീവ് ഇന്റീജർ എടുക്കുകയും ആദ്യത്തെ n ന്റെ ഒരു ലിസ്റ്റ് നൽകുകയും ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ നടപ്പിലാക്കുക.    // >>> countUpTo((5l))
    // (List[Long](2l.toLong, 3l.toLong))
    // >>> countUpTo((11l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))
    // >>> countUpTo((0l))
    // (List[Long]())
    // >>> countUpTo((20l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))
    // >>> countUpTo((1l))
    // (List[Long]())
    // >>> countUpTo((18l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))
    def countUpTo(n : Long) : List[Long] = {
","def countUpTo(n: Long): List[Long] = {
    def isPrime(num: Long): Boolean = {
      if (num < 2) return false
      for (i <- 2L to math.sqrt(num).toLong) {
        if (num % i == 0) return false
      }
      true
    }

    (2L until n).filter(isPrime).map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));
    assert(countUpTo((0l)).equals((List[Long]())));
    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));
    assert(countUpTo((1l)).equals((List[Long]())));
    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));
    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));
    }

}
"
HumanEval_97,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഇൻപുട്ട് എല്ലായ്പ്പോഴും സാധുവാണെന്ന് കരുതുക.    //അവരുടെ യൂണിറ്റ് അക്കങ്ങളുടെ ഗുണനം.    //രണ്ട് പൂർണ്ണസംഖ്യകളെ എടുക്കുന്ന ഫങ്ഷൻ പൂര് ത്തിയാക്കുകയും     // >>> multiply((148l), (412l))
    // (16l)
    // >>> multiply((19l), (28l))
    // (72l)
    // >>> multiply((2020l), (1851l))
    // (0l)
    // >>> multiply((14l), (-15l))
    // (20l)
    def multiply(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def multiply(a: Long, b: Long): Long = {
        val unitDigitA = abs(a % 10)
        val unitDigitB = abs(b % 10)
        unitDigitA * unitDigitB
    }

    def main(args: Array[String]): Unit = {
        println(multiply(148l, 412l))  // 16l
        println(multiply(19l, 28l))    // 72l
        println(multiply(2020l, 1851l)) // 0l
        println(multiply(14l, -15l))   // 20l
    }
}","    }
    def main(args: Array[String]) = {
    assert(multiply((148l), (412l)) == (16l));
    assert(multiply((19l), (28l)) == (72l));
    assert(multiply((2020l), (1851l)) == (0l));
    assert(multiply((14l), (-15l)) == (20l));
    assert(multiply((76l), (67l)) == (42l));
    assert(multiply((17l), (27l)) == (49l));
    assert(multiply((0l), (1l)) == (0l));
    assert(multiply((0l), (0l)) == (0l));
    }

}
"
HumanEval_98,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //ഒരു സ്ട്രിംഗ് s കൊടുത്താൽ, വലിയ അക്ഷരങ്ങളിലുള്ള വോക്കലുകളുടെ എണ്ണം കണക്കുകൂട്ടുക.    // >>> countUpper((""aBCdEf""))
    // (1l)
    // >>> countUpper((""abcdefg""))
    // (0l)
    // >>> countUpper((""dBBE""))
    // (0l)
    def countUpper(s : String) : Long = {
","def countUpper(s: String): Long = {
  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')
  s.zipWithIndex.collect {
    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch
  }.size.toLong
}","    }
    def main(args: Array[String]) = {
    assert(countUpper((""aBCdEf"")) == (1l));
    assert(countUpper((""abcdefg"")) == (0l));
    assert(countUpper((""dBBE"")) == (0l));
    assert(countUpper((""B"")) == (0l));
    assert(countUpper((""U"")) == (1l));
    assert(countUpper(("""")) == (0l));
    assert(countUpper((""EEEE"")) == (2l));
    }

}
"
HumanEval_99,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //രണ്ട് പൂർണ്ണസംഖ്യകളിൽ നിന്നും, അത് പൂജ്യത്തിൽ നിന്നും കുറയ്ക്കുക.    //യും അതിന് ഏറ്റവും അടുത്തുള്ള പൂർണ്ണസംഖ്യയും തിരികെ നൽകുന്നു.    //ഒരു സംഖ്യയെ പ്രതിനിധീകരിക്കുന്ന ഒരു മൂല്യം (സ്ട്രിംഗ്) എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക     // >>> closestInteger((""10""))
    // (10l)
    // >>> closestInteger((""15.3""))
    // (15l)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    def closestInteger(value : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def closestInteger(value: String): Long = {
    val num = value.toDouble
    val lower = floor(num).toLong
    val upper = ceil(num).toLong
    
    if (abs(num - lower) == abs(num - upper)) {
      if (num > 0) upper else lower
    } else {
      round(num)
    }
  }

  def main(args: Array[String]): Unit = {
    println(closestInteger(""10""))  // 10
    println(closestInteger(""15.3"")) // 15
    println(closestInteger(""14.5"")) // 15
    println(closestInteger(""-14.5"")) // -15
  }
}","    }
    def main(args: Array[String]) = {
    assert(closestInteger((""10"")) == (10l));
    assert(closestInteger((""14.5"")) == (15l));
    assert(closestInteger((""-15.5"")) == (-16l));
    assert(closestInteger((""15.3"")) == (15l));
    assert(closestInteger((""0"")) == (0l));
    }

}
"
HumanEval_100,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //i എന്നത് നിലയിലെ കല്ലുകളുടെ എണ്ണം (i+1) ആണ്.    //ഒരു ലിസ്റ്റിലെ ഓരോ ലെവലിലും ഉള്ള കല്ലുകളുടെ എണ്ണം തിരികെ നൽകുന്നു, അവിടെ ഘടകം സൂചികയിൽ     //- അടുത്ത ഇരട്ട സംഖ്യ n ഇരട്ട ആണെങ്കിൽ.    //- അടുത്ത ഇരട്ട സംഖ്യ n ഇരട്ട ആണെങ്കിൽ.    //അടുത്ത ലെവലിലെ കല്ലുകളുടെ എണ്ണം:     //ആദ്യ നിലയില് n കല്ലുകളുണ്ട്.    //ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n ഉണ്ടെങ്കിൽ, നിങ്ങൾ n ലെവൽ കല്ലുകൾ ഒരു കൂമ്പാരം ഉണ്ടാക്കണം.    // >>> makeAPile((3l))
    // (List[Long](3l.toLong, 5l.toLong, 7l.toLong))
    def makeAPile(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
    def makeAPile(n: Long): List[Long] = {
        val pile = ListBuffer[Long]()
        var currentStones = n
        for (_ <- 0 until n.toInt) {
            pile += currentStones
            currentStones += (if (currentStones % 2 == 0) 2 else 2)
        }
        pile.toList
    }

    def main(args: Array[String]): Unit = {
        val result = makeAPile(3L)
        println(result)
    }
}","    }
    def main(args: Array[String]) = {
    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));
    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));
    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));
    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));
    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));
    }

}
"
HumanEval_101,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //സ്ട്രിങ് വാക്കുകളായി വിഭജിച്ച് വാക്കുകളുടെ ഒരു ലിസ്റ്റ് തിരികെ നൽകുക.    //നിങ്ങള് ക്ക് കോമകളോ സ്പെയ്സുകളോ ഉപയോഗിച്ച് വേര് തിരിക്കപ്പെട്ട വാക്കുകള് നല് കും.    // >>> wordsString((""Hi, my name is John""))
    // (List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))
    // >>> wordsString((""One, two, three, four, five, six""))
    // (List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))
    def wordsString(s : String) : List[String] = {
","def wordsString(s: String): List[String] = {
    s.split(""[, ]+"").toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(wordsString((""Hi, my name is John"")).equals((List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))));
    assert(wordsString((""One, two, three, four, five, six"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString((""Hi, my name"")).equals((List[String](""Hi"", ""my"", ""name""))));
    assert(wordsString((""One,, two, three, four, five, six,"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString(("""")).equals((List[String]())));
    assert(wordsString((""ahmed     , gamal"")).equals((List[String](""ahmed"", ""gamal""))));
    }

}
"
HumanEval_102,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //അത്തരമൊരു സംഖ്യ ഇല്ല, അപ്പോൾ ഫംഗ്ഷൻ -1 തിരികെ നൽകണം.    //[x, y] പരിധിയിലുള്ള ഏറ്റവും വലിയ സമസംഖ്യ.    //ഈ ഫങ്ഷൻ രണ്ട് പോസിറ്റീവ് നമ്പറുകളായ x, y എന്നിവ എടുക്കുകയും  എന്ന ഫലം നൽകുകയും ചെയ്യുന്നു.    // >>> chooseNum((12l), (15l))
    // (14l)
    // >>> chooseNum((13l), (12l))
    // (-1l)
    def chooseNum(x : Long, y : Long) : Long = {
","def chooseNum(x: Long, y: Long): Long = {
    // Ensure x is the lesser value and y is the greater value
    val (start, end) = if (x > y) (y, x) else (x, y)
    
    // Start from the end of the range and search backwards for an even number
    for (i <- end to start by -1 if i % 2 == 0) {
      return i
    }
    
    // If no even number is found, return -1
    -1
  }
}","    }
    def main(args: Array[String]) = {
    assert(chooseNum((12l), (15l)) == (14l));
    assert(chooseNum((13l), (12l)) == (-1l));
    assert(chooseNum((33l), (12354l)) == (12354l));
    assert(chooseNum((5234l), (5233l)) == (-1l));
    assert(chooseNum((6l), (29l)) == (28l));
    assert(chooseNum((27l), (10l)) == (-1l));
    assert(chooseNum((7l), (7l)) == (-1l));
    assert(chooseNum((546l), (546l)) == (546l));
    }

}
"
HumanEval_103,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //n m നേക്കാൾ വലുതാണെങ്കിൽ, -1 തിരികെ നൽകുക.    //ഉത്തരം അടുത്തുള്ള പൂർണ്ണസംഖ്യയിലേക്ക് ചുരുക്കുക, അതിനെ ബൈനറി ആയി പരിവർത്തനം ചെയ്യുക.    //n മുതൽ m വരെയുള്ള (n ഉം m ഉം ഉൾപ്പെടെ) മുഴുവൻ സംഖ്യകളുടെ ശരാശരി.    //നിങ്ങള് ക്ക് രണ്ട് പോസിറ്റീവ് ഇന്റര് നമ്പറുകള് n ഉം m ഉം നല് കിയിട്ടുണ്ട്, നിങ്ങളുടെ ജോലി     // >>> roundedAvg((1l), (5l))
    // ""0b11""
    // >>> roundedAvg((7l), (5l))
    // -1l
    // >>> roundedAvg((10l), (20l))
    // ""0b1111""
    // >>> roundedAvg((20l), (33l))
    // ""0b11010""
    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  // Function to compute the average of the integers from n through m
  def roundedAvg(n: Long, m: Long): Either[String, Long] = {
    if (n > m) {
      Right(-1L)
    } else {
      val count = m - n + 1
      val sum = (n + m) * count / 2
      val average = round(sum.toDouble / count)
      Left(""0b"" + average.toLong.toBinaryString)
    }
  }

  def main(args: Array[String]): Unit = {
    println(roundedAvg(1L, 5L))    // Left(""0b11"")
    println(roundedAvg(7L, 5L))    // Right(-1L)
    println(roundedAvg(10L, 20L))  // Left(""0b1111"")
    println(roundedAvg(20L, 33L))  // Left(""0b11010"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(roundedAvg((1l), (5l)).equals(""0b11""));
    assert(roundedAvg((7l), (13l)).equals(""0b1010""));
    assert(roundedAvg((964l), (977l)).equals(""0b1111001010""));
    assert(roundedAvg((996l), (997l)).equals(""0b1111100100""));
    assert(roundedAvg((560l), (851l)).equals(""0b1011000010""));
    assert(roundedAvg((185l), (546l)).equals(""0b101101110""));
    assert(roundedAvg((362l), (496l)).equals(""0b110101101""));
    assert(roundedAvg((350l), (902l)).equals(""0b1001110010""));
    assert(roundedAvg((197l), (233l)).equals(""0b11010111""));
    assert(roundedAvg((7l), (5l)).equals(-1l));
    assert(roundedAvg((5l), (1l)).equals(-1l));
    assert(roundedAvg((5l), (5l)).equals(""0b101""));
    }

}
"
HumanEval_104,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //കുറിപ്പ്: തിരിച്ചുവിട്ട പട്ടിക വർധിച്ചുവരുന്ന ക്രമത്തിൽ ക്രമീകരിക്കണം.    //ഇരട്ട അക്കങ്ങളൊന്നും ഇല്ലാത്ത മൂലകങ്ങൾ.    //പോസിറ്റീവ് ഇന്റഗ്രൽ നമ്പറുകളുടെ ഒരു ലിസ്റ്റ് x. നൽകിയിരിക്കുകയാണ്. എല്ലാ  ന്റെയും ഒരു പട്ടിക തിരികെ നൽകുക.    // >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))
    // (List[Long](1l.toLong, 15l.toLong, 33l.toLong))
    // >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))
    // (List[Long]())
    def uniqueDigits(x : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def uniqueDigits(x: List[Long]): List[Long] = {
    def hasEvenDigit(n: Long): Boolean = {
      n.toString.exists(c => (c - '0') % 2 == 0)
    }

    x.filterNot(hasEvenDigit).sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))
    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));
    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));
    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));
    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));
    }

}
"
HumanEval_105,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //ഒന്ന്, രണ്ട്, മൂന്ന്, നാല്, അഞ്ച്, ആറ്, ഏഴ്, എട്ട്, ഒമ്പത്.    //ഫലമായി ലഭിക്കുന്ന പട്ടിക തിരിച്ച് വയ്ക്കുക, എന്നിട്ട് ഓരോ അക്കവും                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  //ഒരു സംഖ്യകളുടെ പട്ടിക കൊടുത്താൽ, 1 മുതൽ 9 വരെയുള്ള സംഖ്യകളെ അടുക്കുക,     // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))
    // (List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))
    // If the list is empty, return an empty list:
    // >>> byLength((List[Long]()))
    // (List[String]())
    // If the list has any strange number ignore it:
    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))
    // (List[String](""One""))
    def byLength(arr : List[Long]) : List[String] = {
","import scala.collection.mutable._

object Problem {
  def byLength(arr: List[Long]): List[String] = {
    // Map of digit to its corresponding name
    val numToName = Map(
      1L -> ""One"",
      2L -> ""Two"",
      3L -> ""Three"",
      4L -> ""Four"",
      5L -> ""Five"",
      6L -> ""Six"",
      7L -> ""Seven"",
      8L -> ""Eight"",
      9L -> ""Nine""
    )

    // Filter numbers between 1 and 9
    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)
    // Map filtered and sorted numbers to their corresponding names
    filteredAndSorted.map(numToName)
  }
}","    }
    def main(args: Array[String]) = {
    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))));
    assert(byLength((List[Long]())).equals((List[String]())));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](""One""))));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](""Three"", ""Two"", ""One""))));
    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](""Nine"", ""Eight"", ""Four""))));
    }

}
"
HumanEval_106,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //i യുടെ ഫാക്ടോറിയൽ 1 മുതൽ i വരെയുള്ള സംഖ്യകളുടെ ഗുണനമാണ് (1 * 2 * . . . * i).    //ഞാന് 1 മുതല് തുടങ്ങുന്നു.    //അല്ലെങ്കിൽ 1 മുതൽ i വരെയുള്ള സംഖ്യകളുടെ ആകെത്തുക.    //പിന്നെ, ഒരു വലിപ്പം n ഉള്ള ഒരു ലിസ്റ്റ് തിരിച്ചു തരും, അങ്ങനെ i എന്ന മൂലകത്തിന്റെ മൂല്യം i ന്റെ ഫാക്ടോറിയൽ ആയിരിക്കും, i ഇരട്ട ആണെങ്കിൽ     //n നെ പരാമീറ്ററായി എടുക്കുന്ന f ഫംഗ്ഷൻ നടപ്പിലാക്കുക,     // >>> f((5l))
    // (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))
    def f(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def f(n: Long): List[Long] = {
        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)
        
        (1L to n).map { i =>
            if (i % 2 == 0) factorial(i) else (1L to i).sum
        }.toList
    }
}","    }
    def main(args: Array[String]) = {
    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));
    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));
    assert(f((1l)).equals((List[Long](1l.toLong))));
    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));
    }

}
"
HumanEval_107,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം 1:    //പരിധിയിൽ വരുന്ന പൂർണ്ണസംഖ്യകളുടെ പാലിൻഡ്രോമുകൾ ((1, n), ഉൾപ്പെടെ.    //ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു തുപ്പൽ തിരികെ നൽകുക, അതിൽ ഇരട്ടയും അസംഖ്യം യും ഉണ്ട്.    // >>> evenOddPalindrome((3l))
    // ((1l, 2l))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> evenOddPalindrome((12l))
    // ((4l, 6l))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {
","def evenOddPalindrome(n: Long): (Long, Long) = {
  def isPalindrome(x: Long): Boolean = {
    val str = x.toString
    str == str.reverse
  }

  var evenCount: Long = 0
  var oddCount: Long = 0

  for (i <- 1L to n) {
    if (isPalindrome(i)) {
      if (i % 2 == 0) evenCount += 1
      else oddCount += 1
    }
  }

  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));
    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));
    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));
    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));
    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));
    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));
    }

}
"
HumanEval_108,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്, -123 ന്റെ ചിഹ്നമുള്ള അക്കങ്ങൾ -1, 2, 3 എന്നിവയാണ്.    //ഒരു സംഖ്യ നെഗറ്റീവ് ആണെങ്കിൽ, അതിന്റെ ആദ്യത്തെ ചിഹ്നമുള്ള അക്കം നെഗറ്റീവ് ആയിരിക്കും:     // 0 എന്ന സംഖ്യകളുടെ സംഖ്യയുള്ള ഘടകങ്ങളുടെ എണ്ണം.    //ഒരു ഫങ്ഷൻ count_nums എഴുതുക, അത് ഒരു സംഖ്യകളുടെ പട്ടിക എടുത്ത് മടക്കിനൽകുന്നു.    // >>> countNums((List[Long]()))
    // (0l)
    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))
    // (1l)
    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))
    // (3l)
    def countNums(arr : List[Long]) : Long = {
","def countNums(arr: List[Long]): Long = {
  arr.count(num => {
    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>
      if (char == '-') acc else acc + (char - '0')
    }
    sumOfDigits > 0
  }).toLong
}","    }
    def main(args: Array[String]) = {
    assert(countNums((List[Long]())) == (0l));
    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));
    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));
    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));
    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));
    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));
    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));
    assert(countNums((List[Long](1l.toLong))) == (1l));
    }

}
"
HumanEval_109,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //കുറിപ്പ്: ഈ പട്ടികയിൽ അദ്വിതീയമായ ഘടകങ്ങളുണ്ടെന്ന് ഉറപ്പുനൽകുന്നു.    //തന്നിരിക്കുന്ന പട്ടിക ശൂന്യമാണെങ്കിൽ true തിരികെ നൽകുക.    //പിന്നെ ശരി തിരിച്ചു തരാം, അല്ലെങ്കിൽ തെറ്റായി തിരിച്ചു തരാം.    //മുകളില് പറഞ്ഞ പ്രക്രിയ ചെയ്താല് , ക്രമീകരിച്ച പട്ടിക കിട്ടും.    //പട്ടികയിലെ ആരംഭ സ്ഥാനമാണ് 0-ാം സൂചിക.    //ലിസ്റ്റിന്റെ അവസാനത്തെ എലമെന്റ് യിലേക്ക് നീക്കും.    //ഒരു വലത്തോട്ട് നീങ്ങൽ പ്രവർത്തനം അർത്ഥമാക്കുന്നത് പട്ടികയിലെ എല്ലാ ഘടകങ്ങളും ഒരു വരിക്ക് നീങ്ങുന്നു എന്നാണ്.    //വലതുവശത്തേക്കുള്ള ഷിഫ്റ്റ് എത്ര തവണ വേണമെങ്കിലും ചെയ്യാം.    //താഴെ കൊടുത്തിരിക്കുന്ന ലിസ്റ്റിലെ താഴെ പറയുന്ന പ്രവർത്തനം:    // എന്ന പ്രക്രിയയിലൂടെ ഒരു പട്ടിക കുറയാത്ത ക്രമത്തിൽ ക്രമീകരിക്കാൻ സാധിക്കും.    //പട്ടികയിലെ നമ്പറുകൾ ക്രമരഹിതമായി ക്രമീകരിക്കും.    //നമുക്ക് ഒരു പട്ടിക 'arr' ഉണ്ട് N പൂർണ്ണസംഖ്യകളുടെ arr[1], arr[2], ..., arr[N].    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    def moveOneBall(arr : List[Long]) : Boolean = {
","def moveOneBall(arr: List[Long]): Boolean = {
  if (arr.isEmpty) return true

  // Find how many times the array needs to be shifted to become sorted
  val n = arr.length
  var shiftIndex = -1

  for (i <- 0 until n) {
    if (arr(i) > arr((i + 1) % n)) {
      // More than one place where the order breaks means it can't be sorted with a shift
      if (shiftIndex != -1) return false
      shiftIndex = i + 1
    }
  }

  // If no break in order was found, the array is already sorted
  if (shiftIndex == -1) return true

  // Check if shifting by the found index sorts the array
  for (i <- 1 until n) {
    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false
  }
  
  true
}","    }
    def main(args: Array[String]) = {
    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long]())) == (true));
    }

}
"
HumanEval_110,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //ഇല്ലെങ്കിൽ, ""ഇല്ല"" എന്ന് തിരികെ നൽകുക.    //lst1 ന്റെ എല്ലാ ഘടകങ്ങളും സമമാണെങ്കിൽ, ""YES"" എന്ന് തിരികെ നൽകുക.    //lst1 ഉം lst2 ഉം തമ്മിലുള്ള ഘടകങ്ങൾ മാറ്റിയെടുക്കാൻ സാധിക്കുമെങ്കിൽ    //lst1 ഉം lst2 ഉം തമ്മിലുള്ള എക്സ്ചേഞ്ചുകളുടെ എണ്ണത്തിന് പരിധിയില്ല.    //ഇരട്ട സംഖ്യകളുടെ പട്ടിക ഉണ്ടാക്കാന് .    //ഘടകങ്ങള് കൈമാറാന് സാധിക്കുമോ എന്ന് തീരുമാനിക്കുന്നു.    //ഈ പ്രശ്നത്തില് നിങ്ങള് ഒരു ഫങ്ഷൻ നടപ്പിലാക്കും അത് രണ്ട് സംഖ്യകളുടെ പട്ടിക എടുക്കുന്നു,     // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (""YES"")
    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def exchange(lst1: List[Long], lst2: List[Long]): String = {
    // Check if all elements in lst1 are already even
    if (lst1.forall(_ % 2 == 0)) return ""YES""

    // Find if there's any even number in lst2 to exchange with lst1
    val lst2EvensExist = lst2.exists(_ % 2 == 0)

    // Check if there's also at least one odd in lst1 to swap it out
    val lst1OddsExist = lst1.exists(_ % 2 != 0)

    // Only possible if both an even element in lst2 and an odd element in lst1 exist
    if (lst2EvensExist && lst1OddsExist) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((""YES"")));
    }

}
"
HumanEval_111,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //ഒരേ അക്ഷരത്തില് പല അക്ഷരങ്ങള് ഉണ്ടെങ്കില് അവയെല്ലാം തിരികെ നല് കുക.    //ഏറ്റവും കൂടുതൽ തവണ ആവർത്തിക്കുന്നതും അതിനനുസരിച്ച് എണ്ണപ്പെടുന്നതുമായ അക്ഷരത്തിന്റെ     //ഒരു സ്പെയ്സ് വേർതിരിച്ച ചെറിയ അക്ഷരങ്ങളെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു മാപ്പ് തിരികെ നൽകുക     // >>> histogram((""a b c""))
    // (Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l))
    // >>> histogram((""a b b a""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""a b c a b""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""b b b b a""))
    // (Map[String,Long](""b"" -> 4l))
    // >>> histogram((""""))
    // (Map[String,Long]())
    def histogram(test : String) : Map[String,Long] = {
","def histogram(test: String): Map[String, Long] = {
        val words = test.split("" "")
        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)

        if (frequencyMap.isEmpty) return Map.empty[String, Long]

        val maxCount = frequencyMap.values.max
        frequencyMap.filter { case (_, count) => count == maxCount }
    }
}","    }
    def main(args: Array[String]) = {
    assert(histogram((""a b b a"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c a b"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c d g"")).equals((Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l, ""d"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""b b b b a"")).equals((Map[String,Long](""b"" -> 4l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram(("""")).equals((Map[String,Long]())));
    assert(histogram((""a"")).equals((Map[String,Long](""a"" -> 1l))));
    }

}
"
HumanEval_112,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം     //പരിശോധനയ്ക്കായി ഫല സ്ട്രിങ്ങും true/false ഉം അടങ്ങിയ ഒരു ട്യൂപ്പൽ നിങ്ങൾ നൽകണം.    //ഒരു സ്ട്രിംഗ് ഒരു പലിൻഡ്രോം എന്ന് വിളിക്കപ്പെടുന്നു, അത് മുന്നോട്ടും പിന്നോട്ടും ഒരേപോലെ വായിക്കുന്നുവെങ്കിൽ.    //പിന്നെ ഫലം പാലിൻഡ്രോം ആണോ എന്ന് പരിശോധിക്കുക.    //നമുക്ക് രണ്ട് സ്ട്രിങ്ങുകൾ s ഉം c ഉം കിട്ടി, s യിലെ എല്ലാ പ്രതീകങ്ങളും നീക്കം ചെയ്യണം, അത് c യിലെ ഏതെങ്കിലും പ്രതീകത്തിന് തുല്യമാണ്.    //ചുമതല     // >>> reverseDelete((""abcde""), (""ae""))
    // ((""bcd"", false))
    // >>> reverseDelete((""abcdef""), (""b""))
    // ((""acdef"", false))
    // >>> reverseDelete((""abcdedcba""), (""ab""))
    // ((""cdedc"", true))
    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {
","def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {
    // Convert the characters to be deleted into a set for quick lookup
    val deleteSet = c.toSet
    
    // Filter out characters from s that are present in deleteSet
    val filteredString = s.filterNot(deleteSet.contains)
    
    // Check if the filtered string is a palindrome
    val isPalindrome = filteredString == filteredString.reverse
    
    // Return the tuple with the filtered string and the palindrome check result
    (filteredString, isPalindrome)
  }
}","    }
    def main(args: Array[String]) = {
    assert(reverseDelete((""abcde""), (""ae"")).equals(((""bcd"", false))));
    assert(reverseDelete((""abcdef""), (""b"")).equals(((""acdef"", false))));
    assert(reverseDelete((""abcdedcba""), (""ab"")).equals(((""cdedc"", true))));
    assert(reverseDelete((""dwik""), (""w"")).equals(((""dik"", false))));
    assert(reverseDelete((""a""), (""a"")).equals((("""", true))));
    assert(reverseDelete((""abcdedcba""), ("""")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""abcdedcba""), (""v"")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""vabba""), (""v"")).equals(((""abba"", true))));
    assert(reverseDelete((""mamma""), (""mia"")).equals((("""", true))));
    }

}
"
HumanEval_113,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഇൻപുട്ടിന്റെ i-ാം സ്ട്രിങ്ങിലെ അപൂർവ്വ അക്കങ്ങളുടെ എണ്ണം.    //""ഇവിടെ എല്ലാ i- കളും നമ്പർ ഉപയോഗിച്ച് മാറ്റിസ്ഥാപിക്കണം.    //ഔട്ട്പുട്ടിന്റെ ഓരോ ഘടകവും i യിലെ അപൂർവ്വ ഘടകങ്ങളുടെ എണ്ണം ആയിരിക്കണം.    //ഓരോ സ്ട്രിങ്ങും അക്കങ്ങൾ മാത്രമുള്ള ഒരു സ്ട്രിംഗ് ലിസ്റ്റ് നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു ലിസ്റ്റ് നൽകുക.    // >>> oddCount((List[String](""1234567"")))
    // (List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))
    // >>> oddCount((List[String](""3"", ""11111111"")))
    // (List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))
    def oddCount(lst : List[String]) : List[String] = {
","def oddCount(lst: List[String]): List[String] = {
    lst.map { str =>
      val oddCount = str.count(c => c.asDigit % 2 != 0)
      val replacedString = s""the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.""
      replacedString
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(oddCount(List(""1234567"")))  // List(""the number of odd elements 4n the str4ng 4 of the 4nput."")
    println(oddCount(List(""3"", ""11111111"")))  // List(""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput."")
  }
}","    }
    def main(args: Array[String]) = {
    assert(oddCount((List[String](""1234567""))).equals((List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))));
    assert(oddCount((List[String](""3"", ""11111111""))).equals((List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))));
    assert(oddCount((List[String](""271"", ""137"", ""314""))).equals((List[String](""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""))));
    }

}
"
HumanEval_114,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം     //യും    //പൂര് ണ്ണസംഖ്യകളുടെ ഒരു പട്ടിക കൊടുത്താല് , ശൂന്യമല്ലാത്ത ഏതെങ്കിലും ഉപ-പട്ടികയുടെ ഏറ്റവും കുറഞ്ഞ സംഖ്യ കണ്ടെത്തുക     // >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))
    // (1l)
    // >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))
    // (-6l)
    def minSubArraySum(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minSubArraySum(nums: List[Long]): Long = {
    var minEndingHere = nums.head
    var minSoFar = nums.head
    
    for (i <- 1 until nums.length) {
      minEndingHere = min(nums(i), minEndingHere + nums(i))
      minSoFar = min(minSoFar, minEndingHere)
    }
    
    minSoFar
  }

  // Test Cases
  def main(args: Array[String]): Unit = {
    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) // Output: 1
    println(minSubArraySum(List(-1l, -2l, -3l))) // Output: -6
  }
}","    }
    def main(args: Array[String]) = {
    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));
    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));
    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));
    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));
    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));
    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));
    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));
    }

}
"
HumanEval_115,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം 1:    //ബക്കറ്റുകള് താഴെയിറക്കാന് എത്ര പ്രാവശ്യം വേണമെങ്കിലും ചെയ്യണം.    //നിങ്ങളുടെ ജോലി കിണറുകള് ഒഴുകാന് ബക്കറ്റുകള് ഉപയോഗിക്കുക എന്നതാണ്.    //എല്ലാ ബക്കറ്റുകളിലും ഒരേ അളവിലുള്ള വെള്ളം ഉണ്ട്.    //ഓരോ കിണറിനും അതില് നിന്ന് വെള്ളം പുറത്തെടുക്കാന് ഉപയോഗിക്കാവുന്ന ഒരു ബക്കറ്റ് ഉണ്ട്,    //ഓരോ 1യും ഒരു യൂണിറ്റ് വെള്ളത്തെ പ്രതിനിധീകരിക്കുന്നു.    //നിങ്ങള് ക്ക് ഒരു ചതുരാകൃതിയിലുള്ള കിണറുകളുടെ ഒരു ഗ്രിഡ് കിട്ടും. ഓരോ വരിയും ഒരൊറ്റ കിണറിനെ പ്രതിനിധീകരിക്കുന്നു,    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))
    // (6l)
    // Example 2:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))
    // (5l)
    // Example 3:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))
    // (0l)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {
","def maxFill(grid: List[List[Long]], capacity: Long): Long = {
  var totalWaterUnits = 0L

  for (row <- grid) {
    totalWaterUnits += row.sum
  }

  // Calculate the number of times you need to lower the buckets
  val bucketOperations = totalWaterUnits / capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)

  bucketOperations
}","    }
    def main(args: Array[String]) = {
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));
    }

}
"
HumanEval_116,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഇത് ഇങ്ങനെ നടപ്പാക്കണം:    //സമാനമായ എണ്ണം 1 കളുടെ, ദശാംശ മൂല്യം അടിസ്ഥാനമാക്കി അടുക്കുക.    //ബൈനറി പ്രാതിനിധ്യത്തിലെ 1 ന്റെ എണ്ണം വർദ്ധിച്ചുവരുന്ന ക്രമത്തിൽ.    //ഈ കത്തയിൽ, നിങ്ങൾ നെഗറ്റീവ് അല്ലാത്ത സംഖ്യകളുടെ പട്ടിക  അനുസരിച്ച് ക്രമീകരിക്കണം.    // >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))
    // (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))
    // >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))
    def sortArray(arr : List[Long]) : List[Long] = {
","def sortArray(arr: List[Long]): List[Long] = {
        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));
    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));
    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    }

}
"
HumanEval_117,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //കുറിപ്പ്: ഇൻപുട്ട് സ്ട്രിങ്ങിൽ അക്ഷരങ്ങളും സ്പെയ്സുകളും മാത്രമേ ഉള്ളൂ എന്ന് കരുതാം.    //s ശൂന്യമാണെങ്കിൽ ഫങ്ഷൻ ഒരു ശൂന്യമായ ലിസ്റ്റ് നൽകും.    //n സ്വരമാലകൾ, ഈ വാക്കുകൾ s സ്ട്രിങ്ങിൽ പ്രത്യക്ഷപ്പെടുന്ന ക്രമത്തിൽ.    //കൃത്യമായി  അടങ്ങിയിരിക്കുന്ന സ്ട്രിംഗ് s-ലെ എല്ലാ വാക്കുകളുടെയും ഒരു ലിസ്റ്റ് മടക്കിനൽകുന്ന ഒരു ഫംഗ്ഷൻ.    //ഒരു സ്ട്രിംഗ് s ഉം ഒരു സ്വാഭാവിക സംഖ്യ n ഉം നല് കിയിരിക്കെ, നിങ്ങള് ക്ക് നടപ്പിലാക്കാന് നിര് ദ്ദേശമുണ്ട്     // >>> selectWords((""Mary had a little lamb""), (4l))
    // (List[String](""little""))
    // >>> selectWords((""Mary had a little lamb""), (3l))
    // (List[String](""Mary"", ""lamb""))
    // >>> selectWords((""simple white space""), (2l))
    // (List[String]())
    // >>> selectWords((""Hello world""), (4l))
    // (List[String](""world""))
    // >>> selectWords((""Uncle sam""), (3l))
    // (List[String](""Uncle""))
    def selectWords(s : String, n : Long) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def selectWords(s: String, n: Long): List[String] = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    def consonantCount(word: String): Int = {
      word.count(c => c.isLetter && !vowels.contains(c))
    }

    if (s.isEmpty) {
      List()
    } else {
      s.split(""\\s+"").filter(word => consonantCount(word) == n).toList
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(selectWords((""Mary had a little lamb""), (4l)).equals((List[String](""little""))));
    assert(selectWords((""Mary had a little lamb""), (3l)).equals((List[String](""Mary"", ""lamb""))));
    assert(selectWords((""simple white space""), (2l)).equals((List[String]())));
    assert(selectWords((""Hello world""), (4l)).equals((List[String](""world""))));
    assert(selectWords((""Uncle sam""), (3l)).equals((List[String](""Uncle""))));
    assert(selectWords((""""), (4l)).equals((List[String]())));
    assert(selectWords((""a b c d e f""), (1l)).equals((List[String](""b"", ""c"", ""d"", ""f""))));
    }

}
"
HumanEval_118,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //നിങ്ങള് ക്ക് ഊഹിക്കാം, ഈ സ്ട്രിങ്ങിൽ ഇംഗ്ലീഷ് അക്ഷരങ്ങൾ മാത്രമേ ഉള്ളൂ എന്ന്.    //മുകളിലുള്ള നിബന്ധന പാലിക്കുന്ന ഏതെങ്കിലും സ്വരാക്ഷരത്തെ കണ്ടെത്തുക.    //തുടക്കത്തിലും അവസാനത്തിലും ഉള്ള സ്വരാക്ഷരങ്ങൾ കണക്കാക്കില്ല. ഇല്ലെങ്കിൽ ശൂന്യമായ സ്ട്രിംഗ് തിരികെ നൽകുക.    //വാക്കിന്റെ വലതുവശത്ത് നിന്ന് രണ്ട് സ്വരാക്ഷരങ്ങൾ (കേസ് സെൻസിറ്റീവ്).    //നിങ്ങള് ക്ക് ഒരു വാക്ക് കിട്ടും. നിങ്ങള് ക്ക് കിട്ടുന്ന ജോലി അടുത്തുള്ള സ്വരാക്ഷരത്തെ കണ്ടെത്തുക എന്നതാണ്.    // >>> getClosestVowel((""yogurt""))
    // (""u"")
    // >>> getClosestVowel((""FULL""))
    // (""U"")
    // >>> getClosestVowel((""quick""))
    // ("""")
    // >>> getClosestVowel((""ab""))
    // ("""")
    def getClosestVowel(word : String) : String = {
","def getClosestVowel(word: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    for (i <- word.length - 2 until 0 by -1) {
      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {
        return word(i + 1).toString
      }
    }
    
    """"
  }
}","    }
    def main(args: Array[String]) = {
    assert(getClosestVowel((""yogurt"")).equals((""u"")));
    assert(getClosestVowel((""full"")).equals((""u"")));
    assert(getClosestVowel((""easy"")).equals(("""")));
    assert(getClosestVowel((""eAsy"")).equals(("""")));
    assert(getClosestVowel((""ali"")).equals(("""")));
    assert(getClosestVowel((""bad"")).equals((""a"")));
    assert(getClosestVowel((""most"")).equals((""o"")));
    assert(getClosestVowel((""ab"")).equals(("""")));
    assert(getClosestVowel((""ba"")).equals(("""")));
    assert(getClosestVowel((""quick"")).equals(("""")));
    assert(getClosestVowel((""anime"")).equals((""i"")));
    assert(getClosestVowel((""Asia"")).equals(("""")));
    assert(getClosestVowel((""Above"")).equals((""o"")));
    }

}
"
HumanEval_119,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഒരു നല്ല സ്ട്രിംഗ് ഉണ്ടാക്കാന് ഒരു വഴിയുണ്ടെങ്കില് 'അതെ' എന്ന് തിരിച്ചുവിടുക, അല്ലാത്തപക്ഷം 'ഇല്ല' എന്ന് തിരിച്ചുവിടുക.    //"" (()) "" അല്ല.    //ഉദാഹരണത്തിന്: '(((() ' എന്ന സ്ട്രിംഗ് നല്ലതാണ്, അതേസമയം  എന്ന സ്ട്രിംഗ് നല്ലതാണ്.    //S യിലെ എല്ലാ പരാൻതീസിസുകളും  ആണെങ്കിൽ മാത്രമേ ഒരു സ്ട്രിംഗ് S നല്ലതായി കണക്കാക്കപ്പെടുന്നുള്ളൂ.    //ചില ക്രമം, തത്ഫലമായുണ്ടാകുന്ന സ്ട്രിംഗ് നല്ലതായിരിക്കും.    //നിങ്ങളുടെ ജോലി രണ്ടു സ്ട്രിങ്ങുകളും ഒന്നിച്ച് ചേർക്കാൻ സാധിക്കുമോ എന്ന് പരിശോധിക്കുക എന്നതാണ്.    //പരാൻതീസിസ് "" (("" അല്ലെങ്കിൽ അടുത്ത പരാൻതീസിസ് "") "" മാത്രം.    //നിങ്ങള് ക്ക് രണ്ട് സ്ട്രിങ്ങുകളുടെ ഒരു ലിസ്റ്റ് കിട്ടും, രണ്ട് സ്ട്രിങ്ങുകളും ഓപ്പൺ ന്റെ യും യും അടങ്ങിയിരിക്കുന്നു.    // >>> matchParens((List[String](""()("", "")"")))
    // (""Yes"")
    // >>> matchParens((List[String]("")"", "")"")))
    // (""No"")
    def matchParens(lst : List[String]) : String = {
","def matchParens(lst: List[String]): String = {
    def isBalanced(s: String): Boolean = {
      var balance = 0
      for (char <- s) {
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1
        if (balance < 0) return false
      }
      balance == 0
    }
    
    val combinations = List(
      lst(0) + lst(1),
      lst(1) + lst(0)
    )
    
    if (combinations.exists(isBalanced)) ""Yes"" else ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(matchParens((List[String](""()("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", "")""))).equals((""No"")));
    assert(matchParens((List[String](""(()(())"", ""())())""))).equals((""No"")));
    assert(matchParens((List[String]("")())"", ""(()()(""))).equals((""Yes"")));
    assert(matchParens((List[String](""(())))"", ""(()())((""))).equals((""Yes"")));
    assert(matchParens((List[String](""()"", ""())""))).equals((""No"")));
    assert(matchParens((List[String](""(()("", ""()))()""))).equals((""Yes"")));
    assert(matchParens((List[String](""(((("", ""((())""))).equals((""No"")));
    assert(matchParens((List[String]("")(()"", ""(()(""))).equals((""No"")));
    assert(matchParens((List[String]("")("", "")(""))).equals((""No"")));
    assert(matchParens((List[String](""("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", ""(""))).equals((""Yes"")));
    }

}
"
HumanEval_120,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം 1:    //നീളം k യും പരമാവധി k സംഖ്യകളും arr യിലുണ്ട്.    //ഒരു സംഖ്യകളുടെ ലിസ്റ്റ് arr ഉം ഒരു പോസിറ്റീവ് സംഖ്യ k ഉം നൽകിയിട്ടുണ്ടെങ്കിൽ, ഒരു തരംതിരിക്കപ്പെട്ട ലിസ്റ്റ് നൽകുക     // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))
    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))
    // Example 2:
    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))
    // (List[Long](4l.toLong, 4l.toLong))
    // Example 3:
    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))
    // (List[Long](2l.toLong))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    def maximum(arr : List[Long], k : Long) : List[Long] = {
","def maximum(arr: List[Long], k: Long): List[Long] = {
    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));
    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));
    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));
    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));
    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));
    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));
    }

}
"
HumanEval_121,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //പൂര് ണ്ണസംഖ്യകളുടെ ഒരു പട്ടിക നല് കിയിട്ട്, സമസ്ഥാനങ്ങളിലുള്ള എല്ലാ ഭിന്നസംഖ്യകളുടെയും സംഖ്യ തിരികെ നല് കുക.    // >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))
    // (12l)
    // >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))
    // (9l)
    // >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))
    // (0l)
    def solution(lst : List[Long]) : Long = {
","def solution(lst: List[Long]): Long = {
  lst.zipWithIndex.collect {
    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num
  }.sum
}","    }
    def main(args: Array[String]) = {
    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));
    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));
    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));
    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));
    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));
    }

}
"
HumanEval_122,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //arr യിലെ ആദ്യത്തെ k മൂലകങ്ങളുടെ പരമാവധി രണ്ട് അക്കങ്ങളുള്ള മൂലകങ്ങളുടെ സംഖ്യ.    //ഒരു പൂർണ്ണസംഖ്യ arr യും ഒരു പൂർണ്ണസംഖ്യ k യും ഉള്ള ഒരു ശൂന്യമല്ലാത്ത പട്ടിക നൽകിയാൽ, return     // >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))
    // (24l)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    def addElements(arr : List[Long], k : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def addElements(arr: List[Long], k: Long): Long = {
    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum
  }

  def main(args: Array[String]): Unit = {
    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)
    println(result) // Output will be 24L
  }
}","    }
    def main(args: Array[String]) = {
    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));
    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));
    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));
    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));
    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));
    }

}
"
HumanEval_123,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //get_odd_collatz(5) [1, 5] # 5 ന്റെ കോലാറ്റ്സ് ശ്രേണി [5, 16, 8, 4, 2, 1], അതിനാൽ വിചിത്ര സംഖ്യകൾ 1 ഉം 5 ഉം മാത്രമാണ്.    //ഉദാഹരണത്തിന്:     //2. തിരിച്ചുവിട്ട പട്ടിക വർധന ക്രമത്തിൽ അടുക്കുന്നു.    //1. കോലാട്സ്      ആണ് [1].    //കുറിപ്പ്:    //n ന്റെ മൂല്യം എത്രയായിരുന്നാലും, തുടക്കം എപ്പോഴും 1 ആയിരിക്കും.    //മുമ്പത്തെ പദം ഇരട്ട ആണെങ്കിൽ, അടുത്ത പദം മുമ്പത്തെ പദത്തിന്റെ 3 മടങ്ങ് വരും.    //മുമ്പത്തെ പദം ഇപ്രകാരമാണ്: മുമ്പത്തെ പദം ഇരട്ട ആണെങ്കിൽ, അടുത്ത പദം  ന്റെ പകുതി ആണ്.    //താഴെ പറയുന്ന രീതിയിൽ: ഏതെങ്കിലും പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n-ൽ നിന്ന് ആരംഭിക്കുക. പിന്നെ ഓരോ പദവും   ൽ നിന്നും ലഭിക്കുന്നു.    //കോലാറ്റ്സ് അനുമാനം ഒരു ഗണിതശാസ്ത്ര അനുമാനമാണ്, അത് നിർവചിക്കപ്പെട്ട ഒരു ശ്രേണിയെ സംബന്ധിക്കുന്നു.    //ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, ക്രമീകരിച്ച പട്ടിക തിരികെ നൽകുക, അതിൽ കോലാറ്റ്സ് ശ്രേണിയിലെ ഒറ്റ സംഖ്യകൾ അടങ്ങിയിരിക്കുന്നു.    // >>> getOddCollatz((5l))
    // (List[Long](1l.toLong, 5l.toLong))
    def getOddCollatz(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def getOddCollatz(n: Long): List[Long] = {
    val oddNumbers = ListBuffer[Long]()
    var number = n
    while (number != 1) {
      if (number % 2 == 1) {
        oddNumbers += number
      }
      number = if (number % 2 == 0) number / 2 else 3 * number + 1
    }
    oddNumbers += 1
    oddNumbers.sorted.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));
    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));
    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));
    }

}
"
HumanEval_124,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //4. തീയതി എംഎം-ഡിഡി-ആയിയി എന്ന ഫോർമാറ്റിലായിരിക്കണം.    //3. മാസങ്ങളുടെ എണ്ണം 1ൽ കുറവോ 12ൽ കൂടുതലോ ആകരുത്.    //2. മാസങ്ങളായ 1,3,5,7,8,10,12 എന്നിവയുടെ ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 31 ൽ കൂടുതലോ ആയിരിക്കരുത്. മാസങ്ങളായ 4,6,9,11 എന്നിവയുടെ ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 30 ൽ കൂടുതലോ ആയിരിക്കരുത്. മാസമായ 2 ന്റെ ദിവസങ്ങളുടെ എണ്ണം 1 ൽ കുറവോ 29 ൽ കൂടുതലോ ആയിരിക്കരുത്.    //1. തീയതി സ്ട്രിംഗ് ശൂന്യമല്ല.    //താഴെ പറയുന്ന എല്ലാ നിബന്ധനകളും പാലിച്ചാൽ ഈ തീയതി സാധുവാണ്:    //തീയതി ശരിയാണെങ്കിൽ ശരി, അല്ലാത്തപക്ഷം തെറ്റാണ്.    //ഒരു നിശ്ചിത തീയതി സ്ട്രിംഗ് സാധൂകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ എഴുതണം.    // >>> validDate((""03-11-2000""))
    // (true)
    // >>> validDate((""15-01-2012""))
    // (false)
    // >>> validDate((""04-0-2040""))
    // (false)
    // >>> validDate((""06-04-2020""))
    // (true)
    // >>> validDate((""06/04/2020""))
    // (false)
    def validDate(date : String) : Boolean = {
","import scala.util.Try

object Problem {
  def validDate(date: String): Boolean = {
    if (date.isEmpty) return false
    
    val datePattern = """"""^(\d{2})-(\d{2})-(\d{4})$"""""".r

    date match {
      case datePattern(monthStr, dayStr, yearStr) => 
        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {
          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>
            month match {
              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31
              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30
              case 2 => day >= 1 && day <= 29
              case _ => false
            }
          case _ => false
        }
      case _ => false
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(validDate((""03-11-2000"")) == (true));
    assert(validDate((""15-01-2012"")) == (false));
    assert(validDate((""04-0-2040"")) == (false));
    assert(validDate((""06-04-2020"")) == (true));
    assert(validDate((""01-01-2007"")) == (true));
    assert(validDate((""03-32-2011"")) == (false));
    assert(validDate(("""")) == (false));
    assert(validDate((""04-31-3000"")) == (false));
    assert(validDate((""06-06-2005"")) == (true));
    assert(validDate((""21-31-2000"")) == (false));
    assert(validDate((""04-12-2003"")) == (true));
    assert(validDate((""04122003"")) == (false));
    assert(validDate((""20030412"")) == (false));
    assert(validDate((""2003-04"")) == (false));
    assert(validDate((""2003-04-12"")) == (false));
    assert(validDate((""04-2003"")) == (false));
    }

}
"
HumanEval_125,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //അക്ഷരമാല, ഓർഡർ a) = 0, ഓർഡർ b) = 1, . . . ഓർഡർ z) = 25    //കോമകളായി വിഭജിക്കപ്പെടണം ',' കോമകളില്ലെങ്കിൽ,  യിൽ അപൂർവ ക്രമത്തിലുള്ള ചെറിയ അക്ഷരങ്ങളുടെ എണ്ണം നിങ്ങൾ നൽകണം.    //വാക്കുകളുടെ ഒരു സ്ട്രിംഗ് തന്നിരിക്കുന്ന, നിങ്ങൾ ടെക്സ്റ്റിൽ വെളുത്ത സ്പെയ്സുകൾ നിലവിലില്ല എങ്കിൽ, വെളുത്ത സ്പെയ്സുകൾ വിഭജിച്ചു വാക്കുകളുടെ ഒരു ലിസ്റ്റ് തിരികെ     // >>> splitWords((""Hello world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""Hello,world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""abcdef""))
    // 3l
    def splitWords(txt : String) : Either[List[String], Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def splitWords(txt: String): Either[List[String], Long] = {
    if (txt.contains("" "")) {
      Left(txt.split(""\\s+"").toList)
    } else if (txt.contains("","")) {
      Left(txt.split("","").toList)
    } else {
      val oddOrderCount = txt.toCharArray
        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)
      Right(oddOrderCount.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(splitWords((""Hello world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello,world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello world,!"")).equals(List[String](""Hello"", ""world,!"")));
    assert(splitWords((""Hello,Hello,world !"")).equals(List[String](""Hello,Hello,world"", ""!"")));
    assert(splitWords((""abcdef"")).equals(3l));
    assert(splitWords((""aaabb"")).equals(2l));
    assert(splitWords((""aaaBb"")).equals(1l));
    assert(splitWords(("""")).equals(0l));
    }

}
"
HumanEval_126,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //നമ്പർ, false തിരികെ നൽകുന്നു. നെഗറ്റീവ് നമ്പറുകളില്ലെന്നും പൂർണ്ണസംഖ്യകൾ മാത്രമേ ഉള്ളൂവെന്നും കരുതുക.    //ലിസ്റ്റില് ഒന്നിലധികം ഇരട്ടകളുണ്ടെങ്കില് , അവയെല്ലാം ക്രമം അനുസരിച്ച് ക്രമീകരിക്കണം.    //ഒരു നമ്പറുകളുടെ ലിസ്റ്റ് കൊടുത്താൽ, അവ അടുക്കിയിട്ടുണ്ടോ ഇല്ലയോ എന്ന് തിരികെ നൽകുക     // >>> isSorted((List[Long](5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (false)
    def isSorted(lst : List[Long]) : Boolean = {
","def isSorted(lst: List[Long]): Boolean = {
    if (lst.isEmpty || lst.length == 1) return true

    var hasDuplicate = false

    for (i <- 1 until lst.length) {
        if (lst(i) < lst(i - 1)) {
            return false
        }
        if (lst(i) == lst(i - 1)) {
            if (hasDuplicate) return false
            hasDuplicate = true
        } else {
            hasDuplicate = false
        }
    }

    true
}","    }
    def main(args: Array[String]) = {
    assert(isSorted((List[Long](5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));
    assert(isSorted((List[Long]())) == (true));
    assert(isSorted((List[Long](1l.toLong))) == (true));
    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));
    }

}
"
HumanEval_127,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //[ഇൻപുട്ട്/ഔട്ട്പുട്ട്] സാമ്പിളുകൾ:     //രണ്ട് ഇടവേളകളും പരസ്പരം കൂടിച്ചേരുന്നില്ലെങ്കിൽ, ""NO"" എന്ന് തിരികെ നൽകുക.    //ഇല്ലെങ്കിൽ ""ഇല്ല"" എന്ന് തിരികെ നൽകുക.    //ഇന്റർസെക്ഷന് ഒരു പ്രധാന സംഖ്യയാണെങ്കിൽ, ""YES"" എന്ന് തിരികെ നൽകുക.    //അതിന്റെ നീളം 1 ആണ്, അത് ഒരു പ്രൈം നമ്പർ അല്ല.    //ഉദാഹരണത്തിന്, ഇടവേളകളുടെ (1, 3), (2, 4) വിഭജനം (2, 3) ആണ്.    //ഒരു പ്രൈം നമ്പറാണ്.    //നിങ്ങളുടെ ജോലി ഈ രണ്ടു ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ ന്റെ    //ഓരോ ഇടവേളയുടെയും തുടക്കം അതിന്റെ അവസാനത്തെക്കാൾ കുറവോ തുല്യമോ ആണെന്ന് കരുതപ്പെടുന്നു.    //തുടക്കവും അവസാനവും ഉൾപ്പെടുന്നു.    //ഈ ഇടവേളകൾ അടച്ചവയാണ്, അതിനർത്ഥം ഇടവേള (ആരംഭം, അവസാനം)     //ഓരോ ഇടവേളയും ഒരു ജോടി പൂർണ്ണസംഖ്യകളാണ്. ഉദാഹരണത്തിന്, ഇടവേള = (ആരംഭം, അവസാനം) = (1, 2).    //നിങ്ങള് ക്ക് രണ്ടു ഇടവേളകളാണ് നല് കിയിരിക്കുന്നത്.    // >>> intersection(((1l, 2l)), ((2l, 3l)))
    // (""NO"")
    // >>> intersection(((-1l, 1l)), ((0l, 4l)))
    // (""NO"")
    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))
    // (""YES"")
    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {
","import scala.math._

object Problem {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {
    val start = max(interval1._1, interval2._1)
    val end = min(interval1._2, interval2._2)
    if (start > end) return ""NO""

    val length = end - start
    if (isPrime(length)) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((""NO"")));
    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((""NO"")));
    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((""YES"")));
    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((""YES"")));
    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((""NO"")));
    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((""NO"")));
    }

}
"
HumanEval_128,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //കുറിപ്പ്: ശൂന്യമായ arr ന്റെ None മടങ്ങുക    //ലിസ്റ്റിലെ ഓരോ നമ്പറിലും 1, -1 അല്ലെങ്കിൽ 0 എന്ന സംഖ്യ ഉപയോഗിച്ച് പ്രതിനിധീകരിക്കുക.    // പൂര് ണ്ണസംഖ്യകളുടെ ആകെത്തുക, എല്ലാ അടയാളങ്ങളുടെയും ഗുണിതം കൊണ്ട് ഗുണിച്ചാല്    //നിങ്ങള് ക്ക് ഒരു സംഖ്യകളുടെ ലിസ്റ്റ് കിട്ടും, നിങ്ങള് തിരിച്ചു പോകണം.    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))
    // Some(9l)
    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))
    // Some(0l)
    // >>> prodSigns((List[Long]()))
    // None
    def prodSigns(arr : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def prodSigns(arr: List[Long]): Option[Long] = {
    if (arr.isEmpty) return None

    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))
    val sumOfMagnitudes = arr.map(_.abs).sum

    Some(sumOfMagnitudes * productOfSigns)
  }

  private def sign(num: Long): Long = {
    if (num > 0) 1
    else if (num < 0) -1
    else 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));
    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));
    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));
    assert(prodSigns((List[Long]())).equals(None));
    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));
    }

}
"
HumanEval_129,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഏറ്റവും കുറഞ്ഞ പാത കടന്നുപോകുന്ന സെല്ലുകളിലെ മൂല്യങ്ങളുടെ ഒരു ക്രമീകരിച്ച പട്ടിക തിരികെ നൽകുന്നു.    //ഉത്തരം അദ്വിതീയമാണെന്ന് ഉറപ്പുനൽകുന്നു.    //lst_A[j] = lst_B[j]  എന്നതിനു സമാനമാണ്.    //lst_A[i] < lst_B[i] എന്ന തരത്തിലുള്ളതും, ഏതൊരു j (1 <= j < i) നും നമുക്ക്     //lst_B-നേക്കാൾ, മറ്റൊരു വാക്കിൽ പറഞ്ഞാൽ, ഒരു പൂർണ്ണസംഖ്യാ സൂചിക i (1 <= i <= k)  നിലവിലുണ്ട്.    //lst_A, lst_B എന്നിവയെ വിളിക്കാം. lst_A എന്നത് നിഘണ്ടുശാസ്ത്രപരമായി കുറവാണ്.    //A, B എന്നീ സെല്ലുകളിലെ മൂല്യങ്ങളുടെ ക്രമീകരിച്ച ലിസ്റ്റുകൾ തയ്യാറാക്കിയ ശേഷം പോകുക     //ഒരു പാത A (നീളം k) ഒരു പാത B (നീളം k) നേക്കാൾ ചെറുതായി കണക്കാക്കപ്പെടുന്നു     //നിങ്ങള് ക്ക് ഗ്രിഡില് നിന്ന് മാറിപ്പോകാന് കഴിയില്ല.    //അവയൊക്കെ വേറിട്ടവയായിരിക്കണം.    //k നീളമുള്ള ഒരു പാത കൃത്യമായി k സെല്ലുകൾ സന്ദർശിക്കുമെന്നാണ് (അല്ല     //യും    //മറ്റൊരു വാക്കില് , നിങ്ങള് ക്ക് നിങ്ങളുടെ നിലവിലെ ഘടകങ്ങളുമായി ഒരു വശത്ത് പങ്കിടുന്ന സെല്ലുകളിലേക്ക് പോകാം.    //ഏത് സെല്ലിൽ നിന്നും, ഓരോ ഘട്ടത്തിലും നിങ്ങൾക്ക് അയൽ സെല്ലുകളിലേക്ക് നീങ്ങാം,    //ഗ്രിഡിലെ k നീളമുള്ള ഏറ്റവും കുറഞ്ഞ പാത കണ്ടെത്തണം.    //ഗ്രിഡിലെ സെല്ലുകളിൽ കൃത്യമായി ഒരു തവണയാണ് inclusive കാണപ്പെടുന്നത്.    //ഗ്രിഡിലെ ഓരോ സെല്ലിലും ഒരു മൂല്യം അടങ്ങിയിരിക്കുന്നു. [1, N * N] യിലെ ഓരോ പൂർണ്ണസംഖ്യയും    //N വരികളും N നിരകളും ഉള്ള ഒരു ഗ്രിഡ് (N >= 2) ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ k,     // >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))
    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))
    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))
    // (List[Long](1l.toLong))
    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minPath(grid: List[List[Long]], k: Long): List[Long] = {
    val n = grid.length
    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))

    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n

    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {
      if (path.length == k) return path
      var minPath: List[Long] = List.fill(k)(Long.MaxValue)
      for ((dx, dy) <- directions) {
        val nx = x + dx
        val ny = y + dy
        if (isValid(nx, ny)) {
          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))
          if (lexCompare(newPath, minPath)) {
            minPath = newPath
          }
        }
      }
      minPath
    }

    def lexCompare(a: List[Long], b: List[Long]): Boolean = {
      a.zip(b).find { case (x, y) => x != y } match {
        case Some((x, y)) => x < y
        case None => false
      }
    }

    var minPathOverall = List.fill(k)(Long.MaxValue)
    for {
      i <- 0 until n
      j <- 0 until n
    } {
      val startingPath = List(grid(i)(j))
      val currentPath = dfs(i, j, startingPath)
      if (lexCompare(currentPath, minPathOverall)) {
        minPathOverall = currentPath
      }
    }
    minPathOverall
  }
}","    }
    def main(args: Array[String]) = {
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));
    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_130,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ട്രിബൊനാച്ചി ശ്രേണിയിലെ ആദ്യത്തെ n + 1 സംഖ്യകൾ.    //നിങ്ങള് ക്ക് ഒരു നെഗറ്റീവ് അല്ലാത്ത സംഖ്യ n കിട്ടും, നിങ്ങള് ന്റെ ഒരു ലിസ്റ്റ് തിരിച്ചു തരണം.    //= 2 + 3 + 3 = 8     //ത്രി) = ത്രി) + ത്രി) + ത്രി)    //ത്രി) = 3     //ത്രി2) = 1 + (2 / 2) = 2     //ഉദാഹരണത്തിന്:     //n = n-1 + n-2 + n-1 ആണെങ്കിൽ n ഒരു ഒറ്റസംഖ്യയാണ്.    //ത്രികോണം n) = 1 + n / 2, n ഇരട്ട ആണെങ്കിൽ.    //ത്രി) = 3     //ട്രിബോണാച്ചി ശ്രേണിയുടെ നിർവചനം താഴെ പറയുന്നതുമാണ്:    //എന്നിരുന്നാലും, ആളുകൾക്ക് അറിയാത്തത് ട്രിബൊനാച്ചി ശ്രേണിയാണ്.    //ഫിബോനാച്ചി ശ്രേണിയെ കുറിച്ച് എല്ലാവർക്കും അറിയാം, അത് ഗണിതശാസ്ത്രജ്ഞർ ആഴത്തിൽ പഠിച്ചു.    // >>> tri((3l))
    // (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))
    def tri(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def tri(n: Long): List[Long] = {
    // Initialize list with the first element of the Tribonacci sequence
    val tribonacciSeq = ListBuffer[Long](3)

    // Generate remaining elements up to the nth element
    for (i <- 1L to n) {
      if (i % 2 == 0) {
        // If even, the formula is 1 + n / 2
        tribonacciSeq.append(1 + i / 2)
      } else {
        // If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)
        // tri(n + 1) is handled as we iterate further
        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0
        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0
        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) / 2 else 0 // calculated as if the next is even
        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)
      }
    }

    // Return as a list
    tribonacciSeq.toList
  }

  // Test examples
  def main(args: Array[String]): Unit = {
    println(tri(3)) // List(3, 2, 8)
  }
}","    }
    def main(args: Array[String]) = {
    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));
    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));
    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));
    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));
    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));
    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));
    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));
    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));
    assert(tri((0l)).equals((List[Long](1l.toLong))));
    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_131,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //എല്ലാ അക്കങ്ങളും ജോഡി ആണെങ്കിൽ 0 തിരികെ നൽകുക.    //ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ n നൽകിയിട്ടുണ്ടെങ്കിൽ, അസമമായ അക്കങ്ങളുടെ ഗുണനം നൽകുക.    // >>> digits((1l))
    // (1l)
    // >>> digits((4l))
    // (0l)
    // >>> digits((235l))
    // (15l)
    def digits(n : Long) : Long = {
","def digits(n: Long): Long = {
    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product
    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product
}","    }
    def main(args: Array[String]) = {
    assert(digits((5l)) == (5l));
    assert(digits((54l)) == (5l));
    assert(digits((120l)) == (1l));
    assert(digits((5014l)) == (5l));
    assert(digits((98765l)) == (315l));
    assert(digits((5576543l)) == (2625l));
    assert(digits((2468l)) == (0l));
    }

}
"
HumanEval_132,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //യില് കുറഞ്ഞത് ഒരു ബ്രാക്കറ്റ് എങ്കിലും കൂട്ടിയിണക്കിയിട്ടുണ്ടാവണം.    //ബ്രാക്കറ്റുകളുടെ സാധുവായ ഒരു അനുക്രമം ഉണ്ടെങ്കിൽ മാത്രമേ ഫംഗ്ഷൻ true ആയി മടങ്ങുകയുള്ളൂ.    //ഒരു സ്ട്രിംഗ് ഇൻപുട്ടായി എടുക്കുന്ന ഒരു ഫംഗ്ഷൻ ഉണ്ടാക്കുക, അതിൽ ചതുരാകൃതിയിലുള്ള ബ്രാക്കറ്റുകൾ മാത്രമേ ഉള്ളൂ.    // >>> isNested((""[[]]""))
    // (true)
    // >>> isNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> isNested((""[][]""))
    // (false)
    // >>> isNested((""[]""))
    // (false)
    // >>> isNested((""[[][]]""))
    // (true)
    // >>> isNested((""[[]][[""))
    // (true)
    def isNested(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isNested(string: String): Boolean = {
    var stack = new Stack[Char]()
    var nested = false

    for (char <- string) {
      char match {
        case '[' => stack.push(char)
        case ']' =>
          if (stack.nonEmpty) {
            stack.pop()
            if (stack.nonEmpty) {
              nested = true
            }
          }
      }
      if (nested) return true
    }

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isNested((""[[]]"")) == (true));
    assert(isNested((""[]]]]]]][[[[[]"")) == (false));
    assert(isNested((""[][]"")) == (false));
    assert(isNested((""[]"")) == (false));
    assert(isNested((""[[[[]]]]"")) == (true));
    assert(isNested((""[]]]]]]]]]]"")) == (false));
    assert(isNested((""[][][[]]"")) == (true));
    assert(isNested((""[[]"")) == (false));
    assert(isNested((""[]]"")) == (false));
    assert(isNested((""[[]][["")) == (true));
    assert(isNested((""[[][]]"")) == (true));
    assert(isNested(("""")) == (false));
    assert(isNested((""[[[[[[[["")) == (false));
    assert(isNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ലിസ്റ്റിലെ ഓരോ എലമെന്റും ആദ്യം മുകളിലെ int{}    //നിങ്ങള് ക്ക് നല് കിയിട്ടുള്ള ലിസ്റ്റിലെ സംഖ്യകളുടെ ചതുരശ്ര സംഖ്യകളുടെ തുക നല് കണം,     //നിങ്ങള് ക്ക് ഒരു നമ്പര് ലിസ്റ്റ് കിട്ടും.    // >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))
    // (14l)
    // >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))
    // (98l)
    // >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))
    // (84l)
    // >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))
    // (29l)
    // >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))
    // (6l)
    def sumSquares(lst : List[Float]) : Long = {
","import scala.math._

object Problem {
  def sumSquares(lst: List[Float]): Long = {
    lst.map(x => ceil(x.toDouble).toLong)
      .map(x => x * x)
      .sum
  }

  // Example usage, you can test the function with the given examples:
  def main(args: Array[String]): Unit = {
    println(sumSquares(List(1.0f, 2.0f, 3.0f))) // Output: 14
    println(sumSquares(List(1.0f, 4.0f, 9.0f))) // Output: 98
    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) // Output: 84
    println(sumSquares(List(1.4f, 4.2f, 0.0f))) // Output: 29
    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) // Output: 6
  }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));
    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));
    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));
    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));
    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));
    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));
    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));
    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));
    }

}
"
HumanEval_134,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //കുറിപ്പ്: ""വചനം"" എന്നത് സ്പെയ്സ് കൊണ്ട് വേർതിരിക്കുന്ന പ്രതീകങ്ങളുടെ ഒരു കൂട്ടമാണ്.    //ഒരു വാക്കിന്റെ ഭാഗം, അല്ലാത്തപക്ഷം തെറ്റാണ്.    //ഒരു സ്ട്രിങ്ങിന്റെ അക്ഷരമാലയിലെ പ്രതീകമാണ്     //അവസാനത്തെ പ്രതീകം  ആണെങ്കിൽ true എന്ന് തിരികെ നൽകുന്ന ഒരു ഫംഗ്ഷൻ ഉണ്ടാക്കുക.    // >>> checkIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> checkIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> checkIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> checkIfLastCharIsALetter((""""))
    // (false)
    def checkIfLastCharIsALetter(txt : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def checkIfLastCharIsALetter(txt: String): Boolean = {
        if (txt.isEmpty) return false
        val trimmed = txt.trim
        if (trimmed.isEmpty) return false
        val parts = trimmed.split("" "")
        val lastChars = parts.map(_.last)
        if (lastChars.isEmpty) return false
        val lastChar = trimmed.last
        lastChars.contains(lastChar) && lastChar.isLetter
    }
}","    }
    def main(args: Array[String]) = {
    assert(checkIfLastCharIsALetter((""apple"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e"")) == (true));
    assert(checkIfLastCharIsALetter((""eeeee"")) == (false));
    assert(checkIfLastCharIsALetter((""A"")) == (true));
    assert(checkIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    assert(checkIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    assert(checkIfLastCharIsALetter(("""")) == (false));
    assert(checkIfLastCharIsALetter((""eeeee e "")) == (false));
    assert(checkIfLastCharIsALetter((""apple pie"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഇരട്ട മൂല്യങ്ങൾ    //അത്തരം ഒരു ഘടകം നിലവിലില്ലെങ്കിൽ -1 എന്ന നമ്പർ നൽകുക.    //തൊട്ടു മുമ്പുള്ള മൂലകത്തേക്കാൾ വലുതോ തുല്യമോ അല്ല.    //ഒരു ഘടകത്തിന്റെ ഏറ്റവും വലിയ സൂചിക നൽകുന്ന ഒരു ഫംഗ്ഷൻ സൃഷ്ടിക്കുക.    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))
    // (3l)
    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (-1l)
    def canArrange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  def canArrange(arr: List[Long]): Long = {
    for (i <- arr.indices.drop(1)) {
      if (arr(i) < arr(i - 1)) return i.toLong
    }
    -1L
  }
}","    }
    def main(args: Array[String]) = {
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));
    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));
    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));
    assert(canArrange((List[Long]())) == (-1l));
    }

}
"
HumanEval_136,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //പോസിറ്റീവ് ആയതോ നെഗറ്റീവ് ആയതോ ആയ സംഖ്യകളൊന്നും ഇല്ലെങ്കിൽ അവയെ None ആയി തിരിച്ചുവിടുക.    //ഒരു പട്ടികയിലെ പോസിറ്റീവ് ഇന്റീജറുകളുടെ എണ്ണം.    //ഏറ്റവും വലിയ നെഗറ്റീവ് ഇന്റഗ്രൽ ആണ്, ഏറ്റവും ചെറിയത് b ആണ്.    //ഒരു ട്യുപ്പൽ (a, b) തിരികെ നൽകുന്ന ഒരു ഫങ്ഷൻ ഉണ്ടാക്കുക, അവിടെ 'a'  ആണ്.    // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (Some(None), Some(1l))
    // >>> largestSmallestIntegers((List[Long]()))
    // (Some(None), Some(None))
    // >>> largestSmallestIntegers((List[Long](0l.toLong)))
    // (Some(None), Some(None))
    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {
    val negativeIntegers = lst.filter(_ < 0)
    val positiveIntegers = lst.filter(_ > 0)

    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None
    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None

    (largestNegative, smallestPositive)
  }
}","    }
    def main(args: Array[String]) = {
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));
    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));
    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));
    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));
    }

}
"
HumanEval_138,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം     //n എന്ന സംഖ്യയെ കൃത്യമായി 4 പോസിറ്റീവ് ഇരട്ട സംഖ്യകളുടെ തുകയായി എഴുതാനാകുമോ എന്ന് വിലയിരുത്തുക.    // >>> isEqualToSumEven((4l))
    // (false)
    // >>> isEqualToSumEven((6l))
    // (false)
    // >>> isEqualToSumEven((8l))
    // (true)
    def isEqualToSumEven(n : Long) : Boolean = {
","def isEqualToSumEven(n: Long): Boolean = {
    // Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.
    n >= 8 && n % 2 == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(isEqualToSumEven((4l)) == (false));
    assert(isEqualToSumEven((6l)) == (false));
    assert(isEqualToSumEven((8l)) == (true));
    assert(isEqualToSumEven((10l)) == (true));
    assert(isEqualToSumEven((11l)) == (false));
    assert(isEqualToSumEven((12l)) == (true));
    assert(isEqualToSumEven((13l)) == (false));
    assert(isEqualToSumEven((16l)) == (true));
    }

}
"
HumanEval_139,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //n > 0     //ബ്രസീലിയൻ_ഫാക്ടോറിയൽ (n) = n! * (n-1)! * (n-2)! * . . . * 1!     //ബ്രസീലിയൻ ഫാക്ടോറിയൽ താഴെ പറയുന്ന രീതിയിൽ നിർവചിക്കപ്പെട്ടിരിക്കുന്നു:    // >>> specialFactorial((4l))
    // (288l)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    def specialFactorial(n : Long) : Long = {
","def specialFactorial(n: Long): Long = {
        def factorial(x: Long): Long = {
            if (x == 0 || x == 1) 1L
            else x * factorial(x - 1)
        }

        (1L to n).map(factorial).product
    }
}","    }
    def main(args: Array[String]) = {
    assert(specialFactorial((4l)) == (288l));
    assert(specialFactorial((5l)) == (34560l));
    assert(specialFactorial((7l)) == (125411328000l));
    assert(specialFactorial((1l)) == (1l));
    }

}
"
HumanEval_140,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //പിന്നെ തുടർച്ചയായ എല്ലാ സ്പെയ്സുകളും മാറ്റി -     //ഒരു സ്ട്രിങിന് തുടർച്ചയായി 2 സ്പെയ്സുകളിലധികം ഉണ്ടെങ്കിൽ,    //ഒരു ടെക്സ്റ്റ് സ്ട്രിംഗ് തന്നാൽ, അതിലെ എല്ലാ സ്പെയ്സുകളും അടിവരയിടുക,     // >>> fixSpaces(("" Example""))
    // (""Example"")
    // >>> fixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> fixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> fixSpaces(("" Example 3""))
    // (""_Example-3"")
    def fixSpaces(text : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fixSpaces(text: String): String = {
    val result = new StringBuilder()
    var spaceCount = 0
    var leadingSpace = true
    
    for (ch <- text) {
      if (ch == ' ') {
        spaceCount += 1
      } else {
        if (spaceCount > 0) {
          if (leadingSpace && result.isEmpty) {
            result.append('_')
          } else if (spaceCount == 1) {
            result.append('_')
          } else if (spaceCount > 1) {
            result.append('-')
          }
          spaceCount = 0
        }
        result.append(ch)
        leadingSpace = false
      }
    }
    
    if (spaceCount == 1) {
      result.append('_')
    } else if (spaceCount > 1) {
      result.append('-')
    }
    
    result.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(fixSpaces((""Example"")).equals((""Example"")));
    assert(fixSpaces((""Mudasir Hanif "")).equals((""Mudasir_Hanif_"")));
    assert(fixSpaces((""Yellow Yellow  Dirty  Fellow"")).equals((""Yellow_Yellow__Dirty__Fellow"")));
    assert(fixSpaces((""Exa   mple"")).equals((""Exa-mple"")));
    assert(fixSpaces((""   Exa 1 2 2 mple"")).equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //- ഡോട്ടിന് ശേഷം വരുന്ന സബ് സ്ട്രിംഗ് ഇവരിൽ ഒരാളായിരിക്കണം: ['txt', 'exe', 'dll']     //ലാറ്റിൻ അക്ഷരമാലയിലെ അക്ഷരങ്ങൾ ('a'-'z' and 'A'-'Z').    //- ഡോട്ടിന് മുമ്പുള്ള സബ്സ്ട്രിംഗ് ശൂന്യമായിരിക്കരുത്, അത് തുടങ്ങുന്നത്  എന്ന അക്ഷരത്തിൽ നിന്നാണ്.    //- ഫയലിന്റെ പേരില് ഒരു ഡോട്ട് മാത്രമേ ഉള്ളൂ.    //- ഫയലിന്റെ പേരിന് മൂന്ന് അക്കങ്ങളിൽ കൂടുതലാകരുത് ('0'-'9').    //യും    //താഴെ പറയുന്ന എല്ലാ വ്യവസ്ഥകളും പാലിച്ചാൽ മാത്രമേ ഒരു ഫയലിന്റെ പേര് സാധുവായതായി കണക്കാക്കുകയുള്ളൂ.    //ഫയലിന്റെ പേര് സാധുവാണെങ്കിൽ 'അതെ', അല്ലാത്തപക്ഷം 'ഇല്ല' എന്ന് നൽകുന്നു.    //ഒരു ഫയലിന്റെ പേര് പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് എടുത്ത്  എന്ന് റിട്ടേൺ ചെയ്യുന്ന ഒരു ഫംഗ്ഷൻ ഉണ്ടാക്കുക.    // >>> fileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> fileNameCheck((""1example.dll""))
    // (""No"")
    def fileNameCheck(file_name : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fileNameCheck(file_name: String): String = {
    val validExtensions = Set(""txt"", ""exe"", ""dll"")
    val dotIndex = file_name.lastIndexOf('.')

    if (dotIndex == -1) return ""No""

    val beforeDot = file_name.substring(0, dotIndex)
    val afterDot = file_name.substring(dotIndex + 1)

    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return ""No""

    val digitCount = beforeDot.count(_.isDigit)
    if (digitCount > 3) return ""No""

    if (!validExtensions.contains(afterDot)) return ""No""

    ""Yes""
  }

  def main(args: Array[String]): Unit = {
    println(fileNameCheck(""example.txt"")) // ""Yes""
    println(fileNameCheck(""1example.dll"")) // ""No""
    println(fileNameCheck(""test123.exe"")) // ""Yes""
    println(fileNameCheck("".hidden.txt"")) // ""No""
    println(fileNameCheck(""file..txt"")) // ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(fileNameCheck((""example.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""1example.dll"")).equals((""No"")));
    assert(fileNameCheck((""s1sdf3.asd"")).equals((""No"")));
    assert(fileNameCheck((""K.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""MY16FILE3.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""His12FILE94.exe"")).equals((""No"")));
    assert(fileNameCheck((""_Y.txt"")).equals((""No"")));
    assert(fileNameCheck((""?aREYA.exe"")).equals((""No"")));
    assert(fileNameCheck((""/this_is_valid.dll"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.wow"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""this_is_valid.txtexe"")).equals((""No"")));
    assert(fileNameCheck((""#this2_i4s_5valid.ten"")).equals((""No"")));
    assert(fileNameCheck((""@this1_is6_valid.exe"")).equals((""No"")));
    assert(fileNameCheck((""this_is_12valid.6exe4.txt"")).equals((""No"")));
    assert(fileNameCheck((""all.exe.txt"")).equals((""No"")));
    assert(fileNameCheck((""I563_No.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""Is3youfault.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""no_one#knows.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""1I563_Yes3.exe"")).equals((""No"")));
    assert(fileNameCheck((""I563_Yes3.txtt"")).equals((""No"")));
    assert(fileNameCheck((""final..txt"")).equals((""No"")));
    assert(fileNameCheck((""final132"")).equals((""No"")));
    assert(fileNameCheck((""_f4indsartal132."")).equals((""No"")));
    assert(fileNameCheck(("".txt"")).equals((""No"")));
    assert(fileNameCheck((""s."")).equals((""No"")));
    }

}
"
HumanEval_142,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ലിസ്റ്റിലെ എൻട്രികൾ മാറ്റുക, അവയുടെ ഇൻഡെക്സുകൾ 3 അല്ലെങ്കിൽ 4 ന്റെ ഗുണിതമല്ല. ഫംഗ്ഷൻ എല്ലാ എൻട്രികളുടെയും തുക നൽകും.    //3 ന്റെ ഗുണിതവും അതിന്റെ സൂചിക 4 ന്റെ ഗുണിതമാണെങ്കിൽ പൂർണ്ണസംഖ്യ എൻട്രി ക്യൂബ് ചെയ്യും.    //ഈ ഫംഗ്ഷൻ പൂർണ്ണസംഖ്യകളുടെ ഒരു ലിസ്റ്റ് എടുക്കും. ലിസ്റ്റിലെ എല്ലാ എൻട്രികൾക്കും, ഫംഗ്ഷൻ അതിന്റെ സൂചിക a ആണെങ്കിൽ പൂർണ്ണസംഖ്യ എൻട്രിയുടെ ചതുരശ്രണം എടുക്കണം.    //""     // >>> lst
    // List[Long](1l.toLong, 2l.toLong, 3l.toLong)
    // >>> lst
    // List[Long]()
    // >>> lst
    // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)
    def sumSquares(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def sumSquares(lst: List[Long]): Long = {
        lst.zipWithIndex.map { case (value, index) =>
            if (index % 3 == 0) {
                value * value
            } else if (index % 4 == 0) {
                value * value * value
            } else {
                value
            }
        }.sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));
    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));
    assert(sumSquares((List[Long]())) == (0l));
    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));
    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));
    assert(sumSquares((List[Long](0l.toLong))) == (0l));
    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));
    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));
    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));
    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));
    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));
    }

}
"
HumanEval_143,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം 1:    //പുതിയ സ്ട്രിങ്ങിലെ വാക്കുകളുടെ ക്രമം ഒറിജിനലിലേതിന് സമാനമായിരിക്കണം.    //ന്റെ നീളം പ്രൈം നമ്പറുകളാണ്,    // എന്ന വാക്യത്തിന്റെ വാക്കുകൾ അടങ്ങിയ ഒരു സ്ട്രിംഗ് തിരികെ നൽകണം.    //വാക്യത്തില് ചില വാക്കുകള് സ്പെയ്സ് കൊണ്ട് വേര് പിരിയുന്നു,    //നിങ്ങള് ക്ക് ഒരു വാക്യത്തെ പ്രതിനിധീകരിക്കുന്ന ഒരു സ്ട്രിംഗ് നല് കുന്നു,    // >>> wordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> wordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    def wordsInSentence(sentence : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isPrime(n: Int): Boolean = {
    if (n < 2) false
    else if (n == 2) true
    else !(2 to sqrt(n).toInt).exists(n % _ == 0)
  }

  def wordsInSentence(sentence: String): String = {
    val words = sentence.split("" "")
    val primeLengthWords = words.filter(word => isPrime(word.length))
    primeLengthWords.mkString("" "")
  }
  
  // Example usage:
  // println(wordsInSentence(""This is a test""))
  // println(wordsInSentence(""lets go for swimming""))
}","    }
    def main(args: Array[String]) = {
    assert(wordsInSentence((""This is a test"")).equals((""is"")));
    assert(wordsInSentence((""lets go for swimming"")).equals((""go for"")));
    assert(wordsInSentence((""there is no place available here"")).equals((""there is no place"")));
    assert(wordsInSentence((""Hi I am Hussein"")).equals((""Hi am Hussein"")));
    assert(wordsInSentence((""go for it"")).equals((""go for it"")));
    assert(wordsInSentence((""here"")).equals(("""")));
    assert(wordsInSentence((""here is"")).equals((""is"")));
    }

}
"
HumanEval_144,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //x, n എന്നിവ സാധുവായ ഭിന്നസംഖ്യകളാണെന്നും അവയ്ക്ക് നാമകരണമായി പൂജ്യമില്ലെന്നും കരുതാം.    //ഇവിടെ സംഖ്യയും നാമവിശേഷണവും പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളാണ്.    //x ഉം n ഉം ഒരു ഭിന്നസംഖ്യയുടെ സ്ട്രിംഗ് പ്രതിനിധീകരണമാണ്, അവയ്ക്ക് ഇനിപ്പറയുന്ന ഫോർമാറ്റ് ഉണ്ട്,    //x * n. x * n ഒരു പൂർണ്ണസംഖ്യയായി വിലയിരുത്തുകയും false  ആയി വിലയിരുത്തുകയും ചെയ്താൽ ഫംഗ്ഷൻ true ആയി നൽകുന്നു.    //നിങ്ങളുടെ ജോലി ഈ എക്സ്പ്രഷനെ ലളിതമാക്കുന്ന ഒരു ഫങ്ഷൻ ഉണ്ടാക്കുക എന്നതാണ്.    // >>> simplify((""1/5""), (""5/1""))
    // (true)
    // >>> simplify((""1/6""), (""2/1""))
    // (false)
    // >>> simplify((""7/10""), (""10/2""))
    // (false)
    def simplify(x : String, n : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def simplify(x: String, n: String): Boolean = {
    def parseFraction(fraction: String): (Int, Int) = {
      val parts = fraction.split(""/"")
      (parts(0).toInt, parts(1).toInt)
    }

    val (numX, denX) = parseFraction(x)
    val (numN, denN) = parseFraction(n)

    val multipliedNumerator = numX * numN
    val multipliedDenominator = denX * denN

    multipliedNumerator % multipliedDenominator == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/6""), (""2/1"")) == (false));
    assert(simplify((""5/1""), (""3/1"")) == (true));
    assert(simplify((""7/10""), (""10/2"")) == (false));
    assert(simplify((""2/10""), (""50/10"")) == (true));
    assert(simplify((""7/2""), (""4/2"")) == (true));
    assert(simplify((""11/6""), (""6/1"")) == (true));
    assert(simplify((""2/3""), (""5/2"")) == (false));
    assert(simplify((""5/2""), (""3/5"")) == (false));
    assert(simplify((""2/4""), (""8/4"")) == (true));
    assert(simplify((""2/4""), (""4/2"")) == (true));
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //അവയെ യഥാക്രമം ക്രമീകരിക്കുക.    //കുറിപ്പ്: നിരവധി ഇനങ്ങള് ഉണ്ടെങ്കില് അവയുടെ സംഖ്യകളുടെ തുക സമാനമാണെങ്കില്,    //അവരുടെ അക്കങ്ങളുടെ സംഖ്യ അനുസരിച്ച് ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം ക്രമം    //ഒരു ഫങ്ഷൻ എഴുതുക, അത് തന്നിരിക്കുന്ന സംഖ്യകളുടെ പട്ടികയെ തരം തിരിക്കുക.    // >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))
    // (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))
    // >>> orderByPoints((List[Long]()))
    // (List[Long]())
    def orderByPoints(nums : List[Long]) : List[Long] = {
","def orderByPoints(nums: List[Long]): List[Long] = {
    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum
    
    nums.zipWithIndex
      .sortBy { case (num, index) => (digitSum(num), index) }
      .map(_._1)
  }
}","    }
    def main(args: Array[String]) = {
    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));
    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));
    assert(orderByPoints((List[Long]())).equals((List[Long]())));
    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));
    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));
    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));
    }

}
"
HumanEval_146,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //ഒരു സംഖ്യയുടെ ആദ്യത്തെയും അവസാനത്തെയും അക്കം ഒറ്റക്കാണ് (1, 3, 5, 7, 9).    //പട്ടികയിലെ 10 ല് കൂടുതലുള്ള മൂലകങ്ങളുടെ എണ്ണം, രണ്ടും     //ഒരു സംഖ്യകളുടെ പട്ടികയെ ഇൻപുട്ടായി എടുത്ത് റിട്ടേൺ ചെയ്യുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.    // >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))
    // (1l)
    // >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))
    // (2l)
    def specialFilter(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def specialFilter(nums: List[Long]): Long = {
    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
    
    nums.count { num =>
      val absNumStr = num.abs.toString
      val firstDigit = absNumStr.head
      val lastDigit = absNumStr.last
      
      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)
    }.toLong
  }

  def main(args: Array[String]): Unit = {
    println(specialFilter(List(15L, -73L, 14L, -15L))) // Output: 1
    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) // Output: 2
  }
}","    }
    def main(args: Array[String]) = {
    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));
    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));
    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));
    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));
    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));
    assert(specialFilter((List[Long](1l.toLong))) == (0l));
    assert(specialFilter((List[Long]())) == (0l));
    }

}
"
HumanEval_147,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:    //പിന്നെ a[i] + a[j] + a[k] എന്നത് 3 ന്റെ ഗുണിതമാണ്.    //i < j < k,  എന്നതിന്റെ ട്രിപ്പിൾ എണ്ണം (a[i], a[j], a[k]) തിരികെ നൽകുക    //ഓരോ i-നും (1 ≤ i ≤ n) a[i] = i * i - i + 1 ന്റെ മൂല്യം    //നിങ്ങള് ക്ക് ഒരു പോസിറ്റീവ് ഇന്റര് നമ്പര് n കിട്ടും. നിങ്ങള് ഒരു ഇന്റര് ലിസ്റ്റ് ഉണ്ടാക്കണം a നീളം n ന്റെ.    // >>> getMaxTriples((5l))
    // (1l)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    def getMaxTriples(n : Long) : Long = {
","def getMaxTriples(n: Long): Long = {
    val a = (1L to n).map(i => i * i - i + 1).toList
    var count = 0L

    for {
      i <- 0L until n
      j <- i + 1 until n
      k <- j + 1 until n
    } {
      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(getMaxTriples((5l)) == (1l));
    assert(getMaxTriples((6l)) == (4l));
    assert(getMaxTriples((10l)) == (36l));
    assert(getMaxTriples((100l)) == (53361l));
    }

}
"
HumanEval_148,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //ഗ്രഹങ്ങളുടെ ശരിയായ പേരുകളല്ല.    //ഫങ്ഷൻ ഒരു ശൂന്യമായ ട്യൂപ്പൽ നൽകണം planet1 അല്ലെങ്കിൽ planet2     //സൂര്യന് അടുത്തു നിൽക്കുന്നതിനാല് .    //ഗ്രഹത്തിന്റെ ഭ്രമണപഥത്തിനും ഗ്രഹത്തിന്റെ ഭ്രമണപഥത്തിനും ഇടയിലുള്ള സ്ഥലം,     //ഈ ഫങ്ഷൻ                                        //ഗ്രഹം 1, ഗ്രഹം 2 എന്നീ സ്ട്രിങ്ങുകളായി രണ്ടു ഗ്രഹങ്ങളുടെ പേരുകൾ എടുക്കുന്ന ഒരു ഫങ്ഷൻ എഴുതുക.    //യുറാനസ്, നെപ്റ്റ്യൂൺ.    //അടുത്തത് ശുക്രനും, പിന്നെ ഭൂമിയും, ചൊവ്വയും, വ്യാഴവും, ശനിയും,    //നമ്മുടെ സൌരയൂഥത്തില് എട്ടു ഗ്രഹങ്ങളുണ്ട്: സൂര്യന് ഏറ്റവും അടുത്തുള്ളവ.    // >>> bf((""Jupiter""), (""Neptune""))
    // (List[String](""Saturn"", ""Uranus""))
    // >>> bf((""Earth""), (""Mercury""))
    // (List[String](""Venus""))
    // >>> bf((""Mercury""), (""Uranus""))
    // (List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))
    def bf(planet1 : String, planet2 : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def bf(planet1: String, planet2: String): List[String] = {
    val planets = List(""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    
    // Find the indices of the given planets
    val index1Opt = planets.indexOf(planet1)
    val index2Opt = planets.indexOf(planet2)
    
    // If either planet is not found, return an empty list
    if (index1Opt == -1 || index2Opt == -1) {
      return List.empty
    }
    
    // Sort indices to ensure proper traversal direction
    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)
    
    // Get the planets between the indices
    planets.slice(startIndex + 1, endIndex)
  }
}","    }
    def main(args: Array[String]) = {
    assert(bf((""Jupiter""), (""Neptune"")).equals((List[String](""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Mercury"")).equals((List[String](""Venus""))));
    assert(bf((""Mercury""), (""Uranus"")).equals((List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))));
    assert(bf((""Neptune""), (""Venus"")).equals((List[String](""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Earth"")).equals((List[String]())));
    assert(bf((""Mars""), (""Earth"")).equals((List[String]())));
    assert(bf((""Jupiter""), (""Makemake"")).equals((List[String]())));
    }

}
"
HumanEval_149,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //എല്ലാ വാക്കുകളും ഒരേ നീളമുള്ളതാണെന്ന് നിങ്ങള് വിചാരിച്ചേക്കാം.    //ഫങ്ഷൻ ഒരു പട്ടിക തിരികെ നൽകണം.    //രണ്ടു വാക്കുകള് ക്ക് ഒരേ നീളം ഉണ്ടെങ്കില് , പട്ടിക അക്ഷരമാലാ ക്രമത്തില് അടുക്കുക.    //ആ നിയമം അനുസരിച്ച് പട്ടിക തിരിച്ച് കൊടുക്കണം.    //ലിസ്റ്റിന്റെ ക്രമം ഓരോ വാക്കിന്റെയും നീളത്തിനനുസരിച്ച് ഉയരുകയാണ് വേണ്ടത്, പിന്നെ നിങ്ങള്     //ഇതില് തനിപ്പകർപ്പുകള് ഉണ്ടായിരിക്കാം.    //ലിസ്റ്റ് എപ്പോഴും സ്ട്രിങ്ങുകളുടെ ഒരു ലിസ്റ്റാണ്, ഒരിക്കലും സംഖ്യകളുടെ ഒരു ലിസ്റ്റല്ല,    //  ഒരു തരംതിരിക്കപ്പെട്ട പട്ടികയുമായി ഫലമായി ലഭിച്ച പട്ടിക തിരികെ നൽകുന്നു,    //അതിൽ നിന്നും അപൂർവ്വ ദൈർഘ്യമുള്ള സ്ട്രിങ്ങുകൾ ഇല്ലാതാക്കുന്നു,     //ഒരു സ്ട്രിംഗ് ലിസ്റ്റ് ഒരു പാരാമീറ്ററായി സ്വീകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക,    // >>> listSort((List[String](""aa"", ""a"", ""aaa"")))
    // (List[String](""aa""))
    // >>> listSort((List[String](""ab"", ""a"", ""aaa"", ""cd"")))
    // (List[String](""ab"", ""cd""))
    def sortedListSum(lst : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def listSort(lst: List[String]): List[String] = {
        lst.filter(_.length % 2 == 0)
           .sorted
           .sortBy(_.length)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortedListSum((List[String](""aa"", ""a"", ""aaa""))).equals((List[String](""aa""))));
    assert(sortedListSum((List[String](""school"", ""AI"", ""asdf"", ""b""))).equals((List[String](""AI"", ""asdf"", ""school""))));
    assert(sortedListSum((List[String](""d"", ""b"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""d"", ""dcba"", ""abcd"", ""a""))).equals((List[String](""abcd"", ""dcba""))));
    assert(sortedListSum((List[String](""AI"", ""ai"", ""au""))).equals((List[String](""AI"", ""ai"", ""au""))));
    assert(sortedListSum((List[String](""a"", ""b"", ""b"", ""c"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""aaaa"", ""bbbb"", ""dd"", ""cc""))).equals((List[String](""cc"", ""dd"", ""aaaa"", ""bbbb""))));
    }

}
"
HumanEval_150,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //ഒരു പ്രൈം നമ്പർ ആണ്, y ന്റെ മൂല്യം തിരികെ നൽകണം.    //n ന്റെ മൂല്യം  ആണെങ്കിൽ x ന്റെ മൂല്യം തിരികെ നൽകുന്ന ഒരു ലളിതമായ പ്രോഗ്രാം.    // >>> xOrY((7l), (34l), (12l))
    // (34l)
    // >>> xOrY((15l), (8l), (5l))
    // (5l)
    def xOrY(n : Long, x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def isPrime(num: Long): Boolean = {
    if (num <= 1) return false
    if (num <= 3) return true
    if (num % 2 == 0 || num % 3 == 0) return false
    var i = 5
    while (i * i <= num) {
      if (num % i == 0 || num % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def xOrY(n: Long, x: Long, y: Long): Long = {
    if (isPrime(n)) x else y
  }
}","    }
    def main(args: Array[String]) = {
    assert(xOrY((7l), (34l), (12l)) == (34l));
    assert(xOrY((15l), (8l), (5l)) == (5l));
    assert(xOrY((3l), (33l), (5212l)) == (33l));
    assert(xOrY((1259l), (3l), (52l)) == (3l));
    assert(xOrY((7919l), (-1l), (12l)) == (-1l));
    assert(xOrY((3609l), (1245l), (583l)) == (583l));
    assert(xOrY((91l), (56l), (129l)) == (129l));
    assert(xOrY((6l), (34l), (1234l)) == (1234l));
    assert(xOrY((1l), (2l), (0l)) == (0l));
    assert(xOrY((2l), (2l), (0l)) == (2l));
    }

}
"
HumanEval_151,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //നെഗറ്റീവ് ആയതോ പൂർണ്ണസംഖ്യകളല്ലാത്തതോ ആയ സംഖ്യകളെ അവഗണിക്കുക.    //ഒരു സംഖ്യകളുടെ പട്ടിക കൊടുത്താൽ, സംഖ്യകളുടെ സമചതുരങ്ങളുടെ തുക തിരിച്ചു കൊടുക്കുക.    // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))
    // (10l)
    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))
    // (0l)
    // >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))
    // (81l)
    // >>> doubleTheDifference((List[Float](0l.toLong)))
    // (0l)
    // If the input list is empty, return 0.
    def doubleTheDifference(lst : List[Float]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doubleTheDifference(lst: List[Float]): Long = {
    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)
      .map(x => x.toLong * x.toLong)
      .sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(doubleTheDifference((List[Float]())) == (0l));
    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));
    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));
    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));
    }

}
"
HumanEval_152,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:    //മൂല്യം 0 ആണെങ്കില് , അത് ഇല്ലെങ്കില് , അത് ഊഹവും സ്കോറും തമ്മിലുള്ള അബ്സലൂട്ട് വ്യത്യാസമാണ്.    //ഓരോ ഊഹവും എത്ര ദൂരം അകലെയാണെന്ന് സൂചിപ്പിക്കുന്ന അതേ നീളമുള്ള ഒരു ലിസ്റ്റ് തിരികെ നൽകുക.    //നിങ്ങള് ക്ക് രണ്ട് ലിസ്റ്റുകള് ലഭിക്കും, അവയില് സ്കോറുകളും ഊഹങ്ങളും ഉണ്ടാകും, അവയുടെ നീളം തുല്യമായിരിക്കും, ഓരോ സൂചികയിലും ഒരു പൊരുത്തം കാണിക്കും.    //നിങ്ങളുടെ ജോലി ഒരു വ്യക്തി ശരിയായി മത്സരങ്ങൾ ഒരു എണ്ണം ഫലങ്ങൾ ഊഹിച്ചു എന്ന് നിർണ്ണയിക്കാൻ ആണ്.    //ഇത് ശ്രദ്ധിക്കുകയും താരതമ്യം ചെയ്യുകയും ചെയ്യേണ്ടതാണ്.    //ആ നിമിഷം നിങ്ങള് ക്ക് തോന്നിയ വികാരങ്ങളും ചിന്തകളും    //നമ്മള് എല്ലാവരും ആ വികാരത്തെ ഓര് ക്കുന്നുണ്ടാവും ,    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))
    // (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))
    // >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))
    // (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))
    def compare(game : List[Long], guess : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def compare(game: List[Long], guess: List[Long]): List[Long] = {
    game.zip(guess).map { case (g, gs) => abs(g - gs) }
  }
}","    }
    def main(args: Array[String]) = {
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));
    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));
    }

}
"
HumanEval_153,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //(അതിന്റെ ശക്തി - 1 ആണ്).    //'Slices.SERVINGSliCes' എന്ന പദം തിരിച്ചു നൽകുക, കാരണം 'SERVINGSliCes' ആണ് ഏറ്റവും ശക്തമായ എക്സ്റ്റൻഷൻ.    //['സെര്വിന്ഗ്സ്ലിചെസ്', 'ചീസ്', 'സ്റ്റുഫെഡ്'] എന്നിങ്ങനെ വിപുലീകരണങ്ങളുണ്ടെങ്കിൽ നിങ്ങൾ     //ഉദാഹരണത്തിന്, നിങ്ങൾക്ക് ""സ്ലൈസുകൾ"" എന്ന ക്ലാസും ന്റെ ഒരു ലിസ്റ്റും നൽകിയിട്ടുണ്ടെങ്കിൽ    //ലിസ്റ്റിലെ ആദ്യത്തേത് തിരഞ്ഞെടുക്കുക.    //ഒരേ ശക്തി ഉള്ള രണ്ടോ അതിലധികമോ എക്സ്റ്റൻഷനുകൾ ഉണ്ടെങ്കിൽ, നിങ്ങൾ     //ഫോർമാറ്റ്: ക്ലാസ് നാമം. ഏറ്റവും ശക്തമായ വിപുലീകരണ നാമം.     //നിങ്ങള് ഏറ്റവും ശക്തമായ വിപുലീകരണം കണ്ടെത്തി ഇതില് ഒരു സ്ട്രിംഗ് തിരികെ നല് കണം.    //വിപുലീകരണത്തിന്റെ പേരില് , CAP - SM എന്ന സംഖ്യയില് നിന്നാണ് ശക്തി ലഭിക്കുന്നത്.    //എക്സ്റ്റൻഷന്റെ പേരിന്റെ അക്ഷരങ്ങൾ, SM എന്നത് ചെറിയ അക്ഷരങ്ങളുടെ എണ്ണം     //വിപുലീകരണത്തിന്റെ ശക്തി ഇപ്രകാരമാണ്: CAP എന്നത് വലിയ അക്ഷരങ്ങളുടെ സംഖ്യയായിരിക്കട്ടെ     //ക്ലാസ്സിലേക്ക് അധിക ക്ലാസുകൾ ലോഡ് ചെയ്യുന്നതിനാണ് വിപുലീകരണങ്ങൾ ഉപയോഗിക്കുന്നത്.    //നിങ്ങള് ക്ക് ഒരു ക്ലാസിന്റെ പേരും (ഒരു സ്ട്രിംഗ്) എക്സ്റ്റന് ഷനുകളുടെ ഒരു ലിസ്റ്റും ലഭിക്കും.    // >>> StrongestExtension((""my_class""), (List[String](""AA"", ""Be"", ""CC"")))
    // (""my_class.AA"")
    def StrongestExtension(class_name : String, extensions : List[String]) : String = {
","def StrongestExtension(class_name: String, extensions: List[String]): String = {
        extensions.map { extension =>
            val capCount = extension.count(_.isUpper)
            val lowerCount = extension.count(_.isLower)
            val strength = capCount - lowerCount
            (extension, strength)
        }.maxBy(_._2)._1
    } match {
        case strongest => s""$class_name.$strongest""
    }
}","    }
    def main(args: Array[String]) = {
    assert(StrongestExtension((""Watashi""), (List[String](""tEN"", ""niNE"", ""eIGHt8OKe""))).equals((""Watashi.eIGHt8OKe"")));
    assert(StrongestExtension((""Boku123""), (List[String](""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""))).equals((""Boku123.YEs.WeCaNe"")));
    assert(StrongestExtension((""__YESIMHERE""), (List[String](""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""))).equals((""__YESIMHERE.NuLl__"")));
    assert(StrongestExtension((""K""), (List[String](""Ta"", ""TAR"", ""t234An"", ""cosSo""))).equals((""K.TAR"")));
    assert(StrongestExtension((""__HAHA""), (List[String](""Tab"", ""123"", ""781345"", ""-_-""))).equals((""__HAHA.123"")));
    assert(StrongestExtension((""YameRore""), (List[String](""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""))).equals((""YameRore.okIWILL123"")));
    assert(StrongestExtension((""finNNalLLly""), (List[String](""Die"", ""NowW"", ""Wow"", ""WoW""))).equals((""finNNalLLly.WoW"")));
    assert(StrongestExtension((""_""), (List[String](""Bb"", ""91245""))).equals((""_.Bb"")));
    assert(StrongestExtension((""Sp""), (List[String](""671235"", ""Bb""))).equals((""Sp.671235"")));
    }

}
"
HumanEval_154,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //നിങ്ങള് ക്ക് 2 വാക്കുകള് നല് കിയിട്ടുണ്ട്. രണ്ടാമത്തെ വാക്ക് അല്ലെങ്കില് അതില് ഏതെങ്കിലും ഒരു ഭ്രമണം ആദ്യത്തെ വാക്ക് യിലെ ഒരു സബ് സ്ട്രിംഗ് ആണെങ്കില് നിങ്ങള് true തിരിച്ച് നല് കണം.    // >>> cycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> cycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> cycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> cycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> cycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> cycpatternCheck((""himenss""), (""simen""))
    // (true)
    def cycpatternCheck(a : String, b : String) : Boolean = {
","def cycpatternCheck(a: String, b: String): Boolean = {
  val bLength = b.length
  val bDouble = b + b // Create a string with b concatenated with itself to represent all rotations
  for (i <- 0 until bLength) {
    val rotation = bDouble.substring(i, i + bLength) // Get the current rotation
    if (a.contains(rotation)) return true
  }
  false
}","    }
    def main(args: Array[String]) = {
    assert(cycpatternCheck((""xyzw""), (""xyw"")) == (false));
    assert(cycpatternCheck((""yello""), (""ell"")) == (true));
    assert(cycpatternCheck((""whattup""), (""ptut"")) == (false));
    assert(cycpatternCheck((""efef""), (""fee"")) == (true));
    assert(cycpatternCheck((""abab""), (""aabb"")) == (false));
    assert(cycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //ഒരു പൂർണ്ണസംഖ്യ ലഭിച്ചാൽ, യഥാക്രമം ഇരട്ടയും അസംഖ്യം അക്കങ്ങളും ഉള്ള ഒരു ടപ്പിൾ തിരികെ നൽകുക.    // >>> evenOddCount((-12l))
    // ((1l, 1l))
    // >>> evenOddCount((123l))
    // ((1l, 2l))
    def evenOddCount(num : Long) : Tuple2[Long, Long] = {
","def evenOddCount(num: Long): Tuple2[Long, Long] = {
  val digits = num.abs.toString.map(_.asDigit)
  val evenCount = digits.count(_ % 2 == 0).toLong
  val oddCount = digits.count(_ % 2 != 0).toLong
  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddCount((7l)).equals(((0l, 1l))));
    assert(evenOddCount((-78l)).equals(((1l, 1l))));
    assert(evenOddCount((3452l)).equals(((2l, 2l))));
    assert(evenOddCount((346211l)).equals(((3l, 3l))));
    assert(evenOddCount((-345821l)).equals(((3l, 3l))));
    assert(evenOddCount((-2l)).equals(((1l, 0l))));
    assert(evenOddCount((-45347l)).equals(((2l, 3l))));
    assert(evenOddCount((0l)).equals(((1l, 0l))));
    }

}
"
HumanEval_156,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങള്:     //പരിമിതികൾ: 1 <= num <= 1000     //ചെറിയ അക്ഷരങ്ങളില് അത് തിരിച്ചു കൊടുക്കുക.    //ഒരു പോസിറ്റീവ് പൂർണ്ണസംഖ്യ ലഭിച്ചാൽ, അതിന്റെ റോമൻ സംഖ്യാ തുല്യത ഒരു സ്ട്രിംഗായി ലഭിക്കും,     // >>> intToMiniRoman((19l))
    // (""xix"")
    // >>> intToMiniRoman((152l))
    // (""clii"")
    // >>> intToMiniRoman((426l))
    // (""cdxxvi"")
    def intToMiniRoman(number : Long) : String = {
","import scala.collection.mutable._

object Problem {
  def intToMiniRoman(number: Long): String = {
    val romanMap: List[(Int, String)] = List(
      (1000, ""m""),
      (900, ""cm""),
      (500, ""d""),
      (400, ""cd""),
      (100, ""c""),
      (90, ""xc""),
      (50, ""l""),
      (40, ""xl""),
      (10, ""x""),
      (9, ""ix""),
      (5, ""v""),
      (4, ""iv""),
      (1, ""i"")
    )

    var num = number.toInt
    val stringBuilder = new StringBuilder

    for ((value, roman) <- romanMap) {
      while (num >= value) {
        stringBuilder.append(roman)
        num -= value
      }
    }

    stringBuilder.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(intToMiniRoman((19l)).equals((""xix"")));
    assert(intToMiniRoman((152l)).equals((""clii"")));
    assert(intToMiniRoman((251l)).equals((""ccli"")));
    assert(intToMiniRoman((426l)).equals((""cdxxvi"")));
    assert(intToMiniRoman((500l)).equals((""d"")));
    assert(intToMiniRoman((1l)).equals((""i"")));
    assert(intToMiniRoman((4l)).equals((""iv"")));
    assert(intToMiniRoman((43l)).equals((""xliii"")));
    assert(intToMiniRoman((90l)).equals((""xc"")));
    assert(intToMiniRoman((94l)).equals((""xciv"")));
    assert(intToMiniRoman((532l)).equals((""dxxxii"")));
    assert(intToMiniRoman((900l)).equals((""cm"")));
    assert(intToMiniRoman((994l)).equals((""cmxciv"")));
    assert(intToMiniRoman((1000l)).equals((""m"")));
    }

}
"
HumanEval_157,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //90 ഡിഗ്രി     //ഒരു വലതു കോണുള്ള ത്രികോണം ഒരു കോണും വലതു കോണുള്ള ത്രികോണമാണ്.    //വശങ്ങള് ഒരു വലതു കോണുള്ള ത്രികോണം ഉണ്ടാക്കുന്നു, അല്ലാത്തപക്ഷം തെറ്റാണ്.    //ത്രികോണത്തിന്റെ മൂന്നു വശങ്ങളുടെ നീളം കണക്കിലെടുക്കുക. ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രികോണത്തിന്റെ ത്രണം    // >>> rightAngleTriangle((3l), (4l), (5l))
    // (true)
    // >>> rightAngleTriangle((1l), (2l), (3l))
    // (false)
    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {
","def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {
        val sides = List(a, b, c).sorted
        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)
    }
}","    }
    def main(args: Array[String]) = {
    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));
    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));
    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));
    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));
    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));
    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));
    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));
    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));
    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));
    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));
    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));
    }

}
"
HumanEval_158,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //അക്ഷരങ്ങളുടെ ക്രമത്തിൽ ആദ്യം വരുന്ന അക്ഷരമാണ് തിരികെ നൽകുക.    //ഒന്നിലധികം സ്ട്രിങ്ങുകൾക്ക് പരമാവധി എണ്ണം ഉണ്ടെങ്കിൽ,    //ലിസ്റ്റിൽ വ്യത്യസ്ത പദങ്ങളുണ്ട്. പരമാവധി എണ്ണം ഉപയോഗിച്ച് പദം തിരികെ നൽകുക.    //സ്ട്രിങ്ങുകളുടെ ഒരു ലിസ്റ്റ് സ്വീകരിക്കുന്ന ഒരു ഫംഗ്ഷൻ എഴുതുക.    // >>> findMax((List[String](""name"", ""of"", ""string"")))
    // (""string"")
    // >>> findMax((List[String](""name"", ""enam"", ""game"")))
    // (""enam"")
    // >>> findMax((List[String](""aaaaaaa"", ""bb"", ""cc"")))
    // (""aaaaaaa"")
    def findMax(words : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findMax(words: List[String]): String = {
    words.maxBy(word => (word.toSet.size, -word.toLowerCase))
  }
}","    }
    def main(args: Array[String]) = {
    assert(findMax((List[String](""name"", ""of"", ""string""))).equals((""string"")));
    assert(findMax((List[String](""name"", ""enam"", ""game""))).equals((""enam"")));
    assert(findMax((List[String](""aaaaaaa"", ""bb"", ""cc""))).equals((""aaaaaaa"")));
    assert(findMax((List[String](""abc"", ""cba""))).equals((""abc"")));
    assert(findMax((List[String](""play"", ""this"", ""game"", ""of"", ""footbott""))).equals((""footbott"")));
    assert(findMax((List[String](""we"", ""are"", ""gonna"", ""rock""))).equals((""gonna"")));
    assert(findMax((List[String](""we"", ""are"", ""a"", ""mad"", ""nation""))).equals((""nation"")));
    assert(findMax((List[String](""this"", ""is"", ""a"", ""prrk""))).equals((""this"")));
    assert(findMax((List[String](""b""))).equals((""b"")));
    assert(findMax((List[String](""play"", ""play"", ""play""))).equals((""play"")));
    }

}
"
HumanEval_159,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണം:     //മതിയായ കാരറ്റ് ബാക്കിയുണ്ടെങ്കിൽ, ബാക്കിയുള്ള കാരറ്റ് മുഴുവനും കഴിക്കും, പക്ഷേ ഇപ്പോഴും വിശപ്പ് അനുഭവപ്പെടും.    //നിങ്ങളുടെ ഭക്ഷണത്തിനു ശേഷം അവശേഷിക്കുന്ന കാരറ്റ് എണ്ണം ]     //[ ഭക്ഷണത്തിനു ശേഷം കഴിച്ച മൊത്തം കാരറ്റ് എണ്ണം ]    //പക്ഷേ, ഇന്ന് നീ കൂടുതൽ കാരറ്റ് കഴിക്കണം.    //നീ ഒരു വിശന്ന മുയലാണ്, നീ ഇതിനകം ഒരു നിശ്ചിത എണ്ണം കാരറ്റ് കഴിച്ചു,    // >>> eat((5l), (6l), (10l))
    // (List[Long](11l.toLong, 4l.toLong))
    // >>> eat((4l), (8l), (9l))
    // (List[Long](12l.toLong, 1l.toLong))
    // >>> eat((1l), (10l), (10l))
    // (List[Long](11l.toLong, 0l.toLong))
    // >>> eat((2l), (11l), (5l))
    // (List[Long](7l.toLong, 0l.toLong))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def eat(number: Long, need: Long, remaining: Long): List[Long] = {
    val totalNeeded = number + need
    if (remaining >= need) {
      List(totalNeeded, remaining - need)
    } else {
      List(number + remaining, 0)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));
    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));
    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));
    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));
    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));
    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));
    }

}
"
HumanEval_160,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഓപ്പറേറ്റർ ലിസ്റ്റിൽ കുറഞ്ഞത് ഒരു ഓപ്പറേറ്ററും ഓപ്പറന്റ് ലിസ്റ്റിൽ കുറഞ്ഞത് രണ്ട് ഓപ്പറന്റുകളും ഉണ്ടായിരിക്കണം.    //ഓപ്പറാന്റ് എന്നത് നെഗറ്റീവ് അല്ലാത്ത സംഖ്യകളുടെ ഒരു പട്ടികയാണ്.    //ഓപ്പറേറ്റർ ലിസ്റ്റിന്റെ നീളം ഓപ്പറന്റ് ലിസ്റ്റിന്റെ നീളം കുറച്ചാൽ ഒന്നിന് തുല്യമാണ്.    //കുറിപ്പ്:    //=> ഫലം = 9     //ഫലം = 2 + 3 * 4 - 5     //പട്ടിക = [2, 3, 4, 5]     //ഓപ്പറേറ്റർ ['+', '*', '-']     //ഉദാഹരണം:     //എക്സ്പോണന്ഷ്യേഷൻ (**) യും    //നിലവിളക്കുകൾ (    //ഗുണനം (*)     //കുറയ്ക്കല് ( - )     //കൂട്ടിച്ചേര് ത്തു (+)     //അടിസ്ഥാന അല് ജ്ബെറ പ്രവർത്തനങ്ങൾ:    //ഈ എക്സ്പ്രഷന്റെ വിലയിരുത്തൽ തിരികെ നൽകുക.    //രണ്ടാമത്തെ പട്ടിക പൂർണ്ണസംഖ്യകളുടെ പട്ടികയാണ്.    //രണ്ട് ലിസ്റ്റുകൾ ഓപ്പറേറ്ററും ഓപ്പറാന്റും. ആദ്യ ലിസ്റ്റിൽ അടിസ്ഥാന ആൽജെബ്രാ പ്രവർത്തനങ്ങൾ ഉണ്ട്, കൂടാതെ     def doAlgebra(op : List[String], operand : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doAlgebra(op: List[String], operand: List[Long]): Long = {
    var result = operand.head
    for (i <- 0 until op.length) {
      op(i) match {
        case ""+"" => result += operand(i + 1)
        case ""-"" => result -= operand(i + 1)
        case ""*"" => result *= operand(i + 1)
        case ""//"" => result /= operand(i + 1)
        case ""**"" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong
      }
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val operators = List(""+"", ""*"", ""-"")
    val operands = List(2L, 3L, 4L, 5L)
    println(doAlgebra(operators, operands)) // Output: 9
  }
}","    }
    def main(args: Array[String]) = {
    assert(doAlgebra((List[String](""**"", ""*"", ""+"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));
    assert(doAlgebra((List[String](""+"", ""*"", ""-"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));
    assert(doAlgebra((List[String](""//"", ""*"")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));
    }

}
"
HumanEval_161,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണങ്ങൾ     //ഫങ്ഷൻ കിട്ടിയ സ്ട്രിംഗ് തിരിച്ചു കൊടുക്കണം.    //സ്ട്രിങ്ങിൽ അക്ഷരങ്ങളൊന്നും ഇല്ലെങ്കിൽ, സ്ട്രിങ് വിപരീതമാക്കുക.    //അല്ലെങ്കില് , അത് ഇങ്ങനെയായി തുടരുക.    //s[i] ഒരു അക്ഷരമാണെങ്കിൽ, അതിന്റെ കേസ് താഴേ നിന്ന് മുകളിലേക്ക് അല്ലെങ്കിൽ തിരിച്ചും,     //നിങ്ങള് ക്ക് ഒരു സ്ട്രിംഗ് ലഭിക്കുന്നു.    // >>> solve((""1234""))
    // (""4321"")
    // >>> solve((""ab""))
    // (""AB"")
    // >>> solve((""#a@C""))
    // (""#A@c"")
    def solve(s : String) : String = {
","def solve(s: String): String = {
    if (s.exists(_.isLetter)) {
      s.map {
        case c if c.isLetter && c.isLower => c.toUpper
        case c if c.isLetter && c.isUpper => c.toLower
        case c => c
      }.mkString
    } else {
      s.reverse
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(solve((""AsDf"")).equals((""aSdF"")));
    assert(solve((""1234"")).equals((""4321"")));
    assert(solve((""ab"")).equals((""AB"")));
    assert(solve((""#a@C"")).equals((""#A@c"")));
    assert(solve((""#AsdfW^45"")).equals((""#aSDFw^45"")));
    assert(solve((""#6@2"")).equals((""2@6#"")));
    assert(solve((""#$a^D"")).equals((""#$A^d"")));
    assert(solve((""#ccc"")).equals((""#CCC"")));
    }

}
"
HumanEval_162,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //'text' ഒരു ശൂന്യമായ സ്ട്രിംഗ് ആണെങ്കിൽ, None തിരികെ നൽകുക.    //ഒരു സ്ട്രിംഗ് 'ടെക്സ്റ്റ്' നൽകിയിട്ടുണ്ടെങ്കിൽ, അതിന്റെ md5 ഹാഷ് തുല്യമായ സ്ട്രിംഗ് നൽകുക.    // >>> stringToMd5((""Hello world""))
    // Some(""3e25960a79dbc69b674cd4ec67a72c62"")
    def stringToMd5(text : String) : Option[String] = {
","import java.security.MessageDigest

object Problem {
  def stringToMd5(text: String): Option[String] = {
    if (text.isEmpty) None
    else {
      val md = MessageDigest.getInstance(""MD5"")
      val digest = md.digest(text.getBytes)
      Some(digest.map(""%02x"".format(_)).mkString)
    }
  }
}

// Example usage:
// println(Problem.stringToMd5(""Hello world""))  // Output: Some(""3e25960a79dbc69b674cd4ec67a72c62"")","    }
    def main(args: Array[String]) = {
    assert(stringToMd5((""Hello world"")).equals(Some(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert(stringToMd5(("""")).equals(None));
    assert(stringToMd5((""A B C"")).equals(Some(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert(stringToMd5((""password"")).equals(Some(""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,mal_Mlym,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ഉദാഹരണത്തിന്:     //b, ക്രമാനുഗതമായി.    //രണ്ട് പോസിറ്റീവ് പൂർണ്ണസംഖ്യകളായ a, b എന്നിവ നൽകിയിട്ടുണ്ടെങ്കിൽ, a  യും b യും തമ്മിലുള്ള സംഖ്യകളുടെ സംഖ്യകൾ തിരികെ നൽകുക.    // >>> generateIntegers((2l), (8l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((8l), (2l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((10l), (14l))
    // (List[Long]())
    def generateIntegers(a : Long, b : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def generateIntegers(a: Long, b: Long): List[Long] = {
    val start = min(a, b)
    val end = max(a, b)
    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i
    evenNumbers.map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((17l), (89l)).equals((List[Long]())));
    }

}
"
