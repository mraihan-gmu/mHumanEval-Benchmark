task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,als_Latn,ts,"//pragu i dhënë.//Kontrolloni nëse në një masë të caktuar të numrave, janë ndonjë dy numra më afër njëri-tjetrit se // >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
// false
// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
// true
function has_close_elements(numbers: number[], threshold: number): boolean {
","function has_close_elements(numbers: number[], threshold: number): boolean {
    for (let i = 0; i < numbers.length; i++) {
        for (let j = i + 1; j < numbers.length; j++) {
            if (Math.abs(numbers[i] - numbers[j]) < threshold) {
                return true;
            }
        }
    }
    return false;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = has_close_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),true);
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),false);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),true);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),false);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),false);
}

test();"
HumanEval_1,als_Latn,ts,"//Injoroni çdo hapësirë në varg të hyrjes.//Grupet e ndara janë të balancuara (çdo braç i hapur është i mbyllur siç duhet) dhe nuk janë të zhytur brenda njëri-tjetrit.//ndaje ato grupe në vargje të veçanta dhe ktheje rendin e atyre.//Input në këtë funksion është një varg që përmban grupe të shumta të parenteshëve të zhytur. Qëllimi juaj është që të // >>> separate_paren_groups(""( ) (( )) (( )( ))"")
// [""()"", ""(())"", ""(()())""]
function separate_paren_groups(paren_string: string): string[] {
","function separate_paren_groups(paren_string: string): string[] {
    const result: string[] = [];
    let currentGroup: string = """";
    let balance: number = 0;

    for (let char of paren_string) {
        if (char === ' ') {
            continue; // Ignore spaces
        }
        
        currentGroup += char;

        if (char === '(') {
            balance++;
        } else if (char === ')') {
            balance--;
        }

        if (balance === 0 && currentGroup.length > 0) {
            result.push(currentGroup);
            currentGroup = """";
        }
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = separate_paren_groups;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[""(()())"", ""((()))"", ""()"", ""((())()())""]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[""()"", ""(())"", ""((()))"", ""(((())))""]);
  assert.deepEqual(candidate(""(()(())((())))""),[""(()(())((())))""]);
  assert.deepEqual(candidate(""( ) (( )) (( )( ))""),[""()"", ""(())"", ""(()())""]);
}

test();"
HumanEval_2,als_Latn,ts,"//Kthehet pjesa decimale e numrit. //(pjesë e mbetur gjithmonë më e vogël se 1).//dhe pjesa e numrit të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe decimalët //Duke pasur parasysh një numër pozitiv të pikës së lëvizshme, ajo mund të dekompozohet në // >>> truncate_number(3.5)
// 0.5
function truncate_number(number: number): number {
","function truncate_number(number: number): number {
    const integerPart = Math.floor(number);
    return number - integerPart;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = truncate_number;
  assert.deepEqual(candidate(3.5),0.5);
  assert.deepEqual(candidate(1.25),0.25);
  assert.deepEqual(candidate(123.0),0.0);
}

test();"
HumanEval_3,als_Latn,ts,"//në atë pikë funksioni duhet të kthehet true. Përndryshe duhet të kthehet false. //Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe //Ju jepet një sërë operacionesh depozitimi dhe tërheqja në një llogari bankare që fillon me // >>> below_zero([1, 2, 3])
// false
// >>> below_zero([1, 2, -4, 5])
// true
function below_zero(operations: number[]): boolean {
","function below_zero(operations: number[]): boolean {
    let balance = 0;
    
    for (let operation of operations) {
        balance += operation;
        if (balance < 0) {
            return true;
        }
    }
    
    return false;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = below_zero;
  assert.deepEqual(candidate([]),false);
  assert.deepEqual(candidate([1, 2, -3, 1, 2, -3]),false);
  assert.deepEqual(candidate([1, 2, -4, 5, 6]),true);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -4]),false);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -5]),true);
  assert.deepEqual(candidate([1, -2, 2, -2, 5, -5, 4, -4]),true);
}

test();"
HumanEval_4,als_Latn,ts,"//MAD = mesatar. x - x_mean. //element dhe një pikë qendrore (mesatar në këtë rast): //Shkalla mesatare e devijimit absolut është diferenca mesatare absolute midis secilës prej tyre.//rreth mesatares së këtij grupi të të dhënave. //Për një masë të dhënë të numrave të hyrjes, llogaritet devijimi absolut mesatar // >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
// 1.0
function mean_absolute_deviation(numbers: number[]): number {
","function mean_absolute_deviation(numbers: number[]): number {
    const mean = numbers.reduce((acc, num) => acc + num, 0) / numbers.length;
    const absoluteDifferences = numbers.map(num => Math.abs(num - mean));
    const mad = absoluteDifferences.reduce((acc, diff) => acc + diff, 0) / numbers.length;
    return mad;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = mean_absolute_deviation;
  assert.deepEqual(candidate([1.0, 2.0]),0.5);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0]),1.0);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),1.2);
}

test();"
HumanEval_5,als_Latn,ts,"//Shkruani një numër ""delimitor"" midis çdo dy elementeve të njëpasnjëshme të masës së hyrjes ∀numra"" // >>> intersperse([], 4)
// []
// >>> intersperse([1, 2, 3], 4)
// [1, 4, 2, 4, 3]
function intersperse(numbers: number[], delimeter: number): number[] {
","function intersperse(numbers: number[], delimeter: number): number[] {
    if (numbers.length === 0) {
        return [];
    }

    let result: number[] = [];

    for (let i = 0; i < numbers.length; i++) {
        result.push(numbers[i]);
        if (i < numbers.length - 1) {
            result.push(delimeter);
        }
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = intersperse;
  assert.deepEqual(candidate([], 7),[]);
  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);
  assert.deepEqual(candidate([2, 2, 2], 2),[2, 2, 2, 2, 2]);
}

test();"
HumanEval_6,als_Latn,ts,"//Për shembull, (() (()) ka maksimumi dy nivele të gjidhënies ndërsa ((())) ka tre. //Për secilin grup, nxirrni nivelin më të thellë të fshikullimit të parantezave. //Input për këtë funksion është një varg përfaqësuar grupe të shumta për parantezat e mbështjellura të ndara nga hapësira.// >>> parse_nested_parens(""(()()) ((())) () ((())()())"")
// [2, 3, 1, 3]
function parse_nested_parens(paren_string: string): number[] {
","function parse_nested_parens(paren_string: string): number[] {
    return paren_string.split(' ').map(group => {
        let maxDepth = 0;
        let currentDepth = 0;

        for (const char of group) {
            if (char === '(') {
                currentDepth++;
                if (currentDepth > maxDepth) {
                    maxDepth = currentDepth;
                }
            } else if (char === ')') {
                currentDepth--;
            }
        }

        return maxDepth;
    });
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = parse_nested_parens;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[2, 3, 1, 3]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[1, 2, 3, 4]);
  assert.deepEqual(candidate(""(()(())((())))""),[4]);
}

test();"
HumanEval_7,als_Latn,ts,"//Filtrohet një renditje e hyrjes e vargjeve vetëm për ato që përmbajnë varg të caktuar // >>> filter_by_substring([], ""a"")
// []
// >>> filter_by_substring([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
// [""abc"", ""bacd"", ""array""]
function filter_by_substring(strings: string[], substring: string): string[] {
","function filter_by_substring(strings: string[], substring: string): string[] {
    return strings.filter(s => s.includes(substring));
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = filter_by_substring;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""),[""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""),[""grunt"", ""prune""]);
}

test();"
HumanEval_8,als_Latn,ts,"//Shuma e zbrazët duhet të jetë e barabartë me 0 dhe produkti i zbrazët duhet të jetë i barabartë me 1.//Për një masë të dhënë të integers, kthehet një masë që përbëhet nga një shuma dhe një produkt i të gjithë integers në një masë. // >>> sum_product([])
// [0, 1]
// >>> sum_product([1, 2, 3, 4])
// [10, 24]
function sum_product(numbers: number[]): [number, number] {
","function sum_product(numbers: number[]): [number, number] {
    const sum = numbers.reduce((acc, curr) => acc + curr, 0);
    const product = numbers.reduce((acc, curr) => acc * curr, 1);
    return [sum, product];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sum_product;
  assert.deepEqual(candidate([]),[0, 1]);
  assert.deepEqual(candidate([1, 1, 1]),[3, 1]);
  assert.deepEqual(candidate([100, 0]),[100, 0]);
  assert.deepEqual(candidate([3, 5, 7]),[15, 105]);
  assert.deepEqual(candidate([10]),[10, 10]);
}

test();"
HumanEval_9,als_Latn,ts,"//në rendin e duhur.//Nga një rend të dhënë të integers, gjenerojnë një rend të elementit të lartë të rrumbullakosjes gjetur deri në momentin e dhënë // >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
// [1, 2, 3, 3, 3, 4, 4]
function rolling_max(numbers: number[]): number[] {
","function rolling_max(numbers: number[]): number[] {
    let maxArray: number[] = [];
    let currentMax: number = Number.NEGATIVE_INFINITY;
    
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] > currentMax) {
            currentMax = numbers[i];
        }
        maxArray.push(currentMax);
    }

    return maxArray;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = rolling_max;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 1]),[4, 4, 4, 4]);
  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100]);
}

test();"
HumanEval_10,als_Latn,ts,"//- Shtoni në fund të rradhës së një prefiksi rradhës që vjen para sufixhit palindromik.//- Gjeni postfix më të gjatë të zinxhirit të furnizuar që është një palindrom. //Algoritmi është i thjeshtë://Gjeni palindromin më të shkurtër që fillon me një varg të dhënë. // >>> make_palindrome("""")
// """"
// >>> make_palindrome(""cat"")
// ""catac""
// >>> make_palindrome(""cata"")
// ""catac""
function make_palindrome(string: string): string {
","function make_palindrome(string: string): string {
    function isPalindrome(s: string): boolean {
        let left = 0;
        let right = s.length - 1;
        while (left < right) {
            if (s[left] !== s[right]) return false;
            left++;
            right--;
        }
        return true;
    }

    const n = string.length;
    let longestPalindromicPostfixIndex = n;

    for (let i = 0; i < n; i++) {
        if (isPalindrome(string.substring(i))) {
            longestPalindromicPostfixIndex = i;
            break;
        }
    }

    const prefix = string.substring(0, longestPalindromicPostfixIndex);
    const reversedPrefix = prefix.split('').reverse().join('');
    return string + reversedPrefix;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = make_palindrome;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""x""),""x"");
  assert.deepEqual(candidate(""xyz""),""xyzyx"");
  assert.deepEqual(candidate(""xyx""),""xyx"");
  assert.deepEqual(candidate(""jerry""),""jerryrrej"");
}

test();"
HumanEval_11,als_Latn,ts,"//Performo XOR binar në këto input dhe kthimi rezultat gjithashtu si një varg. //Input janë dy vargjet a dhe b që përbëhen vetëm nga 1s dhe 0s. // >>> string_xor(""010"", ""110"")
// ""100""
function string_xor(a: string, b: string): string {
","function string_xor(a: string, b: string): string {
    let result = '';
    for (let i = 0; i < a.length; i++) {
        result += (a[i] === b[i] ? '0' : '1');
    }
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = string_xor;
  assert.deepEqual(candidate(""111000"", ""101010""),""010010"");
  assert.deepEqual(candidate(""1"", ""1""),""0"");
  assert.deepEqual(candidate(""0101"", ""0000""),""0101"");
}

test();"
HumanEval_12,als_Latn,ts,"//kthim i pacaktuar në rast se matrici i hyrjes është bosh.//Nga një sërë vargjesh, kthehet më i gjati. Kthehet i pari në rast të shumëfishtës.// >>> longest([])
// undefined
// >>> longest([""a"", ""b"", ""c""])
// ""a""
// >>> longest([""a"", ""bb"", ""ccc""])
// ""ccc""
function longest(strings: string[]): string | undefined {
","function longest(strings: string[]): string | undefined {
    if (strings.length === 0) {
        return undefined;
    }

    let longestString = strings[0];

    for (const str of strings) {
        if (str.length > longestString.length) {
            longestString = str;
        }
    }

    return longestString;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = longest;
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""x"");
  assert.deepEqual(candidate([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]),""zzzz"");
}

test();"
HumanEval_13,als_Latn,ts,"//Kthehet një ndarësi më i madh i përbashkët i dy integers a dhe b // >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
function greatest_common_divisor(a: number, b: number): number {
","function greatest_common_divisor(a: number, b: number): number {
    while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = greatest_common_divisor;
  assert.deepEqual(candidate(3, 7),1);
  assert.deepEqual(candidate(10, 15),5);
  assert.deepEqual(candidate(49, 14),7);
  assert.deepEqual(candidate(144, 60),12);
}

test();"
HumanEval_14,als_Latn,ts,"//Kthehet një sërë i të gjitha prefikseve nga më e shkurta në më të gjata të vargjet e hyrjes // >>> all_prefixes(""abc"")
// [""a"", ""ab"", ""abc""]
function all_prefixes(string: string): string[] {
","function all_prefixes(string: string): string[] {
    const result: string[] = [];
    for (let i = 1; i <= string.length; i++) {
        result.push(string.substring(0, i));
    }
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = all_prefixes;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""asdfgh""),[""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""]);
  assert.deepEqual(candidate(""WWW""),[""W"", ""WW"", ""WWW""]);
}

test();"
HumanEval_15,als_Latn,ts,"//Kthen një varg që përmban numra të kufizuar me hapësirë duke filluar nga 0 deri n përfshirë. // >>> string_sequence(0)
// ""0""
// >>> string_sequence(5)
// ""0 1 2 3 4 5""
function string_sequence(n: number): string {
","function string_sequence(n: number): string {
    let result: string[] = [];
    for (let i = 0; i <= n; i++) {
        result.push(i.toString());
    }
    return result.join(' ');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = string_sequence;
  assert.deepEqual(candidate(0),""0"");
  assert.deepEqual(candidate(3),""0 1 2 3"");
  assert.deepEqual(candidate(10),""0 1 2 3 4 5 6 7 8 9 10"");
}

test();"
HumanEval_16,als_Latn,ts,"//Duke pasur parasysh një varg, gjeni sa karaktere të veçanta (pa marrë parasysh rastin) përbëhet nga // >>> count_distinct_characters(""xyzXYZ"")
// 3
// >>> count_distinct_characters(""Jerry"")
// 4
function count_distinct_characters(string: string): number {
","function count_distinct_characters(inputString: string): number {
    const lowerCasedString = inputString.toLowerCase();
    const distinctCharacters = new Set<string>();

    for (const char of lowerCasedString) {
        distinctCharacters.add(char);
    }

    return distinctCharacters.size;
}

// Example usage:
console.log(count_distinct_characters(""xyzXYZ"")); // Output: 3
console.log(count_distinct_characters(""Jerry""));  // Output: 4","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = count_distinct_characters;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abcde""),5);
  assert.deepEqual(candidate(""abcdecadeCADE""),5);
  assert.deepEqual(candidate(""aaaaAAAAaaaa""),1);
  assert.deepEqual(candidate(""Jerry jERRY JeRRRY""),5);
}

test();"
HumanEval_17,als_Latn,ts,"//""Hajde"" - nota e katërt, zgjat një ritëm.//'O saje' - gjysmë notë, zgjat dy rrahje.//'O' - nota e plotë, zgjat katër rrahje.//Ja një legjendë://Jo e fundit.//Detyra juaj është të analizojë këtë varg dhe të kthejë një sërë të integers korresponduar me sa goditjet bën secili //Input për këtë funksion është një varg që përfaqëson notat muzikore në një format të veçantë ASCII.// >>> parse_music(""o o| .| o| o| .| .| .| .| o o"")
// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
function parse_music(music_string: string): number[] {
","function parse_music(music_string: string): number[] {
    const notes = music_string.split(' ');
    return notes.map(note => {
        switch (note) {
            case 'o':
                return 4;
            case 'o|':
                return 2;
            case '.|':
                return 1;
            default:
                return 0;
        }
    });
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = parse_music;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""o o o o""),[4, 4, 4, 4]);
  assert.deepEqual(candidate("".| .| .| .|""),[1, 1, 1, 1]);
  assert.deepEqual(candidate(""o| o| .| .| o o o o""),[2, 2, 1, 1, 4, 4, 4, 4]);
  assert.deepEqual(candidate(""o| .| o| .| o o| o o|""),[2, 1, 2, 1, 4, 2, 4, 2]);
}

test();"
HumanEval_18,als_Latn,ts,"//Gjeni sa herë një nënstring i dhënë mund të gjendet në varg origjinal. Numëro rastet e mbivendosura. // >>> how_many_times("""", ""a"")
// 0
// >>> how_many_times(""aaa"", ""a"")
// 3
// >>> how_many_times(""aaaa"", ""aa"")
// 3
function how_many_times(string: string, substring: string): number {
","function how_many_times(string: string, substring: string): number {
    if (substring.length === 0) return 0;
    let count = 0;
    for (let i = 0; i <= string.length - substring.length; i++) {
        if (string.substring(i, i + substring.length) === substring) {
            count++;
        }
    }
    return count;
}

// Example usage:
// console.log(how_many_times(""aaa"", ""a"")); // Output: 3
// console.log(how_many_times(""aaaa"", ""aa"")); // Output: 3
// console.log(how_many_times("""", ""a"")); // Output: 0","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = how_many_times;
  assert.deepEqual(candidate("""", ""x""),0);
  assert.deepEqual(candidate(""xyxyxyx"", ""x""),4);
  assert.deepEqual(candidate(""cacacacac"", ""cac""),4);
  assert.deepEqual(candidate(""john doe"", ""john""),1);
}

test();"
HumanEval_19,als_Latn,ts,"//Kthehet një varg me numra të renditur nga më i vogël në më i madh //Zgjedhjet e vlefshme janë ""zero"", ""një"", ""dy"", ""tre"", ""katër"", ""pesë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"", ""gjashtë"" dhe ""nënjë"". //Input është një varg i numrave të kufizuar nga hapësira nga ""zero"" deri në ""nëntë"".// >>> sort_numbers(""three one five"")
// ""one three five""
function sort_numbers(numbers: string): string {
","function sort_numbers(numbers: string): string {
    const numberWords = [
        'zero', 'one', 'two', 'three', 'four', 
        'five', 'six', 'seven', 'eight', 'nine'
    ];
    
    // Split the input string into an array of words
    const wordsArray = numbers.split(' ');

    // Sort the wordsArray based on the index of each word in numberWords
    wordsArray.sort((a, b) => numberWords.indexOf(a) - numberWords.indexOf(b));

    // Join the sorted array back into a space-delimited string and return
    return wordsArray.join(' ');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sort_numbers;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""three""),""three"");
  assert.deepEqual(candidate(""three five nine""),""three five nine"");
  assert.deepEqual(candidate(""five zero four seven nine eight""),""zero four five seven eight nine"");
  assert.deepEqual(candidate(""six five four three two one zero""),""zero one two three four five six"");
}

test();"
HumanEval_20,als_Latn,ts,"//të tjera dhe i kthejnë në rend (numri më i vogël, numri më i madh).//Nga një sërë numrash të dhënë (me gjatësi të paktën dy) zgjidhni dhe ktheni dy që janë më të afërt me secilin // >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
// [2.0, 2.2]
// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
// [2.0, 2.0]
function find_closest_elements(numbers: number[]): [number, number] {
","function find_closest_elements(numbers: number[]): [number, number] {
    if (numbers.length < 2) {
        throw new Error(""Array must contain at least two numbers"");
    }

    // Sort the array so that we can check consecutive elements
    numbers.sort((a, b) => a - b);

    let closestPair: [number, number] = [numbers[0], numbers[1]];
    let minDifference = Math.abs(numbers[1] - numbers[0]);

    for (let i = 1; i < numbers.length - 1; i++) {
        let currentDifference = Math.abs(numbers[i + 1] - numbers[i]);
        if (currentDifference < minDifference) {
            minDifference = currentDifference;
            closestPair = [numbers[i], numbers[i + 1]];
        }
    }

    return closestPair;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = find_closest_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);
}

test();"
HumanEval_21,als_Latn,ts,"//kështu që numri më i vogël do të bëhet 0 dhe numri më i madh do të bëhet 1 //Duke pasur parasysh një sërë numrash (të paktën dy elementësh), aplikoni një transformim linear në atë sërë, // >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
// [0.0, 0.25, 0.5, 0.75, 1.0]
function rescale_to_unit(numbers: number[]): number[] {
","function rescale_to_unit(numbers: number[]): number[] {
    if (numbers.length < 2) {
        throw new Error(""Array must contain at least two elements"");
    }

    const min = Math.min(...numbers);
    const max = Math.max(...numbers);
    const range = max - min;

    if (range === 0) {
        throw new Error(""All numbers are the same; rescale not possible"");
    }

    return numbers.map(num => (num - min) / range);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = rescale_to_unit;
  assert.deepEqual(candidate([2.0, 49.9]),[0.0, 1.0]);
  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0]);
  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
}

test();"
HumanEval_22,als_Latn,ts,"//Filtrohet një sërë i dhënë i çdo vlere tsthon vetëm për numrat e plotë.// >>> filter_integers([""a"", 3.14, 5])
// [5]
// >>> filter_integers([1, 2, 3, ""abc"", {}, []])
// [1, 2, 3]
function filter_integers(values: any[]): number[] {
","function filter_integers(values: any[]): number[] {
    return values.filter(value => Number.isInteger(value));
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = filter_integers;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([4, {}, [], 23.2, 9, ""adasd""]),[4, 9]);
  assert.deepEqual(candidate([3, ""c"", 3, 3, ""a"", ""b""]),[3, 3, 3]);
}

test();"
HumanEval_23,als_Latn,ts,"//Kthimi i gjatësisë së një vargu të dhënë // >>> strlen("""")
// 0
// >>> strlen(""abc"")
// 3
function strlen(string: string): number {
","function strlen(string: string): number {
    return string.length;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = strlen;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""x""),1);
  assert.deepEqual(candidate(""asdasnakj""),9);
}

test();"
HumanEval_24,als_Latn,ts,"//Për një numër të dhënë n, gjeni numrin më të madh që ndan n në mënyrë të barabartë, më të vogël se n // >>> largest_divisor(15)
// 5
function largest_divisor(n: number): number {
","function largest_divisor(n: number): number {
    for (let i = n - 1; i > 0; i--) {
        if (n % i === 0) {
            return i;
        }
    }
    return 1; // By mathematical definition, 1 is a divisor of any integer.
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = largest_divisor;
  assert.deepEqual(candidate(3),1);
  assert.deepEqual(candidate(7),1);
  assert.deepEqual(candidate(10),5);
  assert.deepEqual(candidate(100),50);
  assert.deepEqual(candidate(49),7);
}

test();"
HumanEval_25,als_Latn,ts,"//Numri i hyrjes duhet të jetë i barabartë me prodhimin e të gjithë faktorëve.//Secili nga faktorët duhet të renditet numrin e herëve që korrespondon me sa herë shfaqet në faktorizim.//Kthehet një sërë faktorësh parësor të një numri të plotë të dhënë në rend nga më i vogël në më i madh.// >>> factorize(8)
// [2, 2, 2]
// >>> factorize(25)
// [5, 5]
// >>> factorize(70)
// [2, 5, 7]
function factorize(n: number): number[] {
","function factorize(n: number): number[] {
    const factors: number[] = [];
    let divisor = 2;
    
    while (n >= 2) {
        if (n % divisor === 0) {
            factors.push(divisor);
            n /= divisor;
        } else {
            divisor++;
        }
    }

    return factors;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = factorize;
  assert.deepEqual(candidate(2),[2]);
  assert.deepEqual(candidate(4),[2, 2]);
  assert.deepEqual(candidate(8),[2, 2, 2]);
  assert.deepEqual(candidate(57),[3, 19]);
  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);
  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);
  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);
  assert.deepEqual(candidate(18),[2, 3, 3]);
}

test();"
HumanEval_26,als_Latn,ts,"//Mbajeni rendin e elementeve të majta të njëjtë si në hyrje.//Nga një sërë e integers, hiqni të gjitha elementët që ndodhin më shumë se një herë.// >>> remove_duplicates([1, 2, 3, 2, 4])
// [1, 3, 4]
function remove_duplicates(numbers: number[]): number[] {
","function remove_duplicates(numbers: number[]): number[] {
    const frequencyMap: Map<number, number> = new Map();

    // Count the occurrences of each number
    for (const num of numbers) {
        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);
    }

    // Filter out the numbers occurring more than once
    return numbers.filter(num => frequencyMap.get(num) === 1);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = remove_duplicates;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5]);
}

test();"
HumanEval_27,als_Latn,ts,"//Për një varg të caktuar, kthe karakteret e vogla në të mëdha dhe të mëdha në të vogla. // >>> flip_case(""Hello"")
// ""hELLO""
function flip_case(string: string): string {
","function flip_case(str: string): string {
    let flipped = '';
    for (let char of str) {
        if (char === char.toUpperCase()) {
            flipped += char.toLowerCase();
        } else {
            flipped += char.toUpperCase();
        }
    }
    return flipped;
}

// Example usage:
console.log(flip_case(""Hello"")); // Output: ""hELLO""","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = flip_case;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hello!""),""hELLO!"");
  assert.deepEqual(candidate(""These violent delights have violent ends""),""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"");
}

test();"
HumanEval_28,als_Latn,ts,"//Të lidhësh një sërë stringesh në një string të vetëm.// >>> concatenate([])
// """"
// >>> concatenate([""a"", ""b"", ""c""])
// ""abc""
function concatenate(strings: string[]): string {
","function concatenate(strings: string[]): string {
    return strings.join('');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = concatenate;
  assert.deepEqual(candidate([]),"""");
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""xyz"");
  assert.deepEqual(candidate([""x"", ""y"", ""z"", ""w"", ""k""]),""xyzwk"");
}

test();"
HumanEval_29,als_Latn,ts,"//Filtro një renditje hyrëse të vargjeve vetëm për ato që fillojnë me një prefiks të caktuar. // >>> filter_by_prefix([], ""a"")
// []
// >>> filter_by_prefix([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
// [""abc"", ""array""]
function filter_by_prefix(strings: string[], prefix: string): string[] {
","function filter_by_prefix(strings: string[], prefix: string): string[] {
    return strings.filter(str => str.startsWith(prefix));
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = filter_by_prefix;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
}

test();"
HumanEval_30,als_Latn,ts,"//Kthen vetëm numrat pozitivë në masë.// >>> get_positive([-1, 2, -4, 5, 6])
// [2, 5, 6]
// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// [5, 3, 2, 3, 9, 123, 1]
function get_positive(l: number[]): number[] {
","function get_positive(l: number[]): number[] {
    return l.filter(num => num > 0);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = get_positive;
  assert.deepEqual(candidate([-1, -2, 4, 5, 6]),[4, 5, 6]);
  assert.deepEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1]);
  assert.deepEqual(candidate([-1, -2]),[]);
  assert.deepEqual(candidate([]),[]);
}

test();"
HumanEval_31,als_Latn,ts,"//Kthehet e vërtetë nëse një numër i dhënë është i parët, dhe i rremë në rastin tjetër. // >>> is_prime(6)
// false
// >>> is_prime(101)
// true
// >>> is_prime(11)
// true
// >>> is_prime(13441)
// true
// >>> is_prime(61)
// true
// >>> is_prime(4)
// false
// >>> is_prime(1)
// false
function is_prime(n: number): boolean {
","function is_prime(n: number): boolean {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_prime;
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(101),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(13441),true);
  assert.deepEqual(candidate(61),true);
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(1),false);
  assert.deepEqual(candidate(5),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(17),true);
  assert.deepEqual(candidate(85),false);
  assert.deepEqual(candidate(77),false);
  assert.deepEqual(candidate(255379),false);
}

test();"
HumanEval_33,als_Latn,ts,"//vlerat e indeksit korrespondues të l, por të renditur.//l' është identike me l në indekset që nuk janë të ndashme me tre, ndërsa vlerat e saj në indekset që janë të ndashme me tre janë të barabarta //Kjo funksion merr një renditje l dhe kthen një renditje l' të tillë që // >>> sort_third([1, 2, 3])
// [1, 2, 3]
// >>> sort_third([5, 6, 3, 4, 8, 9, 2])
// [2, 6, 3, 4, 8, 9, 5]
function sort_third(l: number[]): number[] {
","function sort_third(l: number[]): number[] {
    const indicesDivByThree = l.map((_, i) => i).filter(i => i % 3 === 0);
    const valuesDivByThree = indicesDivByThree.map(i => l[i]).sort((a, b) => a - b);

    const result = l.slice();
    for (let i = 0; i < indicesDivByThree.length; i++) {
        result[indicesDivByThree[i]] = valuesDivByThree[i];
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sort_third;
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);
  assert.deepEqual(candidate([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);
  assert.deepEqual(candidate([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5]);
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);
}

test();"
HumanEval_34,als_Latn,ts,"//Kthehet element i renditur unik në një renditje // >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [0, 2, 3, 5, 9, 123]
function unique(l: number[]): number[] {
","function unique(l: number[]): number[] {
    const uniqueSet = new Set(l);
    const uniqueArray = Array.from(uniqueSet);
    uniqueArray.sort((a, b) => a - b);
    return uniqueArray;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = unique;
  assert.deepEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);
}

test();"
HumanEval_35,als_Latn,ts,"//Kthen elementin maksimal në masë.// >>> max_element([1, 2, 3])
// 3
// >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// 123
function max_element(l: number[]): number {
","function max_element(l: number[]): number {
    if (l.length === 0) {
        throw new Error(""Array is empty"");
    }
    let max = l[0];
    for (let i = 1; i < l.length; i++) {
        if (l[i] > max) {
            max = l[i];
        }
    }
    return max;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = max_element;
  assert.deepEqual(candidate([1, 2, 3]),3);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124);
}

test();"
HumanEval_36,als_Latn,ts,"//Kthehet numri i rasteve që shifra 7 shfaqet në numra të plotë më të vegjël se n që janë të ndarë me 11 ose 13. // >>> fizz_buzz(50)
// 0
// >>> fizz_buzz(78)
// 2
// >>> fizz_buzz(79)
// 3
function fizz_buzz(n: number): number {
","function fizz_buzz(n: number): number {
    let count = 0;

    for (let i = 1; i < n; i++) {
        if (i % 11 === 0 || i % 13 === 0) {
            let numString = i.toString();
            for (let char of numString) {
                if (char === '7') {
                    count++;
                }
            }
        }
    }

    return count;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = fizz_buzz;
  assert.deepEqual(candidate(50),0);
  assert.deepEqual(candidate(78),2);
  assert.deepEqual(candidate(79),3);
  assert.deepEqual(candidate(100),3);
  assert.deepEqual(candidate(200),6);
  assert.deepEqual(candidate(4000),192);
  assert.deepEqual(candidate(10000),639);
  assert.deepEqual(candidate(100000),8026);
}

test();"
HumanEval_37,als_Latn,ts,"//vlerat e indeksive të njëjtë të l, por të renditur. //l' është identik me l në indeksi të çifta, ndërsa vlerat e tij në indeksi të çiftit janë të barabarta //Kjo funksion merr një renditje l dhe kthen një renditje l' të tillë që // >>> sort_even([1, 2, 3])
// [1, 2, 3]
// >>> sort_even([5, 6, 3, 4])
// [3, 6, 5, 4]
function sort_even(l: number[]): number[] {
","function sort_even(l: number[]): number[] {
    const evenIndices: number[] = [];
    const result: number[] = [...l];

    // Collect values at even indices
    for (let i = 0; i < l.length; i += 2) {
        evenIndices.push(l[i]);
    }

    // Sort the collected even indices values
    evenIndices.sort((a, b) => a - b);

    // Place the sorted values back in their original even indices
    for (let i = 0; i < l.length; i += 2) {
        result[i] = evenIndices.shift()!;
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sort_even;
  assert.deepEqual(candidate([1, 2, 3]),[1, 2, 3]);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
  assert.deepEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

test();"
HumanEval_39,als_Latn,ts,"//prime_fib kthen numrin n-të që është një numër Fibonacci dhe është gjithashtu numër i parë. // >>> prime_fib(1)
// 2
// >>> prime_fib(2)
// 3
// >>> prime_fib(3)
// 5
// >>> prime_fib(4)
// 13
// >>> prime_fib(5)
// 89
function prime_fib(n: number): number {
","function isPrime(num: number): boolean {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;
    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
}

function* fibonacciGenerator(): Generator<number, void, unknown> {
    let a = 0, b = 1;
    while (true) {
        let current = a;
        a = b;
        b = current + b;
        yield current;
    }
}

function prime_fib(n: number): number {
    const fibGen = fibonacciGenerator();
    let primeFibs: number[] = [];
    let i = 0;
    while (primeFibs.length < n) {
        const fibNum = fibGen.next().value;
        if (isPrime(fibNum)) {
            primeFibs.push(fibNum);
        }
    }
    return primeFibs[n - 1];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = prime_fib;
  assert.deepEqual(candidate(1),2);
  assert.deepEqual(candidate(2),3);
  assert.deepEqual(candidate(3),5);
  assert.deepEqual(candidate(4),13);
  assert.deepEqual(candidate(5),89);
  assert.deepEqual(candidate(6),233);
  assert.deepEqual(candidate(7),1597);
  assert.deepEqual(candidate(8),28657);
  assert.deepEqual(candidate(9),514229);
  assert.deepEqual(candidate(10),433494437);
}

test();"
HumanEval_40,als_Latn,ts,"//Shuma zero, dhe false ndryshe.//kthyen të vërtetë nëse ka tre elemente të dallueshme në masë që //triples_sum_to_zero merr një sërë të integers si një input. // >>> triples_sum_to_zero([1, 3, 5, 0])
// false
// >>> triples_sum_to_zero([1, 3, -2, 1])
// true
// >>> triples_sum_to_zero([1, 2, 3, 7])
// false
// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
// true
// >>> triples_sum_to_zero([1])
// false
function triples_sum_to_zero(l: number[]): boolean {
","function triples_sum_to_zero(l: number[]): boolean {
    if (l.length < 3) {
        return false;
    }

    // Sort the array
    l.sort((a, b) => a - b);

    // Iterate through the array
    for (let i = 0; i < l.length - 2; i++) {
        let left = i + 1;
        let right = l.length - 1;

        // Use two pointers to find a pair that makes the sum zero with l[i]
        while (left < right) {
            const sum = l[i] + l[left] + l[right];
            if (sum === 0) {
                return true;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return false;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = triples_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, 5, -1]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),true);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([1, 2, 5, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 9, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([1, 3, 5, -100]),false);
  assert.deepEqual(candidate([100, 3, 5, -100]),false);
}

test();"
HumanEval_41,als_Latn,ts,"//Ky funksion jep numrin e përplasjeve të tilla. //në trajektoren e tyre sikur të mos përplaseshin.//Megjithatë, makinat janë të forta dhe të qëndrueshme pafundësisht, dhe si rezultat, ato vazhdojnë të lëvizin.//kur një makinë që lëviz nga e majta në të djathtë godet një makinë që lëviz nga e djathta në të majtë.//Të gjitha makinat lëvizin me të njëjtën shpejtësi.//Dy grupe makinerish fillojnë duke qenë shumë larg nga...//n makina po ecin majtas ne te djathte; ne te njejten kohe, nje grup i ndryshem i n makinave //Imagjinoni një rrugë që është një vijë e drejtë e pafund.function car_race_collision(n: number): number {
","function car_race_collision(n: number): number {
    // Since the cars move at the same speed and are infinitely strong,
    // each pair of a left-to-right car and a right-to-left car will ""collide"" at some point.
    // Therefore, every pair of cars from different sets will collide exactly once.
    
    // We need to find the number of such pairs, which is simply n * n.
    return n * n;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = car_race_collision;
  assert.deepEqual(candidate(2),4);
  assert.deepEqual(candidate(3),9);
  assert.deepEqual(candidate(4),16);
  assert.deepEqual(candidate(8),64);
  assert.deepEqual(candidate(10),100);
}

test();"
HumanEval_42,als_Latn,ts,"//Kthehet një sërë me elemente të rritura me 1.// >>> incr_list([1, 2, 3])
// [2, 3, 4]
// >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [6, 4, 6, 3, 4, 4, 10, 1, 124]
function incr_list(l: number[]): number[] {
","function incr_list(l: number[]): number[] {
    return l.map(num => num + 1);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = incr_list;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([3, 2, 1]),[4, 3, 2]);
  assert.deepEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

test();"
HumanEval_43,als_Latn,ts,"//Shuma zero, dhe false ndryshe.//kthyen të vërtetë nëse ka dy elemente të dallueshme në masë që //pairs_sum_to_zero merr një sërë të integers si një input. // >>> pairs_sum_to_zero([1, 3, 5, 0])
// false
// >>> pairs_sum_to_zero([1, 3, -2, 1])
// false
// >>> pairs_sum_to_zero([1, 2, 3, 7])
// false
// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
// true
// >>> pairs_sum_to_zero([1])
// false
function pairs_sum_to_zero(l: number[]): boolean {
","function pairs_sum_to_zero(l: number[]): boolean {
    const seen = new Set<number>();

    for (const num of l) {
        if (seen.has(-num)) {
            return true;
        }
        seen.add(num);
    }

    return false;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = pairs_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),false);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 30]),true);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 31]),false);
}

test();"
HumanEval_44,als_Latn,ts,"//Numrat e bazave janë më pak se 10.//kthimi i përfaqësimit të vargut pas konvertimit.//Ndryshoni bazën numërore të numrit të hyrjes x në bazë.// >>> change_base(8, 3)
// ""22""
// >>> change_base(8, 2)
// ""1000""
// >>> change_base(7, 2)
// ""111""
function change_base(x: number, base: number): string {
","function change_base(x: number, base: number): string {
    if (base < 2 || base > 9) {
        throw new Error(""Base must be between 2 and 9 inclusive"");
    }
    
    if (x === 0) return ""0"";

    let result: string = """";
    let number: number = x;

    while (number > 0) {
        const remainder = number % base;
        result = remainder.toString() + result;
        number = Math.floor(number / base);
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = change_base;
  assert.deepEqual(candidate(8, 3),""22"");
  assert.deepEqual(candidate(9, 3),""100"");
  assert.deepEqual(candidate(234, 2),""11101010"");
  assert.deepEqual(candidate(16, 2),""10000"");
  assert.deepEqual(candidate(8, 2),""1000"");
  assert.deepEqual(candidate(7, 2),""111"");
  assert.deepEqual(candidate(2, 3),""2"");
  assert.deepEqual(candidate(3, 4),""3"");
  assert.deepEqual(candidate(4, 5),""4"");
  assert.deepEqual(candidate(5, 6),""5"");
  assert.deepEqual(candidate(6, 7),""6"");
  assert.deepEqual(candidate(7, 8),""7"");
}

test();"
HumanEval_45,als_Latn,ts,"//Duke pasur parasysh gjatësinë e një anës dhe zonën e kthimit të lartë për një trekëndësh.// >>> triangle_area(5, 3)
// 7.5
function triangle_area(a: number, h: number): number {
","function triangle_area(a: number, h: number): number {
    return 0.5 * a * h;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(5, 3),7.5);
  assert.deepEqual(candidate(2, 2),2.0);
  assert.deepEqual(candidate(10, 8),40.0);
}

test();"
HumanEval_46,als_Latn,ts,"//Ju lutemi shkruani një funksion për të llogaritur në mënyrë efikase elementin e n-të të sekuencës së numrave fib4. Mos përdorni rikursion. //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).//fib4(3) -> 0 //fib4(2) -> 2 //fib4(1) -> 0 //fib4(0) -> 0 //Rreshtësia e numrave Fib4 është një rreshtësi e ngjashme me rreshtësinë e Fibbonaçit që është e përcaktuar si më poshtë: // >>> fib4(5)
// 4
// >>> fib4(6)
// 8
// >>> fib4(7)
// 14
function fib4(n: number): number {
","function fib4(n: number): number {
    if (n === 0) return 0;
    if (n === 1) return 0;
    if (n === 2) return 2;
    if (n === 3) return 0;

    let fibNumbers = [0, 0, 2, 0];
    for (let i = 4; i <= n; i++) {
        const nextFib = fibNumbers[3] + fibNumbers[2] + fibNumbers[1] + fibNumbers[0];
        fibNumbers.shift();
        fibNumbers.push(nextFib);
    }
    return fibNumbers[3];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = fib4;
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),28);
  assert.deepEqual(candidate(10),104);
  assert.deepEqual(candidate(12),386);
}

test();"
HumanEval_47,als_Latn,ts,"//Kthehet mediana e elementeve në masë l. // >>> median([3, 1, 2, 4, 5])
// 3
// >>> median([-10, 4, 6, 1000, 10, 20])
// 15.0
function median(l: number[]): number {
","function median(l: number[]): number {
    const sorted = l.slice().sort((a, b) => a - b);
    const len = sorted.length;
    
    if (len % 2 === 0) {
        return (sorted[len / 2 - 1] + sorted[len / 2]) / 2;
    } else {
        return sorted[Math.floor(len / 2)];
    }
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = median;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),3);
  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);
  assert.deepEqual(candidate([5]),5);
  assert.deepEqual(candidate([6, 5]),5.5);
  assert.deepEqual(candidate([8, 1, 3, 9, 9, 2, 7]),7);
}

test();"
HumanEval_48,als_Latn,ts,"//Kontrollohet nëse një varg i dhënë është palindrom // >>> is_palindrome("""")
// true
// >>> is_palindrome(""aba"")
// true
// >>> is_palindrome(""aaaaa"")
// true
// >>> is_palindrome(""zbcd"")
// false
function is_palindrome(text: string): boolean {
","function is_palindrome(text: string): boolean {
    return text === text.split('').reverse().join('');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_palindrome;
  assert.deepEqual(candidate(""""),true);
  assert.deepEqual(candidate(""aba""),true);
  assert.deepEqual(candidate(""aaaaa""),true);
  assert.deepEqual(candidate(""zbcd""),false);
  assert.deepEqual(candidate(""xywyx""),true);
  assert.deepEqual(candidate(""xywyz""),false);
  assert.deepEqual(candidate(""xywzx""),false);
}

test();"
HumanEval_49,als_Latn,ts,"//Kthehet 2^n modulo p (të jesh i vetëdijshëm për numrat).// >>> modp(3, 5)
// 3
// >>> modp(1101, 101)
// 2
// >>> modp(0, 101)
// 1
// >>> modp(3, 11)
// 8
// >>> modp(100, 101)
// 1
function modp(n: number, p: number): number {
","function modp(n: number, p: number): number {
    if (n === 0) return 1 % p;
    let result = 1;
    let base = 2;
    
    while (n > 0) {
        if (n % 2 === 1) {
            result = (result * base) % p;
        }
        base = (base * base) % p;
        n = Math.floor(n / 2);
    }
    
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = modp;
  assert.deepEqual(candidate(3, 5),3);
  assert.deepEqual(candidate(1101, 101),2);
  assert.deepEqual(candidate(0, 101),1);
  assert.deepEqual(candidate(3, 11),8);
  assert.deepEqual(candidate(100, 101),1);
  assert.deepEqual(candidate(30, 5),4);
  assert.deepEqual(candidate(31, 5),3);
}

test();"
HumanEval_51,als_Latn,ts,"//remove_vowels është një funksion që merr string dhe kthen string pa vokalë. // >>> remove_vowels("""")
// """"
// >>> remove_vowels(""abcdef"")
// ""bcdf""
// >>> remove_vowels(""aaaaa"")
// """"
// >>> remove_vowels(""aaBAA"")
// ""B""
// >>> remove_vowels(""zbcd"")
// ""zbcd""
function remove_vowels(text: string): string {
","function remove_vowels(text: string): string {
    return text.replace(/[aeiouAEIOU]/g, '');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = remove_vowels;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""abcdef\nghijklm""),""bcdf\nghjklm"");
  assert.deepEqual(candidate(""fedcba""),""fdcb"");
  assert.deepEqual(candidate(""eeeee""),"""");
  assert.deepEqual(candidate(""acBAA""),""cB"");
  assert.deepEqual(candidate(""EcBOO""),""cB"");
  assert.deepEqual(candidate(""ybcd""),""ybcd"");
}

test();"
HumanEval_52,als_Latn,ts,"//Kthehet e vërtetë nëse të gjitha numrat në masë l janë nën pragun t. // >>> below_threshold([1, 2, 4, 10], 100)
// true
// >>> below_threshold([1, 20, 4, 10], 5)
// false
function below_threshold(l: number[], t: number): boolean {
","function below_threshold(l: number[], t: number): boolean {
    return l.every(num => num < t);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = below_threshold;
  assert.deepEqual(candidate([1, 2, 4, 10], 100),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 5),false);
  assert.deepEqual(candidate([1, 20, 4, 10], 21),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 22),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 11),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 10),false);
}

test();"
HumanEval_53,als_Latn,ts,"//Shto dy numra x dhe y.// >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
function add(x: number, y: number): number {
","function add(x: number, y: number): number {
    return x + y;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate(0, 1),1);
  assert.deepEqual(candidate(1, 0),1);
  assert.deepEqual(candidate(2, 3),5);
  assert.deepEqual(candidate(5, 7),12);
  assert.deepEqual(candidate(7, 5),12);
}

test();"
HumanEval_54,als_Latn,ts,"//Kontrolloni nëse dy fjalë kanë karaktere të njëjta.// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
// true
// >>> same_chars(""abcd"", ""dddddddabc"")
// true
// >>> same_chars(""dddddddabc"", ""abcd"")
// true
// >>> same_chars(""eabcd"", ""dddddddabc"")
// false
// >>> same_chars(""abcd"", ""dddddddabce"")
// false
// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
// false
function same_chars(s0: string, s1: string): boolean {
","function same_chars(s0: string, s1: string): boolean {
    const charSet0: Set<string> = new Set(s0);
    const charSet1: Set<string> = new Set(s1);

    if (charSet0.size !== charSet1.size) {
        return false;
    }

    for (const char of charSet0) {
        if (!charSet1.has(char)) {
            return false;
        }
    }

    return true;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = same_chars;
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddeddabc""),true);
  assert.deepEqual(candidate(""abcd"", ""dddddddabc""),true);
  assert.deepEqual(candidate(""dddddddabc"", ""abcd""),true);
  assert.deepEqual(candidate(""eabcd"", ""dddddddabc""),false);
  assert.deepEqual(candidate(""abcd"", ""dddddddabcf""),false);
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddddabc""),false);
  assert.deepEqual(candidate(""aabb"", ""aaccc""),false);
}

test();"
HumanEval_55,als_Latn,ts,"//Kthehet numri i n-të i Fibonaçit. // >>> fib(10)
// 55
// >>> fib(1)
// 1
// >>> fib(8)
// 21
function fib(n: number): number {
","function fib(n: number): number {
    if (n <= 0) {
        throw new Error(""Input should be a positive integer."");
    }
    if (n === 1) return 1;
    if (n === 2) return 1;

    let a = 1, b = 1;
    for (let i = 3; i <= n; i++) {
        const temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

// Example usage:
console.log(fib(10)); // 55
console.log(fib(1));  // 1
console.log(fib(8));  // 21","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = fib;
  assert.deepEqual(candidate(10),55);
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(8),21);
  assert.deepEqual(candidate(11),89);
  assert.deepEqual(candidate(12),144);
}

test();"
HumanEval_56,als_Latn,ts,"//return true nëse çdo kurriz hapësie ka një kurriz mbyllës përkatës. //kurtesat është një varg i ""<"" dhe "">"". // >>> correct_bracketing(""<"")
// false
// >>> correct_bracketing(""<>"")
// true
// >>> correct_bracketing(""<<><>>"")
// true
// >>> correct_bracketing(""><<>"")
// false
function correct_bracketing(brackets: string): boolean {
","function correct_bracketing(brackets: string): boolean {
    let balance = 0;
    for (let char of brackets) {
        if (char === '<') {
            balance++;
        } else if (char === '>') {
            balance--;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance === 0;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""<>""),true);
  assert.deepEqual(candidate(""<<><>>""),true);
  assert.deepEqual(candidate(""<><><<><>><>""),true);
  assert.deepEqual(candidate(""<><><<<><><>><>><<><><<>>>""),true);
  assert.deepEqual(candidate(""<<<><>>>>""),false);
  assert.deepEqual(candidate(""><<>""),false);
  assert.deepEqual(candidate(""<""),false);
  assert.deepEqual(candidate(""<<<<""),false);
  assert.deepEqual(candidate("">""),false);
  assert.deepEqual(candidate(""<<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>><<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>>><>""),false);
}

test();"
HumanEval_57,als_Latn,ts,"//Return true është elementet e rendit janë monotonisht në rritje ose në rënie.// >>> monotonic([1, 2, 4, 20])
// true
// >>> monotonic([1, 20, 4, 10])
// false
// >>> monotonic([4, 1, 0, -10])
// true
function monotonic(l: number[]): boolean {
","function monotonic(l: number[]): boolean {
    if (l.length <= 1) return true;
    
    let increasing = true;
    let decreasing = true;
    
    for (let i = 1; i < l.length; i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
        
        if (!increasing && !decreasing) return false;
    }
    
    return increasing || decreasing;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = monotonic;
  assert.deepEqual(candidate([1, 2, 4, 10]),true);
  assert.deepEqual(candidate([1, 2, 4, 20]),true);
  assert.deepEqual(candidate([1, 20, 4, 10]),false);
  assert.deepEqual(candidate([4, 1, 0, -10]),true);
  assert.deepEqual(candidate([4, 1, 1, 0]),true);
  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);
  assert.deepEqual(candidate([9, 9, 9, 9]),true);
}

test();"
HumanEval_58,als_Latn,ts,"//Kthehet element i renditur unik i përbashkët për dy renditje. // >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
// [1, 5, 653]
// >>> common([5, 3, 2, 8], [3, 2])
// [2, 3]
function common(l1: number[], l2: number[]): number[] {
","function common(l1: number[], l2: number[]): number[] {
    const set1 = new Set(l1);
    const set2 = new Set(l2);
    const commonElements = Array.from(set1).filter(item => set2.has(item));
    return commonElements.sort((a, b) => a - b);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = common;
  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);
  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2, 3]);
  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);
}

test();"
HumanEval_59,als_Latn,ts,"//Kthehet faktori kryesor më i madh i n. supozo n > 1 dhe nuk është një numër i parë. // >>> largest_prime_factor(13195)
// 29
// >>> largest_prime_factor(2048)
// 2
function largest_prime_factor(n: number): number {
","function largest_prime_factor(n: number): number {
    let largestFactor = 1;

    // Divide n by 2 until it becomes odd
    while (n % 2 === 0) {
        largestFactor = 2;
        n /= 2;
    }

    // Check for odd factors from 3 upwards
    for (let i = 3; i <= Math.sqrt(n); i += 2) {
        while (n % i === 0) {
            largestFactor = i;
            n /= i;
        }
    }

    // If n becomes a prime number greater than 2
    if (n > 2) {
        largestFactor = n;
    }

    return largestFactor;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = largest_prime_factor;
  assert.deepEqual(candidate(15),5);
  assert.deepEqual(candidate(27),3);
  assert.deepEqual(candidate(63),7);
  assert.deepEqual(candidate(330),11);
  assert.deepEqual(candidate(13195),29);
}

test();"
HumanEval_60,als_Latn,ts,"//sum_to_n është një funksion që shton numrat nga 1 deri n. // >>> sum_to_n(30)
// 465
// >>> sum_to_n(100)
// 5050
// >>> sum_to_n(5)
// 15
// >>> sum_to_n(10)
// 55
// >>> sum_to_n(1)
// 1
function sum_to_n(n: number): number {
","function sum_to_n(n: number): number {
    return n * (n + 1) / 2;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sum_to_n;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(6),21);
  assert.deepEqual(candidate(11),66);
  assert.deepEqual(candidate(30),465);
  assert.deepEqual(candidate(100),5050);
}

test();"
HumanEval_61,als_Latn,ts,"//return true nëse çdo kurriz hapësie ka një kurriz mbyllës përkatës. //kurtesat është një varg i ""("" dhe "")"". // >>> correct_bracketing(""("")
// false
// >>> correct_bracketing(""()"")
// true
// >>> correct_bracketing(""(()())"")
// true
// >>> correct_bracketing("")(()"")
// false
function correct_bracketing(brackets: string): boolean {
","function correct_bracketing(brackets: string): boolean {
    let balance = 0;

    for (let char of brackets) {
        if (char === '(') {
            balance++;
        } else if (char === ')') {
            balance--;
        }

        // If balance goes negative, there's a closing bracket without a matching opening one
        if (balance < 0) {
            return false;
        }
    }

    // If balance is zero, all opening brackets have matching closing brackets
    return balance === 0;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""()""),true);
  assert.deepEqual(candidate(""(()())""),true);
  assert.deepEqual(candidate(""()()(()())()""),true);
  assert.deepEqual(candidate(""()()((()()())())(()()(()))""),true);
  assert.deepEqual(candidate(""((()())))""),false);
  assert.deepEqual(candidate("")(()""),false);
  assert.deepEqual(candidate(""(""),false);
  assert.deepEqual(candidate(""((((""),false);
  assert.deepEqual(candidate("")""),false);
  assert.deepEqual(candidate(""(()""),false);
  assert.deepEqual(candidate(""()()(()())())(()""),false);
  assert.deepEqual(candidate(""()()(()())()))()""),false);
}

test();"
HumanEval_62,als_Latn,ts,"//Kthe derivati i këtij polinomit në të njëjtën formë.//xs[0] + xs[1] * x + xs[2] * x^2 + .... //xs përfaqësojnë koeficientët e një polinom. // >>> derivative([3, 1, 2, 4, 5])
// [1, 4, 12, 20]
// >>> derivative([1, 2, 3])
// [2, 6]
function derivative(xs: number[]): number[] {
","function derivative(xs: number[]): number[] {
    return xs.slice(1).map((coef, index) => coef * (index + 1));
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = derivative;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);
  assert.deepEqual(candidate([3, 2, 1]),[2, 2]);
  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);
  assert.deepEqual(candidate([1]),[]);
}

test();"
HumanEval_63,als_Latn,ts,"//Ju lutemi shkruani një funksion për të llogaritur në mënyrë efikase elementin e n-të të sekuencës së numrave fibfib. //fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). //Fibfib ((2) == 1 //Fibfib ((1)) == 0 //Fibfib ((0)) == 0 //Rreshtësia e numrave FibFib është një rreshtësi e ngjashme me rreshtësinë e Fibbonaçit që është e përcaktuar si më poshtë: // >>> fibfib(1)
// 0
// >>> fibfib(5)
// 4
// >>> fibfib(8)
// 24
function fibfib(n: number): number {
","function fibfib(n: number): number {
    if (n === 0 || n === 1) return 0;
    if (n === 2) return 1;

    let a = 0;
    let b = 0;
    let c = 1;

    for (let i = 3; i <= n; i++) {
        let next = a + b + c;
        a = b;
        b = c;
        c = next;
    }

    return c;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = fibfib;
  assert.deepEqual(candidate(2),1);
  assert.deepEqual(candidate(1),0);
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),24);
  assert.deepEqual(candidate(10),81);
  assert.deepEqual(candidate(12),274);
  assert.deepEqual(candidate(14),927);
}

test();"
HumanEval_64,als_Latn,ts,"//Shembull: //vokal, por vetëm kur është në fund të fjalës së dhënë.//Vokalit në këtë rast janë ""a"", ""e"", ""i"", ""o"", ""u"". Këtu, ""y"" është gjithashtu një //një fjalë si input dhe kthen numrin e vokalëve në varg. //Shkruaj një funksion vowels_count i cili merr një varg që përfaqëson // >>> vowels_count(""abcde"")
// 2
// >>> vowels_count(""ACEDY"")
// 3
function vowels_count(s: string): number {
","function vowels_count(s: string): number {
    let count = 0;
    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);
    const lowerCaseString = s.toLowerCase();

    for (let i = 0; i < lowerCaseString.length; i++) {
        if (vowels.has(lowerCaseString[i])) {
            count++;
        }
        if (i === lowerCaseString.length - 1 && lowerCaseString[i] === 'y') {
            count++;
        }
    }

    return count;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = vowels_count;
  assert.deepEqual(candidate(""abcde""),2);
  assert.deepEqual(candidate(""Alone""),3);
  assert.deepEqual(candidate(""key""),2);
  assert.deepEqual(candidate(""bye""),1);
  assert.deepEqual(candidate(""keY""),2);
  assert.deepEqual(candidate(""bYe""),1);
  assert.deepEqual(candidate(""ACEDY""),3);
}

test();"
HumanEval_65,als_Latn,ts,"//Nëse shift > numri i shifrave, kthimi i shifrave të kundërta. //dhe kthyen rezultatin si një varg. //Rrethore zhvendosjen e shifrave të x, zhvendosjen e shifrave të drejtë nga zhvendosja.// >>> circular_shift(12, 1)
// ""21""
// >>> circular_shift(12, 2)
// ""12""
function circular_shift(x: number, shift: number): string {
","function circular_shift(x: number, shift: number): string {
    const strNum = x.toString();
    const length = strNum.length;
    if (shift >= length) {
        return strNum.split('').reverse().join('');
    }
    const normalizedShift = shift % length;
    const splitIndex = length - normalizedShift;
    return strNum.slice(splitIndex) + strNum.slice(0, splitIndex);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = circular_shift;
  assert.deepEqual(candidate(100, 2),""001"");
  assert.deepEqual(candidate(12, 2),""12"");
  assert.deepEqual(candidate(97, 8),""79"");
  assert.deepEqual(candidate(12, 1),""21"");
  assert.deepEqual(candidate(11, 101),""11"");
}

test();"
HumanEval_66,als_Latn,ts,"//Shembuj: //Kodet ASCII.//Shkruaj një funksion që merr një varg si input dhe kthen shumën e karaktereve të sipërme vetëm' //Detyrë // >>> digitSum("""")
// 0
// >>> digitSum(""abAB"")
// 131
// >>> digitSum(""abcCd"")
// 67
// >>> digitSum(""helloE"")
// 69
// >>> digitSum(""woArBld"")
// 131
// >>> digitSum(""aAaaaXa"")
// 153
function digitSum(s: string): number {
","function digitSum(s: string): number {
    let sum = 0;
    for (const char of s) {
        if (char >= 'A' && char <= 'Z') {
            sum += char.charCodeAt(0);
        }
    }
    return sum;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = digitSum;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abAB""),131);
  assert.deepEqual(candidate(""abcCd""),67);
  assert.deepEqual(candidate(""helloE""),69);
  assert.deepEqual(candidate(""woArBld""),131);
  assert.deepEqual(candidate(""aAaaaXa""),153);
  assert.deepEqual(candidate("" How are yOu?""),151);
  assert.deepEqual(candidate(""You arE Very Smart""),327);
}

test();"
HumanEval_67,als_Latn,ts,"//për ekzamëll: //në shportë kthehet numri i frutave të mangos në shportë. //portokallët dhe mollët dhe një numër i plotë që përfaqëson numrin e përgjithshëm të frutave //Molla, portokall dhe fruta mango. duke i dhënë një varg që përfaqëson numrin total të //që janë shpërndarë në një shportë me fruta që përmban ky shportë.//Në këtë detyrë, ju do të jepet një varg që përfaqëson një numër të mollëve dhe portokallëve.// >>> fruit_distribution(""5 apples and 6 oranges"", 19)
// 8
// >>> fruit_distribution(""0 apples and 1 oranges"", 3)
// 2
// >>> fruit_distribution(""2 apples and 3 oranges"", 100)
// 95
// >>> fruit_distribution(""100 apples and 1 oranges"", 120)
// 19
function fruit_distribution(s: string, n: number): number {
","function fruit_distribution(s: string, n: number): number {
    const regex = /(\d+) apples and (\d+) oranges/;
    const match = s.match(regex);
    
    if (!match) {
        throw new Error(""Invalid input format"");
    }
    
    const apples = parseInt(match[1], 10);
    const oranges = parseInt(match[2], 10);
    
    const totalApplesAndOranges = apples + oranges;
    return n - totalApplesAndOranges;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = fruit_distribution;
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 19),8);
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 21),10);
  assert.deepEqual(candidate(""0 apples and 1 oranges"", 3),2);
  assert.deepEqual(candidate(""1 apples and 0 oranges"", 3),2);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 100),95);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 5),0);
  assert.deepEqual(candidate(""1 apples and 100 oranges"", 120),19);
}

test();"
HumanEval_68,als_Latn,ts,"//Shembull 1: //Nëse nuk ka vlera të çifta ose matricu i dhënë është bosh, kthe []. //Nyja e pluhur duhet të kthehet në një masë, [small_value, indeks i saj ], //Nëse gjenden shumë nyje me të njëjtën vlerë më të vogël të çiftit kthehet nyja që ka indeksin më të vogël. //Nyja e pluhur duhet të jetë nyja me vlerën më të vogël të çiftit.//Detyra juaj është të merrni një nga nyjet dhe ta ktheni atë.//""Duke pasur parasysh një masë që përfaqëson një degë të një pemë që ka nyje jo-negative të numrit të plotë // >>> pluck([4, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 2:
// >>> pluck([1, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 3:
// >>> pluck([])
// []
// Example 4:
// >>> pluck([5, 0, 3, 0, 4, 2])
// [0, 1]
// Explanation: 0 is the smallest value, but  there are two zeros,
// so we will choose the first zero, which has the smallest index.
// Constraints:
// * 1 <= nodes.length <= 10000
// * 0 <= node.value
function pluck(arr: number[]): number[] {
","function pluck(arr: number[]): number[] {
    let minEvenValue: number | null = null;
    let minIndex: number | null = null;

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 === 0) { // Check if the number is even
            if (minEvenValue === null || arr[i] < minEvenValue) {
                minEvenValue = arr[i];
                minIndex = i;
            }
        }
    }

    if (minEvenValue !== null && minIndex !== null) {
        return [minEvenValue, minIndex];
    } else {
        return [];
    }
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = pluck;
  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);
  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0, 3]);
  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);
  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);
  assert.deepEqual(candidate([7, 9, 7, 1]),[]);
}

test();"
HumanEval_69,als_Latn,ts,"//Shembuj: //Nëse nuk ekziston një vlerë e tillë, kthehet -1.//Frekuenca e një numri të plotë është numri i herë që shfaqet në masë.//zero, dhe ka një frekuencë më të madhe se ose të barabartë me vlerën e vetë numërit të plotë. //Ju është dhënë një sërë jo bosh i integers pozitive. Kthehet numri më i madh i plotë që është më i madh se // >>> search([4, 1, 2, 2, 3, 1])
// 2
// >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])
// 3
// >>> search([5, 5, 4, 4, 4])
// -1
function search(lst: number[]): number {
","function search(lst: number[]): number {
    const frequencyMap: Map<number, number> = new Map();

    // Count frequencies of each integer in the array
    for (const num of lst) {
        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);
    }

    let result = -1;

    // Determine the greatest integer that meets the condition
    for (const [num, freq] of frequencyMap.entries()) {
        if (freq >= num && num > result) {
            result = num;
        }
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = search;
  assert.deepEqual(candidate([5, 5, 5, 5, 1]),1);
  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);
  assert.deepEqual(candidate([3, 3]),-1);
  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);
  assert.deepEqual(candidate([2, 3, 3, 2, 2]),2);
  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);
  assert.deepEqual(candidate([3, 2, 8, 2]),2);
  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);
  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);
  assert.deepEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);
  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);
  assert.deepEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);
  assert.deepEqual(candidate([1]),1);
  assert.deepEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);
  assert.deepEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);
  assert.deepEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);
  assert.deepEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4);
  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);
  assert.deepEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);
  assert.deepEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);
  assert.deepEqual(candidate([10]),-1);
  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);
  assert.deepEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);
  assert.deepEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);
  assert.deepEqual(candidate([3, 10, 10, 9, 2]),-1);
}

test();"
HumanEval_70,als_Latn,ts,"//Shembuj: //pastaj maksimumi i integers mbetjes, pastaj minimale dhe kështu me radhë.//Shkatërrim i çuditshëm, është kur ju filloni me vlerën minimale, //Duke pasur parasysh një sërë të numrave të plotë, kthehet në rend të çuditshëm.// >>> strange_sort_list([1, 2, 3, 4])
// [1, 4, 2, 3]
// >>> strange_sort_list([5, 5, 5, 5])
// [5, 5, 5, 5]
// >>> strange_sort_list([])
// []
function strange_sort_list(lst: number[]): number[] {
","function strange_sort_list(lst: number[]): number[] {
    const sorted = [...lst].sort((a, b) => a - b);
    const result: number[] = [];
    let left = 0;
    let right = sorted.length - 1;

    while (left <= right) {
        if (left === right) {
            result.push(sorted[left]);
        } else {
            result.push(sorted[left]);
            result.push(sorted[right]);
        }
        left++;
        right--;
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = strange_sort_list;
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 4, 2, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7]);
  assert.deepEqual(candidate([5, 5, 5, 5]),[5, 5, 5, 5]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5]);
  assert.deepEqual(candidate([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2]);
  assert.deepEqual(candidate([111111]),[111111]);
}

test();"
HumanEval_71,als_Latn,ts,"//Shembull: //se në anën e tretë.//Tri anët e bëjnë një trekëndësh të vlefshëm kur shuma e dy anëve të tyre është më e madhe.//Ndryshe kthehet -1 //trekëndëshi i rrumbullakosur në 2 pika decimale nëse tre anët formojnë një trekëndësh të vlefshëm. //Duke pasur parasysh gjatësinë e tri anëve të një trekëndëshi, kthehet sipërfaqja e // >>> triangle_area(3, 4, 5)
// 6.0
// >>> triangle_area(1, 2, 10)
// -1
function triangle_area(a: number, b: number, c: number): number {
","function triangle_area(a: number, b: number, c: number): number {
    // Check if the sides form a valid triangle
    if (a + b > c && a + c > b && b + c > a) {
        // Calculate the semi-perimeter
        const s = (a + b + c) / 2;
        // Calculate the area using Heron's formula
        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        // Return the area rounded to 2 decimal places
        return Math.round(area * 100) / 100;
    }
    // Return -1 if the sides do not form a valid triangle
    return -1;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(3, 4, 5),6.0);
  assert.deepEqual(candidate(1, 2, 10),-1);
  assert.deepEqual(candidate(4, 8, 5),8.18);
  assert.deepEqual(candidate(2, 2, 2),1.73);
  assert.deepEqual(candidate(1, 2, 3),-1);
  assert.deepEqual(candidate(10, 5, 7),16.25);
  assert.deepEqual(candidate(2, 6, 3),-1);
  assert.deepEqual(candidate(1, 1, 1),0.43);
  assert.deepEqual(candidate(2, 2, 10),-1);
}

test();"
HumanEval_72,als_Latn,ts,"//Shembull: //Objekti q do të fluturojë nëse është i balancuar (është një sërë palindromik) dhe shuma e elementeve të tij është më e vogël se ose e barabartë me peshën maksimale të mundshme w.//Shkruaj një funksion që kthehet i vërtetë nëse objekti q do të fluturojë, dhe i rremë në rastin tjetër. // >>> will_it_fly([1, 2], 5)
// false
// # 1+2 is less than the maximum possible weight, but it's unbalanced.
// >>> will_it_fly([3, 2, 3], 1)
// false
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
// >>> will_it_fly([3, 2, 3], 9)
// true
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
// >>> will_it_fly([3], 5)
// true
// # 3 is less than the maximum possible weight, and it's balanced.
function will_it_fly(q: number[], w: number): boolean {
","function will_it_fly(q: number[], w: number): boolean {
    // Check if the array is balanced (palindromic)
    const isBalanced = (arr: number[]): boolean => {
        for (let i = 0; i < arr.length / 2; i++) {
            if (arr[i] !== arr[arr.length - 1 - i]) {
                return false;
            }
        }
        return true;
    };

    // Calculate the sum of the elements in the array
    const sumElements = q.reduce((acc, curr) => acc + curr, 0);

    // Check both conditions: balanced array and sum less than or equal to max weight
    return isBalanced(q) && sumElements <= w;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = will_it_fly;
  assert.deepEqual(candidate([3, 2, 3], 9),true);
  assert.deepEqual(candidate([1, 2], 5),false);
  assert.deepEqual(candidate([3], 5),true);
  assert.deepEqual(candidate([3, 2, 3], 1),false);
  assert.deepEqual(candidate([1, 2, 3], 6),false);
  assert.deepEqual(candidate([5], 5),true);
}

test();"
HumanEval_73,als_Latn,ts,"//Për shembull: //Në një ndryshim, ju mund të ndryshoni një element në çdo element tjetër.//duhet të ndryshohet për të bërë palindromik array. një palindromik array është një array që //Duke pasur parasysh një masë arr e integers, të gjeni numrin minimal të elementeve që // >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])
// 4
// >>> smallest_change([1, 2, 3, 4, 3, 2, 2])
// 1
// >>> smallest_change([1, 2, 3, 2, 1])
// 0
function smallest_change(arr: number[]): number {
","function smallest_change(arr: number[]): number {
    let changes = 0;
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {
        if (arr[left] !== arr[right]) {
            changes++;
        }
        left++;
        right--;
    }

    return changes;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = smallest_change;
  assert.deepEqual(candidate([1, 2, 3, 5, 4, 7, 9, 6]),4);
  assert.deepEqual(candidate([1, 2, 3, 4, 3, 2, 2]),1);
  assert.deepEqual(candidate([1, 4, 2]),1);
  assert.deepEqual(candidate([1, 4, 4, 2]),1);
  assert.deepEqual(candidate([1, 2, 3, 2, 1]),0);
  assert.deepEqual(candidate([3, 1, 1, 3]),0);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([0, 1]),1);
}

test();"
HumanEval_74,als_Latn,ts,"//Shembuj //nëse dy renditje kanë të njëjtin numër karakteresh, kthehet renditja e parë.//numri i përgjithshëm i karaktereve në të gjitha vargjet e masës më pak se masën tjetër.//Shkruaj një funksion që pranon dy forma të vargjeve dhe kthen forma që ka // >>> total_match([], [])
// []
// >>> total_match([""hi"", ""admin""], [""hI"", ""Hi""])
// [""hI"", ""Hi""]
// >>> total_match([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
// [""hi"", ""admin""]
// >>> total_match([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
// [""hI"", ""hi"", ""hi""]
// >>> total_match([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
// [""4""]
function total_match(lst1: string[], lst2: string[]): string[] {
","function total_match(lst1: string[], lst2: string[]): string[] {
    const getTotalChars = (arr: string[]): number => {
        return arr.reduce((acc, str) => acc + str.length, 0);
    };

    const totalChars1 = getTotalChars(lst1);
    const totalChars2 = getTotalChars(lst2);

    if (totalChars1 < totalChars2) {
        return lst1;
    } else if (totalChars2 < totalChars1) {
        return lst2;
    } else {
        return lst1;
    }
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = total_match;
  assert.deepEqual(candidate([], []),[]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi""]),[""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]),[""4""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""Hi""]),[""hI"", ""Hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]),[""hI"", ""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([], [""this""]),[]);
  assert.deepEqual(candidate([""this""], []),[]);
}

test();"
HumanEval_75,als_Latn,ts,"//Shembull: //Duke ditur se (a) është më pak se 100.//dhe të rreme në të kundërtën.//Shkruaj një funksion që kthehet e vërtetë nëse numri i dhënë është shumëzimi i 3 numrave të parë // >>> is_multiply_prime(30)
// true
// 30 = 2 * 3 * 5
function is_multiply_prime(a: number): boolean {
","function is_multiply_prime(a: number): boolean {
    // Helper function to check if a number is prime
    function isPrime(n: number): boolean {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 === 0 || n % 3 === 0) return false;
        for (let i = 5; i * i <= n; i += 6) {
            if (n % i === 0 || n % (i + 2) === 0) return false;
        }
        return true;
    }

    // Generate a list of primes less than 100
    const primes: number[] = [];
    for (let i = 2; i < 100; i++) {
        if (isPrime(i)) {
            primes.push(i);
        }
    }

    // Check if a can be expressed as a product of 3 distinct primes
    const primeCount = primes.length;
    for (let i = 0; i < primeCount - 2; i++) {
        for (let j = i + 1; j < primeCount - 1; j++) {
            for (let k = j + 1; k < primeCount; k++) {
                if (primes[i] * primes[j] * primes[k] === a) {
                    return true;
                }
            }
        }
    }
    
    return false;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_multiply_prime;
  assert.deepEqual(candidate(5),false);
  assert.deepEqual(candidate(30),true);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),false);
  assert.deepEqual(candidate(125),true);
  assert.deepEqual(candidate(105),true);
  assert.deepEqual(candidate(126),false);
  assert.deepEqual(candidate(729),false);
  assert.deepEqual(candidate(891),false);
  assert.deepEqual(candidate(1001),true);
}

test();"
HumanEval_76,als_Latn,ts,"//Për shembull: //x është një fuqi e thjeshtë e n nëse n**int=x //fuqia e n dhe false në raste të tjera. //Detyra juaj është të shkruani një funksion që kthehet e vërtetë nëse një numër x është një i thjeshtë // >>> is_simple_power(1, 4)
// true
// >>> is_simple_power(2, 2)
// true
// >>> is_simple_power(8, 2)
// true
// >>> is_simple_power(3, 2)
// false
// >>> is_simple_power(3, 1)
// false
// >>> is_simple_power(5, 3)
// false
function is_simple_power(x: number, n: number): boolean {
","function is_simple_power(x: number, n: number): boolean {
    if (x < 1 || n < 1) return false;
    if (x === 1) return true; // n^0 is 1 for any n

    let power = 1;
    while (power < x) {
        power *= n;
    }
    
    return power === x;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_simple_power;
  assert.deepEqual(candidate(16, 2),true);
  assert.deepEqual(candidate(143214, 16),false);
  assert.deepEqual(candidate(4, 2),true);
  assert.deepEqual(candidate(9, 3),true);
  assert.deepEqual(candidate(16, 4),true);
  assert.deepEqual(candidate(24, 2),false);
  assert.deepEqual(candidate(128, 4),false);
  assert.deepEqual(candidate(12, 6),false);
  assert.deepEqual(candidate(1, 1),true);
  assert.deepEqual(candidate(1, 12),true);
}

test();"
HumanEval_77,als_Latn,ts,"//Shembuj: //Shënim: mund të supozojmë se input është gjithmonë e vlefshme.//nëse ky ingeger është një kub i disa numrave të plotë.//Shkruaj një funksion që merr një numër të plotë a dhe kthen të vërtetë .// >>> iscube(1)
// true
// >>> iscube(2)
// false
// >>> iscube(-1)
// true
// >>> iscube(64)
// true
// >>> iscube(0)
// true
// >>> iscube(180)
// false
function iscube(a: number): boolean {
","function iscube(a: number): boolean {
    // Calculate the cube root of the absolute value of a
    const cubeRoot = Math.cbrt(Math.abs(a));
    // Check if the cube root is an integer
    return cubeRoot === Math.round(cubeRoot);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = iscube;
  assert.deepEqual(candidate(1),true);
  assert.deepEqual(candidate(2),false);
  assert.deepEqual(candidate(-1),true);
  assert.deepEqual(candidate(64),true);
  assert.deepEqual(candidate(180),false);
  assert.deepEqual(candidate(1000),true);
  assert.deepEqual(candidate(0),true);
  assert.deepEqual(candidate(1729),false);
}

test();"
HumanEval_78,als_Latn,ts,"//Shembuj: //dhe simbolet A,B,C,D,E,F janë gjithmonë me shkronja të mëdha.//Shënim: ju mund të supozojë se hyrja është gjithmonë e saktë ose bosh string, //B (= decimal 11), D (= decimal 13). //Pra ju duhet të gjeni një numër nga shifrat e mëposhtme: 2, 3, 5, 7, //Numrat e parë janë 2, 3, 5, 7, 11, 13, 17,...//Shifrat heksaxadecimale janë 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. //më i madh se 1 që nuk është një produkt i dy numrave natyral më të vegjël).//shifra që janë primë (numri prim, ose një prim, është një numër natyral //një numër heksaximal si një varg dhe numëron numrin e hexadecimalëve //Ju është caktuar të shkruani një funksion që merr .// >>> hex_key(""AB"")
// 1
// >>> hex_key(""1077E"")
// 2
// >>> hex_key(""ABED1A33"")
// 4
// >>> hex_key(""123456789ABCDEF0"")
// 6
// >>> hex_key(""2020"")
// 2
function hex_key(num: string): number {
","function hex_key(num: string): number {
    const primeHexDigits = new Set(['2', '3', '5', '7', 'B', 'D']);
    let count = 0;

    for (let digit of num) {
        if (primeHexDigits.has(digit)) {
            count++;
        }
    }

    return count;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = hex_key;
  assert.deepEqual(candidate(""AB""),1);
  assert.deepEqual(candidate(""1077E""),2);
  assert.deepEqual(candidate(""ABED1A33""),4);
  assert.deepEqual(candidate(""2020""),2);
  assert.deepEqual(candidate(""123456789ABCDEF0""),6);
  assert.deepEqual(candidate(""112233445566778899AABBCCDDEEFF00""),12);
}

test();"
HumanEval_79,als_Latn,ts,"//Shembuj: //Karakteret shtesë janë aty për të ndihmuar me formatin.//Do të ketë një çift shtesë të karaktereve 'db' në fillim dhe në fund të vargjes.//Çdo karakter në varg do të jetë ""0"" ose ""1"".//formati binar. Funksioni duhet të kthejë një varg, me secilin karakter që përfaqëson një binar //Do t'ju jepet një numër në formën dhjetore dhe detyra juaj është që ta konvertoni në // >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
function decimal_to_binary(decimal: number): string {
","function decimal_to_binary(decimal: number): string {
    const binaryString = decimal.toString(2);
    return `db${binaryString}db`;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = decimal_to_binary;
  assert.deepEqual(candidate(0),""db0db"");
  assert.deepEqual(candidate(32),""db100000db"");
  assert.deepEqual(candidate(103),""db1100111db"");
  assert.deepEqual(candidate(15),""db1111db"");
}

test();"
HumanEval_80,als_Latn,ts,"//Për shembull: //Një varg është hapt nëse gjatësia e tij është të paktën 3 dhe çdo 3 shkronja rresht janë të dallueshme //Detyra juaj është të kontrolloni nëse vargu është hapt apo jo.//Ju jepet një varg s.// >>> is_happy(""a"")
// false
// >>> is_happy(""aa"")
// false
// >>> is_happy(""abcd"")
// true
// >>> is_happy(""aabb"")
// false
// >>> is_happy(""adb"")
// true
// >>> is_happy(""xyy"")
// false
function is_happy(s: string): boolean {
","function is_happy(s: string): boolean {
    if (s.length < 3) return false;

    for (let i = 0; i <= s.length - 3; i++) {
        const set = new Set(s.substring(i, i + 3));
        if (set.size !== 3) {
            return false;
        }
    }
    
    return true;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_happy;
  assert.deepEqual(candidate(""a""),false);
  assert.deepEqual(candidate(""aa""),false);
  assert.deepEqual(candidate(""abcd""),true);
  assert.deepEqual(candidate(""aabb""),false);
  assert.deepEqual(candidate(""adb""),true);
  assert.deepEqual(candidate(""xyy""),false);
  assert.deepEqual(candidate(""iopaxpoi""),true);
  assert.deepEqual(candidate(""iopaxioi""),false);
}

test();"
HumanEval_81,als_Latn,ts,"//Shembull: //0.0 E //> 0.0 D- //> 0.7 D //> 1.0 D+ //> 1.3 C- //> 1.7 C //> 2.0 C+ //> 2.3 B- //> 2.7 B //> 3.0 B+ //> 3.3 A- //> 3.7 A //4.0 A+ //GPA. Shkalla e letrave.//një funksion që mund të prodhojë një sërë shkallësh shkronjesh duke përdorur tabelën e mëposhtme: //Ajo të ka dhënë një sërë mesatareve për disa nxënës dhe ti duhet të shkruash.//Problemi është se ajo e ka humbur kodin që e përdorte për të vlerësuar.//Mësuesi ka krijuar algoritmin e vet për vlerësimin.//Është javën e fundit të semestrit dhe mësuesi duhet të japë notat.// >>> grade_equation([4.0, 3, 1.7, 2, 3.5])
// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
function numerical_letter_grade(grades: number[]): string[] {
","function numerical_letter_grade(grades: number[]): string[] {
    return grades.map(gpa => {
        if (gpa === 4.0) return ""A+"";
        if (gpa > 3.7) return ""A"";
        if (gpa > 3.3) return ""A-"";
        if (gpa > 3.0) return ""B+"";
        if (gpa > 2.7) return ""B"";
        if (gpa > 2.3) return ""B-"";
        if (gpa > 2.0) return ""C+"";
        if (gpa > 1.7) return ""C"";
        if (gpa > 1.3) return ""C-"";
        if (gpa > 1.0) return ""D+"";
        if (gpa > 0.7) return ""D"";
        if (gpa > 0.0) return ""D-"";
        return ""E"";
    });
}

// Example usage:
// console.log(numerical_letter_grade([4.0, 3, 1.7, 2, 3.5])); // [""A+"", ""B"", ""C-"", ""C"", ""A-""]","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = numerical_letter_grade;
  assert.deepEqual(candidate([4.0, 3, 1.7, 2, 3.5]),[""A+"", ""B"", ""C-"", ""C"", ""A-""]);
  assert.deepEqual(candidate([1.2]),[""D+""]);
  assert.deepEqual(candidate([0.5]),[""D-""]);
  assert.deepEqual(candidate([0.0]),[""E""]);
  assert.deepEqual(candidate([1.0, 0.3, 1.5, 2.8, 3.3]),[""D"", ""D-"", ""C-"", ""B"", ""B+""]);
  assert.deepEqual(candidate([0.0, 0.7]),[""E"", ""D-""]);
}

test();"
HumanEval_82,als_Latn,ts,"//Shembuj //gjatësia është një numër i parë ose i rremë në rast të kundërt //Shkruaj një funksion që merr një varg dhe kthen të vërtetë nëse vargu // >>> prime_length(""Hello"")
// true
// >>> prime_length(""abcdcba"")
// true
// >>> prime_length(""kittens"")
// true
// >>> prime_length(""orange"")
// false
function prime_length(string: string): boolean {
","function prime_length(string: string): boolean {
    const length = string.length;

    if (length < 2) return false;

    for (let i = 2; i * i <= length; i++) {
        if (length % i === 0) {
            return false;
        }
    }
    
    return true;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = prime_length;
  assert.deepEqual(candidate(""Hello""),true);
  assert.deepEqual(candidate(""abcdcba""),true);
  assert.deepEqual(candidate(""kittens""),true);
  assert.deepEqual(candidate(""orange""),false);
  assert.deepEqual(candidate(""wow""),true);
  assert.deepEqual(candidate(""world""),true);
  assert.deepEqual(candidate(""MadaM""),true);
  assert.deepEqual(candidate(""Wow""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""HI""),true);
  assert.deepEqual(candidate(""go""),true);
  assert.deepEqual(candidate(""gogo""),false);
  assert.deepEqual(candidate(""aaaaaaaaaaaaaaa""),false);
  assert.deepEqual(candidate(""Madam""),true);
  assert.deepEqual(candidate(""M""),false);
  assert.deepEqual(candidate(""0""),false);
}

test();"
HumanEval_83,als_Latn,ts,"//Numrat e plotë pozitivë që fillojnë ose përfundojnë me 1.//Duke pasur parasysh një numër të plotë pozitiv n, kthe numrin e numrave me n shifra.function starts_one_ends(n: number): number {
","function starts_one_ends(n: number): number {
    if (n === 1) {
        return 1; // The number '1' is the only 1-digit number starting or ending with '1'
    }

    const totalNumbers = Math.pow(10, n - 1); // Total n-digit numbers starting with any digit from 1 to 9
    const startingWithOne = Math.pow(10, n - 1); // The n-digit numbers starting with '1'
    const endingWithOne = Math.pow(10, n - 1); // The n-digit numbers ending with '1'
    const startingAndEndingWithOne = Math.pow(10, n - 2); // The n-digit numbers starting and ending with '1' 

    // To find numbers that start or end with 1, add those starting with 1 
    // and those ending with 1, then subtract the overlap (those both starting and ending with 1).
    return startingWithOne + endingWithOne - startingAndEndingWithOne;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = starts_one_ends;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(2),18);
  assert.deepEqual(candidate(3),180);
  assert.deepEqual(candidate(4),1800);
  assert.deepEqual(candidate(5),18000);
}

test();"
HumanEval_84,als_Latn,ts,"//Shembull //Duke pasur parasysh një numër të plotë pozitiv N, kthejnë shumën totale të shifrave të saj në binar. // >>> solve(1000)
// ""1""
// >>> solve(150)
// ""110""
// >>> solve(147)
// ""1100""
// Variables:
// @N integer
// Constraints: 0 ≤ N ≤ 10000.
// Output:
// a string of binary number
function solve(N: number): string {
","function solve(N: number): string {
    let sumOfDigits = 0;
    while (N > 0) {
        sumOfDigits += N % 10;
        N = Math.floor(N / 10);
    }
    return sumOfDigits.toString(2);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(1000),""1"");
  assert.deepEqual(candidate(150),""110"");
  assert.deepEqual(candidate(147),""1100"");
  assert.deepEqual(candidate(333),""1001"");
  assert.deepEqual(candidate(963),""10010"");
}

test();"
HumanEval_85,als_Latn,ts,"//Shembuj: //Duke pasur parasysh një sërë jo bosh të integers lst. shtoj elementet madje që janë në indekse çuditshme .. // >>> add([4, 2, 6, 7])
// 2
function add(lst: number[]): number {
","function add(lst: number[]): number {
    return lst.reduce((sum, num, index) => {
        if (index % 2 === 1 && num % 2 === 0) {
            return sum + num;
        }
        return sum;
    }, 0);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate([4, 88]),88);
  assert.deepEqual(candidate([4, 5, 6, 7, 2, 122]),122);
  assert.deepEqual(candidate([4, 0, 6, 7]),0);
  assert.deepEqual(candidate([4, 4, 6, 8]),12);
}

test();"
HumanEval_86,als_Latn,ts,"//Për shembull: //Shënim: Duhet të mbani rendin e fjalëve dhe hapësirat e zbrazëta në fjali.//renditjes në rritje të bazuar në vlerën ASCII. //janë zëvendësuar me një fjalë të re ku të gjitha karakteret janë rregulluar në //Versioni i porositur i varg, është një varg ku të gjitha fjalët (të ndara me hapësirë) //Shkruaj një funksion që merr një varg dhe kthen një version të porositur të tij.// >>> anti_shuffle(""Hi"")
// ""Hi""
// >>> anti_shuffle(""hello"")
// ""ehllo""
// >>> anti_shuffle(""Hello World!!!"")
// ""Hello !!!Wdlor""
function anti_shuffle(s: string): string {
","function anti_shuffle(s: string): string {
  return s.split(' ').map(word =>
    word.split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')
  ).join(' ');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = anti_shuffle;
  assert.deepEqual(candidate(""Hi""),""Hi"");
  assert.deepEqual(candidate(""hello""),""ehllo"");
  assert.deepEqual(candidate(""number""),""bemnru"");
  assert.deepEqual(candidate(""abcd""),""abcd"");
  assert.deepEqual(candidate(""Hello World!!!""),""Hello !!!Wdlor"");
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hi. My name is Mister Robot. How are you?""),"".Hi My aemn is Meirst .Rboot How aer ?ouy"");
}

test();"
HumanEval_87,als_Latn,ts,"//Shembuj: //Gjithashtu, rendoni koordinatat e rreshtit sipas kolonave në rend zbritës.//Sort koordinatat fillimisht nga rreshtat në rendin ngjitës.//secili grup është një koordinatë - (rresht, kolona), duke filluar me 0. //dhe kthehet array e arrays, [(x1, y1), (x2, y2) ...] të tillë që //Duke pasur parasysh lst, dhe x numër i plotë, gjeni numrat e plotë x në masë, //secila rresht mund të përmbajë një numër të ndryshëm kolonave. //i cili është i ngjashëm me matricën, megjithatë, ndryshe nga matricat, //Ju jepet një 2 të dhëna dimensionale, si një masë e fshikulluar, // >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
// >>> get_row([], 1)
// []
// >>> get_row([[], [1], [1, 2, 3]], 3)
// [[2, 2]]
function get_row(lst: number[][], x: number): [number, number][] {
","function get_row(lst: number[][], x: number): [number, number][] {
    const coordinates: [number, number][] = [];

    // Traverse the data matrix
    lst.forEach((row, rowIndex) => {
        row.forEach((value, colIndex) => {
            if (value === x) {
                coordinates.push([rowIndex, colIndex]);
            }
        });
    });

    // Sort the coordinates
    coordinates.sort(([row1, col1], [row2, col2]) => {
        if (row1 === row2) {
            // Sort by columns in descending order
            return col2 - col1;
        }
        // Sort by rows in ascending order
        return row1 - row2;
    });

    return coordinates;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = get_row;
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);
  assert.deepEqual(candidate([], 1),[]);
  assert.deepEqual(candidate([[1]], 2),[]);
  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);
}

test();"
HumanEval_88,als_Latn,ts,"//Shembuj: //* mos e ndrysho rendin e dhënë. //Shënim://ose renditeni në mënyrë zbritëse nëse shuma ((vlera e parë e indeksit, vlera e fundit e indeksit) është e çift. //ju do të renditeni masën e dhënë në rendin ngjitës nëse shuma ((vlera e parë e indeksit, vlera e fundit e indeksit) është e rastësishme, //Duke pasur parasysh një sërë e integers jo-negative, kthehet një cots e sërë të dhënë pas renditjes, // >>> sort_array([])
// []
// >>> sort_array([5])
// [5]
// >>> sort_array([2, 4, 3, 0, 1, 5])
// [0, 1, 2, 3, 4, 5]
// >>> sort_array([2, 4, 3, 0, 1, 5, 6])
// [6, 5, 4, 3, 2, 1, 0]
function sort_array(array: number[]): number[] {
","function sort_array(array: number[]): number[] {
    if (array.length === 0) {
        return [];
    }

    const firstValue = array[0];
    const lastValue = array[array.length - 1];
    const sum = firstValue + lastValue;

    const sortedArray = [...array].sort((a, b) => a - b);

    if (sum % 2 === 0) {
        return sortedArray.reverse();
    } else {
        return sortedArray;
    }
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5]),[5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0]);
  assert.deepEqual(candidate([2, 1]),[1, 2]);
  assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);
  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);
}

test();"
HumanEval_89,als_Latn,ts,"//Për shembull: //Shko poshtë me dy herë në dy vende.//Alfabeti duhet të rrotullohet në mënyrë të tillë që shkronjat //kthen një varg të koduar me alfabetin që rrotullohet. //Krijo një funksion të koduar që merr një varg si argument dhe // >>> encrypt(""hi"")
// ""lm""
// >>> encrypt(""asdfghjkl"")
// ""ewhjklnop""
// >>> encrypt(""gf"")
// ""kj""
// >>> encrypt(""et"")
// ""ix""
function encrypt(s: string): string {
","function encrypt(s: string): string {
    const shift = 2 * 2; // Shift by 4 places
    const alphabetSize = 26;
    
    return s.split('').map(char => {
        const charCode = char.charCodeAt(0);
        
        // Check if the character is a lowercase letter
        if (charCode >= 97 && charCode <= 122) {
            let newCharCode = charCode + shift;
            
            // Wrap around if it goes past 'z'
            if (newCharCode > 122) {
                newCharCode = (newCharCode - 97) % alphabetSize + 97;
            }
            
            return String.fromCharCode(newCharCode);
        }

        // Return the character unchanged if it's not a lowercase letter
        return char;
    }).join('');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = encrypt;
  assert.deepEqual(candidate(""hi""),""lm"");
  assert.deepEqual(candidate(""asdfghjkl""),""ewhjklnop"");
  assert.deepEqual(candidate(""gf""),""kj"");
  assert.deepEqual(candidate(""et""),""ix"");
  assert.deepEqual(candidate(""faewfawefaewg""),""jeiajeaijeiak"");
  assert.deepEqual(candidate(""hellomyfriend""),""lippsqcjvmirh"");
  assert.deepEqual(candidate(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""),""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"");
  assert.deepEqual(candidate(""a""),""e"");
}

test();"
HumanEval_90,als_Latn,ts,"//Kthehet e pacaktuar nëse nuk ka një element të tillë.//Shkruaj një funksion next_smallest (() që kthen elementin e dytë më të vogël të masës. //Ju jepet një sërë e integers.// >>> next_smallest([1, 2, 3, 4, 5])
// 2
// >>> next_smallest([5, 1, 4, 3, 2])
// 2
// >>> next_smallest([])
// undefined
// >>> next_smallest([1, 1])
// undefined
function next_smallest(lst: number[]): number | undefined {
","function next_smallest(lst: number[]): number | undefined {
    if (lst.length < 2) {
        return undefined;
    }
    
    let first: number | undefined = undefined;
    let second: number | undefined = undefined;
    
    for (let num of lst) {
        if (first === undefined || num < first) {
            second = first;
            first = num;
        } else if (num > first && (second === undefined || num < second)) {
            second = num;
        }
    }

    return second;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = next_smallest;
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),2);
  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([1, 1, 1, 1, 0]),1);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([-35, 34, 12, -45]),-35);
}

test();"
HumanEval_91,als_Latn,ts,"//Për shembull: //Fjalët kufizohen me '.', '?' ose '!'. //Një mërzi është një fjali që fillon me fjalën ""Unë"".//Do të të jepet një varg fjalësh, dhe detyra jote është të numërosh numrin.// >>> is_bored(""Hello world"")
// 0
// >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
// 1
function is_bored(S: string): number {
","function is_bored(S: string): number {
    // Split the string into sentences using '.', '?' or '!' as delimiters
    const sentences = S.split(/[.!?]/);

    // Filter sentences that start with ""I"" and count them
    const boredomCount = sentences.filter(sentence => sentence.trim().startsWith('I')).length;

    return boredomCount;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_bored;
  assert.deepEqual(candidate(""Hello world""),0);
  assert.deepEqual(candidate(""Is the sky blue?""),0);
  assert.deepEqual(candidate(""I love It !""),1);
  assert.deepEqual(candidate(""bIt""),0);
  assert.deepEqual(candidate(""I feel good today. I will be productive. will kill It""),2);
  assert.deepEqual(candidate(""You and I are going for a walk""),0);
}

test();"
HumanEval_92,als_Latn,ts,"//Shembuj //Kthen false në çdo rast tjetër.//Kthen të vërtetë nëse një nga numrat është e barabartë me shumën e dy numrave të tjerë, dhe të gjithë numrat janë integers. //Krijo një funksion që merr 3 numra.// >>> any_int(5, 2, 7)
// true
// >>> any_int(3, 2, 2)
// false
// >>> any_int(3, -2, 1)
// true
// >>> any_int(3.6, -2.2, 2)
// false
function any_int(x: number, y: number, z: number): boolean {
","function any_int(x: number, y: number, z: number): boolean {
    // Check if all numbers are integers
    if (!Number.isInteger(x) || !Number.isInteger(y) || !Number.isInteger(z)) {
        return false;
    }
    // Check if one of the numbers is the sum of the other two
    if (x === y + z || y === x + z || z === x + y) {
        return true;
    }
    return false;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = any_int;
  assert.deepEqual(candidate(2, 3, 1),true);
  assert.deepEqual(candidate(2.5, 2, 3),false);
  assert.deepEqual(candidate(1.5, 5, 3.5),false);
  assert.deepEqual(candidate(2, 6, 2),false);
  assert.deepEqual(candidate(4, 2, 2),true);
  assert.deepEqual(candidate(2.2, 2.2, 2.2),false);
  assert.deepEqual(candidate(-4, 6, 2),true);
  assert.deepEqual(candidate(2, 1, 1),true);
  assert.deepEqual(candidate(3, 4, 7),true);
  assert.deepEqual(candidate(3.0, 4, 7),false);
}

test();"
HumanEval_93,als_Latn,ts,"//Shembuj: //Merrni vetëm shkronja.//një vokal në alfabetin anglez.//Mesazhi me shkronja që shfaqet 2 vende para saj.//në mënyrë që të ndërrojë rastin e të gjitha shkronjave, zëvendëson të gjitha vokalët në //Shkruaj një funksion që merr një mesazh, dhe kodon në një të tillë // >>> encode(""test"")
// ""TGST""
// >>> encode(""This is a message"")
// ""tHKS KS C MGSSCGG""
function encode(message: string): string {
","function encode(message: string): string {
    const swapCase = (char: string): string => {
        if (char === char.toLowerCase()) {
            return char.toUpperCase();
        } else {
            return char.toLowerCase();
        }
    };

    const replaceVowel = (char: string): string => {
        const vowels = 'aeiou';
        const nextVowels = 'cgkqw';
        const index = vowels.indexOf(char.toLowerCase());
        if (index !== -1) {
            return char === char.toLowerCase() 
                ? nextVowels[index] 
                : nextVowels[index].toUpperCase();
        }
        return char;
    };

    return message
        .split('')
        .map(char => swapCase(replaceVowel(char)))
        .join('');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = encode;
  assert.deepEqual(candidate(""TEST""),""tgst"");
  assert.deepEqual(candidate(""Mudasir""),""mWDCSKR"");
  assert.deepEqual(candidate(""YES""),""ygs"");
  assert.deepEqual(candidate(""This is a message""),""tHKS KS C MGSSCGG"");
  assert.deepEqual(candidate(""I DoNt KnOw WhAt tO WrItE""),""k dQnT kNqW wHcT Tq wRkTg"");
}

test();"
HumanEval_94,als_Latn,ts,"//Shembuj: //Ju duhet të gjeni vlerën më të madhe të parë dhe të kthehet shuma e shifrave të saj.//Ju jepet një sërë e integers.// >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
// 10
// >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
// 25
// >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
// 13
// >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
// 11
// >>> skjkasdkd([0, 81, 12, 3, 1, 21])
// 3
// >>> skjkasdkd([0, 8, 1, 2, 1, 7])
// 7
function skjkasdkd(lst: number[]): number {
","function isPrime(n: number): boolean {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
}

function sumOfDigits(n: number): number {
    let sum = 0;
    while (n > 0) {
        sum += n % 10;
        n = Math.floor(n / 10);
    }
    return sum;
}

function skjkasdkd(lst: number[]): number {
    let maxPrime = -1;

    for (const num of lst) {
        if (isPrime(num) && num > maxPrime) {
            maxPrime = num;
        }
    }

    return maxPrime === -1 ? 0 : sumOfDigits(maxPrime);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = skjkasdkd;
  assert.deepEqual(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10);
  assert.deepEqual(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25);
  assert.deepEqual(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13);
  assert.deepEqual(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11);
  assert.deepEqual(candidate([0, 81, 12, 3, 1, 21]),3);
  assert.deepEqual(candidate([0, 8, 1, 2, 1, 7]),7);
  assert.deepEqual(candidate([8191]),19);
  assert.deepEqual(candidate([8191, 123456, 127, 7]),19);
  assert.deepEqual(candidate([127, 97, 8192]),10);
}

test();"
HumanEval_95,als_Latn,ts,"//Shembuj: //Funksioni duhet të kthejë false nëse objekti i dhënë është bosh. //case ose të gjitha çelësat janë vargjet me shkronja të mëdha, përndryshe kthehet false. //Duke pasur parasysh një objekt, kthehet e vërtetë nëse të gjitha çelësat janë vargjet në më të ulët // >>> check_dict_case({""a"": ""apple"", ""b"": ""banana""})
// true
// >>> check_dict_case({""a"": ""apple"", ""A"": ""banana"", ""B"": ""banana""})
// false
// >>> check_dict_case({""a"": ""apple"", 8: ""banana"", ""a"": ""apple""})
// false
// >>> check_dict_case({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""})
// false
// >>> check_dict_case({""STATE"": ""NC"", ""ZIP"": ""12345""})
// true
function check_dict_case(dict: {[key: string]: string}): boolean {
","function check_dict_case(dict: { [key: string]: string }): boolean {
    const keys = Object.keys(dict);
    if (keys.length === 0) return false;

    const allLowerCase = keys.every(key => key === key.toLowerCase());
    const allUpperCase = keys.every(key => key === key.toUpperCase());

    return allLowerCase || allUpperCase;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = check_dict_case;
  assert.deepEqual(candidate({""p"": ""pineapple"", ""b"": ""banana""}),true);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""A"": ""banana"", ""B"": ""banana""}),false);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""5"": ""banana"", ""a"": ""apple""}),false);
  assert.deepEqual(candidate({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""}),false);
  assert.deepEqual(candidate({""STATE"": ""NC"", ""ZIP"": ""12345""}),true);
  assert.deepEqual(candidate({""fruit"": ""Orange"", ""taste"": ""Sweet""}),true);
  assert.deepEqual(candidate({}),false);
}

test();"
HumanEval_96,als_Latn,ts,"//për shembull: //numrat e plotë që janë numra të parë dhe më pak se n.//Implementon një funksion që merr një numër të plotë jo-negativ dhe kthen një masë të n të parëve // >>> count_up_to(5)
// [2, 3]
// >>> count_up_to(11)
// [2, 3, 5, 7]
// >>> count_up_to(0)
// []
// >>> count_up_to(20)
// [2, 3, 5, 7, 11, 13, 17, 19]
// >>> count_up_to(1)
// []
// >>> count_up_to(18)
// [2, 3, 5, 7, 11, 13, 17]
function count_up_to(n: number): number[] {
","function count_up_to(n: number): number[] {
    function isPrime(num: number): boolean {
        if (num < 2) return false;
        for (let i = 2; i <= Math.sqrt(num); i++) {
            if (num % i === 0) return false;
        }
        return true;
    }

    const primes: number[] = [];
    for (let i = 2; i < n; i++) {
        if (isPrime(i)) {
            primes.push(i);
        }
    }

    return primes;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = count_up_to;
  assert.deepEqual(candidate(5),[2, 3]);
  assert.deepEqual(candidate(6),[2, 3, 5]);
  assert.deepEqual(candidate(7),[2, 3, 5]);
  assert.deepEqual(candidate(10),[2, 3, 5, 7]);
  assert.deepEqual(candidate(0),[]);
  assert.deepEqual(candidate(22),[2, 3, 5, 7, 11, 13, 17, 19]);
  assert.deepEqual(candidate(1),[]);
  assert.deepEqual(candidate(18),[2, 3, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
  assert.deepEqual(candidate(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

test();"
HumanEval_97,als_Latn,ts,"//Shembuj: //Supozoni se input është gjithmonë i vlefshëm.//prodhimi i shifrave të tyre të njësisë. //Plotësoni funksionin që merr dy numra të plotë dhe kthen // >>> multiply(148, 412)
// 16
// >>> multiply(19, 28)
// 72
// >>> multiply(2020, 1851)
// 0
// >>> multiply(14, -15)
// 20
function multiply(a: number, b: number): number {
","function multiply(a: number, b: number): number {
    const unitDigitA = Math.abs(a) % 10;
    const unitDigitB = Math.abs(b) % 10;
    return unitDigitA * unitDigitB;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = multiply;
  assert.deepEqual(candidate(148, 412),16);
  assert.deepEqual(candidate(19, 28),72);
  assert.deepEqual(candidate(2020, 1851),0);
  assert.deepEqual(candidate(14, -15),20);
  assert.deepEqual(candidate(76, 67),42);
  assert.deepEqual(candidate(17, 27),49);
  assert.deepEqual(candidate(0, 1),0);
  assert.deepEqual(candidate(0, 0),0);
}

test();"
HumanEval_98,als_Latn,ts,"//Për shembull: //Duke pasur parasysh një varg s, numëroni numrin e vokalëve të mëdha në indekse të para. // >>> count_upper(""aBCdEf"")
// 1
// >>> count_upper(""abcdefg"")
// 0
// >>> count_upper(""dBBE"")
// 0
function count_upper(s: string): number {
","function count_upper(s: string): number {
    const uppercaseVowels = new Set(['A', 'E', 'I', 'O', 'U']);
    let count = 0;
    
    for (let i = 0; i < s.length; i += 2) {
        if (uppercaseVowels.has(s[i])) {
            count++;
        }
    }
    
    return count;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = count_upper;
  assert.deepEqual(candidate(""aBCdEf""),1);
  assert.deepEqual(candidate(""abcdefg""),0);
  assert.deepEqual(candidate(""dBBE""),0);
  assert.deepEqual(candidate(""B""),0);
  assert.deepEqual(candidate(""U""),1);
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""EEEE""),2);
}

test();"
HumanEval_99,als_Latn,ts,"//Shembuj //nga dy numra të plotë, rrumbullakoseni larg zero.//dhe kthen numrin e plotë më të afërt me të. Nëse numri është i njëjtë me largësinë //Krijoni një funksion që merr një vlerë (string) që përfaqëson një numër // >>> closest_integer(""10"")
// 10
// >>> closest_integer(""15.3"")
// 15
// Note:
// Rounding away from zero means that if the given number is equidistant
// from two integers, the one you should return is the one that is the
// farthest from zero. For example closest_integer(""14.5"") should
// return 15 and closest_integer(""-14.5"") should return -15.
function closest_integer(value: string): number {
","function closest_integer(value: string): number {
  const num = parseFloat(value);
  if (num > 0) {
    return Math.floor(num + 0.5);
  } else {
    return Math.ceil(num - 0.5);
  }
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = closest_integer;
  assert.deepEqual(candidate(""10""),10);
  assert.deepEqual(candidate(""14.5""),15);
  assert.deepEqual(candidate(""-15.5""),-16);
  assert.deepEqual(candidate(""15.3""),15);
  assert.deepEqual(candidate(""0""),0);
}

test();"
HumanEval_100,als_Latn,ts,"//Shembuj: //i përfaqëson numrin e gurëve në nivel (i+1). //Kthen numrin e gurëve në çdo nivel në një masë, ku element në indeks //- Numri i radhës i çift nëse n është i çift. //- Numri i radhës i rastësishëm nëse n është i rastësishëm. //Numri i gurëve në nivelin tjetër është://Niveli i parë ka n gurë.//Duke pasur parasysh një numër të plotë pozitiv n, ju duhet të bëni një grumbull prej n niveleve të gurëve.// >>> make_a_pile(3)
// [3, 5, 7]
function make_a_pile(n: number): number[] {
","function make_a_pile(n: number): number[] {
    const result: number[] = [];
    let currentStones = n;
    for (let i = 0; i < n; i++) {
        result.push(currentStones);
        if (currentStones % 2 === 0) {
            currentStones += 2; // next even number
        } else {
            currentStones += 2; // next odd number
        }
    }
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = make_a_pile;
  assert.deepEqual(candidate(3),[3, 5, 7]);
  assert.deepEqual(candidate(4),[4, 6, 8, 10]);
  assert.deepEqual(candidate(5),[5, 7, 9, 11, 13]);
  assert.deepEqual(candidate(6),[6, 8, 10, 12, 14, 16]);
  assert.deepEqual(candidate(8),[8, 10, 12, 14, 16, 18, 20, 22]);
}

test();"
HumanEval_101,als_Latn,ts,"//Për shembull: //për të ndarë vargjet në fjalë dhe të kthejë një sërë fjalësh.//Do të të jepet një varg fjalësh të ndara me komma ose hapësira.// >>> words_string(""Hi, my name is John"")
// [""Hi"", ""my"", ""name"", ""is"", ""John""]
// >>> words_string(""One, two, three, four, five, six"")
// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
function words_string(s: string): string[] {
","function words_string(s: string): string[] {
    return s.split(/[\s,]+/).filter(word => word.length > 0);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = words_string;
  assert.deepEqual(candidate(""Hi, my name is John""),[""Hi"", ""my"", ""name"", ""is"", ""John""]);
  assert.deepEqual(candidate(""One, two, three, four, five, six""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""Hi, my name""),[""Hi"", ""my"", ""name""]);
  assert.deepEqual(candidate(""One,, two, three, four, five, six,""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""ahmed     , gamal""),[""ahmed"", ""gamal""]);
}

test();"
HumanEval_102,als_Latn,ts,"//Për shembull: //nuk ka një numër të tillë, atëherë funksioni duhet të kthehet -1.//Numri më i madh i plotë i çift që është në intervalin [x, y] përfshirë.//Kjo funksion merr dy numra pozitivë x dhe y dhe kthen // >>> choose_num(12, 15)
// 14
// >>> choose_num(13, 12)
// -1
function choose_num(x: number, y: number): number {
","function choose_num(x: number, y: number): number {
    // Ensure x is less than or equal to y for proper range searching
    if (x > y) {
        [x, y] = [y, x];
    }
    
    // Start looking from the upper bound of the range
    for (let i = y; i >= x; i--) {
        if (i % 2 === 0) {
            return i;
        }
    }
    
    // If no even number is found in the range
    return -1;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = choose_num;
  assert.deepEqual(candidate(12, 15),14);
  assert.deepEqual(candidate(13, 12),-1);
  assert.deepEqual(candidate(33, 12354),12354);
  assert.deepEqual(candidate(5234, 5233),-1);
  assert.deepEqual(candidate(6, 29),28);
  assert.deepEqual(candidate(27, 10),-1);
  assert.deepEqual(candidate(7, 7),-1);
  assert.deepEqual(candidate(546, 546),546);
}

test();"
HumanEval_103,als_Latn,ts,"//Shembull: //Nëse n është më i madh se m, kthehet -1.//Rrethoni përgjigjen në numrin e plotë më të afërt dhe konvertojeni atë në binar.//mesatarja e numrave të plotë nga n deri në m (duke përfshirë n dhe m).//Ju janë dhënë dy integers pozitive n dhe m, dhe detyra juaj është për të llogaritur // >>> rounded_avg(1, 5)
// ""0b11""
// >>> rounded_avg(7, 5)
// -1
// >>> rounded_avg(10, 20)
// ""0b1111""
// >>> rounded_avg(20, 33)
// ""0b11010""
function rounded_avg(n: number, m: number): string | number {
","function rounded_avg(n: number, m: number): string | number {
    if (n > m) {
        return -1;
    }

    const count = m - n + 1;
    let sum = 0;
    
    for (let i = n; i <= m; i++) {
        sum += i;
    }

    const avg = sum / count;
    const roundedAvg = Math.round(avg);
    return ""0b"" + roundedAvg.toString(2);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = rounded_avg;
  assert.deepEqual(candidate(1, 5),""0b11"");
  assert.deepEqual(candidate(7, 13),""0b1010"");
  assert.deepEqual(candidate(964, 977),""0b1111001010"");
  assert.deepEqual(candidate(996, 997),""0b1111100100"");
  assert.deepEqual(candidate(560, 851),""0b1011000010"");
  assert.deepEqual(candidate(185, 546),""0b101101110"");
  assert.deepEqual(candidate(362, 496),""0b110101101"");
  assert.deepEqual(candidate(350, 902),""0b1001110010"");
  assert.deepEqual(candidate(197, 233),""0b11010111"");
  assert.deepEqual(candidate(7, 5),-1);
  assert.deepEqual(candidate(5, 1),-1);
  assert.deepEqual(candidate(5, 5),""0b101"");
}

test();"
HumanEval_104,als_Latn,ts,"//Për shembull: //Shënim: Array i kthyer duhet të renditet në mënyrë në rritje.//elementet që nuk kanë asnjë shifër të çift.//Duke pasur parasysh një renditje e integers pozitive x. kthehet një renditje të renditur të të gjitha // >>> unique_digits([15, 33, 1422, 1])
// [1, 15, 33]
// >>> unique_digits([152, 323, 1422, 10])
// []
function unique_digits(x: number[]): number[] {
","function unique_digits(x: number[]): number[] {
    // Helper function to check if a number has any even digit
    const hasEvenDigit = (num: number): boolean => {
        while (num > 0) {
            const digit = num % 10;
            if (digit % 2 === 0) return true;
            num = Math.floor(num / 10);
        }
        return false;
    };

    // Filter out numbers without even digits and sort them
    return x.filter(num => !hasEvenDigit(num)).sort((a, b) => a - b);
}

// Example usage:
console.log(unique_digits([15, 33, 1422, 1])); // [1, 15, 33]
console.log(unique_digits([152, 323, 1422, 10])); // []","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = unique_digits;
  assert.deepEqual(candidate([15, 33, 1422, 1]),[1, 15, 33]);
  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);
  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);
  assert.deepEqual(candidate([135, 103, 31]),[31, 135]);
}

test();"
HumanEval_105,als_Latn,ts,"//Për shembull: //Një, dy, tre, katër, pesë, gjashtë, shtatë, tetë, nëntë.//kthej rendin e rezultuar, dhe pastaj zëvendëso çdo shifër me emrin e saj korrespondues nga //Duke pasur parasysh një sërë e integers, rendit integers që janë midis 1 dhe 9 përfshirë, // >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])
// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
// If the array is empty, return an empty array:
// >>> by_length([])
// []
// If the array has any strange number ignore it:
// >>> by_length([1, -1, 55])
// [""One""]
function by_length(arr: number[]): string[] {
","function by_length(arr: number[]): string[] {
    const numberNames: { [key: number]: string } = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    };

    return arr
        .filter(num => num >= 1 && num <= 9)
        .sort((a, b) => b - a)
        .map(num => numberNames[num]);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = by_length;
  assert.deepEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]),[""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -1, 55]),[""One""]);
  assert.deepEqual(candidate([1, -1, 3, 2]),[""Three"", ""Two"", ""One""]);
  assert.deepEqual(candidate([9, 4, 8]),[""Nine"", ""Eight"", ""Four""]);
}

test();"
HumanEval_106,als_Latn,ts,"//Shembull: //Faktoriali i është shumëzimi i numrave nga 1 në i (1 * 2 * ... * i).//Unë filloj nga 1.//ose shuma e numrave nga 1 deri në i. //dhe kthen një masë të madhësisë n, në mënyrë që vlera e elementit në indeks i është faktori i i nëse i është edhe //Implementoni funksionin f që merr n si parameter, // >>> f(5)
// [1, 2, 6, 24, 15]
function f(n: number): number[] {
","function f(n: number): number[] {
    const result: number[] = [];
    for (let i = 1; i <= n; i++) {
        if (i % 2 === 0) {
            // Calculate factorial for even i
            let factorial = 1;
            for (let j = 1; j <= i; j++) {
                factorial *= j;
            }
            result.push(factorial);
        } else {
            // Calculate sum for odd i
            let sum = 0;
            for (let j = 1; j <= i; j++) {
                sum += j;
            }
            result.push(sum);
        }
    }
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = f;
  assert.deepEqual(candidate(5),[1, 2, 6, 24, 15]);
  assert.deepEqual(candidate(7),[1, 2, 6, 24, 15, 720, 28]);
  assert.deepEqual(candidate(1),[1]);
  assert.deepEqual(candidate(3),[1, 2, 6]);
}

test();"
HumanEval_107,als_Latn,ts,"//Shembull 1: //palindromë të tërë që bien brenda intervalit ((1, n), përfshirë. //Duke pasur parasysh një numër të plotë pozitiv n, kthehet një masë që ka numrin e madje dhe i çuditshëm // >>> even_odd_palindrome(3)
// [1, 2]
// Explanation:
// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
// Example 2:
// >>> even_odd_palindrome(12)
// [4, 6]
// Explanation:
// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
// Note:
// 1. 1 <= n <= 10^3
// 2. returned array has the number of even and odd integer palindromes respectively.
function even_odd_palindrome(n: number): [number, number] {
","function isPalindrome(num: number): boolean {
    const str = num.toString();
    return str === str.split('').reverse().join('');
}

function even_odd_palindrome(n: number): [number, number] {
    let evenCount = 0;
    let oddCount = 0;

    for (let i = 1; i <= n; i++) {
        if (isPalindrome(i)) {
            if (i % 2 === 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return [evenCount, oddCount];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = even_odd_palindrome;
  assert.deepEqual(candidate(123),[8, 13]);
  assert.deepEqual(candidate(12),[4, 6]);
  assert.deepEqual(candidate(3),[1, 2]);
  assert.deepEqual(candidate(63),[6, 8]);
  assert.deepEqual(candidate(25),[5, 6]);
  assert.deepEqual(candidate(19),[4, 6]);
  assert.deepEqual(candidate(9),[4, 5]);
  assert.deepEqual(candidate(1),[0, 1]);
}

test();"
HumanEval_108,als_Latn,ts,"//p.sh. -123 ka shifra të nënshkruara -1, 2 dhe 3. //Nëse një numër është negativ, atëherë shifra e tij e parë e nënshkruar do të jetë negative: //numri i elementeve që ka një shtesë të shifrave > 0. //Shkruaj një funksion count_nums i cili merr një sërë të numrave të plotë dhe kthen // >>> count_nums([])
// 0
// >>> count_nums([-1, 11, -11])
// 1
// >>> count_nums([1, 1, 2])
// 3
function count_nums(arr: number[]): number {
","function count_nums(arr: number[]): number {
    function sumOfDigits(num: number): number {
        let sum = 0;
        let str = num.toString();
        for (let i = 0; i < str.length; i++) {
            let digit = parseInt(str[i]);
            if (i === 0 && str[i] === '-') {
                digit = -parseInt(str[i+1]);
                i++;
            }
            sum += digit;
        }
        return sum;
    }

    let count = 0;
    for (const num of arr) {
        if (sumOfDigits(num) > 0) {
            count++;
        }
    }

    return count;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = count_nums;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([-1, -2, 0]),0);
  assert.deepEqual(candidate([1, 1, 2, -2, 3, 4, 5]),6);
  assert.deepEqual(candidate([1, 6, 9, -6, 0, 1, 5]),5);
  assert.deepEqual(candidate([1, 100, 98, -7, 1, -1]),4);
  assert.deepEqual(candidate([12, 23, 34, -45, -56, 0]),5);
  assert.deepEqual(candidate([0, 1]),1);
  assert.deepEqual(candidate([1]),1);
}

test();"
HumanEval_109,als_Latn,ts,"//Për shembull: //Shënim: Matrixja e dhënë është e garantuar të ketë elemente unike.//Nëse renditja e dhënë është bosh atëherë kthehet true. //atëherë kthehet e vërtetë ose kthehet e rremë.//Nëse është e mundur për të marrë array të renditur duke kryer operacionin e mësipërm //pozicioni fillestar në masë, d.m.th. indeksi i 0-të.//Elementi i fundit i rendit do të zhvendoset në //Një operacion i lëvizjes në të djathtë do të thotë lëvizja e të gjitha elementeve të rendit me një.//Ju lejohet të kryeni operacionin e lëvizjes së djathtë sa herë të doni.//operacioni i mëposhtëm në masën e dhënë: //është e mundur të renditet një renditje në mënyrë jo-dalëse duke kryer //Numrat në masë do të renditen në mënyrë të rastësishme.//Ne kemi një sërë 'arr' e N integers arr[1], arr[2], ..., arr[N].The // >>> move_one_ball([3, 4, 5, 1, 2])
// true
// Explanation: By performin 2 right shift operations, non-decreasing order can
// be achieved for the given array.
// >>> move_one_ball([3, 5, 4, 1, 2])
// false
// Explanation:It is not possible to get non-decreasing order for the given
// array by performing any number of right shift operations.
function move_one_ball(arr: number[]): boolean {
","function move_one_ball(arr: number[]): boolean {
    if (arr.length === 0) return true;

    let countDecreases = 0;
    const n = arr.length;

    for (let i = 0; i < n; i++) {
        if (arr[i] > arr[(i + 1) % n]) {
            countDecreases++;
        }
        if (countDecreases > 1) {
            return false;
        }
    }

    return true;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = move_one_ball;
  assert.deepEqual(candidate([3, 4, 5, 1, 2]),true);
  assert.deepEqual(candidate([3, 5, 10, 1, 2]),true);
  assert.deepEqual(candidate([4, 3, 1, 2]),false);
  assert.deepEqual(candidate([3, 5, 4, 1, 2]),false);
  assert.deepEqual(candidate([]),true);
}

test();"
HumanEval_110,als_Latn,ts,"//Për shembull: //Përndryshe, kthe ""JO"".//të gjitha elementët e lst1 të jenë të barabartë, kthe ""YES"". //Nëse është e mundur të shkëmbeni elemente midis lst1 dhe lst2 për të bërë //Nuk ka kufizim në numrin e elementeve të shkëmbyera midis lst1 dhe lst2. //mes tyre për të bërë lst1 një sërë vetëm numra çift. //dhe përcakton nëse është e mundur të kryhet një shkëmbim i elementeve //Në këtë problem, ju do të zbatojë një funksion që merr dy matrices e numrave, // >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
// ""YES""
// >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
// ""NO""
// It is assumed that the input arrays will be non-empty.
function exchange(lst1: number[], lst2: number[]): string {
","function exchange(lst1: number[], lst2: number[]): string {
    const isEven = (num: number) => num % 2 === 0;
    
    // Count the odd numbers in lst1
    const oddCountInLst1 = lst1.reduce((count, num) => count + (isEven(num) ? 0 : 1), 0);

    // Count the even numbers in lst2
    const evenCountInLst2 = lst2.reduce((count, num) => count + (isEven(num) ? 1 : 0), 0);

    // Check if number of odd numbers in lst1 can be matched by even numbers in lst2
    return oddCountInLst1 <= evenCountInLst2 ? ""YES"" : ""NO"";
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = exchange;
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]),""YES"");
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]),""NO"");
  assert.deepEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 4]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 3]),""NO"");
  assert.deepEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),""NO"");
  assert.deepEqual(candidate([100, 200], [200, 200]),""YES"");
}

test();"
HumanEval_111,als_Latn,ts,"//Shembull: //Nëse disa shkronja kanë të njëjtën rast, kthejini të gjitha.//e letrës me më shumë përsëritje dhe që përmban numrin përkatës. //Duke pasur parasysh një varg që përfaqëson një hapësirë të ndarë nga shkronjat e vogla, kthehet një objekt // >>> histogram(""a b c"")
// {""a"": 1, ""b"": 1, ""c"": 1}
// >>> histogram(""a b b a"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""a b c a b"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""b b b b a"")
// {""b"": 4}
// >>> histogram("""")
// {}
function histogram(test: string): {[key: string]: number} {
","function histogram(test: string): { [key: string]: number } {
    if (test.trim() === """") {
        return {};
    }

    const letters = test.split("" "");
    const counts: { [key: string]: number } = {};

    for (const letter of letters) {
        if (letter in counts) {
            counts[letter]++;
        } else {
            counts[letter] = 1;
        }
    }

    let maxCount = 0;
    for (const count of Object.values(counts)) {
        if (count > maxCount) {
            maxCount = count;
        }
    }

    const result: { [key: string]: number } = {};
    for (const [letter, count] of Object.entries(counts)) {
        if (count === maxCount) {
            result[letter] = count;
        }
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = histogram;
  assert.deepEqual(candidate(""a b b a""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c a b""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c d g""),{""a"": 1, ""b"": 1, ""c"": 1, ""d"": 1, ""g"": 1});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""b b b b a""),{""b"": 4});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""""),{});
  assert.deepEqual(candidate(""a""),{""a"": 1});
}

test();"
HumanEval_112,als_Latn,ts,"//Shembull //Ju duhet të kthehet një masë që përmban varg rezultat dhe të vërtetë / të rreme për kontrollin. //Një varg quhet palindrom nëse lexohet njësoj prapa si përpara.//pastaj kontrolloni nëse vargu i rezultatit është palindrom. //Ne kemi dy string s dhe c, ju duhet të fshihet të gjitha karaktereve në s që janë të barabarta me çdo karakter në c //Detyrë // >>> reverse_delete(""abcde"", ""ae"")
// [""bcd"", false]
// >>> reverse_delete(""abcdef"", ""b"")
// [""acdef"", false]
// >>> reverse_delete(""abcdedcba"", ""ab"")
// [""cdedc"", true]
function reverse_delete(s: string, c: string): [string, boolean] {
","function reverse_delete(s: string, c: string): [string, boolean] {
    // Create a Set of characters to delete for faster lookup
    const charsToDelete = new Set(c);

    // Filter out characters in 's' that are in 'c'
    const filteredString = s.split('').filter(char => !charsToDelete.has(char)).join('');

    // Check if the filtered string is a palindrome
    const isPalindrome = filteredString === filteredString.split('').reverse().join('');

    return [filteredString, isPalindrome];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = reverse_delete;
  assert.deepEqual(candidate(""abcde"", ""ae""),[""bcd"", false]);
  assert.deepEqual(candidate(""abcdef"", ""b""),[""acdef"", false]);
  assert.deepEqual(candidate(""abcdedcba"", ""ab""),[""cdedc"", true]);
  assert.deepEqual(candidate(""dwik"", ""w""),[""dik"", false]);
  assert.deepEqual(candidate(""a"", ""a""),["""", true]);
  assert.deepEqual(candidate(""abcdedcba"", """"),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""abcdedcba"", ""v""),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""vabba"", ""v""),[""abba"", true]);
  assert.deepEqual(candidate(""mamma"", ""mia""),["""", true]);
}

test();"
HumanEval_113,als_Latn,ts,"//e shifrave të çuditshme në varg i'th të hyrjes. //string i e input. "" ku të gjitha i duhet të zëvendësohet me numrin //Çdo element i i prodhimit duhet të jetë ""numri i elementeve të çuditshme në //Duke pasur parasysh një sërë stringesh, ku secili string përbëhet vetëm nga shifra, kthehet një sërë.// >>> odd_count([""1234567""])
// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
// >>> odd_count([""3"", ""11111111""])
// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
function odd_count(lst: string[]): string[] {
","function odd_count(lst: string[]): string[] {
    return lst.map(str => {
        // Count the number of odd digits in the string
        let oddCount = Array.from(str).reduce((count, char) => {
            let digit = parseInt(char, 10);
            return digit % 2 !== 0 ? count + 1 : count;
        }, 0);

        // Construct the result string
        return `the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.`;
    });
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = odd_count;
  assert.deepEqual(candidate([""1234567""]),[""the number of odd elements 4n the str4ng 4 of the 4nput.""]);
  assert.deepEqual(candidate([""3"", ""11111111""]),[""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]);
  assert.deepEqual(candidate([""271"", ""137"", ""314""]),[""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""]);
}

test();"
HumanEval_114,als_Latn,ts,"//Shembull //e numrave.//Duke pasur parasysh një sërë e numrave të plotë, gjeni shumën minimale të çdo nën-sërë jo bosh // >>> minSubArraySum([2, 3, 4, 1, 2, 4])
// 1
// >>> minSubArraySum([-1, -2, -3])
// -6
function minSubArraySum(nums: number[]): number {
","function minSubArraySum(nums: number[]): number {
    let minSum = nums[0];
    let currentSum = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        currentSum = Math.min(nums[i], currentSum + nums[i]);
        minSum = Math.min(minSum, currentSum);
    }
    
    return minSum;
}

// Example usage:
// console.log(minSubArraySum([2, 3, 4, 1, 2, 4])); // Output: 1
// console.log(minSubArraySum([-1, -2, -3])); // Output: -6","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = minSubArraySum;
  assert.deepEqual(candidate([2, 3, 4, 1, 2, 4]),1);
  assert.deepEqual(candidate([-1, -2, -3]),-6);
  assert.deepEqual(candidate([-1, -2, -3, 2, -10]),-14);
  assert.deepEqual(candidate([-9999999999999999]),-9999999999999999);
  assert.deepEqual(candidate([0, 10, 20, 1000000]),0);
  assert.deepEqual(candidate([-1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([100, -1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([10, 11, 13, 8, 3, 4]),3);
  assert.deepEqual(candidate([100, -33, 32, -1, 0, -2]),-33);
  assert.deepEqual(candidate([-10]),-10);
  assert.deepEqual(candidate([7]),7);
  assert.deepEqual(candidate([1, -1]),-1);
}

test();"
HumanEval_115,als_Latn,ts,"//Shembull 1: //Shtoni numrin e herë që ju duhet për të ulur kovat.//Detyra juaj është të përdorni kovat për të zbrazur puset.//dhe të gjitha kovat kanë të njëjtën kapacitet.//Çdo pus ka një kovë përkatëse që mund të përdoret për të nxjerrë ujë nga ajo, //dhe çdo 1 në një rresht përfaqëson një njësi të vetme të ujit. //Ju jepet një rrjetë drejtkëndëshe e puset.// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
// 6
// Example 2:
// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
// 5
// Example 3:
// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)
// 0
// Constraints:
// * all wells have the same length
// * 1 <= grid.length <= 10^2
// * 1 <= grid[:,1].length <= 10^2
// * grid[i][j] -> 0 | 1
// * 1 <= capacity <= 10
function max_fill(grid: number[][], capacity: number): number {
","function max_fill(grid: number[][], capacity: number): number {
    let totalBuckets = 0;

    for (let row of grid) {
        let waterUnits = row.reduce((sum, cell) => sum + cell, 0);
        totalBuckets += Math.ceil(waterUnits / capacity);
    }

    return totalBuckets;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = max_fill;
  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);
  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);
  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);
}

test();"
HumanEval_116,als_Latn,ts,"//Duhet të zbatohet kështu://Për numrin e ngjashëm të njësive, renditje bazuar në vlerën dhjetore.//Numri i njësive në paraqitjen e tyre binare në rendin ngjitës.//Në këtë Kata, ju duhet të rendit një sërë e integers jo-negative sipas // >>> sort_array([1, 5, 2, 3, 4])
// [1, 2, 3, 4, 5]
// >>> sort_array([-2, -3, -4, -5, -6])
// [-6, -5, -4, -3, -2]
// >>> sort_array([1, 0, 2, 3, 4])
// [0, 1, 2, 3, 4]
function sort_array(arr: number[]): number[] {
","function sort_array(arr: number[]): number[] {
    return arr.sort((a, b) => {
        const countOnes = (n: number) => n.toString(2).replace(/0/g, """").length;
        const numOnesA = countOnes(a);
        const numOnesB = countOnes(b);

        if (numOnesA !== numOnesB) {
            return numOnesA - numOnesB;
        } else {
            return a - b;
        }
    });
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5]);
  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3]);
  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
  assert.deepEqual(candidate([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
}

test();"
HumanEval_117,als_Latn,ts,"//Shembuj: //Shënim: ju mund të supozojë se varg input përmban vetëm shkronja dhe hapësira.//Nëse string s është bosh atëherë funksioni duhet të kthejë një masë bosh. //n konsonante, në mënyrë që këto fjalë të shfaqen në varg s. //një funksion që kthen një sërë të të gjitha fjalëve nga string s që përmbajnë saktësisht //Duke pasur parasysh një varg s dhe një numër natyror n, ju keni qenë të ngarkuar për të zbatuar // >>> select_words(""Mary had a little lamb"", 4)
// [""little""]
// >>> select_words(""Mary had a little lamb"", 3)
// [""Mary"", ""lamb""]
// >>> select_words(""simple white space"", 2)
// []
// >>> select_words(""Hello world"", 4)
// [""world""]
// >>> select_words(""Uncle sam"", 3)
// [""Uncle""]
function select_words(s: string, n: number): string[] {
","function select_words(s: string, n: number): string[] {
    const isConsonant = (char: string): boolean => {
        const vowels = 'aeiouAEIOU';
        return !vowels.includes(char) && /[a-zA-Z]/.test(char);
    };

    const words = s.split(' ');
    const result: string[] = [];

    for (const word of words) {
        const consonantCount = [...word].filter(isConsonant).length;
        if (consonantCount === n) {
            result.push(word);
        }
    }

    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = select_words;
  assert.deepEqual(candidate(""Mary had a little lamb"", 4),[""little""]);
  assert.deepEqual(candidate(""Mary had a little lamb"", 3),[""Mary"", ""lamb""]);
  assert.deepEqual(candidate(""simple white space"", 2),[]);
  assert.deepEqual(candidate(""Hello world"", 4),[""world""]);
  assert.deepEqual(candidate(""Uncle sam"", 3),[""Uncle""]);
  assert.deepEqual(candidate("""", 4),[]);
  assert.deepEqual(candidate(""a b c d e f"", 1),[""b"", ""c"", ""d"", ""f""]);
}

test();"
HumanEval_118,als_Latn,ts,"//Shembull: //Ju mund të supozojë se string dhënë përmban vetëm letër angleze. //Gjej ndonjë vokal që plotëson kushtet e mësipërme.//Vetëgjuhët në fillim dhe në fund nuk llogariten. Kthejeni një varg bosh nëse nuk e keni bërë.//dy konsonante nga ana e djathtë e fjalës (duke u kujdesur për shkronjat e vogla). //Ju jepet një fjalë, dhe detyra juaj është të gjeni vokalin më të afërt që qëndron në mes të dy fjalëve.// >>> get_closest_vowel(""yogurt"")
// ""u""
// >>> get_closest_vowel(""FULL"")
// ""U""
// >>> get_closest_vowel(""quick"")
// """"
// >>> get_closest_vowel(""ab"")
// """"
function get_closest_vowel(word: string): string {
","function get_closest_vowel(word: string): string {
    const vowels = new Set<string>(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
    for (let i = word.length - 2; i > 0; i--) {
        if (vowels.has(word[i]) && !vowels.has(word[i - 1]) && !vowels.has(word[i + 1])) {
            return word[i];
        }
    }
    return '';
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = get_closest_vowel;
  assert.deepEqual(candidate(""yogurt""),""u"");
  assert.deepEqual(candidate(""full""),""u"");
  assert.deepEqual(candidate(""easy""),"""");
  assert.deepEqual(candidate(""eAsy""),"""");
  assert.deepEqual(candidate(""ali""),"""");
  assert.deepEqual(candidate(""bad""),""a"");
  assert.deepEqual(candidate(""most""),""o"");
  assert.deepEqual(candidate(""ab""),"""");
  assert.deepEqual(candidate(""ba""),"""");
  assert.deepEqual(candidate(""quick""),"""");
  assert.deepEqual(candidate(""anime""),""i"");
  assert.deepEqual(candidate(""Asia""),"""");
  assert.deepEqual(candidate(""Above""),""o"");
}

test();"
HumanEval_119,als_Latn,ts,"//Shembuj: //Kthehet 'Po' nëse ka një mënyrë për të bërë një varg të mirë, dhe kthen 'Jo' në rast të kundërt.//"" (()) "" nuk është.//janë të balancuara. Për shembull: vargu '(()))) është i mirë, ndërsa vargu //Një varg S konsiderohet i mirë nëse dhe vetëm nëse të gjitha parantezat në S //disa rend, që vargu rezultuar do të jetë e mirë.//Puna juaj është të kontrolloni nëse është e mundur të lidhni dy fije në një.//vetëm në parantezat "" (("") ose parantezat e mbyllura "") "".//Ju jepet një sërë prej dy vargjeve, të dy vargjet përbëhen nga të hapur.// >>> match_parens([""()("", "")""])
// ""Yes""
// >>> match_parens(["")"", "")""])
// ""No""
function match_parens(lst: string[]): string {
","function match_parens(lst: string[]): string {
    const canFormGoodString = (s1: string, s2: string): boolean => {
        let balance = 0;

        // Check s1 followed by s2
        for (const char of s1 + s2) {
            if (char === '(') balance++;
            else if (char === ')') balance--;

            if (balance < 0) return false; // More closing than opening
        }
        if (balance === 0) return true; // Balanced

        balance = 0;
        // Check s2 followed by s1
        for (const char of s2 + s1) {
            if (char === '(') balance++;
            else if (char === ')') balance--;

            if (balance < 0) return false; // More closing than opening
        }

        return balance === 0; // Balanced
    };

    return canFormGoodString(lst[0], lst[1]) ? 'Yes' : 'No';
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = match_parens;
  assert.deepEqual(candidate([""()("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", "")""]),""No"");
  assert.deepEqual(candidate([""(()(())"", ""())())""]),""No"");
  assert.deepEqual(candidate(["")())"", ""(()()(""]),""Yes"");
  assert.deepEqual(candidate([""(())))"", ""(()())((""]),""Yes"");
  assert.deepEqual(candidate([""()"", ""())""]),""No"");
  assert.deepEqual(candidate([""(()("", ""()))()""]),""Yes"");
  assert.deepEqual(candidate([""(((("", ""((())""]),""No"");
  assert.deepEqual(candidate(["")(()"", ""(()(""]),""No"");
  assert.deepEqual(candidate(["")("", "")(""]),""No"");
  assert.deepEqual(candidate([""("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", ""(""]),""Yes"");
}

test();"
HumanEval_120,als_Latn,ts,"//Shembull 1: //e gjatësisë k me numrat më të lartë k në arr. //Duke pasur parasysh një masë arr e integers dhe një numër i plotë pozitiv k, kthehet një masë të renditur // >>> maximum([-3, -4, 5], 3)
// [-4, -3, 5]
// Example 2:
// >>> maximum([4, -4, 4], 2)
// [4, 4]
// Example 3:
// >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)
// [2]
// Note:
// 1. The length of the array will be in the range of [1, 1000].
// 2. The elements in the array will be in the range of [-1000, 1000].
// 3. 0 <= k <= len(arr)
function maximum(arr: number[], k: number): number[] {
","function maximum(arr: number[], k: number): number[] {
    // Sort the array in descending order and then take the first k elements
    const sortedArr = arr.sort((a, b) => b - a);
    return sortedArr.slice(0, k).sort((a, b) => a - b);
}

// Example usage:
// console.log(maximum([-3, -4, 5], 3)); // Output: [-4, -3, 5]
// console.log(maximum([4, -4, 4], 2)); // Output: [4, 4]
// console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1)); // Output: [2]","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = maximum;
  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);
  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);
  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);
  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);
  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);
  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);
  assert.deepEqual(candidate([-1, 0, 2, 5, 3, -10], 2),[3, 5]);
  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);
  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);
  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);
  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0),[]);
}

test();"
HumanEval_121,als_Latn,ts,"//Shembuj //Duke pasur parasysh një sërë jo bosh të integers, kthehet shuma e të gjitha elementeve të çuditshme që janë në pozicione të barabarta. // >>> solution([5, 8, 7, 1])
// 12
// >>> solution([3, 3, 3, 3, 3])
// 9
// >>> solution([30, 13, 24, 321])
// 0
function solution(lst: number[]): number {
","function solution(lst: number[]): number {
    let sum: number = 0;
    for (let i = 0; i < lst.length; i += 2) {  // Traverse even indices
        if (lst[i] % 2 !== 0) {  // Check if the element is odd
            sum += lst[i];
        }
    }
    return sum;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = solution;
  assert.deepEqual(candidate([5, 8, 7, 1]),12);
  assert.deepEqual(candidate([3, 3, 3, 3, 3]),9);
  assert.deepEqual(candidate([30, 13, 24, 321]),0);
  assert.deepEqual(candidate([5, 9]),5);
  assert.deepEqual(candidate([2, 4, 8]),0);
  assert.deepEqual(candidate([30, 13, 23, 32]),23);
  assert.deepEqual(candidate([3, 13, 2, 9]),3);
}

test();"
HumanEval_122,als_Latn,ts,"//Shembull: //shuma e elementeve me maksimumi dy shifra nga k elementët e parë të arr. //Duke pasur parasysh një renditje jo bosh të numrave të plotë arr dhe një numër i plotë k, kthimi // >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
// 24
// Constraints:
// 1. 1 <= len(arr) <= 100
// 2. 1 <= k <= len(arr)
function add_elements(arr: number[], k: number): number {
","function add_elements(arr: number[], k: number): number {
    let sum = 0;
    for (let i = 0; i < k; i++) {
        if (arr[i] >= -99 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = add_elements;
  assert.deepEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4);
  assert.deepEqual(candidate([111, 121, 3, 4000, 5, 6], 2),0);
  assert.deepEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125);
  assert.deepEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24);
  assert.deepEqual(candidate([1], 1),1);
}

test();"
HumanEval_123,als_Latn,ts,"//get_odd_collatz(5) kthen [1, 5] # Rreshtin e kollatz për 5 është [5, 16, 8, 4, 2, 1], kështu që numrat e rastësishëm janë vetëm 1 dhe 5. //Për shembull: //2. rendit të kthyer renditur në mënyrë në rritje.//1. Collatz(1) është [1]. //Shënim://Termi plus 1. supozimi është se pa marrë parasysh se çfarë vlere të n, sekuenca gjithmonë do të arrijë 1. //Nëse termi i mëparshëm është i rastësishëm, termi tjetër është 3 herë më i hershmi.//termi i mëparshëm si më poshtë: nëse termi i mëparshëm është i çift, termi i ardhshëm është gjysma e //si më poshtë: fillo me çdo numër të plotë pozitiv n. Pastaj çdo term është marrë nga //Gjyshja e Collatz është një gjetje në matematikë që ka të bëjë me një sekuencë të përcaktuar //Duke pasur parasysh një numër të plotë pozitiv n, kthehet një renditur renditje që ka numrat e çuditshme në radhë Collatz. // >>> get_odd_collatz(5)
// [1, 5]
function get_odd_collatz(n: number): number[] {
","function get_odd_collatz(n: number): number[] {
    const collatzSequence: number[] = [];
    while (n !== 1) {
        if (n % 2 !== 0) {
            collatzSequence.push(n);
        }
        if (n % 2 === 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
    }
    // Include 1 in the sequence if it's odd, as per standard collatz sequence
    collatzSequence.push(1);
    return collatzSequence.sort((a, b) => a - b);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = get_odd_collatz;
  assert.deepEqual(candidate(14),[1, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(5),[1, 5]);
  assert.deepEqual(candidate(12),[1, 3, 5]);
  assert.deepEqual(candidate(1),[1]);
}

test();"
HumanEval_124,als_Latn,ts,"//4. Data duhet të jetë në formatin: mm-dd-yyyy //3. Muajt nuk duhet të jenë më pak se 1 ose më të lartë se 12.//2. Numri i ditëve nuk është më pak se 1 ose më i lartë se 31 ditë për muajt 1,3,5,7,8,10,12. Dhe numri i ditëve nuk është më pak se 1 ose më i lartë se 30 ditë për muajt 4,6,9,11. Dhe, numri i ditëve nuk është më pak se 1 ose më i lartë se 29 për muajin 2.//1. Stringa e datës nuk është bosh.//Data është e vlefshme nëse janë përmbushur të gjitha rregullat e mëposhtme: //kthen të vërtetë nëse data është e vlefshme përndryshe false. //Ju duhet të shkruani një funksion i cili validon një string të caktuar datë dhe // >>> valid_date(""03-11-2000"")
// true
// >>> valid_date(""15-01-2012"")
// false
// >>> valid_date(""04-0-2040"")
// false
// >>> valid_date(""06-04-2020"")
// true
// >>> valid_date(""06/04/2020"")
// false
function valid_date(date: string): boolean {
","function valid_date(date: string): boolean {
    // Check if the date is empty
    if (date.trim() === """") return false;

    // Split the date string into components
    const dateParts = date.split(""-"");
    if (dateParts.length !== 3) return false;

    const [monthStr, dayStr, yearStr] = dateParts;

    // Validate each part of the date
    const month = parseInt(monthStr, 10);
    const day = parseInt(dayStr, 10);
    const year = parseInt(yearStr, 10);

    // Check if all parts are valid numbers
    if (isNaN(month) || isNaN(day) || isNaN(year)) return false;

    // Check the month range
    if (month < 1 || month > 12) return false;

    // Check the day range based on the month
    if ([1, 3, 5, 7, 8, 10, 12].includes(month)) {
        if (day < 1 || day > 31) return false;
    } else if ([4, 6, 9, 11].includes(month)) {
        if (day < 1 || day > 30) return false;
    } else if (month === 2) {
        if (day < 1 || day > 29) return false;
    }

    // All checks passed
    return true;
}

// Example usage
console.log(valid_date(""03-11-2000"")); // true
console.log(valid_date(""15-01-2012"")); // false
console.log(valid_date(""04-0-2040""));  // false
console.log(valid_date(""06-04-2020"")); // true
console.log(valid_date(""06/04/2020"")); // false","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = valid_date;
  assert.deepEqual(candidate(""03-11-2000""),true);
  assert.deepEqual(candidate(""15-01-2012""),false);
  assert.deepEqual(candidate(""04-0-2040""),false);
  assert.deepEqual(candidate(""06-04-2020""),true);
  assert.deepEqual(candidate(""01-01-2007""),true);
  assert.deepEqual(candidate(""03-32-2011""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""04-31-3000""),false);
  assert.deepEqual(candidate(""06-06-2005""),true);
  assert.deepEqual(candidate(""21-31-2000""),false);
  assert.deepEqual(candidate(""04-12-2003""),true);
  assert.deepEqual(candidate(""04122003""),false);
  assert.deepEqual(candidate(""20030412""),false);
  assert.deepEqual(candidate(""2003-04""),false);
  assert.deepEqual(candidate(""2003-04-12""),false);
  assert.deepEqual(candidate(""04-2003""),false);
}

test();"
HumanEval_125,als_Latn,ts,"//Shembuj //alfabeti, ord ((('a') = 0, ord ((('b') = 1, ... ord ((('z') = 25 //duhet të ndahet në koma ',' nëse nuk ka koma ju duhet të kthehet numri i shkronjave të vogla me rend të çuditshëm në //Duke pasur parasysh një varg fjalë, kthehet një sërë fjalësh të ndara në hapësira të bardha, nëse nuk ekzistojnë hapësira të bardha në tekstin që ju kërkoni.// >>> split_words(""Hello world!"")
// [""Hello"", ""world!""]
// >>> split_words(""Hello,world!"")
// [""Hello"", ""world!""]
// >>> split_words(""abcdef"")
// 3
function split_words(txt: string): string[] | number {
","function split_words(txt: string): string[] | number {
    if (txt.includes("" "")) {
        return txt.split("" "");
    }
    if (txt.includes("","")) {
        return txt.split("","");
    }
    const oddOrderCount = [...txt].reduce((count, char) => {
        const charCode = char.charCodeAt(0) - 'a'.charCodeAt(0);
        if (char === char.toLowerCase() && charCode % 2 === 1) {
            return count + 1;
        }
        return count;
    }, 0);

    return oddOrderCount;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = split_words;
  assert.deepEqual(candidate(""Hello world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello,world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello world,!""),[""Hello"", ""world,!""]);
  assert.deepEqual(candidate(""Hello,Hello,world !""),[""Hello,Hello,world"", ""!""]);
  assert.deepEqual(candidate(""abcdef""),3);
  assert.deepEqual(candidate(""aaabb""),2);
  assert.deepEqual(candidate(""aaaBb""),1);
  assert.deepEqual(candidate(""""),0);
}

test();"
HumanEval_126,als_Latn,ts,"//Shembuj //Numri, kthehet false. Mos supozo numra negativë dhe vetëm numra të plotë.//në rendin ngjitës. Nëse array ka më shumë se 1 duplikat të njëjtës//Duke pasur parasysh një sërë numrash, kthehet nëse janë të renditura apo jo.// >>> is_sorted([5])
// true
// >>> is_sorted([1, 2, 3, 4, 5])
// true
// >>> is_sorted([1, 3, 2, 4, 5])
// false
// >>> is_sorted([1, 2, 3, 4, 5, 6])
// true
// >>> is_sorted([1, 2, 3, 4, 5, 6, 7])
// true
// >>> is_sorted([1, 3, 2, 4, 5, 6, 7])
// false
// >>> is_sorted([1, 2, 2, 3, 3, 4])
// true
// >>> is_sorted([1, 2, 2, 2, 3, 4])
// false
function is_sorted(lst: number[]): boolean {
","function is_sorted(lst: number[]): boolean {
    for (let i = 0; i < lst.length - 1; i++) {
        if (lst[i] > lst[i + 1]) {
            return false;
        }
        if (lst[i] === lst[i + 1]) {
            let count = 1;
            while (lst[i + count] === lst[i]) {
                count++;
                if (count > 2) return false;
            }
        }
    }
    return true;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_sorted;
  assert.deepEqual(candidate([5]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, 7]),false);
  assert.deepEqual(candidate([]),true);
  assert.deepEqual(candidate([1]),true);
  assert.deepEqual(candidate([3, 2, 1]),false);
  assert.deepEqual(candidate([1, 2, 2, 2, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);
  assert.deepEqual(candidate([1, 2, 3, 4]),true);
}

test();"
HumanEval_127,als_Latn,ts,"//[input/output] mostrat: //Nëse dy intervalet nuk kryqëzohen, kthe ""JO"".//përndryshe, kthe ""JO"". //Nëse gjatësia e kryqëzimit është një numër i parë, kthehet ""JA"", //e cila gjatësia e saj është 1, e cila nuk është një numër i parë.//Shembull, kryqëzimi i intervaleve (1, 3), (2, 4) është (2, 3) //Intervali është një numër i parë.//Detyra juaj është të përcaktojë nëse gjatësia e kryqëzimit të këtyre dyve //Për çdo interval të caktuar, supozohet se fillimi i tij është më i vogël ose i barabartë me fundin e tij.//përfshin fillimin dhe fundin. //Intervalet e dhëna janë të mbyllura, që do të thotë se intervali (fillim, fund) //ku çdo interval është një palë e integers. Për shembull, interval = (fillimi, fundi) = (1, 2).//Ju jepen dy intervale, // >>> intersection([1, 2], [2, 3])
// ""NO""
// >>> intersection([-1, 1], [0, 4])
// ""NO""
// >>> intersection([-3, -1], [-5, 5])
// ""YES""
function intersection(interval1: [number, number], interval2: [number, number]): string {
","function isPrime(num: number): boolean {
    if (num <= 1) return false;
    if (num <= 3) return true; // 2 and 3 are prime numbers
    if (num % 2 === 0 || num % 3 === 0) return false;
    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
}

function intersection(interval1: [number, number], interval2: [number, number]): string {
    const start = Math.max(interval1[0], interval2[0]);
    const end = Math.min(interval1[1], interval2[1]);

    if (start > end) {
        return ""NO"";
    }

    const length = end - start;

    return isPrime(length) ? ""YES"" : ""NO"";
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = intersection;
  assert.deepEqual(candidate([1, 2], [2, 3]),""NO"");
  assert.deepEqual(candidate([-1, 1], [0, 4]),""NO"");
  assert.deepEqual(candidate([-3, -1], [-5, 5]),""YES"");
  assert.deepEqual(candidate([-2, 2], [-4, 0]),""YES"");
  assert.deepEqual(candidate([-11, 2], [-1, -1]),""NO"");
  assert.deepEqual(candidate([1, 2], [3, 5]),""NO"");
  assert.deepEqual(candidate([1, 2], [1, 2]),""NO"");
  assert.deepEqual(candidate([-2, -2], [-3, -2]),""NO"");
}

test();"
HumanEval_128,als_Latn,ts,"//Shembull: //Shënim: kthimi i pacaktuar për arr të zbrazët. //e çdo numri në masë, të përfaqësuar nga 1, -1 ose 0. //Shuma e madhësive të numrave të plotë të shumëzuar me prodhimin e të gjitha shenjave.//Ju jepet një masë arr e integers dhe ju duhet të kthehet // >>> prod_signs([1, 2, 2, -4])
// 9
// >>> prod_signs([0, 1])
// 0
// >>> prod_signs([])
// undefined
function prod_signs(arr: number[]): number | undefined {
","function prod_signs(arr: number[]): number | undefined {
    if (arr.length === 0) return undefined;

    let sumOfMagnitudes = 0;
    let productOfSigns = 1;

    for (const num of arr) {
        sumOfMagnitudes += Math.abs(num);
        productOfSigns *= Math.sign(num);
    }

    return sumOfMagnitudes * productOfSigns;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = prod_signs;
  assert.deepEqual(candidate([1, 2, 2, -4]),-9);
  assert.deepEqual(candidate([0, 1]),0);
  assert.deepEqual(candidate([1, 1, 1, 2, 3, -1, 1]),-10);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([2, 4, 1, 2, -1, -1, 9]),20);
  assert.deepEqual(candidate([-1, 1, -1, 1]),4);
  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);
  assert.deepEqual(candidate([-1, 1, 1, 0]),0);
}

test();"
HumanEval_129,als_Latn,ts,"//Shembuj: //Kthen një rend të renditur të vlerave në qelizat që shtrihet rruga minimale. //Është e garantuar që përgjigjja është unike.//lst_A[j] = lst_B[j]. //i tillë që lst_A[i] < lst_B[i] dhe për çdo j (1 <= j < i) kemi //se lst_B, me fjalë të tjera, ekziston një indeks i i (1 <= i <= k) //përmes (le t'i quajmë lst_A dhe lst_B), lst_A është lexikografikisht më pak //pas bërjes së renditur matrices e vlerave në qeliza që A dhe B shkojnë //Një rrugë A (e gjatësisë k) konsiderohet më e vogël se një rrugë B (e gjatësisë k) nëse //Nuk mund të ikësh nga rrjeti.//domosdoshmërisht të dallueshme).//Ju lutemi vini re se një rrugë me gjatësi k do të thotë vizita e saktësisht k qelizave (jo //celular. //me fjalë të tjera, ju mund të shkoni në qeliza të cilat ndajnë një buzë me ju aktualisht //nga çdo qelizë, dhe në çdo hap ju mund të lëvizni në çdo qelizë fqinje, //Ju duhet të gjeni rrugën minimale të gjatësisë k në rrjet.//Inclusive shfaqet saktësisht një herë në qelizat e rrjetit.//çdo qelizë e rrjetit përmban një vlerë. Çdo numër i plotë në intervalin [1, N * N] //Duke pasur parasysh një rrjet me N rreshta dhe N kolona (N >= 2) dhe një numër i plotë pozitiv k, // >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
// [1, 2, 1]
// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
// [1]
function minPath(grid: number[][], k: number): number[] {
","function minPath(grid: number[][], k: number): number[] {
    const N = grid.length;
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    
    type State = {path: number[], x: number, y: number, len: number};
    
    // Compare two paths lexicographically
    const isLess = (a: number[], b: number[]): boolean => {
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return a[i] < b[i];
        }
        return false;
    };

    let bestPath: number[] = new Array(k).fill(Number.MAX_VALUE);
    
    // DFS function to explore paths of length k
    function dfs(x: number, y: number, path: number[], len: number): void {
        if (len === k) {
            if (isLess(path, bestPath)) {
                bestPath = [...path];
            }
            return;
        }
        
        for (const [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {
                dfs(nx, ny, [...path, grid[nx][ny]], len + 1);
            }
        }
    }
    
    // Try starting from each cell
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            dfs(i, j, [grid[i][j]], 1);
        }
    }
    
    return bestPath;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = minPath;
  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);
  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);
  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);
  assert.deepEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);
  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);
  assert.deepEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);
  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
  assert.deepEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);
  assert.deepEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);
  assert.deepEqual(candidate([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
  assert.deepEqual(candidate([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

test();"
HumanEval_130,als_Latn,ts,"//Shembuj: //numrat e parë n + 1 të sekuencës Tribonacci. //Ju jepet një numër i plotë jo-negativ n, ju duhet të kthehet një masë e //= 2 + 3 + 3 = 8 //tri(3) = tri(2) + tri(1) + tri(4) //tri(4) = 3 //tri(2) = 1 + (2 / 2) = 2 //Për shembull: //tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), nëse n është i rastësishëm. //tri (n) = 1 + n / 2, nëse n është i çift. //tri(1) = 3 //Rrethi i Tribonaçit përcaktohet nga përsëritja: //Megjithatë, ajo që njerëzit nuk e dinë është sekuenca e Tribonaçit.//Të gjithë e njohin sekuencën e Fibonaçit, ajo është studiuar thellë nga matematikanët në // >>> tri(3)
// [1, 3, 2, 8]
function tri(n: number): number[] {
","function tri(n: number): number[] {
    const tribonacci: number[] = [1, 3]; // Initialize with first two definite values

    function calculateTribonacci(index: number): number {
        if (index < tribonacci.length) {
            return tribonacci[index];
        }

        let result: number;
        if (index % 2 === 0) {
            result = 1 + index / 2;
        } else {
            result = calculateTribonacci(index - 1) + calculateTribonacci(index - 2) + calculateTribonacci(index + 1);
        }

        tribonacci[index] = result; // Memoize the result
        return result;
    }

    for (let i = 0; i <= n; i++) {
        calculateTribonacci(i);
    }

    return tribonacci.slice(0, n + 1);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = tri;
  assert.deepEqual(candidate(3),[1, 3, 2, 8]);
  assert.deepEqual(candidate(4),[1, 3, 2, 8, 3]);
  assert.deepEqual(candidate(5),[1, 3, 2, 8, 3, 15]);
  assert.deepEqual(candidate(6),[1, 3, 2, 8, 3, 15, 4]);
  assert.deepEqual(candidate(7),[1, 3, 2, 8, 3, 15, 4, 24]);
  assert.deepEqual(candidate(8),[1, 3, 2, 8, 3, 15, 4, 24, 5]);
  assert.deepEqual(candidate(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
  assert.deepEqual(candidate(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
  assert.deepEqual(candidate(0),[1]);
  assert.deepEqual(candidate(1),[1, 3]);
}

test();"
HumanEval_131,als_Latn,ts,"//Për shembull: //Kthehet 0 nëse të gjitha shifrat janë të para. //Duke pasur parasysh një numër të plotë pozitiv n, kthehet produkti i shifrave të çuditshme. // >>> digits(1)
// 1
// >>> digits(4)
// 0
// >>> digits(235)
// 15
function digits(n: number): number {
","function digits(n: number): number {
    let product = 1;
    let hasOdd = false;
    
    while (n > 0) {
        let digit = n % 10;
        if (digit % 2 !== 0) {
            product *= digit;
            hasOdd = true;
        }
        n = Math.floor(n / 10);
    }

    return hasOdd ? product : 0;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = digits;
  assert.deepEqual(candidate(5),5);
  assert.deepEqual(candidate(54),5);
  assert.deepEqual(candidate(120),1);
  assert.deepEqual(candidate(5014),5);
  assert.deepEqual(candidate(98765),315);
  assert.deepEqual(candidate(5576543),2625);
  assert.deepEqual(candidate(2468),0);
}

test();"
HumanEval_132,als_Latn,ts,"//ku të paktën një bracket në subsequence është i zhytur. //Funksioni duhet të kthehet true nëse dhe vetëm nëse ekziston një pas-sekuencë e vlefshme e kurrizëve //Krijoni një funksion që merr një varg si input i cili përmban vetëm kurrizë katrore. // >>> is_nested(""[[]]"")
// true
// >>> is_nested(""[]]]]]]][[[[[]"")
// false
// >>> is_nested(""[][]"")
// false
// >>> is_nested(""[]"")
// false
// >>> is_nested(""[[][]]"")
// true
// >>> is_nested(""[[]][["")
// true
function is_nested(string: string): boolean {
","function is_nested(string: string): boolean {
    let depth = 0;
    let hasNesting = false;

    for (let char of string) {
        if (char === '[') {
            depth++;
            if (depth > 1) {
                hasNesting = true;
            }
        } else if (char === ']') {
            if (depth > 0) {
                depth--;
            } else {
                // More closing brackets than opening
                return false;
            }
        }
    }

    // Return true if there was at least one nested bracket and all brackets are matched
    return hasNesting && depth === 0;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_nested;
  assert.deepEqual(candidate(""[[]]""),true);
  assert.deepEqual(candidate(""[]]]]]]][[[[[]""),false);
  assert.deepEqual(candidate(""[][]""),false);
  assert.deepEqual(candidate(""[]""),false);
  assert.deepEqual(candidate(""[[[[]]]]""),true);
  assert.deepEqual(candidate(""[]]]]]]]]]]""),false);
  assert.deepEqual(candidate(""[][][[]]""),true);
  assert.deepEqual(candidate(""[[]""),false);
  assert.deepEqual(candidate(""[]]""),false);
  assert.deepEqual(candidate(""[[]][[""),true);
  assert.deepEqual(candidate(""[[][]]""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""[[[[[[[[""),false);
  assert.deepEqual(candidate(""]]]]]]]]""),false);
}

test();"
HumanEval_133,als_Latn,ts,"//Shembuj: //rrotulloni secilin element në masë në pjesën e sipërme të int ((Tafat) së pari. //Ju duhet të kthehet shuma e numrave në katror në masën e dhënë, //Ju jepet një sërë numrash.// >>> lst([1.0, 2.0, 3.0])
// 14
// >>> lst([1.0, 4.0, 9.0])
// 98
// >>> lst([1.0, 3.0, 5.0, 7.0])
// 84
// >>> lst([1.4, 4.2, 0.0])
// 29
// >>> lst([-2.4, 1.0, 1.0])
// 6
function sum_squares(lst: number[]): number {
","function sum_squares(lst: number[]): number {
    return lst.map(Math.ceil).reduce((sum, num) => sum + num * num, 0);
}

// Example usage:
// console.log(sum_squares([1.0, 2.0, 3.0])); // Output: 14
// console.log(sum_squares([1.0, 4.0, 9.0])); // Output: 98
// console.log(sum_squares([1.0, 3.0, 5.0, 7.0])); // Output: 84
// console.log(sum_squares([1.4, 4.2, 0.0])); // Output: 29
// console.log(sum_squares([-2.4, 1.0, 1.0])); // Output: 6","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 3.0, 5.0, 7.0]),84);
  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);
  assert.deepEqual(candidate([-2.4, 1.0, 1.0]),6);
  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);
  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);
  assert.deepEqual(candidate([-1.4, 4.6, 6.3]),75);
  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);
  assert.deepEqual(candidate([0.0]),0);
  assert.deepEqual(candidate([-1.0]),1);
  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);
}

test();"
HumanEval_134,als_Latn,ts,"//Shembuj: //Shënim: ""fjala"" është një grup i karaktereve të ndara me hapësirë.//një pjesë e një fjale, dhe të rreme ndryshe.//e një rrjeti të dhënë është një karakter alfabetik dhe nuk është //Krijoni një funksion që kthehet true nëse karakteri i fundit është // >>> check_if_last_char_is_a_letter(""apple pie"")
// false
// >>> check_if_last_char_is_a_letter(""apple pi e"")
// true
// >>> check_if_last_char_is_a_letter(""apple pi e "")
// false
// >>> check_if_last_char_is_a_letter("""")
// false
function check_if_last_char_is_a_letter(txt: string): boolean {
","function check_if_last_char_is_a_letter(txt: string): boolean {
    if (txt.trim() === """") return false; // Handle empty or whitespace strings

    // Trim the string to remove any trailing spaces
    txt = txt.trim();

    // Check if the last character is an alphabetical letter and ensure there's a space before it
    const lastChar = txt.charAt(txt.length - 1);
    const isAlpha = /[a-zA-Z]/.test(lastChar);

    return isAlpha && txt.lastIndexOf(' ') === txt.length - 2;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = check_if_last_char_is_a_letter;
  assert.deepEqual(candidate(""apple""),false);
  assert.deepEqual(candidate(""apple pi e""),true);
  assert.deepEqual(candidate(""eeeee""),false);
  assert.deepEqual(candidate(""A""),true);
  assert.deepEqual(candidate(""Pumpkin pie ""),false);
  assert.deepEqual(candidate(""Pumpkin pie 1""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""eeeee e ""),false);
  assert.deepEqual(candidate(""apple pie""),false);
  assert.deepEqual(candidate(""apple pi e ""),false);
}

test();"
HumanEval_135,als_Latn,ts,"//Shembuj: //vlerat e dyfishta.//nuk ekziston asnjë element i tillë atëherë kthehet -1. Array i dhënë nuk do të përmbajë //nuk është më i madh se ose i barabartë me elementin që i paraprin menjëherë.//Krijoni një funksion që kthen indeksin më të madh të një elementi që // >>> can_arrange([1, 2, 4, 3, 5])
// 3
// >>> can_arrange([1, 2, 3])
// -1
function can_arrange(arr: number[]): number {
","function can_arrange(arr: number[]): number {
    for (let i = arr.length - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            return i;
        }
    }
    return -1;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = can_arrange;
  assert.deepEqual(candidate([1, 2, 4, 3, 5]),3);
  assert.deepEqual(candidate([1, 2, 4, 5]),-1);
  assert.deepEqual(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]),2);
  assert.deepEqual(candidate([4, 8, 5, 7, 3]),4);
  assert.deepEqual(candidate([]),-1);
}

test();"
HumanEval_136,als_Latn,ts,"//Shembuj: //Nëse nuk ka integers negative ose pozitive, kthehet si të pa përcaktuar.//e integers pozitive në një masë. //më i madh i integers negative, dhe ""b"" është më i vogël //Krijoni një funksion që kthen një masë (a, b), ku 'a' është // >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])
// [undefined, 1]
// >>> largest_smallest_integers([])
// [undefined, undefined]
// >>> largest_smallest_integers([0])
// [undefined, undefined]
function largest_smallest_integers(lst: number[]): [number | undefined, number | undefined] {
","function largest_smallest_integers(lst: number[]): [number | undefined, number | undefined] {
    let largestNegative: number | undefined = undefined;
    let smallestPositive: number | undefined = undefined;

    for (let num of lst) {
        if (num < 0) {
            if (largestNegative === undefined || num > largestNegative) {
                largestNegative = num;
            }
        } else if (num > 0) {
            if (smallestPositive === undefined || num < smallestPositive) {
                smallestPositive = num;
            }
        }
    }

    return [largestNegative, smallestPositive];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = largest_smallest_integers;
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined, 1]);
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);
  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);
  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);
  assert.deepEqual(candidate([]),[undefined, undefined]);
  assert.deepEqual(candidate([0]),[undefined, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6]),[-1, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6, 0]),[-1, undefined]);
  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3, 1]);
  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);
}

test();"
HumanEval_138,als_Latn,ts,"//Shembull //Vlerëso nëse numri i dhënë n mund të shkruhet si shuma e saktësisht 4 numrave të barabartë pozitivë // >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
function is_equal_to_sum_even(n: number): boolean {
","function is_equal_to_sum_even(n: number): boolean {
    // The sum of 4 positive even numbers is always even and 8 is the smallest such sum (2 + 2 + 2 + 2).
    // Hence, if n is greater than or equal to 8 and even, n can be expressed as the sum of 4 positive even numbers.
    return (n >= 8) && (n % 2 === 0);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = is_equal_to_sum_even;
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),true);
  assert.deepEqual(candidate(11),false);
  assert.deepEqual(candidate(12),true);
  assert.deepEqual(candidate(13),false);
  assert.deepEqual(candidate(16),true);
}

test();"
HumanEval_139,als_Latn,ts,"//Për shembull: //ku n > 0 //brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! //Faktorijali brazilian është i përcaktuar si: // >>> special_factorial(4)
// 288
// The function will receive an integer as input and should return the special
// factorial of this integer.
function special_factorial(n: number): number {
","function factorial(n: number): number {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

function special_factorial(n: number): number {
    if (n <= 0) throw new Error(""Input must be a positive integer"");
    
    let result = 1;
    for (let i = n; i >= 1; i--) {
        result *= factorial(i);
    }
    
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = special_factorial;
  assert.deepEqual(candidate(4),288);
  assert.deepEqual(candidate(5),34560);
  assert.deepEqual(candidate(7),125411328000);
  assert.deepEqual(candidate(1),1);
}

test();"
HumanEval_140,als_Latn,ts,"//pastaj të gjitha hapësirat e njëpasnjëshme të zëvendësohen me - //dhe nëse një varg ka më shumë se 2 hapësira të njëpasnjëshme, //Duke pasur parasysh një varg teksti, zëvendëso të gjitha hapësirat në të me nënvizues, // >>> fix_spaces("" Example"")
// ""Example""
// >>> fix_spaces("" Example 1"")
// ""Example_1""
// >>> fix_spaces("" Example 2"")
// ""_Example_2""
// >>> fix_spaces("" Example 3"")
// ""_Example-3""
function fix_spaces(text: string): string {
","function fix_spaces(text: string): string {
    // Trim leading and trailing spaces
    let trimmedText = text.trim();

    // Use a regular expression to replace all sequences of two or more spaces with ""-""
    let replacedText = trimmedText.replace(/ {2,}/g, '-');

    // Replace remaining single spaces with underscores
    replacedText = replacedText.replace(/ /g, '_');

    return replacedText;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = fix_spaces;
  assert.deepEqual(candidate(""Example""),""Example"");
  assert.deepEqual(candidate(""Mudasir Hanif ""),""Mudasir_Hanif_"");
  assert.deepEqual(candidate(""Yellow Yellow  Dirty  Fellow""),""Yellow_Yellow__Dirty__Fellow"");
  assert.deepEqual(candidate(""Exa   mple""),""Exa-mple"");
  assert.deepEqual(candidate(""   Exa 1 2 2 mple""),""-Exa_1_2_2_mple"");
}

test();"
HumanEval_141,als_Latn,ts,"//Shembuj: //- Substring pas pikës duhet të jetë një nga këto: ['txt', 'exe', 'dll'] //alfabetin latin ('a'-'z' dhe 'A'-'Z'). //- Substring para pikës nuk duhet të jetë bosh, dhe ajo fillon me një letër nga //- Emri i dosjes përmban saktësisht një pikë '.' //- Në emrin e dosjes nuk duhet të ketë më shumë se tre shifra ('0'-'9'). //janë përmbushur: //Emri i një dosjeje konsiderohet i vlefshëm nëse dhe vetëm nëse plotësohen të gjitha kushtet e mëposhtme //""Po"" nëse emri i skedarit është i vlefshëm, dhe kthen ""Jo"" në rast të kundërt. //Krijoni një funksion i cili merr një varg që përfaqëson emrin e një skedari, dhe kthen // >>> file_name_check(""example.txt"")
// ""Yes""
// >>> file_name_check(""1example.dll"")
// ""No""
function file_name_check(file_name: string): string {
","function file_name_check(file_name: string): string {
    // Split the file name into name and extension based on the dot
    const parts = file_name.split('.');
    
    // Check if there's exactly one dot
    if (parts.length !== 2) {
        return 'No';
    }
    
    const [name, extension] = parts;
    
    // Check if the substring before the dot is not empty and starts with a latin letter
    if (name.length === 0 || !/^[a-zA-Z]/.test(name)) {
        return 'No';
    }
    
    // Check if the number of digits in the name is not more than three
    const digitCount = (name.match(/\d/g) || []).length;
    if (digitCount > 3) {
        return 'No';
    }
    
    // Check if the extension is one of the valid options
    const validExtensions = ['txt', 'exe', 'dll'];
    if (!validExtensions.includes(extension)) {
        return 'No';
    }
    
    // All conditions are met, the file name is valid
    return 'Yes';
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = file_name_check;
  assert.deepEqual(candidate(""example.txt""),""Yes"");
  assert.deepEqual(candidate(""1example.dll""),""No"");
  assert.deepEqual(candidate(""s1sdf3.asd""),""No"");
  assert.deepEqual(candidate(""K.dll""),""Yes"");
  assert.deepEqual(candidate(""MY16FILE3.exe""),""Yes"");
  assert.deepEqual(candidate(""His12FILE94.exe""),""No"");
  assert.deepEqual(candidate(""_Y.txt""),""No"");
  assert.deepEqual(candidate(""?aREYA.exe""),""No"");
  assert.deepEqual(candidate(""/this_is_valid.dll""),""No"");
  assert.deepEqual(candidate(""this_is_valid.wow""),""No"");
  assert.deepEqual(candidate(""this_is_valid.txt""),""Yes"");
  assert.deepEqual(candidate(""this_is_valid.txtexe""),""No"");
  assert.deepEqual(candidate(""#this2_i4s_5valid.ten""),""No"");
  assert.deepEqual(candidate(""@this1_is6_valid.exe""),""No"");
  assert.deepEqual(candidate(""this_is_12valid.6exe4.txt""),""No"");
  assert.deepEqual(candidate(""all.exe.txt""),""No"");
  assert.deepEqual(candidate(""I563_No.exe""),""Yes"");
  assert.deepEqual(candidate(""Is3youfault.txt""),""Yes"");
  assert.deepEqual(candidate(""no_one#knows.dll""),""Yes"");
  assert.deepEqual(candidate(""1I563_Yes3.exe""),""No"");
  assert.deepEqual(candidate(""I563_Yes3.txtt""),""No"");
  assert.deepEqual(candidate(""final..txt""),""No"");
  assert.deepEqual(candidate(""final132""),""No"");
  assert.deepEqual(candidate(""_f4indsartal132.""),""No"");
  assert.deepEqual(candidate("".txt""),""No"");
  assert.deepEqual(candidate(""s.""),""No"");
}

test();"
HumanEval_142,als_Latn,ts,"//Shembuj: //ndryshojnë hyrjet në masë indekset e të cilave nuk janë shumëfishtë e 3 ose 4. Funksioni pastaj do të kthejë shumën e të gjitha hyrjeve.//shumëfishtë të 3 dhe do të kubit hyrjen e numrit të plotë nëse indeksi i tij është një shumëfishtë e 4 dhe jo një shumëfishtë e 3. Funksioni nuk do të //Ky funksion do të marrë një renditje të numrave të plotë. Për të gjitha hyrjet në renditje, funksioni do të shtrihet në katror të hyrjes së numrit të plotë nëse indeksi i tij është një //"" // >>> lst
// [1, 2, 3]
// >>> lst
// []
// >>> lst
// [-1, -5, 2, -1, -5]
function sum_squares(lst: number[]): number {
","function sum_squares(lst: number[]): number {
    return lst.reduce((sum, value, index) => {
        if (index % 3 === 0) {
            return sum + (value * value);
        } else if (index % 4 === 0) {
            return sum + (value * value * value);
        } else {
            return sum + value;
        }
    }, 0);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1, 2, 3]),6);
  assert.deepEqual(candidate([1, 4, 9]),14);
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]),9);
  assert.deepEqual(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3);
  assert.deepEqual(candidate([0]),0);
  assert.deepEqual(candidate([-1, -5, 2, -1, -5]),-126);
  assert.deepEqual(candidate([-56, -99, 1, 0, -2]),3030);
  assert.deepEqual(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0);
  assert.deepEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196);
  assert.deepEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448);
}

test();"
HumanEval_143,als_Latn,ts,"//Shembull 1: //renditjes së fjalëve në varg të ri duhet të jetë i njëjtë si origjinal. //të cilat janë numra të parë, //dhe ju duhet të kthehet një varg që përmban fjalët nga fjalia origjinale, //fjalia përmban disa fjalë të ndara me një hapësirë, //Ju jepet një varg që përfaqëson një fjali, // >>> words_in_sentence(""This is a test"")
// ""is""
// Example 2:
// >>> words_in_sentence(""lets go for swimming"")
// ""go for""
// Constraints:
// * 1 <= len(sentence) <= 100
// * sentence contains only letters
function words_in_sentence(sentence: string): string {
","function isPrime(num: number): boolean {
    if (num < 2) return false;
    for (let i = 2; i * i <= num; i++) {
        if (num % i === 0) return false;
    }
    return true;
}

function words_in_sentence(sentence: string): string {
    return sentence
        .split(' ')
        .filter(word => isPrime(word.length))
        .join(' ');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = words_in_sentence;
  assert.deepEqual(candidate(""This is a test""),""is"");
  assert.deepEqual(candidate(""lets go for swimming""),""go for"");
  assert.deepEqual(candidate(""there is no place available here""),""there is no place"");
  assert.deepEqual(candidate(""Hi I am Hussein""),""Hi am Hussein"");
  assert.deepEqual(candidate(""go for it""),""go for it"");
  assert.deepEqual(candidate(""here""),"""");
  assert.deepEqual(candidate(""here is""),""is"");
}

test();"
HumanEval_144,als_Latn,ts,"//Ju mund të supozojmë se x, dhe n janë thyerje të vlefshme, dhe nuk kanë zero si emërues. //<numerator>/<denominator> ku numeratori dhe emëruesi janë numra të tërë pozitivë. //ndryshe. Të dy x dhe n, janë përfaqësim i një fije të një fraksion, dhe kanë formatin e mëposhtëm, //x * n. Funksioni kthehet true nëse x * n vlerësohet në një numër të tërë dhe false //Detyra juaj është të implementoni një funksion që do të thjeshtojë shprehjen.// >>> simplify(""1/5"", ""5/1"")
// true
// >>> simplify(""1/6"", ""2/1"")
// false
// >>> simplify(""7/10"", ""10/2"")
// false
function simplify(x: string, n: string): boolean {
","function simplify(x: string, n: string): boolean {
    const parseFraction = (fraction: string): [number, number] => {
        const [numerator, denominator] = fraction.split('/').map(Number);
        return [numerator, denominator];
    };

    const [xNumerator, xDenominator] = parseFraction(x);
    const [nNumerator, nDenominator] = parseFraction(n);

    // Multiply the fractions: (a/b) * (c/d) = (a*c) / (b*d)
    const resultNumerator = xNumerator * nNumerator;
    const resultDenominator = xDenominator * nDenominator;

    // A product of fractions is a whole number if its numerator divided by denominator is an integer.
    return resultNumerator % resultDenominator === 0;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = simplify;
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/6"", ""2/1""),false);
  assert.deepEqual(candidate(""5/1"", ""3/1""),true);
  assert.deepEqual(candidate(""7/10"", ""10/2""),false);
  assert.deepEqual(candidate(""2/10"", ""50/10""),true);
  assert.deepEqual(candidate(""7/2"", ""4/2""),true);
  assert.deepEqual(candidate(""11/6"", ""6/1""),true);
  assert.deepEqual(candidate(""2/3"", ""5/2""),false);
  assert.deepEqual(candidate(""5/2"", ""3/5""),false);
  assert.deepEqual(candidate(""2/4"", ""8/4""),true);
  assert.deepEqual(candidate(""2/4"", ""4/2""),true);
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/5"", ""1/5""),false);
}

test();"
HumanEval_145,als_Latn,ts,"//Për shembull: //renditeni ato bazuar në indeksin e tyre në rendin origjinal.//Shënim: nëse ka disa artikuj me një shumë të ngjashme të shifrave të tyre, //në rendin ngjitës sipas shumës së shifrave të tyre.//Shkruaj një funksion që rendit rendin e numrave të plotë të dhënë.// >>> order_by_points([1, 11, -1, -11, -12])
// [-1, -11, 1, -12, 11]
// >>> order_by_points([])
// []
function order_by_points(nums: number[]): number[] {
","function order_by_points(nums: number[]): number[] {
    const digitSum = (num: number): number => {
        let sum = 0;
        let value = Math.abs(num);
        while (value > 0) {
            sum += value % 10;
            value = Math.floor(value / 10);
        }
        return sum;
    };

    return nums
        .map((num, index) => ({ num, index, sumOfDigits: digitSum(num) }))
        .sort((a, b) => {
            if (a.sumOfDigits === b.sumOfDigits) {
                return a.index - b.index;
            }
            return a.sumOfDigits - b.sumOfDigits;
        })
        .map(item => item.num);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = order_by_points;
  assert.deepEqual(candidate([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);
  assert.deepEqual(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
  assert.deepEqual(candidate([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);
}

test();"
HumanEval_146,als_Latn,ts,"//Për shembull: //shifrat e parë dhe të fundit të një numri janë të çifta (1, 3, 5, 7, 9). //Numri i elementeve në masë që janë më të mëdha se 10 dhe të dyja //Shkruaj një funksion që merr një sërë numrash si input dhe kthen // >>> specialFilter([15, -73, 14, -15])
// 1
// >>> specialFilter([33, -2, -3, 45, 21, 109])
// 2
function specialFilter(nums: number[]): number {
","function specialFilter(nums: number[]): number {
    const isOdd = (digit: number): boolean => digit % 2 !== 0;

    return nums.reduce((count, num) => {
        const absNumStr = Math.abs(num).toString();
        const firstDigit = parseInt(absNumStr[0]);
        const lastDigit = parseInt(absNumStr[absNumStr.length - 1]);

        if (num > 10 && isOdd(firstDigit) && isOdd(lastDigit)) {
            return count + 1;
        }

        return count;
    }, 0);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = specialFilter;
  assert.deepEqual(candidate([5, -2, 1, -5]),0);
  assert.deepEqual(candidate([15, -73, 14, -15]),1);
  assert.deepEqual(candidate([33, -2, -3, 45, 21, 109]),2);
  assert.deepEqual(candidate([43, -12, 93, 125, 121, 109]),4);
  assert.deepEqual(candidate([71, -2, -33, 75, 21, 19]),3);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([]),0);
}

test();"
HumanEval_147,als_Latn,ts,"//Shembull: //dhe a[i] + a[j] + a[k] është një shumëfishtë e 3. //Kthehet numri i trefishtëve (a[i], a[j], a[k]) të një ku i < j < k, //Për secilin i (1 ≤ i ≤ n), vlera e a[i] = i * i - i + 1. //Ju jepet një numër i plotë pozitiv n. Ju duhet të krijoni një numër i plotë renditje a e gjatësisë n. // >>> get_max_triples(5)
// 1
// Explanation: 
// a = [1, 3, 7, 13, 21]
// The only valid triple is (1, 7, 13).
function get_max_triples(n: number): number {
","function get_max_triples(n: number): number {
    const a: number[] = [];

    for (let i = 1; i <= n; i++) {
        a[i - 1] = i * i - i + 1;
    }

    let count = 0;

    for (let i = 0; i < n - 2; i++) {
        for (let j = i + 1; j < n - 1; j++) {
            for (let k = j + 1; k < n; k++) {
                if ((a[i] + a[j] + a[k]) % 3 === 0) {
                    count++;
                }
            }
        }
    }

    return count;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = get_max_triples;
  assert.deepEqual(candidate(5),1);
  assert.deepEqual(candidate(6),4);
  assert.deepEqual(candidate(10),36);
  assert.deepEqual(candidate(100),53361);
}

test();"
HumanEval_149,als_Latn,ts,"//Për shembull: //Mund të mendoni se të gjitha fjalët do të kenë të njëjtën gjatësi.//Funksioni duhet të kthejë një sërë vargjesh në rend të renditur.//Nëse dy fjalë kanë të njëjtën gjatësi, renditeni renditjen alfabetike.//duhet të kthejë renditjen e renditur nga ajo rregull. //Rendi i rendit duhet të jetë në rritje me gjatësinë e çdo fjale, dhe ju//dhe mund të përmbajë kopje.//Array është gjithmonë një sërë e string dhe kurrë një sërë e numrave, //dhe kthen rendin e rezultatit me një rend të renditur, //fshihet string që kanë gjatësi të çuditshme nga ajo, //Shkruaj një funksion që pranon një sërë stringesh si parameter, // >>> list_sort([""aa"", ""a"", ""aaa""])
// [""aa""]
// >>> list_sort([""ab"", ""a"", ""aaa"", ""cd""])
// [""ab"", ""cd""]
function sorted_list_sum(lst: string[]): string[] {
","function sorted_list_sum(lst: string[]): string[] {
    // Filter out strings with odd lengths
    const filtered = lst.filter(str => str.length % 2 === 0);
    // Sort the array by length, then alphabetically
    const sorted = filtered.sort((a, b) => {
        if (a.length === b.length) {
            return a.localeCompare(b);
        }
        return a.length - b.length;
    });
    return sorted;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = sorted_list_sum;
  assert.deepEqual(candidate([""aa"", ""a"", ""aaa""]),[""aa""]);
  assert.deepEqual(candidate([""school"", ""AI"", ""asdf"", ""b""]),[""AI"", ""asdf"", ""school""]);
  assert.deepEqual(candidate([""d"", ""b"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""d"", ""dcba"", ""abcd"", ""a""]),[""abcd"", ""dcba""]);
  assert.deepEqual(candidate([""AI"", ""ai"", ""au""]),[""AI"", ""ai"", ""au""]);
  assert.deepEqual(candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""aaaa"", ""bbbb"", ""dd"", ""cc""]),[""cc"", ""dd"", ""aaaa"", ""bbbb""]);
}

test();"
HumanEval_150,als_Latn,ts,"//Shembuj: //një numër i parë dhe duhet të kthejë vlerën e y ndryshe. //Një program i thjeshtë i cili duhet të kthejë vlerën e x nëse n është // >>> x_or_y(7, 34, 12)
// 34
// >>> x_or_y(15, 8, 5)
// 5
function x_or_y(n: number, x: number, y: number): number {
","function x_or_y(n: number, x: number, y: number): number {
    function isPrime(num: number): boolean {
        if (num <= 1) return false;
        if (num <= 3) return true;
        
        if (num % 2 === 0 || num % 3 === 0) return false;
        
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        
        return true;
    }

    return isPrime(n) ? x : y;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = x_or_y;
  assert.deepEqual(candidate(7, 34, 12),34);
  assert.deepEqual(candidate(15, 8, 5),5);
  assert.deepEqual(candidate(3, 33, 5212),33);
  assert.deepEqual(candidate(1259, 3, 52),3);
  assert.deepEqual(candidate(7919, -1, 12),-1);
  assert.deepEqual(candidate(3609, 1245, 583),583);
  assert.deepEqual(candidate(91, 56, 129),129);
  assert.deepEqual(candidate(6, 34, 1234),1234);
  assert.deepEqual(candidate(1, 2, 0),0);
  assert.deepEqual(candidate(2, 2, 0),2);
}

test();"
HumanEval_151,als_Latn,ts,"//in the array that are odd. Ignoro numrat që janë negative ose jo integers.//Duke pasur parasysh një sërë numrash, kthehet shuma e katrorëve të numrave.// >>> double_the_difference([1, 3, 2, 0])
// 10
// >>> double_the_difference([-1, -2, 0])
// 0
// >>> double_the_difference([9, -2])
// 81
// >>> double_the_difference([0])
// 0
// If the input array is empty, return 0.
function double_the_difference(lst: number[]): number {
","function double_the_difference(lst: number[]): number {
    return lst
        .filter(num => Number.isInteger(num) && num > 0 && num % 2 !== 0)
        .reduce((sum, num) => sum + num * num, 0);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = double_the_difference;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([5.0, 4.0]),25);
  assert.deepEqual(candidate([0.1, 0.2, 0.3]),0);
  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);
  assert.deepEqual(candidate([-1.0, -2.0, 8.0]),0);
  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);
  assert.deepEqual(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);
}

test();"
HumanEval_152,als_Latn,ts,"//Shembull: //vlera është 0, dhe nëse jo, vlera është diferenca absolute midis parashikimit dhe rezultatit. //Kthehet një masë e gjatësisë së njëjtë që tregon se sa larg ishte çdo gjasim. Nëse ata kanë gatuar saktë, //Ju jepen dy renditje të rezultateve dhe të gjetjeve të gjatësisë së barabartë, ku secili indeks tregon një ndeshje.//Detyra juaj është të përcaktohet nëse një person ka menduar saktë rezultatet e një numri ndeshjesh.//Sigurisht që ia vlen të shënohet dhe të krahasohet.//Ndjenjat dhe mendimet që keni në atë moment janë të njohura.//Mendoj se të gjithë e mbajmë mend atë ndjenjë kur rezulton një e pritur prej kohësh.// >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
// [0, 0, 0, 0, 3, 3]
// >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
// [4, 4, 1, 0, 0, 6]
function compare(game: number[], guess: number[]): number[] {
","function compare(game: number[], guess: number[]): number[] {
    return game.map((score, index) => Math.abs(score - guess[index]));
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = compare;
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3]);
  assert.deepEqual(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0]);
  assert.deepEqual(candidate([1, 2, 3], [-1, -2, -3]),[2, 4, 6]);
  assert.deepEqual(candidate([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1]);
}

test();"
HumanEval_153,als_Latn,ts,"//Shembull: //(forca e tij është -1).//return ""Slices.SErviNGSliCes"" sepse ""SErviNGSliCes"" është zgjatja më e fortë //['SErviNGSliCes', 'Cheese', 'StuFfed'] atëherë ju duhet të //Për shembull, nëse ju jepet ""Slices"" si klasa dhe një masë e //zgjidhni atë që vjen i pari në renditje.//Nëse ka dy ose më shumë zgjatje me të njëjtën forcë, duhet të//format: ClassName.StrongestExtensionName. //Duhet të gjesh zgjatjen më të fortë dhe të kthehesh me një varg në këtë .//në emrin e shtojcës, forca është dhënë nga fraksioni CAP - SM. //shkronja në emrin e shtojcës, dhe le të jetë SM numri i shkronjave të vogla //forca e zgjerimit është si më poshtë: Le të jetë CAP numri i shkronjave të mëdha //Zgjatjet do të përdoren për të ngarkuar klasa shtesë në klasë.//Ju do të jepet emri i një klase (një varg) dhe një sërë zgjatjesh.// >>> Strongest_Extension(""my_class"", [""AA"", ""Be"", ""CC""])
// ""my_class.AA""
function Strongest_Extension(class_name: string, extensions: string[]): string {
","function Strongest_Extension(class_name: string, extensions: string[]): string {
    let strongestExtension = '';
    let maxStrength = -Infinity;

    extensions.forEach(extension => {
        const capCount = extension.split('').filter(char => char >= 'A' && char <= 'Z').length;
        const smCount = extension.split('').filter(char => char >= 'a' && char <= 'z').length;
        const strength = capCount - smCount;

        if (strength > maxStrength) {
            maxStrength = strength;
            strongestExtension = extension;
        }
    });

    return `${class_name}.${strongestExtension}`;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = Strongest_Extension;
  assert.deepEqual(candidate(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]),""Watashi.eIGHt8OKe"");
  assert.deepEqual(candidate(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]),""Boku123.YEs.WeCaNe"");
  assert.deepEqual(candidate(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]),""__YESIMHERE.NuLl__"");
  assert.deepEqual(candidate(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]),""K.TAR"");
  assert.deepEqual(candidate(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]),""__HAHA.123"");
  assert.deepEqual(candidate(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]),""YameRore.okIWILL123"");
  assert.deepEqual(candidate(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]),""finNNalLLly.WoW"");
  assert.deepEqual(candidate(""_"", [""Bb"", ""91245""]),""_.Bb"");
  assert.deepEqual(candidate(""Sp"", [""671235"", ""Bb""]),""Sp.671235"");
}

test();"
HumanEval_154,als_Latn,ts,"//Ju janë dhënë 2 fjalë. Ju duhet të kthehet e vërtetë nëse fjala e dytë ose ndonjë nga rrotullimet e saj është një nënstring në fjalën e parë // >>> cycpattern_check(""abcd"", ""abd"")
// false
// >>> cycpattern_check(""hello"", ""ell"")
// true
// >>> cycpattern_check(""whassup"", ""psus"")
// false
// >>> cycpattern_check(""abab"", ""baa"")
// true
// >>> cycpattern_check(""efef"", ""eeff"")
// false
// >>> cycpattern_check(""himenss"", ""simen"")
// true
function cycpattern_check(a: string, b: string): boolean {
","function cycpattern_check(a: string, b: string): boolean {
    for (let i = 0; i < b.length; i++) {
        const rotation = b.slice(i) + b.slice(0, i);
        if (a.includes(rotation)) {
            return true;
        }
    }
    return false;
}

// Test cases
console.log(cycpattern_check(""abcd"", ""abd"")); // false
console.log(cycpattern_check(""hello"", ""ell"")); // true
console.log(cycpattern_check(""whassup"", ""psus"")); // false
console.log(cycpattern_check(""abab"", ""baa"")); // true
console.log(cycpattern_check(""efef"", ""eeff"")); // false
console.log(cycpattern_check(""himenss"", ""simen"")); // true","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = cycpattern_check;
  assert.deepEqual(candidate(""xyzw"", ""xyw""),false);
  assert.deepEqual(candidate(""yello"", ""ell""),true);
  assert.deepEqual(candidate(""whattup"", ""ptut""),false);
  assert.deepEqual(candidate(""efef"", ""fee""),true);
  assert.deepEqual(candidate(""abab"", ""aabb""),false);
  assert.deepEqual(candidate(""winemtt"", ""tinem""),true);
}

test();"
HumanEval_155,als_Latn,ts,"//Shembull: //Duke pasur parasysh një numër të plotë. kthehet një masë që ka numrin e shifrave të çifta dhe të çifta përkatësisht. // >>> even_odd_count(-12)
// [1, 1]
// >>> even_odd_count(123)
// [1, 2]
function even_odd_count(num: number): [number, number] {
","function even_odd_count(num: number): [number, number] {
    const numStr = Math.abs(num).toString();
    let evenCount = 0;
    let oddCount = 0;

    for (let char of numStr) {
        const digit = parseInt(char);
        if (digit % 2 === 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }

    return [evenCount, oddCount];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = even_odd_count;
  assert.deepEqual(candidate(7),[0, 1]);
  assert.deepEqual(candidate(-78),[1, 1]);
  assert.deepEqual(candidate(3452),[2, 2]);
  assert.deepEqual(candidate(346211),[3, 3]);
  assert.deepEqual(candidate(-345821),[3, 3]);
  assert.deepEqual(candidate(-2),[1, 0]);
  assert.deepEqual(candidate(-45347),[2, 3]);
  assert.deepEqual(candidate(0),[1, 0]);
}

test();"
HumanEval_156,als_Latn,ts,"//Shembuj: //Kufizime: 1 <= num <= 1000 //dhe ktheje me shkronja të vogla.//Duke pasur parasysh një numër të plotë pozitiv, merrni ekuivalentin e tij numerik romak si një varg, // >>> int_to_mini_roman(19)
// ""xix""
// >>> int_to_mini_roman(152)
// ""clii""
// >>> int_to_mini_roman(426)
// ""cdxxvi""
function int_to_mini_roman(number: number): string {
","function int_to_mini_roman(number: number): string {
    const romanNumerals: { [key: number]: string } = {
        1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c',
        90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix',
        5: 'v', 4: 'iv', 1: 'i'
    };
    
    let result = '';
    for (const value of Object.keys(romanNumerals).map(Number).sort((a, b) => b - a)) {
        while (number >= value) {
            result += romanNumerals[value];
            number -= value;
        }
    }
    
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = int_to_mini_roman;
  assert.deepEqual(candidate(19),""xix"");
  assert.deepEqual(candidate(152),""clii"");
  assert.deepEqual(candidate(251),""ccli"");
  assert.deepEqual(candidate(426),""cdxxvi"");
  assert.deepEqual(candidate(500),""d"");
  assert.deepEqual(candidate(1),""i"");
  assert.deepEqual(candidate(4),""iv"");
  assert.deepEqual(candidate(43),""xliii"");
  assert.deepEqual(candidate(90),""xc"");
  assert.deepEqual(candidate(94),""xciv"");
  assert.deepEqual(candidate(532),""dxxxii"");
  assert.deepEqual(candidate(900),""cm"");
  assert.deepEqual(candidate(994),""cmxciv"");
  assert.deepEqual(candidate(1000),""m"");
}

test();"
HumanEval_157,als_Latn,ts,"//Shembull: //90 gradë.//Një trekëndësh i drejtë është një trekëndësh në të cilin një kënd është i drejtë ose //anët formojnë një trekëndësh të drejtë-kullueshëm, false ndryshe.//Duke pasur parasysh gjatësinë e tri anëve të një trekëndëshi. ktheni të vërtetë nëse tre // >>> right_angle_triangle(3, 4, 5)
// true
// >>> right_angle_triangle(1, 2, 3)
// false
function right_angle_triangle(a: number, b: number, c: number): boolean {
","function right_angle_triangle(a: number, b: number, c: number): boolean {
    const sides = [a, b, c].sort((x, y) => x - y);
    return Math.pow(sides[0], 2) + Math.pow(sides[1], 2) === Math.pow(sides[2], 2);
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = right_angle_triangle;
  assert.deepEqual(candidate(3, 4, 5),true);
  assert.deepEqual(candidate(1, 2, 3),false);
  assert.deepEqual(candidate(10, 6, 8),true);
  assert.deepEqual(candidate(2, 2, 2),false);
  assert.deepEqual(candidate(7, 24, 25),true);
  assert.deepEqual(candidate(10, 5, 7),false);
  assert.deepEqual(candidate(5, 12, 13),true);
  assert.deepEqual(candidate(15, 8, 17),true);
  assert.deepEqual(candidate(48, 55, 73),true);
  assert.deepEqual(candidate(1, 1, 1),false);
  assert.deepEqual(candidate(2, 2, 10),false);
}

test();"
HumanEval_158,als_Latn,ts,"//karakteret, kthehet ai që vjen i pari në rendin leksikografik. //Nëse shumë vargjet kanë numrin maksimal të karaktereve unike //Array përmban fjalë të ndryshme. Kthehet fjala me numrin maksimal //Shkruaj një funksion që pranon një sërë stringesh.// >>> find_max([""name"", ""of"", ""string""])
// ""string""
// >>> find_max([""name"", ""enam"", ""game""])
// ""enam""
// >>> find_max([""aaaaaaa"", ""bb"", ""cc""])
// ""aaaaaaa""
function find_max(words: string[]): string {
","function find_max(words: string[]): string {
    function uniqueCharacterCount(word: string): number {
        const uniqueChars = new Set(word);
        return uniqueChars.size;
    }

    let maxWord = words[0];
    let maxUniqueCount = uniqueCharacterCount(maxWord);

    for (let i = 1; i < words.length; i++) {
        const currentUniqueCount = uniqueCharacterCount(words[i]);
        if (
            currentUniqueCount > maxUniqueCount ||
            (currentUniqueCount === maxUniqueCount && words[i] < maxWord)
        ) {
            maxWord = words[i];
            maxUniqueCount = currentUniqueCount;
        }
    }

    return maxWord;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = find_max;
  assert.deepEqual(candidate([""name"", ""of"", ""string""]),""string"");
  assert.deepEqual(candidate([""name"", ""enam"", ""game""]),""enam"");
  assert.deepEqual(candidate([""aaaaaaa"", ""bb"", ""cc""]),""aaaaaaa"");
  assert.deepEqual(candidate([""abc"", ""cba""]),""abc"");
  assert.deepEqual(candidate([""play"", ""this"", ""game"", ""of"", ""footbott""]),""footbott"");
  assert.deepEqual(candidate([""we"", ""are"", ""gonna"", ""rock""]),""gonna"");
  assert.deepEqual(candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]),""nation"");
  assert.deepEqual(candidate([""this"", ""is"", ""a"", ""prrk""]),""this"");
  assert.deepEqual(candidate([""b""]),""b"");
  assert.deepEqual(candidate([""play"", ""play"", ""play""]),""play"");
}

test();"
HumanEval_159,als_Latn,ts,"//Shembull: //nëse nuk ka karrota të mjaftueshme, do t'i hani të gjitha karrotat e mbetura, por do të jeni ende të uritur.//Numri i karrotave që kanë mbetur pas ushqimit tuaj ] //duhet të ktheni një grup prej [numri total i karotave të ngrënë pas vakteve, //por tani duhet të hani më shumë karrota për të plotësuar ushqimet e ditës.//Ti je një lepur i uritur, dhe ti tashmë ke ngrënë një numër të caktuar karrotave,// >>> eat(5, 6, 10)
// [11, 4]
// >>> eat(4, 8, 9)
// [12, 1]
// >>> eat(1, 10, 10)
// [11, 0]
// >>> eat(2, 11, 5)
// [7, 0]
// Variables:
// @number : integer
// the number of carrots that you have eaten.
// @need : integer
// the number of carrots that you need to eat.
// @remaining : integer
// the number of remaining carrots thet exist in stock
// Constrain:
// * 0 <= number <= 1000
// * 0 <= need <= 1000
// * 0 <= remaining <= 1000
// Have fun :)
function eat(number: number, need: number, remaining: number): number[] {
","function eat(number: number, need: number, remaining: number): number[] {
    const totalEaten = number + Math.min(need, remaining);
    const carrotsLeft = Math.max(remaining - need, 0);
    return [totalEaten, carrotsLeft];
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = eat;
  assert.deepEqual(candidate(5, 6, 10),[11, 4]);
  assert.deepEqual(candidate(4, 8, 9),[12, 1]);
  assert.deepEqual(candidate(1, 10, 10),[11, 0]);
  assert.deepEqual(candidate(2, 11, 5),[7, 0]);
  assert.deepEqual(candidate(4, 5, 7),[9, 2]);
  assert.deepEqual(candidate(4, 5, 1),[5, 0]);
}

test();"
HumanEval_160,als_Latn,ts,"//Operator array ka të paktën një operator, dhe operand array ka të paktën dy operandë.//Operand është një sërë e integers jo-negative.//Gjatësia e masës operator është e barabartë me gjatësinë e masës operand minus një.//Shënim://=> Rezultati = 9 //Rezultati = 2 + 3 * 4 - 5 //array = [2, 3, 4, 5] //operator['+', '*', '-'] //Shembull: //Eksponentimi (**) //Ndarja e katit ( //) //Shumëzimi (*) //Zbritje ( - ) //Shtimi (+) //Operacionet themelore të algjebrës://shprehje dhe të kthehet vlerësimi i këtij shprehjeje. //Array i dytë është një sërë e integers. Përdorni dy arrays dhënë për të ndërtuar algebraic //Duke pasur parasysh dy operatoret e rendit, dhe operand. rendit të parë ka operacione themelore algjebrike, dhe function do_algebra(operator: string[], operand: number[]): number {
","function do_algebra(operator: string[], operand: number[]): number {
    let expression = operand[0].toString();

    for (let i = 0; i < operator.length; i++) {
        expression += ` ${operator[i]} ${operand[i + 1]}`;
    }

    return Math.floor(eval(expression));
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = do_algebra;
  assert.deepEqual(candidate([""**"", ""*"", ""+""], [2, 3, 4, 5]),37);
  assert.deepEqual(candidate([""+"", ""*"", ""-""], [2, 3, 4, 5]),9);
  assert.deepEqual(candidate([""//"", ""*""], [7, 3, 4]),8);
}

test();"
HumanEval_161,als_Latn,ts,"//Shembuj //Funksioni duhet të kthejë vargjet e rezultuara.//Nëse varg nuk përmban shkronja, kthejeni varg.//Përndryshe, le të mbetet ashtu siç është.//nëse s[i] është një shkronjë, ktheje rastin e saj nga e poshtmja në të sipërme ose në të kundërtën, //Ju jepet një varg s.// >>> solve(""1234"")
// ""4321""
// >>> solve(""ab"")
// ""AB""
// >>> solve(""#a@C"")
// ""#A@c""
function solve(s: string): string {
","function solve(s: string): string {
    let hasLetter = /[a-zA-Z]/.test(s);
    if (hasLetter) {
        return s.split('').map(char => {
            if (/[a-z]/.test(char)) {
                return char.toUpperCase();
            } else if (/[A-Z]/.test(char)) {
                return char.toLowerCase();
            } else {
                return char;
            }
        }).join('');
    } else {
        return s.split('').reverse().join('');
    }
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(""AsDf""),""aSdF"");
  assert.deepEqual(candidate(""1234""),""4321"");
  assert.deepEqual(candidate(""ab""),""AB"");
  assert.deepEqual(candidate(""#a@C""),""#A@c"");
  assert.deepEqual(candidate(""#AsdfW^45""),""#aSDFw^45"");
  assert.deepEqual(candidate(""#6@2""),""2@6#"");
  assert.deepEqual(candidate(""#$a^D""),""#$A^d"");
  assert.deepEqual(candidate(""#ccc""),""#CCC"");
}

test();"
HumanEval_162,als_Latn,ts,"//Nëse 'tekst' është një varg bosh, kthehet i pa përcaktuar. //Duke pasur parasysh një varg 'tekst', kthehet vargu i tij i ekuivalentit të hash md5. // >>> string_to_md5(""Hello world"")
// ""3e25960a79dbc69b674cd4ec67a72c62""
function string_to_md5(text: string): string | undefined {
","import * as crypto from 'crypto';

function string_to_md5(text: string): string | undefined {
    if (text === """") {
        return undefined;
    }
    return crypto.createHash('md5').update(text).digest('hex');
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = string_to_md5;
  assert.deepEqual(candidate(""Hello world""),""3e25960a79dbc69b674cd4ec67a72c62"");
  assert.deepEqual(candidate(""""),undefined);
  assert.deepEqual(candidate(""A B C""),""0ef78513b0cb8cef12743f5aeb35f888"");
  assert.deepEqual(candidate(""password""),""5f4dcc3b5aa765d61d8327deb882cf99"");
}

test();"
HumanEval_163,als_Latn,ts,"//Për shembull: //dhe b, në rendin ngjitës.//Duke pasur parasysh dy integers pozitive a dhe b, kthehet edhe shifra midis a // >>> generate_integers(2, 8)
// [2, 4, 6, 8]
// >>> generate_integers(8, 2)
// [2, 4, 6, 8]
// >>> generate_integers(10, 14)
// []
function generate_integers(a: number, b: number): number[] {
","function generate_integers(a: number, b: number): number[] {
    let result: number[] = [];
    
    // Get starting and ending points in sorted order
    let start = Math.min(a, b);
    let end = Math.max(a, b);
    
    // Loop through the range
    for (let i = start; i <= end; i++) {
        if (i % 2 === 0) {  // Check if the digit is even
            result.push(i);
        }
    }
    
    return result;
}","declare var require: any;
const assert = require('node:assert');


function test() {
  let candidate = generate_integers;
  assert.deepEqual(candidate(2, 10),[2, 4, 6, 8]);
  assert.deepEqual(candidate(10, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(132, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(17, 89),[]);
}

test();"
