task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,als_Latn,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""Kontrolloni nëse në listën e dhënë të numrave, janë ndonjë dy numra më afër njëri-tjetrit se sa pragu i dhënë. Shembull: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) False >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,als_Latn,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""Input në këtë funksion është një varg që përmban grupe të shumta të parentezës së gjendur. Qëllimi juaj është të ndajë ato grupe në vargje të ndara dhe të kthejë listën e atyre. Grupet e ndara janë të balancuara (çdo kurriz i hapur është i mbyllur siç duhet) dhe nuk janë të gjendur brenda njëri-tjetrit Injoroni çdo hapësirë në varg të hyrjes. Shembull: >>> separate_paren_groups' ((( ) (() (()))))) ' ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,als_Latn,python,"

def truncate_number(number: float) -> float:
    """"""Duke pasur parasysh një numër pozitiv me pikë lundruese, ai mund të dekompozohet në një pjesë të tërë (numri më i madh i plotë më i vogël se numri i dhënë) dhe në decimalë (pjesa e mbetur gjithmonë më e vogël se 1). Kthejeni pjesën decimale të numrit. Shembull: >>> truncate_number(3.5) 0.5 """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,als_Latn,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""Ju jepet një listë e operacioneve të depozitimit dhe tërheqjes në një llogari bankare që fillon me bilanc zero. Detyra juaj është të zbuloni nëse në çdo pikë bilanci i llogarisë bie nën zero, dhe në atë pikë funksioni duhet të kthejë True. Përndryshe duhet të kthejë False. Shembull: >>> below_zero([1, 2, 3]) False >>> below_zero([1, 2, -4, 5]) True """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,als_Latn,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""Për një listë të dhënë të numrave të hyrjes, llogaritet devijimi absolut mesatar rreth mesatares së këtij grupi të të dhënave. Devijimi absolut mesatar është diferenca mesatare absolute midis secilit element dhe një pike qendrore (mesatare në këtë rast): MAD = mesatarja. x - x_mesatare. Shembull: >>> devijim_mesatare_absolut ([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,als_Latn,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""Shkruani një numër ""delimitor"" midis çdo dy elementeve të njëpasnjëshme të listës së hyrjes `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,als_Latn,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""Input në këtë funksion është një varg i përfaqësuar nga grupe të shumta për parentezat e gjendur të ndara nga hapësira. Për secilin grup, prodhojeni nivelin më të thellë të gjëndjes së parentezave. Për shembull (() (()) ka maksimumi dy nivele të gjëndjes ndërsa ((())) ka tre. >>> parse_nested_parens (('((()) ((())) (((()) (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,als_Latn,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""Filtrojë një listë hyrëse të vargjeve vetëm për ato që përmbajnë një varg të caktuar >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,als_Latn,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""Për një listë të caktuar të numrave të plotë, kthehet një tuple që përbëhet nga një shuma dhe një produkt i të gjithë numrave të plotë në një listë. Shuma bosh duhet të jetë e barabartë me 0 dhe produkti bosh duhet të jetë i barabartë me 1. >>> sum_product (([]) (0, 1) >>> sum_product (([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,als_Latn,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""Nga një listë e dhënë e numrave të plotë, gjenerohet një listë e elementit maksimal të rrumbullakosur të gjetur deri në momentin e dhënë në sekuencë. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,als_Latn,python,"

def is_palindrome(string: str) -> bool:
    """"""Gjeni palindromin më të shkurtër që fillon me një varg të dhënë. Ideja e algoritmit është e thjeshtë: - Gjeni postfix më të gjatë të vargut të dhënë që është një palindrom. - Shtojni në fund të vargut të kundërt të një prefiksi vargu që vjen para sufiksit palindromik. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('catac') ' >>> make_palindrome ((('catac') ' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""Testi nëse një varg i dhënë është një palindrom """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,als_Latn,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""Input janë dy vargjet a dhe b që përbëhen vetëm nga 1s dhe 0s. Perform binary XOR në këto hyrje dhe kthimi rezultat gjithashtu si një varg. >>> string_xor (('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,als_Latn,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""Nga lista e vargjeve, kthehet më i gjati. Kthehet i pari në rast se ka vargje të shumta me të njëjtën gjatësi. Kthehet Asnjë në rast se lista e hyrjes është bosh. >>> më i gjati([]) >>> më i gjati(['a', 'b', 'c']) 'a' >>> më i gjati(['a', 'bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,als_Latn,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""Kthehet ndarja më e madhe e përbashkët e dy numrave të plotë a dhe b >>> ndarja më e madhe e përbashkët ((3, 5) 1 >>> ndarja më e madhe e përbashkët ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,als_Latn,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""Kthehet lista e të gjitha prefikseve nga më e shkurta në më të gjata të vargut të hyrjes >>> all_prefixes (('abc') ['a', 'ab', 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,als_Latn,python,"

def string_sequence(n: int) -> str:
    """"""Kthehet një varg që përmban numra të kufizuar nga hapësira duke filluar nga 0 deri n përfshirë. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,als_Latn,python,"

def count_distinct_characters(string: str) -> int:
    """"""Duke pasur parasysh një varg, gjeni sa karaktere të ndryshme (pa marrë parasysh rastin) përbëhet nga >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,als_Latn,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""Input në këtë funksion është një varg që përfaqëson shënime muzikore në një format të veçantë ASCII. Detyra juaj është për të analizuar listën e vargjeve të integrave që korrespondon me shumë rrahje nuk. Këtu është një legjendë: 'o' notë, të fundit rrahje katër 'o' - gjysmë notë, të fundit dy rrahje 'o' - katër notë, të fundit një rrahje >>> parse_music '. 'o o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,als_Latn,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""Gjeni sa herë një nënstring i dhënë mund të gjendet në varg origjinal. Numëro rastet mbivendosëse. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,als_Latn,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""Input është një varg i numrave të kufizuar nga hapësira nga 'zero' deri në 'nëntë'. Zgjedhjet e vlefshme janë 'zero', 'një', 'dy', 'tre', 'katër', 'pesë', 'gjashtë', 'gjashtë', 'gjashtë', 'gjashtë', 'gjashtë' dhe 'gjashtë'. Kthehet vargu me numra të renditur nga më i vogël në më i madh >>> sort_numbers (('tre një pesë') 'një tre pesë' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,als_Latn,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""Nga një listë e dhënë e numrave (me gjatësi të paktën dy) zgjidhni dhe ktheni dy që janë më të afërt me njëri-tjetrin dhe ktheni ato në rend (numri më i vogël, numri më i madh). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,als_Latn,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""Duke pasur parasysh listën e numrave (të paktën dy elementeve), aplikoni një transformim linear në atë listë, në mënyrë që numri më i vogël të bëhet 0 dhe numri më i madh të bëhet 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,als_Latn,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""Filter listë e dhënë e çdo vlerave python vetëm për integers >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,als_Latn,python,"

def strlen(string: str) -> int:
    """"""Gjatësia e kthimit të një vargu të dhënë >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,als_Latn,python,"

def largest_divisor(n: int) -> int:
    """"""Për një numër të dhënë n, gjeni numrin më të madh që ndan n në mënyrë të barabartë, më të vogël se n >>> largest_divisor ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,als_Latn,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""Kthehet lista e faktorëve parësor të një numri të caktuar të plotë në rend nga më i vogël në më të madh. Secili nga faktorët duhet të renditet numrin e herëve që korrespondon me sa herë shfaqet në faktorizim. Numri i hyrjes duhet të jetë i barabartë me prodhimin e të gjithë faktorëve >>> faktorizuar ((8) [2, 2, 2] >>> faktorizuar ((25) [5, 5] >>> faktorizuar ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,als_Latn,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""Nga një listë e numrave të plotë, hiqni të gjithë elementët që ndodhin më shumë se një herë. Mbani rendin e elementeve të majta të njëjtë si në hyrje. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,als_Latn,python,"

def flip_case(string: str) -> str:
    """"""Për një varg të caktuar, ktheni karaktere të vogla në shkronja të mëdha dhe shkronja e madhe në shkronja të vogla. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,als_Latn,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Lista e vargjeve të lidhura në një varg të vetëm >>> varg (([]) '' >>> varg ((['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,als_Latn,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""Filtro një listë hyrëse të vargjeve vetëm për ato që fillojnë me një parafiks të caktuar. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,als_Latn,python,"

def get_positive(l: list):
    """"""Kthehet vetëm numrat pozitivë në listë. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,als_Latn,python,"

def is_prime(n):
    """"""Kthehet e vërtetë nëse një numër i dhënë është prim, dhe i rremë në rast të kundërt. >>> is_prime(6) False >>> is_prime(101) True >>> is_prime(11) True >>> is_prime(13441) True >>> is_prime(61) True >>> is_prime(4) False >>> is_prime(1) False """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,als_Latn,python,"import math


def poly(xs: list, x: float):
    """"""xs janë koeficientë të një polinomi. find_zero gjejnë x të tillë që poly(x) = 0. find_zero kthehet vetëm vetëm zero pikë, edhe nëse ka shumë. Për më tepër, find_zero merr vetëm listën xs që kanë numrin e çift të koeficientëve dhe koeficientin më të madh jo zero pasi garanton një zgjidhje. >>> rrotull (((find_zero[1, 2]), 2) # f(x) = 1 + 2x -0.5 >>> rrotull (((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0""""""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""Vlerëson polinom me koeficientë xs në pikën x. kthim xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,als_Latn,python,"

def sort_third(l: list):
    """"""Ky funksion merr një listë l dhe kthen një listë l 'siç është identike me l në indekset që nuk janë të ndashme me tre, ndërsa vlerat e saj në indekset që janë të ndashme me tre janë të barabarta me vlerat e indekseve përkatëse të l, por të renditura. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,als_Latn,python,"

def unique(l: list):
    """"""Kthehet elementet e renditura unike në një listë >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,als_Latn,python,"

def max_element(l: list):
    """"""Kthehet elementi maksimal në listë. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,als_Latn,python,"

def fizz_buzz(n: int):
    """"""Kthehet numri i rasteve që shifra 7 shfaqet në numra të plotë më të vegjël se n që janë të ndarë me 11 ose 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,als_Latn,python,"

def sort_even(l: list):
    """"""Ky funksion merr një listë l dhe kthen një listë l 'kështu që l' është identik me l në indekset e çuditshme, ndërsa vlerat e saj në indekset e çuditshme janë të barabarta me vlerat e indekseve të çuditshme të l, por të renditura. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,als_Latn,python,"

def encode_cyclic(s: str):
    """"""merr si input string të koduar me encode_cyclic funksion. Kthen string të dekoduar. """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""kthen string të koduar nga grupet ciklike të tre karaktereve.""""""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,als_Latn,python,"

def prime_fib(n: int):
    """"""prime_fib kthen numrin n-të që është një numër Fibonacci dhe është gjithashtu numër i parë. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,als_Latn,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero merr një listë të integers si një input. ajo kthen True nëse ka tre elemente të dallueshme në listë që shuma në zero, dhe False përndryshe. >>> triples_sum_to_zero([1, 3, 5, 0]) False >>> triples_sum_to_zero[(1, 3, -2, 1]) True >>> triples_sum_to_zero([1, 2, 3, 7]) False >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) True >>> triples_sum_to_zero[1]) False """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,als_Latn,python,"

def car_race_collision(n: int):
    """"""Imagjinoni një rrugë që është një vijë e gjatë pafundësisht e drejtë. n makina po ecin majtas-djathtas; njëkohësisht, një grup tjetër i n makinave po ecin djathtas-djathtas. Dy grupet e makinave fillojnë duke qenë shumë larg njëri-tjetrit. Të gjitha makinat lëvizin me të njëjtën shpejtësi. Dy makina thuhet se përplasen kur një makinë që lëviz majtas-djathtas godet një makinë që lëviz djathtas-djathtas. Sidoqoftë, makinat janë pafundësisht të qëndrueshme dhe të forta; si rezultat, ato vazhdojnë të lëvizin në trajektoren e tyre sikur të mos përplasen. Kjo funksion prodhon numrin e përplasjeve të tilla.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,als_Latn,python,"

def incr_list(l: list):
    """"""Kthehet lista me elementë të shtuar me 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,als_Latn,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero merr një listë të integers si një input. ajo kthen True nëse ka dy elemente të dallueshme në listë që shuma në zero, dhe False përndryshe. >>> pairs_sum_to_zero([1, 3, 5, 0]) False >>> pairs_sum_to_zero[(1, 3, -2, 1]) False >>> pairs_sum_to_zero([1, 2, 3, 7]) False >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero[1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,als_Latn,python,"

def change_base(x: int, base: int):
    """"""Ndryshoni bazën numerike të numrit të hyrjes x në bazë. ktheni përfaqësimin e vargut pas konvertimit. numrat e bazave janë më pak se 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,als_Latn,python,"

def triangle_area(a, h):
    """"""Duke pasur parasysh gjatësinë e një anës dhe zonën e kthimit të lartë për një trekëndësh. >>> trekëndësh_areja ((5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,als_Latn,python,"

def fib4(n: int):
    """"""Sekuenca e numrave Fib4 është një sekuencë e ngjashme me sekuencën e Fibbonaçit që është e përcaktuar si më poshtë: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Ju lutemi shkruani një funksion për të llogaritur në mënyrë efikase elementin e n-të të sekuencës së numrave fib4. Mos përdorni rikursion. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,als_Latn,python,"

def median(l: list):
    """"""Kthimi i medianës së elementeve në listë l. >>> median (([3, 1, 2, 4, 5]) 3 >>> median (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,als_Latn,python,"

def is_palindrome(text: str):
    """"""Kontrollohet nëse një varg i dhënë është një palindrom >>> is_palindrom (('') True >>> is_palindrom (('aba') True >>> is_palindrom (('aaaaa') True >>> is_palindrom (('zbcd') False """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,als_Latn,python,"

def modp(n: int, p: int):
    """"""Kthehet 2^n modulo p (qëndroni të vetëdijshëm për numrat). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,als_Latn,python,"

def encode_shift(s: str):
    """"""merr si input string të koduar me encode_shift funksion. Kthen string të dekoduar. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""kthen një varg të koduar duke zhvendosur çdo karakter me 5 në alfabet.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,als_Latn,python,"

def remove_vowels(text):
    """"""remove_vowels është një funksion që merr string dhe kthen string pa vokal. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,als_Latn,python,"

def below_threshold(l: list, t: int):
    """"""Kthehet True nëse të gjitha numrat në listën l janë nën pragun t. >>> below_threshold (([1, 2, 4, 10], 100) True >>> below_threshold (([1, 20, 4, 10], 5) False """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,als_Latn,python,"

def add(x: int, y: int):
    """"""Shto dy numra x dhe y >>> shto{2, 3) 5 >>> shto{5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,als_Latn,python,"

def same_chars(s0: str, s1: str):
    """"""Kontrolloni nëse dy fjalë kanë karaktere të njëjta. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') E vërtetë >>> same_chars (('abcd', 'dddddddabc') E vërtetë >>> same_chars (('dddddddabc', 'abcd') E vërtetë >>> same_chars (('eabcd', 'dddddddabc') E rreme >>> same_chars ((('abcd', 'dddddabddce') E rreme >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') E rreme """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,als_Latn,python,"

def fib(n: int):
    """"""Kthehet numri i n-të i Fibonaçit. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,als_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets është një varg i ""<"" dhe "">"". return True nëse çdo bracket hapës ka një bracket mbyllës përkatës. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,als_Latn,python,"

def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing. >>> monotonic (([1, 2, 4, 20]) True >>> monotonic (([1, 20, 4, 10]) False >>> monotonic (([4, 1, 0, -10]) True """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,als_Latn,python,"

def common(l1: list, l2: list):
    """"""Kthehet element i renditur unik i përbashkët për dy lista. >>> i zakonshëm (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> i zakonshëm (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,als_Latn,python,"

def largest_prime_factor(n: int):
    """"""Kthehet faktori kryesor më i madh i n. Supozoni n > 1 dhe nuk është një numër i parë. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,als_Latn,python,"

def sum_to_n(n: int):
    """"""sum_to_n është një funksion që shton numrat nga 1 deri n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,als_Latn,python,"

def correct_bracketing(brackets: str):
    """"""brackets është një varg i ""("" dhe "")"". return True nëse çdo bracket hapës ka një bracket mbyllës përkatës. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""() True >>> correct_bracketing("") True >>> correct_bracketing("")""""""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,als_Latn,python,"

def derivative(xs: list):
    """"""xs përfaqësojnë koeficientët e një polinomi. xs[0] + xs[1] * x + xs[2] * x^2 + .... Kthe derivati i këtij polinomi në të njëjtën formë. >>> derivati (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivati ([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,als_Latn,python,"

def fibfib(n: int):
    """"""Rreshtësia e numrave FibFib është një rreshtësi e ngjashme me rreshtësinë e Fibbonaçit që është e përcaktuar si më poshtë: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Ju lutemi shkruani një funksion për të llogaritur në mënyrë efikase elementin e n-të të rreshtësisë së numrave fibfib. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,als_Latn,python,"
FIX = """"""Shkruaj një funksion vowels_count i cili merr një varg që përfaqëson një fjalë si input dhe kthen numrin e vokalëve në varg. Vokalët në këtë rast janë 'a', 'e', 'i', 'o', 'u'. Këtu, 'y' është gjithashtu një vokal, por vetëm kur është në fund të fjalës së dhënë. Shembull: >>> vowels_count ((""abcde"") 2 >>> vowels_count ((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""Shtoj më shumë raste testimi.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,als_Latn,python,"
def circular_shift(x, shift):
    """"""Rrethreth zhvendosni shifrat e numrit të plotë x, zhvendosni shifrat nga e djathta me zhvendosje dhe ktheni rezultatin si një varg. Nëse zhvendosja > numri i shifrave, ktheni shifrat e kthyera. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,als_Latn,python,"
def digitSum(s):
    """"""Task Shkrimi i një funksioni që merr një varg si input dhe kthen shumën e karaktereve të sipërme vetëm 'kodet ASCII. Shembuj: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,als_Latn,python,"
def fruit_distribution(s,n):
    """"""Në këtë detyrë, ju do të jepet një varg që përfaqëson një numër të mollëve dhe portokallëve që janë shpërndarë në një shportë me fruta ky shportë përmban mollë, portokall dhe fruta mango. Duke pasur parasysh varg që përfaqëson numrin e përgjithshëm të portokallëve dhe mollëve dhe një numër i plotë që përfaqëson numrin e përgjithshëm të frutave në shportë kthehet numri i frutave mango në shportë. për shembull: fruit_distribution""5( mollë dhe 6 portokall"", 19) -> 19 - 5 - 6 = 8 fruta_shpërndarje""0 mollë dhe 1 portokall"",3) -> 3 - 0 - 1 = 2 fruta_shpërndarje""2 mollë dhe 3 portokall"", 100) -> 100 - 2 - 3 = 95 fruta_shpërndarje""100 mollë dhe 1 portokall"") "",1 -> 120 - 100 - 1 = 19 """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,als_Latn,python,"
def pluck(arr):
    """"""""Duke pasur parasysh një rend që përfaqëson një degë të një peme që ka nyje të entjerave jo-negative, detyra juaj është të zgjidhni një nga nyjet dhe ta ktheni atë. Nyja e zgjedhur duhet të jetë nyja me vlerën më të vogël të çiftit. Nëse gjenden shumë nyje me të njëjtën vlerë më të vogël të çiftit, kthejeni nyjen që ka indeksin më të vogël. Nyja e zgjedhur duhet të kthehet në një listë, [smallest_value, indeksin e saj], Nëse nuk ka vlera të çiftit ose rendja e dhënë është bosh, kthejeni []. Shembull 1: hyrje: [4,2,3] Dalje: [2, 1] Shpjegim: 2 ka vlerën më të vogël të çiftit dhe 2 ka indeksin më të vogël. Shembull 2: hyrje: [1,2,3] Dalje: [2, 1] Shpjegim: 2 ka vlerën më të vogël të çiftit dhe 2 ka indeksin më të vogël të çiftit. Shembull 3: hyrje: [] Dalje: [] Shembull: [4: [5, 3, 4,] hyrje: [0, 2] Dalje: 1 [0, 0] Nëse nuk ka vlera më e vogël e nyjeve, ktheni indeksi i parë, kështu që nuk ka më pak nga zero. Shembull: * = 1 * Shembull: nuk ka më e vogël nga 0 * 0 *""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,als_Latn,python,"
def search(lst):
    '''Ju është dhënë një listë jo bosh e integers pozitive. Kthehet numri më i madh i plotë që është më i madh se zero, dhe ka një frekuencë më të madhe se ose e barabartë me vlerën e vetë integers. Frekuenca e një integers është numri i herë që ajo shfaqet në listë. Nëse nuk ekziston një vlerë të tillë, kthehet -1. Shembuj: search (([4, 1, 2, 2, 3, 1]) == 2 search (([1, 2, 2, 3, 3, 3, 4, 4]) == 3 search (([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,als_Latn,python,"
def strange_sort_list(lst):
    '''Duke pasur parasysh listën e numrave të plotë, kthimi i listës në rend të çuditshëm. Çështja e çuditshme e renditjes është kur filloni me vlerën minimale, pastaj maksimumin e numrave të plotë të mbetur, pastaj minimumin dhe kështu me radhë. Shembuj: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,als_Latn,python,"
def triangle_area(a, b, c):
    '''Duke pasur parasysh gjatësitë e tri anëve të një trekëndëshi. Kthehet sipërfaqja e trekëndëshit e rrumbullakosur në 2 pikë pas desimale nëse tre anët formojnë një trekëndësh të vlefshëm. Përndryshe kthehet -1 Tre anët bëjnë një trekëndësh të vlefshëm kur shuma e dy anëve të ndonjë është më e madhe se ana e tretë. Shembull: trekëndësh_areja(3, 4, 5) == 6.00 trekëndësh_areja(1, 2, 10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,als_Latn,python,"
def will_it_fly(q,w):
    '''Shkruaj një funksion që kthen True nëse objekti q do të fluturojë, dhe False në rastin tjetër. Objekti q do të fluturojë nëse është i balancuar (është një listë palindromike) dhe shuma e elementeve të tij është më e vogël se ose e barabartë me peshën maksimale të mundshme w. Shembull: will_it_fly (([1, 2], 5) â -> False # 1+2 është më pak se pesha maksimale e mundshme, por është e pabalancuar. will_it_fly (([3, 2, 3], 1) â -> False # është e balancuar, por 3+2+3 është më shumë se pesha maksimale e mundshme. will_it_fly (([3, 2, 3], 9) â -> True # 3+23 është më pak se pesha maksimale e mundshme, dhe është e balancuar. will_it_fly ((([3], â 5) -> True # 3 është më pak se pesha maksimale e mundshme, dhe është e balancuar. '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,als_Latn,python,"
def smallest_change(arr):
    """"""Duke pasur parasysh një masë arr e numrave të plotë, gjeni numrin minimal të elementeve që duhet të ndryshohen për ta bërë masën palindromike. Një masë palindromike është një masë që lexohet njësoj prapa dhe përpara. Në një ndryshim, ju mund të ndryshoni një element në çdo element tjetër. Për shembull: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,als_Latn,python,"
def total_match(lst1, lst2):
    '''Shkruaj një funksion që pranon dy lista me vargje dhe kthen listën që ka numrin e përgjithshëm të karaktereve në të gjitha vargjet e listës më pak se lista tjetër. nëse të dy listat kanë të njëjtin numër të karaktereve, kthen listën e parë. Shembuj total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi'] total_match ((['4'], ['1'', '2'', '3'', '4'', '5' -> ['4'])'''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,als_Latn,python,"
def is_multiply_prime(a):
    """"""Shkruaj një funksion që kthehet i vërtetë nëse numri i dhënë është shumëzimi i 3 numrave të parë dhe i rremë në rastin tjetër.""""""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,als_Latn,python,"
def is_simple_power(x, n):
    """"""Detyra juaj është të shkruani një funksion që kthehet i vërtetë nëse një numër x është një fuqi e thjeshtë e n dhe i rremë në raste të tjera. x është një fuqi e thjeshtë e n nëse n**int=x Për shembull: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,als_Latn,python,"
def iscube(a):
    '''Shkruaj një funksion që merr një numër të plotë a dhe kthen të Vërtetë nëse ky ingeger është një kub i disa numrave të plotë. Shënim: ju mund të supozojmë se hyrja është gjithmonë e vlefshme. Shembuj: iscube ((1) ==> True iscube ((2) ==> False iscube ((-1) ==> True iscube ((64) ==> True iscube ((0) ==> True iscube ((180) ==> False '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,als_Latn,python,"
def hex_key(num):
    """"""Ju keni qenë të ngarkuar për të shkruar një funksion që merr një numër heksaxadecimal si një varg dhe numëron numrin e shifrave heksaxadecimale që janë primë (numri i parë, ose një numër i parë, është një numër natyror më i madh se 1 që nuk është një produkt i dy numrave natyror më të vegjël). Shifrat heksaxadecimale janë 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Numrat e parë janë 2, 3, 5, 7, 11, 13, 17,... Kështu që ju duhet të përcaktoni një numër të shifrave të mëposhtme: 2, 3, 5, 7, B (=dekimal 11), D (=dekimal 13). Shënim: ju mund të supozojmë se hyrja është gjithmonë e saktë ose bosh, dhe simbolet A,B,C,D,E,F janë gjithmonë shkronja me shkronja të mëdha. Shembuj: Për numrin ""AB"" dalja duhet të jetë numrin 1. Për numrin ""1077E"" dalja duhet të jetë 2. Për numrin ""AB"" duhet të jetë numrin 1.33A. Për numrin ""AB"" duhet të jetë numrin 4.33A. Për numrin ""ABC"" duhet të jetë 6.012896.04567D. Për numrin ""2020"" duhet të jetë 2.0EF.""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,als_Latn,python,"
def decimal_to_binary(decimal):
    """"""Do t'ju jepet një numër në formën dhjetore dhe detyra juaj është ta konvertoni atë në format binar. Funksioni duhet të kthejë një varg, me secilin karakter që përfaqëson një numër binar. Çdo karakter në varg do të jetë '0' ose '1'. Do të ketë një çift shtesë karakteresh 'db' në fillim dhe në fund të vargut. Karakterët shtesë janë atje për të ndihmuar me formatin. Shembuj: decimal_to_binary ((15) # kthen ""db1111db"" decimal_to_binary32) # kthen ""db100000db""""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,als_Latn,python,"
def is_happy(s):
    """"""Ju jepet një varg s. Detyra juaj është të kontrolloni nëse vargu është i lumtur apo jo. Një varg është i lumtur nëse gjatësia e tij është të paktën 3 dhe çdo 3 shkronja rresht janë të dallueshme Për shembull: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,als_Latn,python,"
def numerical_letter_grade(grades):
    """"""Është javën e fundit të semestrit dhe mësuesi duhet t'u japë notat nxënësve. Mësuesi ka bërë algoritmin e vet për vlerësimin. Problemi i vetëm është se ajo ka humbur kodin që përdori për vlerësimin. Ajo ju ka dhënë një listë të GPA për disa nxënës dhe ju duhet të shkruani një funksion që mund të prodhojë një listë të notave të letrave duke përdorur tabelën e mëposhtme: GPA.""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,als_Latn,python,"
def prime_length(string):
    """"""Shkruaj një funksion që merr një varg dhe kthen të Vërtetën nëse gjatësia e vargut është një numër i parë ose i Rremë në rastin tjetër Shembuj prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,als_Latn,python,"
def starts_one_ends(n):
    """"""Duke pasur parasysh një numër të plotë pozitiv n, kthehet numri i numrave të integrave pozitivë n-shifrore që fillojnë ose përfundojnë me 1. """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,als_Latn,python,"
def solve(N):
    """"""Duke pasur parasysh një numër të plotë pozitiv N, kthe shtimin e përgjithshëm të shifrave të tij në binar. Shembull Për N = 1000, shuma e shifrave do të jetë 1 prodhimi duhet të jetë ""1"". Për N = 150, shuma e shifrave do të jetë 6 prodhimi duhet të jetë ""110"". Për N = 147, shuma e shifrave do të jetë 12 prodhimi duhet të jetë ""1100"".""""""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,als_Latn,python,"
def add(lst):
    """"""Duke pasur parasysh një listë jo bosh të integers lst. shtoj elementët e çift që janë në indekse të çuditshme .. Shembuj: shtoj (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,als_Latn,python,"
def anti_shuffle(s):
    """"""Shkruaj një funksion që merr një varg dhe kthen një version të renditur të tij. Versioni i renditur i vargut, është një varg ku të gjitha fjalët (të ndara nga hapësira) janë zëvendësuar nga një fjalë e re ku të gjithë karaktereve të renditura në mënyrë në rritje bazuar në vlerën ascii. Shënim: Ju duhet të mbani rendin e fjalëve dhe hapësirave të zbrazëta në fjali. Për shembull: anti_shuffle ((('Hi') kthen 'Hi' anti_shuffle (('hello') kthen 'ehllo' anti_shuffle (('Hello World!!!') kthen 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,als_Latn,python,"
def get_row(lst, x):
    """"""Ju jepet një të dhënë 2 dimensionale, si një listë e fshikulluar, e cila është e ngjashme me matricën, megjithatë, ndryshe nga matricat, çdo rresht mund të përmbajë një numër të ndryshëm kolonave. Duke pasur parasysh lst, dhe numrin e plotë x, gjeni numrat e plotë x në listë, dhe kthimi listë e tuples, [(x1, y1), (x2, y2) ...] në mënyrë që çdo tuple është një koordinatë - (rresht, kolona), duke filluar me 0.""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,als_Latn,python,"
def sort_array(array):
    """"""Duke pasur parasysh një rend të numrave të plotë jo-negativë, kthe një kopje të rendit të dhënë pas renditjes, do të renditeni rendin e dhënë në mënyrë në rritje nëse shuma ((vlera e parë e indeksit, vlera e fundit e indeksit) është e çuditshme, ose do ta renditeni në mënyrë zbritëse nëse shuma ((vlera e parë e indeksit, vlera e fundit e indeksit) është e çuditshme. Shënim: * mos ndryshoni rendin e dhënë. Shembuj: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0] """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,als_Latn,python,"
def encrypt(s):
    """"""Krijoni një funksion encrypt që merr një varg si argument dhe kthen një varg të koduar me alfabetin që rrotullohet. alfabeti duhet të rrotullohet në një mënyrë të tillë që shkronjat të zhvendosen poshtë me dy të shumëzuar në dy vende. Për shembull: encrypt('hi') kthen 'lm' encrypt('asdfghjkl') kthen 'ewhjklnop' encrypt('gf') kthen 'kj' encrypt('et') kthen 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,als_Latn,python,"
def next_smallest(lst):
    """"""Ju jepet një listë e numrave të plotë. Shkruajeni një funksion next_smallest (() që kthen elementin e dytë më të vogël të listës. Kthehet Asnjë nëse nuk ka një element të tillë. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Asnjë next_smallest (([1, 1]) == Asnjë """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,als_Latn,python,"
def is_bored(S):
    """"""Do t'ju jepet një varg fjalësh, dhe detyra juaj është të numëroni numrin e mërzitjeve. Një mërzitje është një fjali që fillon me fjalën ""Unë"". Fjalët kufizohen nga '.', '?' ose '!'. Për shembull: >>> është_ mërzitur (shëndetje bota) 0 >>> është_ mërzitur (qiej është blu. Dielli po shkëlqen. Më pëlqen kjo mot "") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,als_Latn,python,"
def any_int(x, y, z):
    '''Krijoni një funksion që merr 3 numra. Kthen të vërtetë nëse një nga numrat është i barabartë me shumën e dy numrave të tjerë, dhe të gjithë numrat janë numra të plotë. Kthen të pavërtetë në çdo rast tjetër. Shembuj any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,als_Latn,python,"
def encode(message):
    """"""Shkruaj një funksion që merr një mesazh, dhe kodon në mënyrë të tillë që të ndërrojë rastin e të gjitha shkronjave, zëvendëson të gjitha vokalët në mesazh me letrën që shfaqet 2 vende para asaj vokali në alfabetin anglez.""""""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,als_Latn,python,"

def skjkasdkd(lst):
    """"""Ju jepet një listë e numrave të plotë. Ju duhet të gjeni vlerën më të madhe të parë dhe të ktheni shumën e shifrave të saj. Shembuj: Për lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] prodhimi duhet të jetë 10 Për lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,1,2,4,2,5,1] prodhimi duhet të jetë 25 Për lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] prodhimi duhet të jetë 13 Për lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] prodhimi duhet të jetë 11 Për lst = [0,81,12,31,21] prodhimi duhet të jetë 3 Për lst = [0,8,1,2,1,7] prodhimi duhet të jetë 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,als_Latn,python,"
def check_dict_case(dict):
    """"""Duke pasur parasysh një fjalor, kthehet True nëse të gjitha çelësat janë vargje me shkronja të vogla ose të gjitha çelësat janë vargje me shkronja të mëdha, përndryshe kthehet False. Funksioni duhet të kthejë False nëse fjalori i dhënë është bosh. Shembuj: check_dict_case{""a"":""apple"", ""b"":""banana""}) duhet të kthejë True. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) duhet të kthejë False. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) duhet të kthejë False. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) False duhet të kthejë check.dict_case{""NC"":""STATE"", ""Z"":""IP""12345}) duhet të kthejë True.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,als_Latn,python,"
def count_up_to(n):
    """"""Implementon një funksion që merr një numër të plotë jo-negativ dhe kthen një masë të n numrave të parë të plotë që janë numra parësor dhe më pak se n. për shembull: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,als_Latn,python,"
def multiply(a, b):
    """"""Përfundoni funksionin që merr dy numra të plotë dhe kthen prodhimin e shifrave të tyre të njësisë. supozojmë se input është gjithmonë i vlefshëm. Shembuj: shumëzimi ((148, 412) duhet të kthehet 16. shumëzimi ((19, 28) duhet të kthehet 72. shumëzimi ((2020, 1851) duhet të kthehet 0. shumëzimi ((14,-15) duhet të kthehet 20. """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,als_Latn,python,"
def count_upper(s):
    """"""Duke pasur parasysh një varg s, numëroni numrin e vokalëve të mëdha në indekse të para. Për shembull: count_upper (('aBCdEf') kthen 1 count_upper (('abcdefg') kthen 0 count_upper (('dBBE') kthen 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,als_Latn,python,"
def closest_integer(value):
    '''Krijoni një funksion që merr një vlerë (string) që përfaqëson një numër dhe kthen numrin e plotë më të afërt me të. Nëse numri është i njëjtë me dy numra të plotë, rrumbullakoseni atë larg nga zero. Shembuj >>> closest_integer ((""10"") 10 >>> closest_integer ((""15.3"") 15 Shënim: Rrumbullimi larg nga zero do të thotë se nëse numri i dhënë është i njëjtë me dy numra të plotë, ai që duhet të kthehet është ai që është më i largët nga zero. Për shembull closest_integer "" ((14.5"") duhet të kthehet 15 dhe closest_integer "" ((-14.5"") duhet të kthehet -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,als_Latn,python,"
def make_a_pile(n):
    """"""Duke pasur parasysh një numër të plotë pozitiv n, ju duhet të bëni një grumbull prej n niveleve gurësh. Niveli i parë ka n gurë. Numri i gurëve në nivelin tjetër është: - numri i ardhshëm i rastësishëm nëse n është i rastësishëm. - numri i ardhshëm i rastësishëm nëse n është i rastësishëm. Kthejeni numrin e gurëve në çdo nivel në një listë, ku elementi në indeks i përfaqëson numrin e gurëve në nivel (i+1). Shembuj: >>> make_a_pile(3) [3, 5, 7] """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,als_Latn,python,"
def words_string(s):
    """"""Do të ju jepet një varg fjalësh të ndara nga komma ose hapësira. Detyra juaj është të ndani varg në fjalë dhe të ktheni një sërë fjalësh. Për shembull: words_string ((""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""] words_string ((""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,als_Latn,python,"
def choose_num(x, y):
    """"""Ky funksion merr dy numra pozitivë x dhe y dhe kthen numrin më të madh të plotë të barabartë që është në intervalin [x, y] përfshirë. Nëse nuk ka një numër të tillë, atëherë funksioni duhet të kthejë -1. Për shembull: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,als_Latn,python,"
def rounded_avg(n, m):
    """"""Ju janë dhënë dy integers pozitiv n dhe m, dhe detyra juaj është për të llogaritur mesataren e integers nga n deri m (duke përfshirë n dhe m). rrumbullakos përgjigjen në numër të plotë më të afërt dhe të konvertojë atë në binar. Nëse n është më i madh se m, kthimi -1. Shembull: rounded_avg ((1, 5) => ""0b11"" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => ""0b11"" rounded_avg ((20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,als_Latn,python,"
def unique_digits(x):
    """"""Duke pasur parasysh një listë të integrave pozitivë x. kthehet një listë e renditur e të gjithë elementeve që nuk ka ndonjë shifër të çift. Shënim: Lista e kthyer duhet të renditet në mënyrë në rritje. Për shembull: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,als_Latn,python,"
def by_length(arr):
    """"""Duke pasur parasysh një sërë numrash të plotë, rendit numrat e plotë që janë midis 1 dhe 9 përfshirë, kthejnë sërë rezultatin, dhe pastaj zëvendësojnë çdo shifër me emrin e saj përkatës nga ""Një"", ""Dy"", ""Tre"", ""Kalim"", ""Pesë"", ""Gjashtë"", ""Shtatë"", ""Vetë"", ""Nëntë"". Për shembull: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> rendit arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> arr të kundërt -> [8, 5, 4, 3, 2, 2, 1, 1] kthimi [""Vetë"", ""Kalim"", ""Dy"", ""Dy"", ""Dy"", ""Two"", ""One"", ""One""] Nëse sërë është bosh, kthimi një sërë: arr = [] kthimi [] Nëse sërë ka ndonjë numër të çuditshëm, injorojeni atë: arr = [1, -1 , 55 -> arr - 1 , arr - 1 , 55 -> arr - 1 -> arr - 5 [51] kthimi - ['One' 1] """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,als_Latn,python,"
def f(n):
    """"""Implementoni funksionin f që merr n si parameter, dhe kthen një listë me madhësi n, në mënyrë që vlera e elementit në indeks i të jetë faktori i nëse i është i njëjtë ose shuma e numrave nga 1 në i ndryshe. i fillon nga 1. faktori i i është shumëzimi i numrave nga 1 në i (1 * 2 * ... * i). Shembull: f (((5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,als_Latn,python,"
def even_odd_palindrome(n):
    """"""Duke pasur parasysh një numër të plotë pozitiv n, kthehet një tuple që ka numrin e palindromave të barabarta dhe të çodhe që bien brenda intervalit ((1, n), përfshirë. Shembull1: Hyrje: 3 Dalje: (1, 2) Shpjegim: Palindroma e barabarta janë 1, 2, 3. njëra prej tyre është e barabarte, dhe dy prej tyre janë të çodhe. Shembull2: Hyrje: 12 Dalje: (4, 6) Shpjegim: Palindroma e barabarta janë 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. katër prej tyre janë të barabarta, dhe 6 prej tyre janë të çodhe. Shënim: 1. 1 <= n <= 10^3 2. tuple ka kthyer numrin e palindromave të barabarta dhe të çodhe respektivisht. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,als_Latn,python,"
def count_nums(arr):
    """"""Shkruaj një funksion count_nums i cili merr një sërë të numrave të plotë dhe kthen numrin e elementeve që ka një shuma të shifrave > 0. Nëse një numër është negativ, atëherë shifra e tij e parë e nënshkruar do të jetë negative: p.sh. -123 ka shifra të nënshkruara -1, 2 dhe 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums[(1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,als_Latn,python,"
def move_one_ball(arr):
    """"""Ne kemi një masë 'arr' prej N integers arr[1], arr[2], ..., arr[N].Numrat në masë do të renditen në mënyrë të rastësishme. Detyra juaj është të përcaktohet nëse është e mundur të renditeni një masë në mënyrë jo-shkurtëse duke kryer operacionin e mëposhtëm në masë të dhënë: Ju lejohet të kryeni operacionin e zhvendosjes së djathtë çdo numër herë. Një operacion zhvendosje të djathtë do të thotë zhvendosja e të gjitha elementeve të masës nga një pozicion në drejtimin e duhur. Elementi i fundit i masës do të zhvendoset në pozicionin fillestar në masë d.m.th. Indeksi i 0th. Nëse është e mundur të merrni masën e renditur duke kryer operacionin e mësipërm, atëherë kthimi i vërtetë kthehet i gabuar. Nëse masë e dhënë është e zbrazët, atëherë kthimi i vërtetë kthehet. Shënim: Lista e dhënë është e garantuar të ketë elemente unike. Për shembull: move_one_{} ball[3, 4, 5, 1== 2> Shpikëqyrje e vërtetë: Përdorimi i saktë: Nga 2 operacione të djathtë, nuk mund të arrihet rend i zhvendosjes së djathtë për masë.""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,als_Latn,python,"
def exchange(lst1, lst2):
    """"""Në këtë problem, ju do të zbatoni një funksion që merr dy lista me numra, dhe përcakton nëse është e mundur të kryhet një shkëmbim i elementeve midis tyre për të bërë lst1 një listë vetëm me numra të çifta. Nuk ka kufizim në numrin e elementeve të shkëmbyera midis lst1 dhe lst2. Nëse është e mundur të shkëmbeni elemente midis lst1 dhe lst2 për të bërë që të gjithë elementët e lst1 të jenë të çifta, kthe ""JA"". Ndryshe, kthe ""JO"". Për shembull: shkëmbim [1, 2, 3, 4], [1, 2, 3, 4]) => ""JA"" shkëmbim [1, 2, 3, 4], [1, 5, 3, 4]) => ""JO"" Supozohet se listat e hyrjes do të jenë jo bosh. """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,als_Latn,python,"
def histogram(test):
    """"""Duke pasur parasysh një varg që përfaqëson një shkronjë të vogël të ndarë nga hapësira, kthehet një fjalor i shkronjës me më shumë përsëritje dhe që përmban numrin përkatës. Nëse disa shkronja kanë të njëjtën shfaqje, kthehen të gjitha. Shembull: histogram (('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram (('a b b a') == {'a': 2, 'b': 2} histogram (('a b c a b') == {'a': 2, 'b': 2} histogram (('b b a') == {'b 4}: histogram (('a b') == {'b 4}) == {} """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,als_Latn,python,"
def reverse_delete(s,c):
    """"""Detyra Na janë dhënë dy vargjet s dhe c, ju duhet të fshini të gjitha karaktere në s që janë të barabarta me çdo karakter në c pastaj kontrolloni nëse vargu i rezultatit është palindrom. Një varg quhet palindrom nëse lexohet i njëjti prapa si përpara. Ju duhet të ktheni një tuple që përmban varg rezultatit dhe të Vërtetë/Të pavërtetë për kontrollin. Shembull Për s = ""abcde"", c = ""ae"", rezultati duhet të jetë ('bcd', False) Për s = ""abcdef"", c = ""b"" rezultati duhet të jetë ('acdef', False) Për s = ""abcdedcba"", c = ""ab"", rezultati duhet të jetë ('cdedc',True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,als_Latn,python,"
def odd_count(lst):
    """"""Duke pasur parasysh një listë e vargjeve, ku secili varg përbëhet vetëm nga shifra, kthehet një listë. Çdo element i i të prodhimit duhet të jetë ""numri i elementeve të çuditshme në varg i të hyrjes. "" ku të gjitha i duhet të zëvendësohen me numrin e shifrave të çuditshme në varg i të hyrjes. >>> odd_count ['1234567']) [""numri i elementeve të çuditshme 4n str4ng 4 e 4nput.""] >>> odd_count ['3', ""111111""]) [""numri i elementeve të çuditshme 1n str1ng 1 e 1nput. "", ""numri i elementeve të çuditshme 8n str8ng 8 e 8nput. ""]""""""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,als_Latn,python,"
def minSubArraySum(nums):
    """"""Duke pasur parasysh një sërë numrash të plotë, gjeni shumën minimale të çdo nën-sërë numrash jo të zbrazët. Shembull minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,als_Latn,python,"
def max_fill(grid, capacity):
    import math
    """"""Ju jepet një rrjetë drejtkëndëshe e puset. Secili rresht përfaqëson një pus të vetëm, dhe secili 1 në një rresht përfaqëson një njësi të vetme të ujit. Secili pus ka një kovë përkatëse që mund të përdoret për të nxjerrë ujë nga ajo, dhe të gjitha kovat kanë të njëjtën kapacitet. Detyra juaj është të përdorni kovat për të zbrazur puset. Prodhojeni numrin e herëve që ju nevojitet për të ulur kovat. Shembull 1: Hyrje: rrjeti: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Hyrje: 62: Hyrje: rrjeti: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1,1]] bucket_capacity: 2 Hyrje: 53: Hyrje: [[:0,0,0], [0,0]] bucket_capacity: 5 Hyrje: 0 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,als_Latn,python,"
def sort_array(arr):
    """"""Në këtë Kata, ju duhet të rendisni një sërë të integrave jo-negativë sipas numrit të njësive në përfaqësimin e tyre binar në rendin ngjitës. Për një numër të ngjashëm të njësive, renditja bazuar në vlerën dhjetore. Ajo duhet të zbatohet si kjo: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,als_Latn,python,"
def select_words(s, n):
    """"""Duke pasur parasysh një varg s dhe një numër natyral n, ju keni qenë të ngarkuar për të zbatuar një funksion që kthen një listë të të gjitha fjalëve nga varg s që përmbajnë saktësisht n konsonantë, në mënyrë që këto fjalë të shfaqen në varg s. Nëse vargu s është bosh atëherë funksioni duhet të kthejë një listë bosh. Shënim: ju mund të supozojë varg hyrje përmban vetëm shkronja dhe hapësira. Shembuj: select_words (((""Mary kishte një qengjë të vogël"", 4) ==> [""i vogël""] select_words (((""Mary kishte një qengjë të vogël"", 3) ==> [""Mary"", ""qengjë""] select_words ""i thjeshtë hapësirë e bardhë"", 2) ==> [] select_words ((""Përshëndetje botë"", 4) ==> [""botë""] select_words (((""Uncle sam"", 3) ==> [""Uncle""] """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,als_Latn,python,"
def get_closest_vowel(word):
    """"""Ju jepet një fjalë. Detyra juaj është të gjeni vokalin më të afërt që qëndron midis dy konsonantëve nga ana e djathtë e fjalës (duke u kujdesur për shkronjat e vogla). Vokalit në fillim dhe në fund nuk llogariten. Kthejeni një varg bosh nëse nuk keni gjetur asnjë vokal që plotëson kushtet e mësipërme. Mund të supozojmë se vargu i dhënë përmban vetëm shkronja angleze. Shembull: get_closest_vowel (((""yogurt"") ==> ""u"" get_closest_vowel (((""F"") ==> ""U"" get_closest_vowel (((""quick"") ==> """" get_closest_vowel"" (((ab"") ==> """" """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,als_Latn,python,"
def match_parens(lst):
    '''Ju jepet një listë me dy vargjet, të dy vargjet përbëhen vetëm nga paranteza të hapura '(' ose paranteza të mbyllura ') '. Puna juaj është të kontrolloni nëse është e mundur të lidhni dy vargjet në një rend, që vargu rezultuar do të jetë i mirë. Një varg S konsiderohet i mirë nëse dhe vetëm nëse të gjitha vargjet në S janë të balancuara. Për shembull: vargu '((()) ' është i mirë, ndërsa vargu '()) ' nuk është. Kthej 'Po' nëse ka një mënyrë për të bërë një varg të mirë, dhe kthen 'Jo' përndryshe. Shembuj: match_parens[('() ', ') ']) == 'Po' match_parens[(') ', ') ']) == 'Jo' '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,als_Latn,python,"
def maximum(arr, k):
    """"""Duke pasur parasysh një masë arr e integers dhe një numër i plotë pozitiv k, kthehet një listë e renditur e gjatësisë k me numrat maksimal k në arr. Shembull1: Hyrje: arr = [-3, -4, 5], k = 3 Dalje: [-4, -3, 5] Shembull2: Hyrje: arr = [4, -4, 4], k = 2 Dalje: [4, 4] Shembull3: Hyrje: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Dalje: [2] Shënim: 1. gjatësia e masës do të jetë në intervalin e [1, 1000]. 2. Elementët në masë do të jenë në intervalin e [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,als_Latn,python,"
def solution(lst):
    """"""Duke pasur parasysh një listë jo bosh të integers, kthehet shuma e të gjitha elementeve të çuditshme që janë në pozicione të barabarta. Shembuj zgjidhje (([5, 8, 7, 1]) ==> 12 zgjidhje (([3, 3, 3, 3, 3]) ==> 9 zgjidhje (([30, 13, 24, 321]) ==> 0 """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,als_Latn,python,"
def add_elements(arr, k):
    """"""Duke pasur parasysh një masë jo të zbrazët të numrave të plotë arr dhe një numër të plotë k, kthejnë shumën e elementeve me të paktën dy shifra nga k elementët e parë të arr. Shembull: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # shumën e 21 + 3 Kufizime: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,als_Latn,python,"
def get_odd_collatz(n):
    """"""Duke pasur parasysh një numër të plotë pozitiv n, kthehet një listë e renditur që ka numrat e çuditshëm në sekuencën e Collatz. Gjyke e Collatz është një supozim në matematikë që ka të bëjë me një sekuencë të përcaktuar si më poshtë: filloni me çdo numër të plotë pozitiv n. Pastaj çdo termë merret nga termi i mëparshëm si më poshtë: nëse termi i mëparshëm është i çift, termi tjetër është gjysma e termi të mëparshëm. Nëse termi i mëparshëm është i çuditshëm, termi tjetër është 3 herë termi i mëparshëm plus 1. Gjyka është se pavarësisht nga vlera e n, sekuenca gjithmonë do të arrijë 1.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,als_Latn,python,"
def valid_date(date):
    """"""Ju duhet të shkruani një funksion i cili validon një varg të caktuar të datës dhe kthen të Vërtetë nëse data është e vlefshme ndryshe False. Data është e vlefshme nëse të gjitha rregullat e mëposhtme janë të përmbushura: 1. Varga e datës nuk është bosh. 2. Numri i ditëve nuk është më pak se 1 ose më i lartë se 31 ditë për muajt 1,3,5,7,8,10,12. Dhe numri i ditëve nuk është më pak se 1 ose më i lartë se 30 ditë për muajt 4,6,9,11. Dhe, numri i ditëve nuk është më pak se 1 ose më i lartë se 29 për muajin 2. 3. Muajt nuk duhet të jenë më pak se 1 ose më të lartë se 12. 4. Data duhet të jetë në formatin: mm-dd-yyyy për shembull: valid_date('03-11-2000') => True_valid_date('15-01-2012') => False valid_date('04-040') => False_valid_date => '06-04-2020') => True_valid_date => '06-04/2020')""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,als_Latn,python,"
def split_words(txt):
    '''Duke pasur parasysh një varg fjalësh, kthehet një listë fjalësh të ndara në hapësira të bardha, nëse nuk ekzistojnë hapësira të bardha në tekst duhet të ndaheni në komma ',' nëse nuk ekzistojnë koma duhet të kthehet numri i shkronjave të vogla me rend të çuditshëm në alfabet, ord ((('a') = 0, ord (((b') = 1, ... ord ((('z') = 25 Shembuj split_words ((""Përshëndetje botë!"") â -> [""Përshëndetje"", ""botë!""] split_words ((""Përshëndetje, botë!"") â -> [""Përshëndetje"", ""botë!"" split_words ((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,als_Latn,python,"
def is_sorted(lst):
    '''Duke pasur parasysh një listë të numrave, kthehet nëse janë të renditura në mënyrë në rritje. Nëse lista ka më shumë se 1 duplikatë të të njëjtit numër, kthehet False. Mos supozo numra negativë dhe vetëm integër. Shembuj është_rregulluar (i renditur) [1]) â -> True is_sorted (i renditur) [1, 2, 3, 4, 5]) â -> True is_sorted (i renditur) [1, 2, 3, 4, 5, 6]) â -> False is_sorted (i renditur) [1, 2, 3, 4, 5, 6, 7]) â -> True is_sorted (i renditur) [1, 3, 2, 4, 5, 6, 7]) â -> False is_sorted (i renditur) [1, 3, 2, 4, 5, 6, 7]) -> False is_sorted (i renditur) [1, 2, 2, 3, 3, 4] â -> True is_sorted (i renditur) [1, 2, 2, 2, 3, 4 -> False ])'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,als_Latn,python,"
def intersection(interval1, interval2):
    """"""Ju janë dhënë dy intervale, ku çdo interval është një palë e integers. Për shembull, interval = (fillimi, fundi) = (1, 2). Intervalet e dhënë janë të mbyllura që do të thotë se interval (fillimi, fundi) përfshin të dy fillimi dhe fundi. Për çdo interval të dhënë, supozohet se fillimi i saj është më pak ose i barabartë me fundin e saj. Detyra juaj është për të përcaktuar nëse gjatësia e kryqëzimit të këtyre dy intervaleve është një numër i parë. Shembull, kryqëzimi i intervaleve (1, 3), (2, 4) është (2, 3) e cila gjatësia e saj është 1, e cila nuk është një numër i parë. Nëse gjatësia e kryqëzimit është një numër i parë, kthehet ""Po"", përndryshe, kthehet ""Jo"". Nëse dy intervalët nuk kryqëzohen, kthehet ""JO"". [input/output] shembuj: kryqëzimi (((1, 2), (2, 3) ==> ""kryqëzimi ((-1, 1), 4) ==> ""kryqëzimi ((1, 5), ==> ""YES"", ((-3, 5>) ))""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,als_Latn,python,"
def prod_signs(arr):
    """"""Ju është dhënë një masë arr e integers dhe ju duhet të kthehet shuma e madhësive e integers shumëzuar me produkt të të gjitha shenjave të çdo numri në masë, të përfaqësuara nga 1, -1 ose 0. Shënim: return Asnjë për bosht arr. Shembull: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == Asnjë""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,als_Latn,python,"
def minPath(grid, k):
    """"""Duke pasur parasysh një rrjet me N rreshta dhe N kolona (N >= 2) dhe një numër të plotë pozitiv k, çdo qelizë e rrjetit përmban një vlerë. Çdo numër i plotë në intervalin [1, N * N] përfshirë shfaqet saktësisht një herë në qelizat e rrjetit. Ju duhet të gjeni rrugën minimale të gjatësisë k në rrjet. Ju mund të filloni nga çdo qelizë, dhe në çdo hap ju mund të lëvizni në çdo qelizë fqinje, me fjalë të tjera, ju mund të shkoni në qelizat që ndajnë një skaj me ju qeliza aktuale. Ju lutemi vini re se një rrugë e gjatësisë k do të thotë të vizitoni saktësisht k qeliza (jo domosdoshmërisht të dallueshme). Ju nuk mund të shkoni jashtë rrjetit. Një rrugë A (e gjatësisë k) konsiderohet më pak se një rrugë B (e gjatësisë k) nëse pas bërjes së listave të renditura të vlerave në qelizat që kalojnë A dhe B (le t'i quajmë ato l_stA dhe l_stB), l_stA është lexikishtishtishtisht më pak se l_st_A, me fjalë të tjera, në rrjetin e rradhës, ju duhet të gjeni një rrugë minimale me gjatësinë k. Ju mund të filloni nga çdo qelizë, dhe në çdo hap tjetër hap ju mund të shkoni nga çdo qeliza fqin e rrjetë, me një qelizë fqin e përbashkët qelize k, me një skalit fqin e cila ndan një skalit të përbashkët me ju. Ju mund të filloni nga çdo qeliza e rrymë e rrjetë, dhe çdo hap i rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës së rrotës""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,als_Latn,python,"
def tri(n):
    """"""Të gjithë e njohin sekuencën e Fibonaçit, ajo është studiuar thellë nga matematikanët në dy shekujt e fundit. Sidoqoftë, ajo që njerëzit nuk e dinë është sekuenca e Tribonaçit. Sekuenca e Tribonaçit përcaktohet nga përsëritja: tri(1) = 3 tri(n) = 1 + n / 2, nëse n është i çift. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), nëse n është i çuditshëm. Për shembull: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Ju u jepet një numër i plotë jo-negativ n, ju duhet të ktheni një listë të numrave të parë n + 1 të sekuencës Tribonaçit. Shembuj: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,als_Latn,python,"
def digits(n):
    """"""Duke pasur parasysh një numër të plotë pozitiv n, kthehet produkti i shifrave të çuditshme. Kthehet 0 nëse të gjitha shifrat janë të para. Për shembull: shifrat ((1) == 1 shifrat ((4) == 0 shifrat ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,als_Latn,python,"
def is_nested(string):
    '''Krijoni një funksion që merr një varg si input i cili përmban vetëm kurorë katrorë. Funksioni duhet të kthejë True nëse dhe vetëm nëse ka një nënsekuencë të vlefshme të kurorëve ku të paktën një kurorë në nënsekuencë është i zhytur. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,als_Latn,python,"

def sum_squares(lst):
    """"""Ju jepet një listë e numrave. Ju duhet të ktheni shumën e numrave në katror në listën e dhënë, rrumbullakosni çdo element në listë në int më të lartë ((Tavan) së pari. Shembuj: Për lst = [1,2,3] prodhimi duhet të jetë 14 Për lst = [1,4,9] prodhimi duhet të jetë 98 Për lst = [1,3,5,7] prodhimi duhet të jetë 84 Për lst = [1.4,4.2,0] prodhimi duhet të jetë 29 Për lst = [-2.4,1,1] prodhimi duhet të jetë 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,als_Latn,python,"
def check_if_last_char_is_a_letter(txt):
    '''Krijoni një funksion që kthen Vërtetë nëse karakteri i fundit i një vargu të dhënë është një karakter alfabetik dhe nuk është pjesë e një fjale, dhe False përndryshe. Shënim: ""fjala"" është një grup karaktereve të ndara nga hapësira. Shembuj: check_if_last_char_is_a_letter ((""tortë me mollë"") â -> False check_if_last_char_is_a_letter ((""tortë me mollë"") â -> True check_if_last_char_is_a_letter ((""tortë me mollë"") â -> False check_if_last_char_is_a_letter"" ((("") â -> False '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,als_Latn,python,"
def can_arrange(arr):
    """"""Krijoni një funksion që kthen indeksin më të madh të një elementi që nuk është më i madh se ose i barabartë me elementin menjëherë para tij. Nëse nuk ekziston një element i tillë atëherë kthen -1. Array i dhënë nuk do të përmbajë vlera të dyfishta. Shembuj: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,als_Latn,python,"
def largest_smallest_integers(lst):
    '''Krijoni një funksion që kthen një tuple (a, b), ku 'a' është më i madhi i integers negative, dhe 'b' është më i vogël i integers pozitive në një listë. Nëse nuk ka integers negative ose pozitive, kthejnë ata si Asnjë. Shembuj: më i madh_smallest_integers[2, 4, 1, 3, 5, 7]) == (Asnjë, 1) më i madh_smallest_integers([]) == (Asnjë, Asnjë) më i madh_smallest_integers[0]) == (Asnjë, Asnjë) '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,als_Latn,python,"
def compare_one(a, b):
    """"""Krijoni një funksion që merr numra të plotë, fluturues, ose varg që përfaqësojnë numrat realë, dhe kthen variablin më të madh në llojin e tij të caktuar të variablit. Kthehet Asnjë nëse vlerat janë të barabarta. Shënim: Nëse një numër real përfaqësohet si një varg, pika fluturuese mund të jetë . ose , compare_one{1, 2.5) â -> 2.5 compare_one{1, ""2,3"") â -> ""2,3"" compare_one{5,1"", ""6"") â -> ""6"" compare_one{1"", 1) â -> Asnjë """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,als_Latn,python,"
def is_equal_to_sum_even(n):
    """"""Vlerësoni nëse numri i dhënë n mund të shkruhet si shuma e saktësisht 4 numrave të barabartë pozitiv Shembull është_i barabartë_me_shumën_even (e barabartë) 4) == False është_i barabartë_me_shumën_even (e barabartë) 6) == False është_i barabartë_me_shumën_even (e barabartë) 8) == True """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,als_Latn,python,"
def special_factorial(n):
    """"""Faktoriali brazilian është i përcaktuar si: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! ku n > 0 Për shembull: >>> special_factorial ((4) 288 Funksioni do të marrë një numër të plotë si input dhe duhet të kthejë faktorialin e veçantë të këtij numri të plotë. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,als_Latn,python,"
def fix_spaces(text):
    """"""_ Shembull-3asysh një tekst të vargut, zëvendëso të gjitha hapësirat në të me nënvizues, dhe nëse një varg ka më shumë se 2 hapësira të njëpasnjëshme, atëherë zëvendëso të gjitha hapësirat e njëpasnjëshme me - fix_spaces ((""Shembull"") == ""Shembull"" fix_spaces ((""Shembull1"") == ""Shembull_1"" fix_spaces (((""Shembull2"") == ""_Shembull_2"" fix_spaces ((""Shembull 3"") == ""_Shembull-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,als_Latn,python,"
def file_name_check(file_name):
    """"""Krijoni një funksion i cili merr një varg që përfaqëson emrin e një skedari, dhe kthen 'Po' nëse emri i skedarit është i vlefshëm, dhe kthen 'Jo' në rast të kundërt. Një emër i skedarit konsiderohet i vlefshëm nëse dhe vetëm nëse plotësohen të gjitha kushtet e mëposhtme: - Nuk duhet të ketë më shumë se tre shifra ('0'-'9') në emrin e skedarit. - Emri i skedarit përmban saktësisht një pikë '.' - Nënvargja para pikës nuk duhet të jetë bosh, dhe fillon me një shkronjë nga alfabeti latin ('a'-'z' dhe 'A'Z'). - Nënvargja pas pikës duhet të jetë një nga këto: ['txt', 'exe', 'lld'] Shembuj: file_name_check""{example.txt"") # => 'Po'_name_file_check""{example.dll1"") => 'Jo' (# emri duhet të fillojë me një shkronjë latin)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,als_Latn,python,"


def sum_squares(lst):
    """""""" Kjo funksion do të marrë një listë të numrave të plotë. Për të gjitha hyrjet në listë, funksioni do të katërrojë hyrjen e numrit të plotë nëse indeksi i tij është një shumëfishtë i 3 dhe do të kubisë hyrjen e numrit të plotë nëse indeksi i tij është një shumëfishtë i 4 dhe jo një shumëfishtë i 3. Funksioni nuk do të ndryshojë hyrjet në listë të cilat indekset nuk janë një shumëfishtë të 3 ose 4. Funksioni pastaj do të kthejë shumën e të gjitha hyrjeve. Shembuj: Për lst = [1,2,3] prodhimi duhet të jetë 6 Për lst = [] prodhimi duhet të jetë 0 Për lst = [-1,-5,2,-1,-5] prodhimi duhet të jetë -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,als_Latn,python,"
def words_in_sentence(sentence):
    """"""Ju jepet një varg që përfaqëson një fjali, fjali përmban disa fjalë të ndara nga një hapësirë, dhe ju duhet të ktheni një varg që përmban fjalët nga fjali origjinale, gjatësia e të cilëve janë numra parësor, renditja e fjalëve në varg të ri duhet të jetë i njëjtë me atë origjinale. Shembull1: Hyrje: fjali = ""Kjo është një provë"" Dalje: ""është"" Shembull2: Hyrje: fjali = ""le të shkojë për not"" Dalje: ""go for"" Kufizime: * 1 <= len(fjalë) <= 100 * Fjali përmban vetëm shkronja """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,als_Latn,python,"
def simplify(x, n):
    """"""Detyra juaj është të implementoni një funksion që do të thjeshtojë shprehjen x * n. Funksioni kthehet True nëse x * n vlerësohet në një numër të tërë dhe False përndryshe. Të dy x dhe n, janë përfaqësim i një fije të një fraksionit dhe kanë formatin e mëposhtëm, <numerator>/<denominator> ku numëruesi dhe emëruesi janë numra të tërë pozitivë. Ju mund të supozoni se x dhe n janë fraksione të vlefshme dhe nuk kanë zero si emërues. thjeshtojne ""1/5"", ""5/1"") = True thjeshtojne ""1/6"", ""2/1"") = False thjeshtojne ""7/10"", ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,als_Latn,python,"
def order_by_points(nums):
    """"""Shkrua një funksion i cili rendit listën e dhënë të numrave të plotë në rendin ngjitës sipas shumës së shifrave të tyre. Shënim: nëse ka disa elemente me një shumë të ngjashme të shifrave të tyre, renditeni ato bazuar në indeksin e tyre në listën origjinale. Për shembull: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,als_Latn,python,"
def specialFilter(nums):
    """"""Shkruaj një funksion që merr një sërë numrash si input dhe kthen numrin e elementeve në sërë që janë më të mëdha se 10 dhe si shifrat e parë dhe të fundit të një numri janë të çuditshme (1, 3, 5, 7, 9). Për shembull: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,als_Latn,python,"
def get_max_triples(n):
    """"""Ju është dhënë një numër i plotë pozitiv n. Ju duhet të krijoni një numër i plotë renditje a e gjatësisë n. Për çdo i (1 ‰¤ i ‰¤ n), vlera e a[i] = i * i - i + 1. Kthehet numri i trefishtë (a[i], a[j], a[k]) e një ku i < j < k, dhe a[i] + a[j] + a[k] është një shumëfish i 3. Shembull: Input: n = 5 Output: 1 Shpjegim: a = [1, 3, 7, 13, 21] Trefishtëja e vetme e vlefshme është (1, 7, 13). """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,als_Latn,python,"
def bf(planet1, planet2):
    '''Ekzistojnë tetë planete në sistemin tonë diellor: më i afërti me Diellin është Merkuri, i ardhshmi është Venusi, pastaj Toka, Marsi, Jupiteri, Saturni, Urani, Neptuni. Shkruaj një funksion që merr dy emra planetash si vargjet planet1 dhe planet2. Funksioni duhet të kthejë një tuple që përmban të gjitha planetet orbitat e të cilave janë të vendosura midis orbitës së planetit1 dhe orbitës së planetit2, të renditura sipas afërsisë me Diellin. Funksioni duhet të kthejë një tuple bosh nëse planet1 ose planet2 nuk janë emrat e saktë të planetit. Shembuj bf ""(Jupiter"", ""Neptuni"") ==> (""Saturn"", ""Uran"") bf ((""Toka"", ""Merkur"") ==> (""Venusi"") bf ((""Merkueri"", ""Uran"") ==> (""Venusi"", ""Toka"", ""Mars"", ""Jupiter"", ""Sn"") '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,als_Latn,python,"
def sorted_list_sum(lst):
    """"""Shkruaj një funksion që pranon një listë e vargjeve si parameter, fshihet vargjet që kanë gjatësi të çuditshme nga ajo, dhe kthen listën e rezultuar me një rend të renditur, Lista është gjithmonë një listë e vargjeve dhe kurrë një masë e numrave, dhe mund të përmbajë kopje. Rendi i listës duhet të jetë në rritje nga gjatësia e çdo fjale, dhe ju duhet të ktheni listën e renditur nga ajo rregull. Nëse dy fjalë kanë të njëjtën gjatësi, renditeni listën alfabetikisht. Funksioni duhet të kthejë një listë e vargjeve në rend të renditur. Ju mund të supozojë se të gjitha fjalët do të kenë të njëjtën gjatësi. Për shembull: assert list_sort[""aa"", ""a"", ""aaa""]) => assert list_sort[""ab"", ""a"", ""aaa"", ""cd"" => ""cd ""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,als_Latn,python,"
def x_or_y(n, x, y):
    """"""Një program i thjeshtë i cili duhet të kthejë vlerën e x nëse n është një numër i parë dhe duhet të kthejë vlerën e y përndryshe. Shembuj: për x_or_y(7, 34, 12) == 34 për x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,als_Latn,python,"
def double_the_difference(lst):
    '''Duke pasur parasysh një listë të numrave, kthehet shuma e katrorëve të numrave në listë që janë të rastësishëm. Injoroni numrat që janë negativë ose jo të plotë. dyfishi_diferenca (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 dyfishi_diferenca (([-1, -2, 0]) == 0 dyfishi_diferenca (([9, -2]) == 81 dyfishi_diferenca (([0]) == 0 Nëse lista e hyrjes është bosh, kthehet 0. '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,als_Latn,python,"
def compare(game,guess):
    """"""Mendoj se të gjithë e mbajmë mend atë ndjenjë kur përfundimisht dihet rezultati i ndonjë ngjarjeje të pritur prej kohësh. Ndjenjat dhe mendimet që keni në atë moment janë patjetër të vlefshme për t'u shënuar dhe krahasuar. Detyra juaj është të përcaktohet nëse një person ka menduar saktë rezultatet e një numri ndeshjesh. Ju u jepen dy renditje të rezultateve dhe gjasimeve me gjatësi të barabartë, ku secili indeks tregon një ndeshje. Kthehet një renditje me të njëjtën gjatësi që tregon se sa larg ishte çdo gjasim. Nëse ata kanë menduar saktë, vlera është 0, dhe nëse jo, vlera është diferenca absolute midis gjasimit dhe rezultatit. shembull: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3][0], [0,0,4,4,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,als_Latn,python,"
def Strongest_Extension(class_name, extensions):
    """"""Do t'ju jepet emri i një klase (një varg) dhe një listë e zgjerimeve. Zgjerimet do të përdoren për të ngarkuar klasa shtesë në klasë. Forca e zgjerimit është si më poshtë: Le të jetë CAP numri i shkronjave të mëdha në emrin e zgjerimit, dhe le të jetë SM numri i shkronjave të vogla në emrin e zgjerimit, forca është dhënë nga fraksioni CAP - SM. Ju duhet të gjeni zgjerimin më të fortë dhe të ktheni një varg në këtë format: ClassName.StrongestExtensionName. Nëse ka dy ose më shumë zgjerime me të njëjtën forcë, ju duhet të zgjidhni atë që vjen e para në listë. Për shembull, nëse ju jepet ""Slices"" si klasa dhe një listë e zgjerimeve: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] atëherë ju duhet të ktheni 'Slices.SEviRNGSliCes' pasi 'SviRNGSliCes' është shkronja më e fortë (egjithimi është: 'AA_Beats'), për shembull, 'AA_Beast' është zgjerimi më i fortë.""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,als_Latn,python,"
def cycpattern_check(a , b):
    """"""Ju janë dhënë 2 fjalë. Ju duhet të kthehet True nëse fjala e dytë ose ndonjë nga rrotullimet e saj është një nënstring në fjalën e parë cycpattern_check(""abcd"",""abd"") => False cycpattern_check(""hello"",""ell"") => True cycpattern_check(""whassup"",""psus"") => False cycpattern_check""abab"",""baa"") => True cycpattern_check(""efef"",""eeff"") => False cycpattern_check""(hims"",""simen"") => True """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,als_Latn,python,"
def even_odd_count(num):
    """"""Duke pasur parasysh një numër të plotë, kthehet një tuple që ka numrin e shifrave të çifta dhe të çifta përkatësisht. Shembull: edhe_çifti_çifti(-12) ==> (1, 1) edhe_çifti_çifti(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,als_Latn,python,"
def int_to_mini_roman(number):
    """"""Duke pasur parasysh një numër të plotë pozitiv, merrni ekuivalentin e tij numerik romak si një varg dhe kthejeni atë me shkronja të vogla. Kufizime: 1 <= num <= 1000 Shembuj: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,als_Latn,python,"
def right_angle_triangle(a, b, c):
    '''Duke pasur parasysh gjatësinë e tri anëve të një trekëndëshi. Kthehet e vërtetë nëse tre anët formojnë një trekëndësh të drejtë-këngull, False përndryshe. Një trekëndësh i drejtë-këngull është një trekëndësh në të cilin një kënd është kënd i drejtë ose 90 gradë. Shembull: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,als_Latn,python,"
def find_max(words):
    """"""Shkruaj një funksion që pranon një listë me vargje. Lista përmban fjalë të ndryshme. Kthej fjalën me numrin maksimal të karaktereve unike. Nëse vargjet e shumta kanë numrin maksimal të karaktereve unike, kthe atë që vjen i pari në rendin leksikografik.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,als_Latn,python,"
def eat(number, need, remaining):
    """"""Ju jeni një lepur i uritur, dhe ju tashmë keni ngrënë një numër të caktuar karrota, por tani ju duhet të hani më shumë karrota për të përfunduar ushqimet e ditës. ju duhet të kthejë një masë të [numri total i karrotave të ngrënë pas vakteve tuaja, numri i karrotave të mbetur pas vakteve tuaja ] nëse nuk ka mjaftueshëm karrota të mbetura, ju do të hani të gjitha karrota të mbetura, por ende do të jetë i uritur. Shembull: * hani(5, 6, 10) -> [11, 4] * hani(4, 8, 9) -> [12, 1] * hani(1, 10, 10) -> [11, 0] * hani(2, 11, 5) -> [7, 0] Variable: @number: numër i plotë i numrit të karrotave që ju keni ngrënë. @need: numri i plotë i karrotave që ju duhet të hani. @remaining: numër i plotë i karrotave të mbetura në stok: * Constrain: 0 = <= 0 * 1000 = <= 0 * 0 = <= 1000 = 0 = > Have fun:""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,als_Latn,python,"
def do_algebra(operator, operand):
    """"""Operator dhe operand. Lista e parë ka operacione themelore algjebrike, dhe lista e dytë është një listë e integrave. Përdorni dy listat e dhëna për të ndërtuar shprehjen algjebrike dhe ktheni vlerësimin e këtij shprehjeje. Operacionet themelore algjebrike: Blerja ( +) Zëvlerësimi ( -) Shumëzimi ( *) Ndarja e katit ( //) Eksponentimi ( ** Shembull) Operator['+', '*', '-'] Array = [2, 3, 4, 5] Rezultati = 2 + 3 * 4 - 5 => Rezultati = 9 Shënim: Gjatësia e listës së operatorit është e barabartë me gjatësinë e listës së operandit minus një. Operand është një listë e integrave jo-negativë. Operatori ka të paktën një listë operatorësh, dhe lista e operandës ka të paktën dy operanda. """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,als_Latn,python,"
def solve(s):
    """"""Nëse s[i] është një shkronjë, kthejeni rastin e saj nga më poshtë në sipër ose kundërt, përndryshe e lini ashtu siç është. Nëse shkronja nuk përmban shkronja, kthejeni shkronjen. Funksioni duhet të kthejë shkronjen e rezultuar. Shembuj zgjidhje ((""1234"") = ""4321"" zgjidhje ((""ab"") = ""AB"" zgjidhje ((""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,als_Latn,python,"
def string_to_md5(text):
    """"""Duke pasur parasysh një varg 'tekst', kthehet vargu i tij ekuivalent md5 hash. Nëse 'tekst' është një varg i zbrazët, kthehet None. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,als_Latn,python,"
def generate_integers(a, b):
    """"""Duke pasur parasysh dy numra të plotë pozitivë a dhe b, kthe numrat e çift midis a dhe b, në rendin ngjitës. Për shembull: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
