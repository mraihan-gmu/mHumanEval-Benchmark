task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    // ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್ ್    //ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯಲ್ಲಿ, ಕ್ಕಿಂತ ಯಾವುದೇ ಎರಡು ಸಂಖ್ಯೆಗಳು ಪರಸ್ಪರ ಹತ್ತಿರವಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ.    // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))
    // (false)
    // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))
    // (true)
    public static bool HasCloseElements(List<float> numbers, float threshold) {
","public static bool HasCloseElements(List<float> numbers, float threshold) {
    numbers.Sort();
    for (int i = 1; i < numbers.Count; i++) {
        if (numbers[i] - numbers[i - 1] < threshold) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
    }

}
"
HumanEval_1,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇನ್ಪುಟ್ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿರುವ ಯಾವುದೇ ಸ್ಥಳಗಳನ್ನು ನಿರ್ಲಕ್ಷಿಸಿ.    //ಪ್ರತ್ಯೇಕ ಗುಂಪುಗಳು ಸಮತೋಲಿತವಾಗಿರುತ್ತವೆ (ಪ್ರತಿ ತೆರೆದ ಬ್ರೇಸ್ ಸರಿಯಾಗಿ ಮುಚ್ಚಲ್ಪಡುತ್ತದೆ) ಮತ್ತು ಪರಸ್ಪರರೊಳಗೆ ಗೂಡುಕಟ್ಟಲಾಗುವುದಿಲ್ಲ .    //ಆ ಗುಂಪನ್ನು ಪ್ರತ್ಯೇಕ ಸ್ಟ್ರಿಂಗ್ಗಳಾಗಿ ಬೇರ್ಪಡಿಸಿ ಮತ್ತು ಆ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ.    //ಈ ಕಾರ್ಯಕ್ಕೆ ಇನ್ಪುಟ್ ಎನ್ನುವುದು ನೆಸ್ಟೆಡ್ ಆವರಣಗಳ ಬಹು ಗುಂಪುಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ. ನಿಮ್ಮ ಗುರಿ     // >>> SeparateParenGroups((""( ) (( )) (( )( ))""))
    // (new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))
    public static List<string> SeparateParenGroups(string paren_string) {
","public static List<string> SeparateParenGroups(string paren_string) {
        List<string> result = new List<string>();
        StringBuilder currentGroup = new StringBuilder();
        int balance = 0;

        foreach (char c in paren_string) {
            if (c == ' ') {
                continue;
            }

            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }

            currentGroup.Append(c);

            // When balance is zero, we have a complete group
            if (balance == 0 && currentGroup.Length > 0) {
                result.Add(currentGroup.ToString());
                currentGroup.Clear();
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SeparateParenGroups((""(()()) ((())) () ((())()())"")).Equals((new List<string>(new string[]{(string)""(()())"", (string)""((()))"", (string)""()"", (string)""((())()())""}))));
    Debug.Assert(SeparateParenGroups((""() (()) ((())) (((())))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""((()))"", (string)""(((())))""}))));
    Debug.Assert(SeparateParenGroups((""(()(())((())))"")).Equals((new List<string>(new string[]{(string)""(()(())((())))""}))));
    Debug.Assert(SeparateParenGroups((""( ) (( )) (( )( ))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))));
    }

}
"
HumanEval_2,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಸಂಖ್ಯೆಯ ದಶಮಾಂಶ ಭಾಗವನ್ನು ಹಿಂತಿರುಗಿ.    //(ಉಳಿದ ಭಾಗವು ಯಾವಾಗಲೂ 1 ಕ್ಕಿಂತ ಚಿಕ್ಕದಾಗಿದೆ).    //ಮತ್ತು ಪೂರ್ಣಾಂಕ ಭಾಗ (ದೊಡ್ಡದಾದ ಪೂರ್ಣಾಂಕವು ನಿರ್ದಿಷ್ಟ ಸಂಖ್ಯೆಯ ಚಿಕ್ಕದಾಗಿದೆ) ಮತ್ತು ದಶಮಾಂಶ     //ಸಕಾರಾತ್ಮಕ ಫ್ಲೋಟಿಂಗ್ ಪಾಯಿಂಟ್ ಸಂಖ್ಯೆಯನ್ನು ನೀಡಿದರೆ, ಅದನ್ನು  ಎಂದು ವಿಭಜಿಸಬಹುದು.    // >>> TruncateNumber((3.5f))
    // (0.5f)
    public static float TruncateNumber(float number) {
","using System;

class Problem {
    // Given a positive floating point number, it can be decomposed into
    // an integer part (largest integer smaller than the given number) and decimals
    // (leftover part always smaller than 1).
    // Return the decimal part of the number.
    public static float TruncateNumber(float number) {
        return number - (float)Math.Floor(number);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TruncateNumber((3.5f)) == (0.5f));
    Debug.Assert(TruncateNumber((1.25f)) == (0.25f));
    Debug.Assert(TruncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಆ ಹಂತದಲ್ಲಿ ಕಾರ್ಯವು true ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು. ಇಲ್ಲದಿದ್ದರೆ ಅದು false ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.    //ಶೂನ್ಯ ಸಮತೋಲನ. ನಿಮ್ಮ ಕಾರ್ಯವು ಯಾವುದೇ ಹಂತದಲ್ಲಿ ಖಾತೆಯ ಸಮತೋಲನ ಶೂನ್ಯಕ್ಕಿಂತ ಕಡಿಮೆಯಾಗಿದ್ದರೆ ಪತ್ತೆಹಚ್ಚುವುದು, ಮತ್ತು     //ನಿಮಗೆ  ಎಂಬ ಅಕ್ಷರದಿಂದ ಪ್ರಾರಂಭವಾಗುವ ಬ್ಯಾಂಕ್ ಖಾತೆಯಲ್ಲಿನ ಠೇವಣಿ ಮತ್ತು ಹಿಂಪಡೆಯುವ ಕಾರ್ಯಾಚರಣೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ.    // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (false)
    // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L})))
    // (true)
    public static bool BelowZero(List<long> operations) {
","long balance = 0;
    foreach (var operation in operations) {
        balance += operation;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowZero((new List<long>())) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-3L, (long)1L, (long)2L, (long)-3L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-5L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-2L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (true));
    }

}
"
HumanEval_4,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //MAD = ಸರಾಸರಿ. x - x_mean.     //ಅಂಶ ಮತ್ತು ಕೇಂದ್ರಬಿಂದು (ಈ ಸಂದರ್ಭದಲ್ಲಿ ಸರಾಸರಿ):     //ಸರಾಸರಿ ಸಂಪೂರ್ಣ ವಿಚಲನವು ಪ್ರತಿ     //ಈ ಡೇಟಾ ಸೆಟ್ನ ಸರಾಸರಿ.    //ಇನ್ಪುಟ್ ಸಂಖ್ಯೆಗಳ ನಿರ್ದಿಷ್ಟ ಪಟ್ಟಿಗಾಗಿ, ಸರಾಸರಿ ಸಂಪೂರ್ಣ ವಿಚಲನವನ್ನು ಲೆಕ್ಕ ಹಾಕಿ.    // >>> MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))
    // (1.0f)
    public static float MeanAbsoluteDeviation(List<float> numbers) {
","if (numbers == null || numbers.Count == 0)
    {
        throw new ArgumentException(""The list of numbers must not be null or empty."");
    }
    
    float sum = 0.0f;
    foreach (float number in numbers)
    {
        sum += number;
    }

    float mean = sum / numbers.Count;
    float absoluteDeviationSum = 0.0f;
    
    foreach (float number in numbers)
    {
        absoluteDeviationSum += Math.Abs(number - mean);
    }
    
    float meanAbsoluteDeviation = absoluteDeviationSum / numbers.Count;
    return meanAbsoluteDeviation;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f}))) == (0.5f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
    }

}
"
HumanEval_5,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇನ್ಪುಟ್ ಪಟ್ಟಿಯ ಪ್ರತಿ ಎರಡು ಸತತ ಅಂಶಗಳ ನಡುವೆ 'ಡಿಲಿಮೀಟರ್' ಸಂಖ್ಯೆಯನ್ನು ಸೇರಿಸಿ `numbers'     // >>> Intersperse((new List<long>()), (4L))
    // (new List<long>())
    // >>> Intersperse((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (4L))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)4L, (long)3L}))
    public static List<long> Intersperse(List<long> numbers, long delimeter) {
","public static List<long> Intersperse(List<long> numbers, long delimeter)
{
    List<long> result = new List<long>();

    if (numbers == null || numbers.Count == 0)
    {
        return result;
    }

    for (int i = 0; i < numbers.Count; i++)
    {
        result.Add(numbers[i]);
        if (i < numbers.Count - 1)
        {
            result.Add(delimeter);
        }
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersperse((new List<long>()), (7L)).Equals((new List<long>())));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)2L})), (8L)).Equals((new List<long>(new long[]{(long)5L, (long)8L, (long)6L, (long)8L, (long)3L, (long)8L, (long)2L}))));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)2L, (long)2L, (long)2L})), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L, (long)2L, (long)2L}))));
    }

}
"
HumanEval_6,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾ. (() (()) ಗೂಡುಕಟ್ಟುವಿಕೆಯ ಗರಿಷ್ಠ ಎರಡು ಹಂತಗಳನ್ನು ಹೊಂದಿದ್ದರೆ ((())) ಮೂರು ಹೊಂದಿದೆ.     //ಗುಂಪಿನ ಪ್ರತಿಯೊಂದು, ಆವರಣಗಳ ಗೂಡುಕಟ್ಟುವಿಕೆ ಆಳವಾದ ಮಟ್ಟದ ಔಟ್ಪುಟ್.     //ಈ ಕಾರ್ಯಕ್ಕೆ ಇನ್ಪುಟ್ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ, ಇದು ಅಂತರಗಳಿಂದ ಬೇರ್ಪಡಿಸಲಾದ ಗೂಡುಗಳ ಆವರಣಗಳಿಗೆ ಬಹು ಗುಂಪುಗಳನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.    // >>> ParseNestedParens((""(()()) ((())) () ((())()())""))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))
    public static List<long> ParseNestedParens(string paren_string) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> ParseNestedParens(string paren_string) {
        List<long> nestingLevels = new List<long>();
        string[] groups = paren_string.Split(' ');

        foreach (string group in groups) {
            long currentLevel = 0;
            long maxLevel = 0;

            foreach (char c in group) {
                if (c == '(') {
                    currentLevel++;
                    if (currentLevel > maxLevel) {
                        maxLevel = currentLevel;
                    }
                } else if (c == ')') {
                    currentLevel--;
                }
            }

            nestingLevels.Add(maxLevel);
        }

        return nestingLevels;
    }

    static void Main(string[] args) {
        string input = ""(()()) ((())) () ((())()())"";
        List<long> result = ParseNestedParens(input);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseNestedParens((""(()()) ((())) () ((())()())"")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(ParseNestedParens((""() (()) ((())) (((())))"")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(ParseNestedParens((""(()(())((())))"")).Equals((new List<long>(new long[]{(long)4L}))));
    }

}
"
HumanEval_7,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ನಿರ್ದಿಷ್ಟ ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ಗಳ ಇನ್ಪುಟ್ ಪಟ್ಟಿಯನ್ನು ಮಾತ್ರ ಫಿಲ್ಟರ್ ಮಾಡಿ    // >>> FilterBySubstring((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterBySubstring((new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""array""}))
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
        List<string> result = new List<string>();
        foreach (string str in strings) {
            if (str.Contains(substring)) {
                result.Add(str);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterBySubstring((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""aaaxxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""aaaxxy"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""grunt"", (string)""trumpet"", (string)""prune"", (string)""gruesome""})), (""run"")).Equals((new List<string>(new string[]{(string)""grunt"", (string)""prune""}))));
    }

}
"
HumanEval_8,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಖಾಲಿ ಮೊತ್ತವು 0 ಮತ್ತು ಖಾಲಿ ಉತ್ಪನ್ನವು 1 ಕ್ಕೆ ಸಮಾನವಾಗಿರಬೇಕು.    //ಪೂರ್ಣಾಂಕಗಳ ಒಂದು ನಿರ್ದಿಷ್ಟ ಪಟ್ಟಿಗಾಗಿ, ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿರುವ ಎಲ್ಲಾ ಪೂರ್ಣಾಂಕಗಳ ಮೊತ್ತ ಮತ್ತು ಉತ್ಪನ್ನವನ್ನು ಒಳಗೊಂಡಿರುವ ಒಂದು ಟುಪಲ್ ಅನ್ನು ಹಿಂತಿರುಗಿ.    // >>> SumProduct((new List<long>()))
    // (Tuple.Create(0L, 1L))
    // >>> SumProduct((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (Tuple.Create(10L, 24L))
    public static Tuple<long, long> SumProduct(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<long, long> SumProduct(List<long> numbers) {
        long sum = 0L;
        long product = 1L;

        foreach (var number in numbers) {
            sum += number;
            product *= number;
        }

        return Tuple.Create(sum, product);
    }

    static void Main(string[] args) {
        // Test cases
        var result1 = SumProduct(new List<long>());
        Console.WriteLine($""({result1.Item1}, {result1.Item2})""); // Should output (0, 1)

        var result2 = SumProduct(new List<long> { 1L, 2L, 3L, 4L });
        Console.WriteLine($""({result2.Item1}, {result2.Item2})""); // Should output (10, 24)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumProduct((new List<long>())).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)1L, (long)1L, (long)1L}))).Equals((Tuple.Create(3L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)100L, (long)0L}))).Equals((Tuple.Create(100L, 0L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))).Equals((Tuple.Create(15L, 105L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)10L}))).Equals((Tuple.Create(10L, 10L))));
    }

}
"
HumanEval_9,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಅನುಕ್ರಮದಲ್ಲಿ.    //ಒಂದು ನಿರ್ದಿಷ್ಟ ಪಟ್ಟಿಯಿಂದ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ರಚಿಸಿ, ನಿರ್ದಿಷ್ಟ ಕ್ಷಣದವರೆಗೆ ಕಂಡುಬರುವ ರೋಲಿಂಗ್ ಗರಿಷ್ಠ ಅಂಶಗಳ ಪಟ್ಟಿಯನ್ನು ರಚಿಸಿ.    // >>> RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L}))
    public static List<long> RollingMax(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> RollingMax(List<long> numbers) {
        List<long> rollingMaxList = new List<long>();
        long currentMax = long.MinValue;

        foreach (var number in numbers) {
            if (number > currentMax) {
                currentMax = number;
            }
            rollingMaxList.Add(currentMax);
        }

        return rollingMaxList;
    }

    public static void Main(string[] args) {
        List<long> numbers = new List<long> { 1L, 2L, 3L, 2L, 3L, 4L, 2L };
        List<long> result = RollingMax(numbers);
        Console.WriteLine(""Rolling Max: "" + string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RollingMax((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)3L, (long)2L, (long)3L, (long)100L, (long)3L}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)100L, (long)100L}))));
    }

}
"
HumanEval_10,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //- ಸ್ಟ್ರಿಂಗ್ ಪೂರ್ವಪ್ರತ್ಯಯದ ಸ್ಟ್ರಿಂಗ್ ರಿವರ್ಸ್ನ ಅಂತ್ಯಕ್ಕೆ ಸೇರಿಸಿ ಅದು ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಪ್ರತ್ಯಯದ ಮೊದಲು ಬರುತ್ತದೆ.    //- ಒದಗಿಸಿದ ಸ್ಟ್ರಿಂಗ್ನ ಅತಿ ಉದ್ದದ ಪೋಸ್ಟ್ಫಿಕ್ಸ್ ಅನ್ನು ಪೈಲಿಂಡ್ರೋಮ್ ಎಂದು ಹುಡುಕಿ.    //ಅಲ್ಗಾರಿದಮ್ ಕಲ್ಪನೆ ಸರಳವಾಗಿದೆ:     //ಒದಗಿಸಿದ ಸ್ಟ್ರಿಂಗ್ನೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುವ ಕಡಿಮೆ ಪಾಲಿಂಡ್ರೋಮ್ ಅನ್ನು ಹುಡುಕಿ.    // >>> MakePalindrome((""""))
    // ("""")
    // >>> MakePalindrome((""cat""))
    // (""catac"")
    // >>> MakePalindrome((""cata""))
    // (""catac"")
    public static string MakePalindrome(string str) {
","if (string.IsNullOrEmpty(str)) return str;

    int maxPalindromeLength = 0;
    for (int i = 0; i < str.Length; i++) {
        if (IsPalindrome(str, i, str.Length - 1)) {
            maxPalindromeLength = str.Length - i;
            break;
        }
    }

    string suffixToPrepend = str.Substring(0, str.Length - maxPalindromeLength);
    char[] reversedPrefix = suffixToPrepend.Reverse().ToArray();
    return str + new string(reversedPrefix);
}

private static bool IsPalindrome(string str, int left, int right) {
    while (left < right) {
        if (str[left] != str[right]) return false;
        left++;
        right--;
    }
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakePalindrome(("""")).Equals(("""")));
    Debug.Assert(MakePalindrome((""x"")).Equals((""x"")));
    Debug.Assert(MakePalindrome((""xyz"")).Equals((""xyzyx"")));
    Debug.Assert(MakePalindrome((""xyx"")).Equals((""xyx"")));
    Debug.Assert(MakePalindrome((""jerry"")).Equals((""jerryrrej"")));
    }

}
"
HumanEval_11,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಈ ಇನ್ಪುಟ್ ಗಳಲ್ಲಿ ಬೈನರಿ XOR ಅನ್ನು ನಿರ್ವಹಿಸಿ ಮತ್ತು ಫಲಿತಾಂಶವನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಹಿಂತಿರುಗಿ.    //ಇನ್ಪುಟ್ ಎರಡು ಸ್ಟ್ರಿಂಗ್ ಗಳು a ಮತ್ತು b ಇವು 1 ಮತ್ತು 0 ಗಳನ್ನು ಮಾತ್ರ ಹೊಂದಿರುತ್ತವೆ.    // >>> StringXor((""010""), (""110""))
    // (""100"")
    public static string StringXor(string a, string b) {
","if (a.Length != b.Length) {
        throw new ArgumentException(""Input strings must be of the same length."");
    }

    StringBuilder result = new StringBuilder(a.Length);

    for (int i = 0; i < a.Length; i++) {
        result.Append(a[i] == b[i] ? '0' : '1');
    }

    return result.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringXor((""111000""), (""101010"")).Equals((""010010"")));
    Debug.Assert(StringXor((""1""), (""1"")).Equals((""0"")));
    Debug.Assert(StringXor((""0101""), (""0000"")).Equals((""0101"")));
    }

}
"
HumanEval_12,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಒಂದೇ ಉದ್ದದ ಸ್ಟ್ರಿಂಗ್ಗಳು. ಇನ್ಪುಟ್ ಪಟ್ಟಿ ಖಾಲಿಯಿದ್ದರೆ ಶೂನ್ಯವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯಿಂದ, ದೀರ್ಘವಾದ ಒಂದನ್ನು ಹಿಂತಿರುಗಿಸಿ. ಬಹು ಗಳ ಸಂದರ್ಭದಲ್ಲಿ ಮೊದಲನೆಯದನ್ನು ಹಿಂತಿರುಗಿಸಿ.    // >>> Longest((new List<string>()))
    // null
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""a"")
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""bb"", (string)""ccc""})))
    // (""ccc"")
    public static string Longest(List<string> strings) {
","if (strings == null || strings.Count == 0)
    {
        return null;
    }
    
    string longest = strings[0];
    
    foreach (string str in strings)
    {
        if (str.Length > longest.Length)
        {
            longest = str;
        }
    }
    
    return longest;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Longest((new List<string>())).Equals(null));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""x"")));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""yyy"", (string)""zzzz"", (string)""www"", (string)""kkkk"", (string)""abc""}))).Equals((""zzzz"")));
    }

}
"
HumanEval_13,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಎರಡು ಪೂರ್ಣಾಂಕಗಳ a ಮತ್ತು b ಗಳ ಒಂದು ದೊಡ್ಡ ಸಾಮಾನ್ಯ ವಿಭಾಜಕವನ್ನು ಹಿಂತಿರುಗಿ.    // >>> GreatestCommonDivisor((3L), (5L))
    // (1L)
    // >>> GreatestCommonDivisor((25L), (15L))
    // (5L)
    public static long GreatestCommonDivisor(long a, long b) {
","// Base case: if b is 0, gcd is a
    if (b == 0)
        return a;
    
    // Recursive call: gcd(a, b) = gcd(b, a % b)
    return GreatestCommonDivisor(b, a % b);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GreatestCommonDivisor((3L), (7L)) == (1L));
    Debug.Assert(GreatestCommonDivisor((10L), (15L)) == (5L));
    Debug.Assert(GreatestCommonDivisor((49L), (14L)) == (7L));
    Debug.Assert(GreatestCommonDivisor((144L), (60L)) == (12L));
    }

}
"
HumanEval_14,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇನ್ಪುಟ್ ಸ್ಟ್ರಿಂಗ್ನ ಚಿಕ್ಕದಾದಿಂದ ಉದ್ದದವರೆಗಿನ ಎಲ್ಲಾ ಪೂರ್ವಪ್ರತ್ಯಯಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ     // >>> AllPrefixes((""abc""))
    // (new List<string>(new string[]{(string)""a"", (string)""ab"", (string)""abc""}))
    public static List<string> AllPrefixes(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list of all prefixes from shortest to longest of the input string
    public static List<string> AllPrefixes(string str) {
        List<string> prefixes = new List<string>();
        for (int i = 1; i <= str.Length; i++) {
            prefixes.Add(str.Substring(0, i));
        }
        return prefixes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AllPrefixes(("""")).Equals((new List<string>())));
    Debug.Assert(AllPrefixes((""asdfgh"")).Equals((new List<string>(new string[]{(string)""a"", (string)""as"", (string)""asd"", (string)""asdf"", (string)""asdfg"", (string)""asdfgh""}))));
    Debug.Assert(AllPrefixes((""WWW"")).Equals((new List<string>(new string[]{(string)""W"", (string)""WW"", (string)""WWW""}))));
    }

}
"
HumanEval_15,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //0 ರಿಂದ n ವರೆಗೆ ಸೇರಿದಂತೆ ಸ್ಥಳ-ನಿರ್ಧರಿತ ಸಂಖ್ಯೆಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.     // >>> StringSequence((0L))
    // (""0"")
    // >>> StringSequence((5L))
    // (""0 1 2 3 4 5"")
    public static string StringSequence(long n) {
","public static string StringSequence(long n) {
    StringBuilder sb = new StringBuilder();
    for (long i = 0; i <= n; i++) {
        if (i > 0) {
            sb.Append("" "");
        }
        sb.Append(i);
    }
    return sb.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringSequence((0L)).Equals((""0"")));
    Debug.Assert(StringSequence((3L)).Equals((""0 1 2 3"")));
    Debug.Assert(StringSequence((10L)).Equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ನೀಡಿದರೆ, ಎಷ್ಟು ವಿಭಿನ್ನ ಅಕ್ಷರಗಳನ್ನು (ಪ್ರಕರಣವನ್ನು ಲೆಕ್ಕಿಸದೆ) ಇದು ಒಳಗೊಂಡಿದೆ ಎಂದು ಕಂಡುಹಿಡಿಯಿರಿ    // >>> CountDistinctCharacters((""xyzXYZ""))
    // (3L)
    // >>> CountDistinctCharacters((""Jerry""))
    // (4L)
    public static long CountDistinctCharacters(string str) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long CountDistinctCharacters(string str) {
        // Convert the string to lower case to handle case insensitivity
        str = str.ToLower();

        // Use a HashSet to store distinct characters
        HashSet<char> distinctChars = new HashSet<char>(str);

        // Return the count of distinct characters
        return distinctChars.Count;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountDistinctCharacters(("""")) == (0L));
    Debug.Assert(CountDistinctCharacters((""abcde"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""abcdecadeCADE"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""aaaaAAAAaaaa"")) == (1L));
    Debug.Assert(CountDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5L));
    }

}
"
HumanEval_17,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //'ಹ್ಯಾಕ್' - ಕ್ವಾರ್ಟರ್ ನೋಟ್, ಒಂದು ಬೀಟ್ ಅನ್ನು ಹೊಂದಿದೆ.    //'ಓ ಛೇ' - ಅರ್ಧ ನೋಟ್, ಎರಡು ಬೀಟ್ಸ್     //'ಒ' - ಸಂಪೂರ್ಣ ಟಿಪ್ಪಣಿ, ನಾಲ್ಕು ಬೀಟ್ಸ್     //ಇಲ್ಲಿ ಒಂದು ದಂತಕಥೆ ಇದೆ:     //ಕೊನೆಯದಲ್ಲ.    //ನಿಮ್ಮ ಕಾರ್ಯವು ಈ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಪಾರ್ಸ್ ಮಾಡುವುದು ಮತ್ತು ಪ್ರತಿ ಎಷ್ಟು ಬೀಟ್ಗಳಿಗೆ ಅನುಗುಣವಾಗಿ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುವುದು     //ಈ ಕಾರ್ಯಕ್ಕೆ ಇನ್ಪುಟ್ ವಿಶೇಷ ASCII ಸ್ವರೂಪದಲ್ಲಿ ಸಂಗೀತದ ಟಿಪ್ಪಣಿಗಳನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.    // >>> ParseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (new List<long>(new long[]{(long)4L, (long)2L, (long)1L, (long)2L, (long)2L, (long)1L, (long)1L, (long)1L, (long)1L, (long)4L, (long)4L}))
    public static List<long> ParseMusic(string music_string) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> ParseMusic(string music_string)
    {
        List<long> beats = new List<long>();
        string[] notes = music_string.Split(' ');
        
        foreach (string note in notes)
        {
            switch (note)
            {
                case ""o"":
                    beats.Add(4L);
                    break;
                case ""o|"":
                    beats.Add(2L);
                    break;
                case "".|"":
                    beats.Add(1L);
                    break;
                default:
                    break;
            }
        }
        
        return beats;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseMusic(("""")).Equals((new List<long>())));
    Debug.Assert(ParseMusic((""o o o o"")).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic(("".| .| .| .|"")).Equals((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}))));
    Debug.Assert(ParseMusic((""o| o| .| .| o o o o"")).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)1L, (long)1L, (long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic((""o| .| o| .| o o| o o|"")).Equals((new List<long>(new long[]{(long)2L, (long)1L, (long)2L, (long)1L, (long)4L, (long)2L, (long)4L, (long)2L}))));
    }

}
"
HumanEval_18,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಮೂಲ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿ ನಿರ್ದಿಷ್ಟ ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಎಷ್ಟು ಬಾರಿ ಕಂಡುಬರುತ್ತದೆ ಎಂಬುದನ್ನು ಕಂಡುಹಿಡಿಯಿರಿ. ಅತಿಕ್ರಮಿಸುವ ಪ್ರಕರಣಗಳನ್ನು ಎಣಿಸಿ.    // >>> HowManyTimes((""""), (""a""))
    // (0L)
    // >>> HowManyTimes((""aaa""), (""a""))
    // (3L)
    // >>> HowManyTimes((""aaaa""), (""aa""))
    // (3L)
    public static long HowManyTimes(string str, string substring) {
","using System;

class Problem {
    public static long HowManyTimes(string str, string substring) {
        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring)) {
            return 0L;
        }

        long count = 0;
        int index = 0;

        while ((index = str.IndexOf(substring, index)) != -1) {
            count++;
            index++;
        }

        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(HowManyTimes(""aaa"", ""a"")); // Output: 3
        Console.WriteLine(HowManyTimes(""aaaa"", ""aa"")); // Output: 3
        Console.WriteLine(HowManyTimes("""", ""a"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HowManyTimes((""""), (""x"")) == (0L));
    Debug.Assert(HowManyTimes((""xyxyxyx""), (""x"")) == (4L));
    Debug.Assert(HowManyTimes((""cacacacac""), (""cac"")) == (4L));
    Debug.Assert(HowManyTimes((""john doe""), (""john"")) == (1L));
    }

}
"
HumanEval_19,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಚಿಕ್ಕದರಿಂದ ದೊಡ್ಡದಕ್ಕೆ ವಿಂಗಡಿಸಲಾದ ಸಂಖ್ಯೆಗಳೊಂದಿಗೆ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂತಿರುಗಿ     //ಮಾನ್ಯ ಆಯ್ಕೆಗಳು 'ಶೂನ್ಯ', 'ಒಂದು', 'ಎರಡು', 'ಮೂರು', 'ನಾಲ್ಕು', 'ಐದು', 'ಆರು', 'ಏಳು', 'ಎಂಟು' ಮತ್ತು 'ಒಂಬತ್ತು'.     //ಇನ್ಪುಟ್ ಎಂಬುದು 'ಶೂನ್ಯ'ದಿಂದ 'ಒಂಬತ್ತು' ವರೆಗಿನ ಸಂಖ್ಯೆಗಳ ಸ್ಥಳ-ನಿರ್ಧರಿತ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.    // >>> SortNumbers((""three one five""))
    // (""one three five"")
    public static string SortNumbers(string numbers) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static string SortNumbers(string numbers)
    {
        Dictionary<string, int> numberWords = new Dictionary<string, int>
        {
            { ""zero"", 0 },
            { ""one"", 1 },
            { ""two"", 2 },
            { ""three"", 3 },
            { ""four"", 4 },
            { ""five"", 5 },
            { ""six"", 6 },
            { ""seven"", 7 },
            { ""eight"", 8 },
            { ""nine"", 9 }
        };

        List<string> numberList = new List<string>(numbers.Split(' '));
        numberList.Sort((a, b) => numberWords[a].CompareTo(numberWords[b]));
        return string.Join("" "", numberList);
    }

    static void Main(string[] args)
    {
        Console.WriteLine(SortNumbers(""three one five"")); // Output: ""one three five""
        Console.WriteLine(SortNumbers(""nine eight seven six"")); // Output: ""six seven eight nine""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortNumbers(("""")).Equals(("""")));
    Debug.Assert(SortNumbers((""three"")).Equals((""three"")));
    Debug.Assert(SortNumbers((""three five nine"")).Equals((""three five nine"")));
    Debug.Assert(SortNumbers((""five zero four seven nine eight"")).Equals((""zero four five seven eight nine"")));
    Debug.Assert(SortNumbers((""six five four three two one zero"")).Equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇತರ ಮತ್ತು ಅವುಗಳನ್ನು ಕ್ರಮದಲ್ಲಿ ಹಿಂತಿರುಗಿ (ಸಣ್ಣ ಸಂಖ್ಯೆ, ದೊಡ್ಡ ಸಂಖ್ಯೆ).    //ಒದಗಿಸಲಾದ ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯಿಂದ (ಕನಿಷ್ಠ ಎರಡು ಉದ್ದದ) ಪ್ರತಿ ಒಂದಕ್ಕೆ ಹತ್ತಿರವಿರುವ ಎರಡು ಸಂಖ್ಯೆಗಳನ್ನು ಆಯ್ಕೆಮಾಡಿ ಮತ್ತು ಹಿಂತಿರುಗಿ     // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))
    // (Tuple.Create(2.0f, 2.2f))
    // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))
    // (Tuple.Create(2.0f, 2.0f))
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
        if (numbers == null || numbers.Count < 2) {
            throw new ArgumentException(""List must contain at least two numbers."");
        }
        
        numbers.Sort();
        float minDifference = float.MaxValue;
        Tuple<float, float> closestPair = null;

        for (int i = 0; i < numbers.Count - 1; i++) {
            float difference = numbers[i + 1] - numbers[i];
            if (difference < minDifference) {
                minDifference = difference;
                closestPair = Tuple.Create(numbers[i], numbers[i + 1]);
            }
        }

        return closestPair;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(3.9f, 4.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))).Equals((Tuple.Create(5.0f, 5.9f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(2.0f, 2.2f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))).Equals((Tuple.Create(2.0f, 2.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))).Equals((Tuple.Create(2.2f, 3.1f))));
    }

}
"
HumanEval_21,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಆದ್ದರಿಂದ ಚಿಕ್ಕದಾದ ಸಂಖ್ಯೆ 0 ಆಗುತ್ತದೆ ಮತ್ತು ದೊಡ್ಡದು 1 ಆಗುತ್ತದೆ     //ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ (ಕನಿಷ್ಠ ಎರಡು ಅಂಶಗಳ), ಆ ಪಟ್ಟಿಗೆ ರೇಖೀಯ ಪರಿವರ್ತನೆಯನ್ನು ಅನ್ವಯಿಸಿ,    // >>> RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))
    // (new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))
    public static List<float> RescaleToUnit(List<float> numbers) {
","public static List<float> RescaleToUnit(List<float> numbers) {
        if (numbers == null || numbers.Count < 2)
            throw new ArgumentException(""List must contain at least two elements."");

        float min = numbers.Min();
        float max = numbers.Max();

        if (min == max)
            throw new ArgumentException(""All elements are the same. Cannot rescale."");

        return numbers.Select(num => (num - min) / (max - min)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)100.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)1.0f, (float)0.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    }

}
"
HumanEval_22,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪೂರ್ಣಾಂಕಗಳಿಗೆ ಮಾತ್ರ ಯಾವುದೇ csthon ಮೌಲ್ಯಗಳ ಪಟ್ಟಿಯನ್ನು ಫಿಲ್ಟರ್ ಮಾಡಿ    // >>> FilterIntegers((new List<object>(new string[]{(string)""a"", (string)3.14f, (string)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> FilterIntegers((new List<object>(new object[]{1L, 2L, 3L, ""abc"", new List<object>()})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    public static List<long> FilterIntegers(List<object> values) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> FilterIntegers(List<object> values) {
        List<long> result = new List<long>();
        foreach (var value in values) {
            if (value is long) {
                result.Add((long)value);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterIntegers((new List<object>())).Equals((new List<long>())));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{4L, new List<object>(), 23.2f, 9L, ""adasd""}))).Equals((new List<long>(new long[]{(long)4L, (long)9L}))));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{3L, ""c"", 3L, 3L, ""a"", ""b""}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_23,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಕೊಟ್ಟಿರುವ ಸ್ಟ್ರಿಂಗ್ನ ರಿಟರ್ನ್ ಉದ್ದ     // >>> StringLength((""""))
    // (0L)
    // >>> StringLength((""abc""))
    // (3L)
    public static long Strlen(string str) {
","return str.Length;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Strlen(("""")) == (0L));
    Debug.Assert(Strlen((""x"")) == (1L));
    Debug.Assert(Strlen((""asdasnakj"")) == (9L));
    }

}
"
HumanEval_24,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಒಂದು ನಿರ್ದಿಷ್ಟ ಸಂಖ್ಯೆಯ n ಗಾಗಿ, n ಗಿಂತ ಚಿಕ್ಕದಾದ, n ಅನ್ನು ಸಮವಾಗಿ ವಿಭಜಿಸುವ ದೊಡ್ಡ ಸಂಖ್ಯೆಯನ್ನು ಹುಡುಕಿ     // >>> LargestDivisor((15L))
    // (5L)
    public static long LargestDivisor(long n) {
","if (n <= 1)
        {
            throw new ArgumentOutOfRangeException(""n must be greater than 1"");
        }
        for (long i = n / 2; i >= 1; i--)
        {
            if (n % i == 0)
            {
                return i;
            }
        }
        return 1; // This line is theoretically unreachable since 1 is always a divisor of n
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestDivisor((3L)) == (1L));
    Debug.Assert(LargestDivisor((7L)) == (1L));
    Debug.Assert(LargestDivisor((10L)) == (5L));
    Debug.Assert(LargestDivisor((100L)) == (50L));
    Debug.Assert(LargestDivisor((49L)) == (7L));
    }

}
"
HumanEval_25,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇನ್ಪುಟ್ ಸಂಖ್ಯೆ ಎಲ್ಲಾ ಅಂಶಗಳ ಉತ್ಪನ್ನಕ್ಕೆ ಸಮಾನವಾಗಿರಬೇಕು     //ಪ್ರತಿಯೊಂದು ಅಂಶವನ್ನು ಎಷ್ಟು ಬಾರಿ ಅಂಶೀಕರಣದಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತದೆ ಎಂಬುದಕ್ಕೆ ಅನುಗುಣವಾಗಿ ಪಟ್ಟಿ ಮಾಡಬೇಕು.    //ಕೊಟ್ಟಿರುವ ಪೂರ್ಣಾಂಕದ ಅವಿಭಾಜ್ಯ ಅಂಶಗಳ ಪಟ್ಟಿಯನ್ನು ಚಿಕ್ಕದರಿಂದ ದೊಡ್ಡದರವರೆಗೆ ಕ್ರಮದಲ್ಲಿ ಹಿಂತಿರುಗಿ.    // >>> Factorize((8L))
    // (new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))
    // >>> Factorize((25L))
    // (new List<long>(new long[]{(long)5L, (long)5L}))
    // >>> Factorize((70L))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)7L}))
    public static List<long> Factorize(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Factorize(long n) {
        List<long> factors = new List<long>();
        for (long i = 2; i * i <= n; i++) {
            while (n % i == 0) {
                factors.Add(i);
                n /= i;
            }
        }
        if (n > 1) {
            factors.Add(n);
        }
        return factors;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Factorize((2L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Factorize((4L)).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Factorize((8L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))));
    Debug.Assert(Factorize((57L)).Equals((new List<long>(new long[]{(long)3L, (long)19L}))));
    Debug.Assert(Factorize((3249L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((185193L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((20577L)).Equals((new List<long>(new long[]{(long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_26,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇನ್ಪುಟ್ನಲ್ಲಿರುವಂತೆ ಎಡಭಾಗದ ಅಂಶಗಳ ಕ್ರಮವನ್ನು ಇಟ್ಟುಕೊಳ್ಳಿ.    //ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯಿಂದ, ಒಂದಕ್ಕಿಂತ ಹೆಚ್ಚು ಬಾರಿ ಸಂಭವಿಸುವ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ತೆಗೆದುಹಾಕಿ.    // >>> RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)4L}))
    public static List<long> RemoveDuplicates(List<long> numbers) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    // From a list of integers, remove all elements that occur more than once.
    // Keep order of elements left the same as in the input.
    public static List<long> RemoveDuplicates(List<long> numbers)
    {
        var elementCount = numbers.GroupBy(n => n)
                                  .ToDictionary(g => g.Key, g => g.Count());

        return numbers.Where(n => elementCount[n] == 1).ToList();
    }

    static void Main(string[] args)
    {
        List<long> numbers = new List<long> { 1, 2, 3, 2, 4 };
        List<long> result = RemoveDuplicates(numbers);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveDuplicates((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L, (long)3L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)5L}))));
    }

}
"
HumanEval_27,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ನಿರ್ದಿಷ್ಟ ಸ್ಟ್ರಿಂಗ್ಗಾಗಿ, ಸಣ್ಣ ಅಕ್ಷರಗಳನ್ನು ದೊಡ್ಡಕ್ಷರಕ್ಕೆ ಮತ್ತು ದೊಡ್ಡಕ್ಷರವನ್ನು ಸಣ್ಣಕ್ಷರಕ್ಕೆ ತಿರುಗಿಸಿ.    // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
","using System;

class Problem {
    // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
        char[] chars = str.ToCharArray();
        for (int i = 0; i < chars.Length; i++) {
            if (char.IsUpper(chars[i])) {
                chars[i] = char.ToLower(chars[i]);
            } else if (char.IsLower(chars[i])) {
                chars[i] = char.ToUpper(chars[i]);
            }
        }
        return new string(chars);
    }
    
    static void Main(string[] args) {
        Console.WriteLine(FlipCase(""Hello"")); // Output should be ""hELLO""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FlipCase(("""")).Equals(("""")));
    Debug.Assert(FlipCase((""Hello!"")).Equals((""hELLO!"")));
    Debug.Assert(FlipCase((""These violent delights have violent ends"")).Equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯನ್ನು ಒಂದೇ ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಜೋಡಿಸಿ    // >>> Concatenate((new List<string>()))
    // ("""")
    // >>> Concatenate((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""abc"")
    public static string Concatenate(List<string> strings) {
","return string.Concat(strings);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Concatenate((new List<string>())).Equals(("""")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""xyz"")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z"", (string)""w"", (string)""k""}))).Equals((""xyzwk"")));
    }

}
"
HumanEval_29,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ನಿರ್ದಿಷ್ಟ ಪೂರ್ವಪ್ರತ್ಯಯದೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುವ ಸ್ಟ್ರಿಂಗ್ಗಳ ಇನ್ಪುಟ್ ಪಟ್ಟಿಯನ್ನು ಮಾತ್ರ ಫಿಲ್ಟರ್ ಮಾಡಿ.    // >>> FilterByPrefix((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterByPrefix((new List<string>(new string[]{(string)""abc"", (string)""bcd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""array""}))
    public static List<string> FilterByPrefix(List<string> strings, string prefix) {
","return strings.Where(s => s.StartsWith(prefix)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterByPrefix((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterByPrefix((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    }

}
"
HumanEval_30,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸಕಾರಾತ್ಮಕ ಸಂಖ್ಯೆಗಳನ್ನು ಮಾತ್ರ ಹಿಂತಿರುಗಿ.    // >>> GetPositive((new List<long>(new long[]{(long)-1L, (long)2L, (long)-4L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)6L}))
    // >>> GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)9L, (long)123L, (long)1L}))
    public static List<long> GetPositive(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetPositive(List<long> l)
    {
        List<long> positiveNumbers = new List<long>();
        foreach (long number in l)
        {
            if (number > 0)
            {
                positiveNumbers.Add(number);
            }
        }
        return positiveNumbers;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L, (long)4L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)4L, (long)5L, (long)6L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)3L, (long)9L, (long)123L, (long)1L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L}))).Equals((new List<long>())));
    Debug.Assert(GetPositive((new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_31,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಕೊಟ್ಟಿರುವ ಸಂಖ್ಯೆಯು ಅವಿಭಾಜ್ಯವಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿ, ಇಲ್ಲದಿದ್ದರೆ false ಅನ್ನು ಹಿಂತಿರುಗಿ.    // >>> IsPrime((6L))
    // (false)
    // >>> IsPrime((101L))
    // (true)
    // >>> IsPrime((11L))
    // (true)
    // >>> IsPrime((13441L))
    // (true)
    // >>> IsPrime((61L))
    // (true)
    // >>> IsPrime((4L))
    // (false)
    // >>> IsPrime((1L))
    // (false)
    public static bool IsPrime(long n) {
","public static bool IsPrime(long n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPrime((6L)) == (false));
    Debug.Assert(IsPrime((101L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((13441L)) == (true));
    Debug.Assert(IsPrime((61L)) == (true));
    Debug.Assert(IsPrime((4L)) == (false));
    Debug.Assert(IsPrime((1L)) == (false));
    Debug.Assert(IsPrime((5L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((17L)) == (true));
    Debug.Assert(IsPrime((85L)) == (false));
    Debug.Assert(IsPrime((77L)) == (false));
    Debug.Assert(IsPrime((255379L)) == (false));
    }

}
"
HumanEval_33,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //l ನ ಅನುಗುಣವಾದ ಸೂಚ್ಯಂಕಗಳ ಮೌಲ್ಯಗಳಿಗೆ, ಆದರೆ ವಿಂಗಡಿಸಲಾಗಿದೆ.    //l' ಮೂರು ಭಾಗಿಸಬಹುದಾದ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ l ಗೆ ಒಂದೇ ಆಗಿರುತ್ತದೆ, ಆದರೆ ಮೂರು ಭಾಗಿಸಬಹುದಾದ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ ಅದರ ಮೌಲ್ಯಗಳು ಸಮಾನವಾಗಿರುತ್ತದೆ     //ಈ ಕಾರ್ಯವು ಒಂದು ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ ಮತ್ತು ಒಂದು ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ l ' ಅಂತಹ     // >>> SortThird((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))
    public static List<long> SortThird(List<long> l) {
","public static List<long> SortThird(List<long> l) {
        List<long> sortedValues = new List<long>();

        // Collect values at indices divisible by three
        for (int i = 0; i < l.Count; i++) {
            if (i % 3 == 0) {
                sortedValues.Add(l[i]);
            }
        }

        // Sort the collected values
        sortedValues.Sort();

        // Place sorted values back into their positions
        int sortedIndex = 0;
        List<long> result = new List<long>(l);
        for (int i = 0; i < result.Count; i++) {
            if (i % 3 == 0) {
                result[i] = sortedValues[sortedIndex++];
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L, (long)1L}))));
    }

}
"
HumanEval_34,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿ ವಿಂಗಡಿಸಲಾದ ಅನನ್ಯ ಅಂಶಗಳನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ    // >>> Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))
    public static List<long> Unique(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return sorted unique elements in a list
    public static List<long> Unique(List<long> l) {
        HashSet<long> uniqueSet = new HashSet<long>(l);
        List<long> uniqueList = new List<long>(uniqueSet);
        uniqueList.Sort();
        return uniqueList;
    }
    
    static void Main(string[] args) {
        List<long> input = new List<long>{5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L};
        List<long> result = Unique(input);
        Console.WriteLine(string.Join("", "", result)); // Output: 0, 2, 3, 5, 9, 123
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))));
    }

}
"
HumanEval_35,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪಟ್ಟಿಯಲ್ಲಿನ ಗರಿಷ್ಠ ಅಂಶವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    // >>> MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (3L)
    // >>> MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (123L)
    public static long MaxElement(List<long> l) {
","return l.Max();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (3L));
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)124L, (long)1L, (long)-10L}))) == (124L));
    }

}
"
HumanEval_36,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //11 ಅಥವಾ 13 ರ ಮೂಲಕ ಭಾಗಿಸಬಹುದಾದ n ಗಿಂತ ಕಡಿಮೆ ಪೂರ್ಣಾಂಕಗಳಲ್ಲಿ 7 ಅಂಕಿಯು ಕಾಣಿಸಿಕೊಳ್ಳುವ ಬಾರಿ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
        long count = 0;
        for (long i = 1; i < n; i++) {
            if (i % 11 == 0 || i % 13 == 0) {
                count += CountSevens(i);
            }
        }
        return count;
    }

    private static int CountSevens(long num) {
        int count = 0;
        while (num > 0) {
            if (num % 10 == 7) {
                count++;
            }
            num /= 10;
        }
        return count;
    }

    // You can test the function with the following main method:
    static void Main(string[] args) {
        Console.WriteLine(FizzBuzz(50));  // Output: 0
        Console.WriteLine(FizzBuzz(78));  // Output: 2
        Console.WriteLine(FizzBuzz(79));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FizzBuzz((50L)) == (0L));
    Debug.Assert(FizzBuzz((78L)) == (2L));
    Debug.Assert(FizzBuzz((79L)) == (3L));
    Debug.Assert(FizzBuzz((100L)) == (3L));
    Debug.Assert(FizzBuzz((200L)) == (6L));
    Debug.Assert(FizzBuzz((4000L)) == (192L));
    Debug.Assert(FizzBuzz((10000L)) == (639L));
    Debug.Assert(FizzBuzz((100000L)) == (8026L));
    }

}
"
HumanEval_37,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //l ನ ಸಮ ಸೂಚ್ಯಂಕಗಳ ಮೌಲ್ಯಗಳಿಗೆ, ಆದರೆ ವಿಂಗಡಿಸಲಾಗಿದೆ.    //l' ಅಪರೂಪದ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ l ಗೆ ಒಂದೇ ಆಗಿರುತ್ತದೆ, ಆದರೆ ಸಮ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ ಅದರ ಮೌಲ್ಯಗಳು ಸಮಾನವಾಗಿರುತ್ತದೆ     //ಈ ಕಾರ್ಯವು ಒಂದು ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ ಮತ್ತು ಒಂದು ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ l ' ಅಂತಹ     // >>> SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortEven((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)3L, (long)6L, (long)5L, (long)4L}))
    public static List<long> SortEven(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // This function takes a list l and returns a list l' such that
    // l' is identical to l in the odd indices, while its values at the even indices are equal
    // to the values of the even indices of l, but sorted.
    public static List<long> SortEven(List<long> l) {
        List<long> evenIndicesValues = new List<long>();

        // Collect values from even indices
        for (int i = 0; i < l.Count; i += 2) {
            evenIndicesValues.Add(l[i]);
        }

        // Sort the collected even index values
        evenIndicesValues.Sort();

        // Reconstruct the list with sorted values at even indices
        List<long> result = new List<long>(l);

        for (int i = 0, j = 0; i < result.Count; i += 2, j++) {
            result[i] = evenIndicesValues[j];
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-10L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)5L, (long)0L, (long)9L, (long)1L, (long)123L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)8L, (long)-12L, (long)4L, (long)23L, (long)2L, (long)3L, (long)11L, (long)12L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-12L, (long)8L, (long)3L, (long)4L, (long)5L, (long)2L, (long)12L, (long)11L, (long)23L, (long)-10L}))));
    }

}
"
HumanEval_39,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //prime_fib ಒಂದು ಫೈಬೊನಾಕಿ ಸಂಖ್ಯೆಯಾಗಿರುವ n-ನೇ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ ಮತ್ತು ಅದು ಸಹ ಅವಿಭಾಜ್ಯವಾಗಿರುತ್ತದೆ.    // >>> PrimeFib((1L))
    // (2L)
    // >>> PrimeFib((2L))
    // (3L)
    // >>> PrimeFib((3L))
    // (5L)
    // >>> PrimeFib((4L))
    // (13L)
    // >>> PrimeFib((5L))
    // (89L)
    public static long PrimeFib(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Method to check if a number is prime
    public static bool IsPrime(long num)
    {
        if (num <= 1) return false;
        if (num == 2) return true;
        if (num % 2 == 0) return false;

        long boundary = (long)Math.Floor(Math.Sqrt(num));

        for (long i = 3; i <= boundary; i += 2)
        {
            if (num % i == 0)
                return false;
        }

        return true;
    }

    // Method to generate Fibonacci numbers and find the n-th prime Fibonacci
    public static long PrimeFib(long n)
    {
        long a = 1, b = 1;
        long primeFibCount = 0;

        while (true)
        {
            long temp = a;
            a = b;
            b = temp + b;

            if (IsPrime(a))
            {
                primeFibCount++;
                if (primeFibCount == n)
                {
                    return a;
                }
            }
        }
    }

    static void Main(string[] args)
    {
        Console.WriteLine(PrimeFib(1)); // Output: 2
        Console.WriteLine(PrimeFib(2)); // Output: 3
        Console.WriteLine(PrimeFib(3)); // Output: 5
        Console.WriteLine(PrimeFib(4)); // Output: 13
        Console.WriteLine(PrimeFib(5)); // Output: 89
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeFib((1L)) == (2L));
    Debug.Assert(PrimeFib((2L)) == (3L));
    Debug.Assert(PrimeFib((3L)) == (5L));
    Debug.Assert(PrimeFib((4L)) == (13L));
    Debug.Assert(PrimeFib((5L)) == (89L));
    Debug.Assert(PrimeFib((6L)) == (233L));
    Debug.Assert(PrimeFib((7L)) == (1597L));
    Debug.Assert(PrimeFib((8L)) == (28657L));
    Debug.Assert(PrimeFib((9L)) == (514229L));
    Debug.Assert(PrimeFib((10L)) == (433494437L));
    }

}
"
HumanEval_40,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಮೊತ್ತವು ಶೂನ್ಯಕ್ಕೆ, ಮತ್ತು ಸುಳ್ಳು ಇಲ್ಲದಿದ್ದರೆ.    //ಇದು  ಎಂದು ಪಟ್ಟಿಯಲ್ಲಿ ಮೂರು ವಿಭಿನ್ನ ಅಂಶಗಳು ಇದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ    //triples_sum_to_zero ಒಂದು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ.    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool TriplesSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool TriplesSumToZero(List<long> l)
    {
        if (l.Count < 3)
            return false;

        l.Sort();

        for (int i = 0; i < l.Count - 2; i++)
        {
            if (i > 0 && l[i] == l[i - 1])
                continue;

            int left = i + 1;
            int right = l.Count - 1;

            while (left < right)
            {
                long sum = l[i] + l[left] + l[right];
                if (sum == 0)
                    return true;
                else if (sum < 0)
                    left++;
                else
                    right--;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)5L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-100L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)100L, (long)3L, (long)5L, (long)-100L}))) == (false));
    }

}
"
HumanEval_41,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಈ ಕಾರ್ಯವು ಇಂತಹ ಘರ್ಷಣೆಗಳ ಸಂಖ್ಯೆಯನ್ನು ಔಟ್ಪುಟ್ ಮಾಡುತ್ತದೆ.    //ಅವುಗಳ ಪಥದಲ್ಲಿ ಅವು ಘರ್ಷಣೆ ಮಾಡದಿದ್ದಂತೆ.    //ಆದರೆ, ಈ ಕಾರುಗಳು ಅಪಾರವಾದ ಬಲವನ್ನು ಹೊಂದಿವೆ; ಇದರ ಪರಿಣಾಮವಾಗಿ, ಅವು ಚಲಿಸುತ್ತಲೇ ಇರುತ್ತವೆ.    //ಎಡದಿಂದ ಬಲಕ್ಕೆ ಚಲಿಸುವ ಕಾರು ಬಲದಿಂದ ಎಡಕ್ಕೆ ಚಲಿಸುವ ಕಾರು ಹೊಡೆದಾಗ.    //ಎಲ್ಲಾ ಕಾರುಗಳು ಒಂದೇ ವೇಗದಲ್ಲಿ ಚಲಿಸುತ್ತವೆ. ಎರಡು ಕಾರುಗಳು ಘರ್ಷಣೆಗೊಳ್ಳುತ್ತವೆ ಎಂದು ಹೇಳಲಾಗುತ್ತದೆ.    //ಎಡದಿಂದ ಬಲಕ್ಕೆ ಚಲಿಸುತ್ತಿದೆ. ಎರಡು ಕಾರುಗಳ ಜೋಡಿಗಳು ಪ್ರಾರಂಭವಾಗುವುದು     //n ಕಾರುಗಳು ಎಡದಿಂದ ಬಲಕ್ಕೆ ಚಲಿಸುತ್ತಿವೆ; ಏಕಕಾಲದಲ್ಲಿ, n ಕಾರುಗಳ ವಿಭಿನ್ನ ಸೆಟ್     //ಒಂದು ರಸ್ತೆಯನ್ನು ಕಲ್ಪಿಸಿಕೊಳ್ಳಿ ಅದು ಪರಿಪೂರ್ಣವಾದ ನೇರ ಅನಂತ ಉದ್ದದ ರೇಖೆಯಾಗಿದೆ.    public static long CarRaceCollision(long n) {
","// Each car moving left to right will collide with each car moving right to left.
        // So the total number of collisions is n * n.
        return n * n;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CarRaceCollision(5));  // Example usage
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CarRaceCollision((2L)) == (4L));
    Debug.Assert(CarRaceCollision((3L)) == (9L));
    Debug.Assert(CarRaceCollision((4L)) == (16L));
    Debug.Assert(CarRaceCollision((8L)) == (64L));
    Debug.Assert(CarRaceCollision((10L)) == (100L));
    }

}
"
HumanEval_42,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //1 ರಷ್ಟು ಹೆಚ್ಚಿಸಿದ ಅಂಶಗಳೊಂದಿಗೆ ರಿಟರ್ನ್ ಪಟ್ಟಿ.    // >>> IncrList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))
    // >>> IncrList((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)6L, (long)4L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))
    public static List<long> IncrList(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list with elements incremented by 1.
    public static List<long> IncrList(List<long> l) {
        return l.Select(x => x + 1).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IncrList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)3L, (long)2L}))));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)5L, (long)2L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)6L, (long)3L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))));
    }

}
"
HumanEval_43,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಮೊತ್ತವು ಶೂನ್ಯಕ್ಕೆ, ಮತ್ತು ಸುಳ್ಳು ಇಲ್ಲದಿದ್ದರೆ.    //ಇದು  ಎಂದು ಪಟ್ಟಿಯಲ್ಲಿ ಎರಡು ವಿಭಿನ್ನ ಅಂಶಗಳು ಇದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ    //pairs_sum_to_zero ಒಂದು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ.    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L})))
    // (true)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool PairsSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool PairsSumToZero(List<long> l)
    {
        HashSet<long> seenNumbers = new HashSet<long>();

        foreach (long number in l)
        {
            if (seenNumbers.Contains(-number))
            {
                return true;
            }
            seenNumbers.Add(number);
        }

        return false;
    }

    public static void Main(string[] args)
    {
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, 5L, 0L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, -2L, 1L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 2L, 3L, 7L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 2L, 4L, -5L, 3L, 5L, 7L })); // true
        Console.WriteLine(PairsSumToZero(new List<long> { 1L })); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)30L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)31L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)30L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)31L}))) == (false));
    }

}
"
HumanEval_44,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಮೂಲ ಸಂಖ್ಯೆಗಳು 10 ಕ್ಕಿಂತ ಕಡಿಮೆ.    //ಪರಿವರ್ತನೆಯ ನಂತರ ಸ್ಟ್ರಿಂಗ್ ಪ್ರಾತಿನಿಧ್ಯವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಇನ್ಪುಟ್ ಸಂಖ್ಯೆಯ x ನ ಸಂಖ್ಯಾ ಆಧಾರವನ್ನು ಆಧಾರಕ್ಕೆ ಬದಲಾಯಿಸಿ.    // >>> ChangeBase((8L), (3L))
    // (""22"")
    // >>> ChangeBase((8L), (2L))
    // (""1000"")
    // >>> ChangeBase((7L), (2L))
    // (""111"")
    public static string ChangeBase(long x, long numBase) {
","using System;
using System.Collections.Generic;

class Problem {
    // Change numerical base of input number x to base.
    // return string representation after the conversion.
    // base numbers are less than 10.
    public static string ChangeBase(long x, long numBase) {
        if (numBase < 2 || numBase > 9) 
            throw new ArgumentException(""Base must be between 2 and 9."");

        if (x < 0) 
            throw new ArgumentException(""Number must be non-negative."");

        if (x == 0) 
            return ""0"";

        string result = string.Empty;
        while (x > 0) {
            long remainder = x % numBase;
            result = remainder + result;
            x /= numBase;
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChangeBase((8L), (3L)).Equals((""22"")));
    Debug.Assert(ChangeBase((9L), (3L)).Equals((""100"")));
    Debug.Assert(ChangeBase((234L), (2L)).Equals((""11101010"")));
    Debug.Assert(ChangeBase((16L), (2L)).Equals((""10000"")));
    Debug.Assert(ChangeBase((8L), (2L)).Equals((""1000"")));
    Debug.Assert(ChangeBase((7L), (2L)).Equals((""111"")));
    Debug.Assert(ChangeBase((2L), (3L)).Equals((""2"")));
    Debug.Assert(ChangeBase((3L), (4L)).Equals((""3"")));
    Debug.Assert(ChangeBase((4L), (5L)).Equals((""4"")));
    Debug.Assert(ChangeBase((5L), (6L)).Equals((""5"")));
    Debug.Assert(ChangeBase((6L), (7L)).Equals((""6"")));
    Debug.Assert(ChangeBase((7L), (8L)).Equals((""7"")));
    }

}
"
HumanEval_45,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಒಂದು ತ್ರಿಕೋನಕ್ಕೆ ಒಂದು ಬದಿಯ ಉದ್ದ ಮತ್ತು ಹೆಚ್ಚಿನ ರಿಟರ್ನ್ ಪ್ರದೇಶವನ್ನು ನೀಡಲಾಗಿದೆ.    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
","using System;

class Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
        return (a * h) / 2.0f;
    }

    static void Main(string[] args) {
        Console.WriteLine(TriangleArea(5L, 3L)); // Output: 7.5
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((5L), (3L)) == (7.5f));
    Debug.Assert(TriangleArea((2L), (2L)) == (2.0f));
    Debug.Assert(TriangleArea((10L), (8L)) == (40.0f));
    }

}
"
HumanEval_46,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //fib4 ಸಂಖ್ಯೆಗಳ ಅನುಕ್ರಮದ n-ನೇ ಅಂಶವನ್ನು ಸಮರ್ಥವಾಗಿ ಲೆಕ್ಕಾಚಾರ ಮಾಡಲು ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ. ಪುನರಾವರ್ತನೆಯನ್ನು ಬಳಸಬೇಡಿ.    //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     //fib4(3) -> 0     //fib4(2) -> 2     //fib4(1) -> 0     //fib4(0) -> 0     //Fib4 ಸಂಖ್ಯೆಯ ಅನುಕ್ರಮವು ಫೈಬೊನಾಕಿ ಅನುಕ್ರಮಕ್ಕೆ ಹೋಲುತ್ತದೆ, ಇದನ್ನು ಈ ಕೆಳಗಿನಂತೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆ:    // >>> Fib4((5L))
    // (4L)
    // >>> Fib4((6L))
    // (8L)
    // >>> Fib4((7L))
    // (14L)
    public static long Fib4(long n) {
","public static long Fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    long[] fib4Seq = new long[n + 1];
    fib4Seq[0] = 0;
    fib4Seq[1] = 0;
    fib4Seq[2] = 2;
    fib4Seq[3] = 0;

    for (long i = 4; i <= n; i++) {
        fib4Seq[i] = fib4Seq[i - 1] + fib4Seq[i - 2] + fib4Seq[i - 3] + fib4Seq[i - 4];
    }

    return fib4Seq[n];
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib4((5L)) == (4L));
    Debug.Assert(Fib4((8L)) == (28L));
    Debug.Assert(Fib4((10L)) == (104L));
    Debug.Assert(Fib4((12L)) == (386L));
    }

}
"
HumanEval_47,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪಟ್ಟಿಯಲ್ಲಿನ ಅಂಶಗಳ ಮಧ್ಯಮವನ್ನು ಹಿಂತಿರುಗಿ l.     // >>> Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (float)3L
    // >>> Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L})))
    // (15.0f)
    public static float Median(List<long> l) {
","public static float Median(List<long> l) {
        l.Sort();
        int count = l.Count;
        if (count % 2 == 1) {
            return (float)l[count / 2];
        } else {
            long mid1 = l[(count / 2) - 1];
            long mid2 = l[count / 2];
            return (mid1 + mid2) / 2.0f;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) == (float)3L);
    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));
    Debug.Assert(Median((new List<long>(new long[]{(long)5L}))) == (float)5L);
    Debug.Assert(Median((new List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));
    Debug.Assert(Median((new List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L, (long)7L}))) == (float)7L);
    }

}
"
HumanEval_48,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಕೊಟ್ಟಿರುವ ಸ್ಟ್ರಿಂಗ್ ಪಾಲಿಂಡ್ರೋಮ್ ಆಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸುತ್ತದೆ     // >>> IsPalindrome((""""))
    // (true)
    // >>> IsPalindrome((""aba""))
    // (true)
    // >>> IsPalindrome((""aaaaa""))
    // (true)
    // >>> IsPalindrome((""zbcd""))
    // (false)
    public static bool IsPalindrome(string text) {
","public static bool IsPalindrome(string text) {
    if (string.IsNullOrEmpty(text))
        return true;

    int left = 0;
    int right = text.Length - 1;

    while (left < right) {
        if (text[left] != text[right])
            return false;
        left++;
        right--;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPalindrome(("""")) == (true));
    Debug.Assert(IsPalindrome((""aba"")) == (true));
    Debug.Assert(IsPalindrome((""aaaaa"")) == (true));
    Debug.Assert(IsPalindrome((""zbcd"")) == (false));
    Debug.Assert(IsPalindrome((""xywyx"")) == (true));
    Debug.Assert(IsPalindrome((""xywyz"")) == (false));
    Debug.Assert(IsPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //2^n modulo p ಅನ್ನು ಹಿಂತಿರುಗಿ (ಸಂಖ್ಯೆಗಳ ಬಗ್ಗೆ ತಿಳಿದಿರಲಿ).    // >>> Modp((3L), (5L))
    // (3L)
    // >>> Modp((1101L), (101L))
    // (2L)
    // >>> Modp((0L), (101L))
    // (1L)
    // >>> Modp((3L), (11L))
    // (8L)
    // >>> Modp((100L), (101L))
    // (1L)
    public static long Modp(long n, long p) {
","using System;
using System.Numerics;

class Problem {
    public static long Modp(long n, long p) {
        // Using the property of modular arithmetic: (a^b) % c = ((a % c)^b) % c
        // We are calculating (2^n) % p
        BigInteger baseNum = 2;
        BigInteger result = BigInteger.ModPow(baseNum, n, p);
        return (long)result;
    }

    static void Main(string[] args) {
        Console.WriteLine(Modp(3L, 5L));   // (3L)
        Console.WriteLine(Modp(1101L, 101L)); // (2L)
        Console.WriteLine(Modp(0L, 101L));   // (1L)
        Console.WriteLine(Modp(3L, 11L));   // (8L)
        Console.WriteLine(Modp(100L, 101L));  // (1L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Modp((3L), (5L)) == (3L));
    Debug.Assert(Modp((1101L), (101L)) == (2L));
    Debug.Assert(Modp((0L), (101L)) == (1L));
    Debug.Assert(Modp((3L), (11L)) == (8L));
    Debug.Assert(Modp((100L), (101L)) == (1L));
    Debug.Assert(Modp((30L), (5L)) == (4L));
    Debug.Assert(Modp((31L), (5L)) == (3L));
    }

}
"
HumanEval_51,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //remove_vowels ಎನ್ನುವುದು ಸ್ವರಗಳಿಲ್ಲದ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವಾಗಿದೆ.    // >>> RemoveVowels((""""))
    // ("""")
    // >>> RemoveVowels((""abcdef""))
    // (""bcdf"")
    // >>> RemoveVowels((""aaaaa""))
    // ("""")
    // >>> RemoveVowels((""aaBAA""))
    // (""B"")
    // >>> RemoveVowels((""zbcd""))
    // (""zbcd"")
    public static string RemoveVowels(string text) {
","HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        StringBuilder result = new StringBuilder();

        foreach (char c in text) {
            if (!vowels.Contains(c)) {
                result.Append(c);
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveVowels(("""")).Equals(("""")));
    Debug.Assert(RemoveVowels((""abcdef\nghijklm"")).Equals((""bcdf\nghjklm"")));
    Debug.Assert(RemoveVowels((""fedcba"")).Equals((""fdcb"")));
    Debug.Assert(RemoveVowels((""eeeee"")).Equals(("""")));
    Debug.Assert(RemoveVowels((""acBAA"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""EcBOO"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""ybcd"")).Equals((""ybcd"")));
    }

}
"
HumanEval_52,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪಟ್ಟಿಯಲ್ಲಿನ ಎಲ್ಲಾ ಸಂಖ್ಯೆಗಳು ಮಿತಿ t ಗಿಂತ ಕೆಳಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L))
    // (true)
    // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L))
    // (false)
    public static bool BelowThreshold(List<long> l, long t) {
","return l.All(x => x < t);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L)) == (false));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (21L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (22L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (11L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (10L)) == (false));
    }

}
"
HumanEval_53,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //x ಮತ್ತು y ಎಂಬ ಎರಡು ಸಂಖ್ಯೆಗಳನ್ನು ಸೇರಿಸಿ.    // >>> Add((2L), (3L))
    // (5L)
    // >>> Add((5L), (7L))
    // (12L)
    public static long Add(long x, long y) {
","return x + y;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((0L), (1L)) == (1L));
    Debug.Assert(Add((1L), (0L)) == (1L));
    Debug.Assert(Add((2L), (3L)) == (5L));
    Debug.Assert(Add((5L), (7L)) == (12L));
    Debug.Assert(Add((7L), (5L)) == (12L));
    }

}
"
HumanEval_54,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಎರಡು ಪದಗಳು ಒಂದೇ ಅಕ್ಷರಗಳನ್ನು ಹೊಂದಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ.    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> SameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> SameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> SameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> SameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    public static bool SameChars(string s0, string s1) {
","public static bool SameChars(string s0, string s1) {
        // Return true if s1 contains all characters of s0
        return s0.All(c => s1.Contains(c)) && s1.All(c => s0.Contains(c));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    Debug.Assert(SameChars((""abcd""), (""dddddddabc"")) == (true));
    Debug.Assert(SameChars((""dddddddabc""), (""abcd"")) == (true));
    Debug.Assert(SameChars((""eabcd""), (""dddddddabc"")) == (false));
    Debug.Assert(SameChars((""abcd""), (""dddddddabcf"")) == (false));
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    Debug.Assert(SameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //n-ನೇ ಫಿಬೊನಾಕಿ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂತಿರುಗಿ.     // >>> Fib((10L))
    // (55L)
    // >>> Fib((1L))
    // (1L)
    // >>> Fib((8L))
    // (21L)
    public static long Fib(long n) {
","if (n <= 0) return 0;
    if (n == 1) return 1;

    long a = 0;
    long b = 1;

    for (long i = 2; i <= n; i++)
    {
        long temp = a + b;
        a = b;
        b = temp;
    }

    return b;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib((10L)) == (55L));
    Debug.Assert(Fib((1L)) == (1L));
    Debug.Assert(Fib((8L)) == (21L));
    Debug.Assert(Fib((11L)) == (89L));
    Debug.Assert(Fib((12L)) == (144L));
    }

}
"
HumanEval_56,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪ್ರತಿ ಆರಂಭಿಕ ಬ್ರಾಕೆಟ್ಗೆ ಅನುಗುಣವಾದ ಮುಚ್ಚುವ ಬ್ರಾಕೆಟ್ ಇದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಬ್ರಾಕೆಟ್ಸ್ ""<"" ಮತ್ತು "">"" ನ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.    // >>> CorrectBracketing((""<""))
    // (false)
    // >>> CorrectBracketing((""<>""))
    // (true)
    // >>> CorrectBracketing((""<<><>>""))
    // (true)
    // >>> CorrectBracketing((""><<>""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","public static bool CorrectBracketing(string brackets) 
{
    int balance = 0;
    foreach (char c in brackets) 
    {
        if (c == '<') 
        {
            balance++;
        } 
        else if (c == '>') 
        {
            balance--;
        }
        
        if (balance < 0) 
        {
            return false;
        }
    }

    return balance == 0;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""<>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<><>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<><>><>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<<><>>>>"")) == (false));
    Debug.Assert(CorrectBracketing((""><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<"")) == (false));
    Debug.Assert(CorrectBracketing((""<<<<"")) == (false));
    Debug.Assert(CorrectBracketing(("">"")) == (false));
    Debug.Assert(CorrectBracketing((""<<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    // ಪಟ್ಟಿ ಅಂಶಗಳು ಏಕತಾನತೆಯಿಂದ ಹೆಚ್ಚುತ್ತಿವೆ ಅಥವಾ ಕಡಿಮೆಯಾಗುತ್ತಿವೆ ಎಂದು ನಿಜವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L})))
    // (true)
    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})))
    // (false)
    // >>> Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L})))
    // (true)
    public static bool Monotonic(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return true if list elements are monotonically increasing or decreasing.
    public static bool Monotonic(List<long> l) {
        if (l.Count < 2) return true; // Lists with less than 2 elements are trivially monotonic.
        
        bool increasing = true;
        bool decreasing = true;

        for (int i = 1; i < l.Count; i++) {
            if (l[i] > l[i - 1]) {
                decreasing = false;
            } else if (l[i] < l[i - 1]) {
                increasing = false;
            }

            // If both flags are false, the list is not monotonic.
            if (!increasing && !decreasing) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)5L, (long)60L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)60L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)9L, (long)9L, (long)9L, (long)9L}))) == (true));
    }

}
"
HumanEval_58,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಎರಡು ಪಟ್ಟಿಗಳ ವಿಂಗಡಿಸಲಾದ ವಿಶಿಷ್ಟ ಸಾಮಾನ್ಯ ಅಂಶಗಳನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    // >>> Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L})))
    // (new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))
    // >>> Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    public static List<long> Common(List<long> l1, List<long> l2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> Common(List<long> l1, List<long> l2)
    {
        // Use HashSet to store unique elements of l1
        var set1 = new HashSet<long>(l1);

        // Use HashSet to store unique elements of l2 and filter common elements
        var commonSet = new HashSet<long>(l2.Where(x => set1.Contains(x)));

        // Convert to a list, sort it and return
        var result = commonSet.ToList();
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_59,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //n ನ ಅತಿದೊಡ್ಡ ಅವಿಭಾಜ್ಯ ಅಂಶವನ್ನು ಹಿಂತಿರುಗಿ. n > 1 ಮತ್ತು ಅವಿಭಾಜ್ಯವಲ್ಲ ಎಂದು ಭಾವಿಸಿ.     // >>> LargestPrimeFactor((13195L))
    // (29L)
    // >>> LargestPrimeFactor((2048L))
    // (2L)
    public static long LargestPrimeFactor(long n) {
","using System;

class Problem {
    public static long LargestPrimeFactor(long n) {
        long largestFactor = -1;
        
        // Remove the factor of 2
        while (n % 2 == 0) {
            largestFactor = 2;
            n /= 2;
        }

        // Check odd factors from 3 upwards
        for (long i = 3; i <= Math.Sqrt(n); i += 2) {
            while (n % i == 0) {
                largestFactor = i;
                n /= i;
            }
        }

        // If n becomes a prime number greater than 2
        if (n > 2) {
            largestFactor = n;
        }

        return largestFactor;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestPrimeFactor((15L)) == (5L));
    Debug.Assert(LargestPrimeFactor((27L)) == (3L));
    Debug.Assert(LargestPrimeFactor((63L)) == (7L));
    Debug.Assert(LargestPrimeFactor((330L)) == (11L));
    Debug.Assert(LargestPrimeFactor((13195L)) == (29L));
    }

}
"
HumanEval_60,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //sum_to_n ಎನ್ನುವುದು 1 ರಿಂದ n ವರೆಗಿನ ಸಂಖ್ಯೆಗಳನ್ನು ಒಟ್ಟುಗೂಡಿಸುವ ಒಂದು ಕಾರ್ಯವಾಗಿದೆ.    // >>> SumToN((30L))
    // (465L)
    // >>> SumToN((100L))
    // (5050L)
    // >>> SumToN((5L))
    // (15L)
    // >>> SumToN((10L))
    // (55L)
    // >>> SumToN((1L))
    // (1L)
    public static long SumToN(long n) {
","return n * (n + 1) / 2;
}
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumToN((1L)) == (1L));
    Debug.Assert(SumToN((6L)) == (21L));
    Debug.Assert(SumToN((11L)) == (66L));
    Debug.Assert(SumToN((30L)) == (465L));
    Debug.Assert(SumToN((100L)) == (5050L));
    }

}
"
HumanEval_61,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪ್ರತಿ ಆರಂಭಿಕ ಬ್ರಾಕೆಟ್ಗೆ ಅನುಗುಣವಾದ ಮುಚ್ಚುವ ಬ್ರಾಕೆಟ್ ಇದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಬ್ರಾಕೆಟ್ಗಳು ""("" ಮತ್ತು """") ಗಳ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಆಗಿದೆ.    // >>> CorrectBracketing((""(""))
    // (false)
    // >>> CorrectBracketing((""()""))
    // (true)
    // >>> CorrectBracketing((""(()())""))
    // (true)
    // >>> CorrectBracketing(("")(()""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","using System;

class Problem {
    public static bool CorrectBracketing(string brackets) {
        int balance = 0;
        foreach (char c in brackets) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false;
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""()"")) == (true));
    Debug.Assert(CorrectBracketing((""(()())"")) == (true));
    Debug.Assert(CorrectBracketing((""()()(()())()"")) == (true));
    Debug.Assert(CorrectBracketing((""()()((()()())())(()()(()))"")) == (true));
    Debug.Assert(CorrectBracketing((""((()())))"")) == (false));
    Debug.Assert(CorrectBracketing(("")(()"")) == (false));
    Debug.Assert(CorrectBracketing((""("")) == (false));
    Debug.Assert(CorrectBracketing((""(((("")) == (false));
    Debug.Assert(CorrectBracketing(("")"")) == (false));
    Debug.Assert(CorrectBracketing((""(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())())(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಈ ಬಹುಪದವಿಯ ವ್ಯುತ್ಪತ್ತಿಯನ್ನು ಅದೇ ರೂಪದಲ್ಲಿ ಹಿಂತಿರುಗಿ.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....     //xs ಬಹುಪದವಿಯ ಗುಣಾಂಕಗಳನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.    // >>> Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))
    // >>> Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)6L}))
    public static List<long> Derivative(List<long> xs) {
","public static List<long> Derivative(List<long> xs) {
        List<long> derivative = new List<long>();
        for (int i = 1; i < xs.Count; i++) {
            derivative.Add(xs[i] * i);
        }
        return derivative;
    }

    static void Main(string[] args) {
        List<long> poly1 = new List<long>{3L, 1L, 2L, 4L, 5L};
        List<long> result1 = Derivative(poly1);
        Console.WriteLine(string.Join("", "", result1));

        List<long> poly2 = new List<long>{1L, 2L, 3L};
        List<long> result2 = Derivative(poly2);
        Console.WriteLine(string.Join("", "", result2));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L, (long)0L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)0L, (long)16L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_63,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ದಯವಿಟ್ಟು fibfib ಸಂಖ್ಯೆಗಳ ಅನುಕ್ರಮದ n-ನೇ ಅಂಶವನ್ನು ಸಮರ್ಥವಾಗಿ ಲೆಕ್ಕಾಚಾರ ಮಾಡಲು ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ.    //fib fib (n) == fib fib (n-1) + fib fib (n-2) + fib (n-3) ಗಳು    //fib fib ((2) == 1     //            //fib fib ((0) == 0     //ಫೈಬ್ಫೈಬ್ ಸಂಖ್ಯೆಯ ಅನುಕ್ರಮವು ಫೈಬೊನಾಕಿ ಅನುಕ್ರಮಕ್ಕೆ ಹೋಲುತ್ತದೆ, ಇದನ್ನು ಈ ಕೆಳಗಿನಂತೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆ:    // >>> Fibfib((1L))
    // (0L)
    // >>> Fibfib((5L))
    // (4L)
    // >>> Fibfib((8L))
    // (24L)
    public static long Fibfib(long n) {
","public static long Fibfib(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 1;

    long a = 0, b = 0, c = 1;
    long result = 0;

    for (long i = 3; i <= n; i++) {
        result = a + b + c;
        a = b;
        b = c;
        c = result;
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fibfib((2L)) == (1L));
    Debug.Assert(Fibfib((1L)) == (0L));
    Debug.Assert(Fibfib((5L)) == (4L));
    Debug.Assert(Fibfib((8L)) == (24L));
    Debug.Assert(Fibfib((10L)) == (81L));
    Debug.Assert(Fibfib((12L)) == (274L));
    Debug.Assert(Fibfib((14L)) == (927L));
    }

}
"
HumanEval_64,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಸ್ವರ, ಆದರೆ ಅದು ಕೊಟ್ಟಿರುವ ಪದದ ಕೊನೆಯಲ್ಲಿ ಮಾತ್ರ.    //ಈ ಸಂದರ್ಭದಲ್ಲಿ ಸ್ವರಗಳು 'a', 'e', 'i', 'o', 'u'. ಇಲ್ಲಿ, 'y' ಕೂಡ ಒಂದು     //ಒಂದು ಪದವನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ಮತ್ತು ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಸ್ವರಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ.    // ಅನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ vowels_count    // >>> VowelsCount((""abcde""))
    // (2L)
    // >>> VowelsCount((""ACEDY""))
    // (3L)
    public static long VowelsCount(string s) {
","using System;

class Problem {
    public static long VowelsCount(string s) {
        if (s == null) return 0;

        s = s.ToLower();
        long count = 0;
        
        for (int i = 0; i < s.Length; i++) {
            char c = s[i];
            if (""aeiou"".Contains(c) || (c == 'y' && i == s.Length - 1)) {
                count++;
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(VowelsCount(""abcde""));  // Output: 2
        Console.WriteLine(VowelsCount(""ACEDY""));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(VowelsCount((""abcde"")) == (2L));
    Debug.Assert(VowelsCount((""Alone"")) == (3L));
    Debug.Assert(VowelsCount((""key"")) == (2L));
    Debug.Assert(VowelsCount((""bye"")) == (1L));
    Debug.Assert(VowelsCount((""keY"")) == (2L));
    Debug.Assert(VowelsCount((""bYe"")) == (1L));
    Debug.Assert(VowelsCount((""ACEDY"")) == (3L));
    }

}
"
HumanEval_65,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //shift > ಅಂಕಿಗಳ ಸಂಖ್ಯೆ, ಹಿಂದಿರುಗಿದ ಅಂಕಿಗಳನ್ನು ಹಿಮ್ಮುಖಗೊಳಿಸಿ.    //ಮತ್ತು ಫಲಿತಾಂಶವನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಪೂರ್ಣಾಂಕ x ನ ಅಂಕಿಗಳನ್ನು ವೃತ್ತಾಕಾರವಾಗಿ ಸರಿಸಿ, ಅಂಕಿಗಳನ್ನು ಬಲಕ್ಕೆ ಸರಿಸಿ     // >>> CircularShift((12L), (1L))
    // (""21"")
    // >>> CircularShift((12L), (2L))
    // (""12"")
    public static string CircularShift(long x, long shift) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Circular shift the digits of the integer x, shift the digits right by shift
    // and return the result as a string.
    // If shift > number of digits, return digits reversed.
    
    public static string CircularShift(long x, long shift) {
        string digits = x.ToString();
        int length = digits.Length;
        
        if (shift > length) {
            char[] reversedDigits = digits.ToCharArray();
            Array.Reverse(reversedDigits);
            return new string(reversedDigits);
        }

        shift = shift % length;  // Normalize shift
        string shiftedPart = digits.Substring(length - (int)shift);
        string remainingPart = digits.Substring(0, length - (int)shift);
        return shiftedPart + remainingPart;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CircularShift((100L), (2L)).Equals((""001"")));
    Debug.Assert(CircularShift((12L), (2L)).Equals((""12"")));
    Debug.Assert(CircularShift((97L), (8L)).Equals((""79"")));
    Debug.Assert(CircularShift((12L), (1L)).Equals((""21"")));
    Debug.Assert(CircularShift((11L), (101L)).Equals((""11"")));
    }

}
"
HumanEval_66,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ASCII ಸಂಕೇತಗಳು     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಮೇಲಿನ ಅಕ್ಷರಗಳ ಮೊತ್ತವನ್ನು ಮಾತ್ರ ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ'     //ಕಾರ್ಯ     // >>> Digitsum((""""))
    // (0L)
    // >>> Digitsum((""abAB""))
    // (131L)
    // >>> Digitsum((""abcCd""))
    // (67L)
    // >>> Digitsum((""helloE""))
    // (69L)
    // >>> Digitsum((""woArBld""))
    // (131L)
    // >>> Digitsum((""aAaaaXa""))
    // (153L)
    public static long Digitsum(string s) {
","public static long Digitsum(string s) {
    long sum = 0;
    foreach (char c in s) {
        if (char.IsUpper(c)) {
            sum += c; // Add ASCII value of the upper case letters.
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digitsum(("""")) == (0L));
    Debug.Assert(Digitsum((""abAB"")) == (131L));
    Debug.Assert(Digitsum((""abcCd"")) == (67L));
    Debug.Assert(Digitsum((""helloE"")) == (69L));
    Debug.Assert(Digitsum((""woArBld"")) == (131L));
    Debug.Assert(Digitsum((""aAaaaXa"")) == (153L));
    Debug.Assert(Digitsum(("" How are yOu?"")) == (151L));
    Debug.Assert(Digitsum((""You arE Very Smart"")) == (327L));
    }

}
"
HumanEval_67,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪಠ್ಯಕ್ಕಾಗಿ:     //ಬುಟ್ಟಿಯಲ್ಲಿರುವ ಹಣ್ಣುಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂತಿರುಗಿ.    //ಕಿತ್ತಳೆ ಮತ್ತು ಸೇಬುಗಳು ಮತ್ತು ಹಣ್ಣುಗಳ ಒಟ್ಟು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಪೂರ್ಣಾಂಕ     //ಸೇಬುಗಳು, ಕಿತ್ತಳೆಗಳು, ಮತ್ತು ಮಾಂಗೊ ಹಣ್ಣುಗಳು. ಒಟ್ಟು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗಿದೆ     //ಈ ಹಣ್ಣಿನ ಬುಟ್ಟಿಯಲ್ಲಿರುವ ಹಣ್ಣಿನ ಬುಟ್ಟಿಯಲ್ಲಿ ವಿತರಿಸಲಾಗುತ್ತದೆ .    //ಈ ಕಾರ್ಯದಲ್ಲಿ, ನಿಮಗೆ ಒಂದು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗುವುದು ಸೇಬುಗಳು ಮತ್ತು ಕಿತ್ತಳೆಗಳು     // >>> FruitDistribution((""5 apples and 6 oranges""), (19L))
    // (8L)
    // >>> FruitDistribution((""0 apples and 1 oranges""), (3L))
    // (2L)
    // >>> FruitDistribution((""2 apples and 3 oranges""), (100L))
    // (95L)
    // >>> FruitDistribution((""100 apples and 1 oranges""), (120L))
    // (19L)
    public static long FruitDistribution(string s, long n) {
","using System;

class Problem {
    public static long FruitDistribution(string s, long n) {
        var parts = s.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        long apples = long.Parse(parts[0]);
        long oranges = long.Parse(parts[3]);

        long totalApplesAndOranges = apples + oranges;
        long mangoes = n - totalApplesAndOranges;
        
        return mangoes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (19L)) == (8L));
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (21L)) == (10L));
    Debug.Assert(FruitDistribution((""0 apples and 1 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""1 apples and 0 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (100L)) == (95L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (5L)) == (0L));
    Debug.Assert(FruitDistribution((""1 apples and 100 oranges""), (120L)) == (19L));
    }

}
"
HumanEval_68,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ 1:     //ಯಾವುದೇ ಸಮ ಮೌಲ್ಯಗಳು ಇಲ್ಲದಿದ್ದರೆ ಅಥವಾ ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿ ಖಾಲಿಯಾಗಿದ್ದರೆ, [] ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ಕಿತ್ತುಹಾಕಿದ ನೋಡ್ ಅನ್ನು ಪಟ್ಟಿಯಲ್ಲಿ ಹಿಂತಿರುಗಿಸಬೇಕು, [ smalest_value, ಅದರ ಸೂಚ್ಯಂಕ ],     //ಒಂದೇ ಚಿಕ್ಕದಾದ ಸಹ ಮೌಲ್ಯವನ್ನು ಹೊಂದಿರುವ ಬಹು ನೋಡ್ಗಳನ್ನು ಕಂಡುಕೊಂಡರೆ, ಚಿಕ್ಕದಾದ ಸೂಚ್ಯಂಕವನ್ನು ಹೊಂದಿರುವ ನೋಡ್ ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.     //ಕಿತ್ತುಕೊಂಡ ನೋಡ್ ಚಿಕ್ಕದಾದ ಸಹ ಮೌಲ್ಯವನ್ನು ಹೊಂದಿರುವ ನೋಡ್ ಆಗಿರಬೇಕು.    //ನಿಮ್ಮ ಕಾರ್ಯವು ಒಂದು ನೋಡ್ ಅನ್ನು ಎಳೆಯುವುದು ಮತ್ತು ಅದನ್ನು ಹಿಂದಿರುಗಿಸುವುದು.    //""ಒಂದು ಮರದ ಒಂದು ಶಾಖೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ ಅದು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕ ನೋಡ್ಗಳನ್ನು ಹೊಂದಿದೆ     // >>> Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> Pluck((new List<long>()))
    // (new List<long>())
    // Example 4:
    // >>> Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)0L, (long)1L}))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    public static List<long> Pluck(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Pluck(List<long> arr)
    {
        long smallestEven = long.MaxValue;
        int indexOfSmallest = -1;

        for (int i = 0; i < arr.Count; i++)
        {
            if (arr[i] % 2 == 0 && arr[i] < smallestEven)
            {
                smallestEven = arr[i];
                indexOfSmallest = i;
            }
        }

        if (indexOfSmallest == -1)
        {
            return new List<long>();
        }
        else
        {
            return new List<long> { smallestEven, indexOfSmallest };
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>())).Equals((new List<long>())));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)0L, (long)5L, (long)3L}))).Equals((new List<long>(new long[]{(long)0L, (long)3L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)4L, (long)8L, (long)4L, (long)8L}))).Equals((new List<long>(new long[]{(long)4L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)6L, (long)7L, (long)1L}))).Equals((new List<long>(new long[]{(long)6L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)9L, (long)7L, (long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_69,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಅಂತಹ ಮೌಲ್ಯವು ಅಸ್ತಿತ್ವದಲ್ಲಿಲ್ಲದಿದ್ದರೆ, -1 ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ಒಂದು ಪೂರ್ಣಾಂಕದ ಆವರ್ತನವು ಪಟ್ಟಿಯಲ್ಲಿ ಅದು ಕಾಣಿಸಿಕೊಳ್ಳುವ ಸಂಖ್ಯೆಯಾಗಿದೆ.    //ಶೂನ್ಯ, ಮತ್ತು ಪೂರ್ಣಾಂಕದ ಮೌಲ್ಯಕ್ಕಿಂತ ಹೆಚ್ಚಿನ ಅಥವಾ ಸಮನಾದ ಆವರ್ತನವನ್ನು ಹೊಂದಿದೆ.    //ನಿಮಗೆ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳ ಒಂದು ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿ ನೀಡಲಾಗಿದೆ.  ಗಿಂತ ದೊಡ್ಡದಾದ ದೊಡ್ಡ ಪೂರ್ಣಾಂಕವನ್ನು ಹಿಂತಿರುಗಿ.    // >>> Search((new List<long>(new long[]{(long)4L, (long)1L, (long)2L, (long)2L, (long)3L, (long)1L})))
    // (2L)
    // >>> Search((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L, (long)4L})))
    // (3L)
    // >>> Search((new List<long>(new long[]{(long)5L, (long)5L, (long)4L, (long)4L, (long)4L})))
    // (-1L)
    public static long Search(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static long Search(List<long> lst)
    {
        // Create a dictionary to store the frequency of each number
        Dictionary<long, long> frequency = new Dictionary<long, long>();

        // Count the frequency of each number in the list
        foreach (long num in lst)
        {
            if (frequency.ContainsKey(num))
            {
                frequency[num]++;
            }
            else
            {
                frequency[num] = 1;
            }
        }

        // Variable to store the greatest integer found
        long result = -1;

        // Go through each item in the frequency dictionary
        foreach (var kvp in frequency)
        {
            long number = kvp.Key;
            long freq = kvp.Value;

            // Check if the number's frequency is greater than or equal to the number itself
            if (freq >= number && number > 0)
            {
                // Update the result if this number is greater than the current result
                result = Math.Max(result, number);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)4L, (long)1L, (long)4L, (long)1L, (long)4L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)3L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L}))) == (8L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)3L, (long)3L, (long)2L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)7L, (long)8L, (long)8L, (long)4L, (long)8L, (long)7L, (long)3L, (long)9L, (long)6L, (long)5L, (long)10L, (long)4L, (long)3L, (long)6L, (long)7L, (long)1L, (long)7L, (long)4L, (long)10L, (long)8L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)2L, (long)8L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)7L, (long)1L, (long)8L, (long)8L, (long)10L, (long)5L, (long)8L, (long)5L, (long)3L, (long)10L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)3L, (long)6L, (long)5L, (long)6L, (long)4L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)6L, (long)7L, (long)1L, (long)4L, (long)7L, (long)1L, (long)8L, (long)8L, (long)9L, (long)8L, (long)10L, (long)10L, (long)8L, (long)4L, (long)10L, (long)4L, (long)10L, (long)1L, (long)2L, (long)9L, (long)5L, (long)7L, (long)9L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)9L, (long)10L, (long)1L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)7L, (long)5L, (long)8L, (long)7L, (long)5L, (long)3L, (long)7L, (long)5L, (long)10L, (long)10L, (long)3L, (long)6L, (long)10L, (long)2L, (long)8L, (long)6L, (long)5L, (long)4L, (long)9L, (long)5L, (long)3L, (long)10L}))) == (5L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)10L, (long)6L, (long)4L, (long)3L, (long)5L, (long)8L, (long)2L, (long)4L, (long)2L, (long)8L, (long)4L, (long)6L, (long)10L, (long)4L, (long)2L, (long)1L, (long)10L, (long)2L, (long)1L, (long)1L, (long)5L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)10L, (long)4L, (long)8L, (long)2L, (long)10L, (long)5L, (long)1L, (long)2L, (long)9L, (long)5L, (long)5L, (long)6L, (long)3L, (long)8L, (long)6L, (long)4L, (long)10L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)6L, (long)10L, (long)1L, (long)6L, (long)9L, (long)10L, (long)8L, (long)6L, (long)8L, (long)7L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)2L, (long)4L, (long)1L, (long)5L, (long)1L, (long)5L, (long)2L, (long)5L, (long)7L, (long)7L, (long)7L, (long)3L, (long)10L, (long)1L, (long)5L, (long)4L, (long)2L, (long)8L, (long)4L, (long)1L, (long)9L, (long)10L, (long)7L, (long)10L, (long)2L, (long)8L, (long)10L, (long)9L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)6L, (long)4L, (long)2L, (long)8L, (long)7L, (long)5L, (long)6L, (long)4L, (long)10L, (long)4L, (long)6L, (long)3L, (long)7L, (long)8L, (long)8L, (long)3L, (long)1L, (long)4L, (long)2L, (long)2L, (long)10L, (long)7L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)8L, (long)6L, (long)10L, (long)2L, (long)6L, (long)10L, (long)2L, (long)7L, (long)8L, (long)10L, (long)3L, (long)8L, (long)2L, (long)6L, (long)2L, (long)3L, (long)1L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)3L, (long)9L, (long)5L, (long)6L, (long)3L, (long)2L, (long)8L, (long)5L, (long)6L, (long)10L, (long)10L, (long)6L, (long)8L, (long)4L, (long)10L, (long)7L, (long)7L, (long)10L, (long)8L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)10L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)7L, (long)7L, (long)2L, (long)4L, (long)7L, (long)2L, (long)10L, (long)9L, (long)7L, (long)5L, (long)7L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)4L, (long)10L, (long)2L, (long)1L, (long)1L, (long)10L, (long)3L, (long)6L, (long)1L, (long)8L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)7L, (long)9L, (long)9L, (long)9L, (long)3L, (long)4L, (long)1L, (long)5L, (long)9L, (long)1L, (long)2L, (long)1L, (long)1L, (long)10L, (long)7L, (long)5L, (long)6L, (long)7L, (long)6L, (long)7L, (long)7L, (long)6L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)10L, (long)10L, (long)9L, (long)2L}))) == (-1L));
    }

}
"
HumanEval_70,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ನಂತರ ಉಳಿದ ಪೂರ್ಣಾಂಕಗಳ ಗರಿಷ್ಠ, ನಂತರ ಕನಿಷ್ಠ ಹೀಗೆ.    //ವಿಚಿತ್ರ ವಿಂಗಡಣೆ, ನೀವು ಕನಿಷ್ಟ ಮೌಲ್ಯದೊಂದಿಗೆ ಪ್ರಾರಂಭಿಸಿದಾಗ,     //ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ವಿಚಿತ್ರ ಕ್ರಮದಲ್ಲಿ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    // >>> StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))
    // >>> StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L})))
    // (new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))
    // >>> StrangeSortList((new List<long>()))
    // (new List<long>())
    public static List<long> StrangeSortList(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> StrangeSortList(List<long> lst) {
        List<long> result = new List<long>();
        lst.Sort();
        int start = 0;
        int end = lst.Count - 1;
        
        while (start <= end) {
            if (start <= end) {
                result.Add(lst[start]);
                start++;
            }
            if (start <= end) {
                result.Add(lst[end]);
                end--;
            }
        }
        
        return result;
    }
    
    static void Main(string[] args) {
        var example1 = StrangeSortList(new List<long> { 1L, 2L, 3L, 4L });
        var example2 = StrangeSortList(new List<long> { 5L, 5L, 5L, 5L });
        var example3 = StrangeSortList(new List<long>());

        Console.WriteLine(string.Join("", "", example1)); // Output: 1, 4, 2, 3
        Console.WriteLine(string.Join("", "", example2)); // Output: 5, 5, 5, 5
        Console.WriteLine(string.Join("", "", example3)); // Output: (empty line)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))).Equals((new List<long>(new long[]{(long)5L, (long)9L, (long)6L, (long)8L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)9L, (long)5L, (long)8L, (long)6L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))).Equals((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L}))).Equals((new List<long>(new long[]{(long)1L, (long)8L, (long)2L, (long)7L, (long)3L, (long)6L, (long)4L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)0L, (long)2L, (long)2L, (long)2L, (long)5L, (long)5L, (long)-5L, (long)-5L}))).Equals((new List<long>(new long[]{(long)-5L, (long)5L, (long)-5L, (long)5L, (long)0L, (long)2L, (long)2L, (long)2L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)111111L}))).Equals((new List<long>(new long[]{(long)111111L}))));
    }

}
"
HumanEval_71,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಮೂರನೇ ಭಾಗಕ್ಕಿಂತಲೂ ಹೆಚ್ಚು.    //ಯಾವುದೇ ಎರಡು ಬದಿಗಳ ಮೊತ್ತವು ದೊಡ್ಡದಾಗಿದ್ದರೆ ಮೂರು ಬದಿಗಳು ಮಾನ್ಯ ತ್ರಿಕೋನವನ್ನು ಮಾಡುತ್ತವೆ.    //ಇಲ್ಲದಿದ್ದರೆ -1  ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ    // ಮೂರು ಬದಿಗಳು ಮಾನ್ಯ ತ್ರಿಕೋನವೊಂದನ್ನು ರೂಪಿಸಿದರೆ ತ್ರಿಕೋನವು 2 ದಶಮಾಂಶ ಬಿಂದುಗಳಿಗೆ ದುಂಡಾದ     // ನ ಪ್ರದೇಶವನ್ನು ಹಿಂತಿರುಗಿ     // >>> TriangleArea((3L), (4L), (5L))
    // (6.0f)
    // >>> TriangleArea((1L), (2L), (10L))
    // (float)-1L
    public static float TriangleArea(long a, long b, long c) {
","public static float TriangleArea(long a, long b, long c) {
    // Check if the sides form a valid triangle using the triangle inequality theorem
    if (a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area of the triangle
        double s = (a + b + c) / 2.0;
        double area = Math.Sqrt(s * (s - a) * (s - b) * (s - c));
        return (float)Math.Round(area, 2);
    }
    return -1;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((3L), (4L), (5L)) == (6.0f));
    Debug.Assert(TriangleArea((1L), (2L), (10L)) == (float)-1L);
    Debug.Assert(TriangleArea((4L), (8L), (5L)) == (8.18f));
    Debug.Assert(TriangleArea((2L), (2L), (2L)) == (1.73f));
    Debug.Assert(TriangleArea((1L), (2L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((10L), (5L), (7L)) == (16.25f));
    Debug.Assert(TriangleArea((2L), (6L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((1L), (1L), (1L)) == (0.43f));
    Debug.Assert(TriangleArea((2L), (2L), (10L)) == (float)-1L);
    }

}
"
HumanEval_72,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ವಸ್ತುವಿನ q ಸಮತೋಲಿತ ವೇಳೆ ಹಾರುವ (ಇದು ಒಂದು ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಪಟ್ಟಿ) ಮತ್ತು ಅದರ ಅಂಶಗಳ ಮೊತ್ತವು ಕಡಿಮೆ ಅಥವಾ ಗರಿಷ್ಠ ಸಾಧ್ಯ ತೂಕ w ಸಮಾನವಾಗಿರುತ್ತದೆ.    //ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಅದು ವಸ್ತುವಿನ q ಹಾರಿದರೆ true ಮತ್ತು ಇಲ್ಲದಿದ್ದರೆ false ಎಂದು ಹಿಂದಿರುಗಿಸುತ್ತದೆ.    // >>> WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L})), (5L))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    public static bool WillItFly(List<long> q, long w) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool WillItFly(List<long> q, long w)
    {
        if (IsPalindromic(q) && SumIsLessThanOrEqual(q, w))
        {
            return true;
        }
        return false;
    }

    private static bool IsPalindromic(List<long> q)
    {
        int count = q.Count;
        for (int i = 0; i < count / 2; i++)
        {
            if (q[i] != q[count - i - 1])
            {
                return false;
            }
        }
        return true;
    }

    private static bool SumIsLessThanOrEqual(List<long> q, long w)
    {
        long sum = 0;
        foreach (var item in q)
        {
            sum += item;
            if (sum > w)
            {
                return false;
            }
        }
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L})), (5L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (6L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)5L})), (5L)) == (true));
    }

}
"
HumanEval_73,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಒಂದು ಬದಲಾವಣೆಯಲ್ಲಿ, ನೀವು ಒಂದು ಅಂಶವನ್ನು ಯಾವುದೇ ಇತರ ಅಂಶಕ್ಕೆ ಬದಲಾಯಿಸಬಹುದು.    //ಪಟ್ಟಿಯನ್ನು ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಮಾಡಲು ಬದಲಾಯಿಸಬೇಕಾಗಿದೆ. ಪಾಲಿಂಡ್ರೋಮಿಕ್ ಪಟ್ಟಿ ಎಂಬುದು ಒಂದು ಪಟ್ಟಿ     //ಪೂರ್ಣಾಂಕಗಳ arr ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ,  ಎಂದು ಕನಿಷ್ಠ ಅಂಶಗಳ ಸಂಖ್ಯೆಯನ್ನು ಕಂಡುಹಿಡಿಯಿರಿ    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L})))
    // (4L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L})))
    // (1L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L})))
    // (0L)
    public static long SmallestChange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SmallestChange(List<long> arr)
    {
        long changes = 0;
        int left = 0;
        int right = arr.Count - 1;

        while (left < right)
        {
            if (arr[left] != arr[right])
            {
                changes++;
            }
            left++;
            right--;
        }

        return changes;
    }

    static void Main()
    {
        // Example usage:
        List<long> list1 = new List<long> { 1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L };
        Console.WriteLine(SmallestChange(list1)); // Output: 4

        List<long> list2 = new List<long> { 1L, 2L, 3L, 4L, 3L, 2L, 2L };
        Console.WriteLine(SmallestChange(list2)); // Output: 1

        List<long> list3 = new List<long> { 1L, 2L, 3L, 2L, 1L };
        Console.WriteLine(SmallestChange(list3)); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L}))) == (4L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)3L, (long)1L, (long)1L, (long)3L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    }

}
"
HumanEval_74,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಎರಡು ಪಟ್ಟಿಗಳು ಒಂದೇ ಸಂಖ್ಯೆಯ ಅಕ್ಷರಗಳನ್ನು ಹೊಂದಿದ್ದರೆ, ಮೊದಲ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ.    //ಪಟ್ಟಿಯ ಎಲ್ಲಾ ಸ್ಟ್ರಿಂಗ್ಗಳಲ್ಲಿನ ಒಟ್ಟು ಸಂಖ್ಯೆಯ ಅಕ್ಷರಗಳು ಇತರ ಪಟ್ಟಿಗಿಂತ ಕಡಿಮೆಯಿವೆ.    //ಎರಡು ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಗಳನ್ನು ಸ್ವೀಕರಿಸುವ ಮತ್ತು  ಹೊಂದಿರುವ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ    // >>> TotalMatch((new List<string>()), (new List<string>()))
    // (new List<string>())
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""})))
    // (new List<string>(new string[]{(string)""hi"", (string)""admin""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""})))
    // (new List<string>(new string[]{(string)""4""}))
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2)
    {
        int totalCharsLst1 = lst1.Sum(s => s.Length);
        int totalCharsLst2 = lst2.Sum(s => s.Length);

        if (totalCharsLst1 <= totalCharsLst2)
        {
            return lst1;
        }
        else
        {
            return lst2;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>())).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""}))).Equals((new List<string>(new string[]{(string)""4""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""Hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hii""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>(new string[]{(string)""this""}))).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""this""})), (new List<string>())).Equals((new List<string>())));
    }

}
"
HumanEval_75,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //(a) 100 ಕ್ಕಿಂತ ಚಿಕ್ಕದಾಗಿದೆ ಎಂದು ತಿಳಿದಿರುವುದು.    //ಮತ್ತು ಸುಳ್ಳು ಬೇರೆ.    //ಕೊಟ್ಟಿರುವ ಸಂಖ್ಯೆಯು 3 ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳ ಗುಣಾಕಾರವಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ     // >>> IsMultiplyPrime((30L))
    // (true)
    // 30 = 2 * 3 * 5
    public static bool IsMultiplyPrime(long a) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsMultiplyPrime(long a) {
        if (a >= 100) return false;
        
        List<long> primes = GeneratePrimes(100);
        
        int count = 0;
        foreach (long prime in primes) {
            while (a % prime == 0) {
                a /= prime;
                count++;
            }
            if (count > 3) break;
        }
        
        return a == 1 && count == 3;
    }

    private static List<long> GeneratePrimes(int max) {
        List<long> primes = new List<long>();
        bool[] isPrime = new bool[max + 1];
        for (int i = 2; i <= max; i++) isPrime[i] = true;

        for (int i = 2; i * i <= max; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= max; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        for (int i = 2; i <= max; i++) {
            if (isPrime[i]) primes.Add(i);
        }

        return primes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsMultiplyPrime((5L)) == (false));
    Debug.Assert(IsMultiplyPrime((30L)) == (true));
    Debug.Assert(IsMultiplyPrime((8L)) == (true));
    Debug.Assert(IsMultiplyPrime((10L)) == (false));
    Debug.Assert(IsMultiplyPrime((125L)) == (true));
    Debug.Assert(IsMultiplyPrime((105L)) == (true));
    Debug.Assert(IsMultiplyPrime((126L)) == (false));
    Debug.Assert(IsMultiplyPrime((729L)) == (false));
    Debug.Assert(IsMultiplyPrime((891L)) == (false));
    Debug.Assert(IsMultiplyPrime((1001L)) == (true));
    }

}
"
HumanEval_76,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //x ಎಂಬುದು n ನ ಸರಳ ಪದರವಾಗಿದೆ n**int=x     //n ನ ಪವರ್ ಮತ್ತು ಇತರ ಸಂದರ್ಭಗಳಲ್ಲಿ ಸುಳ್ಳು.    //ನಿಮ್ಮ ಕಾರ್ಯವು ಒಂದು ಸಂಖ್ಯೆಯ x ಒಂದು ಸರಳ  ಆಗಿದ್ದರೆ ನಿಜವಾದದನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯುವುದು.    // >>> IsSimplePower((1L), (4L))
    // (true)
    // >>> IsSimplePower((2L), (2L))
    // (true)
    // >>> IsSimplePower((8L), (2L))
    // (true)
    // >>> IsSimplePower((3L), (2L))
    // (false)
    // >>> IsSimplePower((3L), (1L))
    // (false)
    // >>> IsSimplePower((5L), (3L))
    // (false)
    public static bool IsSimplePower(long x, long n) {
","if (x < 1 || n < 2)
        return false;

    while (x > 1)
    {
        if (x % n != 0)
            return false;
        x /= n;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSimplePower((16L), (2L)) == (true));
    Debug.Assert(IsSimplePower((143214L), (16L)) == (false));
    Debug.Assert(IsSimplePower((4L), (2L)) == (true));
    Debug.Assert(IsSimplePower((9L), (3L)) == (true));
    Debug.Assert(IsSimplePower((16L), (4L)) == (true));
    Debug.Assert(IsSimplePower((24L), (2L)) == (false));
    Debug.Assert(IsSimplePower((128L), (4L)) == (false));
    Debug.Assert(IsSimplePower((12L), (6L)) == (false));
    Debug.Assert(IsSimplePower((1L), (1L)) == (true));
    Debug.Assert(IsSimplePower((1L), (12L)) == (true));
    }

}
"
HumanEval_77,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಗಮನಿಸಿ: ನೀವು ಇನ್ಪುಟ್ ಯಾವಾಗಲೂ ಮಾನ್ಯ ಎಂದು ಭಾವಿಸಬಹುದು.    //ಈ ಇಂಗರ್ ಒಂದು ಪೂರ್ಣಾಂಕದ ಘನವಾಗಿದ್ದರೆ.    //ಒಂದು ಪೂರ್ಣಾಂಕವನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಮತ್ತು true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ     // >>> Iscube((1L))
    // (true)
    // >>> Iscube((2L))
    // (false)
    // >>> Iscube((-1L))
    // (true)
    // >>> Iscube((64L))
    // (true)
    // >>> Iscube((0L))
    // (true)
    // >>> Iscube((180L))
    // (false)
    public static bool Iscube(long a) {
","using System;

class Problem {
    public static bool Iscube(long a) {
        if (a == 0) return true;
        long absA = Math.Abs(a);
        long cubeRoot = (long)Math.Round(Math.Pow(absA, 1.0 / 3.0));
        return cubeRoot * cubeRoot * cubeRoot == absA;
    }

    static void Main(string[] args) {
        Console.WriteLine(Iscube(1L));    // true
        Console.WriteLine(Iscube(2L));    // false
        Console.WriteLine(Iscube(-1L));   // true
        Console.WriteLine(Iscube(64L));   // true
        Console.WriteLine(Iscube(0L));    // true
        Console.WriteLine(Iscube(180L));  // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Iscube((1L)) == (true));
    Debug.Assert(Iscube((2L)) == (false));
    Debug.Assert(Iscube((-1L)) == (true));
    Debug.Assert(Iscube((64L)) == (true));
    Debug.Assert(Iscube((180L)) == (false));
    Debug.Assert(Iscube((1000L)) == (true));
    Debug.Assert(Iscube((0L)) == (true));
    Debug.Assert(Iscube((1729L)) == (false));
    }

}
"
HumanEval_78,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಮತ್ತು ಚಿಹ್ನೆಗಳು A,B,C,D,E,F ಯಾವಾಗಲೂ ದೊಡ್ಡಕ್ಷರಗಳಾಗಿರುತ್ತವೆ.    //ಗಮನಿಸಿ: ನೀವು ಇನ್ಪುಟ್ ಯಾವಾಗಲೂ ಸರಿಯಾದ ಅಥವಾ ಖಾಲಿ ಸ್ಟ್ರಿಂಗ್ ಎಂದು ಭಾವಿಸಬಹುದು,     //ಬಿ (= ದಶಮಾಂಶ 11), ಡಿ (= ದಶಮಾಂಶ 13).    //ಆದ್ದರಿಂದ ನೀವು ಈ ಕೆಳಗಿನ ಅಂಕೆಗಳ ಸಂಖ್ಯೆಯನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು: 2, 3, 5, 7,     //ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳು 2, 3, 5, 7, 11, 13, 17,...     //ಹೆಕ್ಸಾಡೆಸಿಮಲ್ ಅಂಕಿಗಳು 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     //1 ಕ್ಕಿಂತ ದೊಡ್ಡದಾಗಿದೆ ಅದು ಎರಡು ಸಣ್ಣ ನೈಸರ್ಗಿಕ ಸಂಖ್ಯೆಗಳ ಉತ್ಪನ್ನವಲ್ಲ).    //ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳು (ಪ್ರೈಮ್ ಸಂಖ್ಯೆ, ಅಥವಾ ಅವಿಭಾಜ್ಯ, ನೈಸರ್ಗಿಕ ಸಂಖ್ಯೆ     //ಹೆಕ್ಸಾಡೆಸಿಮಲ್ ಸಂಖ್ಯೆಯನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಮತ್ತು ಹೆಕ್ಸಾಡೆಸಿಮಲ್ ಸಂಖ್ಯೆಯನ್ನು ಎಣಿಕೆ ಮಾಡುತ್ತದೆ     //ನೀವು ಸ್ವೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಲು ನಿಯೋಜಿಸಲಾಗಿದೆ     // >>> HexKey((""AB""))
    // (1L)
    // >>> HexKey((""1077E""))
    // (2L)
    // >>> HexKey((""ABED1A33""))
    // (4L)
    // >>> HexKey((""123456789ABCDEF0""))
    // (6L)
    // >>> HexKey((""2020""))
    // (2L)
    public static long HexKey(string num) {
","public static long HexKey(string num) {
    // Define a set of prime hexadecimal digits
    HashSet<char> primeHexDigits = new HashSet<char> { '2', '3', '5', '7', 'B', 'D' };

    long primeCount = 0;

    // Iterate through each character in the input string
    foreach (char c in num) {
        // If the character is in the set of prime hex digits, increase the count
        if (primeHexDigits.Contains(c)) {
            primeCount++;
        }
    }

    return primeCount;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HexKey((""AB"")) == (1L));
    Debug.Assert(HexKey((""1077E"")) == (2L));
    Debug.Assert(HexKey((""ABED1A33"")) == (4L));
    Debug.Assert(HexKey((""2020"")) == (2L));
    Debug.Assert(HexKey((""123456789ABCDEF0"")) == (6L));
    Debug.Assert(HexKey((""112233445566778899AABBCCDDEEFF00"")) == (12L));
    }

}
"
HumanEval_79,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಹೆಚ್ಚುವರಿ ಅಕ್ಷರಗಳು ಸ್ವರೂಪಕ್ಕೆ ಸಹಾಯ ಮಾಡಲು ಇವೆ.    //ಸ್ಟ್ರಿಂಗ್ನ ಆರಂಭದಲ್ಲಿ ಮತ್ತು ಕೊನೆಯಲ್ಲಿ ಹೆಚ್ಚುವರಿ ಎರಡು ಅಕ್ಷರಗಳು 'db' ಇರುತ್ತದೆ.    //ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಪ್ರತಿಯೊಂದು ಅಕ್ಷರವು '0' ಅಥವಾ '1' ಆಗಿರುತ್ತದೆ.    //ಬೈನರಿ ಸ್ವರೂಪ. ಈ ಕಾರ್ಯವು ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು, ಇದರಲ್ಲಿ ಪ್ರತಿ ಅಕ್ಷರವು ಬೈನರಿ  ಅನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.    //ನಿಮಗೆ ದಶಮಾಂಶ ರೂಪದಲ್ಲಿ ಒಂದು ಸಂಖ್ಯೆಯನ್ನು ನೀಡಲಾಗುವುದು ಮತ್ತು ನಿಮ್ಮ ಕಾರ್ಯವು ಅದನ್ನು ಪರಿವರ್ತಿಸುವುದು    // >>> DecimalToBinary((15L))
    // (""db1111db"")
    // >>> DecimalToBinary((32L))
    // (""db100000db"")
    public static string DecimalToBinary(long decimalNum) {
","public static string DecimalToBinary(long decimalNum) {
    string binary = Convert.ToString(decimalNum, 2);
    return ""db"" + binary + ""db"";
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DecimalToBinary((0L)).Equals((""db0db"")));
    Debug.Assert(DecimalToBinary((32L)).Equals((""db100000db"")));
    Debug.Assert(DecimalToBinary((103L)).Equals((""db1100111db"")));
    Debug.Assert(DecimalToBinary((15L)).Equals((""db1111db"")));
    }

}
"
HumanEval_80,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಹ್ಯಾಪ್ಸ್ ಆಗಿದ್ದರೆ ಅದರ ಉದ್ದವು ಕನಿಷ್ಠ 3 ಆಗಿರುತ್ತದೆ ಮತ್ತು ಪ್ರತಿ 3 ಸತತ ಅಕ್ಷರಗಳು ವಿಭಿನ್ನವಾಗಿರುತ್ತವೆ     //ನಿಮ್ಮ ಕಾರ್ಯವು ಸ್ಟ್ರಿಂಗ್ ಹ್ಯಾಪ್ಸ್ ಅಥವಾ ಇಲ್ಲವೇ ಎಂಬುದನ್ನು ಪರಿಶೀಲಿಸುವುದು.    //ನಿಮಗೆ ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ನೀಡಲಾಗಿದೆ.    // >>> IsHappy((""a""))
    // (false)
    // >>> IsHappy((""aa""))
    // (false)
    // >>> IsHappy((""abcd""))
    // (true)
    // >>> IsHappy((""aabb""))
    // (false)
    // >>> IsHappy((""adb""))
    // (true)
    // >>> IsHappy((""xyy""))
    // (false)
    public static bool IsHappy(string s) {
","if (s.Length < 3) {
        return false;
    }

    for (int i = 0; i <= s.Length - 3; i++) {
        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsHappy((""a"")) == (false));
    Debug.Assert(IsHappy((""aa"")) == (false));
    Debug.Assert(IsHappy((""abcd"")) == (true));
    Debug.Assert(IsHappy((""aabb"")) == (false));
    Debug.Assert(IsHappy((""adb"")) == (true));
    Debug.Assert(IsHappy((""xyy"")) == (false));
    Debug.Assert(IsHappy((""iopaxpoi"")) == (true));
    Debug.Assert(IsHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //0.0 ಇ     //> 0.0 ಡಿ-     //> 0.7 ಡಿ     //> 1.0 ಡಿ +     //> 1.3 C-     //> 1.7 °C     //> 2.0 C+     //> 2.3 ಬಿ-     //> 2.7 ಬಿ     //> 3.0 ಬಿ +     //> 3.3 ಎ-     //> 3.7 ಎ     //4.0 ಎ +     //GPA. ಅಕ್ಷರ ಶ್ರೇಣಿ.    //ಕೆಳಗಿನ ಕೋಷ್ಟಕವನ್ನು ಬಳಸಿಕೊಂಡು ಅಕ್ಷರ ಶ್ರೇಣಿಗಳ ಪಟ್ಟಿಯನ್ನು ಔಟ್ಪುಟ್ ಮಾಡುವ ಒಂದು ಕಾರ್ಯ:     //ಅವರು ನಿಮಗೆ ಕೆಲವು ವಿದ್ಯಾರ್ಥಿಗಳ GPA ಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದ್ದಾರೆ ಮತ್ತು ನೀವು ಬರೆಯಬೇಕಾಗಿದೆ.    //ಆದರೆ, ಅವಳು ಬಳಸುತ್ತಿದ್ದ ಕೋಡ್ ಅನ್ನು ಕಳೆದುಕೊಂಡಿದ್ದಾಳೆ.    //ಶಿಕ್ಷಕ ತನ್ನದೇ ಆದ ಶ್ರೇಣೀಕರಣದ ಕ್ರಮಾವಳಿಗಳನ್ನು ರಚಿಸುತ್ತಿದ್ದಾನೆ.    //ಇದು ಸೆಮಿಸ್ಟರ್ನ ಕೊನೆಯ ವಾರ ಮತ್ತು ಶಿಕ್ಷಕನು ಶ್ರೇಣಿಗಳನ್ನು ನೀಡಬೇಕಾಗಿದೆ     // >>> GradeEquation((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f})))
    // (new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))
    public static List<string> NumericalLetterGrade(List<float> grades) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> NumericalLetterGrade(List<float> grades)
    {
        List<string> letterGrades = new List<string>();

        foreach (var gpa in grades)
        {
            if (gpa == 4.0f)
                letterGrades.Add(""A+"");
            else if (gpa > 3.7f)
                letterGrades.Add(""A"");
            else if (gpa > 3.3f)
                letterGrades.Add(""A-"");
            else if (gpa > 3.0f)
                letterGrades.Add(""B+"");
            else if (gpa > 2.7f)
                letterGrades.Add(""B"");
            else if (gpa > 2.3f)
                letterGrades.Add(""B-"");
            else if (gpa > 2.0f)
                letterGrades.Add(""C+"");
            else if (gpa > 1.7f)
                letterGrades.Add(""C"");
            else if (gpa > 1.3f)
                letterGrades.Add(""C-"");
            else if (gpa > 1.0f)
                letterGrades.Add(""D+"");
            else if (gpa > 0.7f)
                letterGrades.Add(""D"");
            else if (gpa > 0.0f)
                letterGrades.Add(""D-"");
            else
                letterGrades.Add(""E"");
        }

        return letterGrades;
    }

    static void Main(string[] args)
    {
        List<float> gpas = new List<float> { 4.0f, 3.0f, 1.7f, 2.0f, 3.5f };
        List<string> grades = NumericalLetterGrade(gpas);
        Console.WriteLine(string.Join("", "", grades));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f}))).Equals((new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.2f}))).Equals((new List<string>(new string[]{(string)""D+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.5f}))).Equals((new List<string>(new string[]{(string)""D-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f}))).Equals((new List<string>(new string[]{(string)""E""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))).Equals((new List<string>(new string[]{(string)""D"", (string)""D-"", (string)""C-"", (string)""B"", (string)""B+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f, (float)0.7f}))).Equals((new List<string>(new string[]{(string)""E"", (string)""D-""}))));
    }

}
"
HumanEval_82,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಉದ್ದವು ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಾಗಿದ್ದರೆ ಅಥವಾ ಸುಳ್ಳು     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಮತ್ತು ಸ್ಟ್ರಿಂಗ್     // >>> PrimeLength((""Hello""))
    // (true)
    // >>> PrimeLength((""abcdcba""))
    // (true)
    // >>> PrimeLength((""kittens""))
    // (true)
    // >>> PrimeLength((""orange""))
    // (false)
    public static bool PrimeLength(string str) {
","using System;

class Problem {
    public static bool PrimeLength(string str) {
        int length = str.Length;
        if (length < 2) return false;
        
        for (int i = 2; i <= Math.Sqrt(length); i++) {
            if (length % i == 0) return false;
        }
        
        return true;
    }
    
    // Example usage
    public static void Main() {
        Console.WriteLine(PrimeLength(""Hello""));    // true
        Console.WriteLine(PrimeLength(""abcdcba""));  // true
        Console.WriteLine(PrimeLength(""kittens""));  // true
        Console.WriteLine(PrimeLength(""orange""));   // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeLength((""Hello"")) == (true));
    Debug.Assert(PrimeLength((""abcdcba"")) == (true));
    Debug.Assert(PrimeLength((""kittens"")) == (true));
    Debug.Assert(PrimeLength((""orange"")) == (false));
    Debug.Assert(PrimeLength((""wow"")) == (true));
    Debug.Assert(PrimeLength((""world"")) == (true));
    Debug.Assert(PrimeLength((""MadaM"")) == (true));
    Debug.Assert(PrimeLength((""Wow"")) == (true));
    Debug.Assert(PrimeLength(("""")) == (false));
    Debug.Assert(PrimeLength((""HI"")) == (true));
    Debug.Assert(PrimeLength((""go"")) == (true));
    Debug.Assert(PrimeLength((""gogo"")) == (false));
    Debug.Assert(PrimeLength((""aaaaaaaaaaaaaaa"")) == (false));
    Debug.Assert(PrimeLength((""Madam"")) == (true));
    Debug.Assert(PrimeLength((""M"")) == (false));
    Debug.Assert(PrimeLength((""0"")) == (false));
    }

}
"
HumanEval_83,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //1 ರೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುವ ಅಥವಾ ಕೊನೆಗೊಳ್ಳುವ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳು.    //ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಿದರೆ, n-ಅಂಕಿಯ ಸಂಖ್ಯೆಗಳ ಎಣಿಕೆಯನ್ನು ಹಿಂತಿರುಗಿ     public static long StartsOneEnds(long n) {
","if (n == 1) return 1;
        return (long)Math.Pow(10, n - 1) + 9 * (long)Math.Pow(10, n - 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StartsOneEnds((1L)) == (1L));
    Debug.Assert(StartsOneEnds((2L)) == (18L));
    Debug.Assert(StartsOneEnds((3L)) == (180L));
    Debug.Assert(StartsOneEnds((4L)) == (1800L));
    Debug.Assert(StartsOneEnds((5L)) == (18000L));
    }

}
"
HumanEval_84,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ     //ಒಂದು ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ N ನೀಡಿದರೆ, ಅದರ ಅಂಕೆಗಳ ಒಟ್ಟು ಮೊತ್ತವನ್ನು ಬೈನರಿ ರೂಪದಲ್ಲಿ ಹಿಂತಿರುಗಿಸಿ.     // >>> Solve((1000L))
    // (""1"")
    // >>> Solve((150L))
    // (""110"")
    // >>> Solve((147L))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    public static string Solve(long N) {
","public static string Solve(long N) {
        int sumOfDigits = 0;
        while (N > 0) {
            sumOfDigits += (int)(N % 10);
            N /= 10;
        }
        return Convert.ToString(sumOfDigits, 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((1000L)).Equals((""1"")));
    Debug.Assert(Solve((150L)).Equals((""110"")));
    Debug.Assert(Solve((147L)).Equals((""1100"")));
    Debug.Assert(Solve((333L)).Equals((""1001"")));
    Debug.Assert(Solve((963L)).Equals((""10010"")));
    }

}
"
HumanEval_85,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಪೂರ್ಣಾಂಕಗಳ ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ lst. ವಿಚಿತ್ರ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿರುವ ಸಮ ಅಂಶಗಳನ್ನು ಸೇರಿಸಿ.    // >>> Add((new List<long>(new long[]{(long)4L, (long)2L, (long)6L, (long)7L})))
    // (2L)
    public static long Add(List<long> lst) {
","long sum = 0;
    for (int i = 1; i < lst.Count; i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)88L}))) == (88L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)5L, (long)6L, (long)7L, (long)2L, (long)122L}))) == (122L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)0L, (long)6L, (long)7L}))) == (0L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)4L, (long)6L, (long)8L}))) == (12L));
    }

}
"
HumanEval_86,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಗಮನಿಸಿ: ವಾಕ್ಯದಲ್ಲಿನ ಪದಗಳ ಕ್ರಮ ಮತ್ತು ಖಾಲಿ ಜಾಗಗಳನ್ನು ನೀವು ಗಮನಿಸಬೇಕು.    //ವುಳ್ಳ ಮೌಲ್ಯದ ಆಧಾರದ ಮೇಲೆ ಏರುತ್ತಿರುವ ಕ್ರಮ.    // ರಲ್ಲಿ ಎಲ್ಲಾ ಪಾತ್ರಗಳು ಜೋಡಿಸಲಾದ ಹೊಸ ಪದವನ್ನು ಬದಲಿಸಲಾಗುತ್ತದೆ    //ಸ್ಟ್ರಿಂಗ್ನ ಕ್ರಮಬದ್ಧ ಆವೃತ್ತಿ, ಎಲ್ಲಾ ಪದಗಳು (ಅಂತರದಿಂದ ಬೇರ್ಪಡಿಸಲ್ಪಟ್ಟ)     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಅದರ ಕ್ರಮಬದ್ಧ ಆವೃತ್ತಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ.    // >>> AntiShuffle((""Hi""))
    // (""Hi"")
    // >>> AntiShuffle((""hello""))
    // (""ehllo"")
    // >>> AntiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    public static string AntiShuffle(string s) {
","using System;
using System.Linq;

class Problem
{
    public static string AntiShuffle(string s)
    {
        return string.Join("" "", s.Split(' ')
            .Select(word => string.Concat(word.OrderBy(c => c))));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AntiShuffle((""Hi"")).Equals((""Hi"")));
    Debug.Assert(AntiShuffle((""hello"")).Equals((""ehllo"")));
    Debug.Assert(AntiShuffle((""number"")).Equals((""bemnru"")));
    Debug.Assert(AntiShuffle((""abcd"")).Equals((""abcd"")));
    Debug.Assert(AntiShuffle((""Hello World!!!"")).Equals((""Hello !!!Wdlor"")));
    Debug.Assert(AntiShuffle(("""")).Equals(("""")));
    Debug.Assert(AntiShuffle((""Hi. My name is Mister Robot. How are you?"")).Equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಅಲ್ಲದೆ, ಸಾಲಿನ ನಿರ್ದೇಶಾಂಕಗಳನ್ನು ಕಾಲಮ್ಗಳ ಮೂಲಕ ಇಳಿಕೆಯ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಿ.    //ಆರಂಭದಲ್ಲಿ ಸಾಲುಗಳ ಮೂಲಕ ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ನಿರ್ದೇಶಾಂಕಗಳನ್ನು ವಿಂಗಡಿಸಿ.    //ಪ್ರತಿ ಟುಪಲ್ ಒಂದು ನಿರ್ದೇಶಾಂಕವಾಗಿದೆ - (ಸಾಲು, ಕಾಲಮ್ಗಳು), 0 ರಿಂದ ಪ್ರಾರಂಭವಾಗುತ್ತದೆ.    //ಮತ್ತು ಟುಪಲ್ಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, [(x1, y1), (x2, y2) ...] ಅಂತಹ     //lst, ಮತ್ತು ಪೂರ್ಣಾಂಕ x ನೀಡಿದರೆ, ಪಟ್ಟಿಯಲ್ಲಿ ಪೂರ್ಣಾಂಕ x ಗಳನ್ನು ಹುಡುಕಿ,    //ಪ್ರತಿ ಸಾಲು ವಿಭಿನ್ನ ಸಂಖ್ಯೆಯ ಕಾಲಮ್ಗಳನ್ನು ಹೊಂದಿರಬಹುದು.    //ಇದು ಮ್ಯಾಟ್ರಿಕ್ಸ್ಗೆ ಹೋಲುತ್ತದೆ, ಆದರೆ ಮ್ಯಾಟ್ರಿಕ್ಸ್ಗಳಿಗೆ ಹೋಲುತ್ತದೆ,    //ನಿಮಗೆ 2 ಆಯಾಮದ ಡೇಟಾವನ್ನು ನೀಡಲಾಗಿದೆ, ಒಂದು ಗೂಡುಕಟ್ಟಿದ ಪಟ್ಟಿಗಳಂತೆ,     // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))
    // >>> GetRow((new List<List<long>>()), (1L))
    // (new List<Tuple<long, long>>())
    // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
        var result = new List<Tuple<long, long>>();
        
        for (long row = 0; row < lst.Count; row++) {
            List<long> currentRow = lst[(int)row];
            var foundIndices = new List<long>();
            
            for (long col = 0; col < currentRow.Count; col++) {
                if (currentRow[(int)col] == x) {
                    foundIndices.Add(col);
                }
            }
            
            foundIndices.Sort((a, b) => b.CompareTo(a)); // Sort columns in descending order
            
            foreach (var col in foundIndices) {
                result.Add(Tuple.Create(row, col));
            }
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})})), (2L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 1L), (Tuple<long, long>)Tuple.Create(1L, 1L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(3L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(5L, 1L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)1L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(2L, 0L), (Tuple<long, long>)Tuple.Create(3L, 2L), (Tuple<long, long>)Tuple.Create(3L, 0L), (Tuple<long, long>)Tuple.Create(4L, 3L), (Tuple<long, long>)Tuple.Create(4L, 0L), (Tuple<long, long>)Tuple.Create(5L, 4L), (Tuple<long, long>)Tuple.Create(5L, 0L), (Tuple<long, long>)Tuple.Create(6L, 5L), (Tuple<long, long>)Tuple.Create(6L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>()), (1L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L})})), (2L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))));
    }

}
"
HumanEval_88,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //* ನೀಡಲಾದ ಪಟ್ಟಿಯನ್ನು ಬದಲಾಯಿಸಬೇಡಿ.     //ಟಿಪ್ಪಣಿ:     //ಅಥವಾ ಮೊತ್ತವು ((ಮೊದಲ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ, ಕೊನೆಯ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ) ಸಮವಾಗಿದ್ದರೆ ಅದನ್ನು ಇಳಿಕೆಯ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಿ.    //ನೀವು ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯನ್ನು ಆರೋಹಣ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸುತ್ತೀರಿ, ಮೊತ್ತವು ((ಮೊದಲ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ, ಕೊನೆಯ ಸೂಚ್ಯಂಕ ಮೌಲ್ಯ) ಬೆಸವಾಗಿದ್ದರೆ,     //ಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ, ವಿಂಗಡಿಸಿದ ನಂತರ ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯ ಒಂದು ಕೋಕ್ಸ್ ಅನ್ನು ಹಿಂತಿರುಗಿಸಿ,    // >>> SortArray((new List<long>()))
    // (new List<long>())
    // >>> SortArray((new List<long>(new long[]{(long)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))
    public static List<long> SortArray(List<long> array) {
","public static List<long> SortArray(List<long> array) {
        if (array == null || array.Count <= 1) {
            return new List<long>(array);
        }
        
        long firstValue = array[0];
        long lastValue = array[array.Count - 1];
        long sum = firstValue + lastValue;

        List<long> sortedArray = new List<long>(array);

        if (sum % 2 != 0) { // sum is odd, sort ascending
            sortedArray.Sort();
        } else { // sum is even, sort descending
            sortedArray.Sort();
            sortedArray.Reverse();
        }

        return sortedArray;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)5L}))).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)15L, (long)42L, (long)87L, (long)32L, (long)11L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)11L, (long)15L, (long)32L, (long)42L, (long)87L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)21L, (long)14L, (long)23L, (long)11L}))).Equals((new List<long>(new long[]{(long)23L, (long)21L, (long)14L, (long)11L}))));
    }

}
"
HumanEval_89,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಎರಡು ಸ್ಥಳಗಳಿಗೆ ಎರಡು ಬಾರಿ ಕೆಳಗೆ ಚಲಿಸುವಂತೆ ಮಾಡಿ.    //ಅಕ್ಷರಗಳು     //ಅಕ್ಷರಮಾಲೆಯೊಂದಿಗೆ ತಿರುಗಿಸುವ ಮೂಲಕ ಎನ್ಕ್ರಿಪ್ಟ್ ಮಾಡಲಾದ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ.    //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಆರ್ಗ್ಯುಮೆಂಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಎನ್ಕ್ರಿಪ್ಟ್ ಮಾಡಿ ಮತ್ತು     // >>> Encrypt((""hi""))
    // (""lm"")
    // >>> Encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> Encrypt((""gf""))
    // (""kj"")
    // >>> Encrypt((""et""))
    // (""ix"")
    public static string Encrypt(string s) {
","const int shiftAmount = 4; // 2 multiplied by 2 equals 4.

    StringBuilder encrypted = new StringBuilder();

    foreach (char c in s) {
        if (char.IsLetter(c)) {
            char start = char.IsUpper(c) ? 'A' : 'a';
            char encryptedChar = (char)(start + (c - start + shiftAmount) % 26);
            encrypted.Append(encryptedChar);
        } else {
            encrypted.Append(c); // Non-letter characters are not encrypted.
        }
    }

    return encrypted.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encrypt((""hi"")).Equals((""lm"")));
    Debug.Assert(Encrypt((""asdfghjkl"")).Equals((""ewhjklnop"")));
    Debug.Assert(Encrypt((""gf"")).Equals((""kj"")));
    Debug.Assert(Encrypt((""et"")).Equals((""ix"")));
    Debug.Assert(Encrypt((""faewfawefaewg"")).Equals((""jeiajeaijeiak"")));
    Debug.Assert(Encrypt((""hellomyfriend"")).Equals((""lippsqcjvmirh"")));
    Debug.Assert(Encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).Equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    Debug.Assert(Encrypt((""a"")).Equals((""e"")));
    }

}
"
HumanEval_90,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಅಂತಹ ಅಂಶವಿಲ್ಲದಿದ್ದರೆ ಶೂನ್ಯವನ್ನು ಹಿಂತಿರುಗಿಸಿ.    //ಪಟ್ಟಿಯ 2 ನೇ ಚಿಕ್ಕ ಅಂಶವನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು next_smallest ().    //ನಿಮಗೆ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ.    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // 2L
    // >>> NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L})))
    // 2L
    // >>> NextSmallest((new List<long>()))
    // null
    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)1L})))
    // null
    public static Nullable<long> NextSmallest(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Nullable<long> NextSmallest(List<long> lst) {
        if (lst == null || lst.Count < 2) {
            return null;
        }

        HashSet<long> uniqueElements = new HashSet<long>(lst);
        if (uniqueElements.Count < 2) {
            return null;
        }

        List<long> sortedUniqueElements = uniqueElements.ToList();
        sortedUniqueElements.Sort();

        return sortedUniqueElements[1];
    }

    static void Main(string[] args) {
        Console.WriteLine(NextSmallest(new List<long> {1, 2, 3, 4, 5})); // 2
        Console.WriteLine(NextSmallest(new List<long> {5, 1, 4, 3, 2})); // 2
        Console.WriteLine(NextSmallest(new List<long>())); // null
        Console.WriteLine(NextSmallest(new List<long> {1, 1})); // null
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>())).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)0L}))).Equals(1L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));
    }

}
"
HumanEval_91,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ವಾಕ್ಯಗಳನ್ನು '', '?' ಅಥವಾ '!' ಗಳಿಂದ ಪ್ರತ್ಯೇಕಿಸಲಾಗುತ್ತದೆ.    //ಬೇಸರ. ""ನಾನು"" ಎಂಬ ಪದದಿಂದ ಪ್ರಾರಂಭವಾಗುವ ವಾಕ್ಯವು ಬೇಸರವಾಗಿದೆ.    //ನಿಮಗೆ ಪದಗಳ ಒಂದು ಸರಣಿಯನ್ನು ನೀಡಲಾಗುವುದು, ಮತ್ತು ನಿಮ್ಮ ಕಾರ್ಯವು ಸಂಖ್ಯೆಯನ್ನು ಎಣಿಸುವುದು.    // >>> IsBored((""Hello world""))
    // (0L)
    // >>> IsBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1L)
    public static long IsBored(string S) {
","using System;

class Problem {
    public static long IsBored(string S) {
        // Split the input string into sentences based on delimiters '.', '?', '!'
        char[] delimiters = new char[] { '.', '?', '!' };
        string[] sentences = S.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);

        // Count sentences that start with 'I' after trimming leading whitespaces
        long boredomCount = 0;
        foreach (string sentence in sentences) {
            if (sentence.TrimStart().StartsWith(""I"")) {
                boredomCount++;
            }
        }

        return boredomCount;
    }

    static void Main(string[] args) {
        // Example usage:
        Console.WriteLine(IsBored(""Hello world"")); // Output: 0
        Console.WriteLine(IsBored(""The sky is blue. The sun is shining. I love this weather"")); // Output: 1
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsBored((""Hello world"")) == (0L));
    Debug.Assert(IsBored((""Is the sky blue?"")) == (0L));
    Debug.Assert(IsBored((""I love It !"")) == (1L));
    Debug.Assert(IsBored((""bIt"")) == (0L));
    Debug.Assert(IsBored((""I feel good today. I will be productive. will kill It"")) == (2L));
    Debug.Assert(IsBored((""You and I are going for a walk"")) == (0L));
    }

}
"
HumanEval_92,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಯಾವುದೇ ಇತರ ಸಂದರ್ಭಗಳಲ್ಲಿ ತಪ್ಪು ಎಂದು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಒಂದು ಸಂಖ್ಯೆಯು ಇತರ ಎರಡು ಮೊತ್ತಕ್ಕೆ ಸಮನಾಗಿರುತ್ತದೆ ಮತ್ತು ಎಲ್ಲಾ ಸಂಖ್ಯೆಗಳು ಪೂರ್ಣಾಂಕಗಳಾಗಿದ್ದರೆ ನಿಜವಾದದು ಎಂದು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //3 ಸಂಖ್ಯೆಗಳನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ.    // >>> AnyInt((float)5L, (float)2L, (float)7L)
    // (true)
    // >>> AnyInt((float)3L, (float)2L, (float)2L)
    // (false)
    // >>> AnyInt((float)3L, (float)-2L, (float)1L)
    // (true)
    // >>> AnyInt((3.6f), (-2.2f), (float)2L)
    // (false)
    public static bool AnyInt(float x, float y, float z) {
","public static bool AnyInt(float x, float y, float z) {
        if (x == Math.Round(x) && y == Math.Round(y) && z == Math.Round(z)) {
            if (x == y + z || y == x + z || z == x + y) {
                return true;
            }
        }
        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AnyInt((float)2L, (float)3L, (float)1L) == (true));
    Debug.Assert(AnyInt((2.5f), (float)2L, (float)3L) == (false));
    Debug.Assert(AnyInt((1.5f), (float)5L, (3.5f)) == (false));
    Debug.Assert(AnyInt((float)2L, (float)6L, (float)2L) == (false));
    Debug.Assert(AnyInt((float)4L, (float)2L, (float)2L) == (true));
    Debug.Assert(AnyInt((2.2f), (2.2f), (2.2f)) == (false));
    Debug.Assert(AnyInt((float)-4L, (float)6L, (float)2L) == (true));
    Debug.Assert(AnyInt((float)2L, (float)1L, (float)1L) == (true));
    Debug.Assert(AnyInt((float)3L, (float)4L, (float)7L) == (true));
    Debug.Assert(AnyInt((3.0f), (float)4L, (float)7L) == (false));
    }

}
"
HumanEval_93,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಅಕ್ಷರಗಳನ್ನು ಮಾತ್ರ ಊಹಿಸಿ.    //ಇಂಗ್ಲಿಷ್ ಅಕ್ಷರಮಾಲೆಯ ಸ್ವರ.    //ಆ ಸಂದೇಶದ ಮುಂದೆ 2 ಸ್ಥಳಗಳಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುವ ಅಕ್ಷರದೊಂದಿಗೆ ಸಂದೇಶ     // ರಲ್ಲಿನ ಎಲ್ಲಾ ಸ್ವರಗಳನ್ನು ಬದಲಾಯಿಸುತ್ತದೆ.    //ಒಂದು ಸಂದೇಶವನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ, ಮತ್ತು ಅಂತಹ ಒಂದು     // >>> Encode((""test""))
    // (""TGST"")
    // >>> Encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    public static string Encode(string message) {
","public static string Encode(string message) {
    // Define vowels and their replacements
    Dictionary<char, char> vowelReplacement = new Dictionary<char, char>
    {
        { 'a', 'c' },
        { 'e', 'g' },
        { 'i', 'k' },
        { 'o', 'q' },
        { 'u', 'w' },
        { 'A', 'C' },
        { 'E', 'G' },
        { 'I', 'K' },
        { 'O', 'Q' },
        { 'U', 'W' }
    };

    StringBuilder encodedMessage = new StringBuilder();

    foreach (char c in message) {
        if (char.IsLetter(c)) {
            // Swap case
            char swappedCaseChar = char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c);

            // Replace vowels according to the defined map
            if (vowelReplacement.ContainsKey(swappedCaseChar)) {
                encodedMessage.Append(vowelReplacement[swappedCaseChar]);
            } else {
                encodedMessage.Append(swappedCaseChar);
            }
        } else {
            // Non-letter characters should be appended as-is (if necessary)
            encodedMessage.Append(c);
        }
    }

    return encodedMessage.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encode((""TEST"")).Equals((""tgst"")));
    Debug.Assert(Encode((""Mudasir"")).Equals((""mWDCSKR"")));
    Debug.Assert(Encode((""YES"")).Equals((""ygs"")));
    Debug.Assert(Encode((""This is a message"")).Equals((""tHKS KS C MGSSCGG"")));
    Debug.Assert(Encode((""I DoNt KnOw WhAt tO WrItE"")).Equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ನೀವು ದೊಡ್ಡ ಅವಿಭಾಜ್ಯ ಮೌಲ್ಯವನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು ಮತ್ತು ಅದರ ಅಂಕೆಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.    //ನಿಮಗೆ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ.    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L})))
    // (10L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L})))
    // (25L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L})))
    // (13L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L})))
    // (11L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L})))
    // (3L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L})))
    // (7L)
    public static long Skjkasdkd(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long Skjkasdkd(List<long> lst) {
        long largestPrime = -1;

        foreach (var num in lst) {
            if (IsPrime(num) && num > largestPrime) {
                largestPrime = num;
            }
        }

        if (largestPrime == -1) return 0;

        return SumOfDigits(largestPrime);
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;

        if (number % 2 == 0 || number % 3 == 0) return false;

        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }

        return true;
    }

    private static long SumOfDigits(long number) {
        long sum = 0;
        while (number != 0) {
            sum += number % 10;
            number /= 10;
        }
        return sum;
    }
}

// Example of usage:
// var result = Problem.Skjkasdkd(new List<long> {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3});
// Console.WriteLine(result); // Output will be 10","    }
    public static void Main(string[] args) {
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L}))) == (10L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L}))) == (25L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L}))) == (13L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L}))) == (11L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L}))) == (3L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L}))) == (7L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L, (long)123456L, (long)127L, (long)7L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)127L, (long)97L, (long)8192L}))) == (10L));
    }

}
"
HumanEval_95,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಕೊಟ್ಟಿರುವ ನಿಘಂಟು ಖಾಲಿಯಾಗಿದೆ ಎಂದು ಕಾರ್ಯವು ತಪ್ಪು ಎಂದು ಹಿಂತಿರುಗಬೇಕು.    //case ಅಥವಾ ಎಲ್ಲಾ ಕೀಲಿಗಳು ದೊಡ್ಡಕ್ಷರದಲ್ಲಿ ಸ್ಟ್ರಿಂಗ್ಗಳಾಗಿವೆ, ಇಲ್ಲದಿದ್ದರೆ false ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಒಂದು ನಿಘಂಟನ್ನು ನೀಡಿದರೆ, ಎಲ್ಲಾ ಕೀಲಿಗಳು ಕಡಿಮೆ  ನಲ್ಲಿನ ಸ್ಟ್ರಿಂಗ್ಗಳಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿಸಿ.    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""b"", ""banana""}}))
    // (true)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""A"", ""banana""}, {""B"", ""banana""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {8L, ""banana""}, {""a"", ""apple""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))
    // (true)
    public static bool CheckDictCase(Dictionary<string,string> dict) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool CheckDictCase(Dictionary<string, string> dict)
    {
        if (dict.Count == 0)
            return false;

        bool allLower = true;
        bool allUpper = true;

        foreach (var key in dict.Keys)
        {
            if (key != key.ToLower())
                allLower = false;
            if (key != key.ToUpper())
                allUpper = false;
        }

        return allLower || allUpper;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""b"", ""banana""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""fruit"", ""Orange""}, {""taste"", ""Sweet""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>())) == (false));
    }

}
"
HumanEval_96,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳು ಮತ್ತು n ಗಿಂತ ಕಡಿಮೆ ಇರುವ ಪೂರ್ಣಾಂಕಗಳು.    //ಒಂದು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕವನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಮೊದಲ n ನ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸಿ     // >>> CountUpTo((5L))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    // >>> CountUpTo((11L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))
    // >>> CountUpTo((0L))
    // (new List<long>())
    // >>> CountUpTo((20L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))
    // >>> CountUpTo((1L))
    // (new List<long>())
    // >>> CountUpTo((18L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))
    public static List<long> CountUpTo(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> CountUpTo(long n) {
        List<long> primes = new List<long>();
        if (n <= 2) return primes;

        // Check for prime numbers from 2 up to n-1
        for (long i = 2; i < n; i++) {
            if (IsPrime(i)) {
                primes.Add(i);
            }
        }

        return primes;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number == 2) return true;

        long boundary = (long)Math.Sqrt(number);

        for (long i = 2; i <= boundary; i++) {
            if (number % i == 0) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpTo((5L)).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(CountUpTo((6L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((7L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((10L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))));
    Debug.Assert(CountUpTo((0L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((22L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))));
    Debug.Assert(CountUpTo((1L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(CountUpTo((47L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L}))));
    Debug.Assert(CountUpTo((101L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L, (long)47L, (long)53L, (long)59L, (long)61L, (long)67L, (long)71L, (long)73L, (long)79L, (long)83L, (long)89L, (long)97L}))));
    }

}
"
HumanEval_97,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಇನ್ಪುಟ್ ಯಾವಾಗಲೂ ಮಾನ್ಯವಾಗಿರುತ್ತದೆ ಎಂದು ಭಾವಿಸಿ.    //ಅವುಗಳ ಘಟಕ ಅಂಕಿಗಳ ಗುಣಾಂಕ.    //ಎರಡು ಪೂರ್ಣಾಂಕಗಳನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು  ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಕಾರ್ಯವನ್ನು ಪೂರ್ಣಗೊಳಿಸಿ.    // >>> Multiply((148L), (412L))
    // (16L)
    // >>> Multiply((19L), (28L))
    // (72L)
    // >>> Multiply((2020L), (1851L))
    // (0L)
    // >>> Multiply((14L), (-15L))
    // (20L)
    public static long Multiply(long a, long b) {
","public static long Multiply(long a, long b) {
    int unitDigitA = (int)(Math.Abs(a) % 10);
    int unitDigitB = (int)(Math.Abs(b) % 10);
    return (long)(unitDigitA * unitDigitB);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Multiply((148L), (412L)) == (16L));
    Debug.Assert(Multiply((19L), (28L)) == (72L));
    Debug.Assert(Multiply((2020L), (1851L)) == (0L));
    Debug.Assert(Multiply((14L), (-15L)) == (20L));
    Debug.Assert(Multiply((76L), (67L)) == (42L));
    Debug.Assert(Multiply((17L), (27L)) == (49L));
    Debug.Assert(Multiply((0L), (1L)) == (0L));
    Debug.Assert(Multiply((0L), (0L)) == (0L));
    }

}
"
HumanEval_98,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ನೀಡಿದರೆ, ದೊಡ್ಡಕ್ಷರ ಸ್ವರಗಳ ಸಂಖ್ಯೆಯನ್ನು ಸಹ ಸೂಚ್ಯಂಕಗಳಲ್ಲಿ ಎಣಿಸಿ.    // >>> CountUpper((""aBCdEf""))
    // (1L)
    // >>> CountUpper((""abcdefg""))
    // (0L)
    // >>> CountUpper((""dBBE""))
    // (0L)
    public static long CountUpper(string s) {
","using System;

class Problem {
    public static long CountUpper(string s) {
        long count = 0;
        for (int i = 0; i < s.Length; i += 2) {
            if (""AEIOU"".Contains(s[i])) {
                count++;
            }
        }
        return count;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CountUpper(""aBCdEf"")); // Output: 1
        Console.WriteLine(CountUpper(""abcdefg"")); // Output: 0
        Console.WriteLine(CountUpper(""dBBE"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpper((""aBCdEf"")) == (1L));
    Debug.Assert(CountUpper((""abcdefg"")) == (0L));
    Debug.Assert(CountUpper((""dBBE"")) == (0L));
    Debug.Assert(CountUpper((""B"")) == (0L));
    Debug.Assert(CountUpper((""U"")) == (1L));
    Debug.Assert(CountUpper(("""")) == (0L));
    Debug.Assert(CountUpper((""EEEE"")) == (2L));
    }

}
"
HumanEval_99,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಎರಡು ಪೂರ್ಣಾಂಕಗಳಿಂದ, ಅದನ್ನು ಶೂನ್ಯದಿಂದ ಸುತ್ತುವರಿಯಿರಿ.    //ಮತ್ತು ಅದಕ್ಕೆ ಸಮೀಪವಿರುವ ಪೂರ್ಣಾಂಕವನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ. ಸಂಖ್ಯೆ ಸಮದೂರದಲ್ಲಿದ್ದರೆ     //ಒಂದು ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಮೌಲ್ಯವನ್ನು (ಸ್ಟ್ರಿಂಗ್) ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ     // >>> ClosestInteger((""10""))
    // (10L)
    // >>> ClosestInteger((""15.3""))
    // (15L)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    public static long ClosestInteger(string value) {
","public static long ClosestInteger(string value) {
    double number = double.Parse(value);
    return (long)Math.Round(number, MidpointRounding.AwayFromZero);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ClosestInteger((""10"")) == (10L));
    Debug.Assert(ClosestInteger((""14.5"")) == (15L));
    Debug.Assert(ClosestInteger((""-15.5"")) == (-16L));
    Debug.Assert(ClosestInteger((""15.3"")) == (15L));
    Debug.Assert(ClosestInteger((""0"")) == (0L));
    }

}
"
HumanEval_100,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //i ಮಟ್ಟದಲ್ಲಿ ಕಲ್ಲುಗಳ ಸಂಖ್ಯೆಯನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ (i+1).    //ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿ ಪ್ರತಿ ಮಟ್ಟದಲ್ಲಿ ಕಲ್ಲುಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, ಅಲ್ಲಿ ಅಂಶವು ಸೂಚ್ಯಂಕದಲ್ಲಿ     //- ಮುಂದಿನ ಸಮ ಸಂಖ್ಯೆಯ n ಸಮ ವೇಳೆ.    //- n ಬೆಸವಾಗಿದ್ದರೆ ಮುಂದಿನ ಬೆಸ ಸಂಖ್ಯೆ.    //ಮುಂದಿನ ಹಂತದಲ್ಲಿ ಕಲ್ಲುಗಳ ಸಂಖ್ಯೆಃ     //ಮೊದಲ ಹಂತದಲ್ಲಿ n ಕಲ್ಲುಗಳು ಇವೆ.    //ಒಂದು ಸಕಾರಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ಅನ್ನು ನೀಡಿದರೆ, ನೀವು n ಮಟ್ಟದ ಕಲ್ಲುಗಳ ರಾಶಿಯನ್ನು ಮಾಡಬೇಕು.    // >>> MakeAPile((3L))
    // (new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))
    public static List<long> MakeAPile(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> MakeAPile(long n) {
        List<long> pile = new List<long>();
        long currentStones = n;
        
        for (long i = 0; i < n; i++) {
            pile.Add(currentStones);
            currentStones += (n % 2 == 0) ? 2 : 2;
        }

        return pile;
    }
    
    static void Main(string[] args) {
        List<long> result = MakeAPile(3L);
        Console.WriteLine(string.Join("", "", result));  // Output: 3, 5, 7
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakeAPile((3L)).Equals((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))));
    Debug.Assert(MakeAPile((4L)).Equals((new List<long>(new long[]{(long)4L, (long)6L, (long)8L, (long)10L}))));
    Debug.Assert(MakeAPile((5L)).Equals((new List<long>(new long[]{(long)5L, (long)7L, (long)9L, (long)11L, (long)13L}))));
    Debug.Assert(MakeAPile((6L)).Equals((new List<long>(new long[]{(long)6L, (long)8L, (long)10L, (long)12L, (long)14L, (long)16L}))));
    Debug.Assert(MakeAPile((8L)).Equals((new List<long>(new long[]{(long)8L, (long)10L, (long)12L, (long)14L, (long)16L, (long)18L, (long)20L, (long)22L}))));
    }

}
"
HumanEval_101,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಪದಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸಲು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಪದಗಳಾಗಿ ವಿಭಜಿಸಲು.    //ನಿಮಗೆ ಅಲ್ಪವಿರಾಮ ಅಥವಾ ಅಂತರಗಳಿಂದ ಬೇರ್ಪಡಿಸಲಾದ ಪದಗಳ ಒಂದು ಸರಣಿಯನ್ನು ನೀಡಲಾಗುವುದು. ನಿಮ್ಮ ಕಾರ್ಯವು     // >>> WordsString((""Hi, my name is John""))
    // (new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))
    // >>> WordsString((""One, two, three, four, five, six""))
    // (new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))
    public static List<string> WordsString(string s) {
","public static List<string> WordsString(string s) {
    char[] separators = new char[] { ' ', ',' };
    var words = s.Split(separators, StringSplitOptions.RemoveEmptyEntries);
    return new List<string>(words);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsString((""Hi, my name is John"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))));
    Debug.Assert(WordsString((""One, two, three, four, five, six"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString((""Hi, my name"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name""}))));
    Debug.Assert(WordsString((""One,, two, three, four, five, six,"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString(("""")).Equals((new List<string>())));
    Debug.Assert(WordsString((""ahmed     , gamal"")).Equals((new List<string>(new string[]{(string)""ahmed"", (string)""gamal""}))));
    }

}
"
HumanEval_102,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಅಂತಹ ಯಾವುದೇ ಸಂಖ್ಯೆ ಇಲ್ಲ, ಆಗ ಕಾರ್ಯವು -1 ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.    //[x, y] ವ್ಯಾಪ್ತಿಯಲ್ಲಿರುವ ಅತಿದೊಡ್ಡ ಸಮ ಸಮ ಪೂರ್ಣಾಂಕ ಸಂಖ್ಯೆ.    //ಈ ಕಾರ್ಯವು ಎರಡು ಧನಾತ್ಮಕ ಸಂಖ್ಯೆಗಳನ್ನು x ಮತ್ತು y ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ ಮತ್ತು  ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ    // >>> ChooseNum((12L), (15L))
    // (14L)
    // >>> ChooseNum((13L), (12L))
    // (-1L)
    public static long ChooseNum(long x, long y) {
","if (x > y) {
            return -1;
        }
        
        // Ensure x is the bigger one for simplicity
        if (x > y) {
            long temp = x;
            x = y;
            y = temp;
        }
        
        // Start searching from y down to x
        for (long i = y; i >= x; i--) {
            if (i % 2 == 0) {
                return i;
            }
        }
        
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChooseNum((12L), (15L)) == (14L));
    Debug.Assert(ChooseNum((13L), (12L)) == (-1L));
    Debug.Assert(ChooseNum((33L), (12354L)) == (12354L));
    Debug.Assert(ChooseNum((5234L), (5233L)) == (-1L));
    Debug.Assert(ChooseNum((6L), (29L)) == (28L));
    Debug.Assert(ChooseNum((27L), (10L)) == (-1L));
    Debug.Assert(ChooseNum((7L), (7L)) == (-1L));
    Debug.Assert(ChooseNum((546L), (546L)) == (546L));
    }

}
"
HumanEval_104,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಗಮನಿಸಿ: ಹಿಂದಿರುಗಿಸಿದ ಪಟ್ಟಿಯನ್ನು ಹೆಚ್ಚುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಬೇಕು.    //ಯಾವುದೇ ಜೋಡಿ ಅಂಕಿಯ ಅಂಶಗಳಿಲ್ಲ.    //ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ x. ಎಲ್ಲಾ  ನ ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ    // >>> UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L})))
    // (new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))
    // >>> UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L})))
    // (new List<long>())
    public static List<long> UniqueDigits(List<long> x) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> UniqueDigits(List<long> x) {
        return x.Where(n => !n.ToString().Any(c => ""02468"".Contains(c)))
                .OrderBy(n => n)
                .ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L}))).Equals((new List<long>())));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)12345L, (long)2033L, (long)111L, (long)151L}))).Equals((new List<long>(new long[]{(long)111L, (long)151L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)135L, (long)103L, (long)31L}))).Equals((new List<long>(new long[]{(long)31L, (long)135L}))));
    }

}
"
HumanEval_105,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //""ಒಂದು"", ""ಎರಡು"", ""ಮೂರು"", ""ನಾಲ್ಕು"", ""ಐದು"", ""ಆರು"", ""ಏಳು"", ""ಎಂಟು"", ""ಒಂಬತ್ತು""     //ಫಲಿತಾಂಶದ ಪಟ್ಟಿಯನ್ನು ಹಿಮ್ಮುಖಗೊಳಿಸಿ, ನಂತರ ಪ್ರತಿ ಅಂಕಿಯನ್ನು ಅದರ ಅನುಗುಣವಾದ ಹೆಸರಿನಿಂದ     //ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, 1 ಮತ್ತು 9 ರ ನಡುವಿನ ಪೂರ್ಣಾಂಕಗಳನ್ನು ವಿಂಗಡಿಸಿ,    // >>> ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L})))
    // (new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))
    // If the list is empty, return an empty list:
    // >>> ByLength((new List<long>()))
    // (new List<string>())
    // If the list has any strange number ignore it:
    // >>> ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L})))
    // (new List<string>(new string[]{(string)""One""}))
    public static List<string> ByLength(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ByLength(List<long> arr) {
        // Define a dictionary to map numbers to their names.
        var digitToName = new Dictionary<long, string> {
            {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""},
            {5, ""Five""}, {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}
        };

        // Filter the numbers that are between 1 and 9.
        var filtered = arr.Where(x => digitToName.ContainsKey(x)).ToList();

        // Sort the filtered numbers.
        filtered.Sort();

        // Reverse the list.
        filtered.Reverse();

        // Map the numbers to their names using the dictionary.
        return filtered.Select(x => digitToName[x]).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L}))).Equals((new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>())).Equals((new List<string>())));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L}))).Equals((new List<string>(new string[]{(string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)3L, (long)2L}))).Equals((new List<string>(new string[]{(string)""Three"", (string)""Two"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)9L, (long)4L, (long)8L}))).Equals((new List<string>(new string[]{(string)""Nine"", (string)""Eight"", (string)""Four""}))));
    }

}
"
HumanEval_106,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //i ನ ಅಂಶವು 1 ರಿಂದ i ಗೆ ಸಂಖ್ಯೆಗಳ ಗುಣಾಕಾರವಾಗಿದೆ (1 * 2 * . . . * i).    //i 1 ರಿಂದ ಪ್ರಾರಂಭವಾಗುತ್ತದೆ.    //ಅಥವಾ 1 ರಿಂದ i ರವರೆಗಿನ ಸಂಖ್ಯೆಗಳ ಮೊತ್ತ.    //ಮತ್ತು n ಗಾತ್ರದ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, ಅಂದರೆ ಸೂಚ್ಯಂಕ i ನಲ್ಲಿನ ಅಂಶದ ಮೌಲ್ಯವು i ನ ಅಂಶವಾಗಿದೆ, ಅದು i ಕೂಡಿದ್ದರೆ     //n ಅನ್ನು ನಿಯತಾಂಕವಾಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಕಾರ್ಯವನ್ನು f ಅನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸಿ,     // >>> F((5L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))
    public static List<long> F(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> F(long n) {
        List<long> result = new List<long>();

        for (long i = 1; i <= n; i++) {
            if (i % 2 == 0) {
                result.Add(Factorial(i));
            } else {
                result.Add(SumUpTo(i));
            }
        }
        
        return result;
    }

    private static long Factorial(long number) {
        if (number == 0) return 1;
        long factorial = 1;
        for (long i = 1; i <= number; i++) {
            factorial *= i;
        }
        return factorial;
    }

    private static long SumUpTo(long number) {
        return (number * (number + 1)) / 2;
    }

    static void Main(string[] args) {
        List<long> result = F(5);
        foreach (long val in result) {
            Console.WriteLine(val);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(F((5L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))));
    Debug.Assert(F((7L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L, (long)720L, (long)28L}))));
    Debug.Assert(F((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(F((3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L}))));
    }

}
"
HumanEval_107,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ 1:     //ವ್ಯಾಪ್ತಿಯಲ್ಲಿರುವ ಪೂರ್ಣಾಂಕ ಪಾಲಿಂಡ್ರೋಮ್ಗಳು ((1, n), ಸೇರಿದಂತೆ.    //ಒಂದು ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಲಾಗಿದೆ, ಒಂದು ಟುಪಲ್ ಅನ್ನು ಹಿಂತಿರುಗಿ ಅದು ಸಮ ಮತ್ತು ಬೆಸ ಸಂಖ್ಯೆಯನ್ನು ಹೊಂದಿದೆ     // >>> EvenOddPalindrome((3L))
    // (Tuple.Create(1L, 2L))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> EvenOddPalindrome((12L))
    // (Tuple.Create(4L, 6L))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    public static Tuple<long, long> EvenOddPalindrome(long n) {
","public static Tuple<long, long> EvenOddPalindrome(long n) {
    long evenCount = 0;
    long oddCount = 0;

    for (long i = 1; i <= n; i++) {
        if (IsPalindrome(i)) {
            if (i % 2 == 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return Tuple.Create(evenCount, oddCount);
}

private static bool IsPalindrome(long number) {
    long original = number;
    long reversed = 0;

    while (number > 0) {
        long digit = number % 10;
        reversed = reversed * 10 + digit;
        number /= 10;
    }

    return original == reversed;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddPalindrome((123L)).Equals((Tuple.Create(8L, 13L))));
    Debug.Assert(EvenOddPalindrome((12L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((3L)).Equals((Tuple.Create(1L, 2L))));
    Debug.Assert(EvenOddPalindrome((63L)).Equals((Tuple.Create(6L, 8L))));
    Debug.Assert(EvenOddPalindrome((25L)).Equals((Tuple.Create(5L, 6L))));
    Debug.Assert(EvenOddPalindrome((19L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((9L)).Equals((Tuple.Create(4L, 5L))));
    Debug.Assert(EvenOddPalindrome((1L)).Equals((Tuple.Create(0L, 1L))));
    }

}
"
HumanEval_108,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ -123 ಅಂಕಿಗಳು -1, 2, ಮತ್ತು 3     //ಒಂದು ಸಂಖ್ಯೆಯು ಋಣಾತ್ಮಕವಾಗಿದ್ದರೆ, ಅದರ ಮೊದಲ ಸಹಿ ಮಾಡಿದ ಅಂಕಿಯು ಋಣಾತ್ಮಕವಾಗಿರುತ್ತದೆ:    //ಅಂಶಗಳ ಸಂಖ್ಯೆ, ಇದರಲ್ಲಿ ಅಂಕೆಗಳ ಮೊತ್ತವು > 0 ಆಗಿದೆ.    //ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ಹಿಂದಿರುಗಿಸುವ count_nums ಎಂಬ ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ     // >>> CountNums((new List<long>()))
    // (0L)
    // >>> CountNums((new List<long>(new long[]{(long)-1L, (long)11L, (long)-11L})))
    // (1L)
    // >>> CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L})))
    // (3L)
    public static long CountNums(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long CountNums(List<long> arr) {
        long count = 0;

        foreach (long number in arr) {
            long sumOfDigits = 0;
            long num = number;
            
            while (num != 0) {
                long digit = num % 10;
                sumOfDigits += digit;
                num /= 10;
            }

            if (sumOfDigits > 0) {
                count++;
            }
        }

        return count;
    }

    static void Main(string[] args) {
        // Test cases
        Console.WriteLine(CountNums(new List<long>())); // (0L)
        Console.WriteLine(CountNums(new List<long> { -1L, 11L, -11L })); // (1L)
        Console.WriteLine(CountNums(new List<long> { 1L, 1L, 2L })); // (3L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountNums((new List<long>())) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)-1L, (long)-2L, (long)0L}))) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L, (long)-2L, (long)3L, (long)4L, (long)5L}))) == (6L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)6L, (long)9L, (long)-6L, (long)0L, (long)1L, (long)5L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)100L, (long)98L, (long)-7L, (long)1L, (long)-1L}))) == (4L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)12L, (long)23L, (long)34L, (long)-45L, (long)-56L, (long)0L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L}))) == (1L));
    }

}
"
HumanEval_109,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಗಮನಿಸಿ: ನೀಡಲಾದ ಪಟ್ಟಿಯು ಅನನ್ಯ ಅಂಶಗಳನ್ನು ಹೊಂದಿರುವುದು ಖಾತರಿಪಡಿಸುತ್ತದೆ.    //ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯು ಖಾಲಿಯಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ನಂತರ true ಅನ್ನು ಹಿಂತಿರುಗಿ ಇಲ್ಲದಿದ್ದರೆ false ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ಮೇಲಿನ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ನಿರ್ವಹಿಸುವ ಮೂಲಕ ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಪಡೆಯುವುದು ಸಾಧ್ಯವಿದ್ದರೆ     //ಪಟ್ಟಿಯಲ್ಲಿನ ಆರಂಭಿಕ ಸ್ಥಾನ ಅಂದರೆ 0 ನೇ ಸೂಚ್ಯಂಕ.    //ಪಟ್ಟಿಯ ಕೊನೆಯ ಅಂಶವನ್ನು  ಗೆ ಸರಿಸಲಾಗುವುದು    //ಒಂದು ಬಲಕ್ಕೆ ಚಲಿಸುವ ಕಾರ್ಯಾಚರಣೆಯು ಪಟ್ಟಿಯ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ಒಂದು ಮೂಲಕ ಚಲಿಸುವಂತೆ ಮಾಡುತ್ತದೆ.    //ನೀವು ಬಲ ಶಿಫ್ಟ್ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ಯಾವುದೇ ಸಂಖ್ಯೆಯ ಬಾರಿ ನಿರ್ವಹಿಸಲು ಅನುಮತಿಸಲಾಗಿದೆ.    //ಈ ಕೆಳಗಿನ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ನೀಡಿರುವ ಪಟ್ಟಿಯಲ್ಲಿ ಸೇರಿಸಲಾಗಿದೆಃ     // ಅನ್ನು ನಿರ್ವಹಿಸುವ ಮೂಲಕ ಪಟ್ಟಿಯನ್ನು ಇಳಿಕೆಯಾಗದ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಲು ಸಾಧ್ಯವಿದೆ.    //ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸಂಖ್ಯೆಗಳನ್ನು ಯಾದೃಚ್ಛಿಕವಾಗಿ ಆದೇಶಿಸಲಾಗುತ್ತದೆ. ನಿಮ್ಮ ಕಾರ್ಯವು     //ನಾವು N ಪೂರ್ಣಾಂಕಗಳ arr[1], arr[2], ..., arr[N] ನ ಒಂದು ಪಟ್ಟಿಯನ್ನು ಹೊಂದಿದ್ದೇವೆ.    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L})))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L})))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    public static bool MoveOneBall(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool MoveOneBall(List<long> arr) {
        if (arr.Count == 0) return true;

        int n = arr.Count;
        int descentCount = 0;
        int indexOfDescent = -1;

        // Find number of descents in the array
        for (int i = 0; i < n; i++) {
            if (arr[i] > arr[(i + 1) % n]) {
                descentCount++;
                indexOfDescent = (i + 1) % n;
            }
            if (descentCount > 1) {
                return false;
            }
        }

        // No descents means the array is already sorted
        if (descentCount == 0) {
            return true;
        }

        // Check if the single descent allows a circular sorted order
        for (int i = 0; i < n; i++) {
            if (arr[(indexOfDescent + i) % n] > arr[(indexOfDescent + i + 1) % n]) {
                return false;
            }
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)10L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)4L, (long)3L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>())) == (true));
    }

}
"
HumanEval_110,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಇಲ್ಲದಿದ್ದರೆ, ""NO"" ಅನ್ನು ಹಿಂತಿರುಗಿ.    //lst1 ನ ಎಲ್ಲಾ ಅಂಶಗಳು ಸಮವಾಗಿದ್ದರೆ, ""YES"" ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ಇದು ಸಾಧ್ಯ ವೇಳೆ ಅಂಶಗಳನ್ನು ವಿನಿಮಯ ನಡುವೆ lst1 ಮತ್ತು lst2 ಮಾಡಲು     //lst1 ಮತ್ತು lst2 ನಡುವೆ ವಿನಿಮಯ ಮಾಡಿಕೊಳ್ಳುವ ಅಂಶಗಳ ಸಂಖ್ಯೆಗೆ ಯಾವುದೇ ಮಿತಿಯಿಲ್ಲ.    //ವು ಕೇವಲ ಸಮ ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ಮಾಡಲು.    //ಮತ್ತು ಅಂಶಗಳ ವಿನಿಮಯವನ್ನು ನಿರ್ವಹಿಸಲು ಸಾಧ್ಯವಿದೆಯೇ ಎಂದು ನಿರ್ಧರಿಸುತ್ತದೆ     //ಈ ಸಮಸ್ಯೆಯಲ್ಲಿ, ನೀವು ಎರಡು ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಗಳನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸುತ್ತೀರಿ,     // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (""YES"")
    // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L})))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    public static string Exchange(List<long> lst1, List<long> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string Exchange(List<long> lst1, List<long> lst2)
    {
        int countOfOddsInLst1 = lst1.Count(x => x % 2 != 0);
        int countOfEvensInLst2 = lst2.Count(x => x % 2 == 0);

        return countOfOddsInLst1 <= countOfEvensInLst2 ? ""YES"" : ""NO"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)2L, (long)1L, (long)4L, (long)3L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)3L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)3L, (long)2L, (long)6L, (long)1L, (long)8L, (long)9L})), (new List<long>(new long[]{(long)3L, (long)5L, (long)5L, (long)1L, (long)1L, (long)1L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)100L, (long)200L})), (new List<long>(new long[]{(long)200L, (long)200L}))).Equals((""YES"")));
    }

}
"
HumanEval_111,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಹಲವಾರು ಅಕ್ಷರಗಳು ಒಂದೇ ರೀತಿಯ ಸಂಭವವನ್ನು ಹೊಂದಿದ್ದರೆ, ಅವೆಲ್ಲವನ್ನೂ ಹಿಂತಿರುಗಿ.    //ಹೆಚ್ಚು ಪುನರಾವರ್ತನೆಯಾಗುವ ಅಕ್ಷರ ಮತ್ತು ಅದಕ್ಕೆ ಅನುಗುಣವಾದ ಸಂಖ್ಯೆಯನ್ನು ಹೊಂದಿರುವ ಅಕ್ಷರದ.    //ಒಂದು ಅಕ್ಷರವನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ನೀಡಲಾಗಿದೆ, ಒಂದು ನಿಘಂಟನ್ನು ಹಿಂತಿರುಗಿಸಿ     // >>> Histogram((""a b c""))
    // (new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}})
    // >>> Histogram((""a b b a""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""a b c a b""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""b b b b a""))
    // (new Dictionary<string,long>(){{""b"", 4L}})
    // >>> Histogram((""""))
    // (new Dictionary<string,long>())
    public static Dictionary<string,long> Histogram(string test) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Dictionary<string, long> Histogram(string test) {
        if (string.IsNullOrWhiteSpace(test)) {
            return new Dictionary<string, long>();
        }

        var words = test.Split(' ');
        var letterCounts = new Dictionary<string, long>();

        // Count the occurrences of each letter
        foreach (var word in words) {
            if (letterCounts.ContainsKey(word)) {
                letterCounts[word]++;
            } else {
                letterCounts[word] = 1;
            }
        }

        // Determine the maximum count
        long maxCount = letterCounts.Values.Max();

        // Create a dictionary for letters with the maximum count
        var result = letterCounts.Where(pair => pair.Value == maxCount)
                                 .ToDictionary(pair => pair.Key, pair => pair.Value);

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Histogram((""a b b a"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c a b"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c d g"")).Equals((new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}, {""d"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""b b b b a"")).Equals((new Dictionary<string,long>(){{""b"", 4L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram(("""")).Equals((new Dictionary<string,long>())));
    Debug.Assert(Histogram((""a"")).Equals((new Dictionary<string,long>(){{""a"", 1L}})));
    }

}
"
HumanEval_112,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ     //ನೀವು ಫಲಿತಾಂಶದ ಸ್ಟ್ರಿಂಗ್ ಮತ್ತು ಚೆಕ್ಗಾಗಿ true/false ಅನ್ನು ಒಳಗೊಂಡಿರುವ ಟುಪಲ್ ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.    //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಪಾಲಿಂಡ್ರೋಮ್ ಎಂದು ಕರೆಯಲಾಗುತ್ತದೆ, ಅದು ಹಿಂದಕ್ಕೆ ಮತ್ತು ಮುಂದಕ್ಕೆ ಒಂದೇ ರೀತಿ ಓದುತ್ತದೆ.    //ನಂತರ ಫಲಿತಾಂಶದ ಸ್ಟ್ರಿಂಗ್ ಪಾಲಿಂಡ್ರೋಮ್ ಆಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ.    //ನಮಗೆ s ಮತ್ತು c ಎಂಬ ಎರಡು ಸ್ಟ್ರಿಂಗ್ ಗಳು ನೀಡಲಾಗಿದೆ, ನೀವು s ನಲ್ಲಿರುವ ಎಲ್ಲಾ ಅಕ್ಷರಗಳನ್ನು ಅಳಿಸಬೇಕು ಅದು c ನಲ್ಲಿರುವ ಯಾವುದೇ ಅಕ್ಷರಕ್ಕೆ ಸಮನಾಗಿರುತ್ತದೆ     //ಕಾರ್ಯ     // >>> ReverseDelete((""abcde""), (""ae""))
    // (Tuple.Create(""bcd"", false))
    // >>> ReverseDelete((""abcdef""), (""b""))
    // (Tuple.Create(""acdef"", false))
    // >>> ReverseDelete((""abcdedcba""), (""ab""))
    // (Tuple.Create(""cdedc"", true))
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
","using System;
using System.Linq;

class Problem {
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
        // Remove characters from 's' that are in 'c'
        string resultString = new string(s.Where(ch => !c.Contains(ch)).ToArray());
        
        // Check if the result string is a palindrome
        bool isPalindrome = resultString.SequenceEqual(resultString.Reverse());

        // Return the result string and palindrome check as a tuple
        return Tuple.Create(resultString, isPalindrome);
    }

    // Example usage
    static void Main(string[] args) {
        var example1 = ReverseDelete(""abcde"", ""ae"");
        Console.WriteLine($""(\""bcd\"", false) == ({example1.Item1}, {example1.Item2})"");

        var example2 = ReverseDelete(""abcdef"", ""b"");
        Console.WriteLine($""(\""acdef\"", false) == ({example2.Item1}, {example2.Item2})"");

        var example3 = ReverseDelete(""abcdedcba"", ""ab"");
        Console.WriteLine($""(\""cdedc\"", true) == ({example3.Item1}, {example3.Item2})"");
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ReverseDelete((""abcde""), (""ae"")).Equals((Tuple.Create(""bcd"", false))));
    Debug.Assert(ReverseDelete((""abcdef""), (""b"")).Equals((Tuple.Create(""acdef"", false))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""ab"")).Equals((Tuple.Create(""cdedc"", true))));
    Debug.Assert(ReverseDelete((""dwik""), (""w"")).Equals((Tuple.Create(""dik"", false))));
    Debug.Assert(ReverseDelete((""a""), (""a"")).Equals((Tuple.Create("""", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), ("""")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""v"")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""vabba""), (""v"")).Equals((Tuple.Create(""abba"", true))));
    Debug.Assert(ReverseDelete((""mamma""), (""mia"")).Equals((Tuple.Create("""", true))));
    }

}
"
HumanEval_113,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇನ್ಪುಟ್ನ i'th ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಬೆಸ ಅಂಕೆಗಳ ಸಂಖ್ಯೆ.    //ಇನ್ಪುಟ್ನ ಸ್ಟ್ರಿಂಗ್ i. "" ಅಲ್ಲಿ ಎಲ್ಲಾ i ಗಳನ್ನು ಸಂಖ್ಯೆಯಿಂದ ಬದಲಾಯಿಸಬೇಕು    //ಔಟ್ಪುಟ್ನ ಪ್ರತಿ ಅಂಶ i ""ಒಂದು  ರಲ್ಲಿ ಬೆಸ ಅಂಶಗಳ ಸಂಖ್ಯೆ ಇರಬೇಕು    //ಪ್ರತಿ ಸ್ಟ್ರಿಂಗ್ ಕೇವಲ ಅಂಕೆಗಳನ್ನು ಒಳಗೊಂಡಿರುವ ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ, ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ.    // >>> OddCount((new List<string>(new string[]{(string)""1234567""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))
    // >>> OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))
    public static List<string> OddCount(List<string> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> OddCount(List<string> lst)
    {
        List<string> result = new List<string>();
        foreach (var str in lst)
        {
            int oddCount = 0;
            foreach (var c in str)
            {
                if ((c - '0') % 2 != 0) // Check if the digit is odd
                {
                    oddCount++;
                }
            }

            string output = $""the number of odd elements {oddCount}n the str{oddCount}ng {oddCount} of the {oddCount}nput."";
            result.Add(output);
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""1234567""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""271"", (string)""137"", (string)""314""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (string)""the number of odd elements 2n the str2ng 2 of the 2nput.""}))));
    }

}
"
HumanEval_114,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ     //ಗಳು    //ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ಯಾವುದೇ ಖಾಲಿ ಅಲ್ಲದ ಉಪ-ಪಟ್ಟಿಯ ಕನಿಷ್ಠ ಮೊತ್ತವನ್ನು ಕಂಡುಹಿಡಿಯಿರಿ     // >>> Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L})))
    // (1L)
    // >>> Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L})))
    // (-6L)
    public static long Minsubarraysum(List<long> nums) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Minsubarraysum(List<long> nums) {
        long minSum = nums[0], currentSum = nums[0];
        
        for (int i = 1; i < nums.Count; i++) {
            currentSum = Math.Min(nums[i], currentSum + nums[i]);
            minSum = Math.Min(minSum, currentSum);
        }
        
        return minSum;
    }

    // Example usage
    public static void Main() {
        Console.WriteLine(Minsubarraysum(new List<long> { 2L, 3L, 4L, 1L, 2L, 4L })); // Output: 1L
        Console.WriteLine(Minsubarraysum(new List<long> { -1L, -2L, -3L }));         // Output: -6L
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L}))) == (1L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)2L, (long)-10L}))) == (-14L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-9999999999999999L}))) == (-9999999999999999L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)0L, (long)10L, (long)20L, (long)1000000L}))) == (0L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)10L, (long)11L, (long)13L, (long)8L, (long)3L, (long)4L}))) == (3L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-33L, (long)32L, (long)-1L, (long)0L, (long)-2L}))) == (-33L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-10L}))) == (-10L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)7L}))) == (7L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)1L, (long)-1L}))) == (-1L));
    }

}
"
HumanEval_115,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ 1:     //ನೀವು ಬಕೆಟ್ಗಳನ್ನು ಕಡಿಮೆ ಮಾಡಲು ಅಗತ್ಯವಿರುವ ಬಾರಿ ಔಟ್ಪುಟ್.     //ನಿಮ್ಮ ಕೆಲಸವೆಂದರೆ ಬಕೆಟ್ ಗಳನ್ನು ಬಳಸಿಕೊಂಡು ಬಾವಿಯನ್ನು ಖಾಲಿ ಮಾಡುವುದು.    //ಮತ್ತು ಎಲ್ಲಾ ಬಕೆಟ್ಗಳು ಒಂದೇ ಸಾಮರ್ಥ್ಯವನ್ನು ಹೊಂದಿವೆ.    //ಪ್ರತಿಯೊಂದು ಬಾವಿಯಲ್ಲಿಯೂ ಅದಕ್ಕೆ ತಕ್ಕಂತೆ ಒಂದು ಬಕೆಟ್ ಇದೆ, ಅದನ್ನು ನೀರನ್ನು ಹೊರತೆಗೆಯಲು ಬಳಸಬಹುದು,    //ಮತ್ತು ಪ್ರತಿ 1 ರೇಖೆಯು ಒಂದು ಏಕ ಘಟಕ ನೀರನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ.    //ನಿಮಗೆ ಒಂದು ಆಯತಾಕಾರದ ಗ್ರಿಡ್ ನೀಡಲಾಗಿದೆ. ಪ್ರತಿ ಸಾಲು ಒಂದೇ ಒಂದು ಬಾವಿಯನ್ನು ಪ್ರತಿನಿಧಿಸುತ್ತದೆ,     // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L))
    // (6L)
    // Example 2:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L))
    // (5L)
    // Example 3:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L))
    // (0L)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    public static long MaxFill(List<List<long>> grid, long capacity) {
","public static long MaxFill(List<List<long>> grid, long capacity) {
    long operations = 0;

    foreach (var row in grid) {
        long waterUnits = row.Sum();
        operations += waterUnits / capacity;
        if (waterUnits % capacity != 0) {
            operations++;
        }
    }

    return operations;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L)) == (6L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L)) == (5L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L)) == (0L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (2L)) == (4L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (9L)) == (2L));
    }

}
"
HumanEval_116,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಇದನ್ನು ಈ ರೀತಿ ಅನುಷ್ಠಾನಗೊಳಿಸಬೇಕು:    //ಒಂದೇ ರೀತಿಯ ಸಂಖ್ಯೆಯ ಒಂದುಗಳಿಗೆ, ದಶಮಾಂಶ ಮೌಲ್ಯದ ಆಧಾರದ ಮೇಲೆ ವಿಂಗಡಿಸಿ.    //ಅವುಗಳ ಬೈನರಿ ಪ್ರಾತಿನಿಧ್ಯದಲ್ಲಿ ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ಇರುವ ಒಂದುಗಳ ಸಂಖ್ಯೆ.    //ಈ ಕಟಾದಲ್ಲಿ, ನೀವು  ಪ್ರಕಾರ ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ವಿಂಗಡಿಸಬೇಕು    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))
    // (new List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))
    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))
    public static List<long> SortArray(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> SortArray(List<long> arr) {
        return arr.OrderBy(num => CountOnesInBinary(num))
                  .ThenBy(num => num)
                  .ToList();
    }

    private static int CountOnesInBinary(long num) {
        return Convert.ToString(num, 2).Count(c => c == '1');
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    }

}
"
HumanEval_117,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಗಮನಿಸಿ: ನೀವು ಇನ್ಪುಟ್ ಸ್ಟ್ರಿಂಗ್ ಅಕ್ಷರಗಳು ಮತ್ತು ಅಂತರಗಳನ್ನು ಮಾತ್ರ ಹೊಂದಿದೆ ಎಂದು ಭಾವಿಸಬಹುದು.    //ಸ್ಟ್ರಿಂಗ್ s ಖಾಲಿಯಾಗಿದ್ದರೆ, ಕಾರ್ಯವು ಖಾಲಿಯಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು.    //n ವ್ಯಂಜನಗಳು, ಈ ಪದಗಳು ಸ್ಟ್ರಿಂಗ್ s ನಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುವ ಕ್ರಮದಲ್ಲಿ.    //ಒಂದು ಕಾರ್ಯವು ಸ್ಟ್ರಿಂಗ್ s ಯಿಂದ ಎಲ್ಲಾ ಪದಗಳ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ ಅದು ನಿಖರವಾಗಿ     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ಮತ್ತು ಒಂದು ನೈಸರ್ಗಿಕ ಸಂಖ್ಯೆಯನ್ನು ನೀಡಿದರೆ, ನೀವು ಕಾರ್ಯಗತಗೊಳಿಸಲು ಕಾರ್ಯಗತಗೊಳಿಸಿದ್ದೀರಿ     // >>> SelectWords((""Mary had a little lamb""), (4L))
    // (new List<string>(new string[]{(string)""little""}))
    // >>> SelectWords((""Mary had a little lamb""), (3L))
    // (new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))
    // >>> SelectWords((""simple white space""), (2L))
    // (new List<string>())
    // >>> SelectWords((""Hello world""), (4L))
    // (new List<string>(new string[]{(string)""world""}))
    // >>> SelectWords((""Uncle sam""), (3L))
    // (new List<string>(new string[]{(string)""Uncle""}))
    public static List<string> SelectWords(string s, long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> SelectWords(string s, long n) {
        List<string> result = new List<string>();
        if (string.IsNullOrEmpty(s)) 
            return result;

        string[] words = s.Split(' ');
        string consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";

        foreach (string word in words) {
            int consonantCount = 0;
            foreach (char c in word) {
                if (consonants.Contains(c)) {
                    consonantCount++;
                }
            }

            if (consonantCount == n) {
                result.Add(word);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SelectWords((""Mary had a little lamb""), (4L)).Equals((new List<string>(new string[]{(string)""little""}))));
    Debug.Assert(SelectWords((""Mary had a little lamb""), (3L)).Equals((new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))));
    Debug.Assert(SelectWords((""simple white space""), (2L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""Hello world""), (4L)).Equals((new List<string>(new string[]{(string)""world""}))));
    Debug.Assert(SelectWords((""Uncle sam""), (3L)).Equals((new List<string>(new string[]{(string)""Uncle""}))));
    Debug.Assert(SelectWords((""""), (4L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""a b c d e f""), (1L)).Equals((new List<string>(new string[]{(string)""b"", (string)""c"", (string)""d"", (string)""f""}))));
    }

}
"
HumanEval_118,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಕೊಟ್ಟಿರುವ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿ ಇಂಗ್ಲಿಷ್ ಅಕ್ಷರ ಮಾತ್ರ ಇದೆ ಎಂದು ನೀವು ಭಾವಿಸಬಹುದು.    //ಮೇಲಿನ ಸ್ಥಿತಿಯನ್ನು ಪೂರೈಸಿದ ಯಾವುದೇ ಸ್ವರವನ್ನು ಹುಡುಕಿ.    //ಆರಂಭದಲ್ಲಿ ಮತ್ತು ಅಂತ್ಯದಲ್ಲಿನ ಸ್ವರಗಳು ಎಣಿಸುವುದಿಲ್ಲ. ನೀವು ಮಾಡದಿದ್ದರೆ ಖಾಲಿ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂತಿರುಗಿ     //ಪದದ ಬಲ ಭಾಗದಿಂದ ಎರಡು ವ್ಯಂಜನಗಳು (ಪ್ರಮಾಣದ ಸೂಕ್ಷ್ಮ).    //ನಿಮಗೆ ಒಂದು ಪದ ನೀಡಲಾಗಿದೆ. ನಿಮ್ಮ ಕಾರ್ಯವು  ನಡುವೆ ಇರುವ ಹತ್ತಿರದ ಸ್ವರವನ್ನು ಕಂಡುಹಿಡಿಯುವುದು    // >>> GetClosestVowel((""yogurt""))
    // (""u"")
    // >>> GetClosestVowel((""FULL""))
    // (""U"")
    // >>> GetClosestVowel((""quick""))
    // ("""")
    // >>> GetClosestVowel((""ab""))
    // ("""")
    public static string GetClosestVowel(string word) {
","using System;

class Problem {
    public static string GetClosestVowel(string word) {
        if (string.IsNullOrWhiteSpace(word) || word.Length < 3) {
            return """";
        }
        
        HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        
        for (int i = word.Length - 2; i > 0; i--) {
            if (vowels.Contains(word[i]) && 
                !vowels.Contains(word[i - 1]) && !vowels.Contains(word[i + 1])) {
                return word[i].ToString();
            }
        }
        return """";
    }

    static void Main(string[] args) {
        Console.WriteLine(GetClosestVowel(""yogurt"")); // Output: ""u""
        Console.WriteLine(GetClosestVowel(""FULL""));   // Output: ""U""
        Console.WriteLine(GetClosestVowel(""quick""));  // Output: """"
        Console.WriteLine(GetClosestVowel(""ab""));     // Output: """"
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetClosestVowel((""yogurt"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""full"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""easy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""eAsy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ali"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""bad"")).Equals((""a"")));
    Debug.Assert(GetClosestVowel((""most"")).Equals((""o"")));
    Debug.Assert(GetClosestVowel((""ab"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ba"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""quick"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""anime"")).Equals((""i"")));
    Debug.Assert(GetClosestVowel((""Asia"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""Above"")).Equals((""o"")));
    }

}
"
HumanEval_119,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಒಂದು ಉತ್ತಮ ಸ್ಟ್ರಿಂಗ್ ಮಾಡಲು ಒಂದು ಮಾರ್ಗವಿದ್ದರೆ 'ಹೌದು' ಅನ್ನು ಹಿಂತಿರುಗಿ, ಮತ್ತು ಇಲ್ಲದಿದ್ದರೆ 'ಇಲ್ಲ' ಅನ್ನು ಹಿಂತಿರುಗಿ.    //"" (()) "" ಅಲ್ಲ.    //ಸಮತೋಲಿತವಾಗಿದೆ. ಉದಾಹರಣೆಗೆ: '(((() ' ಸ್ಟ್ರಿಂಗ್ ಒಳ್ಳೆಯದು, ಆದರೆ ಸ್ಟ್ರಿಂಗ್     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ S ಅನ್ನು ಉತ್ತಮವೆಂದು ಪರಿಗಣಿಸಲಾಗುತ್ತದೆ ಮತ್ತು ಎಲ್ಲಾ ಆವರಣಗಳು S     //ಕೆಲವು ಕ್ರಮದಲ್ಲಿ, ಪರಿಣಾಮವಾಗಿರುವ ಸ್ಟ್ರಿಂಗ್ ಉತ್ತಮವಾಗಿರುತ್ತದೆ.    //ನಿಮ್ಮ ಕೆಲಸವು ಎರಡು ತಂತಿಗಳನ್ನು ಸಂಯೋಜಿಸಲು ಸಾಧ್ಯವಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸುವುದು.    //ಬ್ರಾಂಡೆಸ್ "" (("" ಅಥವಾ ಮುಚ್ಚಿದ ಬ್ರಾಂಡೆಸ್ "") "" ಮಾತ್ರ.    //ನೀವು ಎರಡು ತಂತಿಗಳನ್ನು ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗುತ್ತದೆ, ಎರಡೂ ತಂತಿಗಳು ಮುಕ್ತ ಒಳಗೊಂಡಿರುತ್ತವೆ     // >>> MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""})))
    // (""Yes"")
    // >>> MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""})))
    // (""No"")
    public static string MatchParens(List<string> lst) {
","public static string MatchParens(List<string> lst) {
        if (lst.Count != 2) return ""No"";

        string str1 = lst[0];
        string str2 = lst[1];

        // Check both possible concatenations
        if (IsValidParentheses(str1 + str2) || IsValidParentheses(str2 + str1))
            return ""Yes"";
        
        return ""No"";
    }

    private static bool IsValidParentheses(string s) {
        int balance = 0;
        foreach (char c in s) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false; // More closing parens than opening
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()(())"", (string)""())())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")())"", (string)""(()()(""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(())))"", (string)""(()())((""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()"", (string)""())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()("", (string)""()))()""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(((("", (string)""((())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")(()"", (string)""(()(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")("", (string)"")(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)""(""}))).Equals((""Yes"")));
    }

}
"
HumanEval_120,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ 1:     //k ಉದ್ದದ ಗರಿಷ್ಠ k ಸಂಖ್ಯೆಗಳೊಂದಿಗೆ arr.     //ಪೂರ್ಣಾಂಕಗಳ arr ಪಟ್ಟಿಯನ್ನು ಮತ್ತು k ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕವನ್ನು ನೀಡಿದರೆ, ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ     // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L))
    // (new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))
    // Example 2:
    // >>> Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L))
    // (new List<long>(new long[]{(long)4L, (long)4L}))
    // Example 3:
    // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))
    // (new List<long>(new long[]{(long)2L}))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    public static List<long> Maximum(List<long> arr, long k) {
","public static List<long> Maximum(List<long> arr, long k) {
    return arr.OrderByDescending(n => n).Take((int)k).OrderBy(n => n).ToList();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L)).Equals((new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L)).Equals((new List<long>(new long[]{(long)4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)123L, (long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (3L)).Equals((new List<long>(new long[]{(long)2L, (long)20L, (long)123L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (4L)).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)20L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)5L, (long)15L, (long)0L, (long)3L, (long)-13L, (long)-8L, (long)0L})), (7L)).Equals((new List<long>(new long[]{(long)-13L, (long)-8L, (long)0L, (long)0L, (long)3L, (long)5L, (long)15L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-1L, (long)0L, (long)2L, (long)5L, (long)3L, (long)-10L})), (2L)).Equals((new List<long>(new long[]{(long)3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)0L, (long)5L, (long)-7L})), (1L)).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L})), (2L)).Equals((new List<long>(new long[]{(long)-4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-10L, (long)10L})), (2L)).Equals((new List<long>(new long[]{(long)-10L, (long)10L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)-23L, (long)243L, (long)-400L, (long)0L})), (0L)).Equals((new List<long>())));
    }

}
"
HumanEval_121,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಪೂರ್ಣಾಂಕಗಳ ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ಸಮ ಸ್ಥಾನದಲ್ಲಿರುವ ಎಲ್ಲಾ ಬೆಸ ಅಂಶಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿಸಿ.    // >>> Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L})))
    // (12L)
    // >>> Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L})))
    // (9L)
    // >>> Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L})))
    // (0L)
    public static long Solution(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Solution(List<long> lst) {
        long sum = 0;
        for (int i = 0; i < lst.Count; i += 2) { // Iterate over even indices
            if (lst[i] % 2 != 0) { // Check if the element is odd
                sum += lst[i];
            }
        }
        return sum;
    }
    
    static void Main() {
        Console.WriteLine(Solution(new List<long>{5L, 8L, 7L, 1L})); // Output: 12
        Console.WriteLine(Solution(new List<long>{3L, 3L, 3L, 3L, 3L})); // Output: 9
        Console.WriteLine(Solution(new List<long>{30L, 13L, 24L, 321L})); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L}))) == (12L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L}))) == (9L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)9L}))) == (5L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)2L, (long)4L, (long)8L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)23L, (long)32L}))) == (23L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)13L, (long)2L, (long)9L}))) == (3L));
    }

}
"
HumanEval_122,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //arr ನ ಮೊದಲ k ಅಂಶಗಳಿಂದ ಗರಿಷ್ಠ ಎರಡು ಅಂಕೆಗಳನ್ನು ಹೊಂದಿರುವ ಅಂಶಗಳ ಮೊತ್ತ.     //ಪೂರ್ಣಾಂಕಗಳ ಖಾಲಿ ಅಲ್ಲದ ಪಟ್ಟಿ arr ಮತ್ತು ಒಂದು ಪೂರ್ಣಾಂಕ k ನೀಡಿದರೆ, return     // >>> AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L))
    // (24L)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    public static long AddElements(List<long> arr, long k) {
","public static long AddElements(List<long> arr, long k) {
        long sum = 0;
        for (int i = 0; i < k; i++) {
            if (arr[i] >= -99 && arr[i] <= 99) {
                sum += arr[i];
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L, (long)-2L, (long)-3L, (long)41L, (long)57L, (long)76L, (long)87L, (long)88L, (long)99L})), (3L)) == (-4L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)121L, (long)3L, (long)4000L, (long)5L, (long)6L})), (2L)) == (0L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)11L, (long)21L, (long)3L, (long)90L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (125L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (24L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L})), (1L)) == (1L));
    }

}
"
HumanEval_123,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //get_odd_collatz(5) [1, 5] ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ. # 5 ರ ಕೋಲಾಟ್ಜ್ ಅನುಕ್ರಮವು [5, 16, 8, 4, 2, 1], ಆದ್ದರಿಂದ ಬೆಸ ಸಂಖ್ಯೆಗಳು ಕೇವಲ 1, ಮತ್ತು 5 ಮಾತ್ರ.    //ಉದಾಹರಣೆಗೆ:     //2. ಹಿಂದಿರುಗಿದ ಪಟ್ಟಿ ಹೆಚ್ಚುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ ವಿಂಗಡಿಸಲಾಗಿದೆ.    //1. ಕೊಲಾಟ್ಜ್ () = .    //ಟಿಪ್ಪಣಿ:     //ಪದರ + 1 ಅಂದಾಜು ಎನ್ ನ ಯಾವ ಮೌಲ್ಯವನ್ನು ಲೆಕ್ಕಿಸದೆ, ಅನುಕ್ರಮವು ಯಾವಾಗಲೂ 1 ಅನ್ನು ತಲುಪುತ್ತದೆ.    //ಹಿಂದಿನ ಪದವು ಬೆಸವಾಗಿದ್ದರೆ, ಮುಂದಿನ ಪದವು ಹಿಂದಿನ ಪದದ 3 ಪಟ್ಟು     //ಹಿಂದಿನ ಪದವು ಈ ಕೆಳಗಿನಂತೆಃ ಹಿಂದಿನ ಪದವು ಸಮವಾಗಿದ್ದರೆ, ಮುಂದಿನ ಪದವು ಅರ್ಧದಷ್ಟು ಇರುತ್ತದೆ.    //ಈ ಕೆಳಗಿನಂತೆ: ಯಾವುದೇ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೊಂದಿಗೆ ಪ್ರಾರಂಭಿಸಿ. ನಂತರ ಪ್ರತಿ ಪದವನ್ನು  ನಿಂದ ಪಡೆಯಲಾಗುತ್ತದೆ.    //ಕೋಲಾಟ್ಜ್ ಊಹೆಯು ಗಣಿತಶಾಸ್ತ್ರದಲ್ಲಿ ಒಂದು ಊಹೆಯಾಗಿದ್ದು ಅದು ವ್ಯಾಖ್ಯಾನಿಸಲಾದ ಅನುಕ್ರಮಕ್ಕೆ ಸಂಬಂಧಿಸಿದೆ .    //ಒಂದು ಸಕಾರಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಿದರೆ, ಒಂದು ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ ಅದು ಕೋಲಾಟ್ಜ್ ಅನುಕ್ರಮದಲ್ಲಿ ಬೆಸ ಸಂಖ್ಯೆಗಳನ್ನು ಹೊಂದಿದೆ.    // >>> GetOddCollatz((5L))
    // (new List<long>(new long[]{(long)1L, (long)5L}))
    public static List<long> GetOddCollatz(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetOddCollatz(long n)
    {
        HashSet<long> oddNumbers = new HashSet<long>();

        while (n != 1)
        {
            if (n % 2 != 0)
            {
                oddNumbers.Add(n);
            }

            if (n % 2 == 0)
            {
                n /= 2;
            }
            else
            {
                n = 3 * n + 1;
            }
        }

        oddNumbers.Add(1); // Add 1 to the set as per problem statement

        List<long> result = new List<long>(oddNumbers);
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetOddCollatz((14L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(GetOddCollatz((5L)).Equals((new List<long>(new long[]{(long)1L, (long)5L}))));
    Debug.Assert(GetOddCollatz((12L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)5L}))));
    Debug.Assert(GetOddCollatz((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    }

}
"
HumanEval_124,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //4. ದಿನಾಂಕವು ಈ ಸ್ವರೂಪದಲ್ಲಿರಬೇಕು: mm-dd-yyyy     //3. ತಿಂಗಳುಗಳು 1 ಕ್ಕಿಂತ ಕಡಿಮೆ ಅಥವಾ 12 ಕ್ಕಿಂತ ಹೆಚ್ಚಿರಬಾರದು.    //2. ತಿಂಗಳು 1,3,5,7,8,10,12 ರ ದಿನಾಂಕವು 1 ಕ್ಕಿಂತ ಕಡಿಮೆಯಿಲ್ಲ ಅಥವಾ 31 ದಿನಗಳಿಗಿಂತ ಹೆಚ್ಚಿಲ್ಲ ಮತ್ತು ತಿಂಗಳು 4,6,9,11 ರ ದಿನಾಂಕವು 1 ಕ್ಕಿಂತ ಕಡಿಮೆಯಿಲ್ಲ ಅಥವಾ 30 ದಿನಗಳಿಗಿಂತ ಹೆಚ್ಚಿಲ್ಲ. ಮತ್ತು, ತಿಂಗಳ 2 ರ ದಿನಾಂಕವು 1 ಕ್ಕಿಂತ ಕಡಿಮೆಯಿಲ್ಲ ಅಥವಾ 29 ಕ್ಕಿಂತ ಹೆಚ್ಚಿಲ್ಲ.    //1. ದಿನಾಂಕದ ಸರಣಿಯು ಖಾಲಿಯಾಗಿಲ್ಲ.    //ಈ ಕೆಳಗಿನ ಎಲ್ಲಾ ನಿಯಮಗಳನ್ನು ಪೂರೈಸಿದರೆ ದಿನಾಂಕವು ಮಾನ್ಯವಾಗಿರುತ್ತದೆಃ     //ದಿನಾಂಕವು ಮಾನ್ಯವಾಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ ಇಲ್ಲದಿದ್ದರೆ false.     //ನೀವು ಒಂದು ನಿರ್ದಿಷ್ಟ ದಿನಾಂಕ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಮೌಲ್ಯೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಬೇಕು ಮತ್ತು     // >>> ValidDate((""03-11-2000""))
    // (true)
    // >>> ValidDate((""15-01-2012""))
    // (false)
    // >>> ValidDate((""04-0-2040""))
    // (false)
    // >>> ValidDate((""06-04-2020""))
    // (true)
    // >>> ValidDate((""06/04/2020""))
    // (false)
    public static bool ValidDate(string date) {
","public static bool ValidDate(string date)
{
    if (string.IsNullOrEmpty(date) || date.Length != 10) return false;

    string[] dateParts = date.Split('-');
    if (dateParts.Length != 3) return false;

    if (!int.TryParse(dateParts[0], out int month) || !int.TryParse(dateParts[1], out int day) || !int.TryParse(dateParts[2], out int year))
    {
        return false;
    }

    if (month < 1 || month > 12) return false;

    if (year < 1) return false;

    bool isValidDay = false;

    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day >= 1 && day <= 31)
    {
        isValidDay = true;
    }
    else if ((month == 4 || month == 6 || month == 9 || month == 11) && day >= 1 && day <= 30)
    {
        isValidDay = true;
    }
    else if (month == 2 && day >= 1 && day <= 29)
    {
        isValidDay = true;
    }

    return isValidDay;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ValidDate((""03-11-2000"")) == (true));
    Debug.Assert(ValidDate((""15-01-2012"")) == (false));
    Debug.Assert(ValidDate((""04-0-2040"")) == (false));
    Debug.Assert(ValidDate((""06-04-2020"")) == (true));
    Debug.Assert(ValidDate((""01-01-2007"")) == (true));
    Debug.Assert(ValidDate((""03-32-2011"")) == (false));
    Debug.Assert(ValidDate(("""")) == (false));
    Debug.Assert(ValidDate((""04-31-3000"")) == (false));
    Debug.Assert(ValidDate((""06-06-2005"")) == (true));
    Debug.Assert(ValidDate((""21-31-2000"")) == (false));
    Debug.Assert(ValidDate((""04-12-2003"")) == (true));
    Debug.Assert(ValidDate((""04122003"")) == (false));
    Debug.Assert(ValidDate((""20030412"")) == (false));
    Debug.Assert(ValidDate((""2003-04"")) == (false));
    Debug.Assert(ValidDate((""2003-04-12"")) == (false));
    Debug.Assert(ValidDate((""04-2003"")) == (false));
    }

}
"
HumanEval_126,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಸಂಖ್ಯೆ, false ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ. ಯಾವುದೇ ಋಣಾತ್ಮಕ ಸಂಖ್ಯೆಗಳನ್ನು ಮತ್ತು ಪೂರ್ಣಾಂಕಗಳನ್ನು ಮಾತ್ರ ಊಹಿಸಿ.    // ಪಟ್ಟಿಯಲ್ಲಿ ಒಂದಕ್ಕಿಂತ ಹೆಚ್ಚು ನಕಲು ಇದ್ದರೆ    //ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗಿದೆ, ಅವು ವಿಂಗಡಿಸಲ್ಪಟ್ಟಿರಲಿ ಅಥವಾ ಇಲ್ಲದಿರಲಿ     // >>> IsSorted((new List<long>(new long[]{(long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L})))
    // (false)
    public static bool IsSorted(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static bool IsSorted(List<long> lst) {
        if (lst.Count == 0) return true;

        // To store the occurrence of each number
        var occurrences = new Dictionary<long, int>();

        for (int i = 0; i < lst.Count - 1; i++) {
            // Check if the current number is greater than the next number
            if (lst[i] > lst[i + 1]) {
                return false;
            }

            // Count the occurrences of each number
            if (occurrences.ContainsKey(lst[i])) {
                occurrences[lst[i]]++;
            } else {
                occurrences[lst[i]] = 1;
            }

            // If any number occurs more than twice
            if (occurrences[lst[i]] > 2) {
                return false;
            }
        }

        // Check the last element in the list for more than two occurrences
        if (occurrences.ContainsKey(lst[lst.Count - 1])) {
            occurrences[lst[lst.Count - 1]]++;
            if (occurrences[lst[lst.Count - 1]] > 2) {
                return false;
            }
        } else {
            occurrences[lst[lst.Count - 1]] = 1;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (false));
    Debug.Assert(IsSorted((new List<long>())) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))) == (true));
    }

}
"
HumanEval_127,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //[ಇನ್ಪುಟ್/ಔಟ್ಪುಟ್] ಮಾದರಿಗಳು:     //ಎರಡು ಮಧ್ಯಂತರಗಳು ಛೇದಿಸದಿದ್ದರೆ, ""NO"" ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ಇಲ್ಲದಿದ್ದರೆ, ""NO"" ಅನ್ನು ಹಿಂತಿರುಗಿ.    // ರೇಖೆಯ ಉದ್ದವು ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಾಗಿದ್ದರೆ, ""YES"" ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ಅದರ ಉದ್ದವು 1 ಆಗಿರುತ್ತದೆ, ಅದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಲ್ಲ.    //ಉದಾಹರಣೆ, ಅಂತರಗಳ (1, 3), (2, 4) ಛೇದಕವು (2, 3) ಆಗಿದೆ.    //ಮಧ್ಯಂತರಗಳು ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಯಾಗಿದೆ.    //ನಿಮ್ಮ ಕಾರ್ಯವು ಈ ಎರಡು     //ಪ್ರತಿ ನಿರ್ದಿಷ್ಟ ಮಧ್ಯಂತರಕ್ಕೆ, ಅದರ ಆರಂಭವು ಅದರ ಅಂತ್ಯಕ್ಕಿಂತ ಕಡಿಮೆ ಅಥವಾ ಸಮನಾಗಿರುತ್ತದೆ ಎಂದು ಭಾವಿಸಲಾಗಿದೆ.    //ಆರಂಭ ಮತ್ತು ಅಂತ್ಯ ಎರಡನ್ನೂ ಒಳಗೊಂಡಿದೆ.    //ಕೊಟ್ಟಿರುವ ಮಧ್ಯಂತರಗಳು ಮುಚ್ಚಲ್ಪಟ್ಟಿವೆ ಅಂದರೆ ಮಧ್ಯಂತರ (ಆರಂಭ, ಅಂತ್ಯ)     //ಅಲ್ಲಿ ಪ್ರತಿ ಮಧ್ಯಂತರವು ಒಂದು ಜೋಡಿ ಪೂರ್ಣಾಂಕಗಳು. ಉದಾಹರಣೆಗೆ, ಮಧ್ಯಂತರ = (ಆರಂಭ, ಅಂತ್ಯ) = (1, 2).    //ನಿಮಗೆ ಎರಡು ಮಧ್ಯಂತರಗಳನ್ನು ನೀಡಲಾಗಿದೆ,     // >>> Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L)))
    // (""YES"")
    public static string Intersection(Tuple<long, long> interval1, Tuple<long, long> interval2) {
","long start1 = interval1.Item1;
    long end1 = interval1.Item2;
    long start2 = interval2.Item1;
    long end2 = interval2.Item2;

    long intersectStart = Math.Max(start1, start2);
    long intersectEnd = Math.Min(end1, end2);

    if (intersectStart > intersectEnd) {
        return ""NO"";
    }

    long intersectionLength = intersectEnd - intersectStart + 1;

    if (IsPrime(intersectionLength)) {
        return ""YES"";
    } else {
        return ""NO"";
    }
}

private static bool IsPrime(long number) {
    if (number < 2) return false;
    if (number == 2) return true;
    if (number % 2 == 0) return false;

    long boundary = (long)Math.Floor(Math.Sqrt(number));

    for (long i = 3; i <= boundary; i += 2) {
        if (number % i == 0) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, 2L)), (Tuple.Create(-4L, 0L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-11L, 2L)), (Tuple.Create(-1L, -1L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(3L, 5L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(1L, 2L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, -2L)), (Tuple.Create(-3L, -2L))).Equals((""NO"")));
    }

}
"
HumanEval_128,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಗಮನಿಸಿ: ಖಾಲಿ arr ಗೆ null ಅನ್ನು ಹಿಂತಿರುಗಿಸಿ.     //ಪಟ್ಟಿಯಲ್ಲಿರುವ ಪ್ರತಿ ಸಂಖ್ಯೆಯ 1, -1 ಅಥವಾ 0 ರೊಂದಿಗೆ ಪ್ರತಿನಿಧಿಸಲಾಗುತ್ತದೆ.    //ಪೂರ್ಣಾಂಕಗಳ ಪ್ರಮಾಣಗಳ ಮೊತ್ತವನ್ನು ಎಲ್ಲಾ ಚಿಹ್ನೆಗಳ ಉತ್ಪನ್ನದಿಂದ ಗುಣಿಸಿದಾಗ     //ನಿಮಗೆ ಪೂರ್ಣಾಂಕಗಳ ಒಂದು ಪಟ್ಟಿ ನೀಡಲಾಗಿದೆ ಮತ್ತು ನೀವು ಮರಳಬೇಕಾಗಿದೆ.    // >>> ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L})))
    // 9L
    // >>> ProdSigns((new List<long>(new long[]{(long)0L, (long)1L})))
    // 0L
    // >>> ProdSigns((new List<long>()))
    // null
    public static Nullable<long> ProdSigns(List<long> arr) {
","public static Nullable<long> ProdSigns(List<long> arr) {
        if (arr == null || arr.Count == 0) return null;

        long sumOfMagnitudes = 0;
        long productOfSigns = 1;

        foreach (var num in arr) {
            sumOfMagnitudes += Math.Abs(num);

            if (num > 0) {
                productOfSigns *= 1;
            } else if (num < 0) {
                productOfSigns *= -1;
            } else {
                productOfSigns = 0;
                break;
            }
        }

        return sumOfMagnitudes * productOfSigns;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L}))).Equals(-9L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)0L, (long)1L}))).Equals(0L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)2L, (long)3L, (long)-1L, (long)1L}))).Equals(-10L));
    Debug.Assert(ProdSigns((new List<long>())).Equals(null));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)2L, (long)-1L, (long)-1L, (long)9L}))).Equals(20L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)-1L, (long)1L}))).Equals(4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)1L}))).Equals(-4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)0L}))).Equals(0L));
    }

}
"
HumanEval_129,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಕನಿಷ್ಠ ಪಥವು ಹಾದುಹೋಗುವ ಕೋಶಗಳ ಮೇಲೆ ಮೌಲ್ಯಗಳ ಕ್ರಮಬದ್ಧ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಉತ್ತರವು ಅನನ್ಯವಾಗಿದೆ ಎಂದು ಖಾತರಿಪಡಿಸಲಾಗಿದೆ.    //lst_A[j] = lst_B[j]  ಎಂದು ಬರೆಯಲಾಗಿದೆ.    //lst_A[i] < lst_B[i] ಮತ್ತು ಯಾವುದೇ j (1 <= j < i) ಗಾಗಿ ನಾವು     //lst_B ಗಿಂತ, ಬೇರೆ ರೀತಿಯಲ್ಲಿ ಹೇಳುವುದಾದರೆ, ಒಂದು ಪೂರ್ಣಾಂಕ ಸೂಚ್ಯಂಕ i (1 <= i <= k)  ಅಸ್ತಿತ್ವದಲ್ಲಿದೆ    //ಮೂಲಕ (ನಾವು ಅವುಗಳನ್ನು lst_A ಮತ್ತು lst_B ಎಂದು ಕರೆಯೋಣ), lst_A ಶಬ್ದಕೋಶೀಯವಾಗಿ ಕಡಿಮೆ     //A ಮತ್ತು B ಗೆ ಹೋಗುವ ಕೋಶಗಳ ಮೇಲೆ ಮೌಲ್ಯಗಳ ಕ್ರಮಬದ್ಧ ಪಟ್ಟಿಗಳನ್ನು ಮಾಡಿದ ನಂತರ     //ಒಂದು ಪಥ A (ಉದ್ದ k) ಅನ್ನು ಒಂದು ಪಥ B (ಉದ್ದ k) ಗಿಂತ ಚಿಕ್ಕದಾಗಿ ಪರಿಗಣಿಸಲಾಗುತ್ತದೆ     //ನೀವು ಗ್ರಿಡ್ನಿಂದ ಹೊರಗೆ ಹೋಗಲು ಸಾಧ್ಯವಿಲ್ಲ.    //ಅಗತ್ಯವಾಗಿ ವಿಭಿನ್ನವಾಗಿವೆ).    //k ಉದ್ದದ ಪಥವು ನಿಖರವಾಗಿ k ಕೋಶಗಳನ್ನು ಭೇಟಿ ಮಾಡುವುದನ್ನು ಸೂಚಿಸುತ್ತದೆ (ಇಲ್ಲ     //    //ಅಂದರೆ, ನೀವು ನಿಮ್ಮ ಪ್ರವಾಹದೊಂದಿಗೆ ಅಂಚನ್ನು ಹಂಚಿಕೊಳ್ಳುವ ಕೋಶಗಳಿಗೆ ಹೋಗಬಹುದು.    //ಯಾವುದೇ ಕೋಶದಿಂದ, ಮತ್ತು ಪ್ರತಿ ಹಂತದಲ್ಲಿ ನೀವು ನೆರೆಯ ಕೋಶಗಳ ಯಾವುದೇ ಚಲಿಸಬಹುದು,     //ನೀವು ಗ್ರಿಡ್ನಲ್ಲಿ k ಉದ್ದದ ಕನಿಷ್ಠ ಮಾರ್ಗವನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು. ನೀವು ಪ್ರಾರಂಭಿಸಬಹುದು     //ಗ್ರಿಡ್ನ ಕೋಶಗಳಲ್ಲಿ ನಿಖರವಾಗಿ ಒಮ್ಮೆ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತದೆ.    //ಗ್ರಿಡ್ನ ಪ್ರತಿಯೊಂದು ಕೋಶವು ಒಂದು ಮೌಲ್ಯವನ್ನು ಹೊಂದಿರುತ್ತದೆ. [1, N * N] ವ್ಯಾಪ್ತಿಯಲ್ಲಿರುವ ಪ್ರತಿ ಪೂರ್ಣಾಂಕ     //N ಸಾಲುಗಳು ಮತ್ತು N ಕಾಲಮ್ಗಳನ್ನು ಹೊಂದಿರುವ ಗ್ರಿಡ್ ನೀಡಲಾಗಿದೆ (N >= 2) ಮತ್ತು k ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ,     // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))
    // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L))
    // (new List<long>(new long[]{(long)1L}))
    public static List<long> Minpath(List<List<long>> grid, long k) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Minpath(List<List<long>> grid, long k) {
        int n = grid.Count;
        List<long> result = new List<long>();
        long[,] dp = new long[n, n];
        (int, int)[,] parent = new (int, int)[n, n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = long.MaxValue;
            }
        }

        var directions = new List<(int, int)>() { (0, 1), (1, 0), (0, -1), (-1, 0) };
        SortedSet<(long, int, int)> pq = new SortedSet<(long, int, int)>((a, b) => a.Item1 == b.Item1 ? (a.Item2 == b.Item2 ? a.Item3.CompareTo(b.Item3) : a.Item2.CompareTo(b.Item2)) : a.Item1.CompareTo(b.Item1));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = grid[i][j];
                pq.Add((grid[i][j], i, j));
            }
        }

        while (pq.Count > 0) {
            var curr = pq.Min;
            pq.Remove(curr);
            long currValue = curr.Item1;
            int x = curr.Item2;
            int y = curr.Item3;

            foreach (var dir in directions) {
                int newX = x + dir.Item1;
                int newY = y + dir.Item2;
                if (newX >= 0 && newX < n && newY >= 0 && newY < n) {
                    long newCost = currValue + grid[newX][newY];
                    if (dp[newX, newY] > newCost) {
                        if (dp[newX, newY] != long.MaxValue) {
                            pq.Remove((dp[newX, newY], newX, newY));
                        }
                        dp[newX, newY] = newCost;
                        parent[newX, newY] = (x, y);
                        pq.Add((dp[newX, newY], newX, newY));
                    }
                }
            }
        }

        (int, int) end = (0, 0);
        long minPathSum = long.MaxValue;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (minPathSum > dp[i, j]) {
                    minPathSum = dp[i, j];
                    end = (i, j);
                }
            }
        }

        Stack<long> pathStack = new Stack<long>();
        (int, int) node = end;
        for (int step = 0; step < k; step++) {
            pathStack.Push(grid[node.Item1][node.Item2]);
            node = parent[node.Item1, node.Item2];
        }

        while (pathStack.Count > 0) {
            result.Add(pathStack.Pop());
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L}), (List<long>)new List<long>(new long[]{(long)9L, (long)10L, (long)11L, (long)12L}), (List<long>)new List<long>(new long[]{(long)13L, (long)14L, (long)15L, (long)16L})})), (4L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)10L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)12L, (long)1L}), (List<long>)new List<long>(new long[]{(long)3L, (long)16L, (long)11L, (long)15L}), (List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L})})), (7L)).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)1L, (long)10L, (long)1L, (long)10L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L}), (List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)15L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)12L}), (List<long>)new List<long>(new long[]{(long)3L, (long)10L, (long)11L, (long)16L})})), (5L)).Equals((new List<long>(new long[]{(long)1L, (long)7L, (long)1L, (long)7L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L})})), (9L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L})})), (12L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)6L, (long)8L, (long)9L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)3L, (long)8L, (long)9L}), (List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)3L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    }

}
"
HumanEval_130,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಟ್ರಿಬೊನಾಕಿ ಅನುಕ್ರಮದ ಮೊದಲ n + 1 ಸಂಖ್ಯೆಗಳು.    //ನಿಮಗೆ ಒಂದು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕ n ನೀಡಲಾಗಿದೆ, ನೀವು  ನ ಪಟ್ಟಿಯನ್ನು ಮರಳಿ ಕೊಡಬೇಕು    //= 2 + 3 + 3 = 8     //ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು ತ್ರಿಪಂಕ್ತಿಯು    //೩     //tri ((2) = 1 + (2 / 2) = 2     //ಉದಾಹರಣೆಗೆ:     //n = n - 1) + n - 2) + n + 1) ಆಗಿದ್ದರೆ, n ಬೆಸವಾಗಿದೆ.    //tri (n) = 1 + n / 2, n ಸಮವಾಗಿದ್ದರೆ.    //ತ್ರಿ  1) = ೩    //ಟ್ರಿಬೊನಾಕಿ ಅನುಕ್ರಮವನ್ನು ಪುನರಾವರ್ತನೆಯಿಂದ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆ:     //ಆದರೆ, ಜನರಿಗೆ ತಿಳಿದಿಲ್ಲದ ವಿಷಯವೆಂದರೆ ಟ್ರಿಬೊನಾಕಿ ಅನುಕ್ರಮ.    //ಪ್ರತಿಯೊಬ್ಬರೂ ಫಿಬೊನಾಕಿ ಅನುಕ್ರಮವನ್ನು ತಿಳಿದಿದ್ದಾರೆ, ಇದನ್ನು ಗಣಿತಜ್ಞರು ಆಳವಾಗಿ ಅಧ್ಯಯನ ಮಾಡಿದ್ದಾರೆ     // >>> Tri((3L))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))
    public static List<long> Tri(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Tri(long n)
    {
        List<long> tribonacci = new List<long>(new long[n + 1]);

        for (long i = 0; i <= n; i++)
        {
            if (i == 0)
                tribonacci[(int)i] = 1;
            else if (i == 1)
                tribonacci[(int)i] = 3;
            else if (i % 2 == 0)
                tribonacci[(int)i] = 1 + i / 2;
            else
                tribonacci[(int)i] = tribonacci[(int)(i - 1)] + tribonacci[(int)(i - 2)] + tribonacci[(int)(i + 1)];
        }
        
        return tribonacci;
    }
    
    static void Main(string[] args)
    {
        // Example usage:
        Console.WriteLine(string.Join("", "", Tri(3)));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Tri((3L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))));
    Debug.Assert(Tri((4L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L}))));
    Debug.Assert(Tri((5L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L}))));
    Debug.Assert(Tri((6L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L}))));
    Debug.Assert(Tri((7L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L}))));
    Debug.Assert(Tri((8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L}))));
    Debug.Assert(Tri((9L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L}))));
    Debug.Assert(Tri((20L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L, (long)6L, (long)48L, (long)7L, (long)63L, (long)8L, (long)80L, (long)9L, (long)99L, (long)10L, (long)120L, (long)11L}))));
    Debug.Assert(Tri((0L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Tri((1L)).Equals((new List<long>(new long[]{(long)1L, (long)3L}))));
    }

}
"
HumanEval_131,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಎಲ್ಲಾ ಅಂಕೆಗಳು ಸಮವಾಗಿದ್ದರೆ 0 ಅನ್ನು ಹಿಂತಿರುಗಿ.    //ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಿದರೆ, ಬೆಸ ಅಂಕೆಗಳ ಉತ್ಪನ್ನವನ್ನು ಹಿಂತಿರುಗಿ.    // >>> Digits((1L))
    // (1L)
    // >>> Digits((4L))
    // (0L)
    // >>> Digits((235L))
    // (15L)
    public static long Digits(long n) {
","using System;

class Problem {
    public static long Digits(long n) {
        long product = 1;
        bool hasOdd = false;

        while (n > 0) {
            long digit = n % 10;
            if (digit % 2 != 0) {
                product *= digit;
                hasOdd = true;
            }
            n /= 10;
        }

        return hasOdd ? product : 0;
    }

    static void Main(string[] args) {
        Console.WriteLine(Digits(1L));    // Output: 1
        Console.WriteLine(Digits(4L));    // Output: 0
        Console.WriteLine(Digits(235L));  // Output: 15
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digits((5L)) == (5L));
    Debug.Assert(Digits((54L)) == (5L));
    Debug.Assert(Digits((120L)) == (1L));
    Debug.Assert(Digits((5014L)) == (5L));
    Debug.Assert(Digits((98765L)) == (315L));
    Debug.Assert(Digits((5576543L)) == (2625L));
    Debug.Assert(Digits((2468L)) == (0L));
    }

}
"
HumanEval_132,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಅಲ್ಲಿ ಕನಿಷ್ಠ ಒಂದು ಬ್ರಾಕೆಟ್ ಅನ್ನು ಸಬ್ಸೆಕ್ವೆನ್ಸಿಗಳಲ್ಲಿ ಗೂಡುಮಾಡಲಾಗಿದೆ.    //ಬ್ರಾಕೆಟ್ಗಳ ಮಾನ್ಯ ಉಪಕ್ರಮವಿದ್ದರೆ ಮಾತ್ರ ಮತ್ತು ಮಾತ್ರ ಕಾರ್ಯವು true ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕು .    //ಕೇವಲ ಚದರ ಆವರಣಗಳನ್ನು ಹೊಂದಿರುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ.    // >>> IsNested((""[[]]""))
    // (true)
    // >>> IsNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> IsNested((""[][]""))
    // (false)
    // >>> IsNested((""[]""))
    // (false)
    // >>> IsNested((""[[][]]""))
    // (true)
    // >>> IsNested((""[[]][[""))
    // (true)
    public static bool IsNested(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsNested(string str) {
        Stack<char> stack = new Stack<char>();
        bool hasNested = false;
        
        foreach (char ch in str) {
            if (ch == '[') {
                stack.Push(ch);
            } else if (ch == ']') {
                if (stack.Count > 0) {
                    stack.Pop();
                    hasNested = true;
                } else {
                    return false; // More closing brackets than opening
                }
            }

            // Check for nesting
            if (stack.Count > 1) {
                hasNested = true;
            }
        }
        
        return stack.Count == 0 && hasNested;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsNested((""[[]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]][[[[[]"")) == (false));
    Debug.Assert(IsNested((""[][]"")) == (false));
    Debug.Assert(IsNested((""[]"")) == (false));
    Debug.Assert(IsNested((""[[[[]]]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]]]]]"")) == (false));
    Debug.Assert(IsNested((""[][][[]]"")) == (true));
    Debug.Assert(IsNested((""[[]"")) == (false));
    Debug.Assert(IsNested((""[]]"")) == (false));
    Debug.Assert(IsNested((""[[]][["")) == (true));
    Debug.Assert(IsNested((""[[][]]"")) == (true));
    Debug.Assert(IsNested(("""")) == (false));
    Debug.Assert(IsNested((""[[[[[[[["")) == (false));
    Debug.Assert(IsNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಪಟ್ಟಿಯಲ್ಲಿರುವ ಪ್ರತಿಯೊಂದು ಅಂಶವನ್ನು ಮೊದಲು ಮೇಲಿನ int ((ಸೀಲಿಂಗ್) ಗೆ ಸುತ್ತಿಕೊಳ್ಳಿ.    //ನೀವು ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸಂಖ್ಯೆಗಳ ಚೌಕದ ಮೊತ್ತವನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕಾಗಿದೆ,     //ನಿಮಗೆ ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿ ನೀಡಲಾಗಿದೆ.    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})))
    // (14L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)4.0f, (float)9.0f})))
    // (98L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))
    // (84L)
    // >>> Lst((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f})))
    // (29L)
    // >>> Lst((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f})))
    // (6L)
    public static long SumSquares(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<float> lst)
    {
        long sum = 0;
        foreach (float num in lst)
        {
            int roundedNum = (int)Math.Ceiling(num);
            sum += (long)(roundedNum * roundedNum);
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f}))) == (29L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)10000.0f, (float)10000.0f}))) == (200000000L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)0.0f}))) == (0L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f}))) == (1L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2L));
    }

}
"
HumanEval_134,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಗಮನಿಸಿ: ""ವರ್ಡ್"" ಎಂಬುದು ಅಕ್ಷರಗಳ ಗುಂಪಾಗಿದ್ದು, ಅಂತರದಿಂದ ಬೇರ್ಪಡಿಸಲಾಗಿದೆ.    //ಒಂದು ಪದದ ಒಂದು ಭಾಗ, ಮತ್ತು ಸುಳ್ಳು ಇಲ್ಲದಿದ್ದರೆ.    //ಒಂದು ನಿರ್ದಿಷ್ಟ ಸ್ಟ್ರಿಂಗ್ನ ಒಂದು ವರ್ಣಮಾಲೆಯ ಅಕ್ಷರವಾಗಿದೆ ಮತ್ತು  ಅಲ್ಲ.    //ಕೊನೆಯ ಅಕ್ಷರ  ಆಗಿದ್ದರೆ true ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ    // >>> CheckIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> CheckIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""""))
    // (false)
    public static bool CheckIfLastCharIsALetter(string txt) {
","public static bool CheckIfLastCharIsALetter(string txt) {
        if (string.IsNullOrWhiteSpace(txt)) {
            return false;
        }

        txt = txt.Trim();
        if (txt.Length == 0) {
            return false;
        }

        int lastIndex = txt.Length - 1;
        char lastChar = txt[lastIndex];

        if (!char.IsLetter(lastChar)) {
            return false;
        }

        if (lastIndex == 0 || char.IsWhiteSpace(txt[lastIndex - 1])) {
            return true;
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckIfLastCharIsALetter((""apple"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""A"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter(("""")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee e "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pie"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಗಳು    //ಅಂತಹ ಯಾವುದೇ ಅಂಶವು ಅಸ್ತಿತ್ವದಲ್ಲಿಲ್ಲದಿದ್ದರೆ -1. ಕೊಟ್ಟಿರುವ ಪಟ್ಟಿಯು  ಅನ್ನು ಹೊಂದಿರುವುದಿಲ್ಲ.    //ಇದು ತಕ್ಷಣವೇ ಅದರ ಹಿಂದಿನ ಅಂಶಕ್ಕಿಂತ ದೊಡ್ಡದಾಗಿದೆ ಅಥವಾ ಸಮನಾಗಿರುವುದಿಲ್ಲ.    //ಒಂದು ಅಂಶದ ಅತಿದೊಡ್ಡ ಸೂಚಿಯನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ ಅದು     // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L})))
    // (3L)
    // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (-1L)
    public static long CanArrange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    // Create a function which returns the largest index of an element which
    // is not greater than or equal to the element immediately preceding it.
    // If no such element exists, then return -1.
    public static long CanArrange(List<long> arr) {
        for (int i = arr.Count - 1; i > 0; i--) {
            if (arr[i] < arr[i - 1]) {
                return i;
            }
        }
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))) == (3L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)5L}))) == (-1L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L}))) == (2L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)4L, (long)8L, (long)5L, (long)7L, (long)3L}))) == (4L));
    Debug.Assert(CanArrange((new List<long>())) == (-1L));
    }

}
"
HumanEval_136,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಯಾವುದೇ ಋಣಾತ್ಮಕ ಅಥವಾ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳಿಲ್ಲದಿದ್ದರೆ, ಅವುಗಳನ್ನು ಶೂನ್ಯವಾಗಿ ಹಿಂತಿರುಗಿಸಿ.    //ಒಂದು ಪಟ್ಟಿಯಲ್ಲಿನ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳ ಸಂಖ್ಯೆ.    //ದೊಡ್ಡದು, ಮತ್ತು 'b' ಚಿಕ್ಕದು     //ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ ಅದು ಒಂದು ಟುಪಲ್ (a, b) ಅನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ, ಅಲ್ಲಿ 'a'     // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L})))
    // Tuple.Create((Nullable<long>)null, 1L)
    // >>> LargestSmallestIntegers((new List<long>()))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)0L})))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
","public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
        Nullable<long> largestNegative = null;
        Nullable<long> smallestPositive = null;

        foreach (var number in lst) {
            if (number < 0) {
                if (largestNegative == null || number > largestNegative) {
                    largestNegative = number;
                }
            } else if (number > 0) {
                if (smallestPositive == null || number < smallestPositive) {
                    smallestPositive = number;
                }
            }
        }

        return Tuple.Create(largestNegative, smallestPositive);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L, (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L, (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    }

}
"
HumanEval_138,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ     //ಕೊಟ್ಟಿರುವ ಸಂಖ್ಯೆಯನ್ನು n ಅನ್ನು ನಿಖರವಾಗಿ 4 ಧನಾತ್ಮಕ ಸಮ ಸಂಖ್ಯೆಗಳ ಮೊತ್ತವಾಗಿ ಬರೆಯಬಹುದೇ ಎಂದು ಮೌಲ್ಯಮಾಪನ ಮಾಡಿ     // >>> IsEqualToSumEven((4L))
    // (false)
    // >>> IsEqualToSumEven((6L))
    // (false)
    // >>> IsEqualToSumEven((8L))
    // (true)
    public static bool IsEqualToSumEven(long n) {
","using System;

class Problem {
    // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
    public static bool IsEqualToSumEven(long n) {
        // Check if n is at least the sum of the smallest 4 positive even numbers (2 + 2 + 2 + 2 = 8)
        return n >= 8 && n % 2 == 0;
    }
    
    static void Main() {
        Console.WriteLine(IsEqualToSumEven(4L));  // false
        Console.WriteLine(IsEqualToSumEven(6L));  // false
        Console.WriteLine(IsEqualToSumEven(8L));  // true
        Console.WriteLine(IsEqualToSumEven(10L)); // true
        Console.WriteLine(IsEqualToSumEven(12L)); // true
        Console.WriteLine(IsEqualToSumEven(15L)); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsEqualToSumEven((4L)) == (false));
    Debug.Assert(IsEqualToSumEven((6L)) == (false));
    Debug.Assert(IsEqualToSumEven((8L)) == (true));
    Debug.Assert(IsEqualToSumEven((10L)) == (true));
    Debug.Assert(IsEqualToSumEven((11L)) == (false));
    Debug.Assert(IsEqualToSumEven((12L)) == (true));
    Debug.Assert(IsEqualToSumEven((13L)) == (false));
    Debug.Assert(IsEqualToSumEven((16L)) == (true));
    }

}
"
HumanEval_139,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಅಲ್ಲಿ n > 0     //ಬ್ರೆಜಿಲಿಯನ್_ಫ್ಯಾಕ್ಟರಿಯಲ್ (n) = n! * (n-1)! * (n-2)! * . . . * 1!     //ಬ್ರೆಜಿಲಿಯನ್ ಫ್ಯಾಕ್ಟೊರಿಯಲ್ ಅನ್ನು ಹೀಗೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆಃ     // >>> SpecialFactorial((4L))
    // (288L)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    public static long SpecialFactorial(long n) {
","using System;
using System.Numerics;

class Problem {
    public static long SpecialFactorial(long n) {
        if (n <= 0)
            throw new ArgumentException(""n must be greater than 0"");
        
        BigInteger brazilianFactorial = 1;
        
        for (long i = 1; i <= n; i++) {
            brazilianFactorial *= Factorial(i);
        }
        
        return (long)brazilianFactorial;
    }
    
    private static BigInteger Factorial(long num) {
        BigInteger result = 1;
        for (long i = 1; i <= num; i++) {
            result *= i;
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SpecialFactorial((4L)) == (288L));
    Debug.Assert(SpecialFactorial((5L)) == (34560L));
    Debug.Assert(SpecialFactorial((7L)) == (125411328000L));
    Debug.Assert(SpecialFactorial((1L)) == (1L));
    }

}
"
HumanEval_140,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ನಂತರ ಎಲ್ಲಾ ಸತತ ಅಂತರಗಳನ್ನು -  ನೊಂದಿಗೆ ಬದಲಾಯಿಸಿ    //ಮತ್ತು ಒಂದು ಸ್ಟ್ರಿಂಗ್ 2 ಕ್ಕಿಂತ ಹೆಚ್ಚು ಸತತ ಸ್ಥಳಗಳನ್ನು ಹೊಂದಿದ್ದರೆ,     //ಒಂದು ವಾಕ್ಯದ ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗಿದೆ, ಎಲ್ಲಾ ಸ್ಥಳಗಳನ್ನು ಅಂಡರ್ಸ್ಕೋರ್ಗಳೊಂದಿಗೆ ಬದಲಾಯಿಸಿ,     // >>> FixSpaces(("" Example""))
    // (""Example"")
    // >>> FixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> FixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> FixSpaces(("" Example 3""))
    // (""_Example-3"")
    public static string FixSpaces(string text) {
","public static string FixSpaces(string text) {
        StringBuilder result = new StringBuilder();
        int spaceCount = 0;

        for (int i = 0; i < text.Length; i++) {
            if (text[i] == ' ') {
                spaceCount++;
            } else {
                if (spaceCount > 2) {
                    result.Append('-');
                } else {
                    for (int j = 0; j < spaceCount; j++) {
                        result.Append('_');
                    }
                }
                result.Append(text[i]);
                spaceCount = 0;
            }
        }

        if (spaceCount > 2) {
            result.Append('-');
        } else {
            for (int j = 0; j < spaceCount; j++) {
                result.Append('_');
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FixSpaces((""Example"")).Equals((""Example"")));
    Debug.Assert(FixSpaces((""Mudasir Hanif "")).Equals((""Mudasir_Hanif_"")));
    Debug.Assert(FixSpaces((""Yellow Yellow  Dirty  Fellow"")).Equals((""Yellow_Yellow__Dirty__Fellow"")));
    Debug.Assert(FixSpaces((""Exa   mple"")).Equals((""Exa-mple"")));
    Debug.Assert(FixSpaces((""   Exa 1 2 2 mple"")).Equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //- ಡಾಟ್ ನಂತರದ ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಈ ಒಂದು ಆಗಿರಬೇಕುಃ ['txt', 'exe', 'dll']     //ಲ್ಯಾಟಿನ್ ಅಕ್ಷರಮಾಲೆ ('a'-'z' ಮತ್ತು 'A'-'Z').    //- ಡಾಟ್ ಮೊದಲು ಸಬ್ಸ್ಟ್ರಿಂಗ್ ಖಾಲಿ ಇರಬಾರದು, ಮತ್ತು ಇದು ಒಂದು ಅಕ್ಷರದೊಂದಿಗೆ ಪ್ರಾರಂಭವಾಗುತ್ತದೆ     //- ಫೈಲ್ ಹೆಸರು ನಿಖರವಾಗಿ ಒಂದು ಚುಕ್ಕೆ '.'     //- ಫೈಲ್ ಹೆಸರಿನಲ್ಲಿ ಮೂರು ಅಂಕೆಗಳಿಗಿಂತ ಹೆಚ್ಚು ('0'-'9') ಇರಬಾರದು.    //ಈ ಕೆಳಗಿನವುಗಳನ್ನು ಪೂರೈಸಲಾಗಿದೆ:    //ಒಂದು ಕಡತದ ಹೆಸರು ಮಾನ್ಯವೆಂದು ಪರಿಗಣಿಸಲ್ಪಡುತ್ತದೆ ಮತ್ತು ಕೆಳಗಿನ ಎಲ್ಲಾ ಷರತ್ತುಗಳನ್ನು ಪೂರೈಸಿದರೆ ಮಾತ್ರ     //ಫೈಲ್ ಹೆಸರು ಮಾನ್ಯವಾಗಿದ್ದರೆ 'ಹೌದು' ಮತ್ತು ಇಲ್ಲದಿದ್ದರೆ 'ಇಲ್ಲ' ಎಂದು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಒಂದು ಫೈಲ್ನ ಹೆಸರನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು  ಅನ್ನು ಹಿಂದಿರುಗಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ರಚಿಸಿ.    // >>> FileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> FileNameCheck((""1example.dll""))
    // (""No"")
    public static string FileNameCheck(string file_name) {
","using System;
using System.Text.RegularExpressions;

class Problem {
    public static string FileNameCheck(string file_name) {
        // Regular expression to validate the file name
        string pattern = @""^[a-zA-Z][^.]*\.[^.]+$"";
        
        // Check if there is exactly one dot and matches the overall pattern
        if (Regex.IsMatch(file_name, pattern)) {
            string[] parts = file_name.Split('.');
            
            // Check if the file extension is one of the allowed values
            if (new[] { ""txt"", ""exe"", ""dll"" }.Contains(parts[1])) {
                // Count the number of digits in the file name
                int digitCount = file_name.Count(char.IsDigit);
                
                // Validate the digit count
                if (digitCount <= 3) {
                    return ""Yes"";
                }
            }
        }
        
        return ""No"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FileNameCheck((""example.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1example.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s1sdf3.asd"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""K.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""MY16FILE3.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""His12FILE94.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_Y.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""?aREYA.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""/this_is_valid.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.wow"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txtexe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""#this2_i4s_5valid.ten"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""@this1_is6_valid.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_12valid.6exe4.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""all.exe.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_No.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""Is3youfault.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""no_one#knows.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1I563_Yes3.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_Yes3.txtt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final..txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final132"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_f4indsartal132."")).Equals((""No"")));
    Debug.Assert(FileNameCheck(("".txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s."")).Equals((""No"")));
    }

}
"
HumanEval_142,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಪಟ್ಟಿಯಲ್ಲಿರುವ ನಮೂದುಗಳನ್ನು ಬದಲಾಯಿಸಿ, ಅದರ ಸೂಚ್ಯಂಕಗಳು 3 ಅಥವಾ 4 ರ ಬಹುಸಂಖ್ಯೆಯಲ್ಲ. ನಂತರ ಕಾರ್ಯವು ಎಲ್ಲಾ ನಮೂದುಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //3 ರ ಬಹುಸಂಖ್ಯೆ ಮತ್ತು ಅದರ ಸೂಚ್ಯಂಕವು 4 ರ ಬಹುಸಂಖ್ಯೆಯಾಗಿದ್ದರೆ ಮತ್ತು 3 ರ ಬಹುಸಂಖ್ಯೆಯಲ್ಲದಿದ್ದರೆ ಪೂರ್ಣಾಂಕ ನಮೂದನ್ನು ಘನೀಕರಿಸುತ್ತದೆ. ಈ ಕಾರ್ಯವು     //ಈ ಕಾರ್ಯವು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ. ಪಟ್ಟಿಯಲ್ಲಿರುವ ಎಲ್ಲಾ ನಮೂದುಗಳಿಗೆ, ಅದರ ಸೂಚ್ಯಂಕವು a ಆಗಿದ್ದರೆ ಕಾರ್ಯವು ಪೂರ್ಣಾಂಕ ನಮೂದನ್ನು ಚೌಕೀಕರಿಸುತ್ತದೆ.    //""     // >>> lst
    // (long)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})
    // >>> lst
    // (long)new List<long>()
    // >>> lst
    // (long)new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L})
    public static long SumSquares(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<long> lst)
    {
        for (int i = 0; i < lst.Count; i++)
        {
            if (i % 3 == 0)
            {
                lst[i] = lst[i] * lst[i];
            }
            else if (i % 4 == 0)
            {
                lst[i] = lst[i] * lst[i] * lst[i];
            }
        }
        long sum = 0;
        foreach (long number in lst)
        {
            sum += number;
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (6L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)4L, (long)9L}))) == (14L));
    Debug.Assert(SumSquares((new List<long>())) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L}))) == (9L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L}))) == (-3L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)0L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L}))) == (-126L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-56L, (long)-99L, (long)1L, (long)0L, (long)-2L}))) == (3030L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)-1L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-16L, (long)-9L, (long)-2L, (long)36L, (long)36L, (long)26L, (long)-20L, (long)25L, (long)-40L, (long)20L, (long)-4L, (long)12L, (long)-26L, (long)35L, (long)37L}))) == (-14196L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-3L, (long)17L, (long)-1L, (long)-15L, (long)13L, (long)-1L, (long)14L, (long)-14L, (long)-12L, (long)-5L, (long)14L, (long)-14L, (long)6L, (long)13L, (long)11L, (long)16L, (long)16L, (long)4L, (long)10L}))) == (-1448L));
    }

}
"
HumanEval_143,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ 1:     //ಹೊಸ ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿನ ಪದಗಳ ಕ್ರಮವು ಮೂಲದಂತೆಯೇ ಇರಬೇಕು.    //ಇದರ ಉದ್ದಗಳು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆಗಳಾಗಿವೆ,     //ಮತ್ತು ನೀವು ಮೂಲ ವಾಕ್ಯದಿಂದ ಪದಗಳನ್ನು ಹೊಂದಿರುವ ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಮರಳಿ ಮಾಡಬೇಕು,     //ವಾಕ್ಯವು ಕೆಲವು ಪದಗಳನ್ನು ಒಳಗೊಂಡಿದೆ,     //ನಿಮಗೆ ಒಂದು ವಾಕ್ಯವನ್ನು ಪ್ರತಿನಿಧಿಸುವ ಸ್ಟ್ರಿಂಗ್ ನೀಡಲಾಗಿದೆ,     // >>> WordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> WordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    public static string WordsInSentence(string sentence) {
","using System;
using System.Collections.Generic;

class Problem {
    public static string WordsInSentence(string sentence) {
        bool IsPrime(int number) {
            if (number <= 1) return false;
            if (number == 2) return true;
            for (int i = 2; i * i <= number; i++) {
                if (number % i == 0) return false;
            }
            return true;
        }

        string[] words = sentence.Split(' ');
        List<string> primeLengthWords = new List<string>();

        foreach (string word in words) {
            if (IsPrime(word.Length)) {
                primeLengthWords.Add(word);
            }
        }

        return string.Join("" "", primeLengthWords);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsInSentence((""This is a test"")).Equals((""is"")));
    Debug.Assert(WordsInSentence((""lets go for swimming"")).Equals((""go for"")));
    Debug.Assert(WordsInSentence((""there is no place available here"")).Equals((""there is no place"")));
    Debug.Assert(WordsInSentence((""Hi I am Hussein"")).Equals((""Hi am Hussein"")));
    Debug.Assert(WordsInSentence((""go for it"")).Equals((""go for it"")));
    Debug.Assert(WordsInSentence((""here"")).Equals(("""")));
    Debug.Assert(WordsInSentence((""here is"")).Equals((""is"")));
    }

}
"
HumanEval_144,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ನೀವು x, ಮತ್ತು n ಯನ್ನು ಮಾನ್ಯ ಭಿನ್ನರಾಶಿಗಳೆಂದು ಊಹಿಸಬಹುದು, ಮತ್ತು ಶೂನ್ಯವನ್ನು ನಾಮಕರಣವಾಗಿ ಹೊಂದಿಲ್ಲ.    //ಅಲ್ಲಿ ಎಣಿಕೆ ಮತ್ತು ನಾಮಕರಣ ಎರಡೂ ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳಾಗಿವೆ.    //x ಮತ್ತು n ಎರಡೂ, ಒಂದು ಭಿನ್ನರಾಶಿಯ ಸ್ಟ್ರಿಂಗ್ ಪ್ರಾತಿನಿಧ್ಯವಾಗಿದೆ, ಮತ್ತು ಈ ಕೆಳಗಿನ ಸ್ವರೂಪವನ್ನು ಹೊಂದಿವೆ,     //x * n. x * n ಒಂದು ಪೂರ್ಣಾಂಕಕ್ಕೆ ಮೌಲ್ಯಮಾಪನ ಮಾಡಿದರೆ ಮತ್ತು false     //ನಿಮ್ಮ ಕಾರ್ಯವು ಅಭಿವ್ಯಕ್ತಿಯನ್ನು ಸರಳಗೊಳಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಅಳವಡಿಸುವುದು     // >>> Simplify((""1/5""), (""5/1""))
    // (true)
    // >>> Simplify((""1/6""), (""2/1""))
    // (false)
    // >>> Simplify((""7/10""), (""10/2""))
    // (false)
    public static bool Simplify(string x, string n) {
","using System;

class Problem {
    public static bool Simplify(string x, string n) {
        var xParts = x.Split('/');
        var nParts = n.Split('/');
        
        int xNumerator = int.Parse(xParts[0]);
        int xDenominator = int.Parse(xParts[1]);
        
        int nNumerator = int.Parse(nParts[0]);
        int nDenominator = int.Parse(nParts[1]);
        
        // Calculate the resulting fraction for x * n
        int resultNumerator = xNumerator * nNumerator;
        int resultDenominator = xDenominator * nDenominator;
        
        // Simplify the fraction by finding the gcd
        int gcd = GCD(resultNumerator, resultDenominator);
        resultNumerator /= gcd;
        resultDenominator /= gcd;
        
        // It is a whole number if the simplified denominator is 1
        return resultDenominator == 1;
    }
    
    private static int GCD(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/6""), (""2/1"")) == (false));
    Debug.Assert(Simplify((""5/1""), (""3/1"")) == (true));
    Debug.Assert(Simplify((""7/10""), (""10/2"")) == (false));
    Debug.Assert(Simplify((""2/10""), (""50/10"")) == (true));
    Debug.Assert(Simplify((""7/2""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""11/6""), (""6/1"")) == (true));
    Debug.Assert(Simplify((""2/3""), (""5/2"")) == (false));
    Debug.Assert(Simplify((""5/2""), (""3/5"")) == (false));
    Debug.Assert(Simplify((""2/4""), (""8/4"")) == (true));
    Debug.Assert(Simplify((""2/4""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಮೂಲ ಪಟ್ಟಿಯಲ್ಲಿರುವ ಸೂಚ್ಯಂಕದ ಆಧಾರದ ಮೇಲೆ ಅವುಗಳನ್ನು ಕ್ರಮಗೊಳಿಸಿ.    //ಗಮನಿಸಿಃ ಹಲವಾರು ಐಟಂಗಳು ತಮ್ಮ ಅಂಕೆಗಳ ಮೊತ್ತವನ್ನು ಹೊಂದಿದ್ದರೆ,     //ಅವುಗಳ ಅಂಕಿಗಳ ಮೊತ್ತದ ಪ್ರಕಾರ ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ.    //ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯನ್ನು ವಿಂಗಡಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ     // >>> OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L})))
    // (new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))
    // >>> OrderByPoints((new List<long>()))
    // (new List<long>())
    public static List<long> OrderByPoints(List<long> nums) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> OrderByPoints(List<long> nums)
    {
        return nums.Select((num, index) => new { Number = num, Index = index, DigitSum = SumOfDigits(num) })
                   .OrderBy(item => item.DigitSum)
                   .ThenBy(item => item.Index)
                   .Select(item => item.Number)
                   .ToList();
    }

    private static int SumOfDigits(long number)
    {
        number = Math.Abs(number);
        int sum = 0;
        while (number > 0)
        {
            sum += (int)(number % 10);
            number /= 10;
        }
        return sum;
    }

    static void Main(string[] args)
    {
        var sortedList = OrderByPoints(new List<long> { 1L, 11L, -1L, -11L, -12L });
        Console.WriteLine(string.Join("", "", sortedList));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L}))).Equals((new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1234L, (long)423L, (long)463L, (long)145L, (long)2L, (long)423L, (long)423L, (long)53L, (long)6L, (long)37L, (long)3457L, (long)3L, (long)56L, (long)0L, (long)46L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)6L, (long)53L, (long)423L, (long)423L, (long)423L, (long)1234L, (long)145L, (long)37L, (long)46L, (long)56L, (long)463L, (long)3457L}))));
    Debug.Assert(OrderByPoints((new List<long>())).Equals((new List<long>())));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)-11L, (long)-32L, (long)43L, (long)54L, (long)-98L, (long)2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)-3L, (long)-32L, (long)-98L, (long)-11L, (long)1L, (long)2L, (long)43L, (long)54L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L, (long)11L}))).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)2L, (long)11L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)0L, (long)6L, (long)6L, (long)-76L, (long)-21L, (long)23L, (long)4L}))).Equals((new List<long>(new long[]{(long)-76L, (long)-21L, (long)0L, (long)4L, (long)23L, (long)6L, (long)6L}))));
    }

}
"
HumanEval_146,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಒಂದು ಸಂಖ್ಯೆಯ ಮೊದಲ ಮತ್ತು ಕೊನೆಯ ಅಂಕೆಗಳು ಬೆಸ (1, 3, 5, 7, 9).    //ಪಟ್ಟಿಯಲ್ಲಿನ ಅಂಶಗಳ ಸಂಖ್ಯೆ 10 ಕ್ಕಿಂತ ಹೆಚ್ಚಿದ್ದರೆ ಮತ್ತು ಎರಡೂ     //ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ಇನ್ಪುಟ್ ಆಗಿ ತೆಗೆದುಕೊಳ್ಳುವ ಮತ್ತು ರಿಟರ್ನ್ಸ್  ಎಂದು ಕರೆಯುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ    // >>> Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L})))
    // (1L)
    // >>> Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L})))
    // (2L)
    public static long Specialfilter(List<long> nums) {
","public static long Specialfilter(List<long> nums) {
        return nums.Count(num => {
            if (num <= 10) return false;
            long positiveNum = Math.Abs(num);
            string numStr = positiveNum.ToString();
            char firstDigit = numStr[0];
            char lastDigit = numStr[numStr.Length - 1];
            return IsOddDigit(firstDigit) && IsOddDigit(lastDigit);
        });
    }

    private static bool IsOddDigit(char digit) {
        return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9';
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)5L, (long)-2L, (long)1L, (long)-5L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L}))) == (1L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L}))) == (2L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)43L, (long)-12L, (long)93L, (long)125L, (long)121L, (long)109L}))) == (4L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)71L, (long)-2L, (long)-33L, (long)75L, (long)21L, (long)19L}))) == (3L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>())) == (0L));
    }

}
"
HumanEval_147,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಮತ್ತು a[i] + a[j] + a[k] ಎಂಬುದು 3 ರ ಬಹುಸಂಖ್ಯೆ.    //i < j < k,  ಎಂಬಲ್ಲಿ a ನ ಮೂರು ಪಟ್ಟುಗಳ ಸಂಖ್ಯೆಯನ್ನು (a[i], a[j], a[k]) ಹಿಂತಿರುಗಿ.    //ಪ್ರತಿ i (1 ≤ i ≤ n) ಗಾಗಿ, a[i] = i * i - i + 1 ರ ಮೌಲ್ಯವನ್ನು ನೀಡಲಾಗುತ್ತದೆ.    //ನಿಮಗೆ ಒಂದು ಸಕಾರಾತ್ಮಕ ಪೂರ್ಣಾಂಕ n ನೀಡಲಾಗಿದೆ. ನೀವು ಉದ್ದ n ನ ಒಂದು ಪೂರ್ಣಾಂಕ ಪಟ್ಟಿಯನ್ನು ರಚಿಸಬೇಕು.    // >>> GetMaxTriples((5L))
    // (1L)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    public static long GetMaxTriples(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long GetMaxTriples(long n) {
        List<long> a = new List<long>();
        for (long i = 1; i <= n; i++) {
            a.Add(i * i - i + 1);
        }

        long count = 0;
        for (int i = 0; i < a.Count; i++) {
            for (int j = i + 1; j < a.Count; j++) {
                for (int k = j + 1; k < a.Count; k++) {
                    if ((a[i] + a[j] + a[k]) % 3 == 0) {
                        count++;
                    }
                }
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        long n = 5; // Example input
        Console.WriteLine(GetMaxTriples(n)); // Should output 1 based on the example given
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetMaxTriples((5L)) == (1L));
    Debug.Assert(GetMaxTriples((6L)) == (4L));
    Debug.Assert(GetMaxTriples((10L)) == (36L));
    Debug.Assert(GetMaxTriples((100L)) == (53361L));
    }

}
"
HumanEval_148,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಗ್ರಹಗಳ ಹೆಸರುಗಳು ಸರಿಯಾಗಿಲ್ಲ.    //ಕಾರ್ಯವು ಒಂದು ಖಾಲಿ ಟುಪಲ್ ಅನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು planet1 ಅಥವಾ planet2     //ಸೂರ್ಯನ ಸಮೀಪದಲ್ಲಿ.    //ಗ್ರಹ1ರ ಕಕ್ಷೆ ಮತ್ತು ಗ್ರಹ2ರ ಕಕ್ಷೆಯ ನಡುವೆ ಇದೆ,     //ಈ ಕಾರ್ಯವು     //ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ ಅದು ಎರಡು ಗ್ರಹಗಳ ಹೆಸರುಗಳನ್ನು ಸ್ಟ್ರಿಂಗ್ಸ್ planet1 ಮತ್ತು planet2 ಎಂದು ತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ.    //ಯುರೇನಸ್, ನೆಪ್ಚೂನ್     //ಮರ್ಕ್ಯುರಿ, ಮುಂದಿನದು ಶುಕ್ರ, ನಂತರ ಭೂಮಿಯ, ಮಂಗಳ, ಗುರು, ಶನಿ,     //ನಮ್ಮ ಸೌರವ್ಯೂಹದಲ್ಲಿ ಎಂಟು ಗ್ರಹಗಳಿವೆ: ಸೂರ್ಯನಿಗೆ ಹತ್ತಿರದವು     // >>> Bf((""Jupiter""), (""Neptune""))
    // (new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))
    // >>> Bf((""Earth""), (""Mercury""))
    // (List<string>(""Venus""))
    // >>> Bf((""Mercury""), (""Uranus""))
    // (new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))
    public static List<string> Bf(string planet1, string planet2) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> Bf(string planet1, string planet2) {
        List<string> planets = new List<string> { ""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"" };
        int index1 = planets.IndexOf(planet1);
        int index2 = planets.IndexOf(planet2);

        if (index1 == -1 || index2 == -1) {
            return new List<string>();
        }
        
        List<string> result = new List<string>();
        int start = Math.Min(index1, index2);
        int end = Math.Max(index1, index2);

        for (int i = start + 1; i < end; i++) {
            result.Add(planets[i]);
        }

        return result;
    }

    public static void Main() {
        Console.WriteLine(string.Join("", "", Bf(""Jupiter"", ""Neptune""))); // Output: Saturn, Uranus
        Console.WriteLine(string.Join("", "", Bf(""Earth"", ""Mercury"")));   // Output: Venus
        Console.WriteLine(string.Join("", "", Bf(""Mercury"", ""Uranus""))); // Output: Venus, Earth, Mars, Jupiter, Saturn
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Bf((""Jupiter""), (""Neptune"")).Equals((new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Mercury"")).Equals((new List<string>(new string[]{(string)""Venus""}))));
    Debug.Assert(Bf((""Mercury""), (""Uranus"")).Equals((new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))));
    Debug.Assert(Bf((""Neptune""), (""Venus"")).Equals((new List<string>(new string[]{(string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Mars""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Jupiter""), (""Makemake"")).Equals((new List<string>())));
    }

}
"
HumanEval_149,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಎಲ್ಲಾ ಪದಗಳು ಒಂದೇ ಉದ್ದವನ್ನು ಹೊಂದಿರುತ್ತವೆ ಎಂದು ನೀವು ಭಾವಿಸಬಹುದು.    //ಈ ಕಾರ್ಯವು ಒಂದು ಶ್ರೇಣಿಯ ಸ್ಟ್ರಿಂಗ್ ಗಳ ಪಟ್ಟಿಯನ್ನು ವಿಂಗಡಿತ ಕ್ರಮದಲ್ಲಿ ಹಿಂದಿರುಗಿಸಬೇಕು.    //ಎರಡು ಪದಗಳು ಒಂದೇ ಉದ್ದವಿದ್ದರೆ, ಪಟ್ಟಿಯನ್ನು ವರ್ಣಮಾಲೆಯ ಪ್ರಕಾರ ವಿಂಗಡಿಸಿ.    //ಈ ನಿಯಮದ ಪ್ರಕಾರ ವಿಂಗಡಿಸಲಾದ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು.    //ಪಟ್ಟಿಯ ಕ್ರಮವು ಪ್ರತಿ ಪದದ ಉದ್ದದಿಂದ ಏರಿಕೆಯಾಗಬೇಕು, ಮತ್ತು ನೀವು     //ಮತ್ತು ಅದು ನಕಲುಗಳನ್ನು ಹೊಂದಿರಬಹುದು.    //ಪಟ್ಟಿಯು ಯಾವಾಗಲೂ ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯಾಗಿದೆ ಮತ್ತು ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿ ಎಂದಿಗೂ,    //ಮತ್ತು ವಿಂಗಡಿಸಲಾದ ಕ್ರಮದೊಂದಿಗೆ ಫಲಿತಾಂಶದ ಪಟ್ಟಿಯನ್ನು ಹಿಂದಿರುಗಿಸುತ್ತದೆ,     //ಅದರಿಂದ ವಿಚಿತ್ರ ಉದ್ದಗಳನ್ನು ಹೊಂದಿರುವ ತಂತಿಗಳನ್ನು ಅಳಿಸುತ್ತದೆ,     //ಒಂದು ಸ್ಟ್ರಿಂಗ್ ಪಟ್ಟಿಯನ್ನು ನಿಯತಾಂಕವಾಗಿ ಸ್ವೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ,     // >>> ListSort((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""})))
    // (new List<string>(new string[]{(string)""aa""}))
    // >>> ListSort((new List<string>(new string[]{(string)""ab"", (string)""a"", (string)""aaa"", (string)""cd""})))
    // (new List<string>(new string[]{(string)""ab"", (string)""cd""}))
    public static List<string> SortedListSum(List<string> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ListSort(List<string> lst) {
        return lst.Where(x => x.Length % 2 == 0)
                  .OrderBy(x => x.Length)
                  .ThenBy(x => x)
                  .ToList();
    }
    
    static void Main() {
        var result1 = ListSort(new List<string> { ""aa"", ""a"", ""aaa"" });
        Console.WriteLine(string.Join("", "", result1)); // Output: aa

        var result2 = ListSort(new List<string> { ""ab"", ""a"", ""aaa"", ""cd"" });
        Console.WriteLine(string.Join("", "", result2)); // Output: ab, cd
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""}))).Equals((new List<string>(new string[]{(string)""aa""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""school"", (string)""AI"", (string)""asdf"", (string)""b""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""asdf"", (string)""school""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""b"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""dcba"", (string)""abcd"", (string)""a""}))).Equals((new List<string>(new string[]{(string)""abcd"", (string)""dcba""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""b"", (string)""c"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aaaa"", (string)""bbbb"", (string)""dd"", (string)""cc""}))).Equals((new List<string>(new string[]{(string)""cc"", (string)""dd"", (string)""aaaa"", (string)""bbbb""}))));
    }

}
"
HumanEval_150,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ಒಂದು ಅವಿಭಾಜ್ಯ ಸಂಖ್ಯೆ ಮತ್ತು y ನ ಮೌಲ್ಯವನ್ನು ಮರಳಿ ನೀಡಬೇಕು ಇಲ್ಲದಿದ್ದರೆ.    //ಒಂದು ಸರಳ ಪ್ರೋಗ್ರಾಂ ಇದು n  ಆಗಿದ್ದರೆ x ನ ಮೌಲ್ಯವನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು    // >>> XOrY((7L), (34L), (12L))
    // (34L)
    // >>> XOrY((15L), (8L), (5L))
    // (5L)
    public static long XOrY(long n, long x, long y) {
","using System;

class Problem {
    public static long XOrY(long n, long x, long y) {
        return IsPrime(n) ? x : y;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;
        if (number % 2 == 0 || number % 3 == 0) return false;
        
        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }
        
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(XOrY((7L), (34L), (12L)) == (34L));
    Debug.Assert(XOrY((15L), (8L), (5L)) == (5L));
    Debug.Assert(XOrY((3L), (33L), (5212L)) == (33L));
    Debug.Assert(XOrY((1259L), (3L), (52L)) == (3L));
    Debug.Assert(XOrY((7919L), (-1L), (12L)) == (-1L));
    Debug.Assert(XOrY((3609L), (1245L), (583L)) == (583L));
    Debug.Assert(XOrY((91L), (56L), (129L)) == (129L));
    Debug.Assert(XOrY((6L), (34L), (1234L)) == (1234L));
    Debug.Assert(XOrY((1L), (2L), (0L)) == (0L));
    Debug.Assert(XOrY((2L), (2L), (0L)) == (2L));
    }

}
"
HumanEval_151,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಪಟ್ಟಿಯಲ್ಲಿರುವ ಬೆಸ ಸಂಖ್ಯೆಗಳು. ಋಣಾತ್ಮಕ ಅಥವಾ ಪೂರ್ಣಾಂಕಗಳಲ್ಲದ ಸಂಖ್ಯೆಗಳನ್ನು ನಿರ್ಲಕ್ಷಿಸಿ.    //ಸಂಖ್ಯೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಿದರೆ, ಸಂಖ್ಯೆಗಳ ಚೌಕಗಳ ಮೊತ್ತವನ್ನು ಹಿಂತಿರುಗಿ     // >>> DoubleTheDifference((new List<float>(new long[]{(long)1L, (long)3L, (long)2L, (long)0L})))
    // (10L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)-1L, (long)-2L, (long)0L})))
    // (0L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)9L, (long)-2L})))
    // (81L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)0L})))
    // (0L)
    // If the input list is empty, return 0.
    public static long DoubleTheDifference(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    // Given a list of numbers, return the sum of squares of the numbers
    // in the list that are odd. Ignore numbers that are negative or not integers.
    public static long DoubleTheDifference(List<float> lst) {
        long sum = 0;
        foreach (var num in lst) {
            if (num >= 0 && num == (long)num && ((long)num % 2) != 0) {
                sum += (long)num * (long)num;
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoubleTheDifference((new List<float>())) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)5.0f, (float)4.0f}))) == (25L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.1f, (float)0.2f, (float)0.3f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.2f, (float)3.0f, (float)5.0f}))) == (34L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165L));
    }

}
"
HumanEval_152,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಮೌಲ್ಯವು 0 ಆಗಿದ್ದರೆ, ಇಲ್ಲದಿದ್ದರೆ, ಮೌಲ್ಯವು ಊಹೆ ಮತ್ತು ಸ್ಕೋರ್ ನಡುವಿನ ಸಂಪೂರ್ಣ ವ್ಯತ್ಯಾಸವಾಗಿದೆ.    //ಪ್ರತಿ ಊಹೆಯು ಎಷ್ಟು ದೂರದಲ್ಲಿದೆ ಎಂಬುದನ್ನು ಸೂಚಿಸುವ ಅದೇ ಉದ್ದದ ಪಟ್ಟಿಯನ್ನು ಹಿಂತಿರುಗಿ. ಅವರು ಸರಿಯಾಗಿ ಊಹಿಸಿದರೆ,     //ನಿಮಗೆ ಎರಡು ಪಟ್ಟಿಗಳ ಅಂಕಗಳು ಮತ್ತು ಊಹೆಗಳಿವೆ, ಪ್ರತಿ ಸೂಚ್ಯಂಕವು ಹೊಂದಾಣಿಕೆಯನ್ನು ತೋರಿಸುತ್ತದೆ.    //ನಿಮ್ಮ ಕೆಲಸವೆಂದರೆ, ಒಬ್ಬ ವ್ಯಕ್ತಿಯು ಹಲವಾರು ಪಂದ್ಯಗಳ ಫಲಿತಾಂಶಗಳನ್ನು ಸರಿಯಾಗಿ ಊಹಿಸಿದ್ದಾನೆಯೇ ಎಂಬುದನ್ನು ನಿರ್ಧರಿಸುವುದು.    //ಖಂಡಿತವಾಗಿಯೂ ಗಮನಿಸಬೇಕಾದ ಮತ್ತು ಹೋಲಿಸುವ ಮೌಲ್ಯದ.    //ಈ ಘಟನೆ ಅಂತಿಮವಾಗಿ ತಿಳಿದಿದೆ. ಆ ಕ್ಷಣದಲ್ಲಿ ನೀವು ಹೊಂದಿರುವ ಭಾವನೆಗಳು ಮತ್ತು ಆಲೋಚನೆಗಳು     //ನಾವು ದೀರ್ಘ ಕಾಯುತ್ತಿದ್ದವು ಕೆಲವು ಫಲಿತಾಂಶವನ್ನು ಆ ಭಾವನೆ ನೆನಪಿಡಿ ಭಾವಿಸುತ್ತೇನೆ     // >>> Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L})))
    // (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))
    // >>> Compare((new List<long>(new long[]{(long)0L, (long)5L, (long)0L, (long)0L, (long)0L, (long)4L})), (new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L, (long)0L, (long)-2L})))
    // (new List<long>(new long[]{(long)4L, (long)4L, (long)1L, (long)0L, (long)0L, (long)6L}))
    public static List<long> Compare(List<long> game, List<long> guess) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Compare(List<long> game, List<long> guess)
    {
        List<long> differences = new List<long>();
        for (int i = 0; i < game.Count; i++)
        {
            differences.Add(Math.Abs(game[i] - guess[i]));
        }
        return differences;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L})), (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L})), (new List<long>(new long[]{(long)-1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)0L, (long)0L, (long)1L}))));
    }

}
"
HumanEval_153,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //(ಅದರ ಬಲವು -1) ಆಗಿದೆ.    //""Slices.SErviNGSliCes"" ಅನ್ನು ಹಿಂತಿರುಗಿಸಿ ಏಕೆಂದರೆ ""SErviNGSliCes"" ಎಂಬುದು ಪ್ರಬಲ ವಿಸ್ತರಣೆಯಾಗಿದೆ     //ವಿಸ್ತರಣೆಗಳುಃ ['SErviNGSliCes', 'Cheese', 'StuFfed'] ಆಗ ನೀವು     //ಉದಾಹರಣೆಗೆ, ನಿಮಗೆ ""ಸ್ಲೈಸ್"" ಅನ್ನು ವರ್ಗವಾಗಿ ನೀಡಿದರೆ ಮತ್ತು     // ಪಟ್ಟಿಯಲ್ಲಿ ಮೊದಲನೆಯದನ್ನು ಆಯ್ಕೆಮಾಡಿ.    //ಎರಡು ಅಥವಾ ಅದಕ್ಕಿಂತ ಹೆಚ್ಚಿನ ವಿಸ್ತರಣೆಗಳು ಒಂದೇ ಬಲವನ್ನು ಹೊಂದಿದ್ದರೆ, ನೀವು     //ಸ್ವರೂಪ: ವರ್ಗದ ಹೆಸರು. ಬಲವಾದ ವಿಸ್ತರಣೆಯ ಹೆಸರು.     //ನೀವು ಬಲವಾದ ವಿಸ್ತರಣೆಯನ್ನು ಕಂಡುಹಿಡಿಯಬೇಕು ಮತ್ತು ಈ     //ವಿಸ್ತರಣೆಯ ಹೆಸರಿನಲ್ಲಿ, CAP - SM ಎಂಬ ಭಾಗದಿಂದ ಶಕ್ತಿಯನ್ನು ನೀಡಲಾಗುತ್ತದೆ.    //ವಿಸ್ತರಣೆಯ ಹೆಸರಿನಲ್ಲಿ ಅಕ್ಷರಗಳು, ಮತ್ತು SM ಚಿಕ್ಕ ಅಕ್ಷರಗಳ ಸಂಖ್ಯೆ ಆಗಿರಲಿ     //ವಿಸ್ತರಣೆಯ ಬಲವು ಈ ಕೆಳಗಿನಂತಿರುತ್ತದೆ: CAP ದೊಡ್ಡಕ್ಷರ ಸಂಖ್ಯೆಯಾಗಿರಲಿ     //ವಿಸ್ತರಣೆಗಳನ್ನು ವರ್ಗಕ್ಕೆ ಹೆಚ್ಚುವರಿ ವರ್ಗಗಳನ್ನು ಲೋಡ್ ಮಾಡಲು ಬಳಸಲಾಗುತ್ತದೆ.    //ನಿಮಗೆ ಒಂದು ವರ್ಗದ ಹೆಸರು (ಒಂದು ಸ್ಟ್ರಿಂಗ್) ಮತ್ತು ವಿಸ್ತರಣೆಗಳ ಪಟ್ಟಿಯನ್ನು ನೀಡಲಾಗುವುದು.    // >>> StrongestExtension((""my_class""), (new List<string>(new string[]{(string)""AA"", (string)""Be"", (string)""CC""})))
    // (""my_class.AA"")
    public static string StrongestExtension(string class_name, List<string> extensions) {
","public static string StrongestExtension(string class_name, List<string> extensions) {
        string strongestExtension = null;
        int maxStrength = int.MinValue;

        foreach (var extension in extensions) {
            int countUpper = extension.Count(char.IsUpper);
            int countLower = extension.Count(char.IsLower);
            int strength = countUpper - countLower;

            if (strength > maxStrength) {
                maxStrength = strength;
                strongestExtension = extension;
            }
        }

        return $""{class_name}.{strongestExtension}"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrongestExtension((""Watashi""), (new List<string>(new string[]{(string)""tEN"", (string)""niNE"", (string)""eIGHt8OKe""}))).Equals((""Watashi.eIGHt8OKe"")));
    Debug.Assert(StrongestExtension((""Boku123""), (new List<string>(new string[]{(string)""nani"", (string)""NazeDa"", (string)""YEs.WeCaNe"", (string)""32145tggg""}))).Equals((""Boku123.YEs.WeCaNe"")));
    Debug.Assert(StrongestExtension((""__YESIMHERE""), (new List<string>(new string[]{(string)""t"", (string)""eMptY"", (string)""nothing"", (string)""zeR00"", (string)""NuLl__"", (string)""123NoooneB321""}))).Equals((""__YESIMHERE.NuLl__"")));
    Debug.Assert(StrongestExtension((""K""), (new List<string>(new string[]{(string)""Ta"", (string)""TAR"", (string)""t234An"", (string)""cosSo""}))).Equals((""K.TAR"")));
    Debug.Assert(StrongestExtension((""__HAHA""), (new List<string>(new string[]{(string)""Tab"", (string)""123"", (string)""781345"", (string)""-_-""}))).Equals((""__HAHA.123"")));
    Debug.Assert(StrongestExtension((""YameRore""), (new List<string>(new string[]{(string)""HhAas"", (string)""okIWILL123"", (string)""WorkOut"", (string)""Fails"", (string)""-_-""}))).Equals((""YameRore.okIWILL123"")));
    Debug.Assert(StrongestExtension((""finNNalLLly""), (new List<string>(new string[]{(string)""Die"", (string)""NowW"", (string)""Wow"", (string)""WoW""}))).Equals((""finNNalLLly.WoW"")));
    Debug.Assert(StrongestExtension((""_""), (new List<string>(new string[]{(string)""Bb"", (string)""91245""}))).Equals((""_.Bb"")));
    Debug.Assert(StrongestExtension((""Sp""), (new List<string>(new string[]{(string)""671235"", (string)""Bb""}))).Equals((""Sp.671235"")));
    }

}
"
HumanEval_154,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ನಿಮಗೆ 2 ಪದಗಳನ್ನು ನೀಡಲಾಗಿದೆ. ನೀವು ಎರಡನೇ ಪದ ಅಥವಾ ಅದರ ಯಾವುದೇ ತಿರುಗುವಿಕೆಗಳು ಮೊದಲ ಪದದಲ್ಲಿ ಉಪಸರಣಿಯಾಗಿದ್ದರೆ ನೀವು true ಅನ್ನು ಹಿಂತಿರುಗಿಸಬೇಕಾಗಿದೆ.    // >>> CycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> CycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> CycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> CycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> CycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> CycpatternCheck((""himenss""), (""simen""))
    // (true)
    public static bool CycpatternCheck(string a, string b) {
","using System;

class Problem {
    public static bool CycpatternCheck(string a, string b) {
        if (a.Length < b.Length) {
            return false;
        }

        string combinedB = b + b;
        for (int i = 0; i < b.Length; i++) {
            string rotation = combinedB.Substring(i, b.Length);
            if (a.Contains(rotation)) {
                return true;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CycpatternCheck((""xyzw""), (""xyw"")) == (false));
    Debug.Assert(CycpatternCheck((""yello""), (""ell"")) == (true));
    Debug.Assert(CycpatternCheck((""whattup""), (""ptut"")) == (false));
    Debug.Assert(CycpatternCheck((""efef""), (""fee"")) == (true));
    Debug.Assert(CycpatternCheck((""abab""), (""aabb"")) == (false));
    Debug.Assert(CycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಒಂದು ಪೂರ್ಣಾಂಕವನ್ನು ನೀಡಲಾಗಿದೆ. ಒಂದು ಟುಪಲ್ ಅನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ ಅದು ಕ್ರಮವಾಗಿ ಸಮ ಮತ್ತು ಬೆಸ ಅಂಕೆಗಳ ಸಂಖ್ಯೆಯನ್ನು ಹೊಂದಿರುತ್ತದೆ.    // >>> EvenOddCount((-12L))
    // (Tuple.Create(1L, 1L))
    // >>> EvenOddCount((123L))
    // (Tuple.Create(1L, 2L))
    public static Tuple<long, long> EvenOddCount(long num) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    public static Tuple<long, long> EvenOddCount(long num) {
        // Convert the number to positive to handle negative numbers
        num = Math.Abs(num);
        long evenCount = 0;
        long oddCount = 0;
        
        while (num > 0) {
            long digit = num % 10;
            if (digit % 2 == 0)
                evenCount++;
            else
                oddCount++;
            num /= 10;
        }
        
        return Tuple.Create(evenCount, oddCount);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddCount((7L)).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(EvenOddCount((-78L)).Equals((Tuple.Create(1L, 1L))));
    Debug.Assert(EvenOddCount((3452L)).Equals((Tuple.Create(2L, 2L))));
    Debug.Assert(EvenOddCount((346211L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-345821L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-2L)).Equals((Tuple.Create(1L, 0L))));
    Debug.Assert(EvenOddCount((-45347L)).Equals((Tuple.Create(2L, 3L))));
    Debug.Assert(EvenOddCount((0L)).Equals((Tuple.Create(1L, 0L))));
    }

}
"
HumanEval_156,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು:     //ನಿರ್ಬಂಧಗಳು: 1 <= num <= 1000     //ಮತ್ತು ಅದನ್ನು ಸಣ್ಣ ಅಕ್ಷರಗಳಲ್ಲಿ ಹಿಂದಿರುಗಿಸಿ.    //ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕವನ್ನು ನೀಡಿದರೆ, ಅದರ ರೋಮನ್ ಸಂಖ್ಯಾ ಸಮಾನತೆಯನ್ನು ಸ್ಟ್ರಿಂಗ್ ಆಗಿ ಪಡೆಯಿರಿ,     // >>> IntToMiniRoman((19L))
    // (""xix"")
    // >>> IntToMiniRoman((152L))
    // (""clii"")
    // >>> IntToMiniRoman((426L))
    // (""cdxxvi"")
    public static string IntToMiniRoman(long number) {
","if (number < 1 || number > 1000)
            throw new ArgumentOutOfRangeException(""number"", ""Input must be between 1 and 1000"");

        // Mapping of Roman numerals
        var romanNumerals = new List<(int value, string numeral)>
        {
            (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
            (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
            (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
            (1, ""i"")
        };

        var sb = new StringBuilder();

        foreach (var (value, numeral) in romanNumerals)
        {
            while (number >= value)
            {
                sb.Append(numeral);
                number -= value;
            }
        }

        return sb.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IntToMiniRoman((19L)).Equals((""xix"")));
    Debug.Assert(IntToMiniRoman((152L)).Equals((""clii"")));
    Debug.Assert(IntToMiniRoman((251L)).Equals((""ccli"")));
    Debug.Assert(IntToMiniRoman((426L)).Equals((""cdxxvi"")));
    Debug.Assert(IntToMiniRoman((500L)).Equals((""d"")));
    Debug.Assert(IntToMiniRoman((1L)).Equals((""i"")));
    Debug.Assert(IntToMiniRoman((4L)).Equals((""iv"")));
    Debug.Assert(IntToMiniRoman((43L)).Equals((""xliii"")));
    Debug.Assert(IntToMiniRoman((90L)).Equals((""xc"")));
    Debug.Assert(IntToMiniRoman((94L)).Equals((""xciv"")));
    Debug.Assert(IntToMiniRoman((532L)).Equals((""dxxxii"")));
    Debug.Assert(IntToMiniRoman((900L)).Equals((""cm"")));
    Debug.Assert(IntToMiniRoman((994L)).Equals((""cmxciv"")));
    Debug.Assert(IntToMiniRoman((1000L)).Equals((""m"")));
    }

}
"
HumanEval_157,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //90 ಡಿಗ್ರಿ     //ಒಂದು ಬಲ ಕೋನ ತ್ರಿಕೋನವು ಒಂದು ಕೋನವು ಬಲ ಕೋನ ಅಥವಾ     //ವು ಒಂದು ಬಲಕೋನೀಯ ತ್ರಿಕೋನವನ್ನು ರೂಪಿಸುತ್ತದೆ, ಇಲ್ಲದಿದ್ದರೆ ಅದು ಸುಳ್ಳು.    //ತ್ರಿಭುಜದ ಮೂರು ಬದಿಗಳ ಉದ್ದವನ್ನು ನೀಡಲಾಗಿದೆ. ತ್ರಿಭುಜದ ಮೂರು     // >>> RightAngleTriangle((3L), (4L), (5L))
    // (true)
    // >>> RightAngleTriangle((1L), (2L), (3L))
    // (false)
    public static bool RightAngleTriangle(long a, long b, long c) {
","using System;

class Problem
{
    public static bool RightAngleTriangle(long a, long b, long c)
    {
        // Sort the sides to make it easier to apply the Pythagorean theorem.
        long[] sides = { a, b, c };
        Array.Sort(sides);

        // Check if the sum of the squares of the smaller two sides equals the square of the largest side.
        return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RightAngleTriangle((3L), (4L), (5L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (2L), (3L)) == (false));
    Debug.Assert(RightAngleTriangle((10L), (6L), (8L)) == (true));
    Debug.Assert(RightAngleTriangle((2L), (2L), (2L)) == (false));
    Debug.Assert(RightAngleTriangle((7L), (24L), (25L)) == (true));
    Debug.Assert(RightAngleTriangle((10L), (5L), (7L)) == (false));
    Debug.Assert(RightAngleTriangle((5L), (12L), (13L)) == (true));
    Debug.Assert(RightAngleTriangle((15L), (8L), (17L)) == (true));
    Debug.Assert(RightAngleTriangle((48L), (55L), (73L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (1L), (1L)) == (false));
    Debug.Assert(RightAngleTriangle((2L), (2L), (10L)) == (false));
    }

}
"
HumanEval_158,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಅಕ್ಷರಗಳ ಪಟ್ಟಿಯಲ್ಲಿ, ಶಬ್ದಕೋಶೀಯ ಕ್ರಮದಲ್ಲಿ ಮೊದಲು ಬರುವ ಅಕ್ಷರವನ್ನು ಹಿಂತಿರುಗಿಸಿ.    //ಬಹು ಸ್ಟ್ರಿಂಗ್ಗಳು ಗರಿಷ್ಠ ಸಂಖ್ಯೆಯ ಅನನ್ಯ     //ಈ ಪಟ್ಟಿಯು ವಿವಿಧ ಪದಗಳನ್ನು ಒಳಗೊಂಡಿದೆ. ಗರಿಷ್ಠ ಸಂಖ್ಯೆಯ ಪದವನ್ನು ಹಿಂತಿರುಗಿ     //ಸ್ಟ್ರಿಂಗ್ಗಳ ಪಟ್ಟಿಯನ್ನು ಸ್ವೀಕರಿಸುವ ಒಂದು ಕಾರ್ಯವನ್ನು ಬರೆಯಿರಿ.    // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""})))
    // (""string"")
    // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""})))
    // (""enam"")
    // >>> FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""})))
    // (""aaaaaaa"")
    public static string FindMax(List<string> words) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string FindMax(List<string> words)
    {
        string result = string.Empty;
        int maxUniqueChars = 0;

        foreach (var word in words)
        {
            var uniqueChars = word.ToCharArray().Distinct().Count();

            if (uniqueChars > maxUniqueChars || (uniqueChars == maxUniqueChars && string.Compare(word, result, StringComparison.Ordinal) < 0))
            {
                maxUniqueChars = uniqueChars;
                result = word;
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""}))).Equals((""string"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""}))).Equals((""enam"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""}))).Equals((""aaaaaaa"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""abc"", (string)""cba""}))).Equals((""abc"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""this"", (string)""game"", (string)""of"", (string)""footbott""}))).Equals((""footbott"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""gonna"", (string)""rock""}))).Equals((""gonna"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""a"", (string)""mad"", (string)""nation""}))).Equals((""nation"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""this"", (string)""is"", (string)""a"", (string)""prrk""}))).Equals((""this"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""b""}))).Equals((""b"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""play"", (string)""play""}))).Equals((""play"")));
    }

}
"
HumanEval_159,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆ:     //ಉಳಿದಿರುವ ಸಾಕಷ್ಟು ಕ್ಯಾರೆಟ್ಗಳು ಇಲ್ಲದಿದ್ದರೆ, ನೀವು ಉಳಿದಿರುವ ಎಲ್ಲಾ ಕ್ಯಾರೆಟ್ಗಳನ್ನು ತಿನ್ನುತ್ತೀರಿ, ಆದರೆ ಇನ್ನೂ ಹಸಿವಿನಿಂದ ಇರುತ್ತೀರಿ.    //ನಿಮ್ಮ ಊಟದ ನಂತರ ಉಳಿದಿರುವ ಕ್ಯಾರೆಟ್ಗಳ ಸಂಖ್ಯೆ ]     //ನೀವು ಊಟದ ನಂತರ ಸೇವಿಸಿದ ಕ್ಯಾರೆಟ್ಗಳ ಒಟ್ಟು ಸಂಖ್ಯೆಯ ಪಟ್ಟಿಯನ್ನು ನೀವು ಹಿಂದಿರುಗಿಸಬೇಕು,    //ಆದರೆ ಈಗ ನೀವು ದಿನಕ್ಕೆ ಊಟವನ್ನು ಪೂರ್ಣಗೊಳಿಸಲು ಹೆಚ್ಚು ಕ್ಯಾರೆಟ್ಗಳನ್ನು ತಿನ್ನಬೇಕು.    //ನೀವು ಹಸಿದ ಮೊಲ, ಮತ್ತು ನೀವು ಈಗಾಗಲೇ ಕ್ಯಾರೆಟ್ ಒಂದು ನಿರ್ದಿಷ್ಟ ಸಂಖ್ಯೆಯ ತಿನ್ನುತ್ತಿದ್ದ,     // >>> Eat((5L), (6L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)4L}))
    // >>> Eat((4L), (8L), (9L))
    // (new List<long>(new long[]{(long)12L, (long)1L}))
    // >>> Eat((1L), (10L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)0L}))
    // >>> Eat((2L), (11L), (5L))
    // (new List<long>(new long[]{(long)7L, (long)0L}))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    public static List<long> Eat(long number, long need, long remaining) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Eat(long number, long need, long remaining) {
        long totalEaten = number;
        long leftAfterMeals;

        if(remaining >= need) {
            totalEaten += need;
            leftAfterMeals = remaining - need;
        } else {
            totalEaten += remaining;
            leftAfterMeals = 0;
        }
        
        return new List<long>{ totalEaten, leftAfterMeals };
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Eat((5L), (6L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)4L}))));
    Debug.Assert(Eat((4L), (8L), (9L)).Equals((new List<long>(new long[]{(long)12L, (long)1L}))));
    Debug.Assert(Eat((1L), (10L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)0L}))));
    Debug.Assert(Eat((2L), (11L), (5L)).Equals((new List<long>(new long[]{(long)7L, (long)0L}))));
    Debug.Assert(Eat((4L), (5L), (7L)).Equals((new List<long>(new long[]{(long)9L, (long)2L}))));
    Debug.Assert(Eat((4L), (5L), (1L)).Equals((new List<long>(new long[]{(long)5L, (long)0L}))));
    }

}
"
HumanEval_160,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಆಪರೇಟರ್ ಪಟ್ಟಿಯಲ್ಲಿ ಕನಿಷ್ಠ ಒಂದು ಆಪರೇಟರ್ ಇದೆ, ಮತ್ತು ಆಪರೇಂಡ್ ಪಟ್ಟಿಯಲ್ಲಿ ಕನಿಷ್ಠ ಎರಡು ಆಪರೇಂಡ್ಗಳಿವೆ.    //ಆಪರೇಂಡ್ ವು ಋಣಾತ್ಮಕವಲ್ಲದ ಪೂರ್ಣಾಂಕಗಳ ಒಂದು ಪಟ್ಟಿಯಾಗಿದೆ.    //ಆಪರೇಟರ್ ಪಟ್ಟಿಯ ಉದ್ದವು ಆಪರೇಂಡ್ ಪಟ್ಟಿಯ ಉದ್ದಕ್ಕೆ ಒಂದು ಮೈನಸ್ಗೆ ಸಮಾನವಾಗಿರುತ್ತದೆ.    //ಟಿಪ್ಪಣಿ:     //=> ಫಲಿತಾಂಶ = 9     //ಫಲಿತಾಂಶ = 2 + 3 * 4 - 5     //ಪಟ್ಟಿ = [2, 3, 4, 5]     //ನಿರ್ವಾಹಕ ['+', '*', '-']     //ಉದಾಹರಣೆ:     //ಮಾಪಕೀಕರಣ (**)     //ನೆಲದ ವಿಭಾಗ ( // )     //ಗುಣಾಕಾರ ( *)     //ಕಳೆಯುವಿಕೆ ( - )     //ಸೇರ್ಪಡೆ (+)     //ಮೂಲಭೂತ ಬೀಜಗಣಿತದ ಕಾರ್ಯಾಚರಣೆಗಳು:     // ಮತ್ತು ಈ ಅಭಿವ್ಯಕ್ತಿಯ ಮೌಲ್ಯಮಾಪನವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ.    //ಎರಡನೇ ಪಟ್ಟಿಯು ಪೂರ್ಣಾಂಕಗಳ ಪಟ್ಟಿಯಾಗಿದೆ. ಅಲ್ಜೀಬ್ರಿಕ್ ಅನ್ನು ನಿರ್ಮಿಸಲು ಎರಡು ಪಟ್ಟಿಗಳನ್ನು ಬಳಸಿ     //ಎರಡು ಪಟ್ಟಿಗಳನ್ನು ನೀಡಲಾಗಿದೆ ಆಪರೇಟರ್, ಮತ್ತು ಆಪರೇಂಡ್. ಮೊದಲ ಪಟ್ಟಿಯಲ್ಲಿ ಮೂಲಭೂತ ಬೀಜಗಣಿತದ ಕಾರ್ಯಾಚರಣೆಗಳು ಇವೆ, ಮತ್ತು     public static long DoAlgebra(List<string> op, List<long> operand) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long DoAlgebra(List<string> op, List<long> operand)
    {
        if (op.Count + 1 != operand.Count || operand.Count < 2)
        {
            throw new ArgumentException(""Invalid input lists."");
        }

        long result = operand[0];

        for (int i = 0; i < op.Count; i++)
        {
            string currentOp = op[i];
            long currentOperand = operand[i + 1];

            switch (currentOp)
            {
                case ""+"":
                    result += currentOperand;
                    break;
                case ""-"":
                    result -= currentOperand;
                    break;
                case ""*"":
                    result *= currentOperand;
                    break;
                case ""//"":
                    result /= currentOperand;
                    break;
                case ""**"":
                    result = (long)Math.Pow(result, currentOperand);
                    break;
                default:
                    throw new InvalidOperationException($""Unsupported operator: {currentOp}"");
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""**"", (string)""*"", (string)""+""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (37L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""+"", (string)""*"", (string)""-""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (9L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""//"", (string)""*""})), (new List<long>(new long[]{(long)7L, (long)3L, (long)4L}))) == (8L));
    }

}
"
HumanEval_161,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗಳು     //ಕಾರ್ಯವು ಫಲಿತಾಂಶದ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂದಿರುಗಿಸಬೇಕು.    //ಸ್ಟ್ರಿಂಗ್ನಲ್ಲಿ ಯಾವುದೇ ಅಕ್ಷರಗಳಿಲ್ಲದಿದ್ದರೆ, ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಮ್ಮುಖಗೊಳಿಸಿ.    //ಇಲ್ಲದಿದ್ದರೆ ಹಾಗೇ ಇಟ್ಟುಕೊಳ್ಳಿ.    //s[i] ಒಂದು ಅಕ್ಷರವಾಗಿದ್ದರೆ, ಅದರ ಪ್ರಕರಣವನ್ನು ಕೆಳಭಾಗದಿಂದ ಮೇಲಿನ ಕಡೆಗೆ ಅಥವಾ ಪ್ರತಿಯಾಗಿ ತಿರುಗಿಸಿ,     //ನಿಮಗೆ ಒಂದು ಸ್ಟ್ರಿಂಗ್ s ನೀಡಲಾಗಿದೆ.    // >>> Solve((""1234""))
    // (""4321"")
    // >>> Solve((""ab""))
    // (""AB"")
    // >>> Solve((""#a@C""))
    // (""#A@c"")
    public static string Solve(string s) {
","public static string Solve(string s) {
        bool hasLetter = s.Any(char.IsLetter);
        if (hasLetter) {
            var result = new StringBuilder(s.Length);
            foreach (char c in s) {
                if (char.IsLetter(c)) {
                    result.Append(char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c));
                } else {
                    result.Append(c);
                }
            }
            return result.ToString();
        } else {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((""AsDf"")).Equals((""aSdF"")));
    Debug.Assert(Solve((""1234"")).Equals((""4321"")));
    Debug.Assert(Solve((""ab"")).Equals((""AB"")));
    Debug.Assert(Solve((""#a@C"")).Equals((""#A@c"")));
    Debug.Assert(Solve((""#AsdfW^45"")).Equals((""#aSDFw^45"")));
    Debug.Assert(Solve((""#6@2"")).Equals((""2@6#"")));
    Debug.Assert(Solve((""#$a^D"")).Equals((""#$A^d"")));
    Debug.Assert(Solve((""#ccc"")).Equals((""#CCC"")));
    }

}
"
HumanEval_162,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //'ಪಠ್ಯ' ಒಂದು ಖಾಲಿ ಸ್ಟ್ರಿಂಗ್ ಆಗಿದ್ದರೆ, null ಅನ್ನು ಹಿಂತಿರುಗಿಸಿ.    //ಒಂದು ಸ್ಟ್ರಿಂಗ್ 'ಪಠ್ಯ' ನೀಡಲಾಗಿದೆ, ಅದರ md5 ಹ್ಯಾಶ್ ಸಮಾನ ಸ್ಟ್ರಿಂಗ್ ಅನ್ನು ಹಿಂತಿರುಗಿ.    // >>> StringToMd5((""Hello world""))
    // (""3e25960a79dbc69b674cd4ec67a72c62"")
    public static string StringToMd5(string text) {
","using System;
using System.Security.Cryptography;
using System.Text;

class Problem {
    public static string StringToMd5(string text) {
        if (string.IsNullOrEmpty(text)) {
            return null;
        }
        
        using (MD5 md5 = MD5.Create()) {
            byte[] inputBytes = Encoding.UTF8.GetBytes(text);
            byte[] hashBytes = md5.ComputeHash(inputBytes);
            
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < hashBytes.Length; i++) {
                sb.Append(hashBytes[i].ToString(""x2""));
            }
            return sb.ToString();
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringToMd5((""Hello world"")).Equals((""3e25960a79dbc69b674cd4ec67a72c62"")));
    Debug.Assert(StringToMd5(("""")).Equals(null));
    Debug.Assert(StringToMd5((""A B C"")).Equals((""0ef78513b0cb8cef12743f5aeb35f888"")));
    Debug.Assert(StringToMd5((""password"")).Equals((""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,kan_Knda,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //ಉದಾಹರಣೆಗೆ:     //ಮತ್ತು b, ಏರುತ್ತಿರುವ ಕ್ರಮದಲ್ಲಿ.    //ಎರಡು ಧನಾತ್ಮಕ ಪೂರ್ಣಾಂಕಗಳನ್ನು ನೀಡಿದರೆ a ಮತ್ತು b, a  ನಡುವಿನ ಸಮ ಅಂಕೆಗಳನ್ನು ಹಿಂತಿರುಗಿ.    // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    public static List<long> GenerateIntegers(long a, long b) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Given two positive integers a and b, return the even digits between a
    // and b, in ascending order.
    // For example:
    // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    
    public static List<long> GenerateIntegers(long a, long b)
    {
        List<long> evenDigits = new List<long> { 2, 4, 6, 8 };
        List<long> result = new List<long>();

        if (a > b)
        {
            // Swap values if a is greater than b to ensure ascending order
            long temp = a;
            a = b;
            b = temp;
        }

        foreach (var even in evenDigits)
        {
            if (even >= a && even <= b)
            {
                result.Add(even);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GenerateIntegers((2L), (10L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((10L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((132L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((17L), (89L)).Equals((new List<long>())));
    }

}
"
