[{"task_id":"HumanEval_0","nl":"kmb_Latn","pl":"go_test.go","prompt":"package has_close_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ o ku bhana kua tokala\/\/Tala se mu mukanda muala o ijimbuete, muala-mu o ijimbuete ia beta ku zukama.\/\/ >>> has_close_elements([]float64{1.0, 2.0, 3.0}, 0.5)\n\/\/ false\n\/\/ >>> has_close_elements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n\/\/ true\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n","canonical_solution":"package has_close_elements_test\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\n\/\/ Check if in given list of numbers, are any two numbers closer to each other than\n\/\/ given threshold.\nfunc has_close_elements(numbers []float64, threshold float64) bool {\n\tsort.Float64s(numbers)\n\tfor i := 0; i < len(numbers)-1; i++ {\n\t\tif math.Abs(numbers[i+1]-numbers[i]) < threshold {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestHasCloseElements(t *testing.T) {\n\ttestCases := []struct {\n\t\tnumbers   []float64\n\t\tthreshold float64\n\t\texpected  bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, false},\n\t\t{[]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3, true},\n\t\t{[]float64{1.5, 1.8, 2.2}, 0.3, true},\n\t\t{[]float64{0.2, 0.4, 0.6, 0.8, 1.0}, 0.15, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"TestCase%d\", i+1), func(t *testing.T) {\n\t\t\tresult := has_close_elements(tc.numbers, tc.threshold)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestHas_Close_Elements(t *testing.T) {\n  candidate := has_close_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95), expected: true },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8), expected: false },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0), expected: true },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_1","nl":"kmb_Latn","pl":"go_test.go","prompt":"package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O jipondo joso ji moneka mu kaxa, ka tokala ku ji kaia.\/\/O ibuka ia jisabhu, a i sokejeka kiambote (kala ibuka ia jisabhu a i sokejeka kiambote) ki i di sokejeka mu ibuka ia jisabhu.\/\/O ku uana o jimbandu jiji, kua-nda kuatekesa o muthu ku sola ni unjimu.\/\/O mbandu íii ia função, ia tokala ku kala ni ijimbuete iavulu.\/\/ >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n\/\/ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n","canonical_solution":"package separate_paren_groups\n\nfunc separate_paren_groups(paren_string string) []string {\n\tvar result []string\n\tvar currentGroup []rune\n\topenCount := 0\n\n\tfor _, char := range paren_string {\n\t\tif char == '(' {\n\t\t\topenCount++\n\t\t\tcurrentGroup = append(currentGroup, char)\n\t\t} else if char == ')' {\n\t\t\topenCount--\n\t\t\tcurrentGroup = append(currentGroup, char)\n\n\t\t\tif openCount == 0 {\n\t\t\t\tresult = append(result, string(currentGroup))\n\t\t\t\tcurrentGroup = nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}","tests":"func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_2","nl":"kmb_Latn","pl":"go_test.go","prompt":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Londekesa o mbandu ia kifika mu kaxa.\/\/(O mbandu ia kaxa iofele, iala ni 1 mu kaxa)\/\/ni mbandu ia kijimbuete (o kijimbuete kia dikota, kiofele, o kijimbuete kia dikota ndenge) ni mbandu ia ku kondala \/\/O mbandu ia beta-o-kota, o mbandu ia beta-o-kota.\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n","canonical_solution":"package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive floating point number, it can be decomposed into\n\/\/ an integer part (largest integer smaller than given number) and decimals\n\/\/ (leftover part always smaller than 1).\n\/\/ Return the decimal part of the number.\n\/\/ >>> truncate_number(3.5)\n\/\/ 0.5\nfunc truncate_number(number float64) float64 {\n    integerPart := int(number)\n    return number - float64(integerPart)\n}\n\nfunc TestTruncateNumber(t *testing.T) {\n    testCases := []struct {\n        input float64\n        expected float64\n    }{\n        {3.5, 0.5},\n        {0.0, 0.0},\n        {7.25, 0.25},\n        {4.99, 0.99},\n        {2.0, 0.0},\n    }\n\n    for _, tc := range testCases {\n        result := truncate_number(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %.2f, got %.2f\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(truncate_number(3.5)) \/\/ Should print 0.5\n    fmt.Println(truncate_number(7.25)) \/\/ Should print 0.25\n}","tests":"func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_3","nl":"kmb_Latn","pl":"go_test.go","prompt":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu veji dia kiki, o muthu u tena ku bhana o kitambuijilu kia tokala kia kibhuidisu, kala:\/\/O kikalakalu kiê, o ku mona se kuebhi kua tena ku sanga o kitadi kiki.\/\/O ku soneka o ima ioso i ua mesena mu kaxa, a i soneka mu mukanda u ku tangela kuila eie ua-nda ku i katula ni ku i ta mu mukanda u ku tangela kuila o mukanda u mateka kiki:\/\/ >>> below_zero([]int{1, 2, 3})\n\/\/ false\n\/\/ >>> below_zero([]int{1, 2, -4, 5})\n\/\/ true\nfunc below_zero(operations []int) bool {\n","canonical_solution":"package below_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc below_zero(operations []int) bool {\n    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestBelowZero(t *testing.T) {\n    testCases := []struct {\n        operations []int\n        expected   bool\n    }{\n        {[]int{1, 2, 3}, false},\n        {[]int{1, 2, -4, 5}, true},\n        {[]int{0, -1, 1}, true},\n        {[]int{}, false},\n        {[]int{-1, 1, -1, 1}, true},\n    }\n    for _, tc := range testCases {\n        result := below_zero(tc.operations)\n        if result != tc.expected {\n            t.Errorf(\"below_zero(%v) = %v; want %v\", tc.operations, result, tc.expected)\n        }\n    }\n}","tests":"func TestBelow_Zero(t *testing.T) {\n  candidate := below_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: false },\n     { actual: candidate([]int{1, 2, -3, 1, 2, -3}), expected: false },\n     { actual: candidate([]int{1, 2, -4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -4}), expected: false },\n     { actual: candidate([]int{1, -1, 2, -2, 5, -5, 4, -5}), expected: true },\n     { actual: candidate([]int{1, -2, 2, -2, 5, -5, 4, -4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_4","nl":"kmb_Latn","pl":"go_test.go","prompt":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/MAD = avalua  x - x_ avalua \/\/kima ni kaxi (o kaxi ka kifika kiki): \/\/O ukexilu ua ku lungulula o ukexilu ua jivelusu, ulondekesa kuila o jivelusu jiji ki ji difu.\/\/O kuila o athu a tena ku di longa o Bibidia ni madivulu metu?\/\/Phala kuijiia o ima iala ku muxima ua muthu, tala o mukanda, Método de cálculo da variável média absoluta.\/\/ >>> mean_absolute_deviation([]float64{1.0, 2.0, 3.0, 4.0})\n\/\/ 1.0\nfunc mean_absolute_deviation(numbers []float64) float64 {\n","canonical_solution":"package mean_absolute_deviation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc mean_absolute_deviation(numbers []float64) float64 {\n    var sum float64\n    for _, num := range numbers {\n        sum += num\n    }\n    mean := sum \/ float64(len(numbers))\n\n    var madSum float64\n    for _, num := range numbers {\n        madSum += math.Abs(num - mean)\n    }\n    return madSum \/ float64(len(numbers))\n}\n\nfunc TestMeanAbsoluteDeviation(t *testing.T) {\n    tests := []struct {\n        input []float64\n        want  float64\n    }{\n        {[]float64{1.0, 2.0, 3.0, 4.0}, 1.0},\n        {[]float64{1.0, 1.0, 1.0, 1.0}, 0.0},\n        {[]float64{2.0, 5.0, 7.0, 10.0}, 2.5},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"mean_absolute_deviation(%v)\", test.input), func(t *testing.T) {\n            got := mean_absolute_deviation(test.input)\n            if got != test.want {\n                t.Errorf(\"mean_absolute_deviation(%v) = %v; want %v\", test.input, got, test.want)\n            }\n        })\n    }\n}","tests":"func TestMean_Absolute_Deviation(t *testing.T) {\n  candidate := mean_absolute_deviation\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0}), expected: 0.5 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0}), expected: 1.0 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: 1.2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_5","nl":"kmb_Latn","pl":"go_test.go","prompt":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O \"dijitadi\" di moneka ngó kioso kia soneka o dixi \"dijitadi\" dia mbandu ia mukanda.\/\/ >>> intersperse([]int{}, 4)\n\/\/ []int{}\n\/\/ >>> intersperse([]int{1, 2, 3}, 4)\n\/\/ []int{1, 4, 2, 4, 3}\nfunc intersperse(numbers []int, delimeter int) []int {\n","canonical_solution":"package intersperse_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc intersperse(numbers []int, delimiter int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := make([]int, 0, len(numbers)*2-1)\n    for i, num := range numbers {\n        if i > 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, num)\n    }\n    return result\n}\n\nfunc TestIntersperse(t *testing.T) {\n    testCases := []struct{\n        input []int\n        delimiter int\n        expected []int\n    }{\n        {[]int{}, 4, []int{}},\n        {[]int{1, 2, 3}, 4, []int{1, 4, 2, 4, 3}},\n        {[]int{1}, 4, []int{1}},\n        {[]int{1, 2}, 4, []int{1, 4, 2}},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"%v, %d\", tc.input, tc.delimiter), func(t *testing.T) {\n            result := intersperse(tc.input, tc.delimiter)\n            if !equal(result, tc.expected) {\n                t.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n            }\n        })\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    \n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    \n    return true\n}","tests":"func TestIntersperse(t *testing.T) {\n  candidate := intersperse\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}, 7), expected: []int{} },\n     { actual: candidate([]int{5, 6, 3, 2}, 8), expected: []int{5, 8, 6, 8, 3, 8, 2} },\n     { actual: candidate([]int{2, 2, 2}, 2), expected: []int{2, 2, 2, 2, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_6","nl":"kmb_Latn","pl":"go_test.go","prompt":"package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika, o kiama kia muxitu, ki tena ku bhanga tumatadi tu iiadi mba tuiadi, maji o kiama kia muxitu, ki tena ku bhanga tumatadi tu tatu.\/\/Phala ku jimbulula o milongi ioso, soneka o diambu ni jiletala mu divulu.\/\/O mbandu íii ia função, ia difu ni fixi ilondekesa ibuka iavulu ia jivelusu, iala bhu kaxi ka jivelusu.\/\/ >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n\/\/ []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n","canonical_solution":"func parse_nested_parens(paren_string string) []int {\n    groups := strings.Fields(paren_string)\n    depths := make([]int, len(groups))\n\n    for i, group := range groups {\n        maxDepth, currentDepth := 0, 0\n        for _, char := range group {\n            if char == '(' {\n                currentDepth++\n                if currentDepth > maxDepth {\n                    maxDepth = currentDepth\n                }\n            } else if char == ')' {\n                currentDepth--\n            }\n        }\n        depths[i] = maxDepth\n    }\n\n    return depths\n}","tests":"func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_7","nl":"kmb_Latn","pl":"go_test.go","prompt":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O mbandu ia kijimbuete kia ku bhana, mu kaxa ka ku tambula, ka-nda moneka dingi.\/\/ >>> filter_by_substring([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_substring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"bacd\", \"array\"}\nfunc filter_by_substring(strings []string, substring string) []string {\n","canonical_solution":"package filter_by_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc filter_by_substring(strings []string, substring string) []string {\n    var result []string\n    for _, str := range strings {\n        if strings.Contains(str, substring) {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterBySubstring(t *testing.T) {\n    tests := []struct {\n        input    []string\n        substring string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"bacd\", \"array\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_substring(test.input, test.substring)\n        if fmt.Sprintf(\"%q\", result) != fmt.Sprintf(\"%q\", test.expected) {\n            t.Errorf(\"filter_by_substring(%q, %q) = %q; expected %q\", test.input, test.substring, result, test.expected)\n        }\n    }\n}","tests":"func TestFilter_By_Substring(t *testing.T) {\n  candidate := filter_by_substring\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"), expected: []string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"} },\n     { actual: candidate([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"), expected: []string{\"grunt\", \"prune\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_8","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia kiama kia muxitu, ki kala kia 0, o kijimbuete kia kiama kia muxitu, ki kala kia 1.\/\/Phala kusanga o kijimbuete kia tokala, soneka o kijimbuete kia mukuá ki ua mesena.\/\/ >>> sum_product([]int{})\n\/\/ []interface{}{0, 1}\n\/\/ >>> sum_product([]int{1, 2, 3, 4})\n\/\/ []interface{}{10, 24}\nfunc sum_product(numbers []int) []interface{} {\n","canonical_solution":"func sum_product(numbers []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n}","tests":"func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_9","nl":"kmb_Latn","pl":"go_test.go","prompt":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O milongi ia-nda kaiela ia-nda zuela ia lungu ni maka enhá.\/\/Mu ku soneka o ima ioso ia moneka, soneka-mu o ima ia beta-kota i u sanga mu kididi kiki.\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n","canonical_solution":"package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ From a given list of integers, generate a list of rolling maximum element found until given moment\n\/\/ in the sequence.\n\/\/ >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n\/\/ []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result := make([]int, len(numbers))\n    maxSoFar := numbers[0]\n    for i, num := range numbers {\n        if num > maxSoFar {\n            maxSoFar = num\n        }\n        result[i] = maxSoFar\n    }\n    return result\n}\n\nfunc TestRollingMax(t *testing.T) {\n    fmt.Println(rolling_max([]int{1, 2, 3, 2, 3, 4, 2})) \/\/ should output []int{1, 2, 3, 3, 3, 4, 4}\n}","tests":"func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_10","nl":"kmb_Latn","pl":"go_test.go","prompt":"package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/- Mu dimatekenu dia kizuelu, soneka-mu kizuelu kia mukuá ki moneka ku dima.\/\/- Sota o postfix ia beta-kota ia kaditele, phala kusanga o polova íii.\/\/O ukexilu ua ku bhanga o ima íii ki u bhonzo kana:\/\/Sota o kizuelu, \"ku dimatekenu\", phala kusanga o kizuelu ki mateka ni kizuelu kimoxi ngó mu veji javulu.\/\/ >>> make_palindrome(\"\")\n\/\/ \"\"\n\/\/ >>> make_palindrome(\"cat\")\n\/\/ \"catac\"\n\/\/ >>> make_palindrome(\"cata\")\n\/\/ \"catac\"\nfunc make_palindrome(myString string) string {\n","canonical_solution":"package make_palindrome_test\n\nimport (\n    \"testing\"\n)\n\nfunc make_palindrome(myString string) string {\n    if len(myString) <= 1 {\n        return myString\n    }\n    \n    \/\/ Helper function to check if a string is a palindrome\n    isPalindrome := func(s string) bool {\n        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n            if s[i] != s[j] {\n                return false\n            }\n        }\n        return true\n    }\n\n    \/\/ Start from the whole string and reduce until we find a palindrome\n    for i := len(myString); i > 0; i-- {\n        if isPalindrome(myString[len(myString)-i:]) {\n            prefix := myString[:len(myString)-i]\n            \/\/ Reverse the prefix and append to original string\n            reversedPrefix := reverse(prefix)\n            return myString + reversedPrefix\n        }\n    }\n\n    \/\/ If no palindromic suffix is found, return original string with reverse appended\n    return myString + reverse(myString)\n}\n\n\/\/ Helper function to reverse a string\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc TestMakePalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"cat\", \"catac\"},\n        {\"cata\", \"catac\"},\n    }\n\n    for _, test := range tests {\n        result := make_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"make_palindrome(%q) = %q; expected %q\", test.input, result, test.expected)\n        }\n    }\n}","tests":"func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_11","nl":"kmb_Latn","pl":"go_test.go","prompt":"package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/XINGANEKA ia lungu ni jifalamenda jiji, ni mu vutuke ni ijimbuete.\/\/O mbandu ia dianga ia kifika, ilondekesa kuila, o mbandu ia dianga ia kifika, ia difu ni mbandu ia kifika mu Bibidia.\/\/ >>> string_xor(\"010\", \"110\")\n\/\/ \"100\"\nfunc string_xor(a string, b string) string {\n","canonical_solution":"result := make([]byte, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] == b[i] {\n\t\t\tresult[i] = '0'\n\t\t} else {\n\t\t\tresult[i] = '1'\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_13","nl":"kmb_Latn","pl":"go_test.go","prompt":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Xisa o dibandela dia dikota dia luiadi a ni b \/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n","canonical_solution":"package greatest_common_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return a greatest common divisor of two integers a and b\n\/\/ >>> greatest_common_divisor(3, 5)\n\/\/ 1\n\/\/ >>> greatest_common_divisor(25, 15)\n\/\/ 5\nfunc greatest_common_divisor(a int, b int) int {\n    for b != 0 {\n        a, b = b, a%b\n    }\n    return a\n}\n\nfunc TestGreatestCommonDivisor(t *testing.T) {\n    tests := []struct {\n        a, b   int\n        expect int\n    }{\n        {3, 5, 1},\n        {25, 15, 5},\n        {54, 24, 6},\n        {48, 18, 6},\n        {101, 103, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.a, test.b), func(t *testing.T) {\n            result := greatest_common_divisor(test.a, test.b)\n            if result != test.expect {\n                t.Errorf(\"expected %d, got %d\", test.expect, result)\n            }\n        })\n    }\n}","tests":"func TestGreatest_Common_Divisor(t *testing.T) {\n  candidate := greatest_common_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 7), expected: 1 },\n     { actual: candidate(10, 15), expected: 5 },\n     { actual: candidate(49, 14), expected: 7 },\n     { actual: candidate(144, 60), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_14","nl":"kmb_Latn","pl":"go_test.go","prompt":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kiki, ki bhana ue idimbu ioso ia mbandu ia filiiale ia mbandu ia ku soneka.\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n","canonical_solution":"package all_prefixes_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list of all prefixes from shortest to longest of the input string\n\/\/ >>> all_prefixes(\"abc\")\n\/\/ []string{\"a\", \"ab\", \"abc\"}\nfunc all_prefixes(myString string) []string {\n    var prefixes []string\n    for i := 1; i <= len(myString); i++ {\n        prefixes = append(prefixes, myString[:i])\n    }\n    return prefixes\n}\n\nfunc TestAllPrefixes(t *testing.T) {\n    result := all_prefixes(\"abc\")\n    expected := []string{\"a\", \"ab\", \"abc\"}\n    for i, v := range result {\n        if v != expected[i] {\n            t.Errorf(\"Test failed, expected %v, got %v\", expected[i], v)\n        }\n    }\n    fmt.Println(\"Test passed\")\n}","tests":"func TestAll_Prefixes(t *testing.T) {\n  candidate := all_prefixes\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"asdfgh\"), expected: []string{\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"} },\n     { actual: candidate(\"WWW\"), expected: []string{\"W\", \"WW\", \"WWW\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_15","nl":"kmb_Latn","pl":"go_test.go","prompt":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku soneka o ima ioso mu ididi iê, kua-nda mu kuatekesa kusanga o ima ioso i ua mesena mu ku soneka.\/\/ >>> string_sequence(0)\n\/\/ \"0\"\n\/\/ >>> string_sequence(5)\n\/\/ \"0 1 2 3 4 5\"\nfunc string_sequence(n int) string {\n","canonical_solution":"package string_sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\n\/\/ Return a string containing space-delimited numbers starting from 0 upto n inclusive.\nfunc string_sequence(n int) string {\n    var parts []string\n    for i := 0; i <= n; i++ {\n        parts = append(parts, fmt.Sprintf(\"%d\", i))\n    }\n    return strings.Join(parts, \" \")\n}\n\nfunc TestStringSequence(t *testing.T) {\n    result := string_sequence(0)\n    expected := \"0\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n    \n    result = string_sequence(5)\n    expected = \"0 1 2 3 4 5\"\n    if result != expected {\n        t.Errorf(\"Expected %s, got %s\", expected, result)\n    }\n}","tests":"func TestString_Sequence(t *testing.T) {\n  candidate := string_sequence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"0\" },\n     { actual: candidate(3), expected: \"0 1 2 3\" },\n     { actual: candidate(10), expected: \"0 1 2 3 4 5 6 7 8 9 10\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_16","nl":"kmb_Latn","pl":"go_test.go","prompt":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu ku tala o ndunge phala kusanga o kijimbuete, tala se mu kijimbuete muala kijimbuete kiebhi.\/\/ >>> count_distinct_characters(\"xyzXYZ\")\n\/\/ 3\n\/\/ >>> count_distinct_characters(\"Jerry\")\n\/\/ 4\nfunc count_distinct_characters(myString string) int {\n","canonical_solution":"package count_distinct_characters_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc count_distinct_characters(myString string) int {\n    characterMap := make(map[rune]bool)\n    for _, char := range strings.ToLower(myString) {\n        characterMap[char] = true\n    }\n    return len(characterMap)\n}\n\nfunc TestCountDistinctCharacters(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected int\n    }{\n        {\"xyzXYZ\", 3},\n        {\"Jerry\", 4},\n        {\"\", 0},\n        {\"Hello, World!\", 10},\n    }\n\n    for _, testCase := range testCases {\n        result := count_distinct_characters(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", testCase.input, testCase.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input '%s': got %d\\n\", testCase.input, result)\n        }\n    }\n}","tests":"func TestCount_Distinct_Characters(t *testing.T) {\n  candidate := count_distinct_characters\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abcde\"), expected: 5 },\n     { actual: candidate(\"abcdecadeCADE\"), expected: 5 },\n     { actual: candidate(\"aaaaAAAAaaaa\"), expected: 1 },\n     { actual: candidate(\"Jerry jERRY JeRRRY\"), expected: 5 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_17","nl":"kmb_Latn","pl":"go_test.go","prompt":"package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O muimbu u tunda muimbu umoxi, u bhita muimbu umoxi.\/\/O \"o\" ia dianga, ilombolola o mbandu ia sukina ia dízui.\/\/O \"k\" ulombolola o \"kuimana\", ni \"kuimana\".\/\/O musoso iú ua makutu:\/\/ki ku disukilu. \/\/O kikalakalu kiê, o ku tokuesa kiambote o ndunge íii ni ku i soneka kala kijimbuete kilondekesa o ku batuka kua jimbandu joso ja mukanda.\/\/O mbandu íii, ia-nda londekesa o jifikula ja muimbu, ja moneka mu ASCII.\/\/ >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\/\/ []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n","canonical_solution":"package parse_music_test\n\nimport (\n    \"strings\"\n)\n\nfunc parse_music(music_string string) []int {\n    notes := strings.Fields(music_string)\n    beats := make([]int, len(notes))\n    for i, note := range notes {\n        switch note {\n        case \"o\":\n            beats[i] = 4\n        case \"o|\":\n            beats[i] = 2\n        case \".|\":\n            beats[i] = 1\n        }\n    }\n    return beats\n}","tests":"func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_18","nl":"kmb_Latn","pl":"go_test.go","prompt":"package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sota kuijiia se veji ji kuxi ja tokala kusoneka o kizuelu \"kaxa\" mu mukanda ua dianga ua milongi.\/\/ >>> how_many_times(\"\", \"a\")\n\/\/ 0\n\/\/ >>> how_many_times(\"aaa\", \"a\")\n\/\/ 3\n\/\/ >>> how_many_times(\"aaaa\", \"aa\")\n\/\/ 3\nfunc how_many_times(myString string, substring string) int {\n","canonical_solution":"func how_many_times(myString string, substring string) int {\n    if len(substring) == 0 {\n        return 0\n    }\n\n    count := 0\n    for i := 0; i <= len(myString)-len(substring); i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHowManyTimes(t *testing.T) {\n    tests := []struct {\n        myString  string\n        substring string\n        expected  int\n    }{\n        {\"\", \"a\", 0},\n        {\"aaa\", \"a\", 3},\n        {\"aaaa\", \"aa\", 3},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%s in %s\", test.substring, test.myString), func(t *testing.T) {\n            result := how_many_times(test.myString, test.substring)\n            if result != test.expected {\n                t.Errorf(\"Expected %d but got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n     { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_19","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Xinda o jimbandu mu kijimbuete kiki, ande dia ku mateka o kolo ia beta-o-kota\/\/O ijimbuete i tena ku kuatekesa, o \"kima kimoxi\", \"kiiadi\", \"kitatu\", \"kanu\", \"samanu\", \"sambuadi\", \"kanake\" ni \"katanu\". \/\/O kijimbuete kia ku bokona, ki moneka ngó mu mbandu ia kijimbuete kia \"zero\" katé ku \"kimbundu\".\/\/ >>> sort_numbers(\"three one five\")\n\/\/ \"one three five\"\nfunc sort_numbers(numbers string) string {\n","canonical_solution":"package sort_numbers_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc sort_numbers(numbers string) string {\n    wordsToNumbers := map[string]int{\n        \"zero\":  0,\n        \"one\":   1,\n        \"two\":   2,\n        \"three\": 3,\n        \"four\":  4,\n        \"five\":  5,\n        \"six\":   6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\":  9,\n    }\n    \n    numbersToWords := []string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    \n    words := strings.Fields(numbers)\n    numberInts := make([]int, len(words))\n    \n    for i, word := range words {\n        numberInts[i] = wordsToNumbers[word]\n    }\n    \n    sort.Ints(numberInts)\n    \n    sortedWords := make([]string, len(words))\n    for i, num := range numberInts {\n        sortedWords[i] = numbersToWords[num]\n    }\n    \n    return strings.Join(sortedWords, \" \")\n}","tests":"func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_20","nl":"kmb_Latn","pl":"go_test.go","prompt":"package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia mukuá, a ki soneka mu ukexilu ua mukuá, mu ku kaiela o ukexilu ua mukuá (se kiofele, a ki soneka mu ukexilu ua mukuá).\/\/O kijimbuete kia mukuá, ki moneka ku luiji, mu ku suluka, soneka-mu o kijimbuete kia mukuá.\/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\/\/ []interface{}{2.0, 2.2}\n\/\/ >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n\/\/ []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers []float64) []interface{} {\n","canonical_solution":"package find_closest_elements_test\n\nimport (\n    \"math\"\n    \"sort\"\n)\n\nfunc find_closest_elements(numbers []float64) []interface{} {\n    if len(numbers) < 2 {\n        return nil\n    }\n    \n    \/\/ Create a sorted copy of the numbers\n    sortedNumbers := make([]float64, len(numbers))\n    copy(sortedNumbers, numbers)\n    sort.Float64s(sortedNumbers)\n    \n    \/\/ Initialize the minimum difference and result\n    minDiff := math.MaxFloat64\n    result := []interface{}{sortedNumbers[0], sortedNumbers[1]}\n    \n    \/\/ Iterate over the sorted numbers to find the closest pair\n    for i := 1; i < len(sortedNumbers); i++ {\n        diff := sortedNumbers[i] - sortedNumbers[i-1]\n        if diff < minDiff {\n            minDiff = diff\n            result[0] = sortedNumbers[i-1]\n            result[1] = sortedNumbers[i]\n        }\n    }\n    \n    return result\n}","tests":"func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0, 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0, 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected: []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_21","nl":"kmb_Latn","pl":"go_test.go","prompt":"package rescale_to_unit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia beta-kota, 1 mu veji dia 0.\/\/Mu ku mona o jifikula ji moneka, mu fikula jiji, tu tena ku mona kuila o jifikula jiji jene mu moneka mu ukexilu ua katunda.\/\/ >>> rescale_to_unit([]float64{1.0, 2.0, 3.0, 4.0, 5.0})\n\/\/ []float64{0.0, 0.25, 0.5, 0.75, 1.0}\nfunc rescale_to_unit(numbers []float64) []float64 {\n","canonical_solution":"package rescale_to_unit_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc rescale_to_unit(numbers []float64) []float64 {\n\tif len(numbers) < 2 {\n\t\treturn numbers\n\t}\n\t\n\tminVal := numbers[0]\n\tmaxVal := numbers[0]\n\tfor _, num := range numbers {\n\t\tif num < minVal {\n\t\t\tminVal = num\n\t\t} else if num > maxVal {\n\t\t\tmaxVal = num\n\t\t}\n\t}\n\n\tscale := maxVal - minVal\n\tif scale == 0 {\n\t\treturn make([]float64, len(numbers))\n\t}\n\n\trescaled := make([]float64, len(numbers))\n\tfor i, num := range numbers {\n\t\trescaled[i] = (num - minVal) \/ scale\n\t}\n\n\treturn rescaled\n}\n\nfunc TestRescaleToUnit(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, []float64{0.0, 0.25, 0.5, 0.75, 1.0}},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, []float64{1.0, 0.75, 0.5, 0.25, 0.0}},\n\t\t{[]float64{2.0, 2.0, 2.0}, []float64{0.0, 0.0, 0.0}},\n\t\t{[]float64{3.0, 3.0}, []float64{0.0, 0.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := rescale_to_unit(test.input)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}","tests":"func TestRescale_To_Unit(t *testing.T) {\n  candidate := rescale_to_unit\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{2.0, 49.9}), expected: []float64{0.0, 1.0} },\n     { actual: candidate([]float64{100.0, 49.9}), expected: []float64{1.0, 0.0} },\n     { actual: candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0}), expected: []float64{0.0, 0.25, 0.5, 0.75, 1.0} },\n     { actual: candidate([]float64{2.0, 1.0, 5.0, 3.0, 4.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n     { actual: candidate([]float64{12.0, 11.0, 15.0, 13.0, 14.0}), expected: []float64{0.25, 0.0, 1.0, 0.5, 0.75} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_22","nl":"kmb_Latn","pl":"go_test.go","prompt":"package filter_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Xinda o milongi iala ku mbandu ia kijimbuete phala ku mona ngó o kijimbuete kia mukuá kiala ku mbandu ia kijimbuete kia mukuá\/\/ >>> filter_integers([]float64{\"a\", 3.14, 5})\n\/\/ []int{5}\n\/\/ >>> filter_integers([]interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}})\n\/\/ []int{1, 2, 3}\nfunc filter_integers(values []interface{}) []int {\n","canonical_solution":"func filter_integers(values []interface{}) []int {\n    var result []int\n    for _, v := range values {\n        if intValue, ok := v.(int); ok {\n            result = append(result, intValue)\n        }\n    }\n    return result\n}\n\nfunc TestFilterIntegers(t *testing.T) {\n    cases := []struct {\n        input    []interface{}\n        expected []int\n    }{\n        {\n            input:    []interface{}{1, 2, 3, \"abc\", map[interface{}]interface{}{}, []interface{}{}},\n            expected: []int{1, 2, 3},\n        },\n        {\n            input:    []interface{}{\"a\", 3.14, 5},\n            expected: []int{5},\n        },\n    }\n\n    for _, c := range cases {\n        result := filter_integers(c.input)\n        if !equal(result, c.expected) {\n            t.Errorf(\"filter_integers(%v) == %v, expected %v\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i, v := range a {\n        if v != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_Integers(t *testing.T) {\n  candidate := filter_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{}), expected: []int{} },\n     { actual: candidate([]interface{}{4, map[interface{}]interface{}{}, []interface{}{}, 23.2, 9, \"adasd\"}), expected: []int{4, 9} },\n     { actual: candidate([]interface{}{3, \"c\", 3, 3, \"a\", \"b\"}), expected: []int{3, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_23","nl":"kmb_Latn","pl":"go_test.go","prompt":"package strlen_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku soneka o ima ioso i tua mesena mu mukanda \/\/ >>> strlen(\"\")\n\/\/ 0\n\/\/ >>> strlen(\"abc\")\n\/\/ 3\nfunc strlen(myString string) int {\n","canonical_solution":"return len(myString)\n}","tests":"func TestStrlen(t *testing.T) {\n  candidate := strlen\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"x\"), expected: 1 },\n     { actual: candidate(\"asdasnakj\"), expected: 9 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_24","nl":"kmb_Latn","pl":"go_test.go","prompt":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phala kusanga o kijimbuete kia dikota, tua tokala kusanga o kijimbuete kia dikota ki tena ku tu muanga o kijimbuete kia dikota.\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n","canonical_solution":"package largest_divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ For a given number n, find the largest number that divides n evenly, smaller than n\n\/\/ >>> largest_divisor(15)\n\/\/ 5\nfunc largest_divisor(n int) int {\n    for i := n\/2; i > 0; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1\n}\n\nfunc TestLargestDivisor(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {15, 5},\n        {100, 50},\n        {49, 7},\n        {81, 27},\n        {1, 1},\n    }\n\n    for _, c := range cases {\n        result := largest_divisor(c.input)\n        if result != c.expected {\n            t.Errorf(\"largest_divisor(%d) == %d, expected %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(largest_divisor(15))\n}","tests":"func TestLargest_Divisor(t *testing.T) {\n  candidate := largest_divisor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: 1 },\n     { actual: candidate(7), expected: 1 },\n     { actual: candidate(10), expected: 5 },\n     { actual: candidate(100), expected: 50 },\n     { actual: candidate(49), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_25","nl":"kmb_Latn","pl":"go_test.go","prompt":"package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia tokala ku kala kia difu ni kijimbuete kia ima ioso i tu mona \/\/O jifalamenda joso ja tokala ku ji soneka mu jikopia, kála kilondekesa o jifalamenda ji tu sanga mu divulu.\/\/O ukexilu iú u tu kuatekesa ku kondala o jifalamenda jetu ja beta-kota, ni ia beta-kota.\/\/ >>> factorize(8)\n\/\/ []int{2, 2, 2}\n\/\/ >>> factorize(25)\n\/\/ []int{5, 5}\n\/\/ >>> factorize(70)\n\/\/ []int{2, 5, 7}\nfunc factorize(n int) []int {\n","canonical_solution":"package factorize\n\nfunc factorize(n int) []int {\n\tvar factors []int\n\tfor i := 2; i*i <= n; i++ {\n\t\tfor n%i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn \/= i\n\t\t}\n\t}\n\tif n > 1 {\n\t\tfactors = append(factors, n)\n\t}\n\treturn factors\n}","tests":"func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_26","nl":"kmb_Latn","pl":"go_test.go","prompt":"package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ima ioso i moneka mu kaxa, ki i lunguluka.\/\/Katula o ima ioso mu mukanda mu moneka ngó o ijimbuete.\/\/ >>> remove_duplicates([]int{1, 2, 3, 2, 4})\n\/\/ []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n","canonical_solution":"package remove_duplicates_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc remove_duplicates(numbers []int) []int {\n\tcounts := make(map[int]int)\n\tfor _, num := range numbers {\n\t\tcounts[num]++\n\t}\n\n\tresult := []int{}\n\tfor _, num := range numbers {\n\t\tif counts[num] == 1 {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestRemoveDuplicates(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 2, 3, 2, 4}, []int{1, 3, 4}},\n\t\t{[]int{1, 1, 1, 1}, []int{}},\n\t\t{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}},\n\t\t{[]int{5, 5, 5, 6}, []int{6}},\n\t\t{[]int{9, 8, 9, 8, 7}, []int{7}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"remove_duplicates(%v)\", test.input), func(t *testing.T) {\n\t\t\tresult := remove_duplicates(test.input)\n\t\t\tif len(result) != len(test.expected) {\n\t\t\t\tt.Errorf(\"Expected length %d, got %d\", len(test.expected), len(result))\n\t\t\t}\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", test.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_27","nl":"kmb_Latn","pl":"go_test.go","prompt":"package flip_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phala kusoneka o kijimbuete kiki, lungulula o kijimbuete kia dikota mu kijimbuete kia dikota, ni kia dikota mu kijimbuete kia ndenge. \/\/ >>> flip_case(\"Hello\")\n\/\/ \"hELLO\"\nfunc flip_case(myString string) string {\n","canonical_solution":"func flip_case(myString string) string {\n\tvar result []rune\n\tfor _, char := range myString {\n\t\tif char >= 'a' && char <= 'z' {\n\t\t\tresult = append(result, char-('a'-'A'))\n\t\t} else if char >= 'A' && char <= 'Z' {\n\t\t\tresult = append(result, char+('a'-'A'))\n\t\t} else {\n\t\t\tresult = append(result, char)\n\t\t}\n\t}\n\treturn string(result)\n}","tests":"func TestFlip_Case(t *testing.T) {\n  candidate := flip_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hello!\"), expected: \"hELLO!\" },\n     { actual: candidate(\"These violent delights have violent ends\"), expected: \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_28","nl":"kmb_Latn","pl":"go_test.go","prompt":"package concatenate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Xisa o majina a jimbandu joso\/\/ >>> concatenate([]string{})\n\/\/ \"\"\n\/\/ >>> concatenate([]string{\"a\", \"b\", \"c\"})\n\/\/ \"abc\"\nfunc concatenate(strings []string) string {\n","canonical_solution":"result := \"\"\n    for _, str := range strings {\n        result += str\n    }\n    return result\n}","tests":"func TestConcatenate(t *testing.T) {\n  candidate := concatenate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}), expected: \"\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\"}), expected: \"xyz\" },\n     { actual: candidate([]string{\"x\", \"y\", \"z\", \"w\", \"k\"}), expected: \"xyzwk\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_29","nl":"kmb_Latn","pl":"go_test.go","prompt":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku soneka o kizuelu \"ku\", kulombolola ku bandekesa kizuelu mu kizuelu.\/\/ >>> filter_by_prefix([]string{}, \"a\")\n\/\/ []string{}\n\/\/ >>> filter_by_prefix([]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\")\n\/\/ []string{\"abc\", \"array\"}\nfunc filter_by_prefix(strings []string, prefix string) []string {\n","canonical_solution":"package filter_by_prefix_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Filter an input list of strings only for ones that start with a given prefix.\nfunc filter_by_prefix(strings []string, prefix string) []string {\n    var result []string\n    for _, str := range strings {\n        if len(str) >= len(prefix) && str[:len(prefix)] == prefix {\n            result = append(result, str)\n        }\n    }\n    return result\n}\n\nfunc TestFilterByPrefix(t *testing.T) {\n    tests := []struct {\n        input    []string\n        prefix   string\n        expected []string\n    }{\n        {[]string{}, \"a\", []string{}},\n        {[]string{\"abc\", \"bcd\", \"cde\", \"array\"}, \"a\", []string{\"abc\", \"array\"}},\n        {[]string{\"hello\", \"helium\", \"world\"}, \"he\", []string{\"hello\", \"helium\"}},\n        {[]string{\"banana\", \"band\", \"bandana\"}, \"ban\", []string{\"banana\", \"band\", \"bandana\"}},\n        {[]string{\"apple\", \"ape\", \"apricot\"}, \"ap\", []string{\"apple\", \"ape\", \"apricot\"}},\n    }\n\n    for _, test := range tests {\n        result := filter_by_prefix(test.input, test.prefix)\n        if !equal(result, test.expected) {\n            t.Errorf(\"filter_by_prefix(%v, %s) = %v; expected %v\", test.input, test.prefix, result, test.expected)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestFilter_By_Prefix(t *testing.T) {\n  candidate := filter_by_prefix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, \"john\"), expected: []string{} },\n     { actual: candidate([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), expected: []string{\"xxx\", \"xxxAAA\", \"xxx\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_30","nl":"kmb_Latn","pl":"go_test.go","prompt":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Vutuka ngó mu mbandu ia tokala mu kaxa.\/\/ >>> get_positive([]int{-1, 2, -4, 5, 6})\n\/\/ []int{2, 5, 6}\n\/\/ >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int {\n","canonical_solution":"package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return only positive numbers in the list.\nfunc get_positive(l []int) []int {\n    var positiveNumbers []int\n    for _, num := range l {\n        if num > 0 {\n            positiveNumbers = append(positiveNumbers, num)\n        }\n    }\n    return positiveNumbers\n}\n\nfunc TestGetPositive(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output []int\n    }{\n        {[]int{-1, 2, -4, 5, 6}, []int{2, 5, 6}},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, []int{5, 3, 2, 3, 9, 123, 1}},\n    }\n    \n    for _, test := range tests {\n        result := get_positive(test.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", test.output) {\n            t.Errorf(\"Expected %v, got %v\", test.output, result)\n        }\n    }\n}","tests":"func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4, 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1, -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_31","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku sanga o kijimbuete kia tokala, mu ku bhanga o polova, kilondekesa o kidi kia milongi.\/\/ >>> is_prime(6)\n\/\/ false\n\/\/ >>> is_prime(101)\n\/\/ true\n\/\/ >>> is_prime(11)\n\/\/ true\n\/\/ >>> is_prime(13441)\n\/\/ true\n\/\/ >>> is_prime(61)\n\/\/ true\n\/\/ >>> is_prime(4)\n\/\/ false\n\/\/ >>> is_prime(1)\n\/\/ false\nfunc is_prime(n int) bool {\n","canonical_solution":"package is_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_prime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPrime(t *testing.T) {\n    testCases := []struct {\n        number   int\n        expected bool\n    }{\n        {6, false},\n        {101, true},\n        {11, true},\n        {13441, true},\n        {61, true},\n        {4, false},\n        {1, false},\n    }\n\n    for _, testCase := range testCases {\n        result := is_prime(testCase.number)\n        if result != testCase.expected {\n            t.Errorf(\"is_prime(%d) = %v; want %v\", testCase.number, result, testCase.expected)\n        } else {\n            fmt.Printf(\"Test Passed: is_prime(%d) = %v\\n\", testCase.number, result)\n        }\n    }\n}","tests":"func TestIs_Prime(t *testing.T) {\n  candidate := is_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(6), expected: false },\n     { actual: candidate(101), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(13441), expected: true },\n     { actual: candidate(61), expected: true },\n     { actual: candidate(4), expected: false },\n     { actual: candidate(1), expected: false },\n     { actual: candidate(5), expected: true },\n     { actual: candidate(11), expected: true },\n     { actual: candidate(17), expected: true },\n     { actual: candidate(85), expected: false },\n     { actual: candidate(77), expected: false },\n     { actual: candidate(255379), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_33","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku di tungula kua ijimbuete, kua lungu ni ku uana o kitadi kia tokala o ku ki ngástala.\/\/O ima i tu mona, i tu kuatekesa kuijiia kuila, o ima i tu mona, ki i lungu ni ima i tu mona mba i tu zuela.\/\/O mbandu íii, ia-nda londekesa o milongi i tua-nda di longa.\/\/ >>> sort_third([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n\/\/ []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n","canonical_solution":"package sort_third_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_third(l []int) []int {\n    type pair struct {\n        index int\n        value int\n    }\n\n    \/\/ Collect the pairs where indices are divisible by 3\n    sortSection := []pair{}\n\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            sortSection = append(sortSection, pair{index: i, value: l[i]})\n        }\n    }\n\n    \/\/ Sort this section based on the values\n    sort.Slice(sortSection, func(i, j int) bool {\n        return sortSection[i].value < sortSection[j].value\n    })\n\n    \/\/ Generate result slice\n    result := make([]int, len(l))\n    copy(result, l)\n\n    \/\/ Fill the sorted values back to the result\n    for _, p := range sortSection {\n        result[p.index] = p.value\n    }\n\n    return result\n}","tests":"func TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_34","nl":"kmb_Latn","pl":"go_test.go","prompt":"package unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kusuluka, jikula o mbandu, ni u soneka o kijimbuete mu mukanda\/\/ >>> unique([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{0, 2, 3, 5, 9, 123}\nfunc unique(l []int) []int {\n","canonical_solution":"package unique_test\n\nimport (\n    \"sort\"\n)\n\nfunc unique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    for _, value := range l {\n        uniqueMap[value] = true\n    }\n\n    uniqueSlice := make([]int, 0, len(uniqueMap))\n    for key := range uniqueMap {\n        uniqueSlice = append(uniqueSlice, key)\n    }\n\n    sort.Ints(uniqueSlice)\n    return uniqueSlice\n}","tests":"func TestUnique(t *testing.T) {\n  candidate := unique\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 3, 5, 2, 3, 3, 9, 0, 123}), expected: []int{0, 2, 3, 5, 9, 123} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_35","nl":"kmb_Latn","pl":"go_test.go","prompt":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu ku bandekesa o kijimbuete kiki, a bandekesa-ku dingi kijimbuete kimoxi.\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n","canonical_solution":"package max_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return maximum element in the list.\n\/\/ >>> max_element([]int{1, 2, 3})\n\/\/ 3\n\/\/ >>> max_element([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n\/\/ 123\nfunc max_element(l []int) int {\n    if len(l) == 0 {\n        panic(\"Empty list has no maximum value\")\n    }\n    max := l[0]\n    for _, value := range l {\n        if value > max {\n            max = value\n        }\n    }\n    return max\n}\n\nfunc TestMaxElement(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 3},\n        {[]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}, 123},\n        {[]int{-1, -2, -3, -4}, -1},\n        {[]int{9, 9, 9, 9}, 9},\n    }\n\n    for _, testCase := range testCases {\n        result := max_element(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"For input %v, expected %d, got %d\", testCase.input, testCase.expected, result)\n        }\n    }\n}","tests":"func TestMax_Element(t *testing.T) {\n  candidate := max_element\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 3 },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), expected: 124 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_36","nl":"kmb_Latn","pl":"go_test.go","prompt":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Kubhanga o mbandu ia kijimbuete 7 mu veji ia mukuá, phala kusanga o kijimbuete kia dikota ki beta-o-kota, o kijimbuete n ki beta-o-kota, phala kusanga o kijimbuete kia dikota ki beta-o-kota, o kijimbuete 11 mba 13. \/\/ >>> fizz_buzz(50)\n\/\/ 0\n\/\/ >>> fizz_buzz(78)\n\/\/ 2\n\/\/ >>> fizz_buzz(79)\n\/\/ 3\nfunc fizz_buzz(n int) int {\n","canonical_solution":"package fizz_buzz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc fizz_buzz(n int) int {\n    count := 0\n    for i := 0; i < n; i++ {\n        if i % 11 == 0 || i % 13 == 0 {\n            count += countSevens(i)\n        }\n    }\n    return count\n}\n\nfunc countSevens(num int) int {\n    strNum := strconv.Itoa(num)\n    count := 0\n    for _, c := range strNum {\n        if c == '7' {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestFizzBuzz(t *testing.T) {\n    tests := []struct {\n        input int\n        expected int\n    }{\n        {50, 0},\n        {78, 2},\n        {79, 3},\n    }\n\n    for _, test := range tests {\n        result := fizz_buzz(test.input)\n        if result != test.expected {\n            t.Errorf(\"fizz_buzz(%d) = %d; expected %d\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(fizz_buzz(50)) \/\/ 0\n    fmt.Println(fizz_buzz(78)) \/\/ 2\n    fmt.Println(fizz_buzz(79)) \/\/ 3\n}","tests":"func TestFizz_Buzz(t *testing.T) {\n  candidate := fizz_buzz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(50), expected: 0 },\n     { actual: candidate(78), expected: 2 },\n     { actual: candidate(79), expected: 3 },\n     { actual: candidate(100), expected: 3 },\n     { actual: candidate(200), expected: 6 },\n     { actual: candidate(4000), expected: 192 },\n     { actual: candidate(10000), expected: 639 },\n     { actual: candidate(100000), expected: 8026 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_37","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sort_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kuila o ku bhanga kiki, kieji londekesa kuila o kathombo ka beta-kota?\/\/O ukexilu ua ku soneka o ima, ua difu ni ukexilu ua jiletala ja katunda, maji mu ithangana ia jiletala, o jiletala ja katunda, ji difu ni jiletala ja katunda.\/\/O mbandu íii, ia-nda londekesa o milongi i tua mesena o ku di longa.\/\/ >>> sort_even([]int{1, 2, 3})\n\/\/ []int{1, 2, 3}\n\/\/ >>> sort_even([]int{5, 6, 3, 4})\n\/\/ []int{3, 6, 5, 4}\nfunc sort_even(l []int) []int {\n","canonical_solution":"package sort_even_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_even(l []int) []int {\n    if len(l) < 2 {\n        return l\n    }\n    \n    \/\/ Extract even indices\n    evens := []int{}\n    for i := 0; i < len(l); i += 2 {\n        evens = append(evens, l[i])\n    }\n    \n    \/\/ Sort even-indexed elements\n    sort.Ints(evens)\n    \n    \/\/ Merge sorted evens back into the original list\n    j := 0\n    for i := 0; i < len(l); i += 2 {\n        l[i] = evens[j]\n        j++\n    }\n\n    return l\n}","tests":"func TestSort_Even(t *testing.T) {\n  candidate := sort_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: []int{1, 2, 3} },\n     { actual: candidate([]int{5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), expected: []int{-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123} },\n     { actual: candidate([]int{5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), expected: []int{-12, 8, 3, 4, 5, 2, 12, 11, 23, -10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_39","nl":"kmb_Latn","pl":"go_test.go","prompt":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/prime_fib u vutula o kijimbuete kia n-th kia difu ni kijimbuete kia Fibonacci, ni kuila o kijimbuete kiki ué ki prime. \/\/ >>> prime_fib(1)\n\/\/ 2\n\/\/ >>> prime_fib(2)\n\/\/ 3\n\/\/ >>> prime_fib(3)\n\/\/ 5\n\/\/ >>> prime_fib(4)\n\/\/ 13\n\/\/ >>> prime_fib(5)\n\/\/ 89\nfunc prime_fib(n int) int {\n","canonical_solution":"package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ isPrime checks if a number is prime\nfunc isPrime(num int) bool {\n    if num <= 1 {\n        return false\n    }\n    if num <= 3 {\n        return true\n    }\n    if num%2 == 0 || num%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= num; i += 6 {\n        if num%i == 0 || num%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nfunc prime_fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    a, b := 1, 1\n    count := 0\n    for count < n {\n        a, b = b, a+b\n        if isPrime(a) {\n            count++\n        }\n    }\n    return a\n}\n\nfunc TestPrimeFib(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {1, 2},\n        {2, 3},\n        {3, 5},\n        {4, 13},\n        {5, 89},\n    }\n\n    for _, test := range tests {\n        result := prime_fib(test.input)\n        if result != test.expected {\n            t.Errorf(\"prime_fib(%d) = %d; expected %d\", test.input, result, test.expected)\n        } else {\n            fmt.Printf(\"prime_fib(%d) = %d\\n\", test.input, result)\n        }\n    }\n}","tests":"func TestPrime_Fib(t *testing.T) {\n  candidate := prime_fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 2 },\n     { actual: candidate(2), expected: 3 },\n     { actual: candidate(3), expected: 5 },\n     { actual: candidate(4), expected: 13 },\n     { actual: candidate(5), expected: 89 },\n     { actual: candidate(6), expected: 233 },\n     { actual: candidate(7), expected: 1597 },\n     { actual: candidate(8), expected: 28657 },\n     { actual: candidate(9), expected: 514229 },\n     { actual: candidate(10), expected: 433494437 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_40","nl":"kmb_Latn","pl":"go_test.go","prompt":"package triples_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku di longa o Bibidia sé ku xinganeka kiavulu, ku tena ku ku kuatekesa ku kala ni unjimu.\/\/ki i difu ni milongi ia mukuá ia Bibidia\/\/O mbandu ia katatu, ia-nda londekesa o milongi i tua-nda di longa.\/\/ >>> triples_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})\n\/\/ true\n\/\/ >>> triples_sum_to_zero([]int{1})\n\/\/ false\nfunc triples_sum_to_zero(l []int) bool {\n","canonical_solution":"func triples_sum_to_zero(l []int) bool {\n    n := len(l)\n    if n < 3 {\n        return false\n    }\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if l[i]+l[j]+l[k] == 0 {\n                    return true\n                }\n            }\n        }\n    }\n    \n    return false\n}\n\nfunc TestTriplesSumToZero(t *testing.T) {\n    tests := []struct {\n        input  []int\n        output bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, true},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 9, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, test := range tests {\n        result := triples_sum_to_zero(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %v, expected %v, got %v\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(triples_sum_to_zero([]int{1, 3, 5, 0}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{1, 3, -2, 1}))   \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1, 2, 3, 7}))    \/\/ false\n    fmt.Println(triples_sum_to_zero([]int{2, 4, -5, 3, 9, 7})) \/\/ true\n    fmt.Println(triples_sum_to_zero([]int{1}))              \/\/ false\n}","tests":"func TestTriples_Sum_To_Zero(t *testing.T) {\n  candidate := triples_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -1}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{1, 2, 5, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 9, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{1, 3, 5, -100}), expected: false },\n     { actual: candidate([]int{100, 3, 5, -100}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_41","nl":"kmb_Latn","pl":"go_test.go","prompt":"package car_race_collision_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kiki, kilondekesa o ijimbuete ia ibuka ia ijimbuete ia jixi ja mukua ja kexile mu uana o athu mu jixi jiji.\/\/O kuila o ku bhanga kiki, kieji londekesa kuila ene a di tungula?\/\/Maji o makalu a beta-kota mu ku kala ni nguzu ku mukutu ua muthu, mukonda dia kiki, ene a tena ku kolokota kuenda.\/\/O dikalu dienda ku ditala, di talela ku mbandu ia kiasu mba ia kadilu.\/\/O dikalu dioso dienda ni lusolo, mu kiki, a di kuata.\/\/O ibuka iiadi íii, ia kexile dikanga dia mbanza ia Nassau, kua lungile o mbandu ia thunda.\/\/Mu kidi, o dikalu dienda ku mbandu ia kiasu ni ia kadilu.\/\/Xinganeka njila ia lebha, ienda katé bhu disukilu, sé-ku muthu u tena ku i nhunga.func car_race_collision(n int) int {\n","canonical_solution":"package car_race_collision_test\n\nimport (\n    \"testing\"\n)\n\nfunc car_race_collision(n int) int {\n    return n\n}\n\nfunc TestCarRaceCollision(t *testing.T) {\n    cases := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 2},\n        {3, 3},\n        {10, 10},\n        {0, 0},\n    }\n\n    for _, c := range cases {\n        result := car_race_collision(c.n)\n        if result != c.expected {\n            t.Errorf(\"car_race_collision(%d) == %d, expected %d\", c.n, result, c.expected)\n        }\n    }\n}","tests":"func TestCar_Race_Collision(t *testing.T) {\n  candidate := car_race_collision\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 4 },\n     { actual: candidate(3), expected: 9 },\n     { actual: candidate(4), expected: 16 },\n     { actual: candidate(8), expected: 64 },\n     { actual: candidate(10), expected: 100 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_42","nl":"kmb_Latn","pl":"go_test.go","prompt":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ima ioso i moneka mu mukanda iú, a i lungulula.\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n","canonical_solution":"package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return list with elements incremented by 1.\n\/\/ >>> incr_list([]int{1, 2, 3})\n\/\/ []int{2, 3, 4}\n\/\/ >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n\/\/ []int{6, 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n    result := make([]int, len(l))\n    for i, val := range l {\n        result[i] = val + 1\n    }\n    return result\n}\n\nfunc TestIncrList(t *testing.T) {\n    cases := []struct {\n        input    []int\n        expected []int\n    }{\n        {[]int{1, 2, 3}, []int{2, 3, 4}},\n        {[]int{5, 3, 5, 2, 3, 3, 9, 0, 123}, []int{6, 4, 6, 3, 4, 4, 10, 1, 124}},\n    }\n\n    for _, c := range cases {\n        result := incr_list(c.input)\n        for i := range result {\n            if result[i] != c.expected[i] {\n                t.Errorf(\"incr_list(%v) == %v, expected %v\", c.input, result, c.expected)\n            }\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(incr_list([]int{1, 2, 3}))          \/\/ should print [2, 3, 4]\n    fmt.Println(incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})) \/\/ should print [6, 4, 6, 3, 4, 4, 10, 1, 124]\n}","tests":"func TestIncr_List(t *testing.T) {\n  candidate := incr_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },\n     { actual: candidate([]int{5, 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_43","nl":"kmb_Latn","pl":"go_test.go","prompt":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku di longa o Bibidia sé ku xinganeka kiavulu, ku tena ku ku kuatekesa ku kala ni unjimu.\/\/i ijimbulula kuma kidi, se ku moneka ima iiadi ki i difu mu kaxa, i tena ku kala ki i difu.\/\/O mbandu pairs_sum_to_zero, i kuata mbandu ia ku soneka o ji-ijimbuete.\/\/ >>> pairs_sum_to_zero([]int{1, 3, 5, 0})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 3, -2, 1})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{1, 2, 3, 7})\n\/\/ false\n\/\/ >>> pairs_sum_to_zero([]int{2, 4, -5, 3, 5, 7})\n\/\/ true\n\/\/ >>> pairs_sum_to_zero([]int{1})\n\/\/ false\nfunc pairs_sum_to_zero(l []int) bool {\n","canonical_solution":"package pairs_sum_to_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pairs_sum_to_zero(l []int) bool {\n    numSet := make(map[int]struct{})\n    for _, num := range l {\n        if _, found := numSet[-num]; found {\n            return true\n        }\n        numSet[num] = struct{}{}\n    }\n    return false\n}\n\nfunc TestPairsSumToZero(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected bool\n    }{\n        {[]int{1, 3, 5, 0}, false},\n        {[]int{1, 3, -2, 1}, false},\n        {[]int{1, 2, 3, 7}, false},\n        {[]int{2, 4, -5, 3, 5, 7}, true},\n        {[]int{1}, false},\n    }\n\n    for _, tc := range testCases {\n        result := pairs_sum_to_zero(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"pairs_sum_to_zero(%v) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %v, result: %v\\n\", tc.input, result)\n        }\n    }\n}","tests":"func TestPairs_Sum_To_Zero(t *testing.T) {\n  candidate := pairs_sum_to_zero\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 0}), expected: false },\n     { actual: candidate([]int{1, 3, -2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 7}), expected: false },\n     { actual: candidate([]int{2, 4, -5, 3, 5, 7}), expected: true },\n     { actual: candidate([]int{1}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 30}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 3, 2, 31}), expected: true },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 30}), expected: false },\n     { actual: candidate([]int{-3, 9, -1, 4, 2, 31}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_44","nl":"kmb_Latn","pl":"go_test.go","prompt":"package change_base_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia beta-kota, kia beta-kota, o kijimbuete kia 10.\/\/O ku lungulula o ima mu ukexilu iú, kua-nda tu kuatekesa ku tendela kiambote o maka.\/\/Xisa o ima ia tokala mu mukanda phala ku i soneka.\/\/ >>> change_base(8, 3)\n\/\/ \"22\"\n\/\/ >>> change_base(8, 2)\n\/\/ \"1000\"\n\/\/ >>> change_base(7, 2)\n\/\/ \"111\"\nfunc change_base(x int, base int) string {\n","canonical_solution":"package change_base_test\n\nimport (\n    \"strconv\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc change_base(x int, base int) string {\n    if base < 2 || base > 9 {\n        return \"\"\n    }\n\n    result := \"\"\n    for x > 0 {\n        remainder := x % base\n        result = strconv.Itoa(remainder) + result\n        x = x \/ base\n    }\n    \n    if result == \"\" {\n        return \"0\"\n    }\n    return result\n}\n\nfunc TestChangeBase(t *testing.T) {\n    tests := []struct {\n        x      int\n        base   int\n        result string\n    }{\n        {8, 3, \"22\"},\n        {8, 2, \"1000\"},\n        {7, 2, \"111\"},\n        {0, 2, \"0\"},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d to base %d\", test.x, test.base), func(t *testing.T) {\n            res := change_base(test.x, test.base)\n            if res != test.result {\n                t.Errorf(\"expected %s, got %s\", test.result, res)\n            }\n        })\n    }\n}","tests":"func TestChange_Base(t *testing.T) {\n  candidate := change_base\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(8, 3), expected: \"22\" },\n     { actual: candidate(9, 3), expected: \"100\" },\n     { actual: candidate(234, 2), expected: \"11101010\" },\n     { actual: candidate(16, 2), expected: \"10000\" },\n     { actual: candidate(8, 2), expected: \"1000\" },\n     { actual: candidate(7, 2), expected: \"111\" },\n     { actual: candidate(2, 3), expected: \"2\" },\n     { actual: candidate(3, 4), expected: \"3\" },\n     { actual: candidate(4, 5), expected: \"4\" },\n     { actual: candidate(5, 6), expected: \"5\" },\n     { actual: candidate(6, 7), expected: \"6\" },\n     { actual: candidate(7, 8), expected: \"7\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_45","nl":"kmb_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O mbandu ia beta-o-kota ni ia beta-o-kota mu ku lebha, ia tokala ku kala ni mbandu jitatu.\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given length of a side and height return area for a triangle.\n\/\/ >>> triangle_area(5, 3)\n\/\/ 7.5\nfunc triangle_area(a int, h int) float64 {\n    return 0.5 * float64(a) * float64(h)\n}\n\nfunc TestTriangleArea(t *testing.T) {\n    cases := []struct {\n        a, h int\n        expected float64\n    }{\n        {5, 3, 7.5},\n        {6, 4, 12.0},\n        {10, 2, 10.0},\n        {8, 5, 20.0},\n    }\n    \n    for _, c := range cases {\n        result := triangle_area(c.a, c.h)\n        if result != c.expected {\n            t.Errorf(\"triangle_area(%d, %d) == %f, expected %f\", c.a, c.h, result, c.expected)\n        } else {\n            fmt.Printf(\"triangle_area(%d, %d) == %f\\n\", c.a, c.h, result)\n        }\n    }\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 3), expected: 7.5 },\n     { actual: candidate(2, 2), expected: 2.0 },\n     { actual: candidate(10, 8), expected: 40.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_46","nl":"kmb_Latn","pl":"go_test.go","prompt":"package fib4_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Soneka o mbandu ia kaxa, phala kusanga o kijimbuete kia kaxa, mu kaxa ka 4. Kana ku tumbula o kijimbuete kia kaxa.\/\/fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\/\/fib4(3) -> 0 \/\/fib4(2) -> 2 \/\/fib4(1) -> 0 \/\/fib4(0) -> 0 \/\/O jivelusu ja mukuá ja Bibidia ji londekesa kuila o ima i tu bhanga, i tena ku tu bhangesa ku di tungula mu ibuka.\/\/ >>> fib4(5)\n\/\/ 4\n\/\/ >>> fib4(6)\n\/\/ 8\n\/\/ >>> fib4(7)\n\/\/ 14\nfunc fib4(n int) int {\n","canonical_solution":"func fib4(n int) int {\n    if n < 0 {\n        return 0\n    }\n    \n    seq := []int{0, 0, 2, 0}\n    \n    if n < 4 {\n        return seq[n]\n    }\n    \n    for i := 4; i <= n; i++ {\n        next := seq[0] + seq[1] + seq[2] + seq[3]\n        seq[0] = seq[1]\n        seq[1] = seq[2]\n        seq[2] = seq[3]\n        seq[3] = next\n    }\n    \n    return seq[3]\n}","tests":"func TestFib4(t *testing.T) {\n  candidate := fib4\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 28 },\n     { actual: candidate(10), expected: 104 },\n     { actual: candidate(12), expected: 386 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_47","nl":"kmb_Latn","pl":"go_test.go","prompt":"package median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ima ioso i moneka mu kaxa, a i soneka mu ukexilu ua tokala.\/\/ >>> median([]int{3, 1, 2, 4, 5})\n\/\/ 3\n\/\/ >>> median([]int{-10, 4, 6, 1000, 10, 20})\n\/\/ 15.0\nfunc median(l []int) float64 {\n","canonical_solution":"package median_test\n\nimport (\n    \"sort\"\n)\n\nfunc median(l []int) float64 {\n    sort.Ints(l)\n    n := len(l)\n    if n%2 == 1 {\n        return float64(l[n\/2])\n    }\n    mid1, mid2 := l[(n\/2)-1], l[n\/2]\n    return float64(mid1+mid2) \/ 2.0\n}","tests":"func TestMedian(t *testing.T) {\n  candidate := median\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: 3 },\n     { actual: candidate([]int{-10, 4, 6, 1000, 10, 20}), expected: 8.0 },\n     { actual: candidate([]int{5}), expected: 5 },\n     { actual: candidate([]int{6, 5}), expected: 5.5 },\n     { actual: candidate([]int{8, 1, 3, 9, 9, 2, 7}), expected: 7 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_48","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Ijiia se o kijimbuete kia mu tokala o ku ki tanga mu % 1\/\/ >>> is_palindrome(\"\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aba\")\n\/\/ true\n\/\/ >>> is_palindrome(\"aaaaa\")\n\/\/ true\n\/\/ >>> is_palindrome(\"zbcd\")\n\/\/ false\nfunc is_palindrome(text string) bool {\n","canonical_solution":"package is_palindrome_test\n\nimport (\n    \"testing\"\n)\n\n\/\/ Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    n := len(text)\n    for i := 0; i < n\/2; i++ {\n        if text[i] != text[n-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIsPalindrome(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"\", true},\n        {\"aba\", true},\n        {\"aaaaa\", true},\n        {\"zbcd\", false},\n    }\n\n    for _, test := range tests {\n        result := is_palindrome(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %v, but got %v\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_49","nl":"kmb_Latn","pl":"go_test.go","prompt":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kiki, o muthu u tena ku soneka o ima ioso mu mukanda.\/\/ >>> modp(3, 5)\n\/\/ 3\n\/\/ >>> modp(1101, 101)\n\/\/ 2\n\/\/ >>> modp(0, 101)\n\/\/ 1\n\/\/ >>> modp(3, 11)\n\/\/ 8\n\/\/ >>> modp(100, 101)\n\/\/ 1\nfunc modp(n int, p int) int {\n","canonical_solution":"package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return 2^n modulo p (be aware of numerics).\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n    }\n    result := 1\n    base := 2\n    for n > 0 {\n        if n%2 == 1 {\n            result = (result * base) % p\n        }\n        base = (base * base) % p\n        n \/= 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T) {\n    tests := []struct {\n        n, p int\n        expected int\n    }{\n        {3, 5, 3},\n        {1101, 101, 2},\n        {0, 101, 1},\n        {3, 11, 8},\n        {100, 101, 1},\n    }\n\n    for _, test := range tests {\n        result := modp(test.n, test.p)\n        if result != test.expected {\n            t.Errorf(\"modp(%d, %d) = %d; expected %d\", test.n, test.p, result, test.expected)\n        } else {\n            fmt.Printf(\"modp(%d, %d) = %d; passed\\n\", test.n, test.p, result)\n        }\n    }\n}","tests":"func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_51","nl":"kmb_Latn","pl":"go_test.go","prompt":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/remove_vowels, o ukexilu ua ku katula o jiletala ni ku ji lungulula mu jiletala ki jala ni jiletala. \/\/ >>> remove_vowels(\"\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"abcdef\")\n\/\/ \"bcdf\"\n\/\/ >>> remove_vowels(\"aaaaa\")\n\/\/ \"\"\n\/\/ >>> remove_vowels(\"aaBAA\")\n\/\/ \"B\"\n\/\/ >>> remove_vowels(\"zbcd\")\n\/\/ \"zbcd\"\nfunc remove_vowels(text string) string {\n","canonical_solution":"package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc remove_vowels(text string) string {\n    vowels := \"aeiouAEIOU\"\n    var result strings.Builder\n    for _, char := range text {\n        if !strings.ContainsRune(vowels, char) {\n            result.WriteRune(char)\n        }\n    }\n    return result.String()\n}\n\nfunc TestRemoveVowels(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"\", \"\"},\n        {\"abcdef\", \"bcdf\"},\n        {\"aaaaa\", \"\"},\n        {\"aaBAA\", \"B\"},\n        {\"zbcd\", \"zbcd\"},\n    }\n\n    for _, test := range tests {\n        if output := remove_vowels(test.input); output != test.expected {\n            t.Errorf(\"remove_vowels(%q) = %q; expected %q\", test.input, output, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    test := &testing.T{}\n    TestRemoveVowels(test)\n    if test.Failed() {\n        fmt.Println(\"Tests failed!\")\n    } else {\n        fmt.Println(\"All tests passed!\")\n    }\n}","tests":"func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual: candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_52","nl":"kmb_Latn","pl":"go_test.go","prompt":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku sanga o kijimbuete kia mukuá, mu kijimbuete ki ua mesena o ku sanga, mu ku bhana o kijimbuete kia mukuá, ua tokala ku soneka o kijimbuete kia mukuá.\/\/ >>> below_threshold([]int{1, 2, 4, 10}, 100)\n\/\/ true\n\/\/ >>> below_threshold([]int{1, 20, 4, 10}, 5)\n\/\/ false\nfunc below_threshold(l []int, t int) bool {\n","canonical_solution":"package below_threshold_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if all numbers in the list l are below threshold t.\nfunc below_threshold(l []int, t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}\n\n\/\/ Example test cases\nfunc TestBelowThreshold(t *testing.T) {\n    if !below_threshold([]int{1, 2, 4, 10}, 100) {\n        t.Error(\"Expected true, got false\")\n    }\n    if below_threshold([]int{1, 20, 4, 10}, 5) {\n        t.Error(\"Expected false, got true\")\n    }\n}\n\nfunc main() {\n    fmt.Println(below_threshold([]int{1, 2, 4, 10}, 100)) \/\/ true\n    fmt.Println(below_threshold([]int{1, 20, 4, 10}, 5))  \/\/ false\n}","tests":"func TestBelow_Threshold(t *testing.T) {\n  candidate := below_threshold\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}, 100), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 5), expected: false },\n     { actual: candidate([]int{1, 20, 4, 10}, 21), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}, 22), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 11), expected: true },\n     { actual: candidate([]int{1, 8, 4, 10}, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_53","nl":"kmb_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/X ni Y, o ibuka iiadi i sokela.\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n","canonical_solution":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Add two numbers x and y\n\/\/ >>> add(2, 3)\n\/\/ 5\n\/\/ >>> add(5, 7)\n\/\/ 12\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc TestAdd(t *testing.T) {\n    testCases := []struct {\n        x, y, expected int\n    }{\n        {2, 3, 5},\n        {5, 7, 12},\n    }\n\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\"add(%d,%d)\", tc.x, tc.y), func(t *testing.T) {\n            result := add(tc.x, tc.y)\n            if result != tc.expected {\n                t.Errorf(\"Expected %d, got %d\", tc.expected, result)\n            }\n        })\n    }\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0, 1), expected: 1 },\n     { actual: candidate(1, 0), expected: 1 },\n     { actual: candidate(2, 3), expected: 5 },\n     { actual: candidate(5, 7), expected: 12 },\n     { actual: candidate(7, 5), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_54","nl":"kmb_Latn","pl":"go_test.go","prompt":"package same_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Sota kuijiia se o izuelu iala ni ijimbuete imoxi. \/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"abcd\", \"dddddddabc\")\n\/\/ true\n\/\/ >>> same_chars(\"dddddddabc\", \"abcd\")\n\/\/ true\n\/\/ >>> same_chars(\"eabcd\", \"dddddddabc\")\n\/\/ false\n\/\/ >>> same_chars(\"abcd\", \"dddddddabce\")\n\/\/ false\n\/\/ >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n\/\/ false\nfunc same_chars(s0 string, s1 string) bool {\n","canonical_solution":"package same_chars_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc same_chars(s0 string, s1 string) bool {\n\tcountChars := func(s string) map[rune]int {\n\t\tcount := make(map[rune]int)\n\t\tfor _, char := range s {\n\t\t\tcount[char]++\n\t\t}\n\t\treturn count\n\t}\n\n\tcount0 := countChars(s0)\n\tcount1 := countChars(s1)\n\n\tfor char := range count0 {\n\t\tif count1[char] < count0[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor char := range count1 {\n\t\tif count0[char] < count1[char] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc TestSameChars(t *testing.T) {\n\ttests := []struct {\n\t\ts0     string\n\t\ts1     string\n\t\tresult bool\n\t}{\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddeddabc\", true},\n\t\t{\"abcd\", \"dddddddabc\", true},\n\t\t{\"dddddddabc\", \"abcd\", true},\n\t\t{\"eabcd\", \"dddddddabc\", false},\n\t\t{\"abcd\", \"dddddddabce\", false},\n\t\t{\"eabcdzzzz\", \"dddzzzzzzzddddabc\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s vs %s\", test.s0, test.s1), func(t *testing.T) {\n\t\t\tif got := same_chars(test.s0, test.s1); got != test.result {\n\t\t\t\tt.Errorf(\"same_chars(%q, %q) = %v; want %v\", test.s0, test.s1, got, test.result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSame_Chars(t *testing.T) {\n  candidate := same_chars\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"), expected: true },\n     { actual: candidate(\"abcd\", \"dddddddabc\"), expected: true },\n     { actual: candidate(\"dddddddabc\", \"abcd\"), expected: true },\n     { actual: candidate(\"eabcd\", \"dddddddabc\"), expected: false },\n     { actual: candidate(\"abcd\", \"dddddddabcf\"), expected: false },\n     { actual: candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"), expected: false },\n     { actual: candidate(\"aabb\", \"aaccc\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_55","nl":"kmb_Latn","pl":"go_test.go","prompt":"package fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Xisa o kijimbuete kia n-th kia Fibonacci. \/\/ >>> fib(10)\n\/\/ 55\n\/\/ >>> fib(1)\n\/\/ 1\n\/\/ >>> fib(8)\n\/\/ 21\nfunc fib(n int) int {\n","canonical_solution":"if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}","tests":"func TestFib(t *testing.T) {\n  candidate := fib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10), expected: 55 },\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(8), expected: 21 },\n     { actual: candidate(11), expected: 89 },\n     { actual: candidate(12), expected: 144 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_56","nl":"kmb_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/return true se o mbandu ia dianga ia polova, iala ni polova ia sukina. \/\/O kijimbuete \">\" mu dimatekenu dia kizuelu, kilombolola \"o jipondo ja izuelu\".\/\/ >>> correct_bracketing(\"<\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"<>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"<<><>>\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"><<>\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '<' {\n            balance++\n        } else if char == '>' {\n            balance--\n            if balance < 0 {\n                return false\n            }\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    testCases := []struct {\n        input    string\n        expected bool\n    }{\n        {input: \"<\", expected: false},\n        {input: \"<>\", expected: true},\n        {input: \"<<><>>\", expected: true},\n        {input: \"><<>\", expected: false},\n        {input: \"<<>>\", expected: true},\n        {input: \"><\", expected: false},\n    }\n\n    for _, tc := range testCases {\n        result := correct_bracketing(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; expected %v\", tc.input, result, tc.expected)\n        } else {\n            fmt.Printf(\"Test passed for input: %q\\n\", tc.input)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_57","nl":"kmb_Latn","pl":"go_test.go","prompt":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku bandekesa, kulombolola kuila o ima ioso iala mu mukanda iú, ia-nda di bandekesa mba ia-nda di batuka.\/\/ >>> monotonic([]int{1, 2, 4, 20})\n\/\/ true\n\/\/ >>> monotonic([]int{1, 20, 4, 10})\n\/\/ false\n\/\/ >>> monotonic([]int{4, 1, 0, -10})\n\/\/ true\nfunc monotonic(l []int) bool {\n","canonical_solution":"package monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Return true if list elements are monotonically increasing or decreasing.\nfunc monotonic(l []int) bool {\n    if len(l) < 2 {\n        return true\n    }\n    increasing := true\n    decreasing := true\n\n    for i := 1; i < len(l); i++ {\n        if l[i] > l[i-1] {\n            decreasing = false\n        }\n        if l[i] < l[i-1] {\n            increasing = false\n        }\n    }\n\n    return increasing || decreasing\n}\n\nfunc TestMonotonic(t *testing.T) {\n    fmt.Println(monotonic([]int{1, 2, 4, 20})) \/\/ true\n    fmt.Println(monotonic([]int{1, 20, 4, 10})) \/\/ false\n    fmt.Println(monotonic([]int{4, 1, 0, -10})) \/\/ true\n}","tests":"func TestMonotonic(t *testing.T) {\n  candidate := monotonic\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 10}), expected: true },\n     { actual: candidate([]int{1, 2, 4, 20}), expected: true },\n     { actual: candidate([]int{1, 20, 4, 10}), expected: false },\n     { actual: candidate([]int{4, 1, 0, -10}), expected: true },\n     { actual: candidate([]int{4, 1, 1, 0}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 2, 5, 60}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 60}), expected: true },\n     { actual: candidate([]int{9, 9, 9, 9}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_58","nl":"kmb_Latn","pl":"go_test.go","prompt":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ukexilu iú u kuatekesa kuijiia se mbandu iahi ia milongi ia Bibidia ia tokala ku i kaiela.\/\/ >>> common([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n\/\/ []int{1, 5, 653}\n\/\/ >>> common([]int{5, 3, 2, 8}, []int{3, 2})\n\/\/ []int{2, 3}\nfunc common(l1 []int, l2 []int) []int {\n","canonical_solution":"package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc common(l1 []int, l2 []int) []int {\n    set1 := make(map[int]struct{})\n    set2 := make(map[int]struct{})\n    commonSet := make(map[int]struct{})\n    \n    \/\/ Fill set1 with elements of l1\n    for _, num := range l1 {\n        set1[num] = struct{}{}\n    }\n    \n    \/\/ Fill set2 with elements of l2\n    for _, num := range l2 {\n        if _, found := set1[num]; found {\n            commonSet[num] = struct{}{}\n        }\n        set2[num] = struct{}{}\n    }\n    \n    result := make([]int, 0, len(commonSet))\n    \n    \/\/ Collect common elements\n    for num := range commonSet {\n        result = append(result, num)\n    }\n    \n    \/\/ Sort the result\n    sort.Ints(result)\n    \n    return result\n}\n\nfunc TestCommon(t *testing.T) {\n    cases := []struct {\n        l1, l2 []int\n        expected []int\n    }{\n        {[]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}, []int{1, 5, 653}},\n        {[]int{5, 3, 2, 8}, []int{3, 2}, []int{2, 3}},\n    }\n    \n    for _, c := range cases {\n        result := common(c.l1, c.l2)\n        if !equal(result, c.expected) {\n            t.Errorf(\"common(%v, %v) == %v, expected %v\", c.l1, c.l2, result, c.expected)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2, 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_59","nl":"kmb_Latn","pl":"go_test.go","prompt":"package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Xisa o muxinda ua dikota ua ima ioso.\/\/ >>> largest_prime_factor(13195)\n\/\/ 29\n\/\/ >>> largest_prime_factor(2048)\n\/\/ 2\nfunc largest_prime_factor(n int) int {\n","canonical_solution":"package largest_prime_factor_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc largest_prime_factor(n int) int {\n\tlargestFactor := 1\n\tdiv := 2\n\n\tfor n > 1 {\n\t\tif n%div == 0 {\n\t\t\tlargestFactor = div\n\t\t\tn \/= div\n\t\t} else {\n\t\t\tdiv++\n\t\t}\n\t}\n\n\treturn largestFactor\n}\n\nfunc TestLargestPrimeFactor(t *testing.T) {\n\ttests := []struct{\n\t\tn int\n\t\texpected int\n\t} {\n\t\t{13195, 29},\n\t\t{2048, 2},\n\t\t{123456, 643},\n\t\t{100, 5},\n\t\t{999, 37},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d\", test.n), func(t *testing.T) {\n\t\t\tif result := largest_prime_factor(test.n); result != test.expected {\n\t\t\t\tt.Errorf(\"largest_prime_factor(%d) = %d; expected %d\", test.n, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual: candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195), expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_60","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sum_to_n_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/sum_to_n, o mbandu ia ku kondala ia 1 mu n.\/\/ >>> sum_to_n(30)\n\/\/ 465\n\/\/ >>> sum_to_n(100)\n\/\/ 5050\n\/\/ >>> sum_to_n(5)\n\/\/ 15\n\/\/ >>> sum_to_n(10)\n\/\/ 55\n\/\/ >>> sum_to_n(1)\n\/\/ 1\nfunc sum_to_n(n int) int {\n","canonical_solution":"func sum_to_n(n int) int {\n    return n * (n + 1) \/ 2\n}\n\nfunc TestSumToN(t *testing.T) {\n    tests := []struct {\n        input    int\n        expected int\n    }{\n        {30, 465},\n        {100, 5050},\n        {5, 15},\n        {10, 55},\n        {1, 1},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"sum_to_n(%d)\", test.input), func(t *testing.T) {\n            result := sum_to_n(test.input)\n            if result != test.expected {\n                t.Errorf(\"Expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestSum_To_N(t *testing.T) {\n  candidate := sum_to_n\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(6), expected: 21 },\n     { actual: candidate(11), expected: 66 },\n     { actual: candidate(30), expected: 465 },\n     { actual: candidate(100), expected: 5050 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_61","nl":"kmb_Latn","pl":"go_test.go","prompt":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/return true se o mbandu ia dianga ia polova, iala ni polova ia sukina. \/\/O kijimbuete \"k\" mu dimatekenu dia kizuelu, kilombolola \"k\".\/\/ >>> correct_bracketing(\"(\")\n\/\/ false\n\/\/ >>> correct_bracketing(\"()\")\n\/\/ true\n\/\/ >>> correct_bracketing(\"(()())\")\n\/\/ true\n\/\/ >>> correct_bracketing(\")(()\")\n\/\/ false\nfunc correct_bracketing(brackets string) bool {\n","canonical_solution":"package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc correct_bracketing(brackets string) bool {\n    balance := 0\n    for _, char := range brackets {\n        if char == '(' {\n            balance++\n        } else if char == ')' {\n            balance--\n        }\n        if balance < 0 {\n            return false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrectBracketing(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected bool\n    }{\n        {\"(\", false},\n        {\"()\", true},\n        {\"(()())\", true},\n        {\")(()\", false},\n        {\"\", true},\n        {\"((()))\", true},\n        {\"(()\", false},\n        {\"())\", false},\n    }\n\n    for _, tt := range tests {\n        result := correct_bracketing(tt.input)\n        if result != tt.expected {\n            t.Errorf(\"correct_bracketing(%q) = %v; want %v\", tt.input, result, tt.expected)\n        } else {\n            fmt.Printf(\"correct_bracketing(%q) = %v\\n\", tt.input, result)\n        }\n    }\n}","tests":"func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_62","nl":"kmb_Latn","pl":"go_test.go","prompt":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Xisa o mbandu ia polinômio ni ia tokala.\/\/xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/O polinômio ia beta-kota, o polinômio ia beta-kota.\/\/ >>> derivative([]int{3, 1, 2, 4, 5})\n\/\/ []int{1, 4, 12, 20}\n\/\/ >>> derivative([]int{1, 2, 3})\n\/\/ []int{2, 6}\nfunc derivative(xs []int) []int {\n","canonical_solution":"package derivative_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ xs represent coefficients of a polynomial.\n\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + ....\n\/\/ Return derivative of this polynomial in the same form.\nfunc derivative(xs []int) []int {\n    if len(xs) <= 1 {\n        return []int{}\n    }\n    \n    derived := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        derived[i-1] = xs[i] * i\n    }\n    return derived\n}\n\nfunc TestDerivative(t *testing.T) {\n    testCases := []struct{\n        input []int\n        expected []int\n    }{\n        {[]int{3, 1, 2, 4, 5}, []int{1, 4, 12, 20}},\n        {[]int{1, 2, 3}, []int{2, 6}},\n        {[]int{1}, []int{}},\n        {[]int{}, []int{}},\n    }\n\n    for _, testCase := range testCases {\n        result := derivative(testCase.input)\n        if !equal(result, testCase.expected) {\n            t.Errorf(\"For input %v, expected %v, but got %v\", \n                     testCase.input, testCase.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestDerivative(t *testing.T) {\n  candidate := derivative\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 1, 2, 4, 5}), expected: []int{1, 4, 12, 20} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 6} },\n     { actual: candidate([]int{3, 2, 1}), expected: []int{2, 2} },\n     { actual: candidate([]int{3, 2, 1, 0, 4}), expected: []int{2, 2, 0, 16} },\n     { actual: candidate([]int{1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_63","nl":"kmb_Latn","pl":"go_test.go","prompt":"package fibfib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Soneka o mbandu ia kaxa, phala kusanga o kijimbuete kia kaxa.\/\/fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). \/\/o o o o o o o o o o o o o o o o o o o o\/\/O kuila o Bibidia i zuela kuila Nzambi ua bhange o muthu mu xitu?\/\/0 0 0 0 0 0 0 0 0 0 0\/\/O ku kaiela o ukexilu ua FibFib, ua difu ni ku kaiela o ukexilu ua Fibbonacci, ua jimbulula kiki: \/\/ >>> fibfib(1)\n\/\/ 0\n\/\/ >>> fibfib(5)\n\/\/ 4\n\/\/ >>> fibfib(8)\n\/\/ 24\nfunc fibfib(n int) int {\n","canonical_solution":"func fibfib(n int) int {\n    if n == 0 || n == 1 {\n        return 0\n    } else if n == 2 {\n        return 1\n    }\n\n    a, b, c := 0, 0, 1\n    for i := 3; i <= n; i++ {\n        next := a + b + c\n        a = b\n        b = c\n        c = next\n    }\n    return c\n}","tests":"func TestFibfib(t *testing.T) {\n  candidate := fibfib\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: 1 },\n     { actual: candidate(1), expected: 0 },\n     { actual: candidate(5), expected: 4 },\n     { actual: candidate(8), expected: 24 },\n     { actual: candidate(10), expected: 81 },\n     { actual: candidate(12), expected: 274 },\n     { actual: candidate(14), expected: 927 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_64","nl":"kmb_Latn","pl":"go_test.go","prompt":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O kizuelu kiki, ki moneka ngó ku disukilu dia kizuelu, maji a ki soneka mu ukexilu uéngi, kála o kizuelu \"mu\".\/\/O kijimbuete kia \"a\", \"e\", \"i\", \"o\", \"u\" mu velusu íii, a ki soneka mu ukexilu ua \"a\", \"e\", \"i\", \"o\", \"u\".\/\/O kizuelu \"ku\", mu dimi dia Hebalaiku kilombolola \"ku\", mu Hebalaiku kilombolola \"ku\", mu Ngeleku kilombolola \"ku\", mu Hebalaiku kilombolola \"ku\".\/\/Soneka o kijimbuete, \/\/ >>> vowels_count(\"abcde\")\n\/\/ 2\n\/\/ >>> vowels_count(\"ACEDY\")\n\/\/ 3\nfunc vowels_count(s string) int {\n","canonical_solution":"package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc vowels_count(s string) int {\n    count := 0\n    s = strings.ToLower(s)\n    vowels := \"aeiou\"\n    for i, char := range s {\n        if strings.ContainsRune(vowels, char) || (char == 'y' && i == len(s)-1) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestVowelsCount(t *testing.T) {\n    tests := []struct {\n        input  string\n        output int\n    }{\n        {\"abcde\", 2},\n        {\"ACEDY\", 3},\n        {\"xyz\", 1},\n        {\"plenty\", 1},\n        {\"queue\", 3},\n    }\n\n    for _, test := range tests {\n        result := vowels_count(test.input)\n        if result != test.output {\n            t.Errorf(\"Expected %d, but got %d for input %s\", test.output, result, test.input)\n        } else {\n            fmt.Printf(\"Success: got %d for input %s\\n\", result, test.input)\n        }\n    }\n}","tests":"func TestVowels_Count(t *testing.T) {\n  candidate := vowels_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\"), expected: 2 },\n     { actual: candidate(\"Alone\"), expected: 3 },\n     { actual: candidate(\"key\"), expected: 2 },\n     { actual: candidate(\"bye\"), expected: 1 },\n     { actual: candidate(\"keY\"), expected: 2 },\n     { actual: candidate(\"bYe\"), expected: 1 },\n     { actual: candidate(\"ACEDY\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_65","nl":"kmb_Latn","pl":"go_test.go","prompt":"package circular_shift_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Se shift > o muxinda ua ijimbuete, o ijimbuete ia tokala ku i lungulula.\/\/ua-nda tambula o kitambuijilu mu ku suluka ua-nda soneka o kitambuijilu.\/\/Xisa o jimbandu ja dífue ni jivelusu.\/\/ >>> circular_shift(12, 1)\n\/\/ \"21\"\n\/\/ >>> circular_shift(12, 2)\n\/\/ \"12\"\nfunc circular_shift(x int, shift int) string {\n","canonical_solution":"package circular_shift_test\n\nimport (\n    \"strconv\"\n)\n\nfunc circular_shift(x int, shift int) string {\n    strX := strconv.Itoa(x)\n    numDigits := len(strX)\n\n    if shift > numDigits {\n        \/\/ Reverse the digits if shift is greater than the number of digits\n        reversed := make([]byte, numDigits)\n        for i := 0; i < numDigits; i++ {\n            reversed[i] = strX[numDigits-i-1]\n        }\n        return string(reversed)\n    } else {\n        \/\/ Perform a circular shift\n        shift = shift % numDigits\n        return strX[numDigits-shift:] + strX[:numDigits-shift]\n    }\n}","tests":"func TestCircular_Shift(t *testing.T) {\n  candidate := circular_shift\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(100, 2), expected: \"001\" },\n     { actual: candidate(12, 2), expected: \"12\" },\n     { actual: candidate(97, 8), expected: \"79\" },\n     { actual: candidate(12, 1), expected: \"21\" },\n     { actual: candidate(11, 101), expected: \"11\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_66","nl":"kmb_Latn","pl":"go_test.go","prompt":"package digitSum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/ASCII jisabhu. \/\/Soneka o ifua ia fuama phala kulondekesa o mbandu ia fuama.\/\/Kikalakalu \/\/ >>> digitSum(\"\")\n\/\/ 0\n\/\/ >>> digitSum(\"abAB\")\n\/\/ 131\n\/\/ >>> digitSum(\"abcCd\")\n\/\/ 67\n\/\/ >>> digitSum(\"helloE\")\n\/\/ 69\n\/\/ >>> digitSum(\"woArBld\")\n\/\/ 131\n\/\/ >>> digitSum(\"aAaaaXa\")\n\/\/ 153\nfunc digitSum(s string) int {\n","canonical_solution":"func digitSum(s string) int {\n    sum := 0\n    for _, char := range s {\n        if char >= 'A' && char <= 'Z' {\n            sum += int(char)\n        }\n    }\n    return sum\n}","tests":"func TestDigitsum(t *testing.T) {\n  candidate := digitSum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"abAB\"), expected: 131 },\n     { actual: candidate(\"abcCd\"), expected: 67 },\n     { actual: candidate(\"helloE\"), expected: 69 },\n     { actual: candidate(\"woArBld\"), expected: 131 },\n     { actual: candidate(\"aAaaaXa\"), expected: 153 },\n     { actual: candidate(\" How are yOu?\"), expected: 151 },\n     { actual: candidate(\"You arE Very Smart\"), expected: 327 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_67","nl":"kmb_Latn","pl":"go_test.go","prompt":"package fruit_distribution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/mu mbandu ia dianga: \/\/mu kitutu, o kijimbuete kia ibundu ia miangu iala mu kitutu. \/\/o ji maçá ni ji maçá ni muxinda ua ibundu \/\/O kijimbuete ki londekesa o muxinda ua ibundu ia tiliku, o tiliku ilombolola o ibundu ia mixi.\/\/O ibundu i moneka mu kitutu kiki, ia tokala ku i ta mu kitutu kia ku bhaka-mu o ibundu.\/\/Mu kubhanga o kikalakalu kiki, a-nda kubhana kaxa ilondekesa o ji maçá ni ji maçá ja mukuá \/\/ >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n\/\/ 8\n\/\/ >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n\/\/ 2\n\/\/ >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n\/\/ 95\n\/\/ >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n\/\/ 19\nfunc fruit_distribution(s string, n int) int {\n","canonical_solution":"package fruit_distribution_test\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"testing\"\n)\n\nfunc fruit_distribution(s string, n int) int {\n    re := regexp.MustCompile(`(\\d+) apples and (\\d+) oranges`)\n    matches := re.FindStringSubmatch(s)\n    \n    if len(matches) != 3 {\n        return -1 \/\/ Could return an error or a sentinel value if input format is incorrect\n    }\n\n    apples, _ := strconv.Atoi(matches[1])\n    oranges, _ := strconv.Atoi(matches[2])\n\n    mangoes := n - (apples + oranges)\n    return mangoes\n}\n\nfunc TestFruitDistribution(t *testing.T) {\n    var tests = []struct {\n        description string\n        inputString string\n        totalFruits int\n        expected    int\n    }{\n        {\"Test case 1\", \"5 apples and 6 oranges\", 19, 8},\n        {\"Test case 2\", \"0 apples and 1 oranges\", 3, 2},\n        {\"Test case 3\", \"2 apples and 3 oranges\", 100, 95},\n        {\"Test case 4\", \"100 apples and 1 oranges\", 120, 19},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.description, func(t *testing.T) {\n            result := fruit_distribution(tt.inputString, tt.totalFruits)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}\n\nfunc main() {\n    fmt.Println(fruit_distribution(\"5 apples and 6 oranges\", 19)) \/\/ 8\n    fmt.Println(fruit_distribution(\"0 apples and 1 oranges\", 3))  \/\/ 2\n    fmt.Println(fruit_distribution(\"2 apples and 3 oranges\", 100)) \/\/ 95\n    fmt.Println(fruit_distribution(\"100 apples and 1 oranges\", 120)) \/\/ 19\n}","tests":"func TestFruit_Distribution(t *testing.T) {\n  candidate := fruit_distribution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"5 apples and 6 oranges\", 19), expected: 8 },\n     { actual: candidate(\"5 apples and 6 oranges\", 21), expected: 10 },\n     { actual: candidate(\"0 apples and 1 oranges\", 3), expected: 2 },\n     { actual: candidate(\"1 apples and 0 oranges\", 3), expected: 2 },\n     { actual: candidate(\"2 apples and 3 oranges\", 100), expected: 95 },\n     { actual: candidate(\"2 apples and 3 oranges\", 5), expected: 0 },\n     { actual: candidate(\"1 apples and 100 oranges\", 120), expected: 19 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_68","nl":"kmb_Latn","pl":"go_test.go","prompt":"package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia 1: \/\/Se o kijimbuete kia mukuá mu njila ki ki tokala, o kijimbuete kiki a-nda ki lungulula.\/\/O kijimbuete kia ku katula, a tokala ku ki soneka mu mukanda, [small_value, its index]\/\/Se tu sanga ji node javulu jala ni kijimbuete kimoxi, tua-nda bhinga ku ji sanga ni kijimbuete kiala ni kijimbuete kiofele. \/\/O kaxa io pinde, ia tokala i kala ni kolo ia xikatela.\/\/O kikalakalu kiê, o ku katula o ji bola ni ku ji vutula.\/\/\"Se tu mona kisangela kia athu ki athu a kidi, o kisangela kiki kia-nda kala kia kidi muene\"\/\/ >>> pluck([]int{4, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 2:\n\/\/ >>> pluck([]int{1, 2, 3})\n\/\/ []int{2, 1}\n\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/ Example 3:\n\/\/ >>> pluck([]int{})\n\/\/ []int{}\n\/\/ Example 4:\n\/\/ >>> pluck([]int{5, 0, 3, 0, 4, 2})\n\/\/ []int{0, 1}\n\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/ so we will choose the first zero, which has the smallest index.\n\/\/ Constraints:\n\/\/ * 1 <= nodes.length <= 10000\n\/\/ * 0 <= node.value\nfunc pluck(arr []int) []int {\n","canonical_solution":"package pluck_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ pluck function that implements the solution as described in the problem\nfunc pluck(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn []int{}\n\t}\n\n\tsmallestEvenValue := -1\n\tindex := -1\n\n\tfor i, val := range arr {\n\t\tif val%2 == 0 {\n\t\t\tif smallestEvenValue == -1 || val < smallestEvenValue {\n\t\t\t\tsmallestEvenValue = val\n\t\t\t\tindex = i\n\t\t\t}\n\t\t}\n\t}\n\n\tif index == -1 {\n\t\treturn []int{}\n\t}\n\n\treturn []int{smallestEvenValue, index}\n}\n\n\/\/ Example unit tests can be implemented by using the testing package\nfunc TestPluck(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{4, 2, 3}, []int{2, 1}},\n\t\t{[]int{1, 2, 3}, []int{2, 1}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{5, 0, 3, 0, 4, 2}, []int{0, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := pluck(test.input)\n\t\tif len(result) != len(test.expected) || (len(result) > 0 && (result[0] != test.expected[0] || result[1] != test.expected[1])) {\n\t\t\tt.Errorf(\"pluck(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_69","nl":"kmb_Latn","pl":"go_test.go","prompt":"package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/Se o kijimbuete kiki ki moneka, a tokala ku soneka o kijimbuete -1.\/\/O veji ia ku sanga o kijimbuete, ia lungu ni veji ia ku moneka o kijimbuete kiki mu mukanda.\/\/O kijimbuete kia mukuá, o zero, ki moneka ngó mu veji imoxi, kiki kilombolola kuila, o kijimbuete kia mukuá, kia beta-o-kota, o zero ndenge.\/\/O ku soneka o ima ioso mu mukanda iú, kua-nda ku kuatekesa kusanga o ima ioso i ua mesena o ku soneka.\/\/ >>> search([]int{4, 1, 2, 2, 3, 1})\n\/\/ 2\n\/\/ >>> search([]int{1, 2, 2, 3, 3, 3, 4, 4, 4})\n\/\/ 3\n\/\/ >>> search([]int{5, 5, 4, 4, 4})\n\/\/ -1\nfunc search(lst []int) int {\n","canonical_solution":"package search_test\n\nimport \"sort\"\n\nfunc search(lst []int) int {\n\tfrequency := make(map[int]int)\n\n\tfor _, num := range lst {\n\t\tfrequency[num]++\n\t}\n\n\tcandidates := []int{}\n\tfor num, count := range frequency {\n\t\tif count >= num {\n\t\t\tcandidates = append(candidates, num)\n\t\t}\n\t}\n\n\tif len(candidates) == 0 {\n\t\treturn -1\n\t}\n\n\tsort.Ints(candidates)\n\treturn candidates[len(candidates)-1]\n}","tests":"func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 5, 5, 5, 1}), expected: 1 },\n     { actual: candidate([]int{4, 1, 4, 1, 4, 4}), expected: 4 },\n     { actual: candidate([]int{3, 3}), expected: -1 },\n     { actual: candidate([]int{8, 8, 8, 8, 8, 8, 8, 8}), expected: 8 },\n     { actual: candidate([]int{2, 3, 3, 2, 2}), expected: 2 },\n     { actual: candidate([]int{2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}), expected: 1 },\n     { actual: candidate([]int{3, 2, 8, 2}), expected: 2 },\n     { actual: candidate([]int{6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}), expected: 1 },\n     { actual: candidate([]int{8, 8, 3, 6, 5, 6, 4}), expected: -1 },\n     { actual: candidate([]int{6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}), expected: 1 },\n     { actual: candidate([]int{1, 9, 10, 1, 3}), expected: 1 },\n     { actual: candidate([]int{6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}), expected: 5 },\n     { actual: candidate([]int{1}), expected: 1 },\n     { actual: candidate([]int{8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}), expected: 4 },\n     { actual: candidate([]int{2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}), expected: 2 },\n     { actual: candidate([]int{1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}), expected: 1 },\n     { actual: candidate([]int{9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}), expected: 4 },\n     { actual: candidate([]int{2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}), expected: 4 },\n     { actual: candidate([]int{9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}), expected: 2 },\n     { actual: candidate([]int{5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}), expected: -1 },\n     { actual: candidate([]int{10}), expected: -1 },\n     { actual: candidate([]int{9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}), expected: 2 },\n     { actual: candidate([]int{5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}), expected: 1 },\n     { actual: candidate([]int{7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}), expected: 1 },\n     { actual: candidate([]int{3, 10, 10, 9, 2}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_70","nl":"kmb_Latn","pl":"go_test.go","prompt":"package strange_sort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/Mu ku suluka, tu tena ku soneka o ima ioso i tua mesena.\/\/O ku uana kiambote o ima, ku bhinga ku dianga ku i sola kala kia tokala.\/\/Mu ku bhana o milongi ia milongi ioso, tu tena ku soneka o milongi ioso mu ukexilu ua tokala.\/\/ >>> strange_sort_list([]int{1, 2, 3, 4})\n\/\/ []int{1, 4, 2, 3}\n\/\/ >>> strange_sort_list([]int{5, 5, 5, 5})\n\/\/ []int{5, 5, 5, 5}\n\/\/ >>> strange_sort_list([]int{})\n\/\/ []int{}\nfunc strange_sort_list(lst []int) []int {\n","canonical_solution":"package strange_sort_list_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc strange_sort_list(lst []int) []int {\n\tif len(lst) == 0 {\n\t\treturn lst\n\t}\n\t\n\tsort.Ints(lst)\n\tres := make([]int, len(lst))\n\tleft, right := 0, len(lst)-1\n\ti := 0\n\n\tfor left <= right {\n\t\tif i%2 == 0 {\n\t\t\tres[i] = lst[left]\n\t\t\tleft++\n\t\t} else {\n\t\t\tres[i] = lst[right]\n\t\t\tright--\n\t\t}\n\t\ti++\n\t}\n\n\treturn res\n}\n\nfunc TestStrangeSortList(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []int\n\t\toutput []int\n\t}{\n\t\t{[]int{1, 2, 3, 4}, []int{1, 4, 2, 3}},\n\t\t{[]int{5, 5, 5, 5}, []int{5, 5, 5, 5}},\n\t\t{[]int{}, []int{}},\n\t\t{[]int{4, 2, 9, 1, 7, 6}, []int{1, 9, 2, 7, 4, 6}},\n\t}\n\tfor _, test := range tests {\n\t\tif res := strange_sort_list(test.input); !equal(res, test.output) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.output, res)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\tfmt.Println(strange_sort_list([]int{1, 2, 3, 4})) \/\/ Should print [1 4 2 3]\n}","tests":"func TestStrange_Sort_List(t *testing.T) {\n  candidate := strange_sort_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 4, 2, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9}), expected: []int{5, 9, 6, 8, 7} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 5, 2, 4, 3} },\n     { actual: candidate([]int{5, 6, 7, 8, 9, 1}), expected: []int{1, 9, 5, 8, 6, 7} },\n     { actual: candidate([]int{5, 5, 5, 5}), expected: []int{5, 5, 5, 5} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}), expected: []int{1, 8, 2, 7, 3, 6, 4, 5} },\n     { actual: candidate([]int{0, 2, 2, 2, 5, 5, -5, -5}), expected: []int{-5, 5, -5, 5, 0, 2, 2, 2} },\n     { actual: candidate([]int{111111}), expected: []int{111111} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_71","nl":"kmb_Latn","pl":"go_test.go","prompt":"package triangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O kuila o ku di longa o Bibidia izuua ioso, kua-nda ku kuatekesa?\/\/O mbandu jitatu, ji lombolola mbandu jiiadi ja beta-o-kota.\/\/Se ki kiene, o mbandu ia kijimbuete kia ku vutuka.\/\/O mbandu ia katatu, a i sokejeka mu jikolo jiiadi, se o ikoka iala ngó ni mbandu imoxi.\/\/Mu ku tala o jithéthembua ji tu sanga mu mbandu jitatu ja milongi, tala o kididi kia-nda kala o mbandu ia katatu.\/\/ >>> triangle_area(3, 4, 5)\n\/\/ 6.0\n\/\/ >>> triangle_area(1, 2, 10)\n\/\/ -1\nfunc triangle_area(a int, b int, c int) float64 {\n","canonical_solution":"package triangle_area_test\n\nimport (\n    \"math\"\n)\n\nfunc triangle_area(a int, b int, c int) float64 {\n    \/\/ Check for the validity of the triangle\n    if a+b <= c || a+c <= b || b+c <= a {\n        return -1\n    }\n    \/\/ Calculate the semi-perimeter\n    s := float64(a+b+c) \/ 2\n    \/\/ Calculate the area using Heron's formula\n    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))\n    \/\/ Round the result to 2 decimal places\n    return math.Round(area*100) \/ 100.0\n}","tests":"func TestTriangle_Area(t *testing.T) {\n  candidate := triangle_area\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: 6.0 },\n     { actual: candidate(1, 2, 10), expected: -1 },\n     { actual: candidate(4, 8, 5), expected: 8.18 },\n     { actual: candidate(2, 2, 2), expected: 1.73 },\n     { actual: candidate(1, 2, 3), expected: -1 },\n     { actual: candidate(10, 5, 7), expected: 16.25 },\n     { actual: candidate(2, 6, 3), expected: -1 },\n     { actual: candidate(1, 1, 1), expected: 0.43 },\n     { actual: candidate(2, 2, 10), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_72","nl":"kmb_Latn","pl":"go_test.go","prompt":"package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O kima ki tunda ku diulu, ki di kuata, ki di sanzumuna, se o ima ioso iala-mu ia tenena, ki i sokela ni ima ia mukuá iala mu ngongo, i tena ku di kuata.\/\/Soneka o mbandu ia kijimbuete, ijimbulula o ima i tua mesena kuila i di kumbidila.\/\/ >>> will_it_fly([]int{1, 2}, 5)\n\/\/ false\n\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 1)\n\/\/ false\n\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/ >>> will_it_fly([]int{3, 2, 3}, 9)\n\/\/ true\n\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/ >>> will_it_fly([]int{3}, 5)\n\/\/ true\n\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q []int, w int) bool {\n","canonical_solution":"func will_it_fly(q []int, w int) bool {\n    sum := 0\n    n := len(q)\n\n    \/\/ Calculate the sum of the elements in q\n    for _, value := range q {\n        sum += value\n    }\n\n    \/\/ Check if sum is greater than the maximum possible weight\n    if sum > w {\n        return false\n    }\n\n    \/\/ Check if the list is a palindrome\n    for i := 0; i < n\/2; i++ {\n        if q[i] != q[n-i-1] {\n            return false\n        }\n    }\n\n    \/\/ If the list is balanced and sum is less than or equal to w\n    return true\n}","tests":"func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_73","nl":"kmb_Latn","pl":"go_test.go","prompt":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O ku lungulula o ima mu veji imoxi, kua-nda ku kuatekesa ku lungulula o ukexilu uê uoso.\/\/O milongi íii, a i lungulula phala ku i soneka mu ukexilu u kuatekesa o athu kuijiia o maka ala mu Bibidia.\/\/Mu ku di longa o milongi ia lungu ni ijimbuete, tala o maukexilu a mukuá a tena ku tu kuatekesa kuijiia se tu athu a kidi mba kana.\/\/ >>> smallest_change([]int{1, 2, 3, 5, 4, 7, 9, 6})\n\/\/ 4\n\/\/ >>> smallest_change([]int{1, 2, 3, 4, 3, 2, 2})\n\/\/ 1\n\/\/ >>> smallest_change([]int{1, 2, 3, 2, 1})\n\/\/ 0\nfunc smallest_change(arr []int) int {\n","canonical_solution":"package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc smallest_change(arr []int) int {\n    n := len(arr)\n    changes := 0\n    for i := 0; i < n\/2; i++ {\n        if arr[i] != arr[n-i-1] {\n            changes++\n        }\n    }\n    return changes\n}\n\nfunc TestSmallestChange(t *testing.T) {\n    tests := []struct{\n        input []int\n        expected int\n    }{\n        {[]int{1, 2, 3, 5, 4, 7, 9, 6}, 4},\n        {[]int{1, 2, 3, 4, 3, 2, 2}, 1},\n        {[]int{1, 2, 3, 2, 1}, 0},\n    }\n\n    for _, test := range tests {\n        result := smallest_change(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input %v, expected %d but got %d\", test.input, test.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", test.input)\n        }\n    }\n}","tests":"func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_74","nl":"kmb_Latn","pl":"go_test.go","prompt":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/Se o majina ku ijimbuete iiadi íii a lungu, soneka-mu o dijina dia dianga.\/\/O kijimbuete kia mukuá, ki moneka ngó mu ukexilu ua mukuá.\/\/Soneka o mbandu ia kijimbuete i ua mesena mu mbandu ia kijimbuete .\/\/ >>> total_match([]string{}, []string{})\n\/\/ []string{}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n\/\/ []string{\"hI\", \"Hi\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"})\n\/\/ []string{\"hi\", \"admin\"}\n\/\/ >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\/\/ []string{\"hI\", \"hi\", \"hi\"}\n\/\/ >>> total_match([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"})\n\/\/ []string{\"4\"}\nfunc total_match(lst1 []string, lst2 []string) []string {\n","canonical_solution":"package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ total_match function returns the list with the smaller total character count.\n\/\/ If both lists have the same character count, it returns the first list.\nfunc total_match(lst1 []string, lst2 []string) []string {\n    sumChars := func(lst []string) int {\n        total := 0\n        for _, str := range lst {\n            total += len(str)\n        }\n        return total\n    }\n    \n    sum1 := sumChars(lst1)\n    sum2 := sumChars(lst2)\n\n    if sum1 <= sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\n\/\/ Test functions can go below to verify the behavior of total_match.\nfunc TestTotalMatch(t *testing.T) {\n    cases := []struct {\n        lst1      []string\n        lst2      []string\n        expected  []string\n    }{\n        {[]string{}, []string{}, []string{}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}, []string{\"hI\", \"Hi\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}, []string{\"hi\", \"admin\"}},\n        {[]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}, []string{\"hI\", \"hi\", \"hi\"}},\n        {[]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}, []string{\"4\"}},\n    }\n\n    for _, c := range cases {\n        result := total_match(c.lst1, c.lst2)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"total_match(%v, %v) == %v, expected %v\", c.lst1, c.lst2, result, c.expected)\n        }\n    }\n}","tests":"func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_75","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_multiply_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Mu kuijiia kuila a) a beta-o-kota, o a) ndenge, tua-nda di longa o kidi kiki.\/\/Maji o milongi ia Bibidia ia lungu ni maka enhá, ki ia kidi.\/\/Soneka o mbandu ia kifika, i ku bhana o kitambuijilu kia kidi, se o muxinda ua 3 ua ibuka ia makota \/\/ >>> is_multiply_prime(30)\n\/\/ true\n\/\/ 30 = 2 * 3 * 5\nfunc is_multiply_prime(a int) bool {\n","canonical_solution":"func is_multiply_prime(a int) bool {\n\tif a < 2 {\n\t\treturn false\n\t}\n\n\tprimeNumbers := generatePrimesUpTo(100)\n\t\n\tfor i := 0; i < len(primeNumbers); i++ {\n\t\tfor j := i; j < len(primeNumbers); j++ {\n\t\t\tfor k := j; k < len(primeNumbers); k++ {\n\t\t\t\tif primeNumbers[i]*primeNumbers[j]*primeNumbers[k] == a {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc generatePrimesUpTo(max int) []int {\n\tisPrime := make([]bool, max+1)\n\tfor i := 2; i <= max; i++ {\n\t\tisPrime[i] = true\n\t}\n\tfor i := 2; i*i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tfor j := i * i; j <= max; j += i {\n\t\t\t\tisPrime[j] = false\n\t\t\t}\n\t\t}\n\t}\n\tvar primes []int\n\tfor i := 2; i <= max; i++ {\n\t\tif isPrime[i] {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\treturn primes\n}","tests":"func TestIs_Multiply_Prime(t *testing.T) {\n  candidate := is_multiply_prime\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: false },\n     { actual: candidate(30), expected: true },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: false },\n     { actual: candidate(125), expected: true },\n     { actual: candidate(105), expected: true },\n     { actual: candidate(126), expected: false },\n     { actual: candidate(729), expected: false },\n     { actual: candidate(891), expected: false },\n     { actual: candidate(1001), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_76","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/x, o kutena kua n, se n**int=x \/\/j ku mbandu ia n, ni ia makutu mu jivelusu ja mukuá.\/\/O kibhwidisu kyetu, o kusoneka o kilondekesu kya kidi, se o kizwelu kiki kidi, ki kala o kizwelu \"x\" ni \"i\".\/\/ >>> is_simple_power(1, 4)\n\/\/ true\n\/\/ >>> is_simple_power(2, 2)\n\/\/ true\n\/\/ >>> is_simple_power(8, 2)\n\/\/ true\n\/\/ >>> is_simple_power(3, 2)\n\/\/ false\n\/\/ >>> is_simple_power(3, 1)\n\/\/ false\n\/\/ >>> is_simple_power(5, 3)\n\/\/ false\nfunc is_simple_power(x int, n int) bool {\n","canonical_solution":"package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_simple_power(x int, n int) bool {\n    if n <= 1 {\n        return x == 1\n    }\n    \n    current := n\n    for current <= x {\n        if current == x {\n            return true\n        }\n        current *= n\n    }\n    return false\n}\n\nfunc TestIsSimplePower(t *testing.T) {\n    tests := []struct {\n        x, n     int\n        expected bool\n    }{\n        {1, 4, true},\n        {2, 2, true},\n        {8, 2, true},\n        {3, 2, false},\n        {3, 1, false},\n        {5, 3, false},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%d,%d\", test.x, test.n), func(t *testing.T) {\n            result := is_simple_power(test.x, test.n)\n            if result != test.expected {\n                t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_77","nl":"kmb_Latn","pl":"go_test.go","prompt":"package iscube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/Mu kifika, o muthu u tena ku sola se u xikina o milongi ia Bibidia, mba kana.\/\/Se o kijimbuete kiki, ki bhana o mbandu ia katatu, tua-nda mona kuila o mbandu ia katatu ia kijimbuete kia kidi.\/\/Soneka o mbandu ia kijimbuete a i lungulula mu kijimbuete kia kidi .\/\/ >>> iscube(1)\n\/\/ true\n\/\/ >>> iscube(2)\n\/\/ false\n\/\/ >>> iscube(-1)\n\/\/ true\n\/\/ >>> iscube(64)\n\/\/ true\n\/\/ >>> iscube(0)\n\/\/ true\n\/\/ >>> iscube(180)\n\/\/ false\nfunc iscube(a int) bool {\n","canonical_solution":"package iscube_test\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc iscube(a int) bool {\n\tif a < 0 {\n\t\ta = -a\n\t}\n\tcubeRoot := math.Cbrt(float64(a))\n\treturn cubeRoot == float64(int(cubeRoot))\n}\n\nfunc TestIsCube(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{1, true},\n\t\t{2, false},\n\t\t{-1, true},\n\t\t{64, true},\n\t\t{0, true},\n\t\t{180, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"iscube(%d)\", test.input), func(t *testing.T) {\n\t\t\tresult := iscube(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestIscube(t *testing.T) {\n  candidate := iscube\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: true },\n     { actual: candidate(2), expected: false },\n     { actual: candidate(-1), expected: true },\n     { actual: candidate(64), expected: true },\n     { actual: candidate(180), expected: false },\n     { actual: candidate(1000), expected: true },\n     { actual: candidate(0), expected: true },\n     { actual: candidate(1729), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_78","nl":"kmb_Latn","pl":"go_test.go","prompt":"package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O kijimbuete A, B, C, D, E, F, ki moneka ngó mu ukexilu ua kijimbuete kia dikota.\/\/O ku soneka o ima ia mesena mu ku bhanga o kikalakalu kiki, kua-nda tu kuatekesa ku bhanga kiambote o kikalakalu kiki.\/\/B (=kuinhi dia ibuka iiadi mu kaxi ka 11) ni D (=kuinhi dia ibuka iiadi mu kaxi ka 13) \/\/Mu kiki, ua tokala kusanga o jifikula jala ku luiji: 2, 3, 5, 7, \/\/O jivelusu ja dianga mu divulu dia Dijingunuinu ji londekesa kuila, o ku di jibha kua-nda bhita muene.\/\/O jipondo ja beta-kota ja divulu didi, o jipondo ja 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\/\/O kijimbuete kiki, ki tena kulombolola o ima iiadi iofele.\/\/O muxinda ua dianga, (o muxinda ua dianga uala ni disukilu dimoxi)\/\/O kijimbuete kia ku tumina, ki moneka ngó mu ukexilu ua ku soneka o kijimbuete kia ku tumina \/\/A ku tumina kusoneka kijimbuete ki bhana o njimbu iê.\/\/ >>> hex_key(\"AB\")\n\/\/ 1\n\/\/ >>> hex_key(\"1077E\")\n\/\/ 2\n\/\/ >>> hex_key(\"ABED1A33\")\n\/\/ 4\n\/\/ >>> hex_key(\"123456789ABCDEF0\")\n\/\/ 6\n\/\/ >>> hex_key(\"2020\")\n\/\/ 2\nfunc hex_key(num string) int {\n","canonical_solution":"func hex_key(num string) int {\n    primeDigits := map[rune]struct{}{\n        '2': {},\n        '3': {},\n        '5': {},\n        '7': {},\n        'B': {},\n        'D': {},\n    }\n\n    count := 0\n    for _, digit := range num {\n        if _, found := primeDigits[digit]; found {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestHexKey(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"AB\", 1},\n        {\"1077E\", 2},\n        {\"ABED1A33\", 4},\n        {\"123456789ABCDEF0\", 6},\n        {\"2020\", 2},\n        {\"\", 0},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"hex_key(%s)\", test.input), func(t *testing.T) {\n            result := hex_key(test.input)\n            if result != test.expected {\n                t.Errorf(\"expected %d, got %d\", test.expected, result)\n            }\n        })\n    }\n}","tests":"func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4 },\n     { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_79","nl":"kmb_Latn","pl":"go_test.go","prompt":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O jiprefixu ni jisufixu jala mu jikopia ja tokala, mu kaxa mu tua mu mona o foto.\/\/O kijimbuete \"db\" mu dimatekenu ni mu disukilu dia kizuelu.\/\/O kijimbuete \"0\" kilombolola \"0\", o kijimbuete \"1\" kilombolola \"1\".\/\/O ukexilu ua ku soneka o ima, ua difu ni ukexilu ua ku soneka milongi mu mukanda.\/\/Ua-nda tambula o dijimbuluilu dia kijimbuete, ua-nda bhinga ku lungulula o kijimbuete kiki mu kijimbuete \/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n","canonical_solution":"package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strconv\"\n)\n\n\/\/ You will be given a number in decimal form and your task is to convert it to\n\/\/ binary format. The function should return a string, with each character representing a binary\n\/\/ number. Each character in the string will be '0' or '1'.\n\/\/ There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n\/\/ The extra characters are there to help with the format.\n\/\/ Examples:\n\/\/ >>> decimal_to_binary(15)\n\/\/ \"db1111db\"\n\/\/ >>> decimal_to_binary(32)\n\/\/ \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    binary := strconv.FormatInt(int64(decimal), 2)\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimalToBinary(t *testing.T) {\n    tests := []struct {\n        input  int\n        output string\n    }{\n        {15, \"db1111db\"},\n        {32, \"db100000db\"},\n        {0, \"db0db\"},\n        {1, \"db1db\"},\n        {255, \"db11111111db\"},\n    }\n\n    for _, test := range tests {\n        result := decimal_to_binary(test.input)\n        if result != test.output {\n            t.Errorf(\"For input %d, expected %s, but got %s\", test.input, test.output, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(decimal_to_binary(15))  \/\/ Output: db1111db\n    fmt.Println(decimal_to_binary(32))  \/\/ Output: db100000db\n    fmt.Println(decimal_to_binary(255)) \/\/ Output: db11111111db\n}","tests":"func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_80","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_happy_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O kijimbuete \" hapgo \" ki moneka ngó se o izuelu iala ni 3 kia jiletala, mu kiki, o jiletala ji 3 ji kaiela, ki ji difu.\/\/O kikalakalu kiê, o kuijiia se o muxi ua mu tunda mba kana.\/\/Ua-nda tambula milongi iavulu.\/\/ >>> is_happy(\"a\")\n\/\/ false\n\/\/ >>> is_happy(\"aa\")\n\/\/ false\n\/\/ >>> is_happy(\"abcd\")\n\/\/ true\n\/\/ >>> is_happy(\"aabb\")\n\/\/ false\n\/\/ >>> is_happy(\"adb\")\n\/\/ true\n\/\/ >>> is_happy(\"xyy\")\n\/\/ false\nfunc is_happy(s string) bool {\n","canonical_solution":"func is_happy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i <= len(s)-3; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestIs_Happy(t *testing.T) {\n  candidate := is_happy\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a\"), expected: false },\n     { actual: candidate(\"aa\"), expected: false },\n     { actual: candidate(\"abcd\"), expected: true },\n     { actual: candidate(\"aabb\"), expected: false },\n     { actual: candidate(\"adb\"), expected: true },\n     { actual: candidate(\"xyy\"), expected: false },\n     { actual: candidate(\"iopaxpoi\"), expected: true },\n     { actual: candidate(\"iopaxioi\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_81","nl":"kmb_Latn","pl":"go_test.go","prompt":"package numerical_letter_grade_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/0.0 E \/\/> 0.0 D- \/\/> 0.7 D \/\/> 1.0 D+ \/\/> 1.3 C- \/\/> 1.7 °C \/\/> 2.0 C+ \/\/> 2.3 B- \/\/> 2.7 B \/\/> 3.0 B+ \/\/> 3.3 A- \/\/> 3.7 A \/\/4.0 A+ \/\/❑ Jitata, o kuila mua mu longa o tuana tuenu ku tanga?\/\/O ukexilu iú u tena kukuatekesa kusanga o kijimbuete kia tokala mu mukanda, mu ku kaiela o ukexilu iú: \/\/Muéne ua ku bhana o jimbandu ja xikola , eie ua tokala ku soneka-mu o jipondo ja xikola .\/\/O maka a mateka kioso o muhatu kia kexile mu bhanga o uenji.\/\/O mulongexi ua kexile mu bhana o kitambuijilu kiê, mu ku sota ndunge phala ku bhana o kitambuijilu kia tokala.\/\/O semana ia sukina ia semestre, o mesene ua tokala kubhana o nota.\/\/ >>> grade_equation([]float64{4.0, 3, 1.7, 2, 3.5})\n\/\/ []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\nfunc numerical_letter_grade(grades []float64) []string {\n","canonical_solution":"func numerical_letter_grade(grades []float64) []string {\n    letterGrades := []string{}\n    for _, grade := range grades {\n        if grade == 4.0 {\n            letterGrades = append(letterGrades, \"A+\")\n        } else if grade > 3.7 {\n            letterGrades = append(letterGrades, \"A\")\n        } else if grade > 3.3 {\n            letterGrades = append(letterGrades, \"A-\")\n        } else if grade > 3.0 {\n            letterGrades = append(letterGrades, \"B+\")\n        } else if grade > 2.7 {\n            letterGrades = append(letterGrades, \"B\")\n        } else if grade > 2.3 {\n            letterGrades = append(letterGrades, \"B-\")\n        } else if grade > 2.0 {\n            letterGrades = append(letterGrades, \"C+\")\n        } else if grade > 1.7 {\n            letterGrades = append(letterGrades, \"C\")\n        } else if grade > 1.3 {\n            letterGrades = append(letterGrades, \"C-\")\n        } else if grade > 1.0 {\n            letterGrades = append(letterGrades, \"D+\")\n        } else if grade > 0.7 {\n            letterGrades = append(letterGrades, \"D\")\n        } else if grade > 0.0 {\n            letterGrades = append(letterGrades, \"D-\")\n        } else {\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}","tests":"func TestNumerical_Letter_Grade(t *testing.T) {\n  candidate := numerical_letter_grade\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{4.0, 3, 1.7, 2, 3.5}), expected: []string{\"A+\", \"B\", \"C-\", \"C\", \"A-\"} },\n     { actual: candidate([]float64{1.2}), expected: []string{\"D+\"} },\n     { actual: candidate([]float64{0.5}), expected: []string{\"D-\"} },\n     { actual: candidate([]float64{0.0}), expected: []string{\"E\"} },\n     { actual: candidate([]float64{1.0, 0.3, 1.5, 2.8, 3.3}), expected: []string{\"D\", \"D-\", \"C-\", \"B\", \"B+\"} },\n     { actual: candidate([]float64{0.0, 0.7}), expected: []string{\"E\", \"D-\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_82","nl":"kmb_Latn","pl":"go_test.go","prompt":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/O ku xinganeka mu ima ioso íii, kua-nda tu kuatekesa ku bhanga o ima ni lusolo.\/\/Soneka o mbandu ia funzo ia mu zuela o kidi, phala kulondekesa se o mbandu ia funzo ia mu zuela o kidi, ia mu zuela o kidi.\/\/ >>> prime_length(\"Hello\")\n\/\/ true\n\/\/ >>> prime_length(\"abcdcba\")\n\/\/ true\n\/\/ >>> prime_length(\"kittens\")\n\/\/ true\n\/\/ >>> prime_length(\"orange\")\n\/\/ false\nfunc prime_length(myString string) bool {\n","canonical_solution":"package prime_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc prime_length(myString string) bool {\n    length := len(myString)\n    return isPrime(length)\n}\n\nfunc TestPrimeLength(t *testing.T) {\n    testCases := []struct{\n        input string\n        expected bool\n    }{\n        {\"Hello\", true},\n        {\"abcdcba\", true},\n        {\"kittens\", true},\n        {\"orange\", false},\n    }\n\n    for _, testCase := range testCases {\n        result := prime_length(testCase.input)\n        if result != testCase.expected {\n            t.Errorf(\"prime_length(%v) returned %v, expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(prime_length(\"Hello\"))  \/\/ true\n    fmt.Println(prime_length(\"abcdcba\"))  \/\/ true\n    fmt.Println(prime_length(\"kittens\"))  \/\/ true\n    fmt.Println(prime_length(\"orange\"))  \/\/ false\n}","tests":"func TestPrime_Length(t *testing.T) {\n  candidate := prime_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello\"), expected: true },\n     { actual: candidate(\"abcdcba\"), expected: true },\n     { actual: candidate(\"kittens\"), expected: true },\n     { actual: candidate(\"orange\"), expected: false },\n     { actual: candidate(\"wow\"), expected: true },\n     { actual: candidate(\"world\"), expected: true },\n     { actual: candidate(\"MadaM\"), expected: true },\n     { actual: candidate(\"Wow\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"HI\"), expected: true },\n     { actual: candidate(\"go\"), expected: true },\n     { actual: candidate(\"gogo\"), expected: false },\n     { actual: candidate(\"aaaaaaaaaaaaaaa\"), expected: false },\n     { actual: candidate(\"Madam\"), expected: true },\n     { actual: candidate(\"M\"), expected: false },\n     { actual: candidate(\"0\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_83","nl":"kmb_Latn","pl":"go_test.go","prompt":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia 1 mu veji dia 1 mu veji javulu.\/\/Mu ku bhana o kijimbuete kia mutokala ua kidi, soneka o kijimbuete kia-nda moneka ku mbandu ia kijimbuete kia-nda moneka ku pholo.func starts_one_ends(n int) int {\n","canonical_solution":"package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Given a positive integer n, return the count of the numbers of n-digit\n\/\/ positive integers that start or end with 1.\nfunc starts_one_ends(n int) int {\n    if n == 1 {\n        return 1\n    }\n\n    countStart1 := 1 * pow(10, n-1)\n    countEnd1 := 9 * pow(10, n-2)\n    \n    return countStart1 + countEnd1\n}\n\nfunc pow(base, exp int) int {\n    if exp == 0 {\n        return 1\n    }\n    result := 1\n    for i := 0; i < exp; i++ {\n        result *= base\n    }\n    return result\n}\n\nfunc TestStartsOneEnds(t *testing.T) {\n    tests := []struct {\n        n        int\n        expected int\n    }{\n        {1, 1},\n        {2, 19},\n        {3, 189},\n        {4, 1899},\n        {5, 18999},\n    }\n\n    for _, tt := range tests {\n        testname := fmt.Sprintf(\"n=%d\", tt.n)\n        t.Run(testname, func(t *testing.T) {\n            result := starts_one_ends(tt.n)\n            if result != tt.expected {\n                t.Errorf(\"got %d, want %d\", result, tt.expected)\n            }\n        })\n    }\n}","tests":"func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual: candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected: 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_84","nl":"kmb_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/Mu ku bhana o kijimbuete kia tenena, soneka o kijimbuete kia-nda moneka ku mbandu ia sukina ia kijimbuete.\/\/ >>> solve(1000)\n\/\/ \"1\"\n\/\/ >>> solve(150)\n\/\/ \"110\"\n\/\/ >>> solve(147)\n\/\/ \"1100\"\n\/\/ Variables:\n\/\/ @N integer\n\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/ Output:\n\/\/ a string of binary number\nfunc solve(N int) string {\n","canonical_solution":"func solve(N int) string {\n    sum := 0\n    for N > 0 {\n        sum += N % 10\n        N \/= 10\n    }\n    return fmt.Sprintf(\"%b\", sum)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1000), expected: \"1\" },\n     { actual: candidate(150), expected: \"110\" },\n     { actual: candidate(147), expected: \"1100\" },\n     { actual: candidate(333), expected: \"1001\" },\n     { actual: candidate(963), expected: \"10010\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_85","nl":"kmb_Latn","pl":"go_test.go","prompt":"package add_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/Mu ku bhana o mbandu ia kijimbuete, ia-nda moneka ngó, tu bandekesa-mu o kijimbuete ni kijimbuete.\/\/ >>> add([]int{4, 2, 6, 7})\n\/\/ 2\nfunc add(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 1; i < len(lst); i += 2 {\n        if lst[i]%2 == 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd(t *testing.T) {\n  candidate := add\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 88}), expected: 88 },\n     { actual: candidate([]int{4, 5, 6, 7, 2, 122}), expected: 122 },\n     { actual: candidate([]int{4, 0, 6, 7}), expected: 0 },\n     { actual: candidate([]int{4, 4, 6, 8}), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_86","nl":"kmb_Latn","pl":"go_test.go","prompt":"package anti_shuffle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Mu kusuluka, soneka o ima ioso ia ku tokala.\/\/O kitadi kia tokala o ku ki ngástala.\/\/a i bhinganesa mu kizuelu kiobhe, mu ukexilu ua kuila o ijimbuete ioso i moneka mu kizuelu \/\/O izuelu ioso iala mu mukanda, a u soneka ni jiletala jofele.\/\/Soneka o ifua ia mu londekesa o polova.\/\/ >>> anti_shuffle(\"Hi\")\n\/\/ \"Hi\"\n\/\/ >>> anti_shuffle(\"hello\")\n\/\/ \"ehllo\"\n\/\/ >>> anti_shuffle(\"Hello World!!!\")\n\/\/ \"Hello !!!Wdlor\"\nfunc anti_shuffle(s string) string {\n","canonical_solution":"package anti_shuffle_test\n\nimport (\n    \"strings\"\n    \"sort\"\n)\n\nfunc anti_shuffle(s string) string {\n    \/\/ Split the input string into words based on spaces\n    words := strings.Fields(s)\n\n    \/\/ Iterate over each word\n    for i, word := range words {\n        \/\/ Convert the word to a slice of runes for sorting\n        runes := []rune(word)\n        \/\/ Sort the runes using custom comparison\n        sort.Slice(runes, func(i, j int) bool {\n            return runes[i] < runes[j]\n        })\n        \/\/ Reassign the sorted runes back to the word\n        words[i] = string(runes)\n    }\n\n    \/\/ Rejoin the words into a single string, keeping original spaces\n    result := \"\"\n    inputIndex := 0\n\n    for _, word := range words {\n        \/\/ Add the spaces prior to the current word\n        for inputIndex < len(s) && s[inputIndex] == ' ' {\n            result += \" \"\n            inputIndex++\n        }\n        \/\/ Add the current sorted word\n        result += word\n        inputIndex += len(word)\n    }\n\n    \/\/ Add trailing spaces, if any.\n    for inputIndex < len(s) && s[inputIndex] == ' ' {\n        result += \" \"\n        inputIndex++\n    }\n\n    return result\n}","tests":"func TestAnti_Shuffle(t *testing.T) {\n  candidate := anti_shuffle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi\"), expected: \"Hi\" },\n     { actual: candidate(\"hello\"), expected: \"ehllo\" },\n     { actual: candidate(\"number\"), expected: \"bemnru\" },\n     { actual: candidate(\"abcd\"), expected: \"abcd\" },\n     { actual: candidate(\"Hello World!!!\"), expected: \"Hello !!!Wdlor\" },\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"Hi. My name is Mister Robot. How are you?\"), expected: \".Hi My aemn is Meirst .Rboot How aer ?ouy\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_87","nl":"kmb_Latn","pl":"go_test.go","prompt":"package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O jipondo ja ku kamena, a ji soneka mu ukexilu uemana.\/\/Di sokejeke kiambote mu ididi ia tokala.\/\/O jipondo joso ja moneka, ja lungu ni ikoka.\/\/ni ku soneka o ima mu mukanda, [(x1, y1), (x2, y2) ...] kala ki tua tange kiá ku dimatekenu \/\/Mu kifika, se tu sanga o kijimbuete lst ni kijimbuete x, tua-nda sanga o kijimbuete x mu mbandu iambe, \/\/o milongi ioso iala ni ji mbandu javulu.\/\/O ukexilu iú ua difu ni ukexilu ua ku kondala o ji matádi, maji o ukexilu uâ ua difu.\/\/O milongi i tua-nda di longa, ia-nda kala kála mukanda u tu bhana itendelesu i tu kuatekesa ku mona o ima mu ukexilu uambote.\/\/ >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n\/\/ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n\/\/ >>> get_row([][]int{}, 1)\n\/\/ [][]interface{}{}\n\/\/ >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n\/\/ [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n","canonical_solution":"package get_row_test\n\nimport (\n\t\"sort\"\n)\n\nfunc get_row(lst [][]int, x int) [][]interface{} {\n\tvar result [][]interface{}\n\n\tfor i, row := range lst {\n\t\tvar temp []interface{}\n\t\tfor j, value := range row {\n\t\t\tif value == x {\n\t\t\t\ttemp = append(temp, []interface{}{i, j})\n\t\t\t}\n\t\t}\n\t\t\/\/ Sort columns in descending order for the current row\n\t\tsort.Slice(temp, func(a, b int) bool {\n\t\t\treturn temp[a].([]interface{})[1].(int) > temp[b].([]interface{})[1].(int)\n\t\t})\n\t\tresult = append(result, temp...)\n\t}\n\n\t\/\/ result is already sorted by rows since we've traversed `lst` row by row\n\treturn result\n}","tests":"func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_88","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/* kana ku lungulula o milongi i ua mu di longa. \/\/[Tanga mu luji]\/\/Se o kijimbuete ((primeval value, last index value) ki moneka, o kijimbuete kia kaiiadi ki moneka ué.\/\/Eie u sola o kijimbuete kia mukuá ki ua mesena o ku sanga mu kaxa, mu ku bandekesa o kijimbuete kiki.\/\/Mu ku bhana o kijimbuete kia kijimbuete kia-nda londekesa o mbandu ia kijimbuete kia mukuá, mu ku suluka soneka o kijimbuete kia mukuá.\/\/ >>> sort_array([]int{})\n\/\/ []int{}\n\/\/ >>> sort_array([]int{5})\n\/\/ []int{5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n\/\/ []int{0, 1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n\/\/ []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return append([]int{}, array...)\n    }\n\n    result := append([]int{}, array...) \/\/ Copy the array to avoid mutating the input\n    if (result[0]+result[len(result)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(result))) \/\/ Sort in descending order\n    } else {\n        sort.Ints(result) \/\/ Sort in ascending order\n    }\n\n    return result\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_89","nl":"kmb_Latn","pl":"go_test.go","prompt":"package encrypt_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O ku uana o jimbandu, ku lombolola kuila o jimbandu ja ku uana o jimbandu, ia-nda kala imoxi.\/\/O ukexilu ua jiletala ja Hebalaiku, ulondekesa kuila, o izuelu iala mu jiletala ja Hebalaiku, ia tokala i kala kála kia soneka o jiletala ja Hebalaiku.\/\/ua mu vutuila o kizuelu \"kima kimoxi ngó\" mu ukexilu uéngi.\/\/Bhanga o kijimbuete ki ua mesena mu mbandu ia kijimbuete, mu kusoneka o kijimbuete kiki mu mbandu ia kijimbuete.\/\/ >>> encrypt(\"hi\")\n\/\/ \"lm\"\n\/\/ >>> encrypt(\"asdfghjkl\")\n\/\/ \"ewhjklnop\"\n\/\/ >>> encrypt(\"gf\")\n\/\/ \"kj\"\n\/\/ >>> encrypt(\"et\")\n\/\/ \"ix\"\nfunc encrypt(s string) string {\n","canonical_solution":"func encrypt(s string) string {\n    result := []rune(s)\n    for i, char := range result {\n        if char >= 'a' && char <= 'z' {\n            result[i] = 'a' + (char-'a'+4)%26\n        } else if char >= 'A' && char <= 'Z' {\n            result[i] = 'A' + (char-'A'+4)%26\n        }\n    }\n    return string(result)\n}","tests":"func TestEncrypt(t *testing.T) {\n  candidate := encrypt\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"hi\"), expected: \"lm\" },\n     { actual: candidate(\"asdfghjkl\"), expected: \"ewhjklnop\" },\n     { actual: candidate(\"gf\"), expected: \"kj\" },\n     { actual: candidate(\"et\"), expected: \"ix\" },\n     { actual: candidate(\"faewfawefaewg\"), expected: \"jeiajeaijeiak\" },\n     { actual: candidate(\"hellomyfriend\"), expected: \"lippsqcjvmirh\" },\n     { actual: candidate(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), expected: \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" },\n     { actual: candidate(\"a\"), expected: \"e\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_91","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O jimbandu ja izuelu a ji uanuna mu \"\", \"?\" mba \"!\" \/\/O kizuelu ku \"bhekela\" mu dimi dia Hebalaiku, kilombolola \"ku divua kiambote\".\/\/Ua-nda tambula izuelu iavulu, mu ku suluka ua-nda sola o izuelu ia tokala.\/\/ >>> is_bored(\"Hello world\")\n\/\/ 0\n\/\/ >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n\/\/ 1\nfunc is_bored(S string) int {\n","canonical_solution":"package is_bored_test\n\nimport (\n    \"strings\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_bored(S string) int {\n    sentences := strings.FieldsFunc(S, func(r rune) bool {\n        return r == '.' || r == '?' || r == '!'\n    })\n    count := 0\n    for _, sentence := range sentences {\n        trimmed := strings.TrimSpace(sentence)\n        if strings.HasPrefix(trimmed, \"I \") {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestIsBored(t *testing.T) {\n    tests := []struct {\n        input string\n        want  int\n    }{\n        {\"Hello world\", 0},\n        {\"The sky is blue. The sun is shining. I love this weather\", 1},\n        {\"I am here. I am there. I am everywhere\", 3},\n        {\"What's up? Are you ok? Yes, I am!\", 1},\n        {\"\", 0},\n        {\"I.\", 1},\n        {\"I! am excited. I? am curious\", 2},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"is_bored(%q)\", tt.input), func(t *testing.T) {\n            got := is_bored(tt.input)\n            if got != tt.want {\n                t.Errorf(\"got %d, want %d\", got, tt.want)\n            }\n        })\n    }\n}","tests":"func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"), expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual: candidate(\"I feel good today. I will be productive. will kill It\"), expected: 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_92","nl":"kmb_Latn","pl":"go_test.go","prompt":"package any_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/O ku sanga o kitambuijilu kia kibhuidisu kiki, kia-nda tu kuatekesa kuijiia se tua mu zuela o kidi mba kana.\/\/O ku sanga o ikoka iiadi íii, i tu kuatekesa kuijiia kuila o ikoka iiadi íii, ia difu, mu kiki, o ikoka iiadi íii mu ku bhita kithangana, i di sokejeka.\/\/Xisa o ikoka iala ni ijimbuete itatu.\/\/ >>> any_int(5, 2, 7)\n\/\/ true\n\/\/ >>> any_int(3, 2, 2)\n\/\/ false\n\/\/ >>> any_int(3, -2, 1)\n\/\/ true\n\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/ false\nfunc any_int(x float64, y float64, z float64) bool {\n","canonical_solution":"package any_int_test\n\nimport (\n    \"testing\"\n)\n\nfunc any_int(x float64, y float64, z float64) bool {\n    \/\/ Check if x, y, and z are integers\n    if x != float64(int(x)) || y != float64(int(y)) || z != float64(int(z)) {\n        return false\n    }\n\n    \/\/ Check if one of the numbers is the sum of the other two\n    if x == y+z || y == x+z || z == x+y {\n        return true\n    }\n\n    return false\n}\n\nfunc TestAnyInt(t *testing.T) {\n    if !any_int(5, 2, 7) {\n        t.Errorf(\"Expected true for any_int(5, 2, 7)\")\n    }\n    if any_int(3, 2, 2) {\n        t.Errorf(\"Expected false for any_int(3, 2, 2)\")\n    }\n    if !any_int(3, -2, 1) {\n        t.Errorf(\"Expected true for any_int(3, -2, 1)\")\n    }\n    if any_int(3.6, -2.2, 2) {\n        t.Errorf(\"Expected false for any_int(3.6, -2.2, 2)\")\n    }\n}","tests":"func TestAny_Int(t *testing.T) {\n  candidate := any_int\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 3, 1), expected: true },\n     { actual: candidate(2.5, 2, 3), expected: false },\n     { actual: candidate(1.5, 5, 3.5), expected: false },\n     { actual: candidate(2, 6, 2), expected: false },\n     { actual: candidate(4, 2, 2), expected: true },\n     { actual: candidate(2.2, 2.2, 2.2), expected: false },\n     { actual: candidate(-4, 6, 2), expected: true },\n     { actual: candidate(2, 1, 1), expected: true },\n     { actual: candidate(3, 4, 7), expected: true },\n     { actual: candidate(3.0, 4, 7), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_93","nl":"kmb_Latn","pl":"go_test.go","prompt":"package encode_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O Bibidia ia ubhe mu dimi dia Kingileji a i lungulula kiambote.\/\/O kizuelu \"muzeletete\" mu dimi dia Kingileji kilombolola \"ku bata\".\/\/O njimbu iala ni kijimbuete kiki, iala ku pholo iê .\/\/O ukexilu ua jiletala ja soneka na-ju o athu, u bhingana o ukexilu ua jiletala ja soneka na-ju o athu.\/\/Soneka o ifua íii, phala ku i soneka mu ukexilu u bhana dingi nguzu.\/\/ >>> encode(\"test\")\n\/\/ \"TGST\"\n\/\/ >>> encode(\"This is a message\")\n\/\/ \"tHKS KS C MGSSCGG\"\nfunc encode(message string) string {\n","canonical_solution":"package encode_test\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc encode(message string) string {\n\tvar encodedMessage strings.Builder\n\n\t\/\/ Mapping of vowels to the letter appearing 2 places ahead\n\tvowelReplacement := map[rune]rune{\n\t\t'a': 'c',\n\t\t'A': 'C',\n\t\t'e': 'g',\n\t\t'E': 'G',\n\t\t'i': 'k',\n\t\t'I': 'K',\n\t\t'o': 'q',\n\t\t'O': 'Q',\n\t\t'u': 'w',\n\t\t'U': 'W',\n\t}\n\n\tfor _, char := range message {\n\t\tif unicode.IsLetter(char) {\n\t\t\t\/\/ Swap case of the character\n\t\t\tif unicode.IsUpper(char) {\n\t\t\t\tchar = unicode.ToLower(char)\n\t\t\t} else {\n\t\t\t\tchar = unicode.ToUpper(char)\n\t\t\t}\n\n\t\t\t\/\/ Replace vowel if the character is a vowel\n\t\t\tif replacement, isVowel := vowelReplacement[char]; isVowel {\n\t\t\t\tchar = replacement\n\t\t\t}\n\t\t}\n\n\t\tencodedMessage.WriteRune(char)\n\t}\n\n\treturn encodedMessage.String()\n}","tests":"func TestEncode(t *testing.T) {\n  candidate := encode\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"TEST\"), expected: \"tgst\" },\n     { actual: candidate(\"Mudasir\"), expected: \"mWDCSKR\" },\n     { actual: candidate(\"YES\"), expected: \"ygs\" },\n     { actual: candidate(\"This is a message\"), expected: \"tHKS KS C MGSSCGG\" },\n     { actual: candidate(\"I DoNt KnOw WhAt tO WrItE\"), expected: \"k dQnT kNqW wHcT Tq wRkTg\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_94","nl":"kmb_Latn","pl":"go_test.go","prompt":"package skjkasdkd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/Eie ua tokala u sota o kijimbuete kia dikota, anga u soneka o kijimbuete kia tokala.\/\/A ku bhana o milongi ia lungu ni ijimbuete ioso.\/\/ >>> skjkasdkd([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n\/\/ 10\n\/\/ >>> skjkasdkd([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n\/\/ 25\n\/\/ >>> skjkasdkd([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n\/\/ 13\n\/\/ >>> skjkasdkd([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n\/\/ 11\n\/\/ >>> skjkasdkd([]int{0, 81, 12, 3, 1, 21})\n\/\/ 3\n\/\/ >>> skjkasdkd([]int{0, 8, 1, 2, 1, 7})\n\/\/ 7\nfunc skjkasdkd(lst []int) int {\n","canonical_solution":"package skjkasdkd_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to check if a number is prime\nfunc isPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\/\/ Function to calculate the sum of digits of a number\nfunc sumOfDigits(n int) int {\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\n\/\/ Function to find the largest prime and return the sum of its digits\nfunc skjkasdkd(lst []int) int {\n\tmaxPrime := -1\n\tfor _, num := range lst {\n\t\tif isPrime(num) && num > maxPrime {\n\t\t\tmaxPrime = num\n\t\t}\n\t}\n\tif maxPrime == -1 {\n\t\treturn 0\n\t}\n\treturn sumOfDigits(maxPrime)\n}\n\nfunc TestSkjkasdkd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}, 10},\n\t\t{[]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}, 25},\n\t\t{[]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}, 13},\n\t\t{[]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}, 11},\n\t\t{[]int{0, 81, 12, 3, 1, 21}, 3},\n\t\t{[]int{0, 8, 1, 2, 1, 7}, 7},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tresult := skjkasdkd(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"got %v, want %v\", result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestSkjkasdkd(t *testing.T) {\n  candidate := skjkasdkd\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}), expected: 10 },\n     { actual: candidate([]int{1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), expected: 25 },\n     { actual: candidate([]int{1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), expected: 13 },\n     { actual: candidate([]int{0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), expected: 11 },\n     { actual: candidate([]int{0, 81, 12, 3, 1, 21}), expected: 3 },\n     { actual: candidate([]int{0, 8, 1, 2, 1, 7}), expected: 7 },\n     { actual: candidate([]int{8191}), expected: 19 },\n     { actual: candidate([]int{8191, 123456, 127, 7}), expected: 19 },\n     { actual: candidate([]int{127, 97, 8192}), expected: 10 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_95","nl":"kmb_Latn","pl":"go_test.go","prompt":"package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O mbandu ia kijimbuete kia ku bhana, a i lungulula.\/\/O kijimbuete kia dikota, ki tena kulombolola kima kioso-kioso, ki kale kijimbuete kia dikota mba kiofele.\/\/O ku soneka o ima mu ididi ioso, ku bhinga ku soneka ngó o ima ia beta-kota, se o jivelusu joso jala ni izuelu ia katunda.\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"b\": \"banana\"})\n\/\/ true\n\/\/ >>> check_dict_case(map[string]string{\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[interface{}]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n\/\/ false\n\/\/ >>> check_dict_case(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"})\n\/\/ true\nfunc check_dict_case(dict map[string]string) bool {\n","canonical_solution":"func check_dict_case(dict map[string]string) bool {\n    if len(dict) == 0 {\n        return false\n    }\n\n    var allLowercase, allUppercase bool\n    for k := range dict {\n        if k != strings.ToLower(k) && k != strings.ToUpper(k) {\n            return false\n        }\n        if k == strings.ToLower(k) {\n            if allUppercase {\n                return false\n            }\n            allLowercase = true\n        }\n        if k == strings.ToUpper(k) {\n            if allLowercase {\n                return false\n            }\n            allUppercase = true\n        }\n    }\n\n    return allLowercase || allUppercase\n}","tests":"func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_96","nl":"kmb_Latn","pl":"go_test.go","prompt":"package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O ibuka ioso íii, iala ni ijimbuete iofele, maji o ibuka ia beta-kota, iala ngó ni ijimbuete iofele.\/\/Xinda o mbandu ia kijimbuete ki ua mesena kusanga mu mbandu ia kijimbuete kia mukuá, phala kusanga o mbandu ia kijimbuete kia dianga.\/\/ >>> count_up_to(5)\n\/\/ []int{2, 3}\n\/\/ >>> count_up_to(11)\n\/\/ []int{2, 3, 5, 7}\n\/\/ >>> count_up_to(0)\n\/\/ []int{}\n\/\/ >>> count_up_to(20)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17, 19}\n\/\/ >>> count_up_to(1)\n\/\/ []int{}\n\/\/ >>> count_up_to(18)\n\/\/ []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int) []int {\n","canonical_solution":"func count_up_to(n int) []int {\n\tprimes := []int{}\n\tfor num := 2; num < n; num++ {\n\t\tif isPrime(num) {\n\t\t\tprimes = append(primes, num)\n\t\t}\n\t}\n\treturn primes\n}\n\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= num; i++ {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_97","nl":"kmb_Latn","pl":"go_test.go","prompt":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O ima i tu zuela, i kuatekesa o muthu ku kala ni ibanzelu iambote.\/\/o mbandu ia kijimbuete kia muxi. \/\/Xinda o mbandu ia kijimbuete, phala kusanga o kijimbuete kia tokala.\/\/ >>> multiply(148, 412)\n\/\/ 16\n\/\/ >>> multiply(19, 28)\n\/\/ 72\n\/\/ >>> multiply(2020, 1851)\n\/\/ 0\n\/\/ >>> multiply(14, -15)\n\/\/ 20\nfunc multiply(a int, b int) int {\n","canonical_solution":"package multiply_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Complete the function that takes two integers and returns \n\/\/ the product of their unit digits.\n\/\/ Assume the input is always valid.\nfunc multiply(a int, b int) int {\n    unitA := abs(a) % 10\n    unitB := abs(b) % 10\n    return unitA * unitB\n}\n\nfunc abs(n int) int {\n    if n < 0 {\n        return -n\n    }\n    return n\n}\n\nfunc TestMultiply(t *testing.T) {\n    fmt.Println(multiply(148, 412)) \/\/ 16\n    fmt.Println(multiply(19, 28))   \/\/ 72\n    fmt.Println(multiply(2020, 1851)) \/\/ 0\n    fmt.Println(multiply(14, -15))  \/\/ 20\n}","tests":"func TestMultiply(t *testing.T) {\n  candidate := multiply\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(148, 412), expected: 16 },\n     { actual: candidate(19, 28), expected: 72 },\n     { actual: candidate(2020, 1851), expected: 0 },\n     { actual: candidate(14, -15), expected: 20 },\n     { actual: candidate(76, 67), expected: 42 },\n     { actual: candidate(17, 27), expected: 49 },\n     { actual: candidate(0, 1), expected: 0 },\n     { actual: candidate(0, 0), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_98","nl":"kmb_Latn","pl":"go_test.go","prompt":"package count_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Mu ku tala o ndunge ia mu bhana, soneka o ji velusu ja beta-kota mu mukanda.\/\/ >>> count_upper(\"aBCdEf\")\n\/\/ 1\n\/\/ >>> count_upper(\"abcdefg\")\n\/\/ 0\n\/\/ >>> count_upper(\"dBBE\")\n\/\/ 0\nfunc count_upper(s string) int {\n","canonical_solution":"package count_upper_test\n\nimport (\n    \"testing\"\n)\n\nfunc count_upper(s string) int {\n    uppercaseVowels := \"AEIOU\"\n    count := 0\n    \n    for i := 0; i < len(s); i += 2 {\n        if contains(uppercaseVowels, s[i]) {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfunc contains(vowels string, ch byte) bool {\n    for i := 0; i < len(vowels); i++ {\n        if vowels[i] == ch {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestCountUpper(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected int\n    }{\n        {\"aBCdEf\", 1},\n        {\"abcdefg\", 0},\n        {\"dBBE\", 0},\n    }\n\n    for _, test := range tests {\n        result := count_upper(test.input)\n        if result != test.expected {\n            t.Errorf(\"For input '%s', expected %d but got %d\", test.input, test.expected, result)\n        }\n    }\n}","tests":"func TestCount_Upper(t *testing.T) {\n  candidate := count_upper\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"aBCdEf\"), expected: 1 },\n     { actual: candidate(\"abcdefg\"), expected: 0 },\n     { actual: candidate(\"dBBE\"), expected: 0 },\n     { actual: candidate(\"B\"), expected: 0 },\n     { actual: candidate(\"U\"), expected: 1 },\n     { actual: candidate(\"\"), expected: 0 },\n     { actual: candidate(\"EEEE\"), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_99","nl":"kmb_Latn","pl":"go_test.go","prompt":"package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/O ku katula o kathombo ku jivelusu jiiadi jiji, kua-nda ku katula o zero.\/\/Se o kijimbuete kia mukuá kia beta kota, o kijimbuete kia mukuá kia beta kota, kia-nda tu kuatekesa kusanga o kijimbuete kia mukuá kia beta kota.\/\/Sokejeka o ima phala kulondekesa o kijimbuete kia mukuá.\/\/ >>> closest_integer(\"10\")\n\/\/ 10\n\/\/ >>> closest_integer(\"15.3\")\n\/\/ 15\n\/\/ Note:\n\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/ from two integers, the one you should return is the one that is the\n\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfunc closest_integer(value string) int {\n","canonical_solution":"package closest_integer_test\n\nimport (\n\t\"strconv\"\n\t\"math\"\n)\n\nfunc closest_integer(value string) int {\n\tnum, err := strconv.ParseFloat(value, 64)\n\tif err != nil {\n\t\treturn 0 \/\/ handle error appropriately in real scenarios\n\t}\n\tif num > 0 {\n\t\treturn int(math.Ceil(num - 0.5))\n\t}\n\treturn int(math.Floor(num + 0.5))\n}","tests":"func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_100","nl":"kmb_Latn","pl":"go_test.go","prompt":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/i ilombolola o jimbandu ja matadi (i+1). \/\/O kijimbuete kiki, ki bhana ue idimbu ia matadi ala mu ididi ioso mua soneka o athu, mu ukexilu ua kijimbuete \/\/- o muxinda ua mukuá se n ua kidi. \/\/- o kijimbuete kia mukuá, se o kijimbuete kia n ki moneka. \/\/O jimbandu ja ku dima ja matadi, ja-nda kala kiki:\/\/O mbandu ia dianga ia kiteka, iala ni \"matadi\".\/\/Se tu bhana o muxinda ua kidifua n, tua-nda bhanga tu matadi a tenena n.\/\/ >>> make_a_pile(3)\n\/\/ []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n","canonical_solution":"package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc make_a_pile(n int) []int {\n    pile := make([]int, n)\n    currentStones := n\n\n    for i := 0; i < n; i++ {\n        pile[i] = currentStones\n        if n%2 == 0 {\n            currentStones += 2\n        } else {\n            currentStones += 2\n        }\n    }\n\n    return pile\n}\n\nfunc TestMakeAPile(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected []int\n    }{\n        {3, []int{3, 5, 7}},\n        {4, []int{4, 6, 8, 10}},\n        {1, []int{1}},\n        {5, []int{5, 7, 9, 11, 13}},\n    }\n\n    for _, c := range cases {\n        res := make_a_pile(c.input)\n        if fmt.Sprintf(\"%v\", res) != fmt.Sprintf(\"%v\", c.expected) {\n            t.Errorf(\"make_a_pile(%d) == %v, expected %v\", c.input, res, c.expected)\n        }\n    }\n}","tests":"func TestMake_A_Pile(t *testing.T) {\n  candidate := make_a_pile\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{3, 5, 7} },\n     { actual: candidate(4), expected: []int{4, 6, 8, 10} },\n     { actual: candidate(5), expected: []int{5, 7, 9, 11, 13} },\n     { actual: candidate(6), expected: []int{6, 8, 10, 12, 14, 16} },\n     { actual: candidate(8), expected: []int{8, 10, 12, 14, 16, 18, 20, 22} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_101","nl":"kmb_Latn","pl":"go_test.go","prompt":"package words_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Phala ku jimbulula o kizuelu \"ku\", soneka-mu o izuelu ia dianga.\/\/O mbandu íii ia-nda ku bhana milongi ia-nda ku kuatekesa ku lungulula o ukexilu uê ua kuzuela.\/\/ >>> words_string(\"Hi, my name is John\")\n\/\/ []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n\/\/ >>> words_string(\"One, two, three, four, five, six\")\n\/\/ []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}\nfunc words_string(s string) []string {\n","canonical_solution":"package words_string_test\n\nimport (\n    \"testing\"\n    \"strings\"\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc words_string(s string) []string {\n    re := regexp.MustCompile(`[,\\s]+`)\n    return re.Split(s, -1)\n}\n\nfunc TestWordsString(t *testing.T) {\n    tests := []struct{\n        input string\n        expected []string\n    }{\n        {\"Hi, my name is John\", []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"}},\n        {\"One, two, three, four, five, six\", []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"}},\n        {\"a,b,c\", []string{\"a\", \"b\", \"c\"}},\n        {\"hello world\", []string{\"hello\", \"world\"}},\n    }\n\n    for _, test := range tests {\n        result := words_string(test.input)\n        if !equal(result, test.expected) {\n            t.Errorf(\"Expected %v, but got %v\", test.expected, result)\n        }\n    }\n}\n\nfunc equal(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestWords_String(t *testing.T) {\n  candidate := words_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Hi, my name is John\"), expected: []string{\"Hi\", \"my\", \"name\", \"is\", \"John\"} },\n     { actual: candidate(\"One, two, three, four, five, six\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"Hi, my name\"), expected: []string{\"Hi\", \"my\", \"name\"} },\n     { actual: candidate(\"One,, two, three, four, five, six,\"), expected: []string{\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"} },\n     { actual: candidate(\"\"), expected: []string{} },\n     { actual: candidate(\"ahmed     , gamal\"), expected: []string{\"ahmed\", \"gamal\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_102","nl":"kmb_Latn","pl":"go_test.go","prompt":"package choose_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Se o muxinda ki u difu, o mbandu ia kijimbuete i moneka ku mbandu ia kaxa, ia tokala i kala -1.\/\/O kijimbuete kia beta-o-kota, kiala mu muxinda [x, y].\/\/O mbandu íii, ia-nda londekesa o ima iiadi íii, x ni y.\/\/ >>> choose_num(12, 15)\n\/\/ 14\n\/\/ >>> choose_num(13, 12)\n\/\/ -1\nfunc choose_num(x int, y int) int {\n","canonical_solution":"func choose_num(x int, y int) int {\n\tif x > y {\n\t\treturn -1\n\t}\n\t\/\/ Start from y and move backwards looking for the largest even number\n\tfor i := y; i >= x; i-- {\n\t\tif i%2 == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc TestChooseNum(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, expected int\n\t}{\n\t\t{12, 15, 14},\n\t\t{13, 12, -1},\n\t\t{4, 10, 10},\n\t\t{5, 5, -1},\n\t\t{6, 6, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"x=%d_y=%d\", test.x, test.y), func(t *testing.T) {\n\t\t\tresult := choose_num(test.x, test.y)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For choose_num(%d, %d), expected %d, but got %d\", test.x, test.y, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestChoose_Num(t *testing.T) {\n  candidate := choose_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(12, 15), expected: 14 },\n     { actual: candidate(13, 12), expected: -1 },\n     { actual: candidate(33, 12354), expected: 12354 },\n     { actual: candidate(5234, 5233), expected: -1 },\n     { actual: candidate(6, 29), expected: 28 },\n     { actual: candidate(27, 10), expected: -1 },\n     { actual: candidate(7, 7), expected: -1 },\n     { actual: candidate(546, 546), expected: 546 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_104","nl":"kmb_Latn","pl":"go_test.go","prompt":"package unique_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O majina a tokala ku i soneka mu ukexilu ua ku bandekesa o kima ki ua mesena.\/\/O mbandu ia kijimbuete kiki, ki iala ni ijimbuete ia kidi.\/\/Mu ku bhana o mbandu ia kijimbuete, x, tu sanga-mu o kijimbuete ki ua solo.\/\/ >>> unique_digits([]int{15, 33, 1422, 1})\n\/\/ []int{1, 15, 33}\n\/\/ >>> unique_digits([]int{152, 323, 1422, 10})\n\/\/ []int{}\nfunc unique_digits(x []int) []int {\n","canonical_solution":"package unique_digits_test\n\nimport (\n    \"sort\"\n)\n\n\/\/ unique_digits returns a sorted list of all elements that don't have any even digit.\nfunc unique_digits(x []int) []int {\n    result := []int{}\n    for _, num := range x {\n        if hasEvenDigit(num) == false {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}\n\n\/\/ hasEvenDigit checks if a given number contains any even digit.\nfunc hasEvenDigit(num int) bool {\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            return true\n        }\n        num \/= 10\n    }\n    return false\n}","tests":"func TestUnique_Digits(t *testing.T) {\n  candidate := unique_digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{15, 33, 1422, 1}), expected: []int{1, 15, 33} },\n     { actual: candidate([]int{152, 323, 1422, 10}), expected: []int{} },\n     { actual: candidate([]int{12345, 2033, 111, 151}), expected: []int{111, 151} },\n     { actual: candidate([]int{135, 103, 31}), expected: []int{31, 135} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_105","nl":"kmb_Latn","pl":"go_test.go","prompt":"package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O kijimbuete kia dianga, kia kaiiadi, kia katatu, kia kauana, kia kasamanu, kia sambuadi, kia dinake, ni kia divua.\/\/Mu kusuka-ku, u bhinganesa o jiletala joso ni majina mâ, mu ku a soneka mu ukexilu uéngi.\/\/Mu ku tala o ji-ijimbuete, sola o ji-ijimbuete ji tua-nda sanga mu kaxa, mu ku suluka soneka-mu o ji-ijimbuete ji tua-nda sanga mu kaxa.\/\/ >>> by_length([]int{2, 1, 1, 4, 5, 8, 2, 3})\n\/\/ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\/\/ If the list is empty, return an empty list:\n\/\/ >>> by_length([]int{})\n\/\/ []string{}\n\/\/ If the list has any strange number ignore it:\n\/\/ >>> by_length([]int{1, -1, 55})\n\/\/ []string{\"One\"}\nfunc by_length(arr []int) []string {\n","canonical_solution":"package by_length_test\n\nimport (\n    \"testing\"\n    \"sort\"\n)\n\nfunc by_length(arr []int) []string {\n    \/\/ Filter numbers between 1 and 9\n    filtered := []int{}\n    for _, num := range arr {\n        if num >= 1 && num <= 9 {\n            filtered = append(filtered, num)\n        }\n    }\n\n    \/\/ Sort in ascending order\n    sort.Ints(filtered)\n\n    \/\/ Reverse the sorted slice\n    for i, j := 0, len(filtered)-1; i < j; i, j = i+1, j-1 {\n        filtered[i], filtered[j] = filtered[j], filtered[i]\n    }\n\n    \/\/ Map numbers to their corresponding names\n    numToString := map[int]string{\n        1: \"One\", 2: \"Two\", 3: \"Three\",\n        4: \"Four\", 5: \"Five\", 6: \"Six\",\n        7: \"Seven\", 8: \"Eight\", 9: \"Nine\",\n    }\n\n    \/\/ Create the result slice with names\n    result := []string{}\n    for _, num := range filtered {\n        result = append(result, numToString[num])\n    }\n\n    return result\n}\n\nfunc TestByLength(t *testing.T) {\n    tests := []struct {\n        input []int\n        want  []string\n    }{\n        {[]int{2, 1, 1, 4, 5, 8, 2, 3}, []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}},\n        {[]int{}, []string{}},\n        {[]int{1, -1, 55}, []string{\"One\"}},\n    }\n\n    for _, test := range tests {\n        t.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n            got := by_length(test.input)\n            if !equals(got, test.want) {\n                t.Errorf(\"got = %v; want %v\", got, test.want)\n            }\n        })\n    }\n}\n\nfunc equals(a, b []string) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}","tests":"func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_106","nl":"kmb_Latn","pl":"go_test.go","prompt":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O mbandu i, ilombolola o maukexilu a tu sanga mu divulu didi.\/\/i mateka ku 1.\/\/mba o muxinda ua jiveji ja 1 ndu ia i. \/\/O kijimbuete kia tokala phala o kijimbuete kia i, o kijimbuete kia i, se o kijimbuete kia i, kia di bandekesa ni di bandekesa, o kijimbuete kia i, se o kijimbuete kia i, kia di bandekesa ni di bandekesa, o kijimbuete kia i, se o kijimbuete kia i, kia di bandekesa ni di bandekesa, o kijimbuete kia i, kia di bandekesa ué.\/\/Xisa o mbandu ia kifika, phala kusanga o kijimbuete kia tokala, soneka o kijimbuete kia mukuá ku mbandu ia kifika.\/\/ >>> f(5)\n\/\/ []int{1, 2, 6, 24, 15}\nfunc f(n int) []int {\n","canonical_solution":"package f_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc f(n int) []int {\n    result := make([]int, n)\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            result[i-1] = factorial(i)\n        } else {\n            result[i-1] = sum(i)\n        }\n    }\n    return result\n}\n\nfunc factorial(num int) int {\n    if num <= 1 {\n        return 1\n    }\n    return num * factorial(num-1)\n}\n\nfunc sum(num int) int {\n    s := 0\n    for i := 1; i <= num; i++ {\n        s += i\n    }\n    return s\n}\n\nfunc TestF(t *testing.T) {\n    expected := []int{1, 2, 6, 24, 15}\n    result := f(5)\n    if !equals(expected, result) {\n        t.Errorf(\"Expected %v, got %v\", expected, result)\n    }\n}\n\nfunc equals(a, b []int) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if a[i] != b[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(f(5)) \/\/ Output: []int{1, 2, 6, 24, 15}\n}","tests":"func TestF(t *testing.T) {\n  candidate := f\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{1, 2, 6, 24, 15} },\n     { actual: candidate(7), expected: []int{1, 2, 6, 24, 15, 720, 28} },\n     { actual: candidate(1), expected: []int{1} },\n     { actual: candidate(3), expected: []int{1, 2, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_107","nl":"kmb_Latn","pl":"go_test.go","prompt":"package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia 1: \/\/palindromo ia dikota, iala bhu kaxi ka jivelusu ((1, n), ni jivelusu ja mukuá. \/\/Mu ku bhana o kijimbuete kia mutokala ua kidi, soneka-mu o kijimbuete kia mutokala ua kidi ni kijimbuete kia kijimbuete kia muxinda.\/\/ >>> even_odd_palindrome(3)\n\/\/ []interface{}{1, 2}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/ Example 2:\n\/\/ >>> even_odd_palindrome(12)\n\/\/ []interface{}{4, 6}\n\/\/ Explanation:\n\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/ Note:\n\/\/ 1. 1 <= n <= 10^3\n\/\/ 2. returned list has the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n int) []interface{} {\n","canonical_solution":"func isPalindrome(num int) bool {\n    original := num\n    reversed := 0\n    for num > 0 {\n        reversed = reversed*10 + num%10\n        num \/= 10\n    }\n    return original == reversed\n}\n\nfunc even_odd_palindrome(n int) []interface{} {\n    evenCount, oddCount := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n}","tests":"func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8, 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     { actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63), expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5, 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     { actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1), expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_108","nl":"kmb_Latn","pl":"go_test.go","prompt":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika, o kijimbuete -123 kiala ni ijimbuete -1, 2 ni 3.\/\/Se o dijitu dia dianga dia kijimbuete a di soneka ni \"k\" a di soneka ni \"k\", mu veji dia \"k\", kala ki tua-nda mona.\/\/o ima ioso mu mukanda iú, a i soneka mu ukexilu umoxi.\/\/Soneka o mbandu count_nums i tambula o ijimbuete ioso, anga i vutula \/\/ >>> count_nums([]int{})\n\/\/ 0\n\/\/ >>> count_nums([]int{-1, 11, -11})\n\/\/ 1\n\/\/ >>> count_nums([]int{1, 1, 2})\n\/\/ 3\nfunc count_nums(arr []int) int {\n","canonical_solution":"package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        digits := num\n        sum := 0\n\n        if digits < 0 {\n            sum = digits % 10\n            digits = -digits \/ 10\n        }\n\n        for digits > 0 {\n            sum += digits % 10\n            digits \/= 10\n        }\n\n        if sum > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCountNums(t *testing.T) {\n    testCases := []struct {\n        input    []int\n        expected int\n    }{\n        {[]int{}, 0},\n        {[]int{-1, 11, -11}, 1},\n        {[]int{1, 1, 2}, 3},\n    }\n\n    for _, tc := range testCases {\n        result := count_nums(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"Expected %v, got %v\", tc.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(count_nums([]int{-1, 11, -11})) \/\/ Output: 1\n    fmt.Println(count_nums([]int{1, 1, 2}))    \/\/ Output: 3\n}","tests":"func TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_109","nl":"kmb_Latn","pl":"go_test.go","prompt":"package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O milongi íii, ki i difu ni milongi ia mukuá.\/\/Se o mbandu ia kijimbuete kia ku bhana, ki iala-mu, mu veji dia kiki, o kijimbuete kia tokala, o mbandu true.\/\/O kuila o ku lungulula o ibanzelu ietu kua-nda tu kuatekesa ku tendela kiambote o maka enhá?\/\/Se o kijimbuete ki ua-nda sanga-mu, a tena ku ki sanga mu maukexilu oso \/\/O kididi kia dianga ku mukanda, o mbandu ia 10.\/\/O mbandu ia sukina mu kaxa, a-nda i lungulula mu mbandu ia mukuá, mu ku i ta mu kididi kia tokala.\/\/O ku bhilula o mbandu ia kiasu, kulombolola ku bhilula o mbandu ia kaxa, mu mbandu ia kadilu.\/\/Eie u tena ku bhanga o ima íii, se u sola ku bhanga kiki.\/\/O kikalakalu kiki, a ki soneka mu mukanda: \/\/tu tena ku uanuna o milongi mu ukexilu ki u difu ni ku uanuna o milongi iokulu, mu ku bhanga kiki: \/\/O milongi ia-nda moneka ngó mu jimbandu, eie ua tokala kuijiia se:\/\/Tu sanga-mu o kijimbuete arr[1], arr[2], ..., arr[N]. O \/\/ >>> move_one_ball([]int{3, 4, 5, 1, 2})\n\/\/ true\n\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/ be achieved for the given list.\n\/\/ >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\/\/ false\n\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/ list by performing any number of right shift operations.\nfunc move_one_ball(arr []int) bool {\n","canonical_solution":"func move_one_ball(arr []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n    }\n\n    \/\/ Detect the point where the order breaks\n    countBreaks := 0\n    index := -1\n\n    for i := 0; i < n; i++ {\n        if arr[i] > arr[(i+1)%n] {\n            countBreaks++\n            index = i\n        }\n    }\n\n    \/\/ If there is at most one point where the order breaks\n    if countBreaks <= 1 {\n        return true\n    }\n\n    return false\n}","tests":"func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_110","nl":"kmb_Latn","pl":"go_test.go","prompt":"package exchange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Se kana, soneka \"Kana\". \/\/O kuila o ima ioso mu veji imoxi ia tokala ku kala ia kidi?\/\/O kuila o ima ia mukuá ia beta o kota, o ima ia mukuá ndenge?\/\/O ima ia beta-kota i tena ku bhanga o komputadolo ku ima ia mukuá ni ji komputadolo.\/\/O ku bhanga o mbandu ia dianga, kulondekesa kuila, o mbandu ia dianga ia lista, ia tokala ku kala ni ijimbuete iiadi.\/\/O ku bhanga kiki, kua-nda kuatekesa kuijiia se o ima ia mukuá ia beta o kota, o ku bhanga ngó o ima ia beta-o-kota.\/\/Mu kifika kiki, tua-nda mona se kiebhi ki tu tena ku bandekesa o muxinda ua jiveji ja mukuá mu veji imoxi, mu ku bandekesa o jiveji ja mukuá.\/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 2, 3, 4})\n\/\/ \"YES\"\n\/\/ >>> exchange([]int{1, 2, 3, 4}, []int{1, 5, 3, 4})\n\/\/ \"NO\"\n\/\/ It is assumed that the input lists will be non-empty.\nfunc exchange(lst1 []int, lst2 []int) string {\n","canonical_solution":"func exchange(lst1 []int, lst2 []int) string {\n    hasEvenInLst2 := false\n    \n    for _, num := range lst2 {\n        if num%2 == 0 {\n            hasEvenInLst2 = true\n            break\n        }\n    }\n    \n    if !hasEvenInLst2 {\n        return \"NO\"\n    }\n    \n    for _, num := range lst1 {\n        if num%2 != 0 {\n            return \"YES\"\n        }\n    }\n\n    return \"YES\"\n}","tests":"func TestExchange(t *testing.T) {\n  candidate := exchange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 2, 3, 4}), expected: \"YES\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{1, 5, 3, 4}), expected: \"NO\" },\n     { actual: candidate([]int{1, 2, 3, 4}, []int{2, 1, 4, 3}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 4}), expected: \"YES\" },\n     { actual: candidate([]int{5, 7, 3}, []int{2, 6, 3}), expected: \"NO\" },\n     { actual: candidate([]int{3, 2, 6, 1, 8, 9}, []int{3, 5, 5, 1, 1, 1}), expected: \"NO\" },\n     { actual: candidate([]int{100, 200}, []int{200, 200}), expected: \"YES\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_111","nl":"kmb_Latn","pl":"go_test.go","prompt":"package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Se o jiletala ji moneka veji javulu, soneka-ju kumoxi.\/\/O mukanda ua beta-o-kota mu ku u tanga, o mukanda ua beta-o-kota mu ku u tanga.\/\/O kijimbuete \"mapa\" kilombolola mbandu ia mapa ia mbandu ia kijimbuete.\/\/ >>> histogram(\"a b c\")\n\/\/ map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n\/\/ >>> histogram(\"a b b a\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"a b c a b\")\n\/\/ map[string]int{\"a\": 2, \"b\": 2}\n\/\/ >>> histogram(\"b b b b a\")\n\/\/ map[string]int{\"b\": 4}\n\/\/ >>> histogram(\"\")\n\/\/ map[string]int{}\nfunc histogram(test string) map[string]int {\n","canonical_solution":"package histogram_test\n\nimport (\n    \"strings\"\n)\n\nfunc histogram(test string) map[string]int {\n    if test == \"\" {\n        return map[string]int{}\n    }\n\n    counts := make(map[string]int)\n    words := strings.Fields(test)\n    \n    var maxCount int\n    for _, word := range words {\n        counts[word]++\n        if counts[word] > maxCount {\n            maxCount = counts[word]\n        }\n    }\n\n    result := make(map[string]int)\n    for key, count := range counts {\n        if count == maxCount {\n            result[key] = count\n        }\n    }\n\n    return result\n}","tests":"func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual: candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_112","nl":"kmb_Latn","pl":"go_test.go","prompt":"package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/Ua tokala u soneka mu mukanda ua ku soneka o ima ia tokala o ku bhanga, ni ia makutu, phala ku tonginina kiambote.\/\/O kizuelu kiki, kilombolola kuila, o ima ioso i tu mona, ki i difu.\/\/Mu kusuluka, tonginina se o kijimbuete kia filiiale kiene o kidi.\/\/Mu kifika, se tu sanga-mu kijimbuete, tua tokala kukatula-mu o kijimbuete \"s\" ni \"c\".\/\/Kikalakalu \/\/ >>> reverse_delete(\"abcde\", \"ae\")\n\/\/ []interface{}{\"bcd\", false}\n\/\/ >>> reverse_delete(\"abcdef\", \"b\")\n\/\/ []interface{}{\"acdef\", false}\n\/\/ >>> reverse_delete(\"abcdedcba\", \"ab\")\n\/\/ []interface{}{\"cdedc\", true}\nfunc reverse_delete(s string, c string) []interface{} {\n","canonical_solution":"func reverse_delete(s string, c string) []interface{} {\n    \/\/ Create a map to store the characters to be deleted\n    deleteMap := make(map[rune]bool)\n    for _, ch := range c {\n        deleteMap[ch] = true\n    }\n    \n    \/\/ Filter the string s by removing characters present in deleteMap\n    var filteredString []rune\n    for _, ch := range s {\n        if !deleteMap[ch] {\n            filteredString = append(filteredString, ch)\n        }\n    }\n    \n    \/\/ Check if the filtered string is a palindrome\n    n := len(filteredString)\n    isPalindrome := true\n    for i := 0; i < n\/2; i++ {\n        if filteredString[i] != filteredString[n-1-i] {\n            isPalindrome = false\n            break\n        }\n    }\n    \n    \/\/ Convert filteredString to a string and prepare result\n    resultString := string(filteredString)\n    return []interface{}{resultString, isPalindrome}\n}","tests":"func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected: []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\", \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_113","nl":"kmb_Latn","pl":"go_test.go","prompt":"package odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O mbandu iambe, \"kima kimoxi ngó\" ia mbandu ia kijimbuete.\/\/O kijimbuete \"i\" mu kididi kia \"i\", mu moneka ngó o kijimbuete \"i\".\/\/O mbandu ia kijimbuete i, ia tokala ku kala ni kijimbuete kimoxi\/\/Mu ku bhana o mbandu ia kijimbuete, a soneka o kijimbuete ni ijimbuete mu mukanda.\/\/ >>> odd_count([]string{\"1234567\"})\n\/\/ []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n\/\/ >>> odd_count([]string{\"3\", \"11111111\"})\n\/\/ []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}\nfunc odd_count(lst []string) []string {\n","canonical_solution":"package odd_count_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc odd_count(lst []string) []string {\n\tresult := []string{}\n\tfor _, str := range lst {\n\t\toddCount := 0\n\t\tfor _, char := range str {\n\t\t\tif char == '1' || char == '3' || char == '5' || char == '7' || char == '9' {\n\t\t\t\toddCount++\n\t\t\t}\n\t\t}\n\t\toutput := fmt.Sprintf(\"the number of odd elements %dn the str%1ng %d of the %dnput.\", oddCount, oddCount, oddCount)\n\t\tresult = append(result, output)\n\t}\n\treturn result\n}\n\nfunc TestOddCount(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{[]string{\"1234567\"}, []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}},\n\t\t{[]string{\"3\", \"11111111\"}, []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif result := odd_count(test.input); !equals(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equals(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOdd_Count(t *testing.T) {\n  candidate := odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"1234567\"}), expected: []string{\"the number of odd elements 4n the str4ng 4 of the 4nput.\"} },\n     { actual: candidate([]string{\"3\", \"11111111\"}), expected: []string{\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"} },\n     { actual: candidate([]string{\"271\", \"137\", \"314\"}), expected: []string{\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_114","nl":"kmb_Latn","pl":"go_test.go","prompt":"package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/ia ku di longa.\/\/Mu ku bhana o kijimbuete kia dijimbuluilu, tala o kijimbuete kia mukuá ki moneka ngó \/\/ >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n\/\/ 1\n\/\/ >>> minSubArraySum([]int{-1, -2, -3})\n\/\/ -6\nfunc minSubArraySum(nums []int) int {\n","canonical_solution":"if len(nums) == 0 {\n        return 0\n    }\n    \n    minEndingHere := nums[0]\n    minSoFar := nums[0]\n\n    for _, num := range nums[1:] {\n        if minEndingHere > 0 {\n            minEndingHere = num\n        } else {\n            minEndingHere += num\n        }\n        \n        if minEndingHere < minSoFar {\n            minSoFar = minEndingHere\n        }\n    }\n    \n    return minSoFar\n}","tests":"func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected: 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual: candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}), expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}), expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6 },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n     { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     { actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}), expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_115","nl":"kmb_Latn","pl":"go_test.go","prompt":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia 1: \/\/Soneka o ji veji ji ua mesena kusukula o dituaia.\/\/O kikalakalu kiê, o ku katula o menha ku dibanda ni ku jikula o fixi ni menha.\/\/O kitutu kioso kia disokejeka kiambote, ki tena ku tula ku ditadi dioso.\/\/O fixi ioso iala ni kididi kiê, muene mu tunda o menha.\/\/O 1 ilombolola o kaxaxi ka menha.\/\/O mbandu ia ku tala ia-nda londekesa o ima i ua tokala ku bhanga phala ku katula mbote mu milongi ia Bibidia.\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1)\n\/\/ 6\n\/\/ Example 2:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2)\n\/\/ 5\n\/\/ Example 3:\n\/\/ >>> max_fill([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5)\n\/\/ 0\n\/\/ Constraints:\n\/\/ * all wells have the same length\n\/\/ * 1 <= grid.length <= 10^2\n\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/ * grid[i][j] -> 0 | 1\n\/\/ * 1 <= capacity <= 10\nfunc max_fill(grid [][]int, capacity int) int {\n","canonical_solution":"package max_fill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_fill(grid [][]int, capacity int) int {\n    totalLowerings := 0\n\n    for _, row := range grid {\n        waterInRow := 0\n        \n        for _, cell := range row {\n            if cell == 1 {\n                waterInRow++\n            }\n        }\n\n        totalLowerings += (waterInRow + capacity - 1) \/ capacity\n    }\n\n    return totalLowerings\n}\n\nfunc TestMaxFill(t *testing.T) {\n    tests := []struct {\n        grid     [][]int\n        capacity int\n        expected int\n    }{\n        {[][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1, 6},\n        {[][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2, 5},\n        {[][]int{{0, 0, 0}, {0, 0, 0}}, 5, 0},\n    }\n\n    for _, test := range tests {\n        result := max_fill(test.grid, test.capacity)\n        if result != test.expected {\n            t.Errorf(\"For grid %v with capacity %d, expected %d but got %d\", test.grid, test.capacity, test.expected, result)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(max_fill([][]int{{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)) \/\/ Output: 6\n    fmt.Println(max_fill([][]int{{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)) \/\/ Output: 5\n    fmt.Println(max_fill([][]int{{0, 0, 0}, {0, 0, 0}}, 5)) \/\/ Output: 0\n}","tests":"func TestMax_Fill(t *testing.T) {\n  candidate := max_fill\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{0, 0, 1, 0}, []int{0, 1, 0, 0}, []int{1, 1, 1, 1}}, 1), expected: 6 },\n     { actual: candidate([][]int{[]int{0, 0, 1, 1}, []int{0, 0, 0, 0}, []int{1, 1, 1, 1}, []int{0, 1, 1, 1}}, 2), expected: 5 },\n     { actual: candidate([][]int{[]int{0, 0, 0}, []int{0, 0, 0}}, 5), expected: 0 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 2), expected: 4 },\n     { actual: candidate([][]int{[]int{1, 1, 1, 1}, []int{1, 1, 1, 1}}, 9), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_116","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O milongi íii ia-nda kuatekesa o: \/\/O ku uana o kijimbuete kiki, kua difuangana ni ku uana o kijimbuete kia mukuá.\/\/O ibuka iiadi íii, iala ni majina mâ a dianga.\/\/Mu kifika, mu kifika kiki, eie ua tokala kusoneka o ijimbuete ioso mu ukexilu ua \/\/ >>> sort_array([]int{1, 5, 2, 3, 4})\n\/\/ []int{1, 2, 3, 4, 5}\n\/\/ >>> sort_array([]int{-2, -3, -4, -5, -6})\n\/\/ []int{-6, -5, -4, -3, -2}\n\/\/ >>> sort_array([]int{1, 0, 2, 3, 4})\n\/\/ []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n","canonical_solution":"package sort_array_test\n\nimport (\n    \"sort\"\n)\n\nfunc sort_array(arr []int) []int {\n    sort.Slice(arr, func(i, j int) bool {\n        countOnes := func(x int) int {\n            count := 0\n            for x != 0 {\n                count += x & 1\n                x >>= 1\n            }\n            return count\n        }\n\n        countI := countOnes(arr[i])\n        countJ := countOnes(arr[j])\n\n        if countI == countJ {\n            return arr[i] < arr[j]\n        }\n        return countI < countJ\n    })\n    return arr\n}","tests":"func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2, 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4, -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected: []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected: []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3, 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2, 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_117","nl":"kmb_Latn","pl":"go_test.go","prompt":"package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O kijimbuete kia ku bhana ku mbandu ia kijimbuete kia-nda londekesa o mbandu ia kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa o kijimbuete kia-nda londekesa\/\/Se o kijimbuete s ki ki moneka, o mbandu ia-nda moneka, ki ia-nda kala ni kijimbuete.\/\/O izuelu íii, i moneka mu ukexilu ua kuila o kizuelu, \"k\".\/\/O mbandu ia kijimbuete, i bhana o izuelu ioso iala mu kijimbuete ki ua mesena.\/\/Mu ku bhana o ndunge ia ku soneka o ima i tua mesena, tua-nda ku bhana o ndunge ia ku soneka o ima i tua mesena.\/\/ >>> select_words(\"Mary had a little lamb\", 4)\n\/\/ []string{\"little\"}\n\/\/ >>> select_words(\"Mary had a little lamb\", 3)\n\/\/ []string{\"Mary\", \"lamb\"}\n\/\/ >>> select_words(\"simple white space\", 2)\n\/\/ []string{}\n\/\/ >>> select_words(\"Hello world\", 4)\n\/\/ []string{\"world\"}\n\/\/ >>> select_words(\"Uncle sam\", 3)\n\/\/ []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n","canonical_solution":"package select_words_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc select_words(s string, n int) []string {\n\t\/\/ Define a helper function to check if a character is a consonant.\n\tisConsonant := func(c rune) bool {\n\t\tc = rune(strings.ToLower(string(c))[0])\n\t\treturn c >= 'a' && c <= 'z' && !strings.ContainsRune(\"aeiou\", c)\n\t}\n\n\t\/\/ Split the string into words.\n\twords := strings.Fields(s)\n\tvar result []string\n\n\t\/\/ Iterate over each word.\n\tfor _, word := range words {\n\t\tconsonantCount := 0\n\t\t\/\/ Count the consonants in the word.\n\t\tfor _, char := range word {\n\t\t\tif isConsonant(char) {\n\t\t\t\tconsonantCount++\n\t\t\t}\n\t\t}\n\t\t\/\/ If the number of consonants matches n, add the word to the result.\n\t\tif consonantCount == n {\n\t\t\tresult = append(result, word)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc TestSelectWords(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        string\n\t\tn        int\n\t\texpected []string\n\t}{\n\t\t{\"Mary had a little lamb\", 4, []string{\"little\"}},\n\t\t{\"Mary had a little lamb\", 3, []string{\"Mary\", \"lamb\"}},\n\t\t{\"simple white space\", 2, []string{}},\n\t\t{\"Hello world\", 4, []string{\"world\"}},\n\t\t{\"Uncle sam\", 3, []string{\"Uncle\"}},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tresult := select_words(testCase.s, testCase.n)\n\t\tif !equal(result, testCase.expected) {\n\t\t\tt.Errorf(\"For input '%s' with n=%d, expected %v, but got %v\", testCase.s, testCase.n, testCase.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_118","nl":"kmb_Latn","pl":"go_test.go","prompt":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O kizuelu kiki, kia lungu ni kizuelu mu dimi dia Kingileji.\/\/sanga o kijimbuete kia mukuá kia tundu ku dimatekenu dia kizuelu.\/\/Se ki mua ki soneka, lungulula-mu o kijimbuete kiê.\/\/o kizuelu \"ku pholo\" ni \"ku kiasu\" mu dimi dia Kingileji.\/\/A ku bhana o kizuelu phala ku sanga o kizuelu kia beta o kota bhu kaxi ka kizuelu, \"mu\".\/\/ >>> get_closest_vowel(\"yogurt\")\n\/\/ \"u\"\n\/\/ >>> get_closest_vowel(\"FULL\")\n\/\/ \"U\"\n\/\/ >>> get_closest_vowel(\"quick\")\n\/\/ \"\"\n\/\/ >>> get_closest_vowel(\"ab\")\n\/\/ \"\"\nfunc get_closest_vowel(word string) string {\n","canonical_solution":"package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_closest_vowel(word string) string {\n    vowels := \"aeiouAEIOU\"\n    isVowel := make(map[rune]bool)\n    for _, v := range vowels {\n        isVowel[v] = true\n    }\n    \n    n := len(word)\n    for i := n-2; i > 0; i-- {\n        if isVowel[rune(word[i])] && \n           !isVowel[rune(word[i-1])] && \n           !isVowel[rune(word[i+1])] {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n\n\/\/ Test functions\nfunc TestGetClosestVowel(t *testing.T) {\n    var tests = []struct {\n        input    string\n        expected string\n    }{\n        {\"yogurt\", \"u\"},\n        {\"FULL\", \"U\"},\n        {\"quick\", \"\"},\n        {\"ab\", \"\"},\n    }\n    \n    for _, test := range tests {\n        result := get_closest_vowel(test.input)\n        if result != test.expected {\n            t.Errorf(\"get_closest_vowel(%q) = %q; want %q\", test.input, result, test.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(get_closest_vowel(\"yogurt\")) \/\/ Output: \"u\"\n    fmt.Println(get_closest_vowel(\"FULL\"))   \/\/ Output: \"U\"\n    fmt.Println(get_closest_vowel(\"quick\"))  \/\/ Output: \"\"\n    fmt.Println(get_closest_vowel(\"ab\"))     \/\/ Output: \"\"\n}","tests":"func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_119","nl":"kmb_Latn","pl":"go_test.go","prompt":"package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/Se o kijimbuete kia-nda moneka ngó, mu veji dia 'Kiene' mu veji dia 'Kana,' mu veji dia kiki, o kijimbuete kia-nda moneka ngó, mu veji dia 'Kiene'.\/\/O kizuelu \"ku\" ki ki moneka ngó mu kizuelu \"mba\".\/\/Mu kifika, o kijimbuete '(((() ' kiambote, maji o kijimbuete \/\/O kijimbuete S, a ki mona kala kiambote, se o kijimbuete S, ki kala ni ijimbuete ia S \/\/O ku bhanga kiki, kua-nda tu kuatekesa ku kala ni ibanzelu iambote, ia-nda tu bhangesa ué ku bhanga o ima iambote.\/\/O kikalakalu kiê, o ku mona se tu tena ku bhanga o ji pondo jiiadi jiji mu veji imoxi.\/\/mu kibandekesu \" ((\") mba mu kibandekesu kia sukina \") \".\/\/O mbandu íii ia ku katula, iala ni ijimbuete iiadi, ilombolola kuila, o mbandu ia ku katula, iala ni ijimbuete iiadi.\/\/ >>> match_parens([]string{\"()(\", \")\"})\n\/\/ \"Yes\"\n\/\/ >>> match_parens([]string{\")\", \")\"})\n\/\/ \"No\"\nfunc match_parens(lst []string) string {\n","canonical_solution":"func match_parens(lst []string) string {\n\tleft1, right1 := countParens(lst[0])\n\tleft2, right2 := countParens(lst[1])\n\n\tif left1+left2 == right1+right2 {\n\t\treturn \"Yes\"\n\t}\n\n\tif left1-right1+left2-right2 == 0 {\n\t\treturn \"Yes\"\n\t}\n\n\treturn \"No\"\n}\n\nfunc countParens(s string) (left int, right int) {\n\tfor _, c := range s {\n\t\tif c == '(' {\n\t\t\tleft++\n\t\t} else if c == ')' {\n\t\t\tright++\n\t\t}\n\t}\n\treturn\n}\n\nfunc TestMatchParens(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []string\n\t\texpected string\n\t}{\n\t\t{[]string{\"()(\", \")\"}, \"Yes\"},\n\t\t{[]string{\")\", \")\"}, \"No\"},\n\t\t{[]string{\"(((\", \")))\"}, \"Yes\"},\n\t\t{[]string{\"(\", \")\"}, \"Yes\"},\n\t\t{[]string{\"))(\", \"(\"}, \"No\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", test.input), func(t *testing.T) {\n\t\t\tif got := match_parens(test.input); got != test.expected {\n\t\t\t\tt.Errorf(\"match_parens(%v) = %v; want %v\", test.input, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_120","nl":"kmb_Latn","pl":"go_test.go","prompt":"package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia 1: \/\/O kijimbuete kia kijimbuete k, mu kijimbuete arr.\/\/Mu ku bhana o kijimbuete arr kia ijimbuete ni kijimbuete k kia uabha, jikula o kijimbuete ki ua solo \/\/ >>> maximum([]int{-3, -4, 5}, 3)\n\/\/ []int{-4, -3, 5}\n\/\/ Example 2:\n\/\/ >>> maximum([]int{4, -4, 4}, 2)\n\/\/ []int{4, 4}\n\/\/ Example 3:\n\/\/ >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1}, 1)\n\/\/ []int{2}\n\/\/ Note:\n\/\/ 1. The length of the list will be in the range of [1, 1000].\n\/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n\/\/ 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n","canonical_solution":"package maximum_test\n\nimport (\n    \"sort\"\n)\n\nfunc maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    \n    \/\/ Sort the array\n    sort.Ints(arr)\n    \n    \/\/ Get the last k elements, which are the largest\n    return arr[len(arr)-k:]\n}","tests":"func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     { actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n     { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2, 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected: []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0}, 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1, 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1, 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2), expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected: []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0}, 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_121","nl":"kmb_Latn","pl":"go_test.go","prompt":"package solution_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/Se tu kondala o kathombo ni kijimbuete kia mukuá, tua-nda tena kusanga o kijimbuete kia tokala.\/\/ >>> solution([]int{5, 8, 7, 1})\n\/\/ 12\n\/\/ >>> solution([]int{3, 3, 3, 3, 3})\n\/\/ 9\n\/\/ >>> solution([]int{30, 13, 24, 321})\n\/\/ 0\nfunc solution(lst []int) int {\n","canonical_solution":"sum := 0\n    for i := 0; i < len(lst); i++ {\n        if i%2 == 0 && lst[i]%2 != 0 {\n            sum += lst[i]\n        }\n    }\n    return sum\n}","tests":"func TestSolution(t *testing.T) {\n  candidate := solution\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 8, 7, 1}), expected: 12 },\n     { actual: candidate([]int{3, 3, 3, 3, 3}), expected: 9 },\n     { actual: candidate([]int{30, 13, 24, 321}), expected: 0 },\n     { actual: candidate([]int{5, 9}), expected: 5 },\n     { actual: candidate([]int{2, 4, 8}), expected: 0 },\n     { actual: candidate([]int{30, 13, 23, 32}), expected: 23 },\n     { actual: candidate([]int{3, 13, 2, 9}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_122","nl":"kmb_Latn","pl":"go_test.go","prompt":"package add_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/o mbandu ia kibandekesu, ia tokala ku kala ni ijimbuete iiadi, mu kibandekesu kimoxi ngó, mu kibandekesu kia kibandekesu kia kibandekesu kia kibandekesu kia kibandekesu kia kibandekesu.\/\/Mu ku bhana o kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete kia kijimbuete.\/\/ >>> add_elements([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n\/\/ 24\n\/\/ Constraints:\n\/\/ 1. 1 <= len(arr) <= 100\n\/\/ 2. 1 <= k <= len(arr)\nfunc add_elements(arr []int, k int) int {\n","canonical_solution":"func add_elements(arr []int, k int) int {\n    sum := 0\n    for i := 0; i < k; i++ {\n        if arr[i] >= -99 && arr[i] <= 99 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}","tests":"func TestAdd_Elements(t *testing.T) {\n  candidate := add_elements\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 41, 57, 76, 87, 88, 99}, 3), expected: -4 },\n     { actual: candidate([]int{111, 121, 3, 4000, 5, 6}, 2), expected: 0 },\n     { actual: candidate([]int{11, 21, 3, 90, 5, 6, 7, 8, 9}, 4), expected: 125 },\n     { actual: candidate([]int{111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4), expected: 24 },\n     { actual: candidate([]int{1}, 1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_123","nl":"kmb_Latn","pl":"go_test.go","prompt":"package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/get_odd_collatz(5) i vutula [1, 5] # O ku kaiela o ukexilu ua ku soneka o ima mu ididi ioso mu tu sanga o kijimbuete 5, kua difu ni ku soneka o ima mu ididi ioso mu tu sanga o kijimbuete 5, 16, 8, 4, 2, 1 ], mu kiki o kijimbuete kia 5 ki moneka ngó mu veji imoxi.\/\/Mu kifika: \/\/2. ua tumikisa o mukanda, mu ku u uanuna mu jimbandu.\/\/1. O mbandu Collatz ((1)) iala ni isoneku [1].\/\/[Tanga mu luji]\/\/O ku bandekesa o mbandu ia beta-o-kota, a ku bandekesa ni 1. O ku bandekesa o mbandu ia beta-o-kota, a ku bandekesa ni 1.\/\/Se o mbandu ia dianga ia kifika ki ia fuama, o mbandu ia mukuá ia kifika, ia kaxaxi, ia kaxaxi ni ia kaxaxi, mu veji dia kiki, ia kaxaxi ni ia kaxaxi, mu veji dia kiki, o mbandu ia katatu, mu veji dia kiki, o mbandu ia kaxaxi ni ia kaxaxi, mu veji dia kiki, o mbandu ia kaxaxi ni ia kaxaxi, mu veji dia kiki, o mbandu ia kaxaxi ni ia kaxaxi.\/\/Se o mbandu ia dianga ia kifika ia tokala kua katanu, o mbandu ia mukuá ia kifika ia tokala kua kamúkua.\/\/Mu ku suluka, tu tena ku sanga o mbandu ia beta-o-kota mu kididi kiki.\/\/O kibanzelu kia Kolac, o kibanzelu kia lungu ni ku kondala o ima.\/\/Mu ku bhana o kijimbuete kia mutokala ua kidi, soneka-mu o kijimbuete kia tokala, phala kulondekesa o ukexilu ua ku lungulula o kijimbuete.\/\/ >>> get_odd_collatz(5)\n\/\/ []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n","canonical_solution":"package get_odd_collatz_test\n\nimport (\n    \"sort\"\n)\n\nfunc get_odd_collatz(n int) []int {\n    oddNumbers := make(map[int]bool)\n\n    for n != 1 {\n        if n%2 != 0 {\n            oddNumbers[n] = true\n        }\n        if n%2 == 0 {\n            n \/= 2\n        } else {\n            n = 3*n + 1\n        }\n    }\n\n    \/\/ Add 1 to the set of odd numbers because the sequence always ends at 1\n    oddNumbers[1] = true\n\n    \/\/ Extract the keys, which represent the odd numbers\n    result := make([]int, 0, len(oddNumbers))\n    for num := range oddNumbers {\n        result = append(result, num)\n    }\n\n    \/\/ Sort the result\n    sort.Ints(result)\n\n    return result\n}","tests":"func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_124","nl":"kmb_Latn","pl":"go_test.go","prompt":"package valid_date_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/4. O kizuua kia tokala ki moneka kala: mm-dd-yyyy \/\/O mbeji ia tokala i tenesa ngó mbeji imoxi, o ia mukua kana.\/\/O kijimbuete kia izuua mu mbeji ia 1 ki ki tokala ku kala kia izuua 31 mu mbeji ia 1, 3, 5, 7, 8, 10, 12 ni kia izuua 30 mu mbeji ia 4, 6, 9, 11 ni kia izuua 29 mu mbeji ia 2.\/\/1. O muimbu ua kuila, o kizuua kia ku batizala, ki ki bhiti luua.\/\/O kizuua kiki, kia-nda bhita ngó se a belesela o itumu íii: \/\/ua tokala u kala o kizuua kia dikumbidila o polova, se o kizuua kia dikumbidila o polova ki i tokala. \/\/Ua tokala u soneka o ima ia beta-o-kota, phala ku u kuatekesa ku sanga o ima i ua mesena mu mukanda.\/\/ >>> valid_date(\"03-11-2000\")\n\/\/ true\n\/\/ >>> valid_date(\"15-01-2012\")\n\/\/ false\n\/\/ >>> valid_date(\"04-0-2040\")\n\/\/ false\n\/\/ >>> valid_date(\"06-04-2020\")\n\/\/ true\n\/\/ >>> valid_date(\"06\/04\/2020\")\n\/\/ false\nfunc valid_date(date string) bool {\n","canonical_solution":"func valid_date(date string) bool {\n    if len(date) == 0 {\n        return false\n    }\n\n    var month, day, year int\n    n, err := fmt.Sscanf(date, \"%02d-%02d-%04d\", &month, &day, &year)\n\n    if err != nil || n != 3 {\n        return false\n    }\n\n    if month < 1 || month > 12 {\n        return false\n    }\n\n    if month == 2 {\n        if day < 1 || day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n\n    return true\n}","tests":"func TestValid_Date(t *testing.T) {\n  candidate := valid_date\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"03-11-2000\"), expected: true },\n     { actual: candidate(\"15-01-2012\"), expected: false },\n     { actual: candidate(\"04-0-2040\"), expected: false },\n     { actual: candidate(\"06-04-2020\"), expected: true },\n     { actual: candidate(\"01-01-2007\"), expected: true },\n     { actual: candidate(\"03-32-2011\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"04-31-3000\"), expected: false },\n     { actual: candidate(\"06-06-2005\"), expected: true },\n     { actual: candidate(\"21-31-2000\"), expected: false },\n     { actual: candidate(\"04-12-2003\"), expected: true },\n     { actual: candidate(\"04122003\"), expected: false },\n     { actual: candidate(\"20030412\"), expected: false },\n     { actual: candidate(\"2003-04\"), expected: false },\n     { actual: candidate(\"2003-04-12\"), expected: false },\n     { actual: candidate(\"04-2003\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_126","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/Mu veji dia ku bhana o mbandu ia kijimbuete, a tokala ku bhana o kijimbuete kia makutu.\/\/Se o milongi i ua mu tanga ia tokala ngó phala eie, kana dingi kubhanga mbandu ia milongi i ua mu tanga.\/\/Mu ku bhana o mbandu ia ku sokejeka o ima, soneka o ima ioso i ua mesena mu mukanda.\/\/ >>> is_sorted([]int{5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 3, 2, 4, 5, 6, 7})\n\/\/ false\n\/\/ >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n\/\/ true\n\/\/ >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n\/\/ false\nfunc is_sorted(lst []int) bool {\n","canonical_solution":"func is_sorted(lst []int) bool {\n    if len(lst) <= 1 {\n        return true\n    }\n    \n    duplicateCount := make(map[int]int)\n\n    for i := 0; i < len(lst)-1; i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n        duplicateCount[lst[i]]++\n        if duplicateCount[lst[i]] > 1 {\n            return false\n        }\n    }\n    \n    \/\/ Check the last element for duplicate\n    duplicateCount[lst[len(lst)-1]]++\n    if duplicateCount[lst[len(lst)-1]] > 1 {\n        return false\n    }\n\n    return true\n}","tests":"func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}), expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected: false },\n     { actual: candidate([]int{}), expected: true },\n     { actual: candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_127","nl":"kmb_Latn","pl":"go_test.go","prompt":"package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/[o ima ia tokala ku i soneka]\/\/Se o jimbandu ki ji di lungu, soneka \"Kana\".\/\/Se kana, soneka \"KANA\". \/\/Se o mbandu ia kijimbuete ilondekesa kuila o mbandu ia kijimbuete, kidi, tua-nda tambula o kitambuijilu kiki: \"KIA kidi\".\/\/O kijimbuete kia dianga, 1 ki ki fu.\/\/Mu kifika, o kididi kia di tungula (1, 3), (2, 4) o kididi kiki, (2, 3) \/\/O ku di zelesa, kua difuangana ni ku di sokejeka mu jimbandu.\/\/O kikalakalu kiê, o kuijiia se o dibandela didi diala ni muxinda ua jikolo jifiiele, mba kana.\/\/O ku di longa o ukexilu ua Jihova ua ku tu umba, kua-nda tu kuatekesa ku kala ni ukexilu uambote.\/\/O divulu didi di mateka ni disukilu.\/\/O kithangana kia ku bhanga o ima íii, kia difu ni ku bhanga o ima ia mukuá.\/\/Mu kifika, o mbandu ia dianga, ni ia sukina, iala ni ji mbandu jiiadi.\/\/Ua-nda tambula o ujitu ua ku bhanga mbandu ia kibuka kiki, mu veji jiiadi.\/\/ >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\/\/ \"NO\"\n\/\/ >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\/\/ \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n","canonical_solution":"package intersection_test\n\nimport (\n\t\"testing\"\n)\n\n\/\/ Helper function to determine if a number is prime\nfunc isPrime(num int) bool {\n\tif num <= 1 {\n\t\treturn false\n\t}\n\tif num == 2 {\n\t\treturn true\n\t}\n\tif num%2 == 0 {\n\t\treturn false\n\t}\n\tfor i := 3; i*i <= num; i += 2 {\n\t\tif num%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc intersection(interval1 []interface{}, interval2 []interface{}) string {\n\tstart1, end1 := interval1[0].(int), interval1[1].(int)\n\tstart2, end2 := interval2[0].(int), interval2[1].(int)\n\n\t\/\/ Determine the intersection of two intervals\n\tintersectStart := max(start1, start2)\n\tintersectEnd := min(end1, end2)\n\n\tif intersectStart > intersectEnd {\n\t\treturn \"NO\"\n\t}\n\n\t\/\/ The length of intersection is end - start\n\tlengthOfIntersection := intersectEnd - intersectStart\n\tif isPrime(lengthOfIntersection) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\n\/\/ Helper function to find the maximum of two integers\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\/\/ Helper function to find the minimum of two integers\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc TestIntersection(t *testing.T) {\n\tif intersection([]interface{}{1, 2}, []interface{}{2, 3}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-1, 1}, []interface{}{0, 4}) != \"NO\" {\n\t\tt.Error(\"Expected NO\")\n\t}\n\tif intersection([]interface{}{-3, -1}, []interface{}{-5, 5}) != \"YES\" {\n\t\tt.Error(\"Expected YES\")\n\t}\n}","tests":"func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_129","nl":"kmb_Latn","pl":"go_test.go","prompt":"package minPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O mbandu íii, i londekesa o ima ia tokala ku bhita mu ithangana ioso.\/\/O kitambuijilu kiki kia-nda kala kia kidi.\/\/O kuila o ima íii ia-nda bhita muene?\/\/Mu kiki, phala o j (1 <= j < i) tu sanga-mu \/\/than lst_B, mu izuelu ia mukuá, kuala o kijimbuete i (1 <= i <= k) \/\/(Tu a xinganeke mu dijina dia isoneku ia mbandu ia A ni ia mbandu ia B) O isoneku ia mbandu ia A, ki i difu ni isoneku ia mbandu ia C.\/\/Mu ku suluka, soneka o ima ioso mu mukanda A, B phala ku sanga o ima i ua mesena.\/\/O njila A (ia lebha k) i beta-o-kota, o njila B (ia lebha k) ndenge, se \/\/O JIPHANGE ja Jihova, ka tena ku lenga o ima ia iibha.\/\/ki ku bhingi ku di ta mu maka a lungu ni ku di longa o Bibidia.)\/\/Tua ku dióndo, tala o njila íii ia lebha k, u i sokejeka mu kijimbuete k (kana ku ki sokesa ni kijimbuete \/\/ ku\/\/O kuila o ji makina ji tena ku tu kuatekesa?\/\/Mu ithangana ioso, eie u tena ku katula o jifoto ja ufusa ja mu mutelembe ué, ni ku ji tumikisa ku jifoto ja mukuá ja ufusa.\/\/Eie u tena ku mateka mu ku sota o njila ia beta-o-kota, phala ku bhixila bhu mbambe.\/\/O kijimbuete \"inclusive\" mu phutu, a ki soneka ngó veji imoxi mu mukanda.\/\/O kijimbuete kia mukuá mu kijimbuete kiki, a ki xana \"kima kimoxi ngó\".\/\/Mu ku mona o ikoka iala ni ijimbuete N, ni ijimbuete N, ni ijimbuete k, \/\/ >>> minPath([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3)\n\/\/ []int{1, 2, 1}\n\/\/ >>> minPath([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1)\n\/\/ []int{1}\nfunc minPath(grid [][]int, k int) []int {\n","canonical_solution":"package minPath_test\n\nimport (\n    \"sort\"\n)\n\nfunc minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    \n    var dfs func(x, y, length int, path []int)\n    var minPath []int\n    minPath = make([]int, k)\n    for i := 0; i < k; i++ {\n        minPath[i] = n*n + 1\n    }\n\n    dfs = func(x, y, length int, path []int) {\n        if length == k {\n            if isLess(path, minPath) {\n                copy(minPath, path)\n            }\n            return\n        }\n        \n        for _, dir := range directions {\n            nx, ny := x+dir[0], y+dir[1]\n            if nx >= 0 && ny >= 0 && nx < n && ny < n {\n                path[length] = grid[nx][ny]\n                dfs(nx, ny, length+1, path)\n            }\n        }\n    }\n    \n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            path := make([]int, k)\n            path[0] = grid[i][j]\n            dfs(i, j, 1, path)\n        }\n    }\n    \n    return minPath\n}\n\nfunc isLess(a, b []int) bool {\n    for i := 0; i < len(a); i++ {\n        if a[i] < b[i] {\n            return true\n        }\n        if a[i] > b[i] {\n            return false\n        }\n    }\n    return false\n}","tests":"func TestMinpath(t *testing.T) {\n  candidate := minPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}, 3), expected: []int{1, 2, 1} },\n     { actual: candidate([][]int{[]int{5, 9, 3}, []int{4, 1, 6}, []int{7, 8, 2}}, 1), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}, []int{13, 14, 15, 16}}, 4), expected: []int{1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{6, 4, 13, 10}, []int{5, 7, 12, 1}, []int{3, 16, 11, 15}, []int{8, 14, 9, 2}}, 7), expected: []int{1, 10, 1, 10, 1, 10, 1} },\n     { actual: candidate([][]int{[]int{8, 14, 9, 2}, []int{6, 4, 13, 15}, []int{5, 7, 1, 12}, []int{3, 10, 11, 16}}, 5), expected: []int{1, 7, 1, 7, 1} },\n     { actual: candidate([][]int{[]int{11, 8, 7, 2}, []int{5, 16, 14, 4}, []int{9, 3, 15, 6}, []int{12, 13, 10, 1}}, 9), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1} },\n     { actual: candidate([][]int{[]int{12, 13, 10, 1}, []int{9, 3, 15, 6}, []int{5, 16, 14, 4}, []int{11, 8, 7, 2}}, 12), expected: []int{1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6} },\n     { actual: candidate([][]int{[]int{2, 7, 4}, []int{3, 1, 5}, []int{6, 8, 9}}, 8), expected: []int{1, 3, 1, 3, 1, 3, 1, 3} },\n     { actual: candidate([][]int{[]int{6, 1, 5}, []int{3, 8, 9}, []int{2, 7, 4}}, 8), expected: []int{1, 5, 1, 5, 1, 5, 1, 5} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}, 10), expected: []int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2} },\n     { actual: candidate([][]int{[]int{1, 3}, []int{3, 2}}, 10), expected: []int{1, 3, 1, 3, 1, 3, 1, 3, 1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_130","nl":"kmb_Latn","pl":"go_test.go","prompt":"package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O ku di bandekesa kua jithéthembua, kulondekesa kuila o jithéthembua jiji, ji di bandekesa ku 10 dia ji kilómetulu.\/\/Se tu bhana o kijimbuete kiofele, n, tua tokala ku soneka o kijimbuete ni ijimbuete iofele, n.\/\/= 2 + 3 + 3 = 8 \/\/(Tanga o kaxa mu mbandu ia dianga.)\/\/tri(4) = 3 \/\/(Tanga o kaxa mu mbandu ia dianga.)\/\/Mu kifika: \/\/tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), se o kijimbuete n, ki kidi. \/\/tri (n) = 1 + n \/ 2, se n kidifua kia katanu. \/\/tri(1) = 3 \/\/O ku di longa o milongi ia lungu ni ku di jibha, a i jimbulula mu maukexilu a kaiela:\/\/Maji o athu kejiia kiambote o ukexilu ua mon'a Tribonacci.\/\/Athu oso ejiia kiambote o ukexilu ua Fibonacci, o jingijiie ja katunda a u tange kiavulu ku hama ia 19.\/\/ >>> tri(3)\n\/\/ []int{1, 3, 2, 8}\nfunc tri(n int) []int {\n","canonical_solution":"func tri(n int) []int {\n    if n < 0 {\n        return []int{}\n    }\n    sequence := make([]int, n+1)\n    sequence[0] = 1 \/\/ tri(0) is not defined in problem, let's start with tri(1)\n    if n >= 1 {\n        sequence[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            sequence[i] = 1 + i\/2\n        } else {\n            sequence[i] = sequence[i-1] + sequence[i-2] + getNextTribonacci(i)\n        }\n    }\n    return sequence\n}\n\nfunc getNextTribonacci(n int) int {\n    if n%2 == 0 {\n        return 1 + n\/2\n    }\n    return getNextTribonacciRec(n+1)\n}\n\nfunc getNextTribonacciRec(n int) int {\n    triNext := make([]int, n+1)\n    triNext[0] = 1 \/\/ again assuming some base start\n    if n >= 1 {\n        triNext[1] = 3\n    }\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            triNext[i] = 1 + i\/2\n        } else {\n            triNext[i] = triNext[i-1] + triNext[i-2] + getNextTribonacci(i)\n        }\n    }\n    return triNext[n]\n}","tests":"func TestTri(t *testing.T) {\n  candidate := tri\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3), expected: []int{1, 3, 2, 8} },\n     { actual: candidate(4), expected: []int{1, 3, 2, 8, 3} },\n     { actual: candidate(5), expected: []int{1, 3, 2, 8, 3, 15} },\n     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3, 15, 4} },\n     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4, 24} },\n     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5} },\n     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35} },\n     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },\n     { actual: candidate(0), expected: []int{1} },\n     { actual: candidate(1), expected: []int{1, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_131","nl":"kmb_Latn","pl":"go_test.go","prompt":"package digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Mu kiki, o mbandu ia sukina ia mukanda, a i soneka mu ukexilu u tu tena ku tendela kiambote.\/\/Mu ku bhana o kijimbuete kia tenena n, soneka o kijimbuete kia ijimbuete ia mukuá. \/\/ >>> digits(1)\n\/\/ 1\n\/\/ >>> digits(4)\n\/\/ 0\n\/\/ >>> digits(235)\n\/\/ 15\nfunc digits(n int) int {\n","canonical_solution":"product := 1\n    hasOdd := false\n\n    for n > 0 {\n        digit := n % 10\n        if digit%2 != 0 {\n            product *= digit\n            hasOdd = true\n        }\n        n \/= 10\n    }\n\n    if hasOdd {\n        return product\n    }\n    return 0\n}","tests":"func TestDigits(t *testing.T) {\n  candidate := digits\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 5 },\n     { actual: candidate(54), expected: 5 },\n     { actual: candidate(120), expected: 1 },\n     { actual: candidate(5014), expected: 5 },\n     { actual: candidate(98765), expected: 315 },\n     { actual: candidate(5576543), expected: 2625 },\n     { actual: candidate(2468), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_132","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/mu mbandu ia sukina, muala o kijimbuete kia mbandu ia sukina.\/\/O mbandu íii, a i lungulula \"kidi\" phala kulondekesa o ima ia mukuá ia difu.\/\/O mbandu íii ia kifika, ia tokala ku kala ni kijimbuete kimoxi.\/\/ >>> is_nested(\"[[]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[]]]]]]][[[[[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[][]\")\n\/\/ false\n\/\/ >>> is_nested(\"[]\")\n\/\/ false\n\/\/ >>> is_nested(\"[[][]]\")\n\/\/ true\n\/\/ >>> is_nested(\"[[]][[\")\n\/\/ true\nfunc is_nested(myString string) bool {\n","canonical_solution":"func is_nested(myString string) bool {\n\tstack := []rune{}\n\tnestingFound := false\n\n\tfor _, char := range myString {\n\t\tif char == '[' {\n\t\t\tstack = append(stack, char)\n\t\t} else if char == ']' {\n\t\t\tif len(stack) > 0 {\n\t\t\t\tstack = stack[:len(stack)-1]\n\t\t\t\tif len(stack) > 0 {\n\t\t\t\t\tnestingFound = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nestingFound\n}","tests":"func TestIs_Nested(t *testing.T) {\n  candidate := is_nested\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"[[]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]][[[[[]\"), expected: false },\n     { actual: candidate(\"[][]\"), expected: false },\n     { actual: candidate(\"[]\"), expected: false },\n     { actual: candidate(\"[[[[]]]]\"), expected: true },\n     { actual: candidate(\"[]]]]]]]]]]\"), expected: false },\n     { actual: candidate(\"[][][[]]\"), expected: true },\n     { actual: candidate(\"[[]\"), expected: false },\n     { actual: candidate(\"[]]\"), expected: false },\n     { actual: candidate(\"[[]][[\"), expected: true },\n     { actual: candidate(\"[[][]]\"), expected: true },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"[[[[[[[[\"), expected: false },\n     { actual: candidate(\"]]]]]]]]\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_133","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O ima ioso i moneka mu kaxa, tu i sokejeka mu jimbandu-jimbandu.\/\/Ua tokala u soneka o kijimbuete kia ku bandekesa mu mukanda, \/\/A ku bhana o majina a athu.\/\/ >>> lst([]float64{1.0, 2.0, 3.0})\n\/\/ 14\n\/\/ >>> lst([]float64{1.0, 4.0, 9.0})\n\/\/ 98\n\/\/ >>> lst([]float64{1.0, 3.0, 5.0, 7.0})\n\/\/ 84\n\/\/ >>> lst([]float64{1.4, 4.2, 0.0})\n\/\/ 29\n\/\/ >>> lst([]float64{-2.4, 1.0, 1.0})\n\/\/ 6\nfunc sum_squares(lst []float64) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n\t\"math\"\n)\n\nfunc sum_squares(lst []float64) int {\n\tsum := 0\n\tfor _, num := range lst {\n\t\tceiledNum := math.Ceil(num)\n\t\tsum += int(ceiledNum * ceiledNum)\n\t}\n\treturn sum\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 2.0, 3.0}), expected: 14 },\n     { actual: candidate([]float64{1.0, 3.0, 5.0, 7.0}), expected: 84 },\n     { actual: candidate([]float64{1.4, 4.2, 0.0}), expected: 29 },\n     { actual: candidate([]float64{-2.4, 1.0, 1.0}), expected: 6 },\n     { actual: candidate([]float64{100.0, 1.0, 15.0, 2.0}), expected: 10230 },\n     { actual: candidate([]float64{10000.0, 10000.0}), expected: 200000000 },\n     { actual: candidate([]float64{-1.4, 4.6, 6.3}), expected: 75 },\n     { actual: candidate([]float64{-1.4, 17.9, 18.9, 19.9}), expected: 1086 },\n     { actual: candidate([]float64{0.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0}), expected: 1 },\n     { actual: candidate([]float64{-1.0, 1.0, 0.0}), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_134","nl":"kmb_Latn","pl":"go_test.go","prompt":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O \"kizuelu\" kilombolola kibuka kia jiletala, a ji uanuna mu jimbandu.\/\/O kizuelu kiki, ki kia mu tokala ué, mukonda o kizuelu kiki, kia tokala ku mbandu ia kizuelu.\/\/O kijimbuete kia mukuá mu kijimbuete kia filiiale, kijimbuete kia jiletala kana.\/\/Sokejeka o kijimbuete true se o kijimbuete kia sukina mu njila íii , kijimbuete kia makutu .\/\/ >>> check_if_last_char_is_a_letter(\"apple pie\")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e\")\n\/\/ true\n\/\/ >>> check_if_last_char_is_a_letter(\"apple pi e \")\n\/\/ false\n\/\/ >>> check_if_last_char_is_a_letter(\"\")\n\/\/ false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n","canonical_solution":"package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\n    \"unicode\"\n)\n\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if len(txt) == 0 || unicode.IsSpace(rune(txt[len(txt)-1])) {\n        return false\n    }\n    \n    lastCharIndex := len(txt) - 1\n    for lastCharIndex >= 0 && unicode.IsSpace(rune(txt[lastCharIndex])) {\n        lastCharIndex--\n    }\n    \n    if lastCharIndex < 0 {\n        return false\n    }\n\n    if !unicode.IsLetter(rune(txt[lastCharIndex])) {\n        return false\n    }\n    \n    \/\/ Check if it's part of a word by looking at the previous character\n    if lastCharIndex > 0 && unicode.IsLetter(rune(txt[lastCharIndex-1])) {\n        return false\n    }\n\n    return true\n}\n\nfunc TestCheckIfLastCharIsALetter(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected bool\n    }{\n        {\"apple pie\", false},\n        {\"apple pi e\", true},\n        {\"apple pi e \", false},\n        {\"\", false},\n        {\"hello world\", true},\n        {\"a \", true},\n        {\" a\", true},\n        {\"abc\", false},\n        {\"abc \", false},\n    }\n\n    for _, c := range cases {\n        t.Run(c.input, func(t *testing.T) {\n            result := check_if_last_char_is_a_letter(c.input)\n            if result != c.expected {\n                t.Errorf(\"Expected %v, got %v for input \\\"%s\\\"\", c.expected, result, c.input)\n            }\n        })\n    }\n}","tests":"func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_135","nl":"kmb_Latn","pl":"go_test.go","prompt":"package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O kuila o athu a tena ku kala ni ibanzelu imoxi ia lungu ni maka enhá?\/\/O milongi ia-nda moneka ngó ku luiji.\/\/ki i soko ni kima kia mukuá.\/\/Bhanga o mbandu ia kijimbuete i ua mesena mu mbandu ia kijimbuete.\/\/ >>> can_arrange([]int{1, 2, 4, 3, 5})\n\/\/ 3\n\/\/ >>> can_arrange([]int{1, 2, 3})\n\/\/ -1\nfunc can_arrange(arr []int) int {\n","canonical_solution":"package can_arrange_test\n\nfunc can_arrange(arr []int) int {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}","tests":"func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_136","nl":"kmb_Latn","pl":"go_test.go","prompt":"package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/Se ki bhuala kijimbuete kia mukuá, a tokala ku ki soneka mu ukexilu ua zero.\/\/O kuila o Bibidia i tena ku tu kuatekesa kuijiia o ima ioso ia lungu ni Nzambi?\/\/O kijimbuete kia beta-kota mu valolo, o kijimbuete kia \"b\" o kijimbuete kia tolo mu valolo.\/\/O mbandu ia kijimbuete, \"a\", ilombolola o mbandu ia kijimbuete \"a\", mu mbandu ia kijimbuete \"b\".\/\/ >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n\/\/ []interface{}{nil, 1}\n\/\/ >>> largest_smallest_integers([]int{})\n\/\/ []interface{}{nil, nil}\n\/\/ >>> largest_smallest_integers([]int{0})\n\/\/ []interface{}{nil, nil}\nfunc largest_smallest_integers(lst []int) []interface{} {\n","canonical_solution":"func largest_smallest_integers(lst []int) []interface{} {\n    var largestNegative *int\n    var smallestPositive *int\n\n    for _, num := range lst {\n        if num < 0 {\n            if largestNegative == nil || num > *largestNegative {\n                largestNegative = new(int)\n                *largestNegative = num\n            }\n        } else if num > 0 {\n            if smallestPositive == nil || num < *smallestPositive {\n                smallestPositive = new(int)\n                *smallestPositive = num\n            }\n        }\n    }\n\n    var result = []interface{}{nil, nil}\n    if largestNegative != nil {\n        result[0] = *largestNegative\n    }\n    if smallestPositive != nil {\n        result[1] = *smallestPositive\n    }\n\n    return result\n}","tests":"func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}), expected: []interface{}{nil, 1} },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4, 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7, 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{0}), expected: []interface{}{nil, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-1, -3, -5, -6, 0}), expected: []interface{}{-1, nil} },\n     { actual: candidate([]int{-6, -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6, -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_138","nl":"kmb_Latn","pl":"go_test.go","prompt":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/Tala se o kijimbuete n, a tena ku ki soneka mu maukexilu aiiadi, kala kijimbuete kia kidi.\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n","canonical_solution":"package is_equal_to_sum_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n\/\/ Example\n\/\/ >>> is_equal_to_sum_even(4)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(6)\n\/\/ false\n\/\/ >>> is_equal_to_sum_even(8)\n\/\/ true\nfunc is_equal_to_sum_even(n int) bool {\n    \/\/ The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8\n    \/\/ Therefore, n must be at least 8 and n must be even\n    return n >= 8 && n%2 == 0\n}\n\n\/\/ Testing the function\nfunc TestIsEqualToSumEven(t *testing.T) {\n    cases := []struct {\n        n      int\n        expect bool\n    }{\n        {4, false},\n        {6, false},\n        {8, true},\n        {10, true},\n        {12, true},\n        {14, true},\n        {16, true},\n    }\n\n    for _, c := range cases {\n        result := is_equal_to_sum_even(c.n)\n        if result != c.expect {\n            t.Errorf(\"is_equal_to_sum_even(%d) == %v, expect %v\", c.n, result, c.expect)\n        } else {\n            fmt.Printf(\"Success: is_equal_to_sum_even(%d) == %v\\n\", c.n, result)\n        }\n    }\n}","tests":"func TestIs_Equal_To_Sum_Even(t *testing.T) {\n  candidate := is_equal_to_sum_even\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: false },\n     { actual: candidate(6), expected: false },\n     { actual: candidate(8), expected: true },\n     { actual: candidate(10), expected: true },\n     { actual: candidate(11), expected: false },\n     { actual: candidate(12), expected: true },\n     { actual: candidate(13), expected: false },\n     { actual: candidate(16), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_139","nl":"kmb_Latn","pl":"go_test.go","prompt":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/mu kaxi ka\/\/(b) O kuila o ku di longa o Bibidia mu xikola ia katunda, kua-nda ku kuatekesa ku bhanga kiambote o kikalakalu kiê?\/\/O kizuelu \"factor\" mu dimi dia akua Brazil, kilombolola: \/\/ >>> special_factorial(4)\n\/\/ 288\n\/\/ The function will receive an integer as input and should return the special\n\/\/ factorial of this integer.\nfunc special_factorial(n int) int {\n","canonical_solution":"package special_factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc special_factorial(n int) int {\n    if n <= 0 {\n        return 1\n    }\n    \n    result := 1\n    for i := 1; i <= n; i++ {\n        result *= factorial(i)\n    }\n    \n    return result\n}\n\nfunc factorial(x int) int {\n    if x == 0 {\n        return 1\n    }\n    prod := 1\n    for i := 1; i <= x; i++ {\n        prod *= i\n    }\n    return prod\n}\n\nfunc TestSpecialFactorial(t *testing.T) {\n    cases := []struct {\n        input    int\n        expected int\n    }{\n        {4, 288},      \/\/ 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288\n        {3, 12},       \/\/ 3! * 2! * 1! = 6 * 2 * 1 = 12\n        {2, 2},        \/\/ 2! * 1! = 2 * 1 = 2\n        {1, 1},        \/\/ 1! = 1\n        {0, 1},        \/\/ Edge case for n=0, considered as 1 for special factorial\n    }\n\n    for _, c := range cases {\n        result := special_factorial(c.input)\n        if result != c.expected {\n            t.Errorf(\"special_factorial(%d) == %d, want %d\", c.input, result, c.expected)\n        }\n    }\n}\n\nfunc main() {\n    fmt.Println(special_factorial(4)) \/\/ Output: 288\n    fmt.Println(special_factorial(3)) \/\/ Output: 12\n}","tests":"func TestSpecial_Factorial(t *testing.T) {\n  candidate := special_factorial\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(4), expected: 288 },\n     { actual: candidate(5), expected: 34560 },\n     { actual: candidate(7), expected: 125411328000 },\n     { actual: candidate(1), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_140","nl":"kmb_Latn","pl":"go_test.go","prompt":"package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/mu kusuluka, bhingana o ijimbuete ni - \/\/se o kijimbuete kiala ni ijimbuete iiadi mba ndenge, \/\/Mu veji dia ku ta kijimbuete kimoxi, ta-mu kijimbuete kia mukuá.\/\/ >>> fix_spaces(\" Example\")\n\/\/ \"Example\"\n\/\/ >>> fix_spaces(\" Example 1\")\n\/\/ \"Example_1\"\n\/\/ >>> fix_spaces(\" Example 2\")\n\/\/ \"_Example_2\"\n\/\/ >>> fix_spaces(\" Example 3\")\n\/\/ \"_Example-3\"\nfunc fix_spaces(text string) string {\n","canonical_solution":"package fix_spaces_test\n\nimport (\n    \"strings\"\n    \"testing\"\n)\n\nfunc fix_spaces(text string) string {\n    var result string\n    spaceCount := 0\n\n    for _, char := range text {\n        if char == ' ' {\n            spaceCount++\n        } else {\n            if spaceCount == 1 {\n                result += \"_\"\n            } else if spaceCount > 1 {\n                result += \"-\"\n            }\n            result += string(char)\n            spaceCount = 0\n        }\n    }\n\n    \/\/ Handle trailing spaces\n    if spaceCount == 1 {\n        result += \"_\"\n    } else if spaceCount > 1 {\n        result += \"-\"\n    }\n\n    return result\n}\n\nfunc TestFixSpaces(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected string\n    }{\n        {\" Example\", \"Example\"},\n        {\" Example 1\", \"Example_1\"},\n        {\" Example 2\", \"_Example_2\"},\n        {\" Example 3\", \"_Example-3\"},\n        {\" Hello    world\", \"_Hello-world\"},\n        {\"   Leading spaces\", \"-Leading_spaces\"},\n    }\n\n    for _, c := range cases {\n        result := fix_spaces(c.input)\n        if result != c.expected {\n            t.Errorf(\"fix_spaces(%q) == %q, expected %q\", c.input, result, c.expected)\n        }\n    }\n}","tests":"func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n     { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n     { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\" },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n     { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_141","nl":"kmb_Latn","pl":"go_test.go","prompt":"package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/- O kijimbuete kia ku kaiela, kia tokala kukala kiki: ['txt', 'exe', 'dll'] \/\/o jiletala ja dimi dia Latini, (a-z, A-z).\/\/- O kijimbuete kia ku pholo ki kia tokala ku kala kia hatu, kia tokala ku kala ni kijimbuete \/\/- O dijina dia falamenda íii, diala ni kijimbuete kimoxi ngó.\/\/- O dijina dia mukanda di tena kukala ngó ni ijimbuete itatu, \"0\" - \"9\".\/\/a mu bhanga kiki: \/\/O dijina dia mukanda, di moneka ngó se diene diala ni ijimbuete ioso íii \/\/O kijimbuete kia \"Kiene\" mu mbandu ia \"Dikutu\" kia tokala, se o dijina dia filiiale dia kidi, mu veji dia kiki, a tokala ku soneka \"Kana\". \/\/O ku bhanga o kifika kiki, kua-nda kuatekesa o muthu ku sanga o kizuelu \"ku\", mu mbandu ia milongi.\/\/ >>> file_name_check(\"example.txt\")\n\/\/ \"Yes\"\n\/\/ >>> file_name_check(\"1example.dll\")\n\/\/ \"No\"\nfunc file_name_check(file_name string) string {\n","canonical_solution":"package file_name_check_test\n\nimport (\n    \"strings\"\n    \"unicode\"\n)\n\nfunc file_name_check(file_name string) string {\n    if len(file_name) == 0 {\n        return \"No\"\n    }\n\n    \/\/ Condition 2: Check for exactly one dot\n    dotIndex := strings.LastIndex(file_name, \".\")\n    if dotIndex == -1 || dotIndex == 0 || dotIndex == len(file_name)-1 {\n        return \"No\"\n    }\n\n    \/\/ Split the file name into two parts\n    namePart := file_name[:dotIndex]\n    extension := file_name[dotIndex+1:]\n\n    \/\/ Condition 4: Check the extension\n    validExtensions := map[string]bool{\n        \"txt\": true,\n        \"exe\": true,\n        \"dll\": true,\n    }\n    if !validExtensions[extension] {\n        return \"No\"\n    }\n\n    \/\/ Condition 3: Check the first character before the dot\n    if !unicode.IsLetter(rune(namePart[0])) {\n        return \"No\"\n    }\n\n    \/\/ Condition 1: Count the digits in the file name\n    digitCount := 0\n    for _, char := range namePart {\n        if unicode.IsDigit(char) {\n            digitCount++\n        }\n    }\n    if digitCount > 3 {\n        return \"No\"\n    }\n\n    \/\/ If all conditions are met, return \"Yes\"\n    return \"Yes\"\n}","tests":"func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual: candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"\/this_is_valid.dll\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n     { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual: candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual: candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected: \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\" },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     { actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected: \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_142","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sum_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O mbandu íii, ia-nda londekesa o ima ia tokala ku lungulula mu mukanda.\/\/O mbandu ia kijimbuete, ia-nda londekesa o kijimbuete kia mukuá ki moneka mu mbandu ia kijimbuete.\/\/O mbandu íii, ia-nda londekesa o ijimbuete ia mbandu ia mukuá ia mukanda.\/\/\" \/\/ >>> lst\n\/\/ []int{1, 2, 3}\n\/\/ >>> lst\n\/\/ int{}\n\/\/ >>> lst\n\/\/ []int{-1, -5, 2, -1, -5}\nfunc sum_squares(lst []int) int {\n","canonical_solution":"package sum_squares_test\n\nimport (\n    \"testing\"\n)\n\nfunc sum_squares(lst []int) int {\n    sum := 0\n    for i, val := range lst {\n        if i%3 == 0 {\n            sum += val * val\n        } else if i%4 == 0 {\n            sum += val * val * val\n        } else {\n            sum += val\n        }\n    }\n    return sum\n}\n\nfunc TestSumSquares(t *testing.T) {\n    tests := []struct {\n        lst      []int\n        expected int\n    }{\n        {[]int{1, 2, 3}, 10},   \/\/ 1^2 + 2 + 3 = 10\n        {[]int{}, 0},           \/\/ empty list\n        {[]int{-1, -5, 2, -1, -5}, 0}, \/\/ (-1)^2 + (-5)^3 + 2 + (-1) = -118\n    }\n\n    for _, test := range tests {\n        result := sum_squares(test.lst)\n        if result != test.expected {\n            t.Errorf(\"sum_squares(%v) = %d; expected %d\", test.lst, result, test.expected)\n        }\n    }\n}","tests":"func TestSum_Squares(t *testing.T) {\n  candidate := sum_squares\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3}), expected: 6 },\n     { actual: candidate([]int{1, 4, 9}), expected: 14 },\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{1, 1, 1, 1, 1, 1, 1, 1, 1}), expected: 9 },\n     { actual: candidate([]int{-1, -1, -1, -1, -1, -1, -1, -1, -1}), expected: -3 },\n     { actual: candidate([]int{0}), expected: 0 },\n     { actual: candidate([]int{-1, -5, 2, -1, -5}), expected: -126 },\n     { actual: candidate([]int{-56, -99, 1, 0, -2}), expected: 3030 },\n     { actual: candidate([]int{-1, 0, 0, 0, 0, 0, 0, 0, -1}), expected: 0 },\n     { actual: candidate([]int{-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}), expected: -14196 },\n     { actual: candidate([]int{-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}), expected: -1448 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_143","nl":"kmb_Latn","pl":"go_test.go","prompt":"package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia 1: \/\/O izuelu ia mu kaiela, ia tokala i kala kála kia kexile mu dimatekenu.\/\/o ima ioso i tu mona, iala ni ima ia kidi, \/\/Mu ku suluka, tu soneka o izuelu i tua tange kiá ku dimatekenu.\/\/mu kaxi ka izuelu, bhuala kijimbuete.\/\/O ku soneka o kizuelu mu mukanda, kilombolola kuila o muthu ua soneka o divulu, ua soneka o izuelu ioso ia tange mu mukanda.\/\/ >>> words_in_sentence(\"This is a test\")\n\/\/ \"is\"\n\/\/ Example 2:\n\/\/ >>> words_in_sentence(\"lets go for swimming\")\n\/\/ \"go for\"\n\/\/ Constraints:\n\/\/ * 1 <= len(sentence) <= 100\n\/\/ * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n","canonical_solution":"package words_in_sentence_test\n\nimport (\n    \"strings\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i*i <= n; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc words_in_sentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var result []string\n\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result = append(result, word)\n        }\n    }\n\n    return strings.Join(result, \" \")\n}","tests":"func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_144","nl":"kmb_Latn","pl":"go_test.go","prompt":"package simplify_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Tu tena ku xikina kwila, x, ni n i tena ku kala ikwatekesu ya kidi, ki i tena ku kala ni dijimbuluilu di zwela kwila a di bhange ni zero.\/\/O kijimbuete ni kijimbuete, ki tena kulombolola kima kimoxi.\/\/O ukexilu ua mukuá ua ku soneka o kizuelu kiki, o ku soneka o kizuelu mu jiletala ja soneka na-ju akuâ.\/\/x * n. O mbandu íii, ia-nda londekesa kuila o milongi íii ia kidi, se o x * n ia kidi muene, ni kuila o milongi íii ia makutu.\/\/O kikalakalu kiê, o ku sokejeka o ima i moneka mu polova, phala ku i lungulula kiambote.\/\/ >>> simplify(\"1\/5\", \"5\/1\")\n\/\/ true\n\/\/ >>> simplify(\"1\/6\", \"2\/1\")\n\/\/ false\n\/\/ >>> simplify(\"7\/10\", \"10\/2\")\n\/\/ false\nfunc simplify(x string, n string) bool {\n","canonical_solution":"package simplify_test\n\nimport (\n    \"strconv\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc simplify(x string, n string) bool {\n    \/\/ Split the input strings into numerators and denominators\n    xParts := strings.Split(x, \"\/\")\n    nParts := strings.Split(n, \"\/\")\n\n    \/\/ Convert the string parts to integers\n    xNumerator, _ := strconv.Atoi(xParts[0])\n    xDenominator, _ := strconv.Atoi(xParts[1])\n    nNumerator, _ := strconv.Atoi(nParts[0])\n    nDenominator, _ := strconv.Atoi(nParts[1])\n\n    \/\/ Perform the multiplication (x * n) = (xNumerator\/nDenominator) * (nNumerator\/nDenominator)\n    resultNumerator := xNumerator * nNumerator\n    resultDenominator := xDenominator * nDenominator\n\n    \/\/ Check if the result is a whole number\n    return resultNumerator%resultDenominator == 0\n}\n\nfunc TestSimplify(t *testing.T) {\n    if !simplify(\"1\/5\", \"5\/1\") {\n        t.Fatalf(\"Expected true, got false\")\n    }\n    if simplify(\"1\/6\", \"2\/1\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n    if simplify(\"7\/10\", \"10\/2\") {\n        t.Fatalf(\"Expected false, got true\")\n    }\n}","tests":"func TestSimplify(t *testing.T) {\n  candidate := simplify\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/6\", \"2\/1\"), expected: false },\n     { actual: candidate(\"5\/1\", \"3\/1\"), expected: true },\n     { actual: candidate(\"7\/10\", \"10\/2\"), expected: false },\n     { actual: candidate(\"2\/10\", \"50\/10\"), expected: true },\n     { actual: candidate(\"7\/2\", \"4\/2\"), expected: true },\n     { actual: candidate(\"11\/6\", \"6\/1\"), expected: true },\n     { actual: candidate(\"2\/3\", \"5\/2\"), expected: false },\n     { actual: candidate(\"5\/2\", \"3\/5\"), expected: false },\n     { actual: candidate(\"2\/4\", \"8\/4\"), expected: true },\n     { actual: candidate(\"2\/4\", \"4\/2\"), expected: true },\n     { actual: candidate(\"1\/5\", \"5\/1\"), expected: true },\n     { actual: candidate(\"1\/5\", \"1\/5\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_145","nl":"kmb_Latn","pl":"go_test.go","prompt":"package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O majina a dianga, a a soneka mu ukexilu umoxi.\/\/Kijimbuete kia mukuá ki moneka ku mbandu ia kijimbuete kia mukuá, mu mbandu ia kijimbuete kia mukuá.\/\/O jipondo joso ja tokala ku ji soneka mu ukexilu umoxi.\/\/Soneka o mbandu ia kijimbuete, i ua mesena mu mbandu ia kijimbuete.\/\/ >>> order_by_points([]int{1, 11, -1, -11, -12})\n\/\/ []int{-1, -11, 1, -12, 11}\n\/\/ >>> order_by_points([]int{})\n\/\/ []int{}\nfunc order_by_points(nums []int) []int {\n","canonical_solution":"package order_by_points_test\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc digitSum(n int) int {\n\tn = abs(n) \/\/ Consider the absolute value for digit sum\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn \/= 10\n\t}\n\treturn sum\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc order_by_points(nums []int) []int {\n\ttype numWithIndex struct {\n\t\tnum   int\n\t\tindex int\n\t}\n\n\tnumsWithIndex := make([]numWithIndex, len(nums))\n\tfor i, num := range nums {\n\t\tnumsWithIndex[i] = numWithIndex{num, i}\n\t}\n\n\tsort.Slice(numsWithIndex, func(i, j int) bool {\n\t\tsumI := digitSum(numsWithIndex[i].num)\n\t\tsumJ := digitSum(numsWithIndex[j].num)\n\t\tif sumI == sumJ {\n\t\t\treturn numsWithIndex[i].index < numsWithIndex[j].index\n\t\t}\n\t\treturn sumI < sumJ\n\t})\n\n\tsortedNums := make([]int, len(nums))\n\tfor i, nwi := range numsWithIndex {\n\t\tsortedNums[i] = nwi.num\n\t}\n\n\treturn sortedNums\n}\n\nfunc TestOrderByPoints(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []int\n\t\texpected []int\n\t}{\n\t\t{[]int{1, 11, -1, -11, -12}, []int{-1, -11, 1, -12, 11}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := order_by_points(tc.input)\n\t\tif !equal(result, tc.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","tests":"func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected: []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98, 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected: []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_146","nl":"kmb_Latn","pl":"go_test.go","prompt":"package specialFilter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O jipondo ja dianga ni ja sukina ja tokala ku i kuata mu kaxi ka kaxi ni kaxi.\/\/o ima ioso iala mu mukanda, iala ni 10 dia ima, mba ia beta-o-kota, o ima iiadi íii, ia difu \/\/Soneka o mbandu ia kijimbuete, i ua mesena ku soneka mu mukanda, mu ku suluka soneka-mu o kijimbuete kia mukuá.\/\/ >>> specialFilter([]int{15, -73, 14, -15})\n\/\/ 1\n\/\/ >>> specialFilter([]int{33, -2, -3, 45, 21, 109})\n\/\/ 2\nfunc specialFilter(nums []int) int {\n","canonical_solution":"package specialFilter_test\n\nimport (\n\t\"testing\"\n)\n\nfunc specialFilter(nums []int) int {\n\tcount := 0\n\tfor _, num := range nums {\n\t\t\/\/ Consider the absolute value of the number\n\t\tabsNum := abs(num)\n\t\tif absNum > 10 {\n\t\t\tstrNum := fmt.Sprintf(\"%d\", absNum)\n\t\t\tfirstDigit := strNum[0]\n\t\t\tlastDigit := strNum[len(strNum)-1]\n\t\t\tif isOdd(firstDigit) && isOdd(lastDigit) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\nfunc isOdd(digit byte) bool {\n\treturn digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9'\n}\n\nfunc TestSpecialFilter(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []int\n\t\texpected int\n\t}{\n\t\t{[]int{15, -73, 14, -15}, 1},\n\t\t{[]int{33, -2, -3, 45, 21, 109}, 2},\n\t\t{[]int{8, 4, 12, 55, 99, 111}, 1},\n\t\t{[]int{-11, -22, -33, -44, -55}, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := specialFilter(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"specialFilter(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","tests":"func TestSpecialfilter(t *testing.T) {\n  candidate := specialFilter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, -2, 1, -5}), expected: 0 },\n     { actual: candidate([]int{15, -73, 14, -15}), expected: 1 },\n     { actual: candidate([]int{33, -2, -3, 45, 21, 109}), expected: 2 },\n     { actual: candidate([]int{43, -12, 93, 125, 121, 109}), expected: 4 },\n     { actual: candidate([]int{71, -2, -33, 75, 21, 19}), expected: 3 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{}), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_147","nl":"kmb_Latn","pl":"go_test.go","prompt":"package get_max_triples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/a[i] + a[j] + a[k] = 3 mu veji javulu. \/\/Kubhanga o mbandu ia katatu ia a mu soneka o a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka a mu soneka\/\/Phala o ima i tu sanga mu kaxa, o kijimbuete a[i] = i * i - i + 1.\/\/Ua-nda tambula o kijimbuete kia mutokala ua-nda moneka, n. Ua-nda soneka o kijimbuete kia mutokala ua-nda moneka, n.\/\/ >>> get_max_triples(5)\n\/\/ 1\n\/\/ Explanation: \n\/\/ a = [1, 3, 7, 13, 21]\n\/\/ The only valid triple is (1, 7, 13).\nfunc get_max_triples(n int) int {\n","canonical_solution":"package get_max_triples_test\n\nimport (\n    \"testing\"\n)\n\nfunc get_max_triples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n    \n    count := 0\n    \n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\nfunc TestGetMaxTriples(t *testing.T) {\n    if get_max_triples(5) != 1 {\n        t.Errorf(\"Expected 1 but got %d\", get_max_triples(5))\n    }\n}","tests":"func TestGet_Max_Triples(t *testing.T) {\n  candidate := get_max_triples\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected: 1 },\n     { actual: candidate(6), expected: 4 },\n     { actual: candidate(10), expected: 36 },\n     { actual: candidate(100), expected: 53361 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_148","nl":"kmb_Latn","pl":"go_test.go","prompt":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/O jiplaneta ki jala ni majina.\/\/O mbandu íii, ia tokala ku i soneka kala ki ia bhingi mu mbandu ia mukuá ia mukanda.\/\/O kuila o ixi ia-nda tema dingi?\/\/O kididi kiki, ki tena ku kala o kitungutu kia ixi, kia tokala o kididi kia 1 mu ngongo, kia tokala o kididi kia 2 mu ixi.\/\/O mbandu íii, ia tokala ku kala ni jiplaneta joso ja tokala ku jiplaneta jiji, kala ni jiplaneta jala ni jithéthembua javulu.\/\/Soneka o ifikula ilondekesa kuila, o ixi ia kexile ni 12 dia jiplaneta.\/\/O jiplaneta mu ngongo, jene ji di tula bhu kaxi ka ixi.\/\/O ixi ia-nda kaiela o jithéthembua, mu kubhita kithangana o ixi ia-nda kituka palaízu.\/\/O ima ioso íii, ilondekesa kuila o ixi ia zukama kua Nzambi.\/\/ >>> bf(\"Jupiter\", \"Neptune\")\n\/\/ []interface{}{\"Saturn\", \"Uranus\"}\n\/\/ >>> bf(\"Earth\", \"Mercury\")\n\/\/ \"Venus\"\n\/\/ >>> bf(\"Mercury\", \"Uranus\")\n\/\/ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n","canonical_solution":"package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ Define the solar system slice with planets ordered by their proximity to the Sun\nvar solarSystem = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\nfunc bf(planet1 string, planet2 string) []interface{} {\n    index1 := -1\n    index2 := -1\n\n    \/\/ Find the indices of the given planet names in the solarSystem slice\n    for i, planet := range solarSystem {\n        if planet == planet1 {\n            index1 = i\n        }\n        if planet == planet2 {\n            index2 = i\n        }\n    }\n\n    \/\/ If either planet name is incorrect, return an empty list\n    if index1 == -1 || index2 == -1 {\n        return []interface{}{}\n    }\n\n    \/\/ Ensure index1 is less than index2 to find planets between them\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n\n    \/\/ Collect and return planets that are located between the two indices\n    var planetsBetween []interface{}\n    for i := index1 + 1; i < index2; i++ {\n        planetsBetween = append(planetsBetween, solarSystem[i])\n    }\n    \n    return planetsBetween\n}\n\nfunc TestBf(t *testing.T) {\n    fmt.Println(bf(\"Jupiter\", \"Neptune\")) \/\/ Should print: []interface{}{\"Saturn\", \"Uranus\"}\n    fmt.Println(bf(\"Earth\", \"Mercury\"))  \/\/ Should print: []interface{}{\"Venus\"}\n    fmt.Println(bf(\"Mercury\", \"Uranus\")) \/\/ Should print: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n}","tests":"func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_149","nl":"kmb_Latn","pl":"go_test.go","prompt":"package sorted_list_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/O izuelu ioso ki ia-nda kala ni valolo.\/\/O mbandu íii, ia tokala ku i soneka mu ukexilu ua tokala.\/\/Se o izuelu ki i difu, soneka o ijimbuete mu ukexilu ua jiletala. \/\/O milongi íii, a i sokejeka mu ukexilu ua tokala.\/\/O izuelu ia tokala i tunda ku dimatekenu, ndu ku disukilu, mu ku suluka u soneka o izuelu i ua mesena o ku kaiela.\/\/O mukanda iú, u tena ué kukala ni mikanda ia mukua.\/\/O mukanda iú, ua tokala u kala ngó ni ijimbuete, kana ni ijimbuete iavulu.\/\/ni ku soneka o ima ioso mu ukexilu ua tokala.\/\/O ku katula o jimbandu ja Bibidia jiji, kua-nda tu kuatekesa ku tendela kiambote o maka u tua mu di longa.\/\/Soneka o mbandu ia kijimbuete, \/\/ >>> list_sort([]string{\"aa\", \"a\", \"aaa\"})\n\/\/ []string{\"aa\"}\n\/\/ >>> list_sort([]string{\"ab\", \"a\", \"aaa\", \"cd\"})\n\/\/ []string{\"ab\", \"cd\"}\nfunc sorted_list_sum(lst []string) []string {\n","canonical_solution":"package sorted_list_sum_test\n\nimport (\n    \"sort\"\n)\n\nfunc sorted_list_sum(lst []string) []string {\n    \/\/ Filter out strings with odd lengths\n    filtered := []string{}\n    for _, str := range lst {\n        if len(str)%2 == 0 {\n            filtered = append(filtered, str)\n        }\n    }\n\n    \/\/ Sort the filtered list by length, then alphabetically\n    sort.Slice(filtered, func(i, j int) bool {\n        if len(filtered[i]) == len(filtered[j]) {\n            return filtered[i] < filtered[j]\n        }\n        return len(filtered[i]) < len(filtered[j])\n    })\n\n    return filtered\n}","tests":"func TestSorted_List_Sum(t *testing.T) {\n  candidate := sorted_list_sum\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"aa\", \"a\", \"aaa\"}), expected: []string{\"aa\"} },\n     { actual: candidate([]string{\"school\", \"AI\", \"asdf\", \"b\"}), expected: []string{\"AI\", \"asdf\", \"school\"} },\n     { actual: candidate([]string{\"d\", \"b\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"d\", \"dcba\", \"abcd\", \"a\"}), expected: []string{\"abcd\", \"dcba\"} },\n     { actual: candidate([]string{\"AI\", \"ai\", \"au\"}), expected: []string{\"AI\", \"ai\", \"au\"} },\n     { actual: candidate([]string{\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"}), expected: []string{} },\n     { actual: candidate([]string{\"aaaa\", \"bbbb\", \"dd\", \"cc\"}), expected: []string{\"cc\", \"dd\", \"aaaa\", \"bbbb\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_150","nl":"kmb_Latn","pl":"go_test.go","prompt":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O kijimbuete kia mukuá, o kijimbuete kia mukuá, o kijimbuete kia mukuá.\/\/O polova íii, ia tokala kulondekesa o kidifua kia x, se n= \/\/ >>> x_or_y(7, 34, 12)\n\/\/ 34\n\/\/ >>> x_or_y(15, 8, 5)\n\/\/ 5\nfunc x_or_y(n int, x int, y int) int {\n","canonical_solution":"package x_or_y_test\n\nimport (\n    \"testing\"\n    \"math\"\n)\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    if n <= 3 {\n        return true\n    }\n    if n%2 == 0 || n%3 == 0 {\n        return false\n    }\n    for i := 5; i*i <= n; i += 6 {\n        if n%i == 0 || n%(i+2) == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc x_or_y(n int, x int, y int) int {\n    if isPrime(n) {\n        return x\n    }\n    return y\n}\n\nfunc TestXOrY(t *testing.T) {\n    cases := []struct{\n        n, x, y, want int\n    }{\n        {7, 34, 12, 34},\n        {15, 8, 5, 5},\n        {2, 10, 20, 10},\n        {1, 5, 15, 15},\n    }\n\n    for _, c := range cases {\n        got := x_or_y(c.n, c.x, c.y)\n        if got != c.want {\n            t.Errorf(\"x_or_y(%d, %d, %d) == %d, want %d\", c.n, c.x, c.y, got, c.want)\n        }\n    }\n}","tests":"func TestX_Or_Y(t *testing.T) {\n  candidate := x_or_y\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7, 34, 12), expected: 34 },\n     { actual: candidate(15, 8, 5), expected: 5 },\n     { actual: candidate(3, 33, 5212), expected: 33 },\n     { actual: candidate(1259, 3, 52), expected: 3 },\n     { actual: candidate(7919, -1, 12), expected: -1 },\n     { actual: candidate(3609, 1245, 583), expected: 583 },\n     { actual: candidate(91, 56, 129), expected: 129 },\n     { actual: candidate(6, 34, 1234), expected: 1234 },\n     { actual: candidate(1, 2, 0), expected: 0 },\n     { actual: candidate(2, 2, 0), expected: 2 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_151","nl":"kmb_Latn","pl":"go_test.go","prompt":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia mukuá, ki tu tena ku ki sanga mu mukanda, mu kiki-phe, o kijimbuete kia mukuá, ki tu tena ku ki sanga mu mukanda.\/\/Kala ki tua tange kiá ku dima, tala se kiebhi o mbandu ia dianga ia kifika, ilondekesa o ima ia mukuá iala ku pholo.\/\/ >>> double_the_difference([]int{1, 3, 2, 0})\n\/\/ 10\n\/\/ >>> double_the_difference([]int{-1, -2, 0})\n\/\/ 0\n\/\/ >>> double_the_difference([]int{9, -2})\n\/\/ 81\n\/\/ >>> double_the_difference([]int{0})\n\/\/ 0\n\/\/ If the input list is empty, return 0.\nfunc double_the_difference(lst []float64) int {\n","canonical_solution":"package double_the_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"math\"\n)\n\nfunc double_the_difference(lst []float64) int {\n    sum := 0\n    for _, num := range lst {\n        if num >= 0 && math.Mod(num, 1) == 0 {\n            intNum := int(num)\n            if intNum%2 != 0 {\n                sum += intNum * intNum\n            }\n        }\n    }\n    return sum\n}\n\nfunc TestDoubleTheDifference(t *testing.T) {\n    cases := []struct {\n        input []float64\n        expected int\n    }{\n        {input: []float64{1, 3, 2, 0}, expected: 10},\n        {input: []float64{-1, -2, 0}, expected: 0},\n        {input: []float64{9, -2}, expected: 81},\n        {input: []float64{0}, expected: 0},\n        {input: []float64{}, expected: 0},\n    }\n\n    for _, c := range cases {\n        result := double_the_difference(c.input)\n        if result != c.expected {\n            t.Errorf(\"double_the_difference(%v) == %d, want %d\", c.input, result, c.expected)\n        } else {\n            fmt.Printf(\"Test passed for input %v. Result: %d\\n\", c.input, result)\n        }\n    }\n}","tests":"func TestDouble_The_Difference(t *testing.T) {\n  candidate := double_the_difference\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]float64{}), expected: 0 },\n     { actual: candidate([]float64{5.0, 4.0}), expected: 25 },\n     { actual: candidate([]float64{0.1, 0.2, 0.3}), expected: 0 },\n     { actual: candidate([]float64{-10.0, -20.0, -30.0}), expected: 0 },\n     { actual: candidate([]float64{-1.0, -2.0, 8.0}), expected: 0 },\n     { actual: candidate([]float64{0.2, 3.0, 5.0}), expected: 34 },\n     { actual: candidate([]float64{-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0}), expected: 165 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_152","nl":"kmb_Latn","pl":"go_test.go","prompt":"package compare_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/kifika: \/\/Se o kijimbuete kia mukuá ki ki fu, o kijimbuete kia mukuá, kilombolola kuila o jipondo ja beta-kota ja moneka ku kijimbuete kia mukuá, o ji pondo ja mukuá ja beta-kota ja moneka ué.\/\/Mu ku suluka, soneka o ima ia beta kota ku dima, mu ku i soneka kala ki ua mesena.\/\/O jipondo joso ja ku tokuesa, jala ni kolo imoxi.\/\/O kikalakalu kiê, o kuijiia se o muthu ua mu zuela o kidi, ua lungu ni ioso ia mu zuela.\/\/O kuila o ku bhanga kiki, kia lungu ué ni ukexilu uetu ua ku mona o ima?\/\/O ibanzelu iê, ni ima i u banza, iene i ku bhangesa ku kala ni ibanzelu ia iibha.\/\/Nange tu di lembalala o kisangusangu ki tu kala na-kiu kioso ki tu tambula o kijimbuete ki tua kingila mu thembu iavulu .\/\/ >>> compare([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2})\n\/\/ []int{0, 0, 0, 0, 3, 3}\n\/\/ >>> compare([]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2})\n\/\/ []int{4, 4, 1, 0, 0, 6}\nfunc compare(game []int, guess []int) []int {\n","canonical_solution":"package compare_test\n\nimport (\n    \"math\"\n    \"testing\"\n    \"fmt\"\n)\n\nfunc compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i := 0; i < len(game); i++ {\n        if game[i] == guess[i] {\n            result[i] = 0\n        } else {\n            result[i] = int(math.Abs(float64(game[i] - guess[i])))\n        }\n    }\n    return result\n}\n\nfunc TestCompare(t *testing.T) {\n    tests := []struct {\n        game  []int\n        guess []int\n        want  []int\n    }{\n        {[]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}, []int{0, 0, 0, 0, 3, 3}},\n        {[]int{0, 5, 0, 0, 0, 4}, []int{4, 1, 1, 0, 0, -2}, []int{4, 4, 1, 0, 0, 6}},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%v vs %v\", tt.game, tt.guess), func(t *testing.T) {\n            got := compare(tt.game, tt.guess)\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"compare(%v, %v) = %v; want %v\", tt.game, tt.guess, got, tt.want)\n                }\n            }\n        })\n    }\n}","tests":"func TestCompare(t *testing.T) {\n  candidate := compare\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 1}, []int{1, 2, 3, 4, 2, -2}), expected: []int{0, 0, 0, 0, 3, 3} },\n     { actual: candidate([]int{0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0}), expected: []int{0, 0, 0, 0, 0, 0} },\n     { actual: candidate([]int{1, 2, 3}, []int{-1, -2, -3}), expected: []int{2, 4, 6} },\n     { actual: candidate([]int{1, 2, 3, 5}, []int{-1, 2, 3, 4}), expected: []int{2, 0, 0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_153","nl":"kmb_Latn","pl":"go_test.go","prompt":"package Strongest_Extension_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/(o nguzu iê, -1).\/\/return 'Slices.SErviNGSliCes' mukonda o kijimbuete 'SErviNGSliCes' kiene o kijimbuete kia beta-o-kota.\/\/Se u mesena ku tanga o dijina dia muthu mu Bibidia, mu kijimbuete: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ua tokala u soneka \/\/Mu kifika, se a ku bhana \"Fragmentos\" kála o milongi ni kijimbuete kia milongi, u tena ku sanga o mbandu ia milongi i ua mesena.\/\/sola o kizuelu kia dianga.\/\/Se o ima i u bhanga ia difu ni ia mukuâ, eie ua tokala u bhanga ioso phala ku kala ni nguzu ia ku u langa.\/\/format: ClassName.StrongestExtensionName. \/\/Ua tokala u sota o kijimbuete kia beta-kota ni ku soneka o kijimbuete kiki mu mukanda\/\/mu dijina dia kibamba, o kutena kua kibamba kiki, a ku bhana bhu kaxi ka CAP - SM. \/\/jiletala mu dijina dia mbandu ia kijimbuete, ni SM ijimbuete ia dikota mu jiletala ja makota \/\/O izuelu ia beta-o-kota mu ku soneka, íii: CAP o kijimbuete kia kisoneku kia dikota \/\/O milongi i tua-nda di longa, ia-nda tu kuatekesa ku bandekesa dingi o milongi mu milongi i tua mesena.\/\/Ua-nda sanga o dijina dia kibuka (kála o ndunge) ni kijimbuete kia ku bandekesa.\/\/ >>> Strongest_Extension(\"my_class\", []string{\"AA\", \"Be\", \"CC\"})\n\/\/ \"my_class.AA\"\nfunc Strongest_Extension(class_name string, extensions []string) string {\n","canonical_solution":"func Strongest_Extension(class_name string, extensions []string) string {\n    strongestExtension := \"\"\n    maxStrength := -1 << 31\n\n    for _, extension := range extensions {\n        capCount, smCount := 0, 0\n        for _, char := range extension {\n            if char >= 'A' && char <= 'Z' {\n                capCount++\n            } else if char >= 'a' && char <= 'z' {\n                smCount++\n            }\n        }\n        strength := capCount - smCount\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n\n    return fmt.Sprintf(\"%s.%s\", class_name, strongestExtension)\n}","tests":"func TestStrongest_Extension(t *testing.T) {\n  candidate := Strongest_Extension\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Watashi\", []string{\"tEN\", \"niNE\", \"eIGHt8OKe\"}), expected: \"Watashi.eIGHt8OKe\" },\n     { actual: candidate(\"Boku123\", []string{\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}), expected: \"Boku123.YEs.WeCaNe\" },\n     { actual: candidate(\"__YESIMHERE\", []string{\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}), expected: \"__YESIMHERE.NuLl__\" },\n     { actual: candidate(\"K\", []string{\"Ta\", \"TAR\", \"t234An\", \"cosSo\"}), expected: \"K.TAR\" },\n     { actual: candidate(\"__HAHA\", []string{\"Tab\", \"123\", \"781345\", \"-_-\"}), expected: \"__HAHA.123\" },\n     { actual: candidate(\"YameRore\", []string{\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"}), expected: \"YameRore.okIWILL123\" },\n     { actual: candidate(\"finNNalLLly\", []string{\"Die\", \"NowW\", \"Wow\", \"WoW\"}), expected: \"finNNalLLly.WoW\" },\n     { actual: candidate(\"_\", []string{\"Bb\", \"91245\"}), expected: \"_.Bb\" },\n     { actual: candidate(\"Sp\", []string{\"671235\", \"Bb\"}), expected: \"Sp.671235\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_154","nl":"kmb_Latn","pl":"go_test.go","prompt":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ku bhilula o kizuelu \"kiebhi kia di sokejeka o ima mu ibuka iiadi íii\", kilombolola kuila, o kizuelu \"kiebhi kia di sokejeka o ima mu ibuka iiadi íii\", kia tokala ku kala kima kimoxi ngó.\/\/ >>> cycpattern_check(\"abcd\", \"abd\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"hello\", \"ell\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"whassup\", \"psus\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"abab\", \"baa\")\n\/\/ true\n\/\/ >>> cycpattern_check(\"efef\", \"eeff\")\n\/\/ false\n\/\/ >>> cycpattern_check(\"himenss\", \"simen\")\n\/\/ true\nfunc cycpattern_check(a string, b string) bool {\n","canonical_solution":"package cycpattern_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc cycpattern_check(a string, b string) bool {\n    n := len(b)\n    \n    \/\/ Generate all rotations of b\n    for i := 0; i < n; i++ {\n        rotated := b[i:] + b[:i]\n        if strings.Contains(a, rotated) {\n            return true\n        }\n    }\n    \n    return false\n}","tests":"func TestCycpattern_Check(t *testing.T) {\n  candidate := cycpattern_check\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"xyzw\", \"xyw\"), expected: false },\n     { actual: candidate(\"yello\", \"ell\"), expected: true },\n     { actual: candidate(\"whattup\", \"ptut\"), expected: false },\n     { actual: candidate(\"efef\", \"fee\"), expected: true },\n     { actual: candidate(\"abab\", \"aabb\"), expected: false },\n     { actual: candidate(\"winemtt\", \"tinem\"), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_155","nl":"kmb_Latn","pl":"go_test.go","prompt":"package even_odd_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Mu ku bandekesa o kijimbuete kiki, ua-nda mona o ukexilu ua ku lungulula o kijimbuete kiki, mu ukexilu uéngi.\/\/ >>> even_odd_count(-12)\n\/\/ []interface{}{1, 1}\n\/\/ >>> even_odd_count(123)\n\/\/ []interface{}{1, 2}\nfunc even_odd_count(num int) []interface{} {\n","canonical_solution":"func even_odd_count(num int) []interface{} {\n    \/\/ Handle negative numbers by taking the absolute value\n    if num < 0 {\n        num = -num\n    }\n    \n    evenCount, oddCount := 0, 0\n\n    \/\/ Iterate over each digit in the number\n    for num > 0 {\n        digit := num % 10\n        if digit%2 == 0 {\n            evenCount++\n        } else {\n            oddCount++\n        }\n        num \/= 10\n    }\n\n    return []interface{}{evenCount, oddCount}\n}\n\nfunc TestEvenOddCount(t *testing.T) {\n    testCases := []struct {\n        input    int\n        expected []interface{}\n    }{\n        {-12, []interface{}{1, 1}},\n        {123, []interface{}{1, 2}},\n        {2468, []interface{}{4, 0}},\n        {1357, []interface{}{0, 4}},\n        {0, []interface{}{1, 0}},\n    }\n\n    for _, testCase := range testCases {\n        result := even_odd_count(testCase.input)\n        if fmt.Sprintf(\"%v\", result) != fmt.Sprintf(\"%v\", testCase.expected) {\n            t.Errorf(\"even_odd_count(%d) = %v; expected %v\", testCase.input, result, testCase.expected)\n        }\n    }\n}","tests":"func TestEven_Odd_Count(t *testing.T) {\n  candidate := even_odd_count\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(7), expected: []interface{}{0, 1} },\n     { actual: candidate(-78), expected: []interface{}{1, 1} },\n     { actual: candidate(3452), expected: []interface{}{2, 2} },\n     { actual: candidate(346211), expected: []interface{}{3, 3} },\n     { actual: candidate(-345821), expected: []interface{}{3, 3} },\n     { actual: candidate(-2), expected: []interface{}{1, 0} },\n     { actual: candidate(-45347), expected: []interface{}{2, 3} },\n     { actual: candidate(0), expected: []interface{}{1, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_156","nl":"kmb_Latn","pl":"go_test.go","prompt":"package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu ia ku bhanga kiki: \/\/O jimbambe: 1 <= num <= 1000 \/\/Mu kusuluka, soneka-mu o diambu di ua mesena.\/\/Mu ku bhana o kijimbuete kia tenena, tala o kijimbuete kia mukuá mu dimi dia Loma, \/\/ >>> int_to_mini_roman(19)\n\/\/ \"xix\"\n\/\/ >>> int_to_mini_roman(152)\n\/\/ \"clii\"\n\/\/ >>> int_to_mini_roman(426)\n\/\/ \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n","canonical_solution":"package int_to_mini_roman_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc int_to_mini_roman(number int) string {\n\tvals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\tsymbols := []string{\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n\n\tvar roman strings.Builder\n\n\tfor i := 0; i < len(vals); i++ {\n\t\tfor number >= vals[i] {\n\t\t\tnumber -= vals[i]\n\t\t\troman.WriteString(symbols[i])\n\t\t}\n\t}\n\treturn roman.String()\n}\n\nfunc TestIntToMiniRoman(t *testing.T) {\n\ttests := []struct {\n\t\tinput    int\n\t\texpected string\n\t}{\n\t\t{19, \"xix\"},\n\t\t{152, \"clii\"},\n\t\t{426, \"cdxxvi\"},\n\t\t{1000, \"m\"},\n\t\t{1, \"i\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d\", tt.input), func(t *testing.T) {\n\t\t\tresult := int_to_mini_roman(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Fatalf(\"expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","tests":"func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_157","nl":"kmb_Latn","pl":"go_test.go","prompt":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/90 a ji kilómetulu.\/\/O dikolombolo didi, diala ni mbandu imoxi ia diametulu, mba mbandu ia mukuá ia diametulu.\/\/O ku tala kiambote o jithéthembua, ki kuatekesa kuijiia kiambote o ima ia mu bhita ku diulu.\/\/O mbandu ia katatu, ia tokala kukala ni izuwa itatu.\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/ true\n\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/ false\nfunc right_angle_triangle(a int, b int, c int) bool {\n","canonical_solution":"package right_angle_triangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc right_angle_triangle(a int, b int, c int) bool {\n    \/\/ Squaring the sides\n    a2, b2, c2 := a*a, b*b, c*c\n    \/\/ Check the Pythagorean theorem for the combination of sides\n    return a2+b2 == c2 || a2+c2 == b2 || b2+c2 == a2\n}","tests":"func TestRight_Angle_Triangle(t *testing.T) {\n  candidate := right_angle_triangle\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 4, 5), expected: true },\n     { actual: candidate(1, 2, 3), expected: false },\n     { actual: candidate(10, 6, 8), expected: true },\n     { actual: candidate(2, 2, 2), expected: false },\n     { actual: candidate(7, 24, 25), expected: true },\n     { actual: candidate(10, 5, 7), expected: false },\n     { actual: candidate(5, 12, 13), expected: true },\n     { actual: candidate(15, 8, 17), expected: true },\n     { actual: candidate(48, 55, 73), expected: true },\n     { actual: candidate(1, 1, 1), expected: false },\n     { actual: candidate(2, 2, 10), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_158","nl":"kmb_Latn","pl":"go_test.go","prompt":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O ukexilu ua ku soneka o izuelu mu divulu, u kuatekesa o muthu ku tendela kiambote o ima.\/\/Se o jiletala jala ni ijimbuete iavulu, mu kijimbuete kimoxi ngó, o ijimbuete ioso ia tokala ku kala ni ijimbuete imoxi.\/\/Mu milongi íii, tu sanga-mu izuelu iavulu, mu kiki, tu tena ku soneka o izuelu i tua mesena mu mbandu ia dianga.\/\/Soneka o ifua ia fuama phala kulondekesa o mbandu ia fuama.\/\/ >>> find_max([]string{\"name\", \"of\", \"string\"})\n\/\/ \"string\"\n\/\/ >>> find_max([]string{\"name\", \"enam\", \"game\"})\n\/\/ \"enam\"\n\/\/ >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\/\/ \"aaaaaaa\"\nfunc find_max(words []string) string {\n","canonical_solution":"package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n    \"sort\"\n)\n\nfunc find_max(words []string) string {\n    maxWord := \"\"\n    maxUnique := 0\n    \n    for _, word := range words {\n        uniqueChars := countUniqueChars(word)\n        if uniqueChars > maxUnique {\n            maxUnique = uniqueChars\n            maxWord = word\n        } else if uniqueChars == maxUnique {\n            if maxWord == \"\" || word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    \n    return maxWord\n}\n\nfunc countUniqueChars(word string) int {\n    charSet := make(map[rune]struct{})\n    for _, c := range word {\n        charSet[c] = struct{}{}\n    }\n    return len(charSet)\n}\n\n\/\/ Test case runs to verify the solution\nfunc TestFindMax(t *testing.T) {\n    testCases := []struct {\n        input []string\n        expected string\n    }{\n        {[]string{\"name\", \"of\", \"string\"}, \"string\"},\n        {[]string{\"name\", \"enam\", \"game\"}, \"enam\"},\n        {[]string{\"aaaaaaa\", \"bb\", \"cc\"}, \"aaaaaaa\"},\n    }\n\n    for _, tc := range testCases {\n        result := find_max(tc.input)\n        if result != tc.expected {\n            t.Errorf(\"For input %v, expected %s, but got %s\", tc.input, tc.expected, result)\n        } else {\n            fmt.Printf(\"Test passed for input %v\\n\", tc.input)\n        }\n    }\n}","tests":"func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_159","nl":"kmb_Latn","pl":"go_test.go","prompt":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/Se o jimbolo ja touala, ki ji soko, eie ua-nda ji dia joso maji kua-nda kala ni nzala.\/\/o mbolo i ua kexile mu dia mu usuku] \/\/[o kudia kua bolo, mu kudia o mbolo ioso i u dia, \/\/Maji lelu ua tokala u dia dingi muzonge phala ku zubha o mbolo ia kizuua.\/\/Eie u kala ni nzala iavulu, maji né kiki, u dia hanji jimbolo javulu.\/\/ >>> eat(5, 6, 10)\n\/\/ []int{11, 4}\n\/\/ >>> eat(4, 8, 9)\n\/\/ []int{12, 1}\n\/\/ >>> eat(1, 10, 10)\n\/\/ []int{11, 0}\n\/\/ >>> eat(2, 11, 5)\n\/\/ []int{7, 0}\n\/\/ Variables:\n\/\/ @number : integer\n\/\/ the number of carrots that you have eaten.\n\/\/ @need : integer\n\/\/ the number of carrots that you need to eat.\n\/\/ @remaining : integer\n\/\/ the number of remaining carrots thet exist in stock\n\/\/ Constrain:\n\/\/ * 0 <= number <= 1000\n\/\/ * 0 <= need <= 1000\n\/\/ * 0 <= remaining <= 1000\n\/\/ Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n","canonical_solution":"package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/ eat calculates the total number of eaten carrots after meals and the number of carrots left.\nfunc eat(number int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{number + need, remaining - need}\n    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n    tests := []struct {\n        number, need, remaining int\n        expected                []int\n    }{\n        {5, 6, 10, []int{11, 4}},\n        {4, 8, 9, []int{12, 1}},\n        {1, 10, 10, []int{11, 0}},\n        {2, 11, 5, []int{7, 0}},\n    }\n\n    for _, test := range tests {\n        result := eat(test.number, test.need, test.remaining)\n        if result[0] != test.expected[0] || result[1] != test.expected[1] {\n            t.Errorf(\"eat(%d, %d, %d) = %v; expected %v\", test.number, test.need, test.remaining, result, test.expected)\n        }\n    }\n}","tests":"func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_160","nl":"kmb_Latn","pl":"go_test.go","prompt":"package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/O kijimbuete kia mukuá, kiala ni kijimbuete kimoxi ngó, o kijimbuete kia mukuá, kiala ni kijimbuete kia kaiiadi.\/\/O kijimbuete kia mukuá, o kijimbuete kia mukuá.\/\/O ku kondala kua muxi, ku lombolola kuila o muxi iú, a u bhange mu ukexilu umoxi.\/\/[Tanga mu luji]\/\/=> O disukilu dia kitambuijilu = 9 \/\/Mu kiki, o kitambuijilu ki kala 2 + 3 * 4 - 5 \/\/[2, 3, 4, 5] \/\/o muendexi u zuela: ['+', '*', '-'] \/\/Mu kifika: \/\/Ku di bandekesa (**) \/\/O ku uana o ima ioso mu ididi imoxi, ki ku bhingi ku i uana mu ididi iavulu\/\/Ku vunda (*) \/\/Ku katula ( - ) \/\/Ku bandekesa (+) \/\/O ifika íii, ia lungu ni ku bhanga o kifika kia difuangana ni fikula ia mu londekesa o muxi.\/\/O ku bhanga kiki, kua-nda ku kuatekesa ku tendela kiambote o ima.\/\/O mbandu ia kaiiadi, ia lungu ni tu mikanda tua mukuá, tu tena ku i sanga mu madivulu a mukuá.\/\/O mbandu ia dianga, ia lungu ni ku kondala o ikoka, ni ia mukuá, ia lungu ni ku kondala o ikoka.func do_algebra(operator []string, operand []int) int {\n","canonical_solution":"package do_algebra_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc do_algebra(operator []string, operand []int) int {\n    if len(operator) != len(operand)-1 {\n        return 0\n    }\n\n    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n            result *= operand[i+1]\n        case \"\/\/\":\n            result \/= operand[i+1]\n        case \"**\":\n            result = intPow(result, operand[i+1])\n        }\n    }\n\n    return result\n}\n\nfunc intPow(base, exp int) int {\n    result := 1\n    for exp != 0 {\n        if exp%2 == 1 {\n            result *= base\n        }\n        exp \/= 2\n        base *= base\n    }\n    return result\n}\n\nfunc TestDoAlgebra(t *testing.T) {\n    operators := []string{\"+\", \"*\", \"-\"}\n    operands := []int{2, 3, 4, 5}\n    expectedResult := 9\n    result := do_algebra(operators, operands)\n    if result != expectedResult {\n        t.Errorf(\"expected %d but got %d\", expectedResult, result)\n    }\n\n    fmt.Println(\"All tests passed.\")\n}","tests":"func TestDo_Algebra(t *testing.T) {\n  candidate := do_algebra\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"**\", \"*\", \"+\"}, []int{2, 3, 4, 5}), expected: 37 },\n     { actual: candidate([]string{\"+\", \"*\", \"-\"}, []int{2, 3, 4, 5}), expected: 9 },\n     { actual: candidate([]string{\"\/\/\", \"*\"}, []int{7, 3, 4}), expected: 8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_161","nl":"kmb_Latn","pl":"go_test.go","prompt":"package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Phangu \/\/O mbandu íii, ia tokala ku i soneka mu ukexilu ua iuka.\/\/Se o kijimbuete ki ua mesena kulondekesa ki ki moneka, lungulula o kijimbuete kiki.\/\/Se ki kiene, o ima i mua zuela, i kale kala kia i soneka.\/\/se o kijimbuete kia i, o kijimbuete kia i, mu veji dia i kale o kijimbuete kia dianga, o kijimbuete kia kaiiadi, mu veji dia ku kala o kijimbuete kia dianga, \/\/Ua-nda tambula milongi iavulu.\/\/ >>> solve(\"1234\")\n\/\/ \"4321\"\n\/\/ >>> solve(\"ab\")\n\/\/ \"AB\"\n\/\/ >>> solve(\"#a@C\")\n\/\/ \"#A@c\"\nfunc solve(s string) string {\n","canonical_solution":"package solve_test\n\nimport (\n    \"unicode\"\n)\n\nfunc solve(s string) string {\n    hasLetter := false\n    result := []rune(s)\n\n    for i, char := range result {\n        if unicode.IsLetter(char) {\n            hasLetter = true\n            if unicode.IsUpper(char) {\n                result[i] = unicode.ToLower(char)\n            } else {\n                result[i] = unicode.ToUpper(char)\n            }\n        }\n    }\n\n    if !hasLetter {\n        \/\/ reverse the string\n        for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {\n            result[i], result[j] = result[j], result[i]\n        }\n    }\n\n    return string(result)\n}","tests":"func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"},{"task_id":"HumanEval_163","nl":"kmb_Latn","pl":"go_test.go","prompt":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\/\/Mu kifika: \/\/b, mu ku bandekesa o ibuka. \/\/Mu ku bhana o kijimbuete a ni b, soneka o kijimbuete a ni b mu kaxi ka a \/\/ >>> generate_integers(2, 8)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(8, 2)\n\/\/ []int{2, 4, 6, 8}\n\/\/ >>> generate_integers(10, 14)\n\/\/ []int{}\nfunc generate_integers(a int, b int) []int {\n","canonical_solution":"package generate_integers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc generate_integers(a int, b int) []int {\n    start, end := a, b\n    if a > b {\n        start, end = b, a\n    }\n    \n    result := []int{}\n    for i := start; i <= end; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestGenerateIntegers(t *testing.T) {\n    tests := []struct {\n        a, b int\n        want []int\n    }{\n        {2, 8, []int{2, 4, 6, 8}},\n        {8, 2, []int{2, 4, 6, 8}},\n        {10, 14, []int{}},\n    }\n    \n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"generate_integers(%d, %d)\", tt.a, tt.b), func(t *testing.T) {\n            got := generate_integers(tt.a, tt.b)\n            if len(got) != len(tt.want) {\n                t.Errorf(\"expected %v, got %v\", tt.want, got)\n                return\n            }\n            for i := range got {\n                if got[i] != tt.want[i] {\n                    t.Errorf(\"expected %v, got %v\", tt.want, got)\n                    return\n                }\n            }\n        })\n    }\n}","tests":"func TestGenerate_Integers(t *testing.T) {\n  candidate := generate_integers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2, 10), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(10, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(132, 2), expected: []int{2, 4, 6, 8} },\n     { actual: candidate(17, 89), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"}]