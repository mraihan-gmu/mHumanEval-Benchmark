task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Ελέγξτε αν σε δεδομένο διάνυσμα αριθμών, υπάρχουν δύο αριθμοί πιο κοντά ο ένας στον άλλο από το δεδομένο όριο. >>> έχει_κοντά_στοιχεία ({}), ({}), ({}), ({}), ({}) ({}) ({}) ({}) ({}) ({}) ({}) ({}) ({}) ({}) ({}) ({}) ({}) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) ({) (}) ({) ({) (}) ({) ({) (}) ({) ({) (}) ({) (}) ({) (}) ({) (}) ({) (}) ({) (}) (}) ({) (}) (}) (}) ({) (}) (}) (}) ({) (}) (}) (}) (}) (}) (}) (}) (}) ({) (}) (}) (}) (}) (}) (
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η εισροή σε αυτή τη συνάρτηση είναι μια σειρά γραμμών που περιέχει πολλαπλές ομάδες ενσωματωμένων παρενθέσεων. Στόχος σας είναι να χωρίσετε αυτές τις ομάδες σε ξεχωριστές σειρές και να επιστρέψετε το διανύστη αυτών. Οι ξεχωριστές ομάδες είναι ισορροπημένες (κάθε ανοιχτή στήλη είναι σωστά κλειστή) και δεν ενσωματωμένες η μία μέσα στην άλλη Αγνοήστε τυχόν διαστήματα στην σειρά εισόδου. >>> separate_paren_groups(""(( ) (() ((( ))))) (std::vector<std::string>(({(std::string) "")"", (((())::"" (std::string) ""(((())))))
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Με δεδομένο θετικό αριθμό πλωτής κλίμακας, μπορεί να αποσυντεθεί σε ακεραίο μέρος (μεγαλύτερο ακέραιο μικρότερο από τον δεδομένο αριθμό) και δεκαδικά (απομεινόμενο μέρος πάντα μικρότερο από 1).
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένας διανύστης των πράξεων κατάθεσης και ανάληψης σε έναν τραπεζικό λογαριασμό που ξεκινά με μηδενικό υπόλοιπο. Το καθήκον σας είναι να ανιχνεύσετε αν σε οποιοδήποτε σημείο το υπόλοιπο του λογαριασμού πέσει κάτω από το μηδέν, και σε αυτό το σημείο η συνάρτηση θα πρέπει να επιστρέψει true. Διαφορετικά θα πρέπει να επιστρέψει false. >>> below_zero(((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (true)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Για ένα δεδομένο διανύστη αριθμών εισόδου, υπολογίστε τη μέση απόλυτη απόκλιση γύρω από το μέσο όρο αυτού του συνόλου δεδομένων. Η μέση απόλυτη απόκλιση είναι η μέση απόλυτη διαφορά μεταξύ κάθε στοιχείου και ενός κεντρικού σημείου (μέσος όρος σε αυτή την περίπτωση): MAD = ο μέσος όρος x - x_μέσος όρος >>> mean_absolute_deviation (((std::vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Εισάγετε έναν αριθμό ""διαμετρητή"" μεταξύ κάθε δύο διαδοχικών στοιχείων του εισερχόμενου διανύστη `numbers' >>> intersperse((std::vector<long>()), (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1, (long) 2, (long) 3}), (4)) (std::vector<long>({long) 1, (long) 4, (long) 2, (long) 4, (long) 3}))
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η είσοδος σε αυτή τη συνάρτηση είναι μια σειρά που αντιπροσωπεύει πολλαπλές ομάδες για ενσωματωμένες παρενθέσεις χωρισμένες με κενά. Για κάθε ομάδα, εκπέμπει το βαθύτερο επίπεδο ενσωμάτωσης παρενθέσεων.
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Φιλτράρει ένα εισερχόμενο διανύστη συμβολοσειρών μόνο για εκείνα που περιέχουν δεδομένη υποσύνδεση >>> filter_by_substring((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_substring((((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""})), (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Για ένα δεδομένο διπλό ακέραιων αριθμών, επιστρέφει ένα tuple που αποτελείται από το άθροισμα και το γινόμενο όλων των ακέραιων αριθμών σε ένα διπλό. Το άδειο άθροισμα θα πρέπει να είναι ίσο με το 0 και το άδειο γινόμενο θα πρέπει να είναι ίσο με το 1. >>> sum_product(((std::vector<long>())) (std::make_tuple(0, 1)) >>> sum_product(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple(10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Από ένα δεδομένο διάνυσμα ακέραιων αριθμών, δημιουργήστε ένα διάνυσμα του κυλιόμενου μέγιστου στοιχείου που βρέθηκε μέχρι δεδομένη στιγμή στη σειρά. >>> rolling_max(((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Βρείτε το μικρότερο παλινδρόμιο που αρχίζει με μια προμηθευμένη αλυσίδα. Η ιδέα του αλγόριθμου είναι απλή: - Βρείτε το μεγαλύτερο postfix της προμηθευμένης αλυσίδας που είναι παλινδρόμιο. - Προσθέστε στο τέλος της αλυσίδας αντίστροφο προθέματος αλυσίδας που έρχεται πριν από το παλινδρομικό επίθετο. >>> make_palindrome ((("""")) ("""") >>> make_palindrome (((""cat"")) (""catac"") >>> make_palindrome (((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η είσοδος είναι δύο σειρές α και β που αποτελούνται μόνο από 1 και 0. Εκτελέστε δυαδικό XOR σε αυτές τις εισόδους και επιστρέψτε το αποτέλεσμα επίσης ως μια σειρά.
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Από το διανύστη των συμβολοσειρών, επιστρέφει το μακρύτερο. Επιστρέφει το πρώτο σε περίπτωση πολλαπλών συμβολοσειρών του ίδιου μήκους. Επιστρέφει το None σε περίπτωση που ο διανύστης εισόδου είναι κενός. >>> longest(((std::vector<std::string>())) std::nullopt >>> longest(((std::vector<std::string>{((std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest((((std::vector<std::string>({(std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει τον μέγιστο κοινό διαιρέτη δύο ακέραιων α και β >>> μέγιστος_κοινός_διαιρέτης (((3), (5)) (1) >>> μέγιστος_κοινός_διαιρέτης (((25), (15)) (5)
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει το διανύστη όλων των προθεσμιών από το συντομότερο στο μακρύτερο της συμβολοσειράς εισόδου >>> all_prefixes (((""abc"")) (std::vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει μια σειρά που περιέχει αριθμούς με οριοθετημένο χώρο που αρχίζουν από το 0 μέχρι και το n. >>> string_sequence((0)) (""0"") >>> string_sequence((5)) (""0 1 2 3 4 5"")
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Με δεδομένη μια σειρά, βρείτε πόσους διακριτούς χαρακτήρες (ανεξάρτητα από την περίπτωση) αποτελείται από >>> count_distinct_characters (((""xyzXYZ"")) (3) >>> count_distinct_characters (((""Jerry"")) (4)
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η εισαγωγή σε αυτή τη συνάρτηση είναι μια χορδή που αντιπροσωπεύει μουσικές νότες σε μορφή ASCII. Το έργο σας είναι να αναλύσετε το φεγγάρι χορδών των ακέραιων που αντιστοιχεί σε πολλούς ρυθμούς. Εδώ είναι ένας θρύλος: 'o' note, lasts four beats 'o, 256' - lasts half note, lasts two beats 'o, 256' - lasts quater note, lasts one beat >>> parse_music.
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Βρείτε πόσες φορές μπορεί να βρεθεί μια δεδομένη υποσύνδεση στην αρχική αλυσίδα. Μετρήστε τις αλληλεπικαλυπτόμενες περιπτώσεις. >>> how_many_times((""""), (""a"")) (0) >>> how_many_times(""aaa""), (""a"") (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η είσοδος είναι μια αλυσίδα με αριθμητικά στοιχεία από το ""μηδέν"" έως το ""νέα"". Οι έγκυρες επιλογές είναι το ""μηδέν"", το ""ένα"", το ""δύο"", το ""τρεις"", το ""τέσσερα"", το ""πέντε"", το ""έξι"", το ""επτά"", το ""οκτώ"" και το ""νέα"". Επιστρέφει την αλυσίδα με αριθμούς ταξινομημένους από το μικρότερο στο μεγαλύτερο >>> sort_numbers((""three one five"")) (""one three five"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Από ένα δοθέντα διανύστη αριθμών (μήρους τουλάχιστον δύο) επιλέξτε και επιστρέψτε δύο που είναι τα πλησιέστερα μεταξύ τους και επιστρέψτε τα με τη σειρά (μικρότερος αριθμός, μεγαλύτερος αριθμός). >>> find_closest_elements (βλ. παρακάτω)
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διάνυσμα αριθμών (τουλάχιστον δύο στοιχείων), εφαρμόστε ένα γραμμικό μετασχηματισμό σε αυτό το διάνυσμα, έτσι ώστε ο μικρότερος αριθμός να γίνει 0 και ο μεγαλύτερος να γίνει 1 >>> rescale_to_unit (συνδυασμός)
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Φίλτρο δεδομένου διανύστης οποιωνδήποτε τιμών cppthon μόνο για ακέραιους αριθμούς >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>(()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει το μήκος της δεδομένης αλυσίδας >>> string_length(("""")) (0) >>> string_length((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Για έναν δεδομένο αριθμό n, βρείτε τον μεγαλύτερο αριθμό που διαιρεί n ομοιόμορφα, μικρότερο από n >>> μεγαλύτερος_διαμεριστής (συνήθως)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει το διάνυσμα των πρώτων παραγόντων ενός δεδομένου ακέραιου αριθμού από τη μικρότερη στην μεγαλύτερη σειρά. Κάθε ένας από τους παράγοντες θα πρέπει να είναι διάνυσμα αριθμό φορές που αντιστοιχεί σε πόσες φορές εμφανίζεται σε παραγοντοποίηση. Ο αριθμός εισόδου θα πρέπει να είναι ίσος με το προϊόν όλων των παραγόντων >>> παραγοντοποίηση (((8)) (std:: vector<long> (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Από ένα διάνυσμα ακέραιων αριθμών, αφαιρέστε όλα τα στοιχεία που εμφανίζονται περισσότερες από μία φορές. Κρατήστε την σειρά των στοιχείων που έχουν μείνει ίδια με την εισροή. >>> remove_duplicates(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Για μια δεδομένη σειρά, αναστρέψτε μικρογραφικούς χαρακτήρες σε μεγάλα και μεγάλα σε μικρογραφικά. >>> flip_case (((""Hello"")) (""hELLO"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Συγκεντρώστε το διανύστη των χορδών σε μια ενιαία χορδή >>> συσπειρώστε ((((std::vector<std::string>())) ("""") >>> συσπειρώστε (((std::vector<std::string>({(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) (""abc"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Φιλτράρει ένα εισερχόμενο διανύστη συμβολοσειρών μόνο για εκείνα που αρχίζουν με ένα δεδομένο πρόθεμα. >>> filter_by_prefix((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string) ""cde"", (stdstring) ""array""})), (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει μόνο θετικούς αριθμούς στον διανύστη. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive((std::vector<long>({long) -5, (long) -3, (long) -5, (long) -2, (long) -3, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει true αν ένας δεδομένος αριθμός είναι πρώτος και false διαφορετικά. >>> is_prime((6)) (false) >>> is_prime((101)) (true) >>> is_prime((11) (true) >>> is_prime((13441)) (true) >>> is_prime(61)) (true) >>> is_prime(4)) (false) >>> is_prime(1)) (false)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Αυτή η συνάρτηση παίρνει ένα διανύστη l και επιστρέφει ένα διανύστη l' έτσι ώστε το l' να είναι πανομοιότυπο με το l στα δείγματα που δεν είναι διαιρετά με το τρία, ενώ οι τιμές του στα δείγματα που είναι διαιρετά με το τρία είναι ίσες με τις τιμές των αντίστοιχων δείκτων του l, αλλά ταξινομημένα.
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει ταξινομημένα μοναδικά στοιχεία σε έναν διανύστη >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει το μέγιστο στοιχείο στο διανύστη. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long)-5, (long) 2, (long)-3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει τον αριθμό των εμφανίσεων του ψηφίου 7 σε ακέραιους αριθμούς μικρότερους από n οι οποίοι διαιρούνται με 11 ή 13. >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Αυτή η συνάρτηση παίρνει ένα διανύστη l και επιστρέφει ένα διανύστη l' έτσι ώστε το l' να είναι πανομοιότυπο με το l στα αρίθμητα δείγματα, ενώ οι τιμές του στα ζυγαριά δείγματα είναι ίσες με τις τιμές των ζυγαριών δείκτων του l, αλλά ταξινομημένες. >>> sort_even{(std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even{(std::vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std::vector<(long>{((long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib επιστρέφει τον n-ο αριθμό που είναι ένας αριθμός Φιμπονάτσι και είναι επίσης πρώτος. >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib((3)) (5) >>> prime_fib((4)) (13) >>> prime_fib(5)) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Το triple_sum_to_zero παίρνει ένα διάνυσμα ακέραιων αριθμών ως εισροή. Επιστρέφει true αν υπάρχουν τρία ξεχωριστά στοιχεία στο διάνυσμα που αθροίζονται στο μηδέν, και false διαφορετικά. >>> triple_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triple_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (true) triple_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) triple_sum_to_zero(((std::vector<long>{long> (long) 2, (long) 4, (long) 5, (long) 3, (long) 9, (long)) (true)) triple_sum_to_zero))) (long_long) >>> (long_vector) >>> (long_long)
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Φανταστείτε μια οδό που είναι μια τέλεια ευθεία άπειρα μεγάλη γραμμή. n αυτοκίνητα οδηγούν αριστερά προς τα δεξιά, ταυτόχρονα, ένα διαφορετικό σύνολο από n αυτοκίνητα οδηγούν δεξιά προς τα αριστερά. Τα δύο σύνολα αυτοκινήτων ξεκινούν πολύ μακριά από το ένα το άλλο. Όλα τα αυτοκίνητα κινούνται με την ίδια ταχύτητα. Δύο αυτοκίνητα λέγεται ότι συγκρούονται όταν ένα αυτοκίνητο που κινείται αριστερά προς τα δεξιά χτυπά ένα αυτοκίνητο που κινείται δεξιά προς τα αριστερά. Ωστόσο, τα αυτοκίνητα είναι άπειρα γερά και ισχυρά. Ως αποτέλεσμα, συνεχίζουν να κινούνται στην τροχιά τους σαν να μην συγκρούστηκαν. Αυτή η συνάρτηση εκπέμπει τον αριθμό τέτοιων συγκρούσεων.
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει το διανύστη με στοιχεία αυξημένα κατά 1. >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>{long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Το pairs_sum_to_zero παίρνει ένα διάνυσμα ακέραιων αριθμών ως εισροή. Επιστρέφει true αν υπάρχουν δύο ξεχωριστά στοιχεία στο διάνυσμα που αθροίζονται στο μηδέν, και false διαφορετικά. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long>{long>(((2, (long) (long) (4, (long) (long) (5, (long) 3, (long) 5, (long) 7))) (true)) >>> pairs_sum_to_zero))) (true) >>> (long_se) >>> (long_vector) >>>
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Αλλαγή αριθμητικής βάσης του αριθμού εισόδου x σε βάση. επιστροφή παράστασης χορδής μετά τη μετατροπή. αριθμοί βάσης είναι μικρότεροι από 10. >>> change_base((8), (3)) (""22"") >>> change_base((8), (2)) (""1000"") >>> change_base((7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνεται το μήκος μιας πλευράς και η υψηλή περιοχή επιστροφής για ένα τρίγωνο. >>> triangle_area((5), (3)) (7.5f)
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η αλληλουχία αριθμών Fib4 είναι μια αλληλουχία παρόμοια με τη σειρά Fibbonacci που ορίζεται ως εξής: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Παρακαλούμε γράψτε μια συνάρτηση για να υπολογίσετε αποτελεσματικά το n-το στοιχείο της αλληλουχίας αριθμών fib4. Μην χρησιμοποιείτε την επανάληψη. >>> fib4((5)) (4) >>> fib4((6)) (8) >>> fib4((7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστροφή μεσαίας διαμέτρου των στοιχείων στο διανύστη l. >>> μεσαία διαμέτρου (long) 1, (long) 2, (long) 4, (long) 5))) (float) 3) >>> μεσαία διαμέτρου (long) 6, (long) 1000, (long) 10, (long) 20))) (15.0f)
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Ελέγχει αν η δεδομένη αλυσίδα είναι ένα παλινδρόμιο >>> is_palindrome ((("""")) (true) >>> is_palindrome (((""aba"")) (true) >>> is_palindrome (((""aaaaa"")) (true) >>> is_palindrome (((""zbcd"")) (false)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει 2 ^ n modulo p (να γνωρίζετε τους αριθμούς). >>> modp(((3), (5)) (3) >>> modp((1101), (101)) (2) >>> modp((0), (101)) (1) >>> modp((3), (11)) (8) >>> modp((100), (101) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels είναι μια συνάρτηση που παίρνει string και επιστρέφει string χωρίς φωνήεντα. >>> remove_vowels(("""")) ("""") >>> remove_vowels((""abcdef"")) (""bcdf"") >>> remove_vowels((""aaaaa"")) ("""") >>> remove_vowels(""aaBAA"")) (""B"") >>> remove_vowels((""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει true αν όλοι οι αριθμοί στον διανύστη l είναι κάτω από το όριο t. >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Προσθέστε δύο αριθμούς x και y >>> προσθέστε ((((2), (3)) (5) >>> προσθέστε (((5), (7)) (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Ελέγξτε αν δύο λέξεις έχουν τους ίδιους χαρακτήρες. >>> same_chars((""eabcdzzzz""), (""dddzzzzzzdeddabc"")) (true) >>> same_chars((""abcd""), (""dddddddabc"")) (true) >>> same_chars(""dddddddabc""), (""abcd"") (true) >>> same_chars((""eabcd""), (""dddddddabc"")) (false) same_chars >>>""((abcd""), (""dddddddabce"") (false) >>> same_chars((""eabcd""), (""ddddzzzzzddddddabc"") (false)
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει τον n-το αριθμό Φιμπονάτσι. >>> fib((10)) (55) >>> fib((1)) (1) >>> fib((8)) (21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets είναι μια σειρά από ""<"" και "">"". επιστρέφει true αν κάθε ανοιχτή κορδέλα έχει μια αντίστοιχη κλειστή κορδέλα. >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>"")) (true) >>> correct_bracketing("">(<>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει true είναι τα στοιχεία του διανύστη αυξάνονται ή μειώνονται μονοτονικά. >>> monotonic(((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (true) >>> monotonic(((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (false) >>> monotonic(((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (true)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει ταξινομημένα μοναδικά κοινά στοιχεία για δύο διανύστες. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>{(long) 5, (long) 3, (long) 2, (long) 8}), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long>{long} 2, (long) 3))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Επιστρέφει τον μεγαλύτερο πρώτον παράγοντα του αριθμού n. Υποθέστε ότι ο αριθμός n > 1 δεν είναι πρώτος. >>> largest_prime_factor (((13195)) (29) >>> largest_prime_factor (((2048)) (2)
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// η συνάθροιση από 1 έως n είναι μια συνάρτηση που αθροίζει αριθμούς από το 1 έως το n. >>> η συνάθροιση από 1 έως n.
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ορθοπερατώματα είναι μια σειρά από ""("" και "")"". επιστρέφει true αν κάθε ανοιχτή παρενίχρηση έχει μια αντίστοιχη κλειστή παρενίχρηση. >>> correct_bracketing((""("")) (false) >>> correct_bracketing(""()
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs αντιπροσωπεύουν συντελεστές πολυωνύμου. xs[0] + xs[1] * x + xs[2] * x^2 + .... Επιστρέφει παράγωγο αυτού του πολυωνύμου με την ίδια μορφή. >>> παράγωγο((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> παράγωγο::std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η αλληλουχία αριθμών FibFib είναι μια αλληλουχία παρόμοια με τη σειρά Fibbonacci που ορίζεται ως εξής: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Παρακαλούμε γράψτε μια συνάρτηση για να υπολογίσετε αποτελεσματικά το n-το στοιχείο της αλληλουχίας αριθμών fibfib. >>> fibfib((1)) (0) >>> fib((5)) (4) >>> fib((8)) (24)
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση vowels_count η οποία παίρνει μια σειρά λέξεων ως εισερχόμενη και επιστρέφει τον αριθμό των φωνητικών στην σειρά. Οι φωνητικοί σε αυτή την περίπτωση είναι 'a', 'e', 'i', 'o', 'u'. Εδώ, το 'y' είναι επίσης ένας φωνητικός, αλλά μόνο όταν βρίσκεται στο τέλος της δεδομένης λέξης. Παράδειγμα: >>> vowels_count (((""abcde"")) (2) >>> vowels_count ((""ACEDY"") (3)
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Κύκλος μετατόπιση των ψηφίων του ακέραιου αριθμού x, μετατόπιση των ψηφίων δεξιά με μετατόπιση και επιστρέφει το αποτέλεσμα ως μια σειρά. Εάν μετατόπιση > αριθμός ψηφίων, επιστρέφει ψηφία ανάποδα. >>> circular_shift((12), (1)) (""21"") >>> circular_shift((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δουλειά Γράψτε μια συνάρτηση που παίρνει μια σειρά ως εισερχόμενη και επιστρέφει το άθροισμα των ανώτερων χαρακτήρων μόνο κωδικών ASCII. Παραδείγματα: >>> digitSum(("""")) (0) >>> digitSum((""abAB"")) (131) >>> digitSum((""abcCd"")) (67) >>> digitSum((""helloE"")) (69) >>> digitSum((""woArBld"")) (131) >>> digitSum((""aAXaaaa"") (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σε αυτή την εργασία, θα σας δοθεί μια σειρά που αντιπροσωπεύει έναν αριθμό μήλων και πορτοκαλιών που κατανέμονται σε ένα καλάθι με φρούτα αυτό το καλάθι περιέχει μήλα, πορτοκάλια και φρούτα μάνγκο. Δεδομένης της σειράς που αντιπροσωπεύει τον συνολικό αριθμό των πορτοκαλιών και μήλων και έναν ακέραιο αριθμό που αντιπροσωπεύει τον συνολικό αριθμό των φρούτων στο καλάθι επιστρέψτε τον αριθμό των φρούτων μάνγκο στο καλάθι. για παράδειγμα: >>> fruit_distribution ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""Δεδομένου ενός διανύστη που αντιπροσωπεύει ένα κλάδο ενός δέντρου που έχει μη αρνητικούς ακέραιους κόμβους, το έργο σας είναι να αρπάξετε έναν από τους κόμβους και να τον επιστρέψετε. Ο αρπαγμένος κόμβος θα πρέπει να είναι ο κόμβος με τη μικρότερη ζυγαριά. Αν βρεθούν πολλαπλά κόμβοι με την ίδια μικρότερη ζυγαριά, επιστρέψτε τον κόμβο που έχει το μικρότερο δείκτη. Ο αρπαγμένος κόμβος θα πρέπει να επιστρέφεται σε ένα διανύστη, [small_value, το δείκτη του], Εάν δεν υπάρχουν ζυγαριά ή ο δεδομένος διανύστης είναι κενός, επιστρέψτε []. Παράδειγμα 1: >>> pluck(((stdvector<<(long>{(long) {4, (long) {2, (long) {3}))) (stdvector::::long} (long) (long) {0, (long)) (long)) (long) {0, (long)) (long)) (long)) (long)) (long) (long) (long) (long) (long) (long) (long)) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένας μη κενός διάνυσμος θετικών ακέραιων. Επιστρέφει το μεγαλύτερο ακέραιο που είναι μεγαλύτερο από το μηδέν και έχει συχνότητα μεγαλύτερη ή ίση με την τιμή του ίδιου του ακέραιου. Η συχνότητα ενός ακέραιου είναι ο αριθμός των φορές που εμφανίζεται στον διάνυσμα. Αν δεν υπάρχει τέτοια τιμή, επιστρέφει -1. Παραδείγματα: >>> search(((std::vector<long>{(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> search((std::vector<(long>1, (long) 2, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4, (long) 4} (3)))) >>> >>> search(std::vector<(long>{(long) 5, (long) 5, (long) 4, (long) 4, (long) 1} (long))
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διάνυσμα ακέραιων, επιστρέφουμε το διάνυσμα με παράξενη σειρά. Η παράξενη ταξινόμηση είναι όταν ξεκινάμε με την ελάχιστη τιμή, στη συνέχεια με τη μέγιστη των υπόλοιπων ακέραιων, στη συνέχεια με τη ελάχιστη και ούτω καθεξής. Παραδείγματα: >>> strange_sort_list{((((std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list<(((std::vector<(long>{(long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5}))) (std::vector<(long> >>> strange_sort_list<((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας τα μήκη των τριών πλευρών ενός τριγώνου. Επιστρέφει την περιοχή του τριγώνου στρογγυλοποιημένη σε 2 δεκαδικά ψηφία αν οι τρεις πλευρές σχηματίζουν ένα έγκυρο τρίγωνο. Διαφορετικά επιστρέφει -1 Τρεις πλευρές κάνουν ένα έγκυρο τρίγωνο όταν το άθροισμα των δύο πλευρών είναι μεγαλύτερο από την τρίτη πλευρά. Παράδειγμα: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που επιστρέφει true αν το αντικείμενο q θα πετάξει, και false διαφορετικά. Το αντικείμενο q θα πετάξει αν είναι ισορροπημένο (είναι ένα παλινδρομικό διάνυσμα) και το άθροισμα των στοιχείων του είναι μικρότερο ή ίσο με το μέγιστο δυνατό βάρος w. Παραδείγμα: >>> will_it_fly((std::vector<long>({long) 1, (long) 2}), (5)) (false) # 1+2 είναι μικρότερο από το μέγιστο δυνατό βάρος, αλλά είναι ανισορροπημένο. >>> will_it_fly((std::vector<long>(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διανύστη arr ακέραιων αριθμών, βρείτε τον ελάχιστο αριθμό στοιχείων που πρέπει να αλλάξουν για να γίνει ο διανύστης παλινδρόμικος. Ένας παλινδρόμικος διανύστης είναι ένας διανύστης που διαβάζεται ο ίδιος προς τα πίσω και προς τα εμπρός. Σε μια αλλαγή, μπορείτε να αλλάξετε ένα στοιχείο σε οποιοδήποτε άλλο στοιχείο. Για παράδειγμα: >>> smallest_change(std::vector<long>((long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 2} (1)))) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1} (0))))
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που δέχεται δύο διανύσματα συμβολοσειρών και επιστρέφει το διανύσμα που έχει συνολικό αριθμό χαρακτήρων σε όλες τις συμβολοσειρές του διανύματος λιγότερο από το άλλο διανύσμα. Αν τα δύο διανύσματα έχουν τον ίδιο αριθμό χαρακτήρων, επιστρέφει το πρώτο διανύσμα. Παραδείγματα >>> total_match (), (std::vector (), (std::string) (d) (hi), (std::string) (d) (hi), (std::string) (d) (hi), (std::string) (d) (hi), (std::string) (d) (hi), (std::string) (d) (hi), (std::string) (d) (hi), (std:string) (d) (hi) (d) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi) (hi (hi) (hi) (hi) (hi) (hi) (hi (hi) (hi) (hi) (hi) (hi (hi) (hi) (hi) (hi) (hi) (hi (hi) (hi) (hi) (hi) (hi (hi) (hi
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που επιστρέφει true αν ο αριθμός που δίδεται είναι ο πολλαπλασιασμός 3 πρώτων αριθμών και false διαφορετικά. Γνωρίζοντας ότι (α) είναι μικρότερο από 100.
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Το καθήκον σας είναι να γράψετε μια συνάρτηση που επιστρέφει true αν ένας αριθμός x είναι μια απλή δύναμη του n και false σε άλλες περιπτώσεις. x είναι μια απλή δύναμη του n αν n**int=x Για παράδειγμα: >>> is_simple_power((1), (4)) (true) >>> is_simple_power(2), (2)) (true) >>> is_simple_power(8), (2)) (true) >>> is_simple_power(3), (2)) (false) >>> is_simple_power(3), (1)) (false) >>> is_simple_power(5), (3)) (false)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που παίρνει έναν ακέραιο αριθμό a και επιστρέφει true αν αυτός ο αριθμός είναι ένας κύβος κάποιου ακέραιου αριθμού. Σημείωση: μπορείτε να υποθέσετε ότι η είσοδος είναι πάντα έγκυρη. Παραδείγματα: >>> iscube((1)) (true) >>> iscube((2)) (false) >>> iscube(-1)) (true) >>> iscube(64)) (true) >>> iscube(0)) (true) >>> iscube((180)) (false)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας έχει ανατεθεί να γράψετε μια συνάρτηση που λαμβάνει έναν εξαδεκαδικό αριθμό ως μια σειρά και μετρά τον αριθμό των εξαδεκαδικών ψηφίων που είναι πρώτοι (πρώτος αριθμός, ή ένας πρώτος, είναι ένας φυσικός αριθμός μεγαλύτερος από 1 που δεν είναι ένα προϊόν δύο μικρότερων φυσικών αριθμών). Τα εξαδεκαδικά ψηφία είναι 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, Α, Β, C, D, Ε, F. Οι πρώτοι αριθμοί είναι 2, 3, 5, 7, 11, 13, 17,... Έτσι, πρέπει να καθορίσετε έναν αριθμό από τους ακόλουθους ψηφία: 2, 3, 5, 7, B (= δεκαδική 11), D (= δεκαδική 13). Σημείωση: μπορείτε να υποθέσετε ότι η είσοδος είναι πάντα σωστή ή κενή, και τα σύμβολα A,B,C,D,E,F είναι πάντα με κεφαλαία γράμματα. Παραδείγματα: >>> hex_((AB""key"") (1) >>> hex_(((1077"") (2) >>> hex_(AB""key"") >>>ABC1"") (4) hex_((33"") >>>ABC1 ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Θα σας δοθεί ένας αριθμός σε δεκαδική μορφή και η εργασία σας είναι να τον μετατρέψετε σε δυαδικό μορφότυπο. Η συνάρτηση θα πρέπει να επιστρέψει μια σειρά, με κάθε χαρακτήρα που αντιπροσωπεύει έναν δυαδικό αριθμό. Κάθε χαρακτήρα στη σειρά θα είναι '0' ή '1'. Θα υπάρχει ένα επιπλέον ζευγάρι χαρακτήρων 'db' στην αρχή και στο τέλος της σειράς. Οι επιπλέον χαρακτήρες είναι εκεί για να βοηθήσουν με τη μορφή. Παραδείγματα: >>> δεκαδική_σε_διπλή((15)) (""db1111db"") >>> δεκαδική_σε_διπλή(32) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται μια αλυσίδα s. Η αποστολή σας είναι να ελέγξετε αν η αλυσίδα είναι hapcpp ή όχι. Μια αλυσίδα είναι hapcpp αν το μήκος της είναι τουλάχιστον 3 και κάθε 3 συνεχόμενα γράμματα είναι ξεχωριστά Για παράδειγμα: >>> is_happy(""a"")) (false) >>> is_happy(""aa"")) (false) >>> is_happy(""abcd"")) (true) >>> is_happy(""aabb"")) (false) >>> is_happy(""adb"")) (true) >>> is_happy(""xyy"") (false)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Είναι η τελευταία εβδομάδα του εξαμήνου και η δασκάλα πρέπει να δώσει τους βαθμούς στους μαθητές. Η δασκάλα έχει κάνει τον δικό της αλγόριθμο για βαθμολόγηση. Το μόνο πρόβλημα είναι ότι έχει χάσει τον κώδικα που χρησιμοποιούσε για βαθμολόγηση. Σας έχει δώσει ένα διανύστη βαθμολογίας για μερικούς μαθητές και πρέπει να γράψετε μια συνάρτηση που μπορεί να εκδώσει ένα διανύστη βαθμολογίας γράμματος χρησιμοποιώντας τον ακόλουθο πίνακα: GPA. Αριθμός γράμματος 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E Παράδειγμα: >>>_grade_equation((std::vector<float>({(float) 4.0f, (float) 3, (float) 1.7f, (float) 2, (float) 3.5f))) (d"" (d"" vector:{std::std::string:std::string:{(std""):d""A+ (d""string:d""string) (A""string) (C) (C) (string) (string) "" (C) ""
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που παίρνει μια σειρά και επιστρέφει true αν το μήκος της σειράς είναι ένας πρώτος αριθμός ή false διαφορετικά Παραδείγματα >>> prime_length((""Hello"")) (true) >>> prime_length((""abcdcba"")) (true) >>> prime_length((""kittens"")) (true) >>> prime_length((""orange"")) (false)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Με δεδομένο θετικό ακέραιο αριθμό n, επιστρέφει τον αριθμό των αριθμών των n-ψήφων θετικών ακέραιων που αρχίζουν ή τελειώνουν με 1.
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα θετικό ακέραιο αριθμό N, επιστρέφει το συνολικό άθροισμα των ψηφίων του σε δυαδικό.
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα μη κενό διάνυσμα ακέραιων αριθμών π.χ. προσθέστε τα ζυγαρά στοιχεία που είναι σε αμόλυντους δείκτες. Παραδείγματα: >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψτε μια συνάρτηση που παίρνει μια σειρά και επιστρέφει μια τακτοποιημένη έκδοση της. Η τακτοποιημένη έκδοση της σειράς, είναι μια σειρά όπου όλες οι λέξεις (διαχωρισμένες με κενό) αντικαθίστανται από μια νέα λέξη όπου όλοι οι χαρακτήρες είναι τακτοποιημένοι σε ανοδική σειρά με βάση την αξία ascii. Σημείωση: Θα πρέπει να διατηρήσετε την σειρά των λέξεων και των κενών διαστημάτων στη φράση. Για παράδειγμα: >>> anti_shuffle((""Hi"")) (""Hi"") >>> anti_shuffle(((""hello"")) (""ehllo"") >>> anti_shuffle""(Hello World!!!"")) (""Hello !!!Wdlor"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένα 2διαστατικό δεδομένο, ως ένα ένθετο διανύστη, το οποίο είναι παρόμοιο με το μήτρα, ωστόσο, σε αντίθεση με τους πίνακες, κάθε γραμμή μπορεί να περιέχει διαφορετικό αριθμό στήλων. Δεδομένου lst, και ακέραιο x, βρείτε ακέραιους x στο διανύστη, και το φεγγάρι επιστροφής των διπλών, [(x1, y1), (x2, y2) ...] έτσι ώστε κάθε διπλή είναι μια συντεταγμένη - (γραμμή, στήλες), ξεκινώντας με 0.
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διάνυσμα μη αρνητικών ακέραιων αριθμών, επιστρέφουμε ένα cocpp του δεδομένου διάνυσμα μετά την ταξινόμηση, θα ταξινομήσουμε το δεδομένο διάνυσμα με ανοδική σειρά αν το άθροισμα (πρώτη τιμή δείκτη, τελευταία τιμή δείκτη) είναι περίεργο, ή θα το ταξινομήσουμε με καθοδική σειρά αν το άθροισμα (πρώτη τιμή δείκτη, τελευταία τιμή δείκτη) είναι ζυγικό. Σημείωση: * μην αλλάζετε το δεδομένο διάνυσμα. Παραδείγματα: >>> sort_array (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση encrypt που παίρνει μια σειρά ως επιχείρημα και επιστρέφει μια σειρά κρυπτογραφημένη με το αλφάβητο να περιστρέφεται. Το αλφάβητο θα πρέπει να περιστρέφεται με τέτοιο τρόπο ώστε τα γράμματα να μετακινούνται προς τα κάτω με δύο πολλαπλασιασμένα σε δύο θέσεις. Για παράδειγμα: >>> encrypt((""hi"")) (""lm"") >>> encrypt((""asdfghjkl"")) (""ewhjklnop"") >>> encrypt((""gf"")) (""kj"") >>> encrypt((""et"")) (""ix"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένας διάνυσμος ακέραιων αριθμών. Γράψτε μια συνάρτηση next_smallest() που επιστρέφει το 2ο μικρότερο στοιχείο του διάνυσμου. Επιστρέφει None αν δεν υπάρχει τέτοιο στοιχείο. >>> next_smallest(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest((std::vector<long>({long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest(std::vector<long>())) std::nullopt >>> next_smallest(std::vector<long>{(long) 1, (long) 1))) std::nullopt
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Θα σας δοθεί μια σειρά λέξεων και η αποστολή σας είναι να μετρήσετε τον αριθμό των βαρεμάτων. Μια βαρεμάρα είναι μια πρόταση που αρχίζει με τη λέξη ""I"". Οι προτάσεις οριοθετούνται από """"., ""?' ή ""!"". Για παράδειγμα: >>> είναι_βαρεμένος (ε) "" (ε) ""Γεια σας κόσμο"")) (0) >>> είναι_βαρεμένος (ε) ""Ο ουρανός είναι μπλε. Ο ήλιος λάμπει. Λατρεύω αυτόν τον καιρό"") (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση που παίρνει 3 αριθμούς. Επιστρέφει true αν ένας από τους αριθμούς είναι ίσος με το άθροισμα των άλλων δύο, και όλοι οι αριθμοί είναι ακέραιοι. Επιστρέφει false σε οποιαδήποτε άλλη περίπτωση. Παραδείγματα >>> any_int{(float{(5)), (float{(2)), (float{(7))) (true) >>> any_int{((float{(3)), (float{(2)), (float{(2))) (false) >>> any_int{(float{(3)), (float{(-2)), (float{(1))) (true) >>> any_int{(((3.6f), (-2.2f), (float{(2))) (false)
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψτε μια συνάρτηση που παίρνει ένα μήνυμα και κωδικοποιεί με τέτοιο τρόπο ώστε να ανταλλάσσει τα κέρματα όλων των γραμμάτων, να αντικαθιστά όλα τα φωνήεντα στο μήνυμα με το γράμμα που εμφανίζεται 2 θέσεις μπροστά από αυτό το φωνήεντο στο αγγλικό αλφάβητο. Υποθέστε μόνο γράμματα. Παραδείγματα: >>> encode((""test"")) (""TGST"") >>> encode((""This is a message"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνεται ένας διάνυσμος ακέραιων αριθμών. Πρέπει να βρείτε τη μεγαλύτερη πρώτη τιμή και να επιστρέψετε το άθροισμα των ψηφίων του. Παραδείγματα: >>> skjkasdkd((std:: vector<long>((long) 0, (long) 3, (long) 2, (long) 1, (long) 3, (long) 3, (long) 4, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα χάρτη, επιστρέφει true αν όλα τα κλειδιά είναι σειρές σε μικρά ή όλα τα κλειδιά είναι σειρές σε μεγάλα γράμματα, αλλιώς επιστρέφει false. Η συνάρτηση θα πρέπει να επιστρέψει false είναι η δεδομένη χαρτογράφηση είναι κενή. Παραδείγματα: >>> check_dict_case, {""}, {""b"", ""banana""}}))) (true) >>> check_dict_case, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}, {""}}, {""}, {""}, {""}}, {""}, {""}}}, {""}}, {""}, {""}, {""}, {""}}}, {""}}, {""}, {""}, {""}}}, {""}, {""}, {""}}},
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Εφαρμόστε μια συνάρτηση που παίρνει έναν μη αρνητικό ακέραιο αριθμό και επιστρέφει έναν διανύστη των πρώτων n ακέραιων που είναι πρώτοι αριθμοί και μικρότεροι από n. για παράδειγμα: >>> count_up_to((5)) (std::vector<long>{(long) 2, (long) 3})) >>> count_up_to(11)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7})) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 19)) >>> count_up_1) (std::vector<long> >>> count_up_to(8) (std:vector<long>{(long)) 3, (long)) (long) 11, (long) 5, (long) 1 (long)) (long)
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Συμπληρώστε τη συνάρτηση που παίρνει δύο ακέραιους αριθμούς και επιστρέφει το γινόμενο των μονάδων τους. Υποθέστε ότι η είσοδος είναι πάντα έγκυρη. Παραδείγματα: >>> πολλαπλασιάστε (((148), (412)) (16) >>> πολλαπλασιάστε (((19), (28)) (72) >>> πολλαπλασιάστε (((2020), (1851)) (0) >>> πολλαπλασιάστε (((14), (-15)) (20)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Για παράδειγμα: >>> count_upper (((""aBCdEf"")) (1) >>> count_upper (((""abcdefg"")) (0) >>> count_upper (((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση που παίρνει μια τιμή (σύνδεση) που αντιπροσωπεύει έναν αριθμό και επιστρέφει τον πλησιέστερο ακέραιο αριθμό σε αυτόν. Αν ο αριθμός είναι εξίσου μακρινός από δύο ακέραιους, στρογγυλοποιήστε τον μακριά από το μηδέν. Παραδείγματα >>> closest_integer (((""10"")) (10) >>> closest_integer (((""15.3"")) Σημείωση (15): Η στρογγυλοποίηση μακριά από το μηδέν σημαίνει ότι αν ο δεδομένος αριθμός είναι εξίσου μακρινός από δύο ακέραιους αριθμούς, αυτός που θα πρέπει να επιστρέψετε είναι αυτός που είναι ο πιο μακρινός από το μηδέν. Για παράδειγμα, closest_integer (((""14.5"") θα πρέπει να επιστρέψει 15 και closest_integer (((-14.5"") θα πρέπει να επιστρέψει -15.
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Ο αριθμός των πέτρινων λίθων στο επόμενο επίπεδο είναι: - ο επόμενος αμόρφωτος αριθμός αν το n είναι αμόρφωτος. - ο επόμενος ζυγικός αριθμός αν το n είναι ζυγικός. Επιστρέφει τον αριθμό των πέτρινων λίθων σε κάθε επίπεδο σε ένα διανύστη, όπου το στοιχείο στο δείκτη i αντιπροσωπεύει τον αριθμό των πέτρινων λίθων στο επίπεδο (i+1).
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Θα σας δοθεί μια σειρά λέξεων χωρισμένες με κόμματα ή κενά. Η αποστολή σας είναι να χωρίσετε τη σειρά σε λέξεις και να επιστρέψετε ένα διανύστη των λέξεων. Για παράδειγμα: >>> words_string (((""Γεια, το όνομά μου είναι John"")) (std::vector<std::string>({(std::string) ""Γεια"", (std::string) ""my"", (std::string) ""name"", (std::string) ""is"", (std::string) ""John""}) >>> words_string (((""Ένα, δύο, τρία, τέσσερα, πέντε, έξι"")) (std::vector<std::string>{(stdstring) ""Ένα"", (std::string) ""Είκοσι"", (std::string) ""Τρία"", (std::string) ""Τέσσερα"", (std::string) ""Πέντε"", (std::string) ""Εξι""})
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Αυτή η συνάρτηση παίρνει δύο θετικούς αριθμούς x και y και επιστρέφει τον μεγαλύτερο ζυγο αριθμό που είναι στην περιοχή [x, y] συμπεριλαμβανομένου. Αν δεν υπάρχει τέτοιος αριθμός, τότε η συνάρτηση θα πρέπει να επιστρέψει -1.
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// Σας δίνονται δύο θετικοί ακέραιοι αριθμοί n και m, και το καθήκον σας είναι να υπολογίσετε τον μέσο όρο των ακέραιων αριθμών από n έως m (συμπεριλαμβανομένων των n και m). Γυρίστε την απάντηση στον πλησιέστερο ακέραιο αριθμό και μετατρέψτε το σε δυαδικό. Αν το n είναι μεγαλύτερο από m, επιστρέψτε -1.
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σημείωση: Ο ελεγκτής που επιστρέφεται πρέπει να ταξινομείται με αυξανόμενη σειρά. Για παράδειγμα: >>> unique_digits(std::vector<long>({long) 15, (long) 33, (long) 1422, (long) 1}))) (std::vector<long>{long) 1, (long) 15, (long) 33})) >>> unique_digits(std::vector<long>{long) 152, (long) 323, (long) 1422, (long) 10}))) (std::vector<long>(long))
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διάνυσμα ακέραιων αριθμών, ταξινομήστε τους ακέραιους αριθμούς που είναι μεταξύ 1 και 9 συμπεριλαμβανομένων, αντιστρέψτε το αποτέλεσμα διάνυσμα, και στη συνέχεια αντικαταστήστε κάθε ψηφίο με το αντίστοιχο όνομα από ""Ένα"", ""Δύο"", ""Τρία"", ""Τέσσερα"", ""Πέντε"", ""Έξι"", ""Επτά"", ""Οκτώ"", ""Εννέα"". Για παράδειγμα: >>> by_length(std::string<<(long>{long) 2, (long) 1, (long) 1, (long) 4, (long) 5, (long) 8, (long) 2, (long) 3}))) (std::vector<std::string>{(d::string>) ""Εκτώ"", (std::string) ""Πέντε"", (std::string>) ""Τέσσερα"", (std::string>) ""Τρία"", (std::string>) ""Τρία"", (std::string>) ""Τέσσερα"", (std::string>) ""Πέντε"", ""Εκτώ"", (d:string>) ""Εκτώ"", (d:string> (d:string>) ""Εκτώ""): (long> (long) ""Αν αδιαφορονο αριθμόν διάνυσμα, αν ο διάνυσμα έχει κενός διάνυσμα, αδιάνυσμα: (d: (d:string) (long) (long) (long (long) (long) (long (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long) (long) (long (long) (long) (long) (long (long) (long) (long (long) (long (long) (long) (long) (long) (long) (long (long ()) (long) (long) (long) (long (long) (long) (long (long) (long
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Εφαρμόστε τη συνάρτηση f που παίρνει n ως παράμετρο και επιστρέφει ένα διανύστη μεγέθους n, έτσι ώστε η τιμή του στοιχείου στο δείκτη i να είναι το παραγοντικό του i αν το i είναι ζυγικό ή το άθροισμα των αριθμών από το 1 έως το i διαφορετικά. i ξεκινά από το 1. το παραγοντικό του i είναι ο πολλαπλασιασμός των αριθμών από το 1 έως το i (1 * 2 * ... * i).
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα θετικό ακέραιο n, επιστρέφει ένα tuple που έχει τον αριθμό των ζυγών και των ατόμων ακέραιων παλινδρόμων που εμπίπτουν στην περιοχή ((1, n), συμπεριλαμβανομένων. Παράδειγμα 1: >>> even_odd_palindrome (((3)) (std::make_tuple ((1, 2)) Εξηγία: Ο ακέραιος παλινδρόμος είναι 1, 2, 3. ένας από αυτούς είναι ζυγός και δύο από αυτούς είναι ατόμοι. Παράδειγμα 2: >>> even_odd_palindrome (((12)) (std::make_tuple (((4, 6)) Εξηγία: Ο ακέραιος παλινδρόμος είναι 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. τέσσερις από αυτούς είναι ζυγός και 6 από αυτούς είναι ατόμοι. Σημείωση: 1. < 1 = n = 10 ^ 3 2. Το tuple επιστρέφει έχει τον αριθμό των ζυγών και των ατόμων ακέραιων παλινδρόμων αντίστοιχα.
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση count_nums η οποία παίρνει έναν διάνυσμα ακέραιων αριθμών και επιστρέφει τον αριθμό των στοιχείων του, το οποίο έχει άθροισμα ψηφίων > 0. Αν ένας αριθμός είναι αρνητικός, τότε το πρώτο ψηφίο του θα είναι αρνητικό: π.χ. -123 έχει ψηφία -1, 2, και 3. >>> count_nums{(std::vector<long>())) (0) >>> count_nums{(std::vector<long>{(long) -1, (long) -11, (long) -11}))) (1) >>> count_nums{(std::vector<long>{(long) 1, (long) 1, (long) 2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Έχουμε ένα διανύστη 'arr' από N ακέραιους αριθμούς arr[1], arr[2], ..., arr[N].Οι αριθμοί στο διανύστη θα είναι τυχαία ταξινομημένοι.Το καθήκον σας είναι να καθορίσετε αν είναι δυνατό να έχετε ένα διανύστη ταξινομημένο σε μη μειωτική σειρά, εκτελώντας την ακόλουθη λειτουργία στον δεδομένο διανύστη: Σας επιτρέπεται να εκτελέσετε την δεξιά μετατόπιση οποιεσδήποτε φορές.Μια δεξιά μετατόπιση σημαίνει μετατόπιση όλων των στοιχείων του διανύστης από μία θέση προς τη σωστή κατεύθυνση.Το τελευταίο στοιχείο του διανύστη θα μετακινηθεί στην αρχική θέση του διανύστη, δηλαδή 0ος δείκτης.Αν είναι δυνατό να αποκτήσετε το ταξινομημένο διανύστη εκτελώντας την παραπάνω λειτουργία, τότε επιστρέψτε true.Αν ο δεδομένος διανύστης είναι κενός, τότε επιστρέψτε true.Σημ: Ο δεδομένος διανύστης είναι εγγυητος να έχει μοναδικά στοιχεία.Για παράδειγμα: >>> move_oneball_{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σε αυτό το πρόβλημα, θα εφαρμόσετε μια συνάρτηση που παίρνει δύο διανύσματα αριθμών και καθορίζει αν είναι δυνατό να γίνει μια ανταλλαγή στοιχείων μεταξύ τους για να γίνει ο lst1 ένας διανύστης μόνο ζυγικών αριθμών. Δεν υπάρχει όριο στον αριθμό των ανταλλαγμένων στοιχείων μεταξύ των lst1 και lst2. Αν είναι δυνατό να ανταλλαχθούν στοιχεία μεταξύ των lst1 και lst2 για να γίνουν όλα τα στοιχεία του lst1 ζυγικά, επιστρέψτε ""ΝΑΙ"". Διαφορετικά, επιστρέψτε ""ΟΧΙ"". Για παράδειγμα: >>> exchange((std::vector<>((long) {1, (long) 2, (long) 3, (long) 4})), (std::vector<>(long) {1, (long) 2, (long) 3, (long) 4}) (""ΝΑΙ"") >>>((std::exchange<> vector{1, (long) (long) 2, (long) 3, (long) 4}), (std::vector<>(NO> (long) {1, (long) 5, (long)) (long) (long) (long)) υποθέτει ότι η είσοδος θα είναι κενή.
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Εάν μια σειρά γραμμάτων αντιπροσωπεύει ένα διάστημα που χωρίζεται από μικρά γράμματα, επιστρέφει ένα χάρτη του γράμματος με την περισσότερη επανάληψη και που περιέχει τον αντίστοιχο αριθμό. Αν πολλά γράμματα έχουν την ίδια εμφάνιση, επιστρέφουν όλα. Παράδειγμα: >>> ιστογράφημα (a) (a), 1}, {""b"", 1}, {""c"", 1}}) >>> ιστογράφημα (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (a) (b) (b) (b) (b) (b) (b) (b) (b) (b) (b) (b) (c) (c) (c) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d) (d
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνεται σε μας δύο σειρές s και c, πρέπει να διαγράψετε όλους τους χαρακτήρες στο s που είναι ίσοι με οποιονδήποτε χαρακτήρα στο c και να ελέγξετε αν το αποτέλεσμα είναι παλινδρόμιο. Μια σειρά ονομάζεται παλινδρόμιο αν διαβάζεται το ίδιο προς τα πίσω και προς τα εμπρός. Θα πρέπει να επιστρέψετε ένα tuple που περιέχει το αποτέλεσμα και το true/false για τον έλεγχο.
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Κάθε στοιχείο i της εξόδου θα πρέπει να είναι ""ο αριθμός των αμόριων στοιχείων στην αλυσίδα i της εισόδου"". όπου όλα τα i θα πρέπει να αντικατασταθούν από τον αριθμό των αμόριων ψηφίων στην i' αλυσίδα της εισόδου. >>> odd_count((std::vector<std::string>(({std::string) ""1234567""}))) (std::vector<std::string>({stdstring)::""ο αριθμός των αμόριων στοιχείων 4n της αλυσίδας 4n. ""})) >>> odd_count(stdvector<stdstring>::{((stdstring) "", ""3 (αλυσίδα)::dstring) 11""11""11""))) (std::vector<std::string>:n: 1 (αλυσίδα) 1 (αλυσίδα) 8n. "" 1 (αλυσίδα) 8"")
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διάνυσμα ακέραιων αριθμών, βρείτε το ελάχιστο άθροισμα οποιουδήποτε μη κενού υποδιάνυσμα αριθμών. Παράδειγμα >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Κάθε γραμμή αντιπροσωπεύει ένα μοναδικό πηγάδι και κάθε 1 σε μια σειρά αντιπροσωπεύει μια μοναδική μονάδα νερού. Κάθε πηγάδι έχει έναν αντίστοιχο κουβά που μπορεί να χρησιμοποιηθεί για να εξαγάγει νερό από αυτό και όλοι οι κουβάδες έχουν την ίδια χωρητικότητα. Η εργασία σας είναι να χρησιμοποιήσετε τους κουβάδες για να αδειάσετε τους πηγάδες. Εκπέμψτε τον αριθμό των φορές που πρέπει να κατεβάσετε τους κουβάδες. Παράδειγμα 1: >>> max_fill((long_long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long) (long_long_long) (long_long_long) (long_long_long_long) (long_long_long_long) (long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long_long
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σε αυτό το Kata, πρέπει να ταξινομήσετε ένα διάνυσμα μη αρνητικών ακέραιων αριθμών σύμφωνα με τον αριθμό των ατόμων στη δυαδική τους αναπαράσταση σε ανοδική σειρά. Για παρόμοιο αριθμό ατόμων, ταξινομήστε με βάση την δεκαδική τιμή. Πρέπει να εφαρμοστεί ως εξής: >>> sort_array((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5}) >>> sort_array(std::vector<long>{(long) 2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std::vector<long>{(long>{-6, (long) 5, (long) 4, (long) 3, (long) 2} >>> sort_array_std::vector<long>{(long>1, (long) 3, (long) 4, (long)) (long) 1, (long) (long) (long) (long) (long) (long) (long) (long))
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σημείωση: μπορείτε να υποθέσετε ότι η εισερχόμενη συμβολοσειρά περιέχει μόνο γράμματα και κενά. Παραδείγματα: >>> select_words (<string>), (4) (<string>), (<string>), (<string>), (<string>), (<string>), (<string>) (<string>), (<string>) (<string>), (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (<string>) (>) (<string>) (>) (<string>) (>) (<string))
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται μια λέξη. Η αποστολή σας είναι να βρείτε το πλησιέστερο φωνητικό που βρίσκεται μεταξύ δύο συλλαβών από τη δεξιά πλευρά της λέξης (επισήμανση κεντρικής γραμμής). Οι φωνητικοί στην αρχή και το τέλος δεν μετράνε. Επιστρέψτε κενή σειρά αν δεν βρείτε κανένα φωνητικό που πληροί την ανωτέρω προϋπόθεση. Μπορείτε να υποθέσετε ότι η δοθείσα σειρά περιέχει μόνο αγγλικά γράμματα.
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένας διανύστης δύο συμβολοσειρών, και οι δύο συμβολοσειρές αποτελούνται μόνο από ανοιχτές παρενθέσεις '(' ή κλειστές παρενθέσεις ') '. Η δουλειά σας είναι να ελέγξετε αν είναι δυνατό να συσχετίσετε τις δύο συμβολοσειρές με κάποια σειρά, ώστε η προκύπτουσα συμβολοσειρά να είναι καλή. Μια συμβολοσειρά S θεωρείται καλή μόνο και μόνο αν όλες οι παρενθέσεις στο S είναι ισορροπημένες. Για παράδειγμα: η συμβολοσειρά '(())) ' είναι καλή, ενώ η συμβολοσειρά '()) ' δεν είναι. Επιστρέψτε 'Ναι' αν υπάρχει τρόπος να κάνετε μια καλή συμβολοσειρά, και επιστρέψτε 'Όχι' διαφορετικά. Παραδείγματα: >>> match_parens((std:: vector<std:: string>{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διανύστη arr ακέραιων αριθμών και ένα θετικό ακέραιο αριθμό k, επιστρέψτε ένα ταξινομημένο διανύστη μήκους k με τους μέγιστους αριθμούς k σε arr. Παράδειγμα 1: >>> max{((std::vector<long>{(long) -3, (long) -4, (long) -5,)), (3)) (std::vector<long>{(long) -4, (long) -3, (long) -5)) Παράδειγμα 2: >>> max{(std::vector<long>{(long) -4, (long) -4, (long) -4}), (2)) (std::vector<long>{(long) -4, (long) -4}) Παράδειγμα 3: >>> max{(std::vector<<long>{(long) -3, (long) -2, (long) -1, (long) -2, (long) -1, (long) -2, (long) -1,) (1) (std::vector{{(arr>) -2): 1. Το μήκος του διανύκτου θα είναι στην περιοχή των 1000 στοιχείων. Σημείωση: len= 0-1, len=2.
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα μη κενό διάνυσμα ακέραιων, επιστρέφει το άθροισμα όλων των αμόριων στοιχείων που βρίσκονται σε ζυγικές θέσεις. Παραδείγματα >>> λύση: (((std::vector<long>({long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> λύση: (((std::vector<long>({long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> λύση: (((std::vector<long>({long) 30, (long) 13, (long) 24, (long) 321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα μη κενό διάνυσμα ακέραιων αριθμών arr και έναν ακέραιο αριθμό k, επιστρέφει το άθροισμα των στοιχείων με το πολύ δύο ψηφία από τα πρώτα k στοιχεία του arr. Παράδειγμα: >>> add_elements{}std::vector<long>{(long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) Περιορισμοί: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Η υπόθεση του Collatz είναι μια υπόθεση στα μαθηματικά που αφορά μια ακολουθία που ορίζεται ως εξής: ξεκινήστε με οποιοδήποτε θετικό ακέραιο n. Στη συνέχεια, κάθε όρος λαμβάνεται από τον προηγούμενο όρο ως εξής: αν ο προηγούμενος όρος είναι ζυγός, ο επόμενος όρος είναι το μισό του προηγούμενου όρου. Αν ο προηγούμενος όρος είναι αμόριος, ο επόμενος όρος είναι 3 φορές ο προηγούμενος όρος συν 1.
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Πρέπει να γράψετε μια συνάρτηση που επικυρώνει μια δεδομένη σειρά ημερομηνιών και επιστρέφει true αν η ημερομηνία είναι έγκυρη διαφορετικά false. Η ημερομηνία είναι έγκυρη αν πληρούνται όλοι οι ακόλουθοι κανόνες: 1. Η σειρά ημερομηνιών δεν είναι κενή. 2. Ο αριθμός των ημερών δεν είναι μικρότερος από 1 ή μεγαλύτερος από 31 ημέρες για τους μήνες 1,3,5,7,8,10,12. Και ο αριθμός των ημερών δεν είναι μικρότερος από 1 ή μεγαλύτερος από 30 ημέρες για τους μήνες 4,6,9,11. Και ο αριθμός των ημερών δεν είναι μικρότερος από 1 ή μεγαλύτερος από 29 για τον μήνα 2. 3. Οι μήνες δεν πρέπει να είναι μικρότεροι από 1 ή μεγαλύτεροι από 12. 4. Η ημερομηνία πρέπει να είναι στη μορφή: mm-dd-yyyy >>> valid_(date((103-11-2000"")) (true >>> valid_date((15-01-2012"")) (false) >>> valid_date(04-040"") (false) valid >>> valid_(date_(06-2020) (true >>> valid_date""06/04/2020) (false)
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// Με δεδομένη μια σειρά λέξεων, επιστρέφει ένα διανύστη λέξεων χωρισμένο σε κενό, αν δεν υπάρχουν κενά στο κείμενο θα πρέπει να χωριστεί σε κόμματα ',' αν δεν υπάρχουν κόμματα θα πρέπει να επιστρέψει τον αριθμό των μικρών γραμμάτων με ακανόνιστη σειρά στο αλφάβητο, ord('a') = 0, ord('b') = 1, ... ord('z') = 25 Παραδείγματα >>> split_words(((""Hello world!"")) std::vector<std::string>(({(std::string) ""Hello"", (std::string) ""world!""}) >>> split_words(((""Hello, world!"")) std::vector<std::string>{((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα διάνυσμα αριθμών, επιστρέφει αν είναι ταξινομημένα ή όχι σε ανοδική σειρά. Αν ο διάνυσμος έχει περισσότερους από 1 αντιγράφους του ίδιου αριθμού, επιστρέφει false. Υποθέστε ότι δεν υπάρχουν αρνητικοί αριθμοί και μόνο ακέραιοι. Παραδείγματα >>> is_sorted (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Για παράδειγμα, η διασταύρωση των διαστημάτων (1, 3), (2, 4) είναι (2, 3) η οποία έχει μήκος 1, που δεν είναι πρώτος αριθμός. Εάν το μήκος της διασταύρωσης είναι πρώτος αριθμός, επιστρέφετε ""ΝΑΙ"", διαφορετικά επιστρέφετε ""ΟΧΙ"". Αν τα δύο διαστήματα δεν διασταυρώνονται, επιστρέφετε ""ΟΧΙ"". [input/output] δείγματα: >>> διασταύρωση: ((((dmake_tuple1, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένας διανύστης ακεραίων και πρέπει να επιστρέψετε το άθροισμα των μεγεθών των ακεραίων πολλαπλασιασμένο με το γινόμενο όλων των σημείων κάθε αριθμού στον διανύστη, που αντιπροσωπεύεται από 1, -1 ή 0. Σημείωση: επιστρέφει None για κενό διανύστη. Παράδειγμα: >>> prod_signs(((std::vector<long>{(long) 1, (long) 2, (long) 2, (long) - 4}))) 9 >>> prod_signs(std::vector<long>({(long) 0, (long) 1}))) 0 >>> prod_signs((std::vector<long>(())) std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Κάθε ακέραιο αριθμός στην περιοχή [1, N * N] συμπεριλαμβανομένου εμφανίζεται ακριβώς μία φορά στα κύτταρα του πλέγματος. Πρέπει να βρείτε τη ελάχιστη διαδρομή μήκους k στο πλέγμα. Μπορείτε να ξεκινήσετε από οποιοδήποτε κελί και σε κάθε βήμα μπορείτε να μετακινηθείτε σε οποιοδήποτε από τα γειτονικά κύτταρα, με άλλα λόγια, μπορείτε να πάτε σε κύτταρα που μοιράζονται μια άκρη με το τρέχον κελί σας. Παρακαλούμε σημειώστε ότι μια διαδρομή μήκους k σημαίνει επίσκεψη ακριβώς k κελίων (όχι απαραίτητα διακριτών). Δεν μπορείτε να βγείτε από το πλέγμα. Μια διαδρομή A (μήκους k) θεωρείται μικρότερη από μια διαδρομή B (μήκους k) εάν μετά την παραγωγή των ταξινομημένων διανυσμών των τιμών στα κύτταρα που περνούν από το A και το B (ας τις ονομάσουμε l_stA και l_stB), η λεξιογραφική διαδρομή είναι μικρότερη από την l_stA, με άλλα λόγια, υπάρχει ένας ατοδικός ατο πλέγματος που είναι μοναδικός για κάθε κύτταρα (i = j_st_jj_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Όλοι γνωρίζουν τη σειρά Φιμπονατσι, μελετήθηκε βαθιά από τους μαθηματικούς τους τελευταίους δύο αιώνες. Ωστόσο, αυτό που οι άνθρωποι δεν γνωρίζουν είναι η σειρά Τριμπονατσι. Η σειρά Τριμπονατσι ορίζεται από την επανάληψη: tri(1) = 3 tri(n) = 1 + n / 2, αν n είναι ζυγική. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), αν n είναι αρίθμητη. Για παράδειγμα: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Σας δίνεται ένας μη αρνητικός ακέραιος αριθμός n, πρέπει να επιστρέψετε έναν διανέκτη των πρώτων n + 1 της σειράς Τριμπονατσι. Παραδείγματα: >>> tri(3) (dst long vector><{(long} (long 1, long 3, long 2, long 8))
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα θετικό ακέραιο αριθμό n, επιστρέφει το γινόμενο των περιττών ψηφίων. Επιστρέφει 0 αν όλα τα ψηφία είναι ζεύγαλα. Για παράδειγμα: >>> ψηφία (((1)) (1) >>> ψηφία (((4)) (0) >>> ψηφία (((235)) (15)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση που παίρνει μια σειρά ως εισροή η οποία περιέχει μόνο τετράγωνες αγκύλες. Η συνάρτηση θα πρέπει να επιστρέψει true αν και μόνο αν υπάρχει μια έγκυρη υποδοχή αγκυλών όπου τουλάχιστον μία αγκύλα στην υποδοχή είναι ενσωματωμένη. >>> is_nested((""[[]]"")) (true) >>> is_nested((""[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένας διάνυσμος αριθμών. Πρέπει να επιστρέψετε το άθροισμα των τετραγωνισμένων αριθμών στον δεδομένο διάνυσμο, στρογγυλοποιώντας πρώτα κάθε στοιχείο του διάνυσμου στο ανώτερο άθροισμα. Παραδείγματα: >>> lst: vector: float: 1.0f, (float: 2.0f, (float: 3.0f)))) (14) >>> lst: vector: float: 1.0f, (float: 4.0f, (float: 9.0f)))) >>> (98) lst: vector: float: 1.0f, (float: 3.0f, (float: 5.0f, (float: 7.0f) >>> (84) >>> lst: vector: float: 1.04f, (float: 2.04f, (float: 0.0f)) (6) >>> vector: float: 1.04f, (float: 2.04f, (float: 0.0f)) (6) >>> vector: float: 1.04f, (float: 1.04f)
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση που επιστρέφει true αν ο τελευταίος χαρακτήρας μιας δεδομένης αλφαβητικής αλυσίδας είναι αλφαβητικός χαρακτήρας και δεν αποτελεί μέρος μιας λέξης, και false διαφορετικά. Σημείωση: ""word"" είναι μια ομάδα χαρακτήρων χωρισμένων με κενό. Παραδείγματα: >>> check_if_last_char_is_a_letter((""apple pie"")) (false) >>> check_if_last_char_is_a_letter(""apple pi e"")) (true) >>> check_if_last_char_is_a_letter ""apple pi e "")) (false) >>> check_if_last_char_is_a_letter"" (false)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση που επιστρέφει τον μεγαλύτερο δείκτη ενός στοιχείου που δεν είναι μεγαλύτερο ή ίσο με το στοιχείο που το προηγείται αμέσως. Αν δεν υπάρχει τέτοιο στοιχείο, επιστρέφει -1. Ο δοσμένος διανύστης δεν θα περιέχει διπλές τιμές. Παραδείγματα: >>> can_arrange(((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση που επιστρέφει ένα tuple (a, b), όπου 'a' είναι το μεγαλύτερο από τα αρνητικά ακέραια, και 'b' είναι το μικρότερο από τα θετικά ακέραια σε ένα διάνυσμα. Αν δεν υπάρχουν αρνητικά ή θετικά ακέραια, επιστρέφει ως None. Παραδείγματα: >>> largest_smallest_integers((std::vector<long>{long>) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7}))) std::make_tuplestd::optional<long>{long>), std::optional<long>{long>) >>> largest_smallest_integers{((std::vector<long>{long>)
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// Δημιουργήστε μια συνάρτηση που παίρνει ακέραιους αριθμούς, πλωτές μονάδες ή σειρές που αντιπροσωπεύουν πραγματικούς αριθμούς και επιστρέφει τη μεγαλύτερη μεταβλητή στον δεδομένο τύπο μεταβλητής. Επιστρέφει None εάν οι τιμές είναι ίσες. Σημείωση: Εάν ένας πραγματικός αριθμός αντιπροσωπεύεται ως μια σειρά, το πλωτό σημείο μπορεί να είναι . ή , >>> compare_one(1, 2.5f) 2.5f >>> compare_one(1, ""2,3"") ""2,3"" >>> compare_one(""5,1"", ""6"") ""6"" >>> compare_one(""1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Αξιολογήστε αν ο δοθέντος αριθμός n μπορεί να γραφτεί ως το άθροισμα ακριβώς 4 θετικών ζυγικών αριθμών Παράδειγμα >>> είναι_ισοδύναμο_με_το_σύνολο_ακόμα και (((4)) (ψευδές) >>> είναι_ισοδύναμο_με_το_σύνολο_ακόμα και ((6)) (ψευδές) >>> είναι_ισοδύναμο_με_το_σύνολο_ακόμα και ((8)) (αληθές)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Το βραζιλιάνικο παραγοντικό ορίζεται ως: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! όπου n > 0 Για παράδειγμα: >>> special_factorial((4)) (288) Η συνάρτηση θα λάβει έναν ακέραιο αριθμό ως είσοδο και θα πρέπει να επιστρέψει το ειδικό παραγοντικό αυτού του ακέραιου αριθμού.
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Με δεδομένο ένα κείμενο στη σειρά κειμένων, αντικαταστήστε όλα τα κενά με υπογράμματα, και αν μια σειρά έχει περισσότερα από 2 διαδοχικά κενά, τότε αντικαταστήστε όλα τα διαδοχικά κενά με - >>> fix_spaces ((("" Παράδειγμα "")) (""Παράδειγμα"") >>> fix_spaces ((("" Παράδειγμα 1"")) (""Παράδειγμα_1"") >>> fix_spaces ((("" Παράδειγμα 2"")) (""_Example_2"") >>> fix_spaces ((("" Παράδειγμα 3"")) (""_Example-3"")
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δημιουργήστε μια συνάρτηση που παίρνει μια σειρά γραμμών που αντιπροσωπεύει το όνομα ενός αρχείου, και επιστρέφει ""Ναι"" αν το όνομα του αρχείου είναι έγκυρο, και επιστρέφει ""Όχι"" διαφορετικά. Ένα όνομα αρχείου θεωρείται έγκυρο εάν και μόνο εάν πληρούνται όλες οι ακόλουθες προϋποθέσεις: - Δεν πρέπει να υπάρχουν περισσότερα από τρία ψηφία ('0'-'9') στο όνομα του αρχείου. - Το όνομα του αρχείου περιέχει ακριβώς ένα σημείο '.' - Η υποσύνδεση πριν από το σημείο δεν πρέπει να είναι κενή και να αρχίζει με ένα γράμμα από το λατινικό αλφάβητο ('a'-'z' και 'A'-Z'). - Η υποσύνδεση μετά από το σημείο πρέπει να είναι ένα από τα εξής: ['txt', 'exe', 'll'] Παραδείγματα: >>> file_name_check""((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// "" Αυτή η συνάρτηση θα πάρει έναν διάνυσμα ακέραιων αριθμών. Για όλες τις καταχωρήσεις στον διάνυσμα, η συνάρτηση θα τετραγωνίσει την ακέραιη καταχώρηση αν ο δείκτης της είναι πολλαπλάσιος του 3 και θα τοποθετήσει στον κύβο την ακέραιη καταχώρηση αν ο δείκτης της είναι πολλαπλάσιος του 4 και όχι πολλαπλάσιος του 3. Η συνάρτηση δεν θα αλλάξει τις καταχωρήσεις στον διάνυσμα των οποίων οι δείκτες δεν είναι πολλαπλάσιος του 3 ή 4. Η συνάρτηση θα επιστρέψει το άθροισμα όλων των καταχωρήσεων. Παραδείγματα: >>> lst (long({(long) 1, (long) 2, (long) 3, (long) 5})
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται μια σειρά που αντιπροσωπεύει μια πρόταση, η πρόταση περιέχει μερικές λέξεις χωρισμένες με ένα κενό, και πρέπει να επιστρέψετε μια σειρά που περιέχει τις λέξεις από την αρχική πρόταση, των οποίων τα μήκη είναι πρώτοι αριθμοί, η σειρά των λέξεων στη νέα σειρά θα πρέπει να είναι η ίδια με την αρχική.
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Το έργο σας είναι να εφαρμόσετε μια συνάρτηση που θα απλοποιήσει την έκφραση x * n. Η συνάρτηση επιστρέφει true αν x * n αξιολογείται σε έναν ακέραιο αριθμό και false διαφορετικά. Και τα δύο x και n, είναι συμβολισμός γραμμής ενός κλάσματος, και έχουν την ακόλουθη μορφή, < αριθμητής>/< παρονομαστής> όπου και ο αριθμητής και ο παρονομαστής είναι θετικοί ακέραιοι αριθμοί. Μπορείτε να υποθέσετε ότι το x και το n είναι έγκυρα κλάσματα και δεν έχουν μηδέν ως παρονομαστή. >>> απλοποιήστε (((""1/5""), (""5/1"")) (αλήθεια) >>> απλοποιήστε (((""1/6""), (""2/1"") (ψευδής) >>> απλοποιήστε ((((""7/10""), (""10/2"") (ψευδής)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που ταξινομεί τον δεδομένο διάνυσμα των ακέραιων αριθμών σε ανοδική σειρά σύμφωνα με το άθροισμα των ψηφίων τους. Σημείωση: αν υπάρχουν πολλά στοιχεία με παρόμοιο άθροισμα των ψηφίων τους, ταξινομήστε τα με βάση τον δείκτη τους στον αρχικό διάνυσμα. Για παράδειγμα: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) -1, (long) -12, (long) 11})) >>> order_by_points(std::vector<long>())) (std::vector<long>(long))
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψτε μια συνάρτηση που παίρνει έναν矢量 αριθμών ως εισροή και επιστρέφει τον αριθμό των στοιχείων στον矢量 που είναι μεγαλύτεροι από 10 και τόσο το πρώτο όσο και το τελευταίο ψηφίο ενός αριθμού είναι αμόρφωτα (1, 3, 5, 7, 9). Για παράδειγμα: >>> specialFilter((std::vector<long>({long) 15, (long) -73, (long) -14, (long) -15}))) (1) >>> specialFilter((std::vector<long>({long) 33, (long) -2, (long) -3, (long) -45, (long) -21, (long) -109} (2))))
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται ένας θετικός ακέραιος αριθμός n. Πρέπει να δημιουργήσετε έναν ακέραιο διανύστη α μήκους n. Για κάθε i (1 ≤ i ≤ n), η τιμή του a[i] = i * i - i + 1. Επιστρέφει τον αριθμό των τριπλών (a[i], a[j], a[k]) του α όπου i < j < k, και a[i] + a[j] + a[k] είναι πολλαπλάσιο του 3. Παράδειγμα: >>> get_max_triples((5)) (1) Εξηγή: a = [1, 3, 7, 13, 21] Το μόνο έγκυρο τριπλό είναι (1, 7, 13).
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Υπάρχουν οκτώ πλανήτες στο ηλιακό μας σύστημα: ο πλησιέστερος στον Ήλιο είναι ο Ερμής, ο επόμενος είναι η Αφροδίτης, στη συνέχεια η Γη, ο Άρης, ο Δίας, ο Κρόνος, ο Ουρανός, ο Ποσειδώνας. Γράψε μια συνάρτηση που παίρνει δύο ονόματα πλανητών ως χορδές πλανήτης1 και πλανήτης2. Η συνάρτηση θα πρέπει να επιστρέψει ένα tuple που περιέχει όλους τους πλανήτες των οποίων οι τροχιές βρίσκονται μεταξύ της τροχιάς του πλανήτη1 και της τροχιάς του πλανήτη2, ταξινομημένες από την εγγύτητα προς τον ήλιο. Η συνάρτηση θα πρέπει να επιστρέψει ένα κενό tuple αν ο πλανήτης1 ή ο πλανήτης2 δεν είναι σωστές ονόματα πλανητών. Παραδείγματα >>> bf((""Δία""), (""Δία"") (std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που δέχεται ένα διανύστη συμβολοσειρών ως παράμετρο, διαγράφει τις συμβολοσειρές που έχουν ανούσια μήκος από αυτό, και επιστρέφει το αποτέλεσμα με μια ταξινομημένη σειρά. Το διανύστη είναι πάντα ένα διανύστη συμβολοσειρών και ποτέ ένα διανύστη αριθμών, και μπορεί να περιέχει αντίγραφα. Η σειρά του διανύστης θα πρέπει να είναι ανοδική κατά μήκος κάθε λέξης, και θα πρέπει να επιστρέφετε το διανύστη ταξινομημένο από αυτόν τον κανόνα. Αν δύο λέξεις έχουν το ίδιο μήκος, ταξινομηθεί το διανύστη αλφαβητικά. Η συνάρτηση θα πρέπει να επιστρέψει ένα διανύστη συμβολοσειρών σε ταξινομημένη σειρά. Μπορείτε να υποθέσετε ότι όλες οι λέξεις θα έχουν το ίδιο μήκος. Για παράδειγμα: >>> list_sort{""}std::stdvector<stdstring>{""}std::stdstring"" (a) "" (a) "" (a) (a) (aa"" (a) (a) (d (d) (d) (d (d) (d) (d) (d (d) (d) (d) (d (d) (d) (d (d) (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d) (d (d) (d (d) (d) (d (d) (d) (d) (d (d) (d (d) (d) (d) (d (d) (d) (d (d) (d) (d (d) (d (d) (d) (d) (d (d) (d) (d) (d (d) (d) (d) (d (d) (d (d) (d) (d
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Ένα απλό πρόγραμμα που θα πρέπει να επιστρέψει την τιμή του x αν n είναι ένας πρώτος αριθμός και θα πρέπει να επιστρέψει την τιμή του y διαφορετικά. Παραδείγματα: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας έναν διάνυσμα αριθμών, επιστρέφουμε το άθροισμα των τετραγώνων των αριθμών στον διάνυσμα που είναι αμόριοι. Αγνοούμε τους αριθμούς που είναι αρνητικοί ή όχι ακέραιοι. >>> double_the_difference{(((std::vector<float>({(long) 1, (long) 3, (long) 2, (long) 0}))) (10) >>> double_the_difference{((std::vector<float>{(long) -1, (long) -2, (long) 0}))) (0) >>> double_the_difference{((std::vector<float>{(long) -9, (long) -2)))) (81) >>> double_the_difference{((std::vector<float>{(long) -0}))) (0) Εάν ο διάνυσμα εισόδου είναι κενός, επιστρέφουμε 0.
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Νομίζω ότι όλοι μας θυμόμαστε αυτό το συναίσθημα όταν το αποτέλεσμα κάποιου πολυαναμενόμενου γεγονότος είναι επιτέλους γνωστό. Τα συναισθήματα και οι σκέψεις που έχετε εκείνη τη στιγμή αξίζουν σίγουρα να σημειωθούν και να συγκριθούν. Το καθήκον σας είναι να καθορίσετε αν ένα άτομο μάντεψε σωστά τα αποτελέσματα ενός αριθμού αγώνων. Σας δίνονται δύο διανύστες βαθμολογιών και μαντεψιών ίσης διάρκειας, όπου κάθε δείκτης δείχνει μια αντιστοιχία. Επιστρέψτε ένα διανύστη του ίδιου μήκους που υποδηλώνει πόσο μακριά ήταν κάθε μαντεψία. Αν μαντέψετε σωστά, η τιμή είναι 0, και αν όχι, η τιμή είναι η απόλυτη διαφορά μεταξύ της μαντεψίας και του σκορ. παραδείγμα: >>> (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Θα σας δοθεί το όνομα μιας τάξης (μια σειρά) και ένα διανύστη επεκτάσεων. Οι επεκτάσεις θα χρησιμοποιηθούν για να φορτώσετε πρόσθετες τάξεις στην τάξη. Η ισχύς της επεκτάσεως είναι η εξής: Ας είναι η CAP ο αριθμός των κεφαλαίων γραμμάτων στο όνομα της επεκτάσεως, και ας είναι η SM ο αριθμός των μικρών γραμμάτων στο όνομα της επεκτάσεως, η ισχύς δίνεται από το κλάσμα CAP - SM. Θα πρέπει να βρείτε την ισχυρότερη επεκτάση και να επιστρέψετε μια σειρά με αυτή τη μορφή: ClassName.StrongestExtensionName. Εάν υπάρχουν δύο ή περισσότερες επεκτάσεις με την ίδια ισχύ, θα πρέπει να επιλέξετε την πρώτη που εμφανίζεται στο διανύστη. Για παράδειγμα, αν σας δοθεί ""Slices"" ως τάξη και ένα διανύστη των επεκτάσεων: ['SErviSliNGCes'', 'Cheese', 'StufedF'], τότε θα πρέπει να επιστρέψετε 'Slices.SErviSliNGCes' και 'SliNGC::::::st:myst:myst:viSliNGC::st:myst:st:myst:SliNG::st:st:myst:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:d:
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνονται 2 λέξεις. Πρέπει να επιστρέψετε true αν η δεύτερη λέξη ή οποιαδήποτε από τις περιστροφές της είναι υποσύνδεση στην πρώτη λέξη >>> cycpattern_check((""abcd""), (""abd"")) (false) >>> cycpattern_check((""hello""), (""ell"")) (true) >>> cycpattern_check((""whassup""), (""psus"")) (false) >>> cycpattern_check((""abab""), (""baa"")) (true) >>> cycpattern_(check""efef""), (""eeff"") cy (false) >>> cycpattern_check((""himens""), (""simen"") (true)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνεται ένας ακέραιος αριθμός. επιστρέφει ένα tuple που έχει τον αριθμό των ζυγών και των αμόριων ψηφίων αντίστοιχα.
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας ένα θετικό ακέραιο, πάρτε το ισοδύναμο του ρωμαϊκού αριθμού ως μια σειρά, και επιστρέψτε το σε μικρογραφία. Περιορισμοί: 1 <= num <= 1000 Παραδείγματα: >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426)) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας τα μήκη των τριών πλευρών ενός τριγώνου. Επιστρέφει true αν οι τρεις πλευρές σχηματίζουν ένα ορθογώνιο τρίγωνο, false διαφορετικά. Ένα ορθογώνιο τρίγωνο είναι ένα τρίγωνο στο οποίο μια γωνία είναι ορθογώνιο ή 90 μοίρες. Παράδειγμα: >>> right_angle_triangle((3), (4), (5)) (true) >>> right_angle_triangle(1), (2), (3)) (false)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Γράψε μια συνάρτηση που δέχεται ένα διανύστη συμβολοσειρών. Ο διανύστης περιέχει διαφορετικές λέξεις. Επιστρέφει τη λέξη με τον μέγιστο αριθμό μοναδικών χαρακτήρων. Αν πολλαπλές συμβολοσειρές έχουν τον μέγιστο αριθμό μοναδικών χαρακτήρων, επιστρέφει αυτόν που έρχεται πρώτος στη λεξικογραφική σειρά. >>> find_max((std::vector<std::string>({(std::string) ""name"", (std::string) ""of"", (std::string) ""string""}))) (""string"") >>> find_max{(std::vector<std::string>({(std::string) ""name"", (std::string) ""enam"") >>> find_max{(std::vector<std>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Είσαι ένα πεινασμένο κουνέλι, και έχεις ήδη φάει ένα ορισμένο αριθμό καρότων, αλλά τώρα πρέπει να φας περισσότερα καρότα για να ολοκληρώσεις τα γεύματα της ημέρας. θα πρέπει να επιστρέψεις έναν διανύστη [συνολικός αριθμός των καρότων που έχουν καταναλωθεί μετά τα γεύματα σου, ο αριθμός των καρότων που έχουν απομείνει μετά τα γεύματα σου ] αν δεν υπάρχουν αρκετά εναπομείναντα καρότα, θα φας όλα τα εναπομείναντα καρότα, αλλά θα είσαι ακόμα πεινασμένος. Παράδειγμα: >>> τρώει((5), (6), (10)) (std::vector<long>{(()11, (long) 4}) >>> τρώει(4), (8), (9) (std::vector<long>{(() 12, ( (1})) τρώει >>>(1), (10), (10) (std::vector<long>{() 11, (long) 0)) >>>(2), (11), (5) (std::vector<<<d> (long>) 7, (long>) 0) @ V: ο αριθμός των εναπομείναντων καρότων που χρειάζεσαι να φας είναι 1000: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας δύο διανύσματα, έναν φορέα και έναν τελεστή. Ο πρώτος διανύστης έχει βασικές πράξεις άλγεβρας και ο δεύτερος διανύστης είναι ένας διανύστης ακέραιων αριθμών. Χρησιμοποιήστε τους δύο δεδομένους διανύστες για να δημιουργήσετε την άλγεβρική έκφραση και να επιστρέψετε την αξιολόγηση αυτής της έκφρασης. Οι βασικές πράξεις άλγεβρας: Προσθήκη (+) Υποβολή ( ) - Πολλαπλασιασμός ( *) Διαιρέση ( // ) Εκθέτηση ( **) Παράδειγμα: διανύστης['+', '*', '-'] διανύστης = [2, 3, 4, 5] αποτέλεσμα = 2 + 3 * 4 - 5 => αποτέλεσμα = 9 Σημείωση: Το μήκος του διανύστης χειριστή είναι ίσο με το μήκος του διανύστης χειριστή μείον ένα. Ο διανύστης χειριστής είναι ένας διανύστης μη αρνητων ακέραιων αριθμών. Ο διανύστης χειριστής έχει τουλάχιστον έναν φορέα και ο διανύστης χειριστής έχει τουλάχιστον δύο χειριστές.
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Σας δίνεται μια αλυσίδα s. αν s[i] είναι ένα γράμμα, αντιστρέψτε την κεντρική της από κάτω προς πάνω ή αντίστροφα, αλλιώς κρατήστε την όπως είναι. Αν η αλυσίδα δεν περιέχει γράμματα, αντιστρέψτε την αλυσίδα. Η συνάρτηση θα πρέπει να επιστρέψει την προκύπτουσα αλυσίδα. Παραδείγματα >>> solve((""1234"")) (""4321"") >>> solve((""ab"")) (""AB"") >>> solve((""#a@C"")) (""#A@c"")
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Εάν η string είναι κενή, επιστρέφει None. >>> string_to_md5 ((((""Hello world"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,ell_Grek,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// Δίνοντας δύο θετικούς ακέραιους αριθμούς α και β, επιστρέφουμε τους ζυγούς αριθμούς μεταξύ α και β, με ανοδική σειρά. Για παράδειγμα: >>> generate_integers((2), (8)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((8), (2)) (std::vector<long>({(long)2, (long)4, (long)6, (long)8})) >>> generate_integers((10), (14) (std::vector<long>())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
