task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,fon_Latn,hs,"--kpò è è.--◯ Kpɔ́n ɖɔ nùjlɛ́kpo wè ɖò nùjlɛ́kpo e è ná lɛ́ ɖó lɛ́ɛ mɛ ɔ, ye ɖò akpáxwé ɖě ɔ́ tɔn hú ɖě ɔ à jí--  >>> hasCloseElements [1.0,2.0,3.0] 0.5
--  False
--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3
--  True
hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold =","hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold = any (\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a /= b]","
main :: IO ()
main = do
  let candidate = hasCloseElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_1,fon_Latn,hs,"--Mi ma sɔ́ dó nùkwín e mi nɔ zán dó wlan nǔ lɛ é mɛ ó.--Ahwan e ɖò yeɖée mɛ lɛ é nɔ ɖò jlɛ̌ jí (ahwan e ɖò yeɖée mɛ lɛ é ɖokpo ɖokpo nɔ ɖò yeɖée mɛ ganji) bɔ ye nɔ nɔ yeɖée mɛ ǎ.--ɖè mɛ enɛ lɛ ɖó kpɔ́ bó ná lɛ́ wá nú mɛ e ɖò mɛ lɛ é.--̆ Nǔ e è nɔ sɔ́ dó azɔ̀ elɔ mɛ é wɛ nyí nùkwín e nɔ ɖó nùɖé lɛ dó mɛ é.--  >>> separateParenGroups ""( ) (( )) (( )( ))""
--  [""()"",""(())"",""(()())""]
separateParenGroups :: String -> [String]
separateParenGroups paren_string =","separateParenGroups :: String -> [String]
separateParenGroups paren_string = go paren_string 0 [] """" []
  where
    go [] _ _ current acc = if null current then acc else acc ++ [current]
    go (x:xs) depth stack current acc
      | x == ' ' = go xs depth stack current acc
      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc
      | x == ')' =
          let newCurrent = current ++ [x]
              newDepth = depth - 1
          in if newDepth == 0
             then go xs newDepth (tail stack) """" (acc ++ [newCurrent])
             else go xs newDepth (tail stack) newCurrent acc
      | otherwise = error ""Unexpected character""","
main :: IO ()
main = do
  let candidate = separateParenGroups
  if candidate ""(()()) ((())) () ((())()())"" == [""(()())"",""((()))"",""()"",""((())()())""] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [""()"",""(())"",""((()))"",""(((())))""] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [""(()(())((())))""] then pure () else error ""assertion failed""
  if candidate ""( ) (( )) (( )( ))"" == [""()"",""(())"",""(()())""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_2,fon_Latn,hs,"--Zɔ́n nú númɛ̀ ɔ́ sín akpáxwé wǒgɔ́dó ɔ́.--(kpá e nɔ lɛ́ kpo ɖò mɛ é nɔ ɖò kpɛví hú 1).--kpò nú nùxwásún (nùnxwásún ɖaxó e hú nùxwásún e è ná é) kpo nǔxwásún wǒzángbè tɔn lɛ kpo --¢ñá Ý÷åé êáëü óýóôçìá, ìðïñåß íá ÷ùñçèåß óå ¢ñá--  >>> truncateNumber 3.5
--  0.5
truncateNumber :: Float -> Float
truncateNumber number =","truncateNumber :: Float -> Float
truncateNumber number = number - fromIntegral (floor number)","
main :: IO ()
main = do
  let candidate = truncateNumber
  if candidate 3.5 == 0.5 then pure () else error ""assertion failed""
  if candidate 1.25 == 0.25 then pure () else error ""assertion failed""
  if candidate 123.0 == 0.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_3,fon_Latn,hs,"--ɖo finɛ ɔ azɔwan ɔ na lɛ́ kɔ́n true.--azɔ̀n núwùn tɔn. azɔ̀n towe wɛ nyí ɖɔ a na mɔ̀ nú azɔ̀n núwùn tɔn jɛ̀ núwùn jí ɖò fí ɖebǔ ɔ́, bɔ a na lɛ́ mɔ ɖɔ é jɛ̀ núwùn jí.--È na wèmá nùxwásá è ɖè sín akwɛ́xwé lɛ́ɛ tɔn ɖò akwɛ́xwé lɛ́ɛ tɔn jí bɔ è nɔ bɛ́ dó wèmá ɔ jí ɖɔ--  >>> belowZero [1,2,3]
--  False
--  >>> belowZero [1,2,(-4),5]
--  True
belowZero :: [Int] -> Bool
belowZero operations =","belowZero :: [Int] -> Bool
belowZero operations = any (< 0) $ scanl (+) 0 operations","
main :: IO ()
main = do
  let candidate = belowZero
  if candidate [] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-4),5,6] == True then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error ""assertion failed""
  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_4,fon_Latn,hs,"--MAD = mɛ̀. x - x_méan.--nǔɖevi kpo ayijε kpo (nɔntin ɔ ɖo ninɔmɛ elɔ mɛ): --Nǔ e nɔ nyí mɛɖesɔhwe mɛtɔn ɔ wɛ nyí mɛɖesɔhwe mɛtɔn e ɖò mɛ we lɛ tɛntin é.--e ɖò nǔ e è nɔ mɔ ɖò nǔ e è nɔ mɔ ɖò nǔ e è nɔ mɔ ɖò nǔ e è nɔ mɔ é mɛ é mɛ é.--e è na mɔ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ è è ná dó lɛ́ɛ ɔ́, è na lɛ́ mɔ mɛ e nɔ lɛ́ nyí mɛ e nɔ lɛ́ nyí mɛ ɔ́ é sín nǔ lɛ́ɛ.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]
--  1.0
meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers =","meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers = sum absoluteDifferences / fromIntegral (length numbers)
  where
    mean = sum numbers / fromIntegral (length numbers)
    absoluteDifferences = map (\x -> abs (x - mean)) numbers","
main :: IO ()
main = do
  let candidate = meanAbsoluteDeviation
  if candidate [1.0,2.0] == 0.5 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_5,fon_Latn,hs,"--̆ Zɔ́n nùjlɛ́kpo 'delimeter' ɖò nùɖé wè ɖò kpɔ́ nú nùjlɛ́kpo ̆ nùjlɛ́kpo 'input list' ̆ lɛ́ɛ ̆--  >>> intersperse [] 4
--  []
--  >>> intersperse [1,2,3] 4
--  [1,4,2,4,3]
intersperse :: [Int] -> Int -> [Int]
intersperse numbers delimeter =","intersperse :: [Int] -> Int -> [Int]
intersperse [] _ = []
intersperse [x] _ = [x]
intersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","
main :: IO ()
main = do
  let candidate = intersperse
  if candidate [] 7 == [] then pure () else error ""assertion failed""
  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error ""assertion failed""
  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_6,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ (() (()) ɖó xɛ̀ wè ɖò gbɛmɛ bɔ ((())) ɖó atɔn. --Ɖo kplékplé ɖokpo ɖokpo ɔ mɛ ɔ, ɖè tɛn e mɛ nùɖé lɛ́ɛ nɔ ɖò mɛ é ɖó wuntun lɛ́ɛ mɛ.--̆ Nǔ e è nɔ sɔ́ dó azɔ̀ elɔ mɛ é wɛ nyí nùkwín ɖé bɔ è nɔ sɔ́ dó ɖè nùɖé lɛ́ɛ ɖó kpɔ́ bɔ è nɔ sɔ́ nùɖé lɛ́ɛ ɖó vo nú yeɖée.--  >>> parseNestedParens ""(()()) ((())) () ((())()())""
--  [2,3,1,3]
parseNestedParens :: String -> [Int]
parseNestedParens paren_string =","parseNestedParens :: String -> [Int]
parseNestedParens paren_string = map maxDepth (words paren_string)
  where
    maxDepth :: String -> Int
    maxDepth = go 0 0
      where
        go :: Int -> Int -> String -> Int
        go currentDepth maxDepth [] = maxDepth
        go currentDepth maxDepth (c:cs)
          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs
          | c == ')'  = go (currentDepth - 1) maxDepth cs
          | otherwise = go currentDepth maxDepth cs","
main :: IO ()
main = do
  let candidate = parseNestedParens
  if candidate ""(()()) ((())) () ((())()())"" == [2,3,1,3] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [4] then pure () else error ""assertion failed""
  pure ()"
HumanEval_7,fon_Latn,hs,"--◯ Zán wuntun lɛ sín nùxwásá bo sɔ́ wuntun e ɖò wuntun ɔ sín akpáxwé ɖé mɛ lɛ é dó wuntun ɔ mɛ.--  >>> filterBySubstring [] ""a""
--  []
--  >>> filterBySubstring [""abc"",""bacd"",""cde"",""array""] ""a""
--  [""abc"",""bacd"",""array""]
filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring =","filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring = filter (substring `isInfixOf`) strings
  where isInfixOf = isInfixOf","
main :: IO ()
main = do
  let candidate = filterBySubstring
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""aaaxxy"",""john doe"",""xxxAAA"",""xxx""] ""xx"" == [""xxx"",""aaaxxy"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""grunt"",""trumpet"",""prune"",""gruesome""] ""run"" == [""grunt"",""prune""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_8,fon_Latn,hs,"--Xwédo e ma ɖó nǔ ɖé ǎ é ɖó na nyí 0 bɔ nǔ e ma ɖó nǔ ɖé ǎ é ɖó na nyí 1.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> sumProduct []
--  (0, 1)
--  >>> sumProduct [1,2,3,4]
--  (10, 24)
sumProduct :: [Int] -> (Int, Int)
sumProduct numbers =","sumProduct :: [Int] -> (Int, Int)
sumProduct numbers = (sum numbers, product numbers)","
main :: IO ()
main = do
  let candidate = sumProduct
  if candidate [] == (0, 1) then pure () else error ""assertion failed""
  if candidate [1,1,1] == (3, 1) then pure () else error ""assertion failed""
  if candidate [100,0] == (100, 0) then pure () else error ""assertion failed""
  if candidate [3,5,7] == (15, 105) then pure () else error ""assertion failed""
  if candidate [10] == (10, 10) then pure () else error ""assertion failed""
  pure ()"
HumanEval_9,fon_Latn,hs,"--ɖo hunhun ɔ mɛ.--│N'í ɔ, è na sɔ́ nùxwlé lɛ sín nùxwlé ɖé dó bló nùxwlé ɖé bɔ è na mɔ nǔ e ɖò nǔ jí hú ɖě lɛ bǐ é ɖò hweɖelɛnu.--  >>> rollingMax [1,2,3,2,3,4,2]
--  [1,2,3,3,3,4,4]
rollingMax :: [Int] -> [Int]
rollingMax numbers =","rollingMax :: [Int] -> [Int]
rollingMax = scanl1 max","
main :: IO ()
main = do
  let candidate = rollingMax
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error ""assertion failed""
  pure ()"
HumanEval_10,fon_Latn,hs,"--- Zɔ́n wèmá è nɔ́ nyí wèmá-kpò-kpò ɔ́ sín nukɔnmɛ e nɔ́ jɛ nukɔn nú wèmá-kpò-kpò e nɔ nyí wèmá-kpò-kpò é.--- Xà postfix mɛxo tɔn e nyí palindrome é ɖò xɛ ɔ mɛ.--Alɔgorithm linlin ɔ nyi mε: --◯ Xà palindrome kpɛví e bɛ́ ɖò xɛ̀ e è na é jí é.--  >>> makePalindrome """"
--  """"
--  >>> makePalindrome ""cat""
--  ""catac""
--  >>> makePalindrome ""cata""
--  ""catac""
makePalindrome :: String -> String
makePalindrome string =","makePalindrome :: String -> String
makePalindrome string = string ++ reverse (take (length string - palindromeLength) string)
  where
    palindromeLength = longestPalindromicSuffix string

longestPalindromicSuffix :: String -> Int
longestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]

isPalindrome :: String -> Bool
isPalindrome s = s == reverse s","
main :: IO ()
main = do
  let candidate = makePalindrome
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""x"" == ""x"" then pure () else error ""assertion failed""
  if candidate ""xyz"" == ""xyzyx"" then pure () else error ""assertion failed""
  if candidate ""xyx"" == ""xyx"" then pure () else error ""assertion failed""
  if candidate ""jerry"" == ""jerryrrej"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_11,fon_Latn,hs,"--Zɔ́n xor binary dó nǔ è nɔ byɔ mɛ lɛ́ɛ jí bo lɛ́ lɛ́ wá mɔ̀ nùɖé lɛ́ nyí wuntun ɖé.--输入是两个字符串 a和b,只有1和0--  >>> stringXor ""010"" ""110""
--  ""100""
stringXor :: String -> String -> String
stringXor a b =","stringXor :: String -> String -> String
stringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","
main :: IO ()
main = do
  let candidate = stringXor
  if candidate ""111000"" ""101010"" == ""010010"" then pure () else error ""assertion failed""
  if candidate ""1"" ""1"" == ""0"" then pure () else error ""assertion failed""
  if candidate ""0101"" ""0000"" == ""0101"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_12,fon_Latn,hs,"--e nɔ na w'azɔ̌ e na nɔ mɔ lɛ é ɖokpo ɔ. E na lɛ́ lɛ́ yí nǔɖé ɖò nù e è w'azɔ̌ ɔ mɛ é mɛ ǎ.--̆ E na lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́--  >>> longest []
--  Just (Nothing)
--  >>> longest [""a"",""b"",""c""]
--  Just (""a"")
--  >>> longest [""a"",""bb"",""ccc""]
--  Just (""ccc"")
longest :: [String] -> Maybe String
longest strings =","longest :: [String] -> Maybe String
longest [] = Nothing
longest strings = Just $ foldl1 (\acc x -> if length x > length acc then x else acc) strings","
main :: IO ()
main = do
  let candidate = longest
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == Just (""x"") then pure () else error ""assertion failed""
  if candidate [""x"",""yyy"",""zzzz"",""www"",""kkkk"",""abc""] == Just (""zzzz"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_13,fon_Latn,hs,"--Ðɔ nǔ e nɔ zɔ́n bɔ nùjlɛ́kpá wè a kpo b kpo nɔ ɖó nǔ e nɔ zɔ́n bɔ è nɔ ɖó nǔ e nɔ zɔ́n bɔ è nɔ ɖó nǔ e nɔ zɔ́n bɔ è nɔ ɖó nǔ wè é.--  >>> greatestCommonDivisor 3 5
--  1
--  >>> greatestCommonDivisor 25 15
--  5
greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b =","greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b
  | b == 0    = a
  | otherwise = greatestCommonDivisor b (a `mod` b)","
main :: IO ()
main = do
  let candidate = greatestCommonDivisor
  if candidate 3 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 15 == 5 then pure () else error ""assertion failed""
  if candidate 49 14 == 7 then pure () else error ""assertion failed""
  if candidate 144 60 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_14,fon_Latn,hs,"--│ lɛ ɔ e na lɛ ɔ e na lɛ ɔ ɔ ɔ e na lɛ ɔ ɔ ɔ e na lɛ ɔ ɔ ɔ--  >>> allPrefixes ""abc""
--  [""a"",""ab"",""abc""]
allPrefixes :: String -> [String]
allPrefixes string =","allPrefixes :: String -> [String]
allPrefixes string = [take n string | n <- [1 .. length string]]","
main :: IO ()
main = do
  let candidate = allPrefixes
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""asdfgh"" == [""a"",""as"",""asd"",""asdf"",""asdfg"",""asdfgh""] then pure () else error ""assertion failed""
  if candidate ""WWW"" == [""W"",""WW"",""WWW""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_15,fon_Latn,hs,"--̆ E na lɛ́ lɛ́ yí nùkwín e ɖò nùjlɛ́kpo lɛ́ɛ jí ɖò fí è ɖè lɛ́ɛ jí é sín 0 jɛ n jí.--  >>> stringSequence 0
--  ""0""
--  >>> stringSequence 5
--  ""0 1 2 3 4 5""
stringSequence :: Int -> String
stringSequence n =","stringSequence :: Int -> String
stringSequence n = unwords $ map show [0..n]","
main :: IO ()
main = do
  let candidate = stringSequence
  if candidate 0 == ""0"" then pure () else error ""assertion failed""
  if candidate 3 == ""0 1 2 3"" then pure () else error ""assertion failed""
  if candidate 10 == ""0 1 2 3 4 5 6 7 8 9 10"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_16,fon_Latn,hs,"--◯ Wǎ nú wuntun ɖé, bo kpɔ́n ɖɔ wuntun alɔkpa nabí lɛ́ɛ wɛ ɖò wuntun ɔ mɛ (e ɖò nǔ e è wlan é mɛ ǎ)--  >>> countDistinctCharacters ""xyzXYZ""
--  3
--  >>> countDistinctCharacters ""Jerry""
--  4
countDistinctCharacters :: String -> Int
countDistinctCharacters string =","import Data.Char (toLower)
import Data.Set (fromList, size)

countDistinctCharacters :: String -> Int
countDistinctCharacters string = size . fromList $ map toLower string","
main :: IO ()
main = do
  let candidate = countDistinctCharacters
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abcde"" == 5 then pure () else error ""assertion failed""
  if candidate ""abcdecadeCADE"" == 5 then pure () else error ""assertion failed""
  if candidate ""aaaaAAAAaaaa"" == 1 then pure () else error ""assertion failed""
  if candidate ""Jerry jERRY JeRRRY"" == 5 then pure () else error ""assertion failed""
  pure ()"
HumanEval_17,fon_Latn,hs,"--'High' - nǔ e è nɔ ylɔ ɖɔ quater, bɔ é nɔ xɔ̀n azɔn ɖokpo--'o saji' - nǔxixo ayizɛ́n, bɔ é nɔ́ nɔ wè--'O' - nǔ e è nɔ ylɔ ɖɔ 'o' é bǐ, é nɔ xɔ azɔn ɛnɛ--Nǔ e è ɖɔ dó hwenuxó ɔ wú ɔ ɖíe:--é nyí gudo tɔn ǎ.--azɔ towe wɛ nyí ɖɔ a na wlan xixo elɔ bo na lɛ́ lɛ́ lɛ́ vɔ́ nùxwásá e sɔgbe xá nabí e mɛ ɖokpó ɖokpó na xo é--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> parseMusic ""o o| .| o| o| .| .| .| .| o o""
--  [4,2,1,2,2,1,1,1,1,4,4]
parseMusic :: String -> [Int]
parseMusic music_string =","parseMusic :: String -> [Int]
parseMusic music_string = map beats (words music_string)
  where
    beats ""o"" = 4
    beats ""o|"" = 2
    beats "".|"" = 1
    beats _ = 0","
main :: IO ()
main = do
  let candidate = parseMusic
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""o o o o"" == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate "".| .| .| .|"" == [1,1,1,1] then pure () else error ""assertion failed""
  if candidate ""o| o| .| .| o o o o"" == [2,2,1,1,4,4,4,4] then pure () else error ""assertion failed""
  if candidate ""o| .| o| .| o o| o o|"" == [2,1,2,1,4,2,4,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_18,fon_Latn,hs,"--│Xà nǔ e è na mɔ ɖò xwɛ ɔ mɛ é nú azɔn nabí e è na mɔ ɖò xwɛ ɔ mɛ é.--  >>> howManyTimes """" ""a""
--  0
--  >>> howManyTimes ""aaa"" ""a""
--  3
--  >>> howManyTimes ""aaaa"" ""aa""
--  3
howManyTimes :: String -> String -> Int
howManyTimes string substring =","howManyTimes :: String -> String -> Int
howManyTimes string substring
  | null substring = 0
  | otherwise = length . filter isPrefixOfSubstring $ tails string
  where
    isPrefixOfSubstring = isPrefixOf substring
    isPrefixOf :: Eq a => [a] -> [a] -> Bool
    isPrefixOf prefix str = prefix `isPrefixOf` str","
main :: IO ()
main = do
  let candidate = howManyTimes
  if candidate """" ""x"" == 0 then pure () else error ""assertion failed""
  if candidate ""xyxyxyx"" ""x"" == 4 then pure () else error ""assertion failed""
  if candidate ""cacacacac"" ""cac"" == 4 then pure () else error ""assertion failed""
  if candidate ""john doe"" ""john"" == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_19,fon_Latn,hs,"--Zɔ́n nùjlɛ́kpo lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé kpɛví bǐ jɛ nùɖé ɖaxó bǐ jí --Nǔ e è sixu sɔ́ lɛ́ɛ wɛ nyí 'wǒ', 'ɖokpo', 'we', ' atɔn', 'nɛ', 'atɔ́n', 'sín', 'sínwe', 'zǒzǒ' kpo 'tɔn'. --¢ãéï åßíáé Ýíá ðåñéïñéóìÝíï ðëáßóéï óôáèìþí áðü ôï '0' ìÝ÷ñé ôï '9'.--  >>> sortNumbers ""three one five""
--  ""one three five""
sortNumbers :: String -> String
sortNumbers numbers =","import Data.List (sort)
import Data.Maybe (fromJust)
import Data.Map (Map, fromList, lookup)

sortNumbers :: String -> String
sortNumbers numbers = unwords $ map snd $ sort $ map (\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)
  where
    wordToNumber :: Map String Int
    wordToNumber = fromList [(""zero"", 0), (""one"", 1), (""two"", 2), (""three"", 3), (""four"", 4),
                             (""five"", 5), (""six"", 6), (""seven"", 7), (""eight"", 8), (""nine"", 9)]","
main :: IO ()
main = do
  let candidate = sortNumbers
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""three"" == ""three"" then pure () else error ""assertion failed""
  if candidate ""three five nine"" == ""three five nine"" then pure () else error ""assertion failed""
  if candidate ""five zero four seven nine eight"" == ""zero four five seven eight nine"" then pure () else error ""assertion failed""
  if candidate ""six five four three two one zero"" == ""zero one two three four five six"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_20,fon_Latn,hs,"--bo na lɛ́ lɛ́ kɔ́n yě ɖò tito jí (àkwɛ́ kpɛví, àkwɛ́ ɖaxó).--│Xà nùxwásá e è ná lɛ́ ɖò nùxwásá lɛ́ɛ jí é (e nɔ́ ná wè ɖò wè jí) bo sɔ́ we e ɖò wè jí lɛ́ɛ bó lɛ́ lɛ́ lɛ́ wá nú we lɛ́ɛ.--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]
--  (2.0, 2.2)
--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]
--  (2.0, 2.0)
findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers =","findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)
  where
    sortedNumbers = sort numbers
    minByDiff (a1, b1) (a2, b2)
      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)
      | otherwise = (a2, b2)","
main :: IO ()
main = do
  let candidate = findClosestElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_21,fon_Latn,hs,"--e na zɔ́n bɔ nùxà e ɖò kpɛví hú bǐ é na húzú 0 bɔ nùxà e ɖò ɖaxó hú bǐ é na húzú 1 --│Nɛ è na wlan nùxwlé lɛ sín nùxwlé (e nɔ ɖó nùɖé wè ɖò mɛ é), è na zán nùxwlé lɛ sín nùxwlé lɛ sín nùxwlé lɛ dó nùxwlé énɛ́ ɔ jí,--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]
--  [0.0,0.25,0.5,0.75,1.0]
rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers =","rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers = map (\x -> (x - minVal) / range) numbers
  where
    minVal = minimum numbers
    maxVal = maximum numbers
    range = maxVal - minVal","
main :: IO ()
main = do
  let candidate = rescaleToUnit
  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error ""assertion failed""
  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error ""assertion failed""
  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  pure ()"
HumanEval_23,fon_Latn,hs,"--│Nyɔ e è na wlan ɔ sín gege tɔn ɔ.--  >>> strlen """"
--  0
--  >>> strlen ""abc""
--  3
strlen :: String -> Int
strlen string =","strlen :: String -> Int
strlen string = length string","
main :: IO ()
main = do
  let candidate = strlen
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""x"" == 1 then pure () else error ""assertion failed""
  if candidate ""asdasnakj"" == 9 then pure () else error ""assertion failed""
  pure ()"
HumanEval_24,fon_Latn,hs,"--Ÿ na nùxwlé e è ná mì é n ɔ, mɔ nùxwlé e ɖò nùxwlé e nɔ má n ɖó wè é é, e nɔ hú nùxwlé e è ná mì é.--  >>> largestDivisor 15
--  5
largestDivisor :: Int -> Int
largestDivisor n =","largestDivisor :: Int -> Int
largestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = largestDivisor
  if candidate 3 == 1 then pure () else error ""assertion failed""
  if candidate 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 == 5 then pure () else error ""assertion failed""
  if candidate 100 == 50 then pure () else error ""assertion failed""
  if candidate 49 == 7 then pure () else error ""assertion failed""
  pure ()"
HumanEval_25,fon_Latn,hs,"--nùmε e è nɔ sɔ́ dó wlan ɔ ná ɔ na cí nùtɔ́n e è nɔ sɔ́ dó wlan nǔ lɛ bǐ é ɖɔhun.--E na wlan nuɖevi ɖokpo ɖokpo ɔ azɔn nabi e é nɔ tɔ́n ɖò nǔkpɔnkpɔn mɛ é.--│Nɔ ɔ na lɛ́ lɛ́ lɛ́ kɔ nú nùjlɛ́kpá e è ná lɛ́ ná é sín nùjlɛ́kpá kpɛví ɔ́ jí jɛ nùjlɛ́kpá ɖaxó ɔ́ jí.--  >>> factorize 8
--  [2,2,2]
--  >>> factorize 25
--  [5,5]
--  >>> factorize 70
--  [2,5,7]
factorize :: Int -> [Int]
factorize n =","factorize :: Int -> [Int]
factorize n = factorize' n 2
  where
    factorize' 1 _ = []
    factorize' m f
      | m `mod` f == 0 = f : factorize' (m `div` f) f
      | otherwise      = factorize' m (f + 1)","
main :: IO ()
main = do
  let candidate = factorize
  if candidate 2 == [2] then pure () else error ""assertion failed""
  if candidate 4 == [2,2] then pure () else error ""assertion failed""
  if candidate 8 == [2,2,2] then pure () else error ""assertion failed""
  if candidate 57 == [3,19] then pure () else error ""assertion failed""
  if candidate 3249 == [3,3,19,19] then pure () else error ""assertion failed""
  if candidate 185193 == [3,3,3,19,19,19] then pure () else error ""assertion failed""
  if candidate 20577 == [3,19,19,19] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_26,fon_Latn,hs,"--Mi hɛn nǔ lɛ sín tito ɔ ɖesu ɖi lee mi hɛn ye gbɔn ɖò nǔ e mi wlan lɛ é mɛ é ɖɔhun.--◯ Hɔn nǔ e nɔ jɛ azɔn hú ɖokpo é bǐ sín nùxwlémɛ e mɛ è nɔ mɔ nùxixa ɔ ɖè é mɛ.--  >>> removeDuplicates [1,2,3,2,4]
--  [1,3,4]
removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers =","removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers = filter (\x -> count x numbers == 1) numbers
  where
    count x = length . filter (== x)","
main :: IO ()
main = do
  let candidate = removeDuplicates
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error ""assertion failed""
  pure ()"
HumanEval_27,fon_Latn,hs,"--◯ Nú è na wlan wuntun ɖé ɔ, wlan wuntun kpɛví lɛ dó wuntun ɖaxó lɛ mɛ, wuntun ɖaxó lɛ dó wuntun kpɛví lɛ mɛ.--  >>> flipCase ""Hello""
--  ""hELLO""
flipCase :: String -> String
flipCase string =","flipCase :: String -> String
flipCase = map flipChar
  where
    flipChar c
      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)
      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)
      | otherwise = c","
main :: IO ()
main = do
  let candidate = flipCase
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hello!"" == ""hELLO!"" then pure () else error ""assertion failed""
  if candidate ""These violent delights have violent ends"" == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_28,fon_Latn,hs,"--◯ Wěma lɛ sín xota ɖó kpɔ́ bɔ è wlan dó wuntun ɖokpo mɛ--  >>> concatenate []
--  """"
--  >>> concatenate [""a"",""b"",""c""]
--  ""abc""
concatenate :: [String] -> String
concatenate strings =","concatenate :: [String] -> String
concatenate strings = concat strings","
main :: IO ()
main = do
  let candidate = concatenate
  if candidate [] == """" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == ""xyz"" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z"",""w"",""k""] == ""xyzwk"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_29,fon_Latn,hs,"--◯ Filter a input list of strings for ones that start with a given prefix. ◯ Filter a input list of strings for ones that start with a given prefix.--  >>> filterByPrefix [] ""a""
--  []
--  >>> filterByPrefix [""abc"",""bcd"",""cde"",""array""] ""a""
--  [""abc"",""array""]
filterByPrefix :: [String] -> String -> [String]
filterByPrefix strings prefix =","filterByPrefix strings prefix = filter (isPrefixOf prefix) strings
  where
    isPrefixOf pfx str = take (length pfx) str == pfx","
main :: IO ()
main = do
  let candidate = filterByPrefix
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_30,fon_Latn,hs,"--│Nyɔ e ɖò nùxwásá ɔ mɛ lɛ é kɛɖɛ wɛ é na lɛ́ na.--  >>> getPositive [(-1),2,(-4),5,6]
--  [2,5,6]
--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  [5,3,2,3,9,123,1]
getPositive :: [Int] -> [Int]
getPositive l =","getPositive :: [Int] -> [Int]
getPositive l = filter (> 0) l","
main :: IO ()
main = do
  let candidate = getPositive
  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error ""assertion failed""
  if candidate [(-1),(-2)] == [] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_31,fon_Latn,hs,"--│Nɔ ɔ na lɛ́ lɛ́ wá nyí nùɖé nú nùjlɛ́n e è na lɛ́ ná é nyí nùjlɛ́n taɖutɔ́ ɖé ɔ, é na lɛ́ wá nyí nǔvú nú nùɖé.--  >>> isPrime 6
--  False
--  >>> isPrime 101
--  True
--  >>> isPrime 11
--  True
--  >>> isPrime 13441
--  True
--  >>> isPrime 61
--  True
--  >>> isPrime 4
--  False
--  >>> isPrime 1
--  False
isPrime :: Int -> Bool
isPrime n =","isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = not (any (\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","
main :: IO ()
main = do
  let candidate = isPrime
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 101 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 13441 == True then pure () else error ""assertion failed""
  if candidate 61 == True then pure () else error ""assertion failed""
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 1 == False then pure () else error ""assertion failed""
  if candidate 5 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 17 == True then pure () else error ""assertion failed""
  if candidate 85 == False then pure () else error ""assertion failed""
  if candidate 77 == False then pure () else error ""assertion failed""
  if candidate 255379 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_33,fon_Latn,hs,"--e nɔ sɔ́ dó nǔ e è nɔ ylɔ́ ɖɔ ""l"" lɛ́ɛ wu, amɔ̌ è nɔ ɖè ye ɖó vovo.--l' cí l ɖɔhun ɖò nǔ e è ma nɔ má ɖó atɔn ǎ lɛ é mɛ, có nùjlɛ́n tɔn lɛ ɖò nǔ e è nɔ má ɖó atɔn lɛ é mɛ ɔ, ɖokpo ɔ wɛ ye nyí --azɔ̀ élɔ́ nɔ́ yí nùkwín l bó nɔ́ lɛ́ yí nùkwín l mɔ̌hun--  >>> sortThird [1,2,3]
--  [1,2,3]
--  >>> sortThird [5,6,3,4,8,9,2]
--  [2,6,3,4,8,9,5]
sortThird :: [Int] -> [Int]
sortThird l =","sortThird :: [Int] -> [Int]
sortThird l = map selectElem indexed
  where
    indexed = zip [0..] l
    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]
    sortedThirdElems = sortedElems thirdIndicesElems
    sortedElems = id -- or List.sort if imported
    selectElem (i, x)
      | i `mod` 3 == 0 = head sortedThirdElems
      | otherwise = x
    replaceSortedElem xs sorted = map selectElem indexed
      where
        replaceElem i (x:xs)
          | i == 0 = x:xs
          | otherwise = replaceElem (i - 1) xs
        selectElem (i, x)
          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)
          | otherwise = x","
main :: IO ()
main = do
  let candidate = sortThird
  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error ""assertion failed""
  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error ""assertion failed""
  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error ""assertion failed""
  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_34,fon_Latn,hs,"--̆ Zɔ̀n nǔɖòɖó bunɔ e è ɖè ɖò nùwlanwlan ɖé mɛ lɛ é--  >>> unique [5,3,5,2,3,3,9,0,123]
--  [0,2,3,5,9,123]
unique :: [Int] -> [Int]
unique l =","unique :: [Int] -> [Int]
unique l = sort $ nub l
  where
    -- | Remove duplicate elements from a list.
    nub :: (Eq a) => [a] -> [a]
    nub [] = []
    nub (x:xs) = x : nub (filter (/= x) xs)

    -- | Sort a list of elements (using QuickSort algorithm).
    sort :: (Ord a) => [a] -> [a]
    sort [] = []
    sort (x:xs) =
      let smallerSorted = sort [a | a <- xs, a <= x]
          biggerSorted = sort [a | a <- xs, a > x]
      in  smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = unique
  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error ""assertion failed""
  pure ()"
HumanEval_35,fon_Latn,hs,"--│Nɔ ɔ ɖo nǔ e ɖo atɛ ɔ mɛ é bǐ wɛ.--  >>> maxElement [1,2,3]
--  3
--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  123
maxElement :: [Int] -> Int
maxElement l =","maxElement :: [Int] -> Int
maxElement [] = error ""List cannot be empty""
maxElement (x:xs) = maxElementHelper xs x
  where
    maxElementHelper [] currentMax = currentMax
    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","
main :: IO ()
main = do
  let candidate = maxElement
  if candidate [1,2,3] == 3 then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error ""assertion failed""
  pure ()"
HumanEval_36,fon_Latn,hs,"--│Nɔ ɔ na lɛ́ lɛ́ nú azɔn nabí e nùjlɛ́kpo 7 ɔ na tɔ́n ɖò nùjlɛ́kpo e ɖò kpò nú nú n bɔ è na má ɖó nú 11 alǒ 13. │--  >>> fizzBuzz 50
--  0
--  >>> fizzBuzz 78
--  2
--  >>> fizzBuzz 79
--  3
fizzBuzz :: Int -> Int
fizzBuzz n =","fizzBuzz :: Int -> Int
fizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","
main :: IO ()
main = do
  let candidate = fizzBuzz
  if candidate 50 == 0 then pure () else error ""assertion failed""
  if candidate 78 == 2 then pure () else error ""assertion failed""
  if candidate 79 == 3 then pure () else error ""assertion failed""
  if candidate 100 == 3 then pure () else error ""assertion failed""
  if candidate 200 == 6 then pure () else error ""assertion failed""
  if candidate 4000 == 192 then pure () else error ""assertion failed""
  if candidate 10000 == 639 then pure () else error ""assertion failed""
  if candidate 100000 == 8026 then pure () else error ""assertion failed""
  pure ()"
HumanEval_37,fon_Latn,hs,"--e nɔ sɔ́ dó nùjlɛ́jlɛ́ e ɖò l jí lɛ́ɛ jí, amɔ̌ è nɔ ɖè ye ɖó alɔkpa ɖé.--l' cí l ɖò nùjlɛ́jlɛ́ e nyí nǔɖòɖó ɖé lɛ é mɛ, có nùjlɛ́jlɛ́jlɛ́ tɔn lɛ ɖò nùjlɛ́jlɛ́ e nyí nǔɖòɖó lɛ é mɛ ɔ cí ɖokpo ɔ́ ɖɔhun.--azɔ̀ élɔ́ nɔ́ yí nùkwín l bó nɔ́ lɛ́ yí nùkwín l mɔ̌hun--  >>> sortEven [1,2,3]
--  [1,2,3]
--  >>> sortEven [5,6,3,4]
--  [3,6,5,4]
sortEven :: [Int] -> [Int]
sortEven l =","sortEven :: [Int] -> [Int]
sortEven l = merge odds sortedEvens
  where
    (odds, evens) = partitionList l
    sortedEvens = sort evens

    partitionList :: [Int] -> ([Int], [Int])
    partitionList [] = ([], [])
    partitionList [x] = ([x], [])
    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)
      where
        (xsOdds, xsEvens) = partitionList xs

    merge :: [Int] -> [Int] -> [Int]
    merge [] ys = ys
    merge (x:xs) [] = x:xs
    merge (x:xs) (y:ys) = x:y:merge xs ys","
main :: IO ()
main = do
  let candidate = sortEven
  if candidate [1,2,3] == [1,2,3] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error ""assertion failed""
  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_39,fon_Latn,hs,"--prime_fib nɔ lɛ́ yí nùɖé nú númɛ̀ n-ɔ́tɔ́ ɔ́' númɛ̀ Fibonacci tɔn bɔ é nyí nùɖé nú númɛ̀ nùɖé nú númɛ̀ ɔ́ lɔ.--  >>> primeFib 1
--  2
--  >>> primeFib 2
--  3
--  >>> primeFib 3
--  5
--  >>> primeFib 4
--  13
--  >>> primeFib 5
--  89
primeFib :: Int -> Int
primeFib n =","primeFib :: Int -> Int
primeFib n = primeFibs !! (n - 1)
  where
    primeFibs = filter isPrime fibs
    fibs = map fst $ iterate (\(a, b) -> (b, a + b)) (0, 1)

isPrime :: Int -> Bool
isPrime k
  | k < 2 = False
  | k == 2 = True
  | even k = False
  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]
  where
    upperLimit = floor . sqrt $ fromIntegral k","
main :: IO ()
main = do
  let candidate = primeFib
  if candidate 1 == 2 then pure () else error ""assertion failed""
  if candidate 2 == 3 then pure () else error ""assertion failed""
  if candidate 3 == 5 then pure () else error ""assertion failed""
  if candidate 4 == 13 then pure () else error ""assertion failed""
  if candidate 5 == 89 then pure () else error ""assertion failed""
  if candidate 6 == 233 then pure () else error ""assertion failed""
  if candidate 7 == 1597 then pure () else error ""assertion failed""
  if candidate 8 == 28657 then pure () else error ""assertion failed""
  if candidate 9 == 514229 then pure () else error ""assertion failed""
  if candidate 10 == 433494437 then pure () else error ""assertion failed""
  pure ()"
HumanEval_40,fon_Latn,hs,"--nùɖé ɔ́' nǔ e nyí nǔ ɔ́' nǔ e nyí nǔ ǎ é wɛ.--é na lɛ́ kɔ́n True nú nǔɖòɖó atɔn ɖò nùjlɛ́jlɛ́ ɔ́ mɛ bɔ --3_sum_to_zero nɔ yí nùɖé lɛ sín nùɖé lɛ dó nùɖé lɛ mɛ.--  >>> triplesSumToZero [1,3,5,0]
--  False
--  >>> triplesSumToZero [1,3,(-2),1]
--  True
--  >>> triplesSumToZero [1,2,3,7]
--  False
--  >>> triplesSumToZero [2,4,(-5),3,9,7]
--  True
--  >>> triplesSumToZero [1]
--  False
triplesSumToZero :: [Int] -> Bool
triplesSumToZero l =","triplesSumToZero :: [Int] -> Bool
triplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]
  where
    tails [] = []
    tails xs@(_:xs') = xs : tails xs'","
main :: IO ()
main = do
  let candidate = triplesSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-1)] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [1,2,5,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,9,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-100)] == False then pure () else error ""assertion failed""
  if candidate [100,3,5,(-100)] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_41,fon_Latn,hs,"--azɔ̀n élɔ́ nɔ́ sɔ́ nùɖé lɛ́ɛ dó nùɖé lɛ́ɛ mɛ̀.--ye nɔ ɖò yiyi wɛ ɖi ɖɔ ye ma ko mɔ yeɖée kpɔ́n gbeɖé ǎ ɖɔhun.--Amɔ̌, kɛkɛ́ lɛ́ɛ ɖó hlɔnhlɔn bo lɛ́ ɖó hlɔnhlɔn tawun; enɛ wu ɔ, ye nɔ kpó ɖò yiyi wɛ.--hwenu e mɔto e ɖò yiyi wɛ sín amyɔxwé yì ɖisixwé é xò mɔto e ɖò yiyi wɛ sín ɖisixwé yì amyɔxwé é.--mɔ̌ wɛ mɛ lɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛ--ye ɖo ali we wɛ.--mɔto n nɔ ɖo ali ji wɛ sín amyɔxwé yì ɖisixwé; ɖò hwe ɖokpo ɔ nu ɔ, mɔto vovo lɛ tɔn n nɔ ɖo ali ji wɛ--│Nyɛ suɔmi nɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔ nɔ ɔ │mɛ ɔcarRaceCollision :: Int -> Int
carRaceCollision n =","carRaceCollision :: Int -> Int
carRaceCollision n = n","
main :: IO ()
main = do
  let candidate = carRaceCollision
  if candidate 2 == 4 then pure () else error ""assertion failed""
  if candidate 3 == 9 then pure () else error ""assertion failed""
  if candidate 4 == 16 then pure () else error ""assertion failed""
  if candidate 8 == 64 then pure () else error ""assertion failed""
  if candidate 10 == 100 then pure () else error ""assertion failed""
  pure ()"
HumanEval_42,fon_Latn,hs,"--│Nɔ ɔ na lɛ na nǔ lɛ e è sɔ́ 1 dó lɛ é.--  >>> incrList [1,2,3]
--  [2,3,4]
--  >>> incrList [5,3,5,2,3,3,9,0,123]
--  [6,4,6,3,4,4,10,1,124]
incrList :: [Int] -> [Int]
incrList l =","incrList :: [Int] -> [Int]
incrList l = map (+1) l","
main :: IO ()
main = do
  let candidate = incrList
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [4,3,2] then pure () else error ""assertion failed""
  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error ""assertion failed""
  pure ()"
HumanEval_43,fon_Latn,hs,"--nùɖé ɔ́' nǔ e nyí nǔ ɔ́' nǔ e nyí nǔ ǎ é wɛ.--é na lɛ́ kɔ́n True nú nǔ wè ɖò nùjlɛ́jlɛ́ ɔ́ mɛ bɔ --拼_s_sum_to_zero nɔ yí nùxwlé lɛ sín nùxwlé lɛ dó nùxwlé lɛ mɛ.--  >>> pairsSumToZero [1,3,5,0]
--  False
--  >>> pairsSumToZero [1,3,(-2),1]
--  False
--  >>> pairsSumToZero [1,2,3,7]
--  False
--  >>> pairsSumToZero [2,4,(-5),3,5,7]
--  True
--  >>> pairsSumToZero [1]
--  False
pairsSumToZero :: [Int] -> Bool
pairsSumToZero l =","pairsSumToZero :: [Int] -> Bool
pairsSumToZero l = any (\x -> -x `elem` l) l && (length l > 1)","
main :: IO ()
main = do
  let candidate = pairsSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,5,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_44,fon_Latn,hs,"--nùxwásá lɛ́ɛ ɖò hweɖénu hú 10.--lɛ́ kɔ́n nùjlɛ́jlɛ́ sín nùjlɛ́jlɛ́ ɔ́.--̆ Zě nùjlɛ́nkpa nú x ɔ́ dó nùjlɛ́nkpa nú x ɔ́.--  >>> changeBase 8 3
--  ""22""
--  >>> changeBase 8 2
--  ""1000""
--  >>> changeBase 7 2
--  ""111""
changeBase :: Int -> Int -> String
changeBase x base =","changeBase :: Int -> Int -> String
changeBase x base
  | x < base  = show x
  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","
main :: IO ()
main = do
  let candidate = changeBase
  if candidate 8 3 == ""22"" then pure () else error ""assertion failed""
  if candidate 9 3 == ""100"" then pure () else error ""assertion failed""
  if candidate 234 2 == ""11101010"" then pure () else error ""assertion failed""
  if candidate 16 2 == ""10000"" then pure () else error ""assertion failed""
  if candidate 8 2 == ""1000"" then pure () else error ""assertion failed""
  if candidate 7 2 == ""111"" then pure () else error ""assertion failed""
  if candidate 2 3 == ""2"" then pure () else error ""assertion failed""
  if candidate 3 4 == ""3"" then pure () else error ""assertion failed""
  if candidate 4 5 == ""4"" then pure () else error ""assertion failed""
  if candidate 5 6 == ""5"" then pure () else error ""assertion failed""
  if candidate 6 7 == ""6"" then pure () else error ""assertion failed""
  if candidate 7 8 == ""7"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_45,fon_Latn,hs,"--¢ñá Ý÷åé ìåãÜëï âáèìü êáé ðïëý ìåãÜëï âáèìü ðñïóôáóßáò ãéá Ýíá åíéó÷õôÞ.--  >>> triangleArea 5 3
--  7.5
triangleArea :: Int -> Int -> Float
triangleArea a h =","triangleArea :: Int -> Int -> Float
triangleArea a h = 0.5 * fromIntegral a * fromIntegral h","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 5 3 == 7.5 then pure () else error ""assertion failed""
  if candidate 2 2 == 2.0 then pure () else error ""assertion failed""
  if candidate 10 8 == 40.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_46,fon_Latn,hs,"--Mi wlan azɔ̀ ɖé bo na dó mɔ nùɖé lɛ́ɛ ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ fib4 tɔn mɛ. Mi ma zán nǔ e nɔ lɛ́ nyí nǔ lɛ́ɛ é ó.--fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --¢ñá ôï Fib4 åßíáé Ýíá ðëáßóéï ðïõ åßíáé óáí ôï Fibbonacci ðïõ ëÝãåôáé åðßóçò: --  >>> fib4 5
--  4
--  >>> fib4 6
--  8
--  >>> fib4 7
--  14
fib4 :: Int -> Int
fib4 n =","fib4 :: Int -> Int
fib4 n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 2
  | n == 3 = 0
  | otherwise = iter 0 0 2 0 n
  where
    iter a b c d 4 = a + b + c + d
    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","
main :: IO ()
main = do
  let candidate = fib4
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 28 then pure () else error ""assertion failed""
  if candidate 10 == 104 then pure () else error ""assertion failed""
  if candidate 12 == 386 then pure () else error ""assertion failed""
  pure ()"
HumanEval_47,fon_Latn,hs,"--̆ E na lɛ́ lɛ́ lɛ́ kɔ̀n nǔ e ɖò nùwlanwlan ɔ́ mɛ lɛ́ɛ sín nùxwlégbí ɔ́.--  >>> median [3,1,2,4,5]
--  3.0
--  >>> median [(-10),4,6,1000,10,20]
--  15.0
median :: [Int] -> Float
median l =","median :: [Int] -> Float
median l 
  | odd n     = fromIntegral $ sorted !! mid
  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) / 2
  where
    sorted = sort l
    n = length l
    mid = n `div` 2
    sort = sortBy compare","
main :: IO ()
main = do
  let candidate = median
  if candidate [3,1,2,4,5] == 3.0 then pure () else error ""assertion failed""
  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error ""assertion failed""
  if candidate [5] == 5.0 then pure () else error ""assertion failed""
  if candidate [6,5] == 5.5 then pure () else error ""assertion failed""
  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_48,fon_Latn,hs,"--ɔn nú wuntun e è ná é nyí palindrome à ɔn nú wuntun e è ná é nyí palindrome à ɔn nú wuntun e è ná é--  >>> isPalindrome """"
--  True
--  >>> isPalindrome ""aba""
--  True
--  >>> isPalindrome ""aaaaa""
--  True
--  >>> isPalindrome ""zbcd""
--  False
isPalindrome :: String -> Bool
isPalindrome text =","isPalindrome :: String -> Bool
isPalindrome text = text == reverse text","
main :: IO ()
main = do
  let candidate = isPalindrome
  if candidate """" == True then pure () else error ""assertion failed""
  if candidate ""aba"" == True then pure () else error ""assertion failed""
  if candidate ""aaaaa"" == True then pure () else error ""assertion failed""
  if candidate ""zbcd"" == False then pure () else error ""assertion failed""
  if candidate ""xywyx"" == True then pure () else error ""assertion failed""
  if candidate ""xywyz"" == False then pure () else error ""assertion failed""
  if candidate ""xywzx"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_49,fon_Latn,hs,"--Ðɔ 2^n modulo p (nùn nùmεkɔn).--  >>> modp 3 5
--  3
--  >>> modp 1101 101
--  2
--  >>> modp 0 101
--  1
--  >>> modp 3 11
--  8
--  >>> modp 100 101
--  1
modp :: Int -> Int -> Int
modp n p =","modp :: Int -> Int -> Int
modp n p = powMod 2 n p

powMod :: Int -> Int -> Int -> Int
powMod base exp modulus
  | modulus == 1 = 0
  | exp == 0     = 1
  | exp == 1     = base `mod` modulus
  | otherwise    = if odd exp
                   then (base * halfExp * halfExp) `mod` modulus
                   else (halfExp * halfExp) `mod` modulus
  where
    halfExp = powMod base (exp `div` 2) modulus","
main :: IO ()
main = do
  let candidate = modp
  if candidate 3 5 == 3 then pure () else error ""assertion failed""
  if candidate 1101 101 == 2 then pure () else error ""assertion failed""
  if candidate 0 101 == 1 then pure () else error ""assertion failed""
  if candidate 3 11 == 8 then pure () else error ""assertion failed""
  if candidate 100 101 == 1 then pure () else error ""assertion failed""
  if candidate 30 5 == 4 then pure () else error ""assertion failed""
  if candidate 31 5 == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_51,fon_Latn,hs,"--remove_vowels wɛ nyí azɔ̀ e nɔ yí wèmá bó nɔ lɛ́ lɛ́ wèmá e mɛ wèmá ɖě ma ɖè ǎ é.--  >>> removeVowels """"
--  """"
--  >>> removeVowels ""abcdef""
--  ""bcdf""
--  >>> removeVowels ""aaaaa""
--  """"
--  >>> removeVowels ""aaBAA""
--  ""B""
--  >>> removeVowels ""zbcd""
--  ""zbcd""
removeVowels :: String -> String
removeVowels text =","removeVowels :: String -> String
removeVowels text = filter (`notElem` ""aeiouAEIOU"") text","
main :: IO ()
main = do
  let candidate = removeVowels
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""abcdef
ghijklm"" == ""bcdf
ghjklm"" then pure () else error ""assertion failed""
  if candidate ""fedcba"" == ""fdcb"" then pure () else error ""assertion failed""
  if candidate ""eeeee"" == """" then pure () else error ""assertion failed""
  if candidate ""acBAA"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""EcBOO"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""ybcd"" == ""ybcd"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_52,fon_Latn,hs,"--│Nɔ ɔ ɔ ɔ, nú nùxwásá l' ɖò nùxwásá ɔ mɛ lɛ́ɛ bǐ ɖò fí e è nɔ ɖó nǔ e è nɔ ylɔ ɖɔ t' é ǎ ɔ, é nɔ lɛ́ nyí nugbǒ.--  >>> belowThreshold [1,2,4,10] 100
--  True
--  >>> belowThreshold [1,20,4,10] 5
--  False
belowThreshold :: [Int] -> Int -> Bool
belowThreshold l t =",belowThreshold l t = all (< t) l,"
main :: IO ()
main = do
  let candidate = belowThreshold
  if candidate [1,2,4,10] 100 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 5 == False then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 21 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 22 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 11 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_53,fon_Latn,hs,"--¢ñá ðÜñå 2 ðïëëÜ x êáé y--  >>> add 2 3
--  5
--  >>> add 5 7
--  12
add :: Int -> Int -> Int
add x y =","add :: Int -> Int -> Int
add x y = x + y","
main :: IO ()
main = do
  let candidate = add
  if candidate 0 1 == 1 then pure () else error ""assertion failed""
  if candidate 1 0 == 1 then pure () else error ""assertion failed""
  if candidate 2 3 == 5 then pure () else error ""assertion failed""
  if candidate 5 7 == 12 then pure () else error ""assertion failed""
  if candidate 7 5 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_54,fon_Latn,hs,"--◯ Kpɔ́n ɖɔ xókwin wè ɖó wuntun ɖokpo ɔ à jí.--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc""
--  True
--  >>> sameChars ""abcd"" ""dddddddabc""
--  True
--  >>> sameChars ""dddddddabc"" ""abcd""
--  True
--  >>> sameChars ""eabcd"" ""dddddddabc""
--  False
--  >>> sameChars ""abcd"" ""dddddddabce""
--  False
--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc""
--  False
sameChars :: String -> String -> Bool
sameChars s0 s1 =","import Data.List (nub, sort)

sameChars :: String -> String -> Bool
sameChars s0 s1 = sort (nub s0) == sort (nub s1)","
main :: IO ()
main = do
  let candidate = sameChars
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddeddabc"" == True then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabc"" == True then pure () else error ""assertion failed""
  if candidate ""dddddddabc"" ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""eabcd"" ""dddddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabcf"" == False then pure () else error ""assertion failed""
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""aabb"" ""aaccc"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_55,fon_Latn,hs,"--Ðɔ númɛ Fibonacci tɔn n-ɔ ɔ.--  >>> fib 10
--  55
--  >>> fib 1
--  1
--  >>> fib 8
--  21
fib :: Int -> Int
fib n =","fib :: Int -> Int
fib n = fibHelper 0 1 n
  where
    fibHelper a _ 0 = a
    fibHelper a b n = fibHelper b (a + b) (n - 1)","
main :: IO ()
main = do
  let candidate = fib
  if candidate 10 == 55 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 8 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 89 then pure () else error ""assertion failed""
  if candidate 12 == 144 then pure () else error ""assertion failed""
  pure ()"
HumanEval_56,fon_Latn,hs,"--lɛ́ kɔ́n nǔ e nyí nugbǒ é nú wuntun e nɔ hun lɛ é bǐ ɖó wuntun e nɔ sú lɛ é ɖokpo. --ɛ́n lɛ́ɛ ɔ́' wuntun ""<"" kpo "">"" kpo wɛ.--  >>> correctBracketing ""<""
--  False
--  >>> correctBracketing ""<>""
--  True
--  >>> correctBracketing ""<<><>>""
--  True
--  >>> correctBracketing ""><<>""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBrackets brackets 0 == 0

checkBrackets :: String -> Int -> Int
checkBrackets [] n = n
checkBrackets (x:xs) n
  | n < 0 = -1
  | x == '<' = checkBrackets xs (n + 1)
  | x == '>' = checkBrackets xs (n - 1)
  | otherwise = checkBrackets xs n","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""<>"" == True then pure () else error ""assertion failed""
  if candidate ""<<><>>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<<><><>><>><<><><<>>>"" == True then pure () else error ""assertion failed""
  if candidate ""<<<><>>>>"" == False then pure () else error ""assertion failed""
  if candidate ""><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<"" == False then pure () else error ""assertion failed""
  if candidate ""<<<<"" == False then pure () else error ""assertion failed""
  if candidate "">"" == False then pure () else error ""assertion failed""
  if candidate ""<<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>>><>"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_57,fon_Latn,hs,"--│Nɔ ɔ ɔ ɔ, nǔ lɛ nɔ jɛji ɖò jijɛji wɛ alǒ ɖò dín wɛ.--  >>> monotonic [1,2,4,20]
--  True
--  >>> monotonic [1,20,4,10]
--  False
--  >>> monotonic [4,1,0,(-10)]
--  True
monotonic :: [Int] -> Bool
monotonic l =","monotonic :: [Int] -> Bool
monotonic l = increasing l || decreasing l
  where
    increasing xs = all (uncurry (<=)) (zip xs (tail xs))
    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","
main :: IO ()
main = do
  let candidate = monotonic
  if candidate [1,2,4,10] == True then pure () else error ""assertion failed""
  if candidate [1,2,4,20] == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] == False then pure () else error ""assertion failed""
  if candidate [4,1,0,(-10)] == True then pure () else error ""assertion failed""
  if candidate [4,1,1,0] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,2,5,60] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,60] == True then pure () else error ""assertion failed""
  if candidate [9,9,9,9] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_58,fon_Latn,hs,"--│Nɔ ɔ na lɛ́ lɛ́ ɖó nǔ e ɖò mɛ wè lɛ́ɛ mɛ é ɖokpo ɔ.--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]
--  [1,5,653]
--  >>> common [5,3,2,8] [3,2]
--  [2,3]
common :: [Int] -> [Int] -> [Int]
common l1 l2 =","common :: [Int] -> [Int] -> [Int]
common l1 l2 = uniqueSortedCommon
  where
    commonElements = filter (`elem` l2) l1
    uniqueCommon = removeDuplicates commonElements
    uniqueSortedCommon = sort uniqueCommon

    removeDuplicates :: [Int] -> [Int]
    removeDuplicates = foldr (\x seen -> if x `elem` seen then seen else x : seen) []

    sort :: [Int] -> [Int]
    sort [] = []
    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)
      where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs","
main :: IO ()
main = do
  let candidate = common
  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error ""assertion failed""
  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_59,fon_Latn,hs,"--返回n>1的最大素因数.--  >>> largestPrimeFactor 13195
--  29
--  >>> largestPrimeFactor 2048
--  2
largestPrimeFactor :: Int -> Int
largestPrimeFactor n =","largestPrimeFactor :: Int -> Int
largestPrimeFactor n = helper n 2
  where
    helper n factor
      | factor * factor > n = n
      | n `mod` factor == 0 = helper (n `div` factor) factor
      | otherwise = helper n (factor + 1)","
main :: IO ()
main = do
  let candidate = largestPrimeFactor
  if candidate 15 == 5 then pure () else error ""assertion failed""
  if candidate 27 == 3 then pure () else error ""assertion failed""
  if candidate 63 == 7 then pure () else error ""assertion failed""
  if candidate 330 == 11 then pure () else error ""assertion failed""
  if candidate 13195 == 29 then pure () else error ""assertion failed""
  pure ()"
HumanEval_60,fon_Latn,hs,"--¢óõí sum_to_n åéíáé ìéá åðéëïãç ðïõ ðñïóöåñåé áñéèìïõò áðï 1 ìÝ÷ñé n. --  >>> sumToN 30
--  465
--  >>> sumToN 100
--  5050
--  >>> sumToN 5
--  15
--  >>> sumToN 10
--  55
--  >>> sumToN 1
--  1
sumToN :: Int -> Int
sumToN n =","sumToN :: Int -> Int
sumToN n = sum [1..n]","
main :: IO ()
main = do
  let candidate = sumToN
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 66 then pure () else error ""assertion failed""
  if candidate 30 == 465 then pure () else error ""assertion failed""
  if candidate 100 == 5050 then pure () else error ""assertion failed""
  pure ()"
HumanEval_61,fon_Latn,hs,"--lɛ́ kɔ́n nǔ e nyí nugbǒ é nú wuntun e nɔ hun lɛ é bǐ ɖó wuntun e nɔ sú lɛ é ɖokpo. --│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> correctBracketing ""(""
--  False
--  >>> correctBracketing ""()""
--  True
--  >>> correctBracketing ""(()())""
--  True
--  >>> correctBracketing "")(()""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBalance brackets 0
  where
    checkBalance [] 0 = True
    checkBalance [] _ = False
    checkBalance (x:xs) n
      | x == '('  = checkBalance xs (n + 1)
      | x == ')' && n > 0 = checkBalance xs (n - 1)
      | otherwise = False","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""()"" == True then pure () else error ""assertion failed""
  if candidate ""(()())"" == True then pure () else error ""assertion failed""
  if candidate ""()()(()())()"" == True then pure () else error ""assertion failed""
  if candidate ""()()((()()())())(()()(()))"" == True then pure () else error ""assertion failed""
  if candidate ""((()())))"" == False then pure () else error ""assertion failed""
  if candidate "")(()"" == False then pure () else error ""assertion failed""
  if candidate ""("" == False then pure () else error ""assertion failed""
  if candidate ""(((("" == False then pure () else error ""assertion failed""
  if candidate "")"" == False then pure () else error ""assertion failed""
  if candidate ""(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())())(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())()))()"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_62,fon_Latn,hs,"--Zɔ́n nùjlɛ́nkpó sín nǔ e nyí nùjlɛ́nkpó enɛ tɔn é dó nùjlɛ́nkpó ɖokpo ɔ mɛ.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --¢ñá xs áðïôåëïýí ôá óõíäÝóìáôá ôçò ðïëéôéêÞò.--  >>> derivative [3,1,2,4,5]
--  [1,4,12,20]
--  >>> derivative [1,2,3]
--  [2,6]
derivative :: [Int] -> [Int]
derivative xs =","derivative :: [Int] -> [Int]
derivative xs = zipWith (*) (tail xs) [1..]","
main :: IO ()
main = do
  let candidate = derivative
  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,6] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [2,2] then pure () else error ""assertion failed""
  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error ""assertion failed""
  if candidate [1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_63,fon_Latn,hs,"--Mi wlan azɔ̀ ɖé bo na dó mɔ nùɖé lɛ́ɛ ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ ɔ́ mɛ.--fεfεfεn (n) == fεfεfεn (n-1) + fεfεfεn (n-2) + fεfεfεn (n-3).--fib fib ((2) == 1 --fεfεfε)--fibfib(0) == 0 --¢ñá ôï FibFib åßíáé Ýíá ðëáßóéï ðïõ åßíáé óáí ôï Fibbonacci ðïõ ëÝãåôáé åðßóçò: --  >>> fibfib 1
--  0
--  >>> fibfib 5
--  4
--  >>> fibfib 8
--  24
fibfib :: Int -> Int
fibfib n =","fibfib :: Int -> Int
fibfib n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 1
  | otherwise = fibs !! n
  where
    fibs = 0 : 0 : 1 : zipWith3 (\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","
main :: IO ()
main = do
  let candidate = fibfib
  if candidate 2 == 1 then pure () else error ""assertion failed""
  if candidate 1 == 0 then pure () else error ""assertion failed""
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 24 then pure () else error ""assertion failed""
  if candidate 10 == 81 then pure () else error ""assertion failed""
  if candidate 12 == 274 then pure () else error ""assertion failed""
  if candidate 14 == 927 then pure () else error ""assertion failed""
  pure ()"
HumanEval_64,fon_Latn,hs,"--Kpɔ́n: --xo ɔ, amɔ̌ enyi é ɖò xógbe e è na é sín vivɔnu ɔ jɛn wɛ ɔ.--Hweɖegbe tɔn ɖo fí ɔ ye nyí 'a', 'e', 'i', 'o', 'u'. fí ɔ, 'y' ɔ lɔ nyí a --e nɔ sɔ́ xókwin ɖé dó mɔ nǔ è nɔ dó é, bo nɔ lɛ́ lɛ́ ɖó vowel lɛ́ɛ ɖò wuntun ɔ mɛ.--◯ Wlan azɔ̀ e nɔ ylɔ́ ɖɔ vowels_count é e nɔ yí xwɛ e nɔ ɖɔ --  >>> vowelsCount ""abcde""
--  2
--  >>> vowelsCount ""ACEDY""
--  3
vowelsCount :: String -> Int
vowelsCount s =","vowelsCount :: String -> Int
vowelsCount s = length $ filter isVowel $ zip s [1..]
  where
    isVowel (c, pos) =
      let lowercaseC = toLower c
          isRegularVowel = lowercaseC `elem` ""aeiou""
          isLastCharY = lowercaseC == 'y' && pos == length s
      in isRegularVowel || isLastCharY","
main :: IO ()
main = do
  let candidate = vowelsCount
  if candidate ""abcde"" == 2 then pure () else error ""assertion failed""
  if candidate ""Alone"" == 3 then pure () else error ""assertion failed""
  if candidate ""key"" == 2 then pure () else error ""assertion failed""
  if candidate ""bye"" == 1 then pure () else error ""assertion failed""
  if candidate ""keY"" == 2 then pure () else error ""assertion failed""
  if candidate ""bYe"" == 1 then pure () else error ""assertion failed""
  if candidate ""ACEDY"" == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_65,fon_Latn,hs,"--Nú shift > nùxwásá nú wèmá lɛ́ɛ ɔ́, wèmá lɛ́ɛ ná lɛ́ kɔ́n.--bo na lɛ́ lɛ́ wá mɔ nǔ e è mɔ é dó wuntun ɖé mɛ.--¢ñá ðåñéóóüôåñï ôá óçìåßá ôïõ óçìåßïõ ×, ðåñéóóüôåñï ôá óçìåßá ðñïò ôá ðÜíù.--  >>> circularShift 12 1
--  ""21""
--  >>> circularShift 12 2
--  ""12""
circularShift :: Int -> Int -> String
circularShift x shift =","circularShift :: Int -> Int -> String
circularShift x shift =
  let digits = show x
      len = length digits
      effectiveShift = shift `mod` len
  in if shift > len
     then reverse digits
     else let (begin, end) = splitAt (len - effectiveShift) digits
          in end ++ begin","
main :: IO ()
main = do
  let candidate = circularShift
  if candidate 100 2 == ""001"" then pure () else error ""assertion failed""
  if candidate 12 2 == ""12"" then pure () else error ""assertion failed""
  if candidate 97 8 == ""79"" then pure () else error ""assertion failed""
  if candidate 12 1 == ""21"" then pure () else error ""assertion failed""
  if candidate 11 101 == ""11"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_66,fon_Latn,hs,"--Kpɔ́ndéwú: --ASCII wèmá lɛ́ɛ.--Wlǎn azɔ̀ e nɔ yí wèmá wèmá ɖé dó mɛ bo nɔ lɛ́ lɛ́ yí wèmá wèmá ɖaxó lɛ́ɛ sín nùɖé lɛ́ɛ dó mɛ é' --azɔ̌ e è ɖó ná wa é--  >>> digitsum """"
--  0
--  >>> digitsum ""abAB""
--  131
--  >>> digitsum ""abcCd""
--  67
--  >>> digitsum ""helloE""
--  69
--  >>> digitsum ""woArBld""
--  131
--  >>> digitsum ""aAaaaXa""
--  153
digitsum :: String -> Int
digitsum s =","digitsum :: String -> Int
digitsum s = sum $ map fromEnum $ filter isUpper s","
main :: IO ()
main = do
  let candidate = digitsum
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abAB"" == 131 then pure () else error ""assertion failed""
  if candidate ""abcCd"" == 67 then pure () else error ""assertion failed""
  if candidate ""helloE"" == 69 then pure () else error ""assertion failed""
  if candidate ""woArBld"" == 131 then pure () else error ""assertion failed""
  if candidate ""aAaaaXa"" == 153 then pure () else error ""assertion failed""
  if candidate "" How are yOu?"" == 151 then pure () else error ""assertion failed""
  if candidate ""You arE Very Smart"" == 327 then pure () else error ""assertion failed""
  pure ()"
HumanEval_67,fon_Latn,hs,"--nú è ɖò xó ɖɔ wɛ ɔ: --ɖo xasun ɔ mɛ ɔ mi na ɖɔ kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n.--atinsinsɛn kpo atinsɛn kpo kpo kpodo xwiɖe e nɔte nú atinsɛn lɛ bǐ é kpo --e nɔ ɖe nùjlɛdonǔwu e nɔ xlɛ́ ɖɔ nǔ lɛ́ɛ bǐ ɖò kpɔ́ é--e è nɔ má dó atínkwɛ́ ɖé mɛ é ɔ́, atínkwɛ́ énɛ́ ɔ́ mɛ wɛ è nɔ mɔ atín tɔn lɛ́ɛ ɖè.--◯ Ðò azɔ̌ elɔ mɛ ɔ, è na na we xójlawema e nɔte nú atinsinsinsɛn kpo atínlaví kpo é ɖé.--  >>> fruitDistribution ""5 apples and 6 oranges"" 19
--  8
--  >>> fruitDistribution ""0 apples and 1 oranges"" 3
--  2
--  >>> fruitDistribution ""2 apples and 3 oranges"" 100
--  95
--  >>> fruitDistribution ""100 apples and 1 oranges"" 120
--  19
fruitDistribution :: String -> Int -> Int
fruitDistribution s n =","import Text.Read (readMaybe)

fruitDistribution :: String -> Int -> Int
fruitDistribution s n = n - totalApplesOranges
  where
    totalApplesOranges = sum $ map (readNumber . words) [""apples"", ""oranges""]
    readNumber keyword = case dropWhile (not . (=="" "") . dropWhile (/=' ')) $ words s of
      [] -> 0
      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","
main :: IO ()
main = do
  let candidate = fruitDistribution
  if candidate ""5 apples and 6 oranges"" 19 == 8 then pure () else error ""assertion failed""
  if candidate ""5 apples and 6 oranges"" 21 == 10 then pure () else error ""assertion failed""
  if candidate ""0 apples and 1 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""1 apples and 0 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 100 == 95 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 5 == 0 then pure () else error ""assertion failed""
  if candidate ""1 apples and 100 oranges"" 120 == 19 then pure () else error ""assertion failed""
  pure ()"
HumanEval_68,fon_Latn,hs,"--Kpɔ́ndo 1: --Nú nùɖé ma ɖò nùɖé jí ǎ alǒ nùɖé ma ɖò nùɖé jí ǎ ɔ, lɛ́ kɔ [].--e na lɛ́ vɔ́ nùxwlé e è sɔ́ ɖó vo ɔ́ dó wuntun ɖé mɛ, [smallest_value, its index], --Nú è mɔ nɔ̀n gègě bo ɖó nùxíɖíɖó e nyí ganxixo kpɛví bǐ é ɖokpó ɔ ɔ, lɛ́ kɔ nú nɔ̀n e ɖó nùxíɖíɖó e nyí ganxixo kpɛví bǐ é. --E nɔ nyí nuvo e è nɔ sɔ́ ɖó vo é wɛ nyí nuvo e nɔ ɖó akwɛ́ e nyí ganxixo é.--azɔ towe wɛ nyí ɖɔ a na ɖè nukɔ́n ɖokpo bo na lɛ́ sɔ́ ɛ.--""E na bo na w'azɔ̌ e nɔ xlɛ́ alɔkwín atín ɖé tɔn e ɖó nùjlɛ́kpikpa e nyí nùjlɛ́kpikpa ǎ lɛ é é ɔ --  >>> pluck [4,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 2:
--  >>> pluck [1,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 3:
--  >>> pluck []
--  []
--  Example 4:
--  >>> pluck [5,0,3,0,4,2]
--  [0,1]
--  Explanation: 0 is the smallest value, but  there are two zeros,
--  so we will choose the first zero, which has the smallest index.
--  Constraints:
--  * 1 <= nodes.length <= 10000
--  * 0 <= node.value
pluck :: [Int] -> [Int]
pluck arr =","pluck :: [Int] -> [Int]
pluck arr = case filter (\(x, _) -> even x) (zip arr [0..]) of
    [] -> []
    evens -> let (value, index) = minimum evens in [value, index]","
main :: IO ()
main = do
  let candidate = pluck
  if candidate [4,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error ""assertion failed""
  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error ""assertion failed""
  if candidate [5,4,8,4,8] == [4,1] then pure () else error ""assertion failed""
  if candidate [7,6,7,1] == [6,1] then pure () else error ""assertion failed""
  if candidate [7,9,7,1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_69,fon_Latn,hs,"--Kpɔ́ndéwú: --Enyi nùɖé ma ɖò finɛ ǎ ɔ, lɛ́ kɔ́n -1.--nùxwásá nú nùjlɛ́kpá ɖé ɔ́ wɛ nyí azɔn nabí e é nɔ tɔ́n ɖò nùjlɛ́kpá ɔ́ mɛ é.--azɔn, bo ɖó hwɛhwɛ e hú alǒ e cí nùxwlémɛ ɔ ɖesu tɔn é.--̆ E na lɛ́ ná nùxwɛ́ e nyí nùxwɛ́ ɖagbe lɛ́ɛ sín nùɖé lɛ́ɛ nú mi bɔ é na nyí nùxwɛ́ e nyí nùxwɛ́ ɖagbe lɛ́ɛ bǐ ɔ́ tɔn.--  >>> search [4,1,2,2,3,1]
--  2
--  >>> search [1,2,2,3,3,3,4,4,4]
--  3
--  >>> search [5,5,4,4,4]
--  (-1)
search :: [Int] -> Int
search lst =","import Data.List (group, sort)
import Data.Ord (comparing)

search :: [Int] -> Int
search lst = 
    let frequencies = map (\g -> (head g, length g)) . group . sort $ lst
        candidates = filter (\(val, freq) -> freq >= val) frequencies
    in case candidates of
         [] -> -1
         _  -> fst . maximum $ candidates","
main :: IO ()
main = do
  let candidate = search
  if candidate [5,5,5,5,1] == 1 then pure () else error ""assertion failed""
  if candidate [4,1,4,1,4,4] == 4 then pure () else error ""assertion failed""
  if candidate [3,3] == (-1) then pure () else error ""assertion failed""
  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error ""assertion failed""
  if candidate [2,3,3,2,2] == 2 then pure () else error ""assertion failed""
  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error ""assertion failed""
  if candidate [3,2,8,2] == 2 then pure () else error ""assertion failed""
  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error ""assertion failed""
  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error ""assertion failed""
  if candidate [1,9,10,1,3] == 1 then pure () else error ""assertion failed""
  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error ""assertion failed""
  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error ""assertion failed""
  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error ""assertion failed""
  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error ""assertion failed""
  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error ""assertion failed""
  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error ""assertion failed""
  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error ""assertion failed""
  if candidate [10] == (-1) then pure () else error ""assertion failed""
  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error ""assertion failed""
  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error ""assertion failed""
  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error ""assertion failed""
  if candidate [3,10,10,9,2] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_70,fon_Latn,hs,"--Kpɔ́ndéwú: --enɛ ɔ gudo ɔ è na lɛ́ sɔ́ nùjlɛ́kpá e kpo lɛ́ɛ bǐ dó mɔ nùjlɛ́kpá ɖaxó ɔ, bɔ è na lɛ́ sɔ́ nùjlɛ́kpá kpɛví ɔ.--E nɔ jɛ̀ nùɖé lɛ jí ɖò nùɖé lɛ jí ǎ, é nɔ nyí ɖɔ è nɔ bɛ́ nùɖé lɛ sín akwɛ́ jí,--◯ Nú è na wlan nùxwlémɛ e ɖò nùɖé lɛ mɛ lɛ é ɔ, è na lɛ́ wlan nùxwlémɛ e ɖò tito e è ma ɖó ǎ é mɛ é.--  >>> strangeSortList [1,2,3,4]
--  [1,4,2,3]
--  >>> strangeSortList [5,5,5,5]
--  [5,5,5,5]
--  >>> strangeSortList []
--  []
strangeSortList :: [Int] -> [Int]
strangeSortList lst =","strangeSortList :: [Int] -> [Int]
strangeSortList [] = []
strangeSortList lst = go (sort lst) True
  where
    go [] _ = []
    go xs toggle
      | toggle    = head xs : go (tail xs) False
      | otherwise = last xs : go (init xs) True","
main :: IO ()
main = do
  let candidate = strangeSortList
  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error ""assertion failed""
  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error ""assertion failed""
  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error ""assertion failed""
  if candidate [111111] == [111111] then pure () else error ""assertion failed""
  pure ()"
HumanEval_71,fon_Latn,hs,"--Kpɔ́n: --e ɖo akpá atɔngɔ ɔ.--Xò atɔn lɛ́ɛ nɔ́ bló ɖɔ̀ atɔnví ɔ́ nyí nùɖé, nú è na mɔ ɖɔ̀ wè lɛ́ɛ bǐ sín nǔ e è kplé ɔ́ hú gǎn we ɔ́.--E ma nyí mɔ̌ ǎ ɔ́, é ná lɛ́ kɔ́n -1 .--azɔmε atɔnvɔn ɔ e wεn ɔ e na wεn ɔ e na wεn ɔ e na wεn ɔ ɔ e na wεn ɔ e na wεn ɔ e na wεn ɔ--¢óå ðïõ åßíáé ôá ðåñéóóüôåñá ôùí 3 ðßóù ìÝôñùí ôçò ðåñéï÷Þò.--  >>> triangleArea 3 4 5
--  6.0
--  >>> triangleArea 1 2 10
--  (-1).0
triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c =","import Text.Printf (printf)

triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c
    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))
    | otherwise = -1
  where
    s = (fromIntegral (a + b + c)) / 2
    isValidTriangle x y z = x + y > z && x + z > y && y + z > x
    roundToTwoDecimals x = read (printf ""%.2f"" x) :: Float","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 3 4 5 == 6.0 then pure () else error ""assertion failed""
  if candidate 1 2 10 == (-1).0 then pure () else error ""assertion failed""
  if candidate 4 8 5 == 8.18 then pure () else error ""assertion failed""
  if candidate 2 2 2 == 1.73 then pure () else error ""assertion failed""
  if candidate 1 2 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 10 5 7 == 16.25 then pure () else error ""assertion failed""
  if candidate 2 6 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 1 1 1 == 0.43 then pure () else error ""assertion failed""
  if candidate 2 2 10 == (-1).0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_72,fon_Latn,hs,"--Kpɔ́n: --Nǔ e nɔ nyí q ɔ na zɔn, enyi é ɖò jlɛjɛnǔmɛ (e nyí nùjlɛ́n e nɔ nyí palindrome é) bo nùɖíɖó tɔn lɛ sín nùxwlémɛ nɔ hwe hú alǒ nɔ cí wuvi e è sixu ɖó é w.--拼出一个函数,如果对象q会飞,则返回True,否则返回False.--  >>> willItFly [1,2] 5
--  False
--  # 1+2 is less than the maximum possible weight, but it's unbalanced.
--  >>> willItFly [3,2,3] 1
--  False
--  # it's balanced, but 3+2+3 is more than the maximum possible weight.
--  >>> willItFly [3,2,3] 9
--  True
--  # 3+2+3 is less than the maximum possible weight, and it's balanced.
--  >>> willItFly [3] 5
--  True
--  # 3 is less than the maximum possible weight, and it's balanced.
willItFly :: [Int] -> Int -> Bool
willItFly q w =","willItFly :: [Int] -> Int -> Bool
willItFly q w = isPalindrome q && sum q <= w

isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs","
main :: IO ()
main = do
  let candidate = willItFly
  if candidate [3,2,3] 9 == True then pure () else error ""assertion failed""
  if candidate [1,2] 5 == False then pure () else error ""assertion failed""
  if candidate [3] 5 == True then pure () else error ""assertion failed""
  if candidate [3,2,3] 1 == False then pure () else error ""assertion failed""
  if candidate [1,2,3] 6 == False then pure () else error ""assertion failed""
  if candidate [5] 5 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_73,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --e nɔ xa ɖokpo ɔ ɖo gudo kpo nukɔn kpo. Ðò ye na lɛ ɔ, a sixu ɖyɔ nǔɖogbɛ ɖokpo bo na lɛ́ huzu nǔɖogbɛ ɖevo.--e ɖo na ɖyɔ wɛ bo na bló bɔ nùwlanwlan ɔ na nyí palindromic.--◯ Xà nùxwlé lɛ́ɛ tɔn ɖò nùxwlé ɔ mɛ, mɔ nùxwlé lɛ́ɛ tɔn e ɖò nùxwlé ɔ mɛ é bǐ--  >>> smallestChange [1,2,3,5,4,7,9,6]
--  4
--  >>> smallestChange [1,2,3,4,3,2,2]
--  1
--  >>> smallestChange [1,2,3,2,1]
--  0
smallestChange :: [Int] -> Int
smallestChange arr =","smallestChange :: [Int] -> Int
smallestChange arr = sum $ zipWith (\x y -> if x /= y then 1 else 0) arr (reverse arr)","
main :: IO ()
main = do
  let candidate = smallestChange
  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error ""assertion failed""
  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,2,3,2,1] == 0 then pure () else error ""assertion failed""
  if candidate [3,1,1,3] == 0 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_74,fon_Latn,hs,"--Kpɔ́ndéwú --enyi wèmá lɛ́ɛ ɖò nǔ e è wlan lɛ́ɛ mɛ ɖokpó ɔ́, wèmá nukɔntɔn ɔ́ wɛ è na lɛ́ wlan.--nùxwásá nùxwásá tɔn ɖò nùjlɛ́n lɛ́ɛ bǐ mɛ é dín hú nùxwásá ɖě ɔ́.--│ Wlan azɔ̀ e nɔ yí gbè nú xójlawema wè bo nɔ lɛ́ lɛ́ wá xójlawema e ɖó │--  >>> totalMatch [] []
--  []
--  >>> totalMatch [""hi"",""admin""] [""hI"",""Hi""]
--  [""hI"",""Hi""]
--  >>> totalMatch [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""]
--  [""hi"",""admin""]
--  >>> totalMatch [""hi"",""admin""] [""hI"",""hi"",""hi""]
--  [""hI"",""hi"",""hi""]
--  >>> totalMatch [""4""] [""1"",""2"",""3"",""4"",""5""]
--  [""4""]
totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2 =","totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2
  | totalChars lst1 < totalChars lst2 = lst1
  | totalChars lst1 > totalChars lst2 = lst2
  | otherwise = lst1
  where
    totalChars = sum . map length","
main :: IO ()
main = do
  let candidate = totalMatch
  if candidate [] [] == [] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi""] == [""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [""4""] [""1"",""2"",""3"",""4"",""5""] == [""4""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""Hi""] == [""hI"",""Hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hi""] == [""hI"",""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hii""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [] [""this""] == [] then pure () else error ""assertion failed""
  if candidate [""this""] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_75,fon_Latn,hs,"--Kpɔ́n: --Nukúnmɛ ɖɔ (a) ɖò kpɛví hú 100.--bo lɛ́ nyí nǔvú.--Ÿ na wlan azɔ̀ e na lɛ́ yí gbè nú nùjlɛ́kpo e è na lɛ́ ná é ɔ́' è na lɛ́ sɔ́ nùjlɛ́kpo nukɔntɔn 3 lɛ́ɛ dó azɔn ɖokpó jí é.--  >>> isMultiplyPrime 30
--  True
--  30 = 2 * 3 * 5
isMultiplyPrime :: Int -> Bool
isMultiplyPrime a =","isMultiplyPrime :: Int -> Bool
isMultiplyPrime a = any isTriplePrimeProduct primeTriples
  where
    primes = filter isPrime [2..99]
    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]
    isTriplePrimeProduct (x, y, z) = x * y * z == a

isPrime :: Int -> Bool
isPrime n 
  | n < 2     = False
  | otherwise = not (any (\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","
main :: IO ()
main = do
  let candidate = isMultiplyPrime
  if candidate 5 == False then pure () else error ""assertion failed""
  if candidate 30 == True then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == False then pure () else error ""assertion failed""
  if candidate 125 == True then pure () else error ""assertion failed""
  if candidate 105 == True then pure () else error ""assertion failed""
  if candidate 126 == False then pure () else error ""assertion failed""
  if candidate 729 == False then pure () else error ""assertion failed""
  if candidate 891 == False then pure () else error ""assertion failed""
  if candidate 1001 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_76,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --x nyí nùɖé bɔ è nɔ sɔ́ dó kpá nú n enyi n**int=x --nǔ e nyí nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ ɔ ǎ é.--azɔ towe wɛ nyí ɖɔ a na wlan azɔ̀ e na lɛ́ yí gbè nú nùɖé ɔ́ ɖɔ é nyí nùɖé bɔ è nɔ ylɔ ɖɔ x ɔ́ ɖɔ nǔɖé bɔ è nɔ ylɔ ɖɔ x ɔ́ ɖɔ nǔɖé bɔ è nɔ ylɔ ɖɔ x ɔ́.--  >>> isSimplePower 1 4
--  True
--  >>> isSimplePower 2 2
--  True
--  >>> isSimplePower 8 2
--  True
--  >>> isSimplePower 3 2
--  False
--  >>> isSimplePower 3 1
--  False
--  >>> isSimplePower 5 3
--  False
isSimplePower :: Int -> Int -> Bool
isSimplePower x n =","isSimplePower :: Int -> Int -> Bool
isSimplePower x n
  | x < 1 || n < 1 = False
  | n == 1 = x == 1
  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","
main :: IO ()
main = do
  let candidate = isSimplePower
  if candidate 16 2 == True then pure () else error ""assertion failed""
  if candidate 143214 16 == False then pure () else error ""assertion failed""
  if candidate 4 2 == True then pure () else error ""assertion failed""
  if candidate 9 3 == True then pure () else error ""assertion failed""
  if candidate 16 4 == True then pure () else error ""assertion failed""
  if candidate 24 2 == False then pure () else error ""assertion failed""
  if candidate 128 4 == False then pure () else error ""assertion failed""
  if candidate 12 6 == False then pure () else error ""assertion failed""
  if candidate 1 1 == True then pure () else error ""assertion failed""
  if candidate 1 12 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_77,fon_Latn,hs,"--Kpɔ́ndéwú: --Akpàkpà: a sixu ɖɔ ɖɔ nǔ e è wlan ɔ na nɔ wà hwebǐnu.--enyi mɛ e ɖò xixo ɔ nyí xixo nùjlɛ́kpá ɖé tɔn ɔ.--Ÿ na wlan azɔ̀ e nɔ yí nùxwɛ́ e nyí nùxwɛ́ ɔ́ ɖokpó bó nɔ yí gbè nú True é.--  >>> iscube 1
--  True
--  >>> iscube 2
--  False
--  >>> iscube (-1)
--  True
--  >>> iscube 64
--  True
--  >>> iscube 0
--  True
--  >>> iscube 180
--  False
iscube :: Int -> Bool
iscube a =","iscube :: Int -> Bool
iscube a = let n = round (fromIntegral a ** (1/3)) in n^3 == a","
main :: IO ()
main = do
  let candidate = iscube
  if candidate 1 == True then pure () else error ""assertion failed""
  if candidate 2 == False then pure () else error ""assertion failed""
  if candidate (-1) == True then pure () else error ""assertion failed""
  if candidate 64 == True then pure () else error ""assertion failed""
  if candidate 180 == False then pure () else error ""assertion failed""
  if candidate 1000 == True then pure () else error ""assertion failed""
  if candidate 0 == True then pure () else error ""assertion failed""
  if candidate 1729 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_78,fon_Latn,hs,"--Kpɔ́ndéwú: --akpàkpà lɛ A,B,C,D,E,F ɔ́' è nɔ sɔ́ wèmá ɖaxó dó wèmá lɛ́ɛ.--Akpàkpà: mi sixu ɖɔ ɖɔ nǔ e è wlan ɔ sɔgbe hwebǐnu alǒ é nyí xɛ́n ɖé ǎ,--B (=mɛ̀gbò 11), D (=mɛ̀gbò 13). --N'ò ɔ, a ɖó na kpɔ́n nùjlɛ́kpo e ɖò wuntun elɔ lɛ mɛ lɛ é: 2, 3, 5, 7, --Nùxwlémɛ nukɔntɔn lɛ wɛ nyí 2, 3, 5, 7, 11, 13, 17,...--Wěma afɔtɔn-nukún-ɖokpo lɛ wɛ nyí 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. --e hú 1 bo ma nyí nùjlɛ́kpo nùjlɛ́kpo wè e ɖò kpò é tɔn ǎ é).--nùxwásá nùɖé lɛ́ɛ wɛ nyí nùjlɛ́kpá (númɛ́ e nyí nùjlɛ́kpá é ɖé wɛ nyí nùjlɛ́kpá nùjlɛ́kpá ɖé --nùxwásùn wǒ-wě-wě tɔn ɖé wɛ nyí xɛ́n ɖé bɔ é nɔ́ xa nùxwásùn wǒ-wě tɔn lɛ́ɛ --È byɔ mi ɖɔ mi ni wlan azɔ̀ e nɔ yí nǔ lɛ é ɖokpo--  >>> hexKey ""AB""
--  1
--  >>> hexKey ""1077E""
--  2
--  >>> hexKey ""ABED1A33""
--  4
--  >>> hexKey ""123456789ABCDEF0""
--  6
--  >>> hexKey ""2020""
--  2
hexKey :: String -> Int
hexKey num =","hexKey :: String -> Int
hexKey num = length . filter (`elem` primeHexDigits) $ num
  where
    primeHexDigits = ""2357BD""","
main :: IO ()
main = do
  let candidate = hexKey
  if candidate ""AB"" == 1 then pure () else error ""assertion failed""
  if candidate ""1077E"" == 2 then pure () else error ""assertion failed""
  if candidate ""ABED1A33"" == 4 then pure () else error ""assertion failed""
  if candidate ""2020"" == 2 then pure () else error ""assertion failed""
  if candidate ""123456789ABCDEF0"" == 6 then pure () else error ""assertion failed""
  if candidate ""112233445566778899AABBCCDDEEFF00"" == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_79,fon_Latn,hs,"--Kpɔ́ndéwú: --Akpáxwé e è sɔ́ dó lɛ́ɛ ɖò finɛ bo na d'alɔ ɖò nùwlanwlan ɔ mɛ.--E na sɔ́ wèmá 'db' wè dó nukɔn ɖò wèmá ɔ́ sín bǐbɛ́mɛ, bo lɛ́ sɔ́ wèmá 'db' we dó wèmá ɔ́ sín bǐbɛ́mɛ.--Akɔdo ɖokpo ɖokpo ɖo xɛ ɔ mɛ ɔ e na nyi '0' alo '1'.--binary format. azɔ na lɛ na w'azɔ ɔ, bo na lɛ na w'azɔ ɔ ɖokpo ɖokpo ɔ na nɔte nú binary --◯ È na na mi nùxwásá ɖé ɖò wuntun wǒzángbè mɛ bɔ azɔ̌ mitɔn wɛ nyí ɖɔ mi na yí é dó ◯ jí--  >>> decimalToBinary 15
--  ""db1111db""
--  >>> decimalToBinary 32
--  ""db100000db""
decimalToBinary :: Int -> String
decimalToBinary decimal =","decimalToBinary :: Int -> String
decimalToBinary decimal = ""db"" ++ toBinary decimal ++ ""db""
  where
    toBinary 0 = ""0""
    toBinary n = reverse (binaryHelper n)

    binaryHelper 0 = """"
    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","
main :: IO ()
main = do
  let candidate = decimalToBinary
  if candidate 0 == ""db0db"" then pure () else error ""assertion failed""
  if candidate 32 == ""db100000db"" then pure () else error ""assertion failed""
  if candidate 103 == ""db1100111db"" then pure () else error ""assertion failed""
  if candidate 15 == ""db1111db"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_80,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --Hwe ɖokpo ɔ ɔ wɛ nyí haphs enyi gǒ tɔn ma hú 3 ǎ bɔ wuntun atɔn e ɖò kpò lɛ é bǐ nɔ nyí nǔ ɖokpo ɔ --azɔ towe wɛ nyí ɖɔ a na kpɔ́n ɖɔ xwɛ ɔ nyí haphs à alǒ ǎ.--È na wèmá nú we.--  >>> isHappy ""a""
--  False
--  >>> isHappy ""aa""
--  False
--  >>> isHappy ""abcd""
--  True
--  >>> isHappy ""aabb""
--  False
--  >>> isHappy ""adb""
--  True
--  >>> isHappy ""xyy""
--  False
isHappy :: String -> Bool
isHappy s =","isHappy :: String -> Bool
isHappy s
  | length s < 3 = False
  | otherwise = all distinctTriples (windows 3 s)
  where
    distinctTriples [x, y, z] = x /= y && y /= z && x /= z
    distinctTriples _ = False
    windows n xs
      | length xs < n = []
      | otherwise = take n xs : windows n (tail xs)","
main :: IO ()
main = do
  let candidate = isHappy
  if candidate ""a"" == False then pure () else error ""assertion failed""
  if candidate ""aa"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""adb"" == True then pure () else error ""assertion failed""
  if candidate ""xyy"" == False then pure () else error ""assertion failed""
  if candidate ""iopaxpoi"" == True then pure () else error ""assertion failed""
  if candidate ""iopaxioi"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_81,fon_Latn,hs,"--Kpɔ́n: --0.0 E --> 0.0 D- --> 0.7 D -->1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 B+ --> 3.3 A- --> 3.7 A --4.0 A+ --xwi xwi xwi xwi xwi xwi--azɔ̀ e nɔ́ hɛn ɔ́, è na zán távo elɔ bo na ɖè wèmá lɛ sín nùjlɛ́jlɛ́ ɖé xlɛ́: --É ná nǔ e mɛví lɛ́ɛ ɖé lɛ́ɛ ɖó é we bɔ a ɖó na wlan .--Kpo ɖokpo ɔ wɛ nyí ɖɔ, é bú wuntun e é nɔ zán dó ɖè nǔ lɛ é.--azɔmɛvi ɔ ɖo jijɛ wɛ bo na sɔ́ azɔmɛvi lɛ́ɛ ɖó vo.--◯ Azǎn e gbè gbè è nɔ kplɔ́n nǔ mɛ é wɛ nyí ɖɔ mɛ̌si ɔ ɖó na ɖɔ nǔ e è kplɔ́n mɛ é nú mɛ.--  >>> gradeEquation [4.0,3,1.7,2,3.5]
--  [""A+"",""B"",""C-"",""C"",""A-""]
numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades =","numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades = map gpaToLetterGrade grades
  where
    gpaToLetterGrade gpa
      | gpa == 4.0 = ""A+""
      | gpa > 3.7  = ""A""
      | gpa > 3.3  = ""A-""
      | gpa > 3.0  = ""B+""
      | gpa > 2.7  = ""B""
      | gpa > 2.3  = ""B-""
      | gpa > 2.0  = ""C+""
      | gpa > 1.7  = ""C""
      | gpa > 1.3  = ""C-""
      | gpa > 1.0  = ""D+""
      | gpa > 0.7  = ""D""
      | gpa > 0.0  = ""D-""
      | otherwise  = ""E""","
main :: IO ()
main = do
  let candidate = numericalLetterGrade
  if candidate [4.0,3,1.7,2,3.5] == [""A+"",""B"",""C-"",""C"",""A-""] then pure () else error ""assertion failed""
  if candidate [1.2] == [""D+""] then pure () else error ""assertion failed""
  if candidate [0.5] == [""D-""] then pure () else error ""assertion failed""
  if candidate [0.0] == [""E""] then pure () else error ""assertion failed""
  if candidate [1.0,0.3,1.5,2.8,3.3] == [""D"",""D-"",""C-"",""B"",""B+""] then pure () else error ""assertion failed""
  if candidate [0.0,0.7] == [""E"",""D-""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_82,fon_Latn,hs,"--Kpɔ́ndéwú --length nyí nùjlɔ́mɛnu nukɔntɔn ɖé alǒ False nú é ma nyí mɔ̌ ǎ ɔ --Ÿ na wlan azɔ̀ e nɔ yí wèmá ɖé bo nɔ lɛ́ yí gbè nú true nú wèmá ɔ--  >>> primeLength ""Hello""
--  True
--  >>> primeLength ""abcdcba""
--  True
--  >>> primeLength ""kittens""
--  True
--  >>> primeLength ""orange""
--  False
primeLength :: String -> Bool
primeLength string =","primeLength :: String -> Bool
primeLength string = isPrime (length string)

isPrime :: Int -> Bool
isPrime n
  | n < 2     = False
  | n == 2    = True
  | even n    = False
  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = primeLength
  if candidate ""Hello"" == True then pure () else error ""assertion failed""
  if candidate ""abcdcba"" == True then pure () else error ""assertion failed""
  if candidate ""kittens"" == True then pure () else error ""assertion failed""
  if candidate ""orange"" == False then pure () else error ""assertion failed""
  if candidate ""wow"" == True then pure () else error ""assertion failed""
  if candidate ""world"" == True then pure () else error ""assertion failed""
  if candidate ""MadaM"" == True then pure () else error ""assertion failed""
  if candidate ""Wow"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""HI"" == True then pure () else error ""assertion failed""
  if candidate ""go"" == True then pure () else error ""assertion failed""
  if candidate ""gogo"" == False then pure () else error ""assertion failed""
  if candidate ""aaaaaaaaaaaaaaa"" == False then pure () else error ""assertion failed""
  if candidate ""Madam"" == True then pure () else error ""assertion failed""
  if candidate ""M"" == False then pure () else error ""assertion failed""
  if candidate ""0"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_83,fon_Latn,hs,"--nùxwlé lɛ́ɛ e nɔ bɛ́ ɖò 1 jí alǒ nɔ fó ɖò 1 jí é.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │startsOneEnds :: Int -> Int
startsOneEnds n =","startsOneEnds :: Int -> Int
startsOneEnds n
  | n <= 0    = 0
  | n == 1    = 1
  | otherwise = 18 * 10^(n-2)","
main :: IO ()
main = do
  let candidate = startsOneEnds
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 2 == 18 then pure () else error ""assertion failed""
  if candidate 3 == 180 then pure () else error ""assertion failed""
  if candidate 4 == 1800 then pure () else error ""assertion failed""
  if candidate 5 == 18000 then pure () else error ""assertion failed""
  pure ()"
HumanEval_84,fon_Latn,hs,"--Kpɔ́ndéwú --│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> solve 1000
--  ""1""
--  >>> solve 150
--  ""110""
--  >>> solve 147
--  ""1100""
--  Variables:
--  @N integer
--  Constraints: 0 ≤ N ≤ 10000.
--  Output:
--  a string of binary number
solve :: Int -> String
solve N =","solve :: Int -> String
solve N = toBinary (sumOfDigits N)
  where
    sumOfDigits 0 = 0
    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)

    toBinary 0 = ""0""
    toBinary n = reverse (toBinary' n)
      where
        toBinary' 0 = """"
        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","
main :: IO ()
main = do
  let candidate = solve
  if candidate 1000 == ""1"" then pure () else error ""assertion failed""
  if candidate 150 == ""110"" then pure () else error ""assertion failed""
  if candidate 147 == ""1100"" then pure () else error ""assertion failed""
  if candidate 333 == ""1001"" then pure () else error ""assertion failed""
  if candidate 963 == ""10010"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_85,fon_Latn,hs,"--Kpɔ́ndéwú: --̆ E ná nùxwlé lɛ e nyí nùɖé ǎ lɛ é ɔ́, kpɔ́n nǔxwlé lɛ e ɖò nùxwlé lɛ jí lɛ é dó nukɔn.--  >>> add [4,2,6,7]
--  2
add :: [Int] -> Int
add lst =","add :: [Int] -> Int
add lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","
main :: IO ()
main = do
  let candidate = add
  if candidate [4,88] == 88 then pure () else error ""assertion failed""
  if candidate [4,5,6,7,2,122] == 122 then pure () else error ""assertion failed""
  if candidate [4,0,6,7] == 0 then pure () else error ""assertion failed""
  if candidate [4,4,6,8] == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_86,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --Akpàkpà: A ɖó na hɛn xókwin lɛ kpo tɛn mɛ e ɖò mɛ lɛ é kpo ɖó kpɔ́ ɖò hwɛgbe ɔ mɛ.--e nɔ ɖo jijɛ wɛ ɖò nǔ e è nɔ ylɔ ɖɔ ascii é jí.--è nɔ sɔ́ xókwin yɔyɔ́ ɖé dó ɖyɔ́ xókwin ɔ́ jí bɔ mɛ e è sɔ́ ɖó tò jí lɛ́ɛ bǐ nɔ́ ɖò --Sɛ́n e è ɖè ɖò nǔ lɛ mɛ é ɔ́, wuntun ɖé wɛ bɔ xókwin lɛ́ɛ bǐ (e è nɔ klán ɖó vo) --◯ Wlan azɔ̀ e nɔ yí wuntun ɖé bo nɔ lɛ́ yí gbè nú wuntun ɔ sín lilɛdogbeɖevomɛ ɖé é.--  >>> antiShuffle ""Hi""
--  ""Hi""
--  >>> antiShuffle ""hello""
--  ""ehllo""
--  >>> antiShuffle ""Hello World!!!""
--  ""Hello !!!Wdlor""
antiShuffle :: String -> String
antiShuffle s =","import Data.List (sort)
import Data.Char (isAlpha)

antiShuffle :: String -> String
antiShuffle s = unwords $ map sortWord (wordsAndSpaces s)
  where
    sortWord word = if all isAlpha word then sort word else word
    wordsAndSpaces [] = []
    wordsAndSpaces xs = if head xs == ' ' 
                        then "" "" : wordsAndSpaces (dropWhile (== ' ') xs)
                        else let (word, rest) = break (== ' ') xs
                             in word : wordsAndSpaces rest","
main :: IO ()
main = do
  let candidate = antiShuffle
  if candidate ""Hi"" == ""Hi"" then pure () else error ""assertion failed""
  if candidate ""hello"" == ""ehllo"" then pure () else error ""assertion failed""
  if candidate ""number"" == ""bemnru"" then pure () else error ""assertion failed""
  if candidate ""abcd"" == ""abcd"" then pure () else error ""assertion failed""
  if candidate ""Hello World!!!"" == ""Hello !!!Wdlor"" then pure () else error ""assertion failed""
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hi. My name is Mister Robot. How are you?"" == "".Hi My aemn is Meirst .Rboot How aer ?ouy"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_87,fon_Latn,hs,"--Kpɔ́ndéwú: --Bo lɛ́ sɔ́ lɛ́ɛ ɖó kpɔ́ bó ná dó ɖè ɖò nùjlɛ́jlɛ́ jí.--Nɔ kpɔn nǔ lɛ gbɔn xota lɛ jí ɖò tito jí.--xwɛ́kɛ́ lɛ́ɛ bǐ ɔ́, nǔ e è nɔ ylɔ́ ɖɔ ""coordinate"" ɔ́ wɛ nyí nǔ e è nɔ ylɔ́ ɖɔ ""row"" é.--bo na lɛ́ lɛ́ lɛ́ mɔ̀ nùɖé lɛ́ɛ ɖò nùɖé lɛ́ɛ mɛ, [(x1, y1), (x2, y2) ...] mɔ̌ --E na mɔ lst, kpo x, mɔ x ɖo nùxwlɛn ɔ mɛ, --xota ɖokpo ɖokpo sixu ɖó nùjlɛ́jlɛ́ gǒjímɛ vovo.--e cí matrix ɖɔhun, amɔ̌, é cí matrix lɛ ɖɔhun ǎ,--È na wèmá wè-gblɛ́n lɛ́ɛ mi, ɖò nùxwlé lɛ́ɛ mɛ,--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1
--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]
--  >>> getRow [] 1
--  []
--  >>> getRow [[],[1],[1,2,3]] 3
--  [(2, 2)]
getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x =","getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x = concatMap processRow (zip [0..] lst)
  where
    processRow (rowIndex, row) = 
      let colIndices = reverse $ findIndices (== x) row
      in [(rowIndex, colIndex) | colIndex <- colIndices]

findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","
main :: IO ()
main = do
  let candidate = getRow
  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error ""assertion failed""
  if candidate [] 1 == [] then pure () else error ""assertion failed""
  if candidate [[1]] 2 == [] then pure () else error ""assertion failed""
  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_88,fon_Latn,hs,"--Kpɔ́ndéwú: --* ma ɖyɔ nùwlanwlan e è na lɛ é ó.--Akpádo:--alǒ ɖè é ɖò nùxwásá è ɖò jɛ wɛ é mɛ nú nùxwásá ɔ ((mɛ̀ jɛ nukɔn nú nùxwásá ɔ, mɛ̀ jɛ nukɔn nú nùxwásá ɔ) nyí nùxwásá wè. --mi na sɔ́ wuntun ɔ́ dó zɔ́n nú wuntun ɔ́ ná ɖò jí wɛ, nú nǔ e è kplé ɔ́ (wuntun nukɔntɔn ɔ́, wuntun gǔdo gúdo tɔn ɔ́) nyí wuntun ǎ ɔ́,--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> sortArray []
--  []
--  >>> sortArray [5]
--  [5]
--  >>> sortArray [2,4,3,0,1,5]
--  [0,1,2,3,4,5]
--  >>> sortArray [2,4,3,0,1,5,6]
--  [6,5,4,3,2,1,0]
sortArray :: [Int] -> [Int]
sortArray array =","sortArray :: [Int] -> [Int]
sortArray array
  | null array = array
  | otherwise =
    let first = head array
        last = last array
        sumFirstLast = first + last
    in if odd sumFirstLast
       then sort array
       else reverse (sort array)","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5] == [5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error ""assertion failed""
  if candidate [2,1] == [1,2] then pure () else error ""assertion failed""
  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error ""assertion failed""
  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error ""assertion failed""
  pure ()"
HumanEval_89,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --yì jɛ wè jí azɔn wè yì tɛn wè jí.--E na lɛ́ ɖò wlan e è nɔ zán dó wlan nǔ lɛ é mɛ é ɖó na nɔ́ ɖíɖí ɖò ali ɖé jí bɔ wlan lɛ na nɔ́ nyí:--é nɔ́ lɛ́ yí wèmá wèmá ɖé dó wèmá ɔ́ jí.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> encrypt ""hi""
--  ""lm""
--  >>> encrypt ""asdfghjkl""
--  ""ewhjklnop""
--  >>> encrypt ""gf""
--  ""kj""
--  >>> encrypt ""et""
--  ""ix""
encrypt :: String -> String
encrypt s =","encrypt :: String -> String
encrypt s = map shiftChar s
  where
    shiftChar c
      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')
      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')
      | otherwise = c","
main :: IO ()
main = do
  let candidate = encrypt
  if candidate ""hi"" == ""lm"" then pure () else error ""assertion failed""
  if candidate ""asdfghjkl"" == ""ewhjklnop"" then pure () else error ""assertion failed""
  if candidate ""gf"" == ""kj"" then pure () else error ""assertion failed""
  if candidate ""et"" == ""ix"" then pure () else error ""assertion failed""
  if candidate ""faewfawefaewg"" == ""jeiajeaijeiak"" then pure () else error ""assertion failed""
  if candidate ""hellomyfriend"" == ""lippsqcjvmirh"" then pure () else error ""assertion failed""
  if candidate ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"" == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" then pure () else error ""assertion failed""
  if candidate ""a"" == ""e"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_90,fon_Latn,hs,"--Ðɔ nǔɖé nú nùɖé ma ɖò finɛ ǎ ɔ.--Wlǎn azɔ̀ e nyí next_smallest (a) bó ná lɛ́ lɛ́ lɛ́ kɔ̀n nǔ e nyí nǔ wègɔ́ e ɖò nù lɛ́ɛ mɛ é.--◯ È na nùxwlémɛ e è nɔ ylɔ ɖɔ nùxixa ɔ lɛ é we.--  >>> nextSmallest [1,2,3,4,5]
--  Just (2)
--  >>> nextSmallest [5,1,4,3,2]
--  Just (2)
--  >>> nextSmallest []
--  Just (Nothing)
--  >>> nextSmallest [1,1]
--  Just (Nothing)
nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =","nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =
  let uniqueSorted = removeDuplicates $ quicksort lst
  in if length uniqueSorted < 2
     then Nothing
     else Just (uniqueSorted !! 1)

removeDuplicates :: (Ord a) => [a] -> [a]
removeDuplicates = foldr (\x acc -> if x `elem` acc then acc else x : acc) []

quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = nextSmallest
  if candidate [1,2,3,4,5] == Just (2) then pure () else error ""assertion failed""
  if candidate [5,1,4,3,2] == Just (2) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1,1,1,0] == Just (1) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error ""assertion failed""
  pure ()"
HumanEval_91,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --Xò xota lɛ́ɛ jí ɔ, è nɔ sɔ́ """", ""?"" alǒ ""!"" dó ɖó dogbó.--""Boredom"" ɔ́ xógbe e nɔ bɛ́ dó ""I"" jí é wɛ.--È na sɔ́ xókwin ɖé lɛ dó así nú mi bɔ azɔ̌ e mi na wa é wɛ nyí ɖɔ mi na xa númɛ ɔ.--  >>> isBored ""Hello world""
--  0
--  >>> isBored ""The sky is blue. The sun is shining. I love this weather""
--  1
isBored :: String -> Int
isBored S =","isBored :: String -> Int
isBored s = length $ filter (startsWithI . words) $ splitSentences s
  where
    splitSentences :: String -> [String]
    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters "".?!""
    
    splitOnDelimiters :: String -> String -> [String]
    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of
      """" -> []
      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''
    
    startsWithI :: [String] -> Bool
    startsWithI [] = False
    startsWithI (x:_) = map toLower x == ""i""","
main :: IO ()
main = do
  let candidate = isBored
  if candidate ""Hello world"" == 0 then pure () else error ""assertion failed""
  if candidate ""Is the sky blue?"" == 0 then pure () else error ""assertion failed""
  if candidate ""I love It !"" == 1 then pure () else error ""assertion failed""
  if candidate ""bIt"" == 0 then pure () else error ""assertion failed""
  if candidate ""I feel good today. I will be productive. will kill It"" == 2 then pure () else error ""assertion failed""
  if candidate ""You and I are going for a walk"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_92,fon_Latn,hs,"--Kpɔ́ndéwú --E nɔ lɛ́ lɛ́ wá ɖó nǔvú ɖò ninɔmɛ ɖevo lɛ mɛ.--E na lɛ́ lɛ́ wá yì nú nùjlɛ́n lɛ́ɛ ɖokpo ɔ́ na nyí nùjlɛ́n we ɖě lɛ́ɛ sín nǔjlɛ́n, bɔ nùjlɛ́n lɛ́ɛ bǐ na nyí nùjlɛ́n ɔ́.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> anyInt 5 2 7
--  True
--  >>> anyInt 3 2 2
--  False
--  >>> anyInt 3 (-2) 1
--  True
--  >>> anyInt 3.6 -2.2 2
--  False
anyInt :: Float -> Float -> Float -> Bool
anyInt x y z =","anyInt :: Float -> Float -> Float -> Bool
anyInt x y z
  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =
      x == y + z || y == x + z || z == x + y
  | otherwise = False","
main :: IO ()
main = do
  let candidate = anyInt
  if candidate 2.0 3.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 2.5 2.0 3.0 == False then pure () else error ""assertion failed""
  if candidate 1.5 5.0 3.5 == False then pure () else error ""assertion failed""
  if candidate 2.0 6.0 2.0 == False then pure () else error ""assertion failed""
  if candidate 4.0 2.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.2 2.2 2.2 == False then pure () else error ""assertion failed""
  if candidate (-4).0 6.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.0 1.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_93,fon_Latn,hs,"--Kpɔ́ndéwú: --Mi nɔ sɔ́ wlan lɛ́ɛ kɛɖɛ́ dó mɔ nǔ.--xósúsú ɖò wlanwlán e è nɔ dó gbè mɛ é mɛ.--wɛn ɔ kpo wèmá e nɔ tɔ́n ɖò tɛn wè nukɔn nú wèmá ɔ kpo --e nɔ ɖyɔ́ xókwin lɛ́ɛ bǐ, nɔ ɖyɔ́ xókwin lɛ́ɛ bǐ ɖò  mɛ é.--◯ Wlan azɔ̀ e nɔ yí wɛn ɖé, bo nɔ wlan dó mɔ̌ é ɖé--  >>> encode ""test""
--  ""TGST""
--  >>> encode ""This is a message""
--  ""tHKS KS C MGSSCGG""
encode :: String -> String
encode message =","encode :: String -> String
encode = map transformChar
  where
    transformChar :: Char -> Char
    transformChar c
      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c
      | otherwise      = swapCase c c
      where
        lowerC = toLower c

    isVowel :: Char -> Bool
    isVowel c = c `elem` ""aeiou""

    swapCase :: Char -> Char -> Char
    swapCase origC c
      | isUpper origC = toLower c
      | otherwise     = toUpper c","
main :: IO ()
main = do
  let candidate = encode
  if candidate ""TEST"" == ""tgst"" then pure () else error ""assertion failed""
  if candidate ""Mudasir"" == ""mWDCSKR"" then pure () else error ""assertion failed""
  if candidate ""YES"" == ""ygs"" then pure () else error ""assertion failed""
  if candidate ""This is a message"" == ""tHKS KS C MGSSCGG"" then pure () else error ""assertion failed""
  if candidate ""I DoNt KnOw WhAt tO WrItE"" == ""k dQnT kNqW wHcT Tq wRkTg"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_94,fon_Latn,hs,"--Kpɔ́ndéwú: --A na mɔ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ e nyí nùjlɛ́jlɛ́ nukɔn nukɔntɔn ɔ bo na lɛ́ yí nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ tɔn lɛ́ɛ sín nùjlɛ́jlɛ́.--◯ È na nùxwlémɛ e è nɔ ylɔ ɖɔ nùxixa ɔ lɛ é we.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]
--  10
--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]
--  25
--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]
--  13
--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]
--  11
--  >>> skjkasdkd [0,81,12,3,1,21]
--  3
--  >>> skjkasdkd [0,8,1,2,1,7]
--  7
skjkasdkd :: [Int] -> Int
skjkasdkd lst =","skjkasdkd :: [Int] -> Int
skjkasdkd lst = sumDigits (largestPrime lst)

-- Function to check if a number is prime
isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]

-- Integer square root using binary search, O(log n)
isqrt :: Int -> Int
isqrt n = floor . sqrt $ fromIntegral n

-- Function to find the largest prime in the list
largestPrime :: [Int] -> Int
largestPrime = foldr (\x acc -> if isPrime x && x > acc then x else acc) 0

-- Function to calculate the sum of the digits of a number
sumDigits :: Int -> Int
sumDigits 0 = 0
sumDigits n = n `mod` 10 + sumDigits (n `div` 10)","
main :: IO ()
main = do
  let candidate = skjkasdkd
  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error ""assertion failed""
  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error ""assertion failed""
  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error ""assertion failed""
  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error ""assertion failed""
  if candidate [0,81,12,3,1,21] == 3 then pure () else error ""assertion failed""
  if candidate [0,8,1,2,1,7] == 7 then pure () else error ""assertion failed""
  if candidate [8191] == 19 then pure () else error ""assertion failed""
  if candidate [8191,123456,127,7] == 19 then pure () else error ""assertion failed""
  if candidate [127,97,8192] == 10 then pure () else error ""assertion failed""
  pure ()"
HumanEval_95,fon_Latn,hs,"--Kpɔ́ndéwú: --azɔ̀ ɔ́ ɖó na lɛ́ kɔ̀n nǔ e nyí nǔvú é nú nùxwlémɛ́n nùxwlémɛ́n ɔ́ nyí nǔvú.--case alǒ azin lɛ bǐ nyí xɛtɛ lɛ ɖò wema ɖaxó mɛ, nú é ma nyí mɔ̌ ǎ ɔ é na lɛ́ lɛ́ wá nyí False. --◯ N'í ná ɖó nùxójomɛ lɛ́ɛ ɔ́, nú wuntun lɛ́ɛ bǐ nyí xójomɛ ɖò fí e è nɔ sɔ́ wuntun lɛ́ɛ dó ɖó wuntun lɛ́ɛ ɔ́, é ná lɛ́ nyí True.--  >>> checkDictCase [(""a"", ""apple""), (""b"", ""banana"")]
--  True
--  >>> checkDictCase [(""a"", ""apple""), (""A"", ""banana""), (""B"", ""banana"")]
--  False
--  >>> checkDictCase [(""a"", ""apple""), (8, ""banana""), (""a"", ""apple"")]
--  False
--  >>> checkDictCase [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")]
--  False
--  >>> checkDictCase [(""STATE"", ""NC""), (""ZIP"", ""12345"")]
--  True
checkDictCase :: [(String, String)] -> Bool
checkDictCase dict =","import Data.Char (isUpper, isLower)

checkDictCase :: [(String, String)] -> Bool
checkDictCase [] = False
checkDictCase dict = all isLower allKeys || all isUpper allKeys
  where
    allKeys = concatMap fst dict","
main :: IO ()
main = do
  let candidate = checkDictCase
  if candidate [(""p"", ""pineapple""), (""b"", ""banana"")] == True then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""A"", ""banana""), (""B"", ""banana"")] == False then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""5"", ""banana""), (""a"", ""apple"")] == False then pure () else error ""assertion failed""
  if candidate [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")] == False then pure () else error ""assertion failed""
  if candidate [(""STATE"", ""NC""), (""ZIP"", ""12345"")] == True then pure () else error ""assertion failed""
  if candidate [(""fruit"", ""Orange""), (""taste"", ""Sweet"")] == True then pure () else error ""assertion failed""
  if candidate [] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_96,fon_Latn,hs,"--kpɔ́ndéwú ɔ: --nùxwlé lɛ́ɛ e nyí nùjlɛ́kpá lɛ́ɛ bo ɖò hweɖénu nú n.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> countUpTo 5
--  [2,3]
--  >>> countUpTo 11
--  [2,3,5,7]
--  >>> countUpTo 0
--  []
--  >>> countUpTo 20
--  [2,3,5,7,11,13,17,19]
--  >>> countUpTo 1
--  []
--  >>> countUpTo 18
--  [2,3,5,7,11,13,17]
countUpTo :: Int -> [Int]
countUpTo n =","countUpTo :: Int -> [Int]
countUpTo n = filter isPrime [2..n-1]

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = countUpTo
  if candidate 5 == [2,3] then pure () else error ""assertion failed""
  if candidate 6 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 7 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 10 == [2,3,5,7] then pure () else error ""assertion failed""
  if candidate 0 == [] then pure () else error ""assertion failed""
  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error ""assertion failed""
  if candidate 1 == [] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error ""assertion failed""
  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error ""assertion failed""
  pure ()"
HumanEval_97,fon_Latn,hs,"--Kpɔ́ndéwú: --Mi ɖɔ ɖɔ nǔ e è wlan ɔ́ nɔ́ sɔgbe hwebǐnu.--nùjlɛ́kpo tɔn yetɔn lɛ sín nǔkúnmɛ.--¢ñá ðÜñå ôï ðñüãñáììá ðïõ ðáßæåé 2 êáôáóôÜóåéò êáé ðáßæåé ¢ñá--  >>> multiply 148 412
--  16
--  >>> multiply 19 28
--  72
--  >>> multiply 2020 1851
--  0
--  >>> multiply 14 (-15)
--  20
multiply :: Int -> Int -> Int
multiply a b =","multiply :: Int -> Int -> Int
multiply a b = (abs a `mod` 10) * (abs b `mod` 10)","
main :: IO ()
main = do
  let candidate = multiply
  if candidate 148 412 == 16 then pure () else error ""assertion failed""
  if candidate 19 28 == 72 then pure () else error ""assertion failed""
  if candidate 2020 1851 == 0 then pure () else error ""assertion failed""
  if candidate 14 (-15) == 20 then pure () else error ""assertion failed""
  if candidate 76 67 == 42 then pure () else error ""assertion failed""
  if candidate 17 27 == 49 then pure () else error ""assertion failed""
  if candidate 0 1 == 0 then pure () else error ""assertion failed""
  if candidate 0 0 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_98,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --◯ Xà nùjlɛdonǔwu s, bo xa xókwin ɖaxó e ɖò nǔ e è wlan dó nǔ wu é mɛ é bǐ.--  >>> countUpper ""aBCdEf""
--  1
--  >>> countUpper ""abcdefg""
--  0
--  >>> countUpper ""dBBE""
--  0
countUpper :: String -> Int
countUpper s =","countUpper :: String -> Int
countUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` ""AEIOU""]","
main :: IO ()
main = do
  let candidate = countUpper
  if candidate ""aBCdEf"" == 1 then pure () else error ""assertion failed""
  if candidate ""abcdefg"" == 0 then pure () else error ""assertion failed""
  if candidate ""dBBE"" == 0 then pure () else error ""assertion failed""
  if candidate ""B"" == 0 then pure () else error ""assertion failed""
  if candidate ""U"" == 1 then pure () else error ""assertion failed""
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""EEEE"" == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_99,fon_Latn,hs,"--Kpɔ́ndéwú --sín nùɖé wè lɛ́ɛ jí ɔ́, mi ná lɛ́ lɛ́ dó lɛ́ zɔ́n nú zéro.--é nɔ́ lɛ́ yí nùjlɛ́kpá e sɛ́ dó é. Nú nùjlɛ́kpá ɔ́ ɖò zɔ́n ɖokpó ɔ́ jí ɔ́ --̆ Wà nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nùɖé nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú--  >>> closestInteger ""10""
--  10
--  >>> closestInteger ""15.3""
--  15
--  Note:
--  Rounding away from zero means that if the given number is equidistant
--  from two integers, the one you should return is the one that is the
--  farthest from zero. For example closest_integer(""14.5"") should
--  return 15 and closest_integer(""-14.5"") should return -15.
closestInteger :: String -> Int
closestInteger value =","closestInteger :: String -> Int
closestInteger value = 
  let n = read value :: Double
  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","
main :: IO ()
main = do
  let candidate = closestInteger
  if candidate ""10"" == 10 then pure () else error ""assertion failed""
  if candidate ""14.5"" == 15 then pure () else error ""assertion failed""
  if candidate ""-15.5"" == (-16) then pure () else error ""assertion failed""
  if candidate ""15.3"" == 15 then pure () else error ""assertion failed""
  if candidate ""0"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_100,fon_Latn,hs,"--Kpɔ́ndéwú: --i nɔte nú awinnya lɛ́ɛ ɖò xù ɔ́ mɛ (i+1).--Zɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n--- nú n nyí nùjlɛ́n wè ɔ, nú é nyí wè ɔ, nú é nyí wè ɔ.--- nú n nyí nùxwɛ́ ɔ́, nú è na ɖɔ ɖɔ nùxwɛ́ e bɔ d'é jí é.--Awǐnnya e ɖò xɔ e ɖò nukɔn é mɛ lɛ́ɛ sín nùɖé nyí: --Awinnya n wɛ ɖò xɔ nukɔntɔn ɔ mɛ.--│ │N'e na nyí nùxwlémɛ e nyí nǔ ɖagbe é n ɔ, a ɖó na bló awinnya xwɛ n.--  >>> makeAPile 3
--  [3,5,7]
makeAPile :: Int -> [Int]
makeAPile n =","makeAPile :: Int -> [Int]
makeAPile n = take n [n, n + 2 ..]","
main :: IO ()
main = do
  let candidate = makeAPile
  if candidate 3 == [3,5,7] then pure () else error ""assertion failed""
  if candidate 4 == [4,6,8,10] then pure () else error ""assertion failed""
  if candidate 5 == [5,7,9,11,13] then pure () else error ""assertion failed""
  if candidate 6 == [6,8,10,12,14,16] then pure () else error ""assertion failed""
  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error ""assertion failed""
  pure ()"
HumanEval_101,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --bo na klán wuntun ɔ dó xókwin lɛ jí bo na lɛ́ lɛ́ wá mɔ xókwin lɛ sín nùwlanwlan.--È na sɔ́ xókwin lɛ́ɛ dó akpáxwé ɖé lɛ́ɛ mɛ, bɔ è na ɖó wuntun alǒ tɛn dó lɛ́ɛ.--  >>> wordsString ""Hi, my name is John""
--  [""Hi"",""my"",""name"",""is"",""John""]
--  >>> wordsString ""One, two, three, four, five, six""
--  [""One"",""two"",""three"",""four"",""five"",""six""]
wordsString :: String -> [String]
wordsString s =","wordsString :: String -> [String]
wordsString s = words $ map (\c -> if c == ',' then ' ' else c) s","
main :: IO ()
main = do
  let candidate = wordsString
  if candidate ""Hi, my name is John"" == [""Hi"",""my"",""name"",""is"",""John""] then pure () else error ""assertion failed""
  if candidate ""One, two, three, four, five, six"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate ""Hi, my name"" == [""Hi"",""my"",""name""] then pure () else error ""assertion failed""
  if candidate ""One,, two, three, four, five, six,"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""ahmed     , gamal"" == [""ahmed"",""gamal""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_102,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --nú nùjlɛ́nkpa mɔ̌hunkɔtɔn ɖě ma ɖò finɛ ǎ ɔ, azɔ̀ ɔ na lɛ́ lɛ́ kɔ́n -1.--nùxwléma ganxixo ɖaxó e ɖò tɛntin [x, y] é.--E nɔ sɔ́ nùxwɛ́ ɖagbe wè x kpo y kpo bó nɔ lɛ́ yí nùxwɛ́ ɖagbe wè lɛ́ɛ dó nùxwɛ́ ɖagbe wè lɛ́ɛ jí--  >>> chooseNum 12 15
--  14
--  >>> chooseNum 13 12
--  (-1)
chooseNum :: Int -> Int -> Int
chooseNum x y =","chooseNum :: Int -> Int -> Int
chooseNum x y
    | x > y = -1
    | even upperBound = upperBound
    | even (upperBound - 1) = upperBound - 1
    | otherwise = -1
  where
    upperBound = max x y","
main :: IO ()
main = do
  let candidate = chooseNum
  if candidate 12 15 == 14 then pure () else error ""assertion failed""
  if candidate 13 12 == (-1) then pure () else error ""assertion failed""
  if candidate 33 12354 == 12354 then pure () else error ""assertion failed""
  if candidate 5234 5233 == (-1) then pure () else error ""assertion failed""
  if candidate 6 29 == 28 then pure () else error ""assertion failed""
  if candidate 27 10 == (-1) then pure () else error ""assertion failed""
  if candidate 7 7 == (-1) then pure () else error ""assertion failed""
  if candidate 546 546 == 546 then pure () else error ""assertion failed""
  pure ()"
HumanEval_104,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --Akpàkpà: Akpákpà e è na lɛ́ wá lɛ́ɛ ɔ́, è ɖó na sɔ́ dó tito jí.--nǔ e ma ɖó nùxixa ɖokpo ǎ é.--│Nɛ è na wlan nùxwlémɛ e nɔ ɖó nùxixa ɖagbe lɛ é x. ɔ, è na lɛ́ wlan nùxwlémɛ e è ɖè lɛ é bǐ.--  >>> uniqueDigits [15,33,1422,1]
--  [1,15,33]
--  >>> uniqueDigits [152,323,1422,10]
--  []
uniqueDigits :: [Int] -> [Int]
uniqueDigits x =","uniqueDigits :: [Int] -> [Int]
uniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","
main :: IO ()
main = do
  let candidate = uniqueDigits
  if candidate [15,33,1422,1] == [1,15,33] then pure () else error ""assertion failed""
  if candidate [152,323,1422,10] == [] then pure () else error ""assertion failed""
  if candidate [12345,2033,111,151] == [111,151] then pure () else error ""assertion failed""
  if candidate [135,103,31] == [31,135] then pure () else error ""assertion failed""
  pure ()"
HumanEval_105,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --""Alɔ̌"", ""Hwlɛ"", ""Gbe"", ""Nɔ"", ""Gbɛ"", ""Gbɛtɔ́"", ""Gbɛtɔ́n"", ""Gbɛtɔ́n"", ""Gbɛtɔn"". --lɛ́ kɔ́n nù e è mɔ é, bo sɔ́ nùkwín ɖokpo ɖokpo ɖó tɛn tɔn mɛ nú nù e é nɔ nyí é sín --¢ñá ðñïóöÝñåé ìéá éóôïñßá áðü ïñéóìÝíåò ðåñéðôþóåéò, êáôáóôñÝöåé ôéò ðåñéðôþóåéò ðïõ åßíáé ìåôáîý 1 êáé 9 ðáñáðÜíù, --  >>> byLength [2,1,1,4,5,8,2,3]
--  [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""]
--  If the list is empty, return an empty list:
--  >>> byLength []
--  []
--  If the list has any strange number ignore it:
--  >>> byLength [1,(-1),55]
--  [""One""]
byLength :: [Int] -> [String]
byLength arr =","byLength :: [Int] -> [String]
byLength arr = map digitName . reverse . sort . filter isValid $ arr
  where
    isValid x = x >= 1 && x <= 9
    digitName x = case x of
      1 -> ""One""
      2 -> ""Two""
      3 -> ""Three""
      4 -> ""Four""
      5 -> ""Five""
      6 -> ""Six""
      7 -> ""Seven""
      8 -> ""Eight""
      9 -> ""Nine""
      _ -> error ""Unexpected number""","
main :: IO ()
main = do
  let candidate = byLength
  if candidate [2,1,1,4,5,8,2,3] == [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-1),55] == [""One""] then pure () else error ""assertion failed""
  if candidate [1,(-1),3,2] == [""Three"",""Two"",""One""] then pure () else error ""assertion failed""
  if candidate [9,4,8] == [""Nine"",""Eight"",""Four""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_106,fon_Latn,hs,"--Kpɔ́n: --nùxwásá nú i ɔ́ wɛ nyí nùjlɛ́kpo e ɖò 1 jí jɛ i jí é (1 * 2 * ... * i).--un bɛ́ sín 1.--alǒ nùjlɛ́kpo lɛ sín xota sín 1 jɛ i jí. --bo na lɛ́ lɛ́ yí nùxwlé e nyí nùxwlé n tɔn é, bɔ nǔ e ɖò nǔxwlé i jí é sín akwɛ́ ná nyí nǔxwlé i tɔn ɔ́, nú i nyí nǔxwlé --¢ñá ðÜñå ôï f ðïõ âÜæåé n óáí ðñïóùðéêü, --  >>> f 5
--  [1,2,6,24,15]
f :: Int -> [Int]
f n =","f :: Int -> [Int]
f n = map g [1..n]
  where
    g i
      | even i    = factorial i
      | otherwise = sum [1..i]
    
    factorial 0 = 1
    factorial m = product [1..m]","
main :: IO ()
main = do
  let candidate = f
  if candidate 5 == [1,2,6,24,15] then pure () else error ""assertion failed""
  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  if candidate 3 == [1,2,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_107,fon_Latn,hs,"--Kpɔ́ndo 1: --nùjlɛ́kpá palindromes e ɖò tɛnkpɔn ɔ mɛ lɛ é wɛ nyí ((1, n), kpodo mɛ lɛ kpo. --¢óå ìéá êáëÞ óåéñÜ n, ðáßæåé Ýíá êëßìá ðïõ Ý÷åé ôï ðïóïóôü ôùí ðáñáðÜíù êáé ôùí ðáñáðÜíù ¢óå ìéá óåéñÜ ðïõ Ý÷åé ôï ðïóïóôü ôùí ðáñáðÜíù--  >>> evenOddPalindrome 3
--  (1, 2)
--  Explanation:
--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
--  Example 2:
--  >>> evenOddPalindrome 12
--  (4, 6)
--  Explanation:
--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
--  Note:
--  1. 1 <= n <= 10^3
--  2. returned tuple has the number of even and odd integer palindromes respectively.
evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n =","evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n = (length evens, length odds)
  where
    isPalindrome x = show x == reverse (show x)
    palindromes = filter isPalindrome [1..n]
    evens = filter even palindromes
    odds  = filter odd palindromes","
main :: IO ()
main = do
  let candidate = evenOddPalindrome
  if candidate 123 == (8, 13) then pure () else error ""assertion failed""
  if candidate 12 == (4, 6) then pure () else error ""assertion failed""
  if candidate 3 == (1, 2) then pure () else error ""assertion failed""
  if candidate 63 == (6, 8) then pure () else error ""assertion failed""
  if candidate 25 == (5, 6) then pure () else error ""assertion failed""
  if candidate 19 == (4, 6) then pure () else error ""assertion failed""
  if candidate 9 == (4, 5) then pure () else error ""assertion failed""
  if candidate 1 == (0, 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_108,fon_Latn,hs,"--¢óå ð.÷. -123 Ý÷åé ðáñáããåëìáôéêÜ -1, 2 êáé 3. --Enyi nùxwásá ɖé nyí nǔglɔ́ ɔ, hǔn wuntun tɔn nukɔntɔn ɔ na nyí nǔglɔ́: --nùxwlé lɛ́ɛ e nùxwlé lɛ́ɛ tɔn sín nùxwlé ɔ́ hú 0 é. --Ÿ na wlan azɔ̀ count_nums e nɔ yí nùxwlé lɛ sín nùxwlé lɛ bo nɔ lɛ́ lɛ́ kɔ̀n é--  >>> countNums []
--  0
--  >>> countNums [(-1),11,(-11)]
--  1
--  >>> countNums [1,1,2]
--  3
countNums :: [Int] -> Int
countNums arr =","countNums :: [Int] -> Int
countNums arr = length $ filter ((> 0) . sumDigits) arr
  where
    sumDigits 0 = 0
    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)
                  in sum digits","
main :: IO ()
main = do
  let candidate = countNums
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),0] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error ""assertion failed""
  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error ""assertion failed""
  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error ""assertion failed""
  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_109,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --Akpá: Akpá e è na lɛ́ ɖó lɛ́ɛ ná nyí nǔ ɖokpo ɔ ɖò nùjlɛ́jlɛ́ e è na lɛ́ ɖó é mɛ.--Enyi wèmá e è na é ma ɖò nùɖé ǎ ɔ, é na lɛ́ wá yì True. --bo lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́--Nú é kpéwú bo na mɔ nùjlɛ́jlɛ́ e è ɖè ɔ́ gbɔn azɔ̌ e è ɖɔ ɖò tají é gblamɛ ɔ́ --tɛnkpɔn e mɛ è bɛ́ ɖò nùjlɛ́jlɛ́ ɔ mɛ é, é wɛ nyí nǔ e è nɔ ylɔ ɖɔ 0gɔ́ ɔ.--e na kpò ɖò ali ɖagbe ɔ mɛ.--azɔ̀ ɖisiɖisiɖisi ɖokpó ɖisiɖisi nú nùjɔnǔ lɛ́ɛ bǐ ɖò nùjlɛ́jlɛ́ ɔ́ mɛ̀ nú ɖokpó--A na bló azɔ̀ ɖisiɖisi nú azɔn mɔkpan.--azɔ̀ e bɔ̀ é ɖò nùjlɛ́jlɛ́ e è wlan ɖò fí é jí é: --e sixu ɖe lɛ ɖo tito e ma nɔ jɛ te ǎ mɛ gbɔn azɔ̌ e nyí --nùjlɛ́jlɛ́ ɖò nùjlɛ́jlɛ́ ɔ́ mɛ lɛ́ɛ ɔ́ è na sɔ́ yě ɖó nùɖé wú ǎ. azɔ̌ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ ɖɔ--ɛ̀n ɖ'emɛ̀ ɔ́, nùɖé ɖò nùɖé jí, nùɖé ɖò nùɖé jí, nùɖé ɖò nùɖé jí.--  >>> moveOneBall [3,4,5,1,2]
--  True
--  Explanation: By performin 2 right shift operations, non-decreasing order can
--  be achieved for the given list.
--  >>> moveOneBall [3,5,4,1,2]
--  False
--  Explanation:It is not possible to get non-decreasing order for the given
--  list by performing any number of right shift operations.
moveOneBall :: [Int] -> Bool
moveOneBall arr =","moveOneBall :: [Int] -> Bool
moveOneBall [] = True
moveOneBall arr = canBeSorted (arr ++ arr)
  where
    n = length arr
    canBeSorted xs = any isSorted (take n <$> tails xs)
    isSorted ys = and $ zipWith (<=) ys (tail ys)
    tails [] = []
    tails l@(_:xs) = l : tails xs","
main :: IO ()
main = do
  let candidate = moveOneBall
  if candidate [3,4,5,1,2] == True then pure () else error ""assertion failed""
  if candidate [3,5,10,1,2] == True then pure () else error ""assertion failed""
  if candidate [4,3,1,2] == False then pure () else error ""assertion failed""
  if candidate [3,5,4,1,2] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_110,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --E ma nyí mɔ̌ ǎ ɔ, lɛ́ kɔ nú ""ÉÒ"".--nú nǔ lɛ́ɛ bǐ ɖò lst1 mɛ ɔ, yí gbè nú ""YES"".--Nú è na kpéwú bo ɖyɔ nǔ lɛ ɖò lst1 kpo lst2 kpo tɛntin bo bló bɔ --E sɔ́ ɖó dogbó nú nùxámɛ nǔ e è sixu ɖyɔ ɖò lst1 kpo lst2 kpo tɛntin é ǎ.--ye na bló lst1 nùjlɛ́n e nyí nùjlɛ́n lɛ é sín nùjlɛ́n ɖokpo.--bo na ɖɔ ɖɔ emi sixu ɖyɔ nǔ lɛ à jí à jí --¢ñá óôï èÝìá áõôü, èá ðñïóöÝñåéò ìéá ðñÜîç ðïõ ðáßæåé 2 ðåñéðôþóåéò óôïõò ðïäïóöáéñéóôÝò, ¢ñá óôï èÝìá áõôü,--  >>> exchange [1,2,3,4] [1,2,3,4]
--  ""YES""
--  >>> exchange [1,2,3,4] [1,5,3,4]
--  ""NO""
--  It is assumed that the input lists will be non-empty.
exchange :: [Int] -> [Int] -> String
exchange lst1 lst2 =","exchange :: [Int] -> [Int] -> String
exchange lst1 lst2
  | all even lst1 = ""YES""
  | null oddLst1 || null evenLst2 = ""NO""
  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)
                in if possibility then ""YES"" else ""NO""
  where
    oddLst1 = filter odd lst1
    evenLst2 = filter even lst2","
main :: IO ()
main = do
  let candidate = exchange
  if candidate [1,2,3,4] [1,2,3,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [1,5,3,4] == ""NO"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [2,1,4,3] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,3] == ""NO"" then pure () else error ""assertion failed""
  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == ""NO"" then pure () else error ""assertion failed""
  if candidate [100,200] [200,200] == ""YES"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_111,fon_Latn,hs,"--Kpɔ́n: --Enyi wèmá lɛ́ɛ ɖò nǔ ɖokpo ɔ mɛ ɔ, lɛ́ kɔ nú ye bǐ.--wema e è nɔ lɛ́ wlan azɔn mɔkpan bɔ è nɔ lɛ́ wlan azɔn mɔkpan é.--̆ E ná wèmá e nɔ xlɛ́ wèmá kpɛví kpɛví e è klán ɖó vo lɛ é é ɔ, é ná lɛ́ wá nùxwlémɛ ɖé lɛ sín nùxwlémɛ.--  >>> histogram ""a b c""
--  [(""a"", 1), (""b"", 1), (""c"", 1)]
--  >>> histogram ""a b b a""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""a b c a b""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""b b b b a""
--  [(""b"", 4)]
--  >>> histogram """"
--  []
histogram :: String -> [(String, Int)]
histogram test =","import Data.List (group, sort)
import Data.Ord (comparing)

histogram :: String -> [(String, Int)]
histogram input =
  let wordsList = words input
      grouped = group $ sort wordsList
      countList = map (\ws -> (head ws, length ws)) grouped
      maxCount = if null countList then 0 else maximum $ map snd countList
  in filter ((== maxCount) . snd) countList","
main :: IO ()
main = do
  let candidate = histogram
  if candidate ""a b b a"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c a b"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c d g"" == [(""a"", 1), (""b"", 1), (""c"", 1), (""d"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""b b b b a"" == [(""b"", 4)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""a"" == [(""a"", 1)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_112,fon_Latn,hs,"--Kpɔ́ndéwú --A na lɛ́ yí nùɖé lɛ́ɛ dó nùɖé lɛ́ɛ mɛ, bɔ nǔ e è na mɔ é ná nyí nǔ e è na mɔ é kpo nǔ e è na mɔ é kpo.--Hweɖevonu ɔ wɛ è nɔ ylɔ ɖɔ palindrome enyi e nɔ xa gbɔn vo nú ée è nɔ xa gbɔn nukɔn é.--bo kpɔ́n ɖɔ xwɛ e è mɔ é nyí palindrome à jí.--e na lɛ́ sɔ́ wuntun e ɖò wuntun e ɖò wuntun c mɛ é bǐ dó wuntun s mɛ.--azɔ̌ e è ɖó ná wa é--  >>> reverseDelete ""abcde"" ""ae""
--  (""bcd"", False)
--  >>> reverseDelete ""abcdef"" ""b""
--  (""acdef"", False)
--  >>> reverseDelete ""abcdedcba"" ""ab""
--  (""cdedc"", True)
reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =","import Data.List (filter)

reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =
  let result = filter (`notElem` c) s
  in (result, result == reverse result)","
main :: IO ()
main = do
  let candidate = reverseDelete
  if candidate ""abcde"" ""ae"" == (""bcd"", False) then pure () else error ""assertion failed""
  if candidate ""abcdef"" ""b"" == (""acdef"", False) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""ab"" == (""cdedc"", True) then pure () else error ""assertion failed""
  if candidate ""dwik"" ""w"" == (""dik"", False) then pure () else error ""assertion failed""
  if candidate ""a"" ""a"" == ("""", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" """" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""v"" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""vabba"" ""v"" == (""abba"", True) then pure () else error ""assertion failed""
  if candidate ""mamma"" ""mia"" == ("""", True) then pure () else error ""assertion failed""
  pure ()"
HumanEval_113,fon_Latn,hs,"--̆n ɔ́, wuntun e è nɔ ylɔ ɖɔ ""i"" ɔ́ nɔ́ ɖó wuntun e è nɔ ylɔ ɖɔ ""i"" é.--wèmá è è ná dó è é.--Nǔɖevi ɖokpo ɖokpo i tɔn e è nɔ ɖe tɔ́n é ɖó na nyí nùxíxo nǔɖevi e ɖò nǔɖevi ɔ mɛ é tɔn.--│E ɖo xuxu wε, bo wε ɖokpo ɖokpo nɔ ɖo nuɖevi ɖokpo ɖokpo ji ɔ, e na lɛ na wε xuxu wε.--  >>> oddCount [""1234567""]
--  [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
--  >>> oddCount [""3"",""11111111""]
--  [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""]
oddCount :: [String] -> [String]
oddCount lst =","oddCount :: [String] -> [String]
oddCount lst = map formatString lst
  where
    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""

    countOdds :: String -> Int
    countOdds str = length $ filter isOddDigit str

    formatString :: String -> String
    formatString str =
      let oddCount = countOdds str in
      ""the number of odd elements "" ++ show oddCount ++ 
      ""n the str"" ++ show oddCount ++ ""ng "" ++ show oddCount ++
      "" of the "" ++ show oddCount ++ ""nput.""","
main :: IO ()
main = do
  let candidate = oddCount
  if candidate [""1234567""] == [""the number of odd elements 4n the str4ng 4 of the 4nput.""] then pure () else error ""assertion failed""
  if candidate [""3"",""11111111""] == [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""] then pure () else error ""assertion failed""
  if candidate [""271"",""137"",""314""] == [""the number of odd elements 2n the str2ng 2 of the 2nput."",""the number of odd elements 3n the str3ng 3 of the 3nput."",""the number of odd elements 2n the str2ng 2 of the 2nput.""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_114,fon_Latn,hs,"--Kpɔ́ndéwú --nùxwlé lɛ́ɛ.--¢ñá ðñïóöÝñåé ìéá êáôçãïñßá áðü ÷ñÞìáôá, âñåßôå ôï ìéêñüôåñï ÷ñÞìá óå êÜèå óõãêåêñéìÝíç êáôçãïñßá.--  >>> minsubarraysum [2,3,4,1,2,4]
--  1
--  >>> minsubarraysum [(-1),(-2),(-3)]
--  (-6)
minsubarraysum :: [Int] -> Int
minsubarraysum nums =","minsubarraysum :: [Int] -> Int
minsubarraysum nums = minimum $ scanl1 (\acc x -> min x (acc + x)) nums","
main :: IO ()
main = do
  let candidate = minsubarraysum
  if candidate [2,3,4,1,2,4] == 1 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error ""assertion failed""
  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error ""assertion failed""
  if candidate [0,10,20,1000000] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [10,11,13,8,3,4] == 3 then pure () else error ""assertion failed""
  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error ""assertion failed""
  if candidate [(-10)] == (-10) then pure () else error ""assertion failed""
  if candidate [7] == 7 then pure () else error ""assertion failed""
  if candidate [1,(-1)] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_115,fon_Latn,hs,"--Kpɔ́ndo 1: --Wá azɔn nabi a na dó j'azɔ̌n lɛ́ɛ.--azɔ̌ towe wɛ nyí ɖɔ a ni zán kɔ́n lɛ bo dó xú tɔ ɔ́.--bo sinkpo lɛ bǐ nɔ ɖó jijɔ ɖokpo ɔ.--Hɔn ɖokpo ɖokpo nɔ ɖó go e è sixu zán bo na ɖè sin sín mɛ é,--bo 1 ɖokpo ɖokpo ɖo ali ɖokpo ɔ mɛ nɔte nú azɔmɛ ɖokpo sin tɔn.--A mɔ sɛ́nxí lɛ́ɛ sín xósúsú ɖé. Xósúsú ɖokpo ɖokpo nɔte nú sɛ́nxí ɖokpo.--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1
--  6
--  Example 2:
--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2
--  5
--  Example 3:
--  >>> maxFill [[0,0,0],[0,0,0]] 5
--  0
--  Constraints:
--  * all wells have the same length
--  * 1 <= grid.length <= 10^2
--  * 1 <= grid[:,1].length <= 10^2
--  * grid[i][j] -> 0 | 1
--  * 1 <= capacity <= 10
maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity =","maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity = ceiling (fromIntegral totalWater / fromIntegral capacity)
  where
    totalWater = sum (map sum grid)","
main :: IO ()
main = do
  let candidate = maxFill
  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error ""assertion failed""
  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error ""assertion failed""
  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_116,fon_Latn,hs,"--E na bló gbɔn mɔ̀:--Nú è na mɔ nú nùjlɛ́jlɛ́ ɖokpo ɔ ɔ́, è na ɖè nǔ lɛ ɖó nǔ e è nɔ ylɔ ɖɔ nǔ wǒzángbè é jí.--nùxwásá nú mɛ ɖò nùjlɛ́kpá binary tɔn yetɔn mɛ ɖò nùxwásá jí.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> sortArray [1,5,2,3,4]
--  [1,2,3,4,5]
--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]
--  [(-6),(-5),(-4),(-3),(-2)]
--  >>> sortArray [1,0,2,3,4]
--  [0,1,2,3,4]
sortArray :: [Int] -> [Int]
sortArray arr =","import Data.Bits (popCount)
import Data.List (sortBy)

sortArray :: [Int] -> [Int]
sortArray arr = sortBy compareOnesAndValues arr
  where
    compareOnesAndValues x y =
      let onesX = popCount x
          onesY = popCount y
      in if onesX == onesY
         then compare x y
         else compare onesX onesY","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error ""assertion failed""
  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error ""assertion failed""
  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error ""assertion failed""
  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  pure ()"
HumanEval_117,fon_Latn,hs,"--Kpɔ́ndéwú: --Akpàkpà: a sixu ɖɔ ɖɔ xò e è nɔ dó ɔ́ ɖó wlan kpo tɛn kpo kɛɖɛ.--Enyi wèmá ɔ́ ɖò mɛ̀ ɔ́, azɔ̀ ɔ́ ɖó na lɛ́ lɛ́ wá nùɖé lɛ́ ɖò mɛ̀ ǎ.--n xó e nɔ ɖò wuntun ɔ mɛ lɛ é, bɔ xógbe enɛ lɛ nɔ wá ɖò wuntun ɔ mɛ s. --azɔ̀ e nɔ́ lɛ́ lɛ́ sín xókwin lɛ́ɛ bǐ sín nùxwásá ɖò xɛ́n s mɛ é --¢ñá Ý÷åé êÜíåé êÜðïéï ðëáßóéï s êáé Ýíáò éäáíéêüò ÷ñþìáò n, Ý÷åé êáôáëçîåé íá ðñïóöÝñåé ¢ñá Ý÷åé êÜíåé êÜðïéï ðëáßóéï s êáé Ýíáò éäáíéêüò ÷ñþìáò n.--  >>> selectWords ""Mary had a little lamb"" 4
--  [""little""]
--  >>> selectWords ""Mary had a little lamb"" 3
--  [""Mary"",""lamb""]
--  >>> selectWords ""simple white space"" 2
--  []
--  >>> selectWords ""Hello world"" 4
--  [""world""]
--  >>> selectWords ""Uncle sam"" 3
--  [""Uncle""]
selectWords :: String -> Int -> [String]
selectWords s n =","selectWords :: String -> Int -> [String]
selectWords s n = filter (\word -> countConsonants word == n) (words s)
  where
    countConsonants = length . filter (`elem` consonants)
    consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ""","
main :: IO ()
main = do
  let candidate = selectWords
  if candidate ""Mary had a little lamb"" 4 == [""little""] then pure () else error ""assertion failed""
  if candidate ""Mary had a little lamb"" 3 == [""Mary"",""lamb""] then pure () else error ""assertion failed""
  if candidate ""simple white space"" 2 == [] then pure () else error ""assertion failed""
  if candidate ""Hello world"" 4 == [""world""] then pure () else error ""assertion failed""
  if candidate ""Uncle sam"" 3 == [""Uncle""] then pure () else error ""assertion failed""
  if candidate """" 4 == [] then pure () else error ""assertion failed""
  if candidate ""a b c d e f"" 1 == [""b"",""c"",""d"",""f""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_118,fon_Latn,hs,"--Kpɔ́n: --Mi sixu ɖɔ ɖɔ wuntun e è na é ɔ na ɖó wuntun e è nɔ zán dó wlan xókwin Eŋlisi tɔn lɛ é kɛɖɛ.--mɔ̀ xókwin ɖé ɖò xókwin ɔ mɛ bɔ é sɔgbe xá nǔ e ɖò jǐ é.--Akɔmasɔgbe ɖo nukɔnmɛ kpo gudo kpo ɔ e nɔ xa ǎ. Bo lɛ́ sɔ́ mɛ e ma nyí mɛ ǎ é.--kpɔnnú wè sín akpáxwé ɖisixwé xó ɔ tɔn (wùnnúmɛ e nɔ dó nǔ e ɖò xó ɔ mɛ é wu).--È na we xógbe ɖé. Azɔ̌ towe wɛ nyí ɖɔ a ni mɔ xógbe e nɔ nyí xo e ɖò we mɛ é.--  >>> getClosestVowel ""yogurt""
--  ""u""
--  >>> getClosestVowel ""FULL""
--  ""U""
--  >>> getClosestVowel ""quick""
--  """"
--  >>> getClosestVowel ""ab""
--  """"
getClosestVowel :: String -> String
getClosestVowel word =","getClosestVowel :: String -> String
getClosestVowel word = go (reverse word) False
  where
    vowels = ""aeiouAEIOU""
    go [] _ = """"
    go (x:xs) lastWasConsonant
      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False
      | x `notElem` vowels = go xs True
      | otherwise = go xs False","
main :: IO ()
main = do
  let candidate = getClosestVowel
  if candidate ""yogurt"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""full"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""easy"" == """" then pure () else error ""assertion failed""
  if candidate ""eAsy"" == """" then pure () else error ""assertion failed""
  if candidate ""ali"" == """" then pure () else error ""assertion failed""
  if candidate ""bad"" == ""a"" then pure () else error ""assertion failed""
  if candidate ""most"" == ""o"" then pure () else error ""assertion failed""
  if candidate ""ab"" == """" then pure () else error ""assertion failed""
  if candidate ""ba"" == """" then pure () else error ""assertion failed""
  if candidate ""quick"" == """" then pure () else error ""assertion failed""
  if candidate ""anime"" == ""i"" then pure () else error ""assertion failed""
  if candidate ""Asia"" == """" then pure () else error ""assertion failed""
  if candidate ""Above"" == ""o"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_119,fon_Latn,hs,"--Kpɔ́ndéwú: --E na lɛ́ lɛ́ lɛ́ yí gbè nú xógbe 'Ɛɛn' nú ali ɖé ɖò finɛ bo na bló nùjlɛdonǔwu ɖagbe ɖé ɔ, bo lɛ́ lɛ́ yí gbè nú xógbe 'Ée' nú é ma nyí mɔ̌ ǎ ɔ.--""()) "" nyí ǎ.--e nɔ ɖo jlɛjε. ε: xɔntɔn '(()))) ɔ nyɔ, hwenu e xɔntɔn --Xò S è nɔ ɖɔ é nyɔ́ nú è na sɔ́ xò S mɛ̀ lɛ́ɛ bǐ dó ganmɛ --e na bɔ è na mɔ xɛ ɖagbe ɖé é.--azɔ̌ towe wɛ nyí ɖɔ a na kpɔ́n ɖɔ è na kpéwú bo dó wlan xɛ wè lɛ dó wlan mɛ à jí--wema e ɖò mɛ é ɖokpo ɖokpo wɛ nɔ nyí "" ("") ""--◯ È na wèmá we we we, wèmá we lɛ bǐ ɔ́' è nɔ ylɔ́ ɖɔ open.--  >>> matchParens [""()("","")""]
--  ""Yes""
--  >>> matchParens ["")"","")""]
--  ""No""
matchParens :: [String] -> String
matchParens lst =","matchParens :: [String] -> String
matchParens [a, b] =
    if isValid (a ++ b) || isValid (b ++ a) then ""Yes"" else ""No""
  where
    isValid :: String -> Bool
    isValid = go 0
      where
        go 0 [] = True
        go _ [] = False
        go n (x:xs)
            | x == '('  = go (n + 1) xs
            | x == ')'  = n > 0 && go (n - 1) xs
    isValid _ = False","
main :: IO ()
main = do
  let candidate = matchParens
  if candidate [""()("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"","")""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()(())"",""())())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")())"",""(()()(""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(())))"",""(()())((""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""()"",""())""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()("",""()))()""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(((("",""((())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")(()"",""(()(""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")("","")(""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"",""(""] == ""Yes"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_120,fon_Latn,hs,"--Kpɔ́ndo 1: --e nɔ nyí k bɔ è nɔ mɔ nú nùjlɛ́kpo k ɖò arr mɛ é.--¢óå ðïõ Ý÷åé êÜíåé êÜðïéåò ðåñéðôþóåéò êáé êÜðïéåò ðåñéðôþóåéò, ðáñáêïëïõèÞóåé Ýíá êáôáóôñïöÝò ðåñéðôþóåéò.--  >>> maximum [(-3),(-4),5] 3
--  [(-4),(-3),5]
--  Example 2:
--  >>> maximum [4,(-4),4] 2
--  [4,4]
--  Example 3:
--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1
--  [2]
--  Note:
--  1. The length of the list will be in the range of [1, 1000].
--  2. The elements in the list will be in the range of [-1000, 1000].
--  3. 0 <= k <= len(arr)
maximum :: [Int] -> Int -> [Int]
maximum arr k =","maximum :: [Int] -> Int -> [Int]
maximum arr k = take k $ reverse $ sort arr","
main :: IO ()
main = do
  let candidate = maximum
  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error ""assertion failed""
  if candidate [4,(-4),4] 2 == [4,4] then pure () else error ""assertion failed""
  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error ""assertion failed""
  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error ""assertion failed""
  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error ""assertion failed""
  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error ""assertion failed""
  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error ""assertion failed""
  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error ""assertion failed""
  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error ""assertion failed""
  if candidate [(-10),10] 2 == [(-10),10] then pure () else error ""assertion failed""
  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_121,fon_Latn,hs,"--Kpɔ́ndéwú --│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> solution [5,8,7,1]
--  12
--  >>> solution [3,3,3,3,3]
--  9
--  >>> solution [30,13,24,321]
--  0
solution :: [Int] -> Int
solution lst =","solution :: [Int] -> Int
solution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","
main :: IO ()
main = do
  let candidate = solution
  if candidate [5,8,7,1] == 12 then pure () else error ""assertion failed""
  if candidate [3,3,3,3,3] == 9 then pure () else error ""assertion failed""
  if candidate [30,13,24,321] == 0 then pure () else error ""assertion failed""
  if candidate [5,9] == 5 then pure () else error ""assertion failed""
  if candidate [2,4,8] == 0 then pure () else error ""assertion failed""
  if candidate [30,13,23,32] == 23 then pure () else error ""assertion failed""
  if candidate [3,13,2,9] == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_122,fon_Latn,hs,"--Kpɔ́n: --nǔ e nɔ́ nyí nǔ e ɖò nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nɔ nyí nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nɔ nyí nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nɔ nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é.--¢óå ðïõ å÷åé êáíåíá óõãêåêñéìåíï ñïäéï ôùí áóèåíåéùí arr êáé êáíåíá áóèåíåéï k, return --  >>> addElements [111,21,3,4000,5,6,7,8,9] 4
--  24
--  Constraints:
--  1. 1 <= len(arr) <= 100
--  2. 1 <= k <= len(arr)
addElements :: [Int] -> Int -> Int
addElements arr k =","addElements :: [Int] -> Int -> Int
addElements arr k = sum $ filter (\x -> x >= -99 && x <= 99) $ take k arr","
main :: IO ()
main = do
  let candidate = addElements
  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error ""assertion failed""
  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error ""assertion failed""
  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error ""assertion failed""
  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error ""assertion failed""
  if candidate [1] 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_123,fon_Latn,hs,"--get_odd_collatz(5) lɛ́ lɛ́ kɔ́ [1, 5] # Akɔ́n e è nɔ ylɔ́ ɖɔ collatz nú 5 ɔ́ nyí [5, 16, 8, 4, 2, 1], enɛ ɔ́, nùxwléma e nyí kwín ɖokpo lɛ́ɛ wɛ nyí 1 kpo 5. --Ði kpɔ́ndéwú ɔ: --2. nùkɔn e è lɛ́ wá lɛ́ɛ ɖò jíjló jí.--1. Collatz(1) wɛ nyí [1]. --Akpádo:--xìnxín + 1 ɔ́' è nɔ ɖɔ ɖɔ nú n' ɖò nǔ ɖebǔ mɛ ɔ' nù lɛ́ɛ nɔ́ yì 1 hwebǐnu.--Nú akpáxwé e jɛ nukɔn é nyí nǔmaɖinǔ ɔ, akpáxwé e bɔ d'é jí ɔ nyí 3 azɔn ée jɛ nukɔn é tɔn.--nukɔnmɛ tɔn ɔ nɛ: enyi nukɔnmɛ tɔn ɔ nyí ganmɛ ɔ, nukɔnmɛ tɔn ɔ na nyí akpáxwé ɖokpo ɔ tɔn--e na nyi: bɛ ɔ kpodo xwɛ e nyi nuɖevi n lɛ kpo. Enɛ ɔ gudo ɔ, è na mɔ mɛ ɖokpo ɖokpo sín --Collatz sín nùxwlémɛ ɔ wɛ nyí nùxwlémɛ ɖò matimátikunmɛ mɛ bɔ é kan nǔɖevonu ɖé wu.--│Nɔ ɔ, e na lɛ́ sɔ́ nùɖé lɛ́ɛ ɖó kpɔ́n ɔ, e na lɛ́ sɔ́ nùɖé lɛ́ɛ ɖó kpɔ́n ɔ, é na lɛ́ sɔ́ nùɖé lɛ́ɛ ɖó kpɔ́n ɔ.--  >>> getOddCollatz 5
--  [1,5]
getOddCollatz :: Int -> [Int]
getOddCollatz n =","getOddCollatz :: Int -> [Int]
getOddCollatz n = sort . filter odd $ collatzSequence n
  where
    collatzSequence 1 = [1]
    collatzSequence x
      | even x    = x : collatzSequence (x `div` 2)
      | otherwise = x : collatzSequence (3 * x + 1)","
main :: IO ()
main = do
  let candidate = getOddCollatz
  if candidate 14 == [1,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 5 == [1,5] then pure () else error ""assertion failed""
  if candidate 12 == [1,3,5] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_124,fon_Latn,hs,"--4. Azǎn ɔ ɖó na ɖò wuntun elɔ mɛ: mm-dd-yyyy --3. sun lɛ na nɔ hwe na 1 bo na nɔ syɛn na 12 ǎ.--2. ě sɔ́ azǎn lɛ́ɛ ɖò azǎn 1 jí ǎ, alǒ hú azǎn 31 ɖò sun 1,3,5,7,8,10,12 lɛ́ɛ mɛ ǎ. ě sɔ́ azǎn lɛ́ɛ ɖò azǎn 1 jí ǎ, abǐ hú azǎn 30 ɖò sun 4,6,9,11 lɛ́ɛ mɛ ǎ. ě sɔ́ azǎn lɛ́ɛ ɖò azǎn 1 jí ǎ, abǐ hú azǎn 29 ɖò sun 2 mɛ ǎ.--1. Azǎn ɔ́ ɖò mɛ̀ ă.--Azǎn ɔ na nyí gbè ɖagbe nú è na bló sɔgbe xá nugbodòdó elɔ lɛ bǐ: --lɛ́ yí gbè nú True nú azǎn ɔ́ sɔgbe à ǎ ɔ́ False. --A ɖo na wlan azɔ na ɖe hun hwenu e è na lɛ é kpo --  >>> validDate ""03-11-2000""
--  True
--  >>> validDate ""15-01-2012""
--  False
--  >>> validDate ""04-0-2040""
--  False
--  >>> validDate ""06-04-2020""
--  True
--  >>> validDate ""06/04/2020""
--  False
validDate :: String -> Bool
validDate date =","import Text.Read (readMaybe)
import Data.List.Split (splitOn)

validDate :: String -> Bool
validDate date =
    case splitOn ""-"" date of
        [m, d, y] -> isValidMonthDayYear m d y
        _         -> False

isValidMonthDayYear :: String -> String -> String -> Bool
isValidMonthDayYear m d y =
    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of
        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day
        _ -> False

isValidMonth :: Int -> Bool
isValidMonth month = month >= 1 && month <= 12

isValidDay :: Int -> Int -> Bool
isValidDay month day
    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31
    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30
    | month == 2                           = day >= 1 && day <= 29
    | otherwise                            = False","
main :: IO ()
main = do
  let candidate = validDate
  if candidate ""03-11-2000"" == True then pure () else error ""assertion failed""
  if candidate ""15-01-2012"" == False then pure () else error ""assertion failed""
  if candidate ""04-0-2040"" == False then pure () else error ""assertion failed""
  if candidate ""06-04-2020"" == True then pure () else error ""assertion failed""
  if candidate ""01-01-2007"" == True then pure () else error ""assertion failed""
  if candidate ""03-32-2011"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""04-31-3000"" == False then pure () else error ""assertion failed""
  if candidate ""06-06-2005"" == True then pure () else error ""assertion failed""
  if candidate ""21-31-2000"" == False then pure () else error ""assertion failed""
  if candidate ""04-12-2003"" == True then pure () else error ""assertion failed""
  if candidate ""04122003"" == False then pure () else error ""assertion failed""
  if candidate ""20030412"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04-12"" == False then pure () else error ""assertion failed""
  if candidate ""04-2003"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_126,fon_Latn,hs,"--Kpɔ́ndéwú --nùmε, na lɛ́ kɔ̀n nǔvú.--enyi nǔ ɖokpo ɔ ɖò wema ɖokpo jí hú ɖokpo ɔ ɔ ɔ --◯ Nú è na wlan nùjlɛ lɛ sín nùjlɛ lɛ ɔ, è na lɛ́ ɖɔ nú è ɖè nùjlɛ lɛ ɖó alɔkpa ɖé jí à jí à jí ǎ.--  >>> isSorted [5]
--  True
--  >>> isSorted [1,2,3,4,5]
--  True
--  >>> isSorted [1,3,2,4,5]
--  False
--  >>> isSorted [1,2,3,4,5,6]
--  True
--  >>> isSorted [1,2,3,4,5,6,7]
--  True
--  >>> isSorted [1,3,2,4,5,6,7]
--  False
--  >>> isSorted [1,2,2,3,3,4]
--  True
--  >>> isSorted [1,2,2,2,3,4]
--  False
isSorted :: [Int] -> Bool
isSorted lst =","isSorted :: [Int] -> Bool
isSorted lst = go lst Nothing
  where
    go [] _ = True
    go [x] _ = True
    go (x:y:xs) prev
      | x > y = False
      | x == y && prev == Just x = False
      | otherwise = go (y:xs) (Just x)","
main :: IO ()
main = do
  let candidate = isSorted
  if candidate [5] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,7] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  if candidate [1] == True then pure () else error ""assertion failed""
  if candidate [3,2,1] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,2,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,3,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,3,3,4] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_127,fon_Latn,hs,"--[kpɔnú/kpɔnú] kpɔ́n: --Enyi tɛnkpɔn wè lɛ ma ɖò nǔ ɖokpo ɔ mɛ ǎ ɔ, lɛ́ kɔ nú ""ÉÒ"".--enyi é ma nyí mɔ̌ ǎ ɔ, lɛ́ kɔ nú ""ÉÒ"".--Nú wuntun ɔ sín hùn nyí nùjlɛ́jlɛ́ nukɔn nukɔntɔn ɔ, lɛ́ yí gbè nú ""YES"", --e nɔ nyí 1 é nyí nùjlɛ́kpo nukɔn nukɔntɔn ɖé ǎ.--Kpɔ́ndéwú ɔ, fí e tɛnkpɔn lɛ (1, 3), (2, 4) nɔ gbɔn é wɛ nyí (2, 3) --nùxwásá ɖé wɛ nyí númɛ̀ nùjlɛ́jlɛ́ tɔn.--azɔ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ̀ ɖɔ̀ we enɛ lɛ sín hùn e ɖekpo wɛ é nyí é--Ɖó nú tɛnkpɔn ɖokpo ɖokpo ɔ, è nɔ ɖi ɖɔ tɛnkpɔn ɔ sín bɛ́ wɛ nyí kpɛví alǒ cí fí e é wá yì é.--e nɔ lɛ́ ɖó fí e è jɛ nǔ lɛ é kpo fí e è wá fó é kpo.--Hweɖokpo e è na lɛ é na nyí mɛ̀, enɛ ɔ́ wɛ nyí ɖɔ hweɖokpo ɔ (bɛ́, fó) --fí e tɛnkpɔnmɛ ɖokpo ɖokpo nyí nùxwɛ́ e nyí nùjlɛ́kpɔnmɛ lɛ é sín wè é. Cɔ́nkpɔnmɛ ɔ, tɛnkpɔnmɛ = (bɛ́, fó) = (1, 2).--◯ È nɔ sɔ́ tɛn we dó mɛ,--  >>> intersection (1, 2) (2, 3)
--  ""NO""
--  >>> intersection ((-1), 1) (0, 4)
--  ""NO""
--  >>> intersection ((-3), (-1)) ((-5), 5)
--  ""YES""
intersection :: (Int, Int) -> (Int, Int) -> String
intersection interval1 interval2 =","intersection :: (Int, Int) -> (Int, Int) -> String
intersection (start1, end1) (start2, end2) = 
    if intersectionLength > 0 && isPrime intersectionLength
    then ""YES""
    else ""NO""
  where
    intersectionStart = max start1 start2
    intersectionEnd = min end1 end2
    intersectionLength = intersectionEnd - intersectionStart + 1
    
    isPrime :: Int -> Bool
    isPrime n
      | n <= 1 = False
      | n == 2 = True
      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","
main :: IO ()
main = do
  let candidate = intersection
  if candidate (1, 2) (2, 3) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-1), 1) (0, 4) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-3), (-1)) ((-5), 5) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-2), 2) ((-4), 0) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-11), 2) ((-1), (-1)) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (3, 5) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (1, 2) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-2), (-2)) ((-3), (-2)) == ""NO"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_128,fon_Latn,hs,"--Kpɔ́n: --Akpá: é na lɛ́ lɛ́ yí nǔɖé ɖó nùɖé wú ǎ.--nùxwásá ɖokpo ɖokpo ɖò nùjlɛ́jlɛ́ ɔ́ mɛ, è nɔ sɔ́ 1, -1 alǒ 0 dó xlɛ́ ɛ.--nùxwásá e nyí nùjlɛ́kpá lɛ́ɛ sín nùjlɛ́kpá e è sɔ́ nùjlɛ́kpá lɛ́ɛ bǐ sín nǔkún dó ná é --◯ È na nùxwlémɛ e è na lɛ́ yí ɔ́ nú we.--  >>> prodSigns [1,2,2,(-4)]
--  Just (9)
--  >>> prodSigns [0,1]
--  Just (0)
--  >>> prodSigns []
--  Just (Nothing)
prodSigns :: [Int] -> Maybe Int
prodSigns arr =","prodSigns :: [Int] -> Maybe Int
prodSigns [] = Nothing
prodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","
main :: IO ()
main = do
  let candidate = prodSigns
  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error ""assertion failed""
  if candidate [0,1] == Just (0) then pure () else error ""assertion failed""
  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error ""assertion failed""
  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,0] == Just (0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_129,fon_Latn,hs,"--Kpɔ́ndéwú: --E nɔ lɛ́ lɛ́ vɔ́ nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ ɖó tito jí ɖò nǔ e jí ali kpɛví ɔ gbɔn é jí.--E nɔ mɔ ɖɔ xósin ɔ nɔ nyí ɖokpo ɔ.--lst_A[j] = lst_B[j].--e nɔ nyi lst_A[i] < lst_B[i] bo bo na j (1 <= j < i) ɔ e nɔ nyi --hú lst_B, ɖò xó ɖevo mɛ ɔ, nùxwlé lɛ́ɛ ɖò nùxwlé lɛ́ɛ mɛ i (1 <= i <= k) --lst_A kpo lst_B kpo wɛ mǐ na ylɔ́ ɖɔ lst_A, lst_A ɔ́, xókwin tɔn lɛ́ɛ nɔ́ ɖɔ nǔ kpɛɖé.--ee è na bló nùjlɛdonǔwu nùjlɛdonǔwu lɛ tɔn ɖò nǔ e A kpo B kpo na yì é jí ɔ,--Ali e nyí A (e lín dó k é) ɔ è nɔ mɔ ɖɔ é vlɔ́ hú ali e nyí B (e lín dó k é) nú --A SƆ́ na bú ɖò fí e è nɔ mɔ nǔ ɖè é ǎ.--é nɔ ɖó na nyí nǔ e è sixu ɖè yeɖée sín mɛ é ǎ).--Mi nywɛ ɖɔ ali e nyi kpodo ayi kpo kε ɔ na ɖɔ ɖɔ mi na yi bo kpɔ́n bunɔ k (e ma nyí ɖɔ mi na kpɔ́n bunɔ --azɔn ɔ.--é ɖɔ ɖɔ, a sixu yì nùvò e nɔ ɖó xósusu ɖokpo ɔ xá towe lɛ é mɛ--bo ɖo tɛn ɖokpo ɖokpo mɛ ɔ a sixu yì tɛn e nɔ sɛkpɔ mɛ é ɖokpo ɖokpo mɛ,--A na mɔ ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpo--e nɔ tɔ́n azɔn ɖokpo ɖò xɔ lɛ́ɛ mɛ ɖò nùxwásá ɔ́ mɛ.--azɔmε ɖokpo ɖokpo ɖo nuvi ɔ mε ɔ, e nɔ hɛn jijɔ ɖokpo ɖokpo ɖo nuvi ɔ mε.--∆ɛ́n nùxwlé ɖé e ɖó xósín N kpo gǒjímɛ N kpo (N >= 2) bɔ nùxwlé e nyí k é ɖé ɔ, --  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3
--  [1,2,1]
--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1
--  [1]
minpath :: [[Int]] -> Int -> [Int]
minpath grid k =","import Data.List (sort, sortBy)
import Data.Ord (comparing)
import Control.Monad (guard)

minpath :: [[Int]] -> Int -> [Int]
minpath grid k = head $ sort paths
  where
    n = length grid
    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]
    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
      where
        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n
    value (r, c) = grid !! r !! c
    paths = do
      start <- cells
      findPaths k [start]
    findPaths 1 path = return $ map value path
    findPaths l path@(current:_) = do
      next <- neighbors current
      findPaths (l-1) (next : path)","
main :: IO ()
main = do
  let candidate = minpath
  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error ""assertion failed""
  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error ""assertion failed""
  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error ""assertion failed""
  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error ""assertion failed""
  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error ""assertion failed""
  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error ""assertion failed""
  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_130,fon_Latn,hs,"--Kpɔ́ndéwú: --nùxwásá n + 1 nukɔntɔn lɛ́ɛ ɖò tito Tribonacci tɔn mɛ.--è na na mi nùxwléma e nyí nùɖé ǎ é n, mi ɖó na lɛ́ lɛ́ wá nú nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma e nyí nùxwléma é.--= 2 + 3 + 3 = 8 --3ì3í3÷í3 ôîðìû = 3ì3í3÷í3 ôîðìû + 3ì3í3÷í3 ôîðìû + 3ì3í3÷í3 ôîðìû (4)--tri(4) = 3 --tri(2) = 1 + (2 / 2) = 2 --Ði kpɔ́ndéwú ɔ: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), enyi n nyí nùxwlé. --tri ((n) = 1 + n / 2, enyi n nyí mɛ wè.--tri(1) = 3 --Tribonacci sín nùxwlé lɛ́ɛ nɔ́ nyí:--Amɔ̌, nǔ e mɛ lɛ ma tuùn ǎ ɔ wɛ nyí tito Tribonacci tɔn.--Mɛ bǐ tuùn nǔ e è nɔ ylɔ ɖɔ Fibonacci sín nùjlɛ́jlɛ́ é, mɛxwématɔ́n lɛ́ɛ kplɔ́n nǔ dó nǔ enɛ jí ɖò xwè kanweko ɔ mɛ.--  >>> tri 3
--  [1,3,2,8]
tri :: Int -> [Int]
tri n =","tri :: Int -> [Int]
tri n = map tribonacci [0..n]
  where
    -- Define the recursive function to calculate the tribonacci value for a given n
    tribonacci :: Int -> Int
    tribonacci 0 = 1
    tribonacci 1 = 3
    tribonacci x
      | even x    = 1 + x `div` 2
      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","
main :: IO ()
main = do
  let candidate = tri
  if candidate 3 == [1,3,2,8] then pure () else error ""assertion failed""
  if candidate 4 == [1,3,2,8,3] then pure () else error ""assertion failed""
  if candidate 5 == [1,3,2,8,3,15] then pure () else error ""assertion failed""
  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error ""assertion failed""
  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error ""assertion failed""
  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error ""assertion failed""
  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error ""assertion failed""
  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error ""assertion failed""
  if candidate 0 == [1] then pure () else error ""assertion failed""
  if candidate 1 == [1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_131,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --Zɔ́n 0 nú wèmá lɛ́ɛ bǐ nyí ganmɛ. --¢óå ìéá ðñïóùðéêÞ èÝóç n, ðáñáêïëïõèÞóôå ôï ðñïóùðéêü ôùí ðåñéóóüôåñùí.--  >>> digits 1
--  1
--  >>> digits 4
--  0
--  >>> digits 235
--  15
digits :: Int -> Int
digits n =","digits :: Int -> Int
digits n
  | null oddDigits = 0
  | otherwise      = product oddDigits
  where
    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","
main :: IO ()
main = do
  let candidate = digits
  if candidate 5 == 5 then pure () else error ""assertion failed""
  if candidate 54 == 5 then pure () else error ""assertion failed""
  if candidate 120 == 1 then pure () else error ""assertion failed""
  if candidate 5014 == 5 then pure () else error ""assertion failed""
  if candidate 98765 == 315 then pure () else error ""assertion failed""
  if candidate 5576543 == 2625 then pure () else error ""assertion failed""
  if candidate 2468 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_132,fon_Latn,hs,"--e ɖo atɛ ɖokpo ɖo nukun tɔn ɔ mɛ ɔ e nɔ ɖo yeɖée mɛ.--azɔ̀ ɔ́ ɖó na lɛ́ kɔ̀ True nú é ɖò cóbɔ́ è na lɛ́ ɖó wuntun e ɖò wuntun lɛ́ɛ mɛ é --│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> isNested ""[[]]""
--  True
--  >>> isNested ""[]]]]]]][[[[[]""
--  False
--  >>> isNested ""[][]""
--  False
--  >>> isNested ""[]""
--  False
--  >>> isNested ""[[][]]""
--  True
--  >>> isNested ""[[]][[""
--  True
isNested :: String -> Bool
isNested string =","isNested :: String -> Bool
isNested string = go string 0 False
  where
    go [] _ nested = nested
    go (x:xs) depth nested
      | x == '['  = go xs (depth + 1) (nested || depth >= 1)
      | x == ']' && depth > 0 = go xs (depth - 1) nested
      | otherwise = go xs depth nested","
main :: IO ()
main = do
  let candidate = isNested
  if candidate ""[[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]][[[[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[][]"" == False then pure () else error ""assertion failed""
  if candidate ""[]"" == False then pure () else error ""assertion failed""
  if candidate ""[[[[]]]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]]]]]"" == False then pure () else error ""assertion failed""
  if candidate ""[][][[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[]]"" == False then pure () else error ""assertion failed""
  if candidate ""[[]][["" == True then pure () else error ""assertion failed""
  if candidate ""[[][]]"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""[[[[[[[["" == False then pure () else error ""assertion failed""
  if candidate ""]]]]]]]]"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_133,fon_Latn,hs,"--Kpɔ́ndéwú: --blŏ wŭ ɖò nùjlɛ́n ɔ mɛ̀ nú nùɖé lɛ́ɛ bǐ jɛ̀ nú nùɖé lɛ́ɛ bǐ jɛ̀ nú nùɖé lɛ́ɛ bǐ jɛ̀ nú nùɖé lɛ́ɛ bǐ jɛ̀ nú nùɖé lɛ́ɛ bǐ jɛ̀ nú nùɖé lɛ́ɛ bǐ jɛ̀ nú nùɖé lɛ́ɛ bǐ--A na lɛ́ yí nùjlɛ́kpo e è sɔ́ dó wexwɛ ɔ́ sín kwɛ́ɛ sín nùjlɛ́kpo dó lɛ́ɛ é sín xwi, --◯ È na nùɖé lɛ we.--  >>> lst [1.0,2.0,3.0]
--  14
--  >>> lst [1.0,4.0,9.0]
--  98
--  >>> lst [1.0,3.0,5.0,7.0]
--  84
--  >>> lst [1.4,4.2,0.0]
--  29
--  >>> lst [-2.4,1.0,1.0]
--  6
sumSquares :: [Float] -> Int
sumSquares lst =","import Data.List (foldl')
import Prelude hiding (sum)

sumSquares :: [Float] -> Int
sumSquares lst = foldl' (\acc x -> acc + ceiling x ^ 2) 0 lst","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error ""assertion failed""
  if candidate [1.4,4.2,0.0] == 29 then pure () else error ""assertion failed""
  if candidate [-2.4,1.0,1.0] == 6 then pure () else error ""assertion failed""
  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error ""assertion failed""
  if candidate [10000.0,10000.0] == 200000000 then pure () else error ""assertion failed""
  if candidate [-1.4,4.6,6.3] == 75 then pure () else error ""assertion failed""
  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error ""assertion failed""
  if candidate [0.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0] == 1 then pure () else error ""assertion failed""
  if candidate [-1.0,1.0,0.0] == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_134,fon_Latn,hs,"--Kpɔ́ndéwú: --Akpá: ""gbe"" ɔ wuntun lɛ sín ahwan wɛ bɔ è nɔ ɖe tɛn ɖó vo nú ye.--xó ɔ́ sín akpáxwé ɖé, bɔ nǔ e ma nyí xó ɔ́ ǎ ɔ́ nyí nǔvú.--wèmá è è wèmá è è wèmá è è wèmá è è wèmá è è wèmá è è wèmá è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è--ɔ̀n nùɖé bɔ̀ é na lɛ́ yí gbè nú True nú wèmá gudo tɔn ɔ́ --  >>> checkIfLastCharIsALetter ""apple pie""
--  False
--  >>> checkIfLastCharIsALetter ""apple pi e""
--  True
--  >>> checkIfLastCharIsALetter ""apple pi e ""
--  False
--  >>> checkIfLastCharIsALetter """"
--  False
checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt =","checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt = 
    let trimmed = reverse . dropWhile (== ' ') $ reverse txt
    in case trimmed of
        [] -> False
        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","
main :: IO ()
main = do
  let candidate = checkIfLastCharIsALetter
  if candidate ""apple"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e"" == True then pure () else error ""assertion failed""
  if candidate ""eeeee"" == False then pure () else error ""assertion failed""
  if candidate ""A"" == True then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie "" == False then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie 1"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""eeeee e "" == False then pure () else error ""assertion failed""
  if candidate ""apple pie"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e "" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_135,fon_Latn,hs,"--Kpɔ́ndéwú: --nùjlɛdonǔwu lɛ́ɛ ɖò wè wè wè.--nùɖé tíìn ǎ ɔ́, é ná lɛ́ kɔ́n -1.--e nyi nuvεn e ɖo nukɔn tɔn tlolo ɔ a nyi nuvεn e nyi nukɔn tɔn tlolo ɔ a nyi nuvεn e ɖo nukɔn tɔn tlolo ɔ a.--│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> canArrange [1,2,4,3,5]
--  3
--  >>> canArrange [1,2,3]
--  (-1)
canArrange :: [Int] -> Int
canArrange arr =","canArrange :: [Int] -> Int
canArrange arr = go arr (-1) 0
  where
    go [] maxIdx _ = maxIdx
    go [_] maxIdx _ = maxIdx
    go (x:y:xs) maxIdx idx
      | x >= y    = go (y:xs) idx (idx + 1)
      | otherwise = go (y:xs) maxIdx (idx + 1)","
main :: IO ()
main = do
  let candidate = canArrange
  if candidate [1,2,4,3,5] == 3 then pure () else error ""assertion failed""
  if candidate [1,2,4,5] == (-1) then pure () else error ""assertion failed""
  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error ""assertion failed""
  if candidate [4,8,5,7,3] == 4 then pure () else error ""assertion failed""
  if candidate [] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_136,fon_Latn,hs,"--Kpɔ́ndéwú: --Nú nùɖé ma ɖò nùɖé jí ǎ ɔ, è na lɛ́ sɔ́ nùɖé dó mɔ nùɖé ǎ.--e nɔ ɖɔ nùxixa ɖagbe lɛ ɖò nùxwlé lɛ mɛ é.--nùxwléma ayihun lɛ́ɛ bǐ ɔ́' b' wɛ nyí kpɛví ɔ́--ɔ̀ nùɖé bɔ̀ é ná lɛ́ yí nùɖé lɛ́ɛ dó nùɖé lɛ́ɛ mɛ̀, bɔ̀ é ná lɛ́ yí nùɖé lɛ́ɛ dó nùɖé lɛ́ɛ mɛ̀.--  >>> largestSmallestIntegers [2,4,1,3,5,7]
--  (Nothing, 1)
--  >>> largestSmallestIntegers []
--  (Nothing, Nothing)
--  >>> largestSmallestIntegers [0]
--  (Nothing, Nothing)
largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst =","largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst = (largestNegative, smallestPositive)
  where
    negatives = filter (< 0) lst
    positives = filter (> 0) lst
    largestNegative = if null negatives then Nothing else Just (maximum negatives)
    smallestPositive = if null positives then Nothing else Just (minimum positives)","
main :: IO ()
main = do
  let candidate = largestSmallestIntegers
  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error ""assertion failed""
  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error ""assertion failed""
  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error ""assertion failed""
  if candidate [] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [0] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_138,fon_Latn,hs,"--Kpɔ́ndéwú --│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> isEqualToSumEven 4
--  False
--  >>> isEqualToSumEven 6
--  False
--  >>> isEqualToSumEven 8
--  True
isEqualToSumEven :: Int -> Bool
isEqualToSumEven n =","isEqualToSumEven :: Int -> Bool
isEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","
main :: IO ()
main = do
  let candidate = isEqualToSumEven
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == True then pure () else error ""assertion failed""
  if candidate 11 == False then pure () else error ""assertion failed""
  if candidate 12 == True then pure () else error ""assertion failed""
  if candidate 13 == False then pure () else error ""assertion failed""
  if candidate 16 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_139,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --fí e n > 0 ɖè é--brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! --ɛ́n Brésil tɔn ɔ́' è nɔ ylɔ̀ ɖɔ: --  >>> specialFactorial 4
--  288
--  The function will receive an integer as input and should return the special
--  factorial of this integer.
specialFactorial :: Int -> Int
specialFactorial n =","specialFactorial :: Int -> Int
specialFactorial n = product [factorial x | x <- [1..n]]
  where
    factorial 0 = 1
    factorial k = k * factorial (k - 1)","
main :: IO ()
main = do
  let candidate = specialFactorial
  if candidate 4 == 288 then pure () else error ""assertion failed""
  if candidate 5 == 34560 then pure () else error ""assertion failed""
  if candidate 7 == 125411328000 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_140,fon_Latn,hs,"--bo sɔ́ -  dó ɖyɔ́ tɛn e ɖò lɛ́ɛ bǐ--bo enyi xwɛ ɖokpo ɖó tɛnvi wè e nɔ ɖò jijimɛ lɛ é hú ɔ, --◯ Zě wuntun wlan tɔn ɖé ɔ, nɔ tɛnkpɔn bo nɔ ɖè fí e ɖò vo lɛ é bǐ ɖó wuntun e è nɔ ɖè ɖò do lɛ é jí,--  >>> fixSpaces "" Example""
--  ""Example""
--  >>> fixSpaces "" Example 1""
--  ""Example_1""
--  >>> fixSpaces "" Example 2""
--  ""_Example_2""
--  >>> fixSpaces "" Example 3""
--  ""_Example-3""
fixSpaces :: String -> String
fixSpaces text =","fixSpaces :: String -> String
fixSpaces text = concatMap replaceSpaces (groupSpaces text)
  where
    groupSpaces :: String -> [String]
    groupSpaces [] = []
    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest

    replaceSpaces :: String -> String
    replaceSpaces spaces@(x:_)
      | x == ' ' && length spaces > 2 = ""-""
      | x == ' ' = replicate (length spaces) '_'
      | otherwise = spaces","
main :: IO ()
main = do
  let candidate = fixSpaces
  if candidate ""Example"" == ""Example"" then pure () else error ""assertion failed""
  if candidate ""Mudasir Hanif "" == ""Mudasir_Hanif_"" then pure () else error ""assertion failed""
  if candidate ""Yellow Yellow  Dirty  Fellow"" == ""Yellow_Yellow__Dirty__Fellow"" then pure () else error ""assertion failed""
  if candidate ""Exa   mple"" == ""Exa-mple"" then pure () else error ""assertion failed""
  if candidate ""   Exa 1 2 2 mple"" == ""-Exa_1_2_2_mple"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_141,fon_Latn,hs,"--Kpɔ́ndéwú: --- Hwe e ɖò dot ɔ gudo é ɖó na nyí ɖokpo ɖò elɔ lɛ mɛ: ['txt', 'exe', 'dll'] --wèmá-wlámá Latɛ́n tɔn lɛ́ɛ ('a'-'z' kpo 'A'-'Z') --- Wema e ɖò nukɔn nú dot ɔ ɖó na nyí nǔtí ǎ, bɔ é ka na bɛ́ ɖò wèmá  tɔn jí.--- Hɔnkpɔn ɔ sín nyikɔ ɔ ɖ'akpá ɖokpo ɖokpo mɛ.'--- Ðèñóíîê äîëæåí èìåòü íå áîëüøå 3 çíà÷åê (""0"" - ""9""). --e nɔ kpé: --Akɔɖε ɔ sín nyikɔ nɔ nyí ɖagbe enyi bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na.--'Ɛɛn' nú nyikɔ ɔ sɔgbe, bo na lɛ́ lɛ́ yí gbè nú 'Ée' nú é ma sɔgbe ǎ.--◯ Wà nùɖé bɔ é nɔ yí wuntun e nɔ ɖè nyikɔ wema ɖé tɔn xlɛ́ é bo nɔ lɛ́ yí wuntun ɔ--  >>> fileNameCheck ""example.txt""
--  ""Yes""
--  >>> fileNameCheck ""1example.dll""
--  ""No""
fileNameCheck :: String -> String
fileNameCheck file_name =","import Data.Char (isDigit, isLetter)

fileNameCheck :: String -> String
fileNameCheck file_name 
  | countDots /= 1 = ""No""
  | length digits > 3 = ""No""
  | null beforeDot || not (isLetter (head beforeDot)) = ""No""
  | afterDot `notElem` validExtensions = ""No""
  | otherwise = ""Yes""
  where 
    (beforeDot, afterDot) = span (/= '.') file_name
    countDots = length $ filter (== '.') file_name
    digits = filter isDigit file_name
    validExtensions = [""txt"", ""exe"", ""dll""]
    afterDot = if null dotAndAfter then """" else tail dotAndAfter
    dotAndAfter = dropWhile (/= '.') file_name","
main :: IO ()
main = do
  let candidate = fileNameCheck
  if candidate ""example.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1example.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s1sdf3.asd"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""K.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""MY16FILE3.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""His12FILE94.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_Y.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""?aREYA.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""/this_is_valid.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.wow"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txtexe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""#this2_i4s_5valid.ten"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""@this1_is6_valid.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_12valid.6exe4.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""all.exe.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_No.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""Is3youfault.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""no_one#knows.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1I563_Yes3.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_Yes3.txtt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final..txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final132"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_f4indsartal132."" == ""No"" then pure () else error ""assertion failed""
  if candidate "".txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s."" == ""No"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_142,fon_Latn,hs,"--Kpɔ́ndéwú: --ɖyɔ nùjlɛdonǔwu e ɖò nùjlɛdonǔwu ɔ mɛ lɛ é e sín nùjlɛdonǔwu ma nyí 3 alǒ 4 sín nǔxixa ǎ é ɔ, azɔ̀ ɔ na lɛ́ lɛ́ kɔ nú nùjlɛdonǔwu lɛ́ɛ bǐ.--nùxíɖókpɔ́ 3 tɔn ɔ́' é ná sɔ́ nùxíɖókpɔ́ ɔ́ dó ɖó wuntun nú nùxíɖókpɔ́ ɔ́' nú wuntun tɔn nyí nùxíɖókpɔ́ 4 tɔn é nyí nùxíɖókpɔ́ 3 tɔn ǎ ɔ́' azɔ̀ ɔ́ ná sɔ́ ǎ--azɔ̀ élɔ́ ná yí nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ lɛ́ɛ tɔn. nú nùjlɛ́jlɛ́ e ɖò nùjlɛ́jlɛ́ ɔ́ mɛ lɛ́ɛ bǐ ɔ́, azɔ̀ ɔ́ na sɔ́ nùjlɛ́jlɛ́ ɔ́ sín alɔgwé ɖó wè jí, nú nùjlɛ́jlɛ́ tɔn nyí a --"" --  >>> lst
--  [1,2,3]
--  >>> lst
--  []
--  >>> lst
--  [(-1),(-5),2,(-1),(-5)]
sumSquares :: [Int] -> Int
sumSquares lst =","sumSquares :: [Int] -> Int
sumSquares lst = sum $ zipWith transform [0..] lst
  where
    transform idx x
      | idx `mod` 3 == 0 = x * x
      | idx `mod` 4 == 0 = x * x * x
      | otherwise        = x","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1,2,3] == 6 then pure () else error ""assertion failed""
  if candidate [1,4,9] == 14 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error ""assertion failed""
  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error ""assertion failed""
  if candidate [0] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error ""assertion failed""
  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error ""assertion failed""
  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error ""assertion failed""
  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error ""assertion failed""
  pure ()"
HumanEval_143,fon_Latn,hs,"--Kpɔ́ndo 1: --xókwin lɛ́ɛ ɖò wuntun yɔyɔ́ ɔ́ mɛ́ ɖó ná cí xókwin nukɔntɔn ɔ́ ɖɔhun.--e sín hùn nyí nùxwásún nukɔn nukɔntɔn lɛ é, --bo na lɛ́ lɛ́ lɛ́ wá xwɛ e mɛ xókwin e ɖò xwɛ ɔ́ mɛ é ɖè é, --xókwin ɖé lɛ ɖò nuɖe ɔ mɛ bɔ nuɖe ɔ nɔ zɔ́n nú xókwin ɖé lɛ, --È na wlan nùjlɛdonǔwu e nɔte nú xógbe ɖé é nú we,--  >>> wordsInSentence ""This is a test""
--  ""is""
--  Example 2:
--  >>> wordsInSentence ""lets go for swimming""
--  ""go for""
--  Constraints:
--  * 1 <= len(sentence) <= 100
--  * sentence contains only letters
wordsInSentence :: String -> String
wordsInSentence sentence =","import Data.List (intercalate)

wordsInSentence :: String -> String
wordsInSentence sentence = intercalate "" "" $ filter (isPrime . length) (words sentence)

isPrime :: Int -> Bool
isPrime n | n < 2     = False
          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = wordsInSentence
  if candidate ""This is a test"" == ""is"" then pure () else error ""assertion failed""
  if candidate ""lets go for swimming"" == ""go for"" then pure () else error ""assertion failed""
  if candidate ""there is no place available here"" == ""there is no place"" then pure () else error ""assertion failed""
  if candidate ""Hi I am Hussein"" == ""Hi am Hussein"" then pure () else error ""assertion failed""
  if candidate ""go for it"" == ""go for it"" then pure () else error ""assertion failed""
  if candidate ""here"" == """" then pure () else error ""assertion failed""
  if candidate ""here is"" == ""is"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_144,fon_Latn,hs,"--A sixu ɖɔ ɖɔ x, kpo n kpo ɔ nuvò e jɛxa lɛ wɛ bo ma ɖó nuvɔ́ dó nuvò mɛ ǎ.--ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé--x kpo n kpo we lɛ ɔ, ye nyi aklunɔzoli nuɖe bo nɔ nyi aklunɔzoli elɔ:--x * n. Function ɔ na lɛ́ kɔ́n True nú x * n nɔ́ nyí nùjlɛ́kpá ɖé bo nɔ́ nyí False --azɔ towe wɛ nyí ɖɔ a na bló azɔ̀ e na bló bɔ xógbe ɔ na bɔ́n ɔ́--  >>> simplify ""1/5"" ""5/1""
--  True
--  >>> simplify ""1/6"" ""2/1""
--  False
--  >>> simplify ""7/10"" ""10/2""
--  False
simplify :: String -> String -> Bool
simplify x n =","import Data.Ratio (denominator, numerator, (%))

simplify :: String -> String -> Bool
simplify x n =
  let (xNum, xDen) = toFraction x
      (nNum, nDen) = toFraction n
      result = (xNum * nNum) % (xDen * nDen)
  in denominator result == 1

toFraction :: String -> (Integer, Integer)
toFraction s =
  let (numStr, _:denStr) = break (=='/') s
  in (read numStr, read denStr)","
main :: IO ()
main = do
  let candidate = simplify
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/6"" ""2/1"" == False then pure () else error ""assertion failed""
  if candidate ""5/1"" ""3/1"" == True then pure () else error ""assertion failed""
  if candidate ""7/10"" ""10/2"" == False then pure () else error ""assertion failed""
  if candidate ""2/10"" ""50/10"" == True then pure () else error ""assertion failed""
  if candidate ""7/2"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""11/6"" ""6/1"" == True then pure () else error ""assertion failed""
  if candidate ""2/3"" ""5/2"" == False then pure () else error ""assertion failed""
  if candidate ""5/2"" ""3/5"" == False then pure () else error ""assertion failed""
  if candidate ""2/4"" ""8/4"" == True then pure () else error ""assertion failed""
  if candidate ""2/4"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""1/5"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_145,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --ɖè ye ɖó nùjlɛ́jlɛ́ yetɔn ɖò nùjlɛ́jlɛ́ tò ɔ́ tɔn mɛ é jí.--Akpá: enyi nǔ e è wlan dó nǔ lɛ jí lɛ é sín nùxwásá cí ɖokpo ɔ ɔ ɔ, --ɖo kpɔnkpɔn wɛ ɖò nùxwásá yetɔn lɛ sín nùxwásá jí.--                        --  >>> orderByPoints [1,11,(-1),(-11),(-12)]
--  [(-1),(-11),1,(-12),11]
--  >>> orderByPoints []
--  []
orderByPoints :: [Int] -> [Int]
orderByPoints nums =","import Data.List (sortBy)
import Data.Function (on)

orderByPoints :: [Int] -> [Int]
orderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums
  where
    sumOfDigits :: Int -> Int
    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)
    
    indexedNums :: [(Int, Int)]
    indexedNums = zip (map sumOfDigits nums) nums","
main :: IO ()
main = do
  let candidate = orderByPoints
  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error ""assertion failed""
  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error ""assertion failed""
  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_146,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --xɔgbe nukɔntɔn kpo gudo tɔn kpo ɔ nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ--nùxwásá nǔ e ɖò nùjlɛ́jlɛ́ ɔ́ mɛ lɛ́ɛ tɔn hú 10 bɔ we lɛ́ɛ bǐ wɛ nyí --◯ Wlǎn nùɖé e nɔ yí nùjlɛ́kpo lɛ sín nùɖé lɛ dó mɛ bo nɔ lɛ́ yí é--  >>> specialfilter [15,(-73),14,(-15)]
--  1
--  >>> specialfilter [33,(-2),(-3),45,21,109]
--  2
specialfilter :: [Int] -> Int
specialfilter nums =","specialfilter :: [Int] -> Int
specialfilter nums = length $ filter isSpecial nums
  where
    isSpecial n = n > 10 && isOddFirstAndLast (abs n)

    isOddFirstAndLast :: Int -> Bool
    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit
      where
        xStr = show x
        firstDigit = head xStr
        lastDigit = last xStr

    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""","
main :: IO ()
main = do
  let candidate = specialfilter
  if candidate [5,(-2),1,(-5)] == 0 then pure () else error ""assertion failed""
  if candidate [15,(-73),14,(-15)] == 1 then pure () else error ""assertion failed""
  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error ""assertion failed""
  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error ""assertion failed""
  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_147,fon_Latn,hs,"--Kpɔ́ndéwú:--bɔ a[i] + a[j] + a[k] nyí nùɖé bɔ è nɔ jlɛ́ dó 3 jí.--Zɔ́n nùxwásá atɔnvlɔ́ɖó (a[i], a[j], a[k]) nú a fí e i < j < k, --nú mɛ ɖokpo ɖokpo i (1 ≤ i ≤ n) ɔ, akwɛ́ a[i] = i * i - i + 1 tɔn. --̆ E na na mi nùxwɛ́ e nyí nùxwɛ́ ɖagbe é n. Mi ɖó na bló nùxwɛ́ e nyí nùxwɛ́ e nyí nùxwɛ́ ɖagbe é a tɔn é.--  >>> getMaxTriples 5
--  1
--  Explanation: 
--  a = [1, 3, 7, 13, 21]
--  The only valid triple is (1, 7, 13).
getMaxTriples :: Int -> Int
getMaxTriples n =","getMaxTriples :: Int -> Int
getMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]
  where
    a = [i * i - i + 1 | i <- [1..n]]","
main :: IO ()
main = do
  let candidate = getMaxTriples
  if candidate 5 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 4 then pure () else error ""assertion failed""
  if candidate 10 == 36 then pure () else error ""assertion failed""
  if candidate 100 == 53361 then pure () else error ""assertion failed""
  pure ()"
HumanEval_149,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --A sixu ɖɔ ɖɔ xógbe lɛ bǐ na ɖó ganxixo ɖokpo ɔ.--azɔ̀ ɔ́ ɖó ná lɛ́ kɔ̀n nùjlɛ́jlɛ́ xwɛ́ ɖò tito jí.--Nú xókwin wè lɛ́ɛ ɖò mɔ̌ ɖokpó ɔ́, ɖè nùwlanwlan lɛ́ɛ ɖò wlanví lɛ́ɛ mɛ.--e na lɛ́ kɔ́n nù lɛ́ɛ ɔ́, è na sɔ́ yě ɖó alɔkpa e mɛ è ɖè é.--E na w'azɔ̌ ɔ́ ná nɔ́ jɛ̀ jí ɖò xókwin ɖokpo ɖokpo sín línlín mɛ, bɔ a na lɛ́ --é sixu ɖ'azɔ̌ dó è.--nùjlɛ́jlɛ́ ɔ́ nɔ́ nyí nùjlɛ́jlɛ́ xɛ́ɛ tɔn lɛ́ɛ tɔn tɛ́nwe, é nɔ́ nyí nùjlɛ́jlɛ́ nú nùjlɛ́jlɛ́ lɛ́ɛ tɔn tɛ́nwe ǎ.--bo na lɛ́ lɛ́ wá mɔ nǔ e è wlan lɛ́ɛ ɔ́ ɖò tito jí, --e nɔ ɖe xɛ e nɔ ɖó ganxixo e nɔ nyí ganxixo é lɛ sín mɛ, --◯ Wlǎn azɔ̀ e nɔ yí gbè nú nùjlɛ́n xójlawema tɔn lɛ é dó ɖó nùjlɛ́n lɛ é,--  >>> listSort [""aa"",""a"",""aaa""]
--  [""aa""]
--  >>> listSort [""ab"",""a"",""aaa"",""cd""]
--  [""ab"",""cd""]
sortedListSum :: [String] -> [String]
sortedListSum lst =","sortedListSum :: [String] -> [String]
sortedListSum lst = sortBy compareStrings (filter evenLength lst)
  where
    evenLength s = even (length s)
    compareStrings s1 s2
      | length s1 == length s2 = compare s1 s2
      | otherwise = compare (length s1) (length s2)","
main :: IO ()
main = do
  let candidate = sortedListSum
  if candidate [""aa"",""a"",""aaa""] == [""aa""] then pure () else error ""assertion failed""
  if candidate [""school"",""AI"",""asdf"",""b""] == [""AI"",""asdf"",""school""] then pure () else error ""assertion failed""
  if candidate [""d"",""b"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""d"",""dcba"",""abcd"",""a""] == [""abcd"",""dcba""] then pure () else error ""assertion failed""
  if candidate [""AI"",""ai"",""au""] == [""AI"",""ai"",""au""] then pure () else error ""assertion failed""
  if candidate [""a"",""b"",""b"",""c"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""aaaa"",""bbbb"",""dd"",""cc""] == [""cc"",""dd"",""aaaa"",""bbbb""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_150,fon_Latn,hs,"--Kpɔ́ndéwú: --e na lɛ́ lɛ́ yí nùɖé nú y.--¢ñá ìéá ìéêñÞ ëýóç ðïõ èá ðñÝðåé íá áðïêôÞóåé ôçí ôéìÞ ôïõ x áí ôï n åßíáé --  >>> xOrY 7 34 12
--  34
--  >>> xOrY 15 8 5
--  5
xOrY :: Int -> Int -> Int -> Int
xOrY n x y =","xOrY :: Int -> Int -> Int -> Int
xOrY n x y = if isPrime n then x else y

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = xOrY
  if candidate 7 34 12 == 34 then pure () else error ""assertion failed""
  if candidate 15 8 5 == 5 then pure () else error ""assertion failed""
  if candidate 3 33 5212 == 33 then pure () else error ""assertion failed""
  if candidate 1259 3 52 == 3 then pure () else error ""assertion failed""
  if candidate 7919 (-1) 12 == (-1) then pure () else error ""assertion failed""
  if candidate 3609 1245 583 == 583 then pure () else error ""assertion failed""
  if candidate 91 56 129 == 129 then pure () else error ""assertion failed""
  if candidate 6 34 1234 == 1234 then pure () else error ""assertion failed""
  if candidate 1 2 0 == 0 then pure () else error ""assertion failed""
  if candidate 2 2 0 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_151,fon_Latn,hs,"--nùxwásá e nyí nùɖé ǎ lɛ́ɛ ɔ́, mi ma sɔ́ dó nùxwásá e nyí nǔmaɖinǔ lɛ́ɛ jí ó.--◯ Nú è na wlan nùjlɛ lɛ sín nùjlɛ lɛ ɔ, wlan nùjlɛ lɛ sín kwɛ́ɛ sín nǔ e è na lɛ é.--  >>> doubleTheDifference [1,3,2,0]
--  10
--  >>> doubleTheDifference [(-1),(-2),0]
--  0
--  >>> doubleTheDifference [9,(-2)]
--  81
--  >>> doubleTheDifference [0]
--  0
--  If the input list is empty, return 0.
doubleTheDifference :: [Float] -> Int
doubleTheDifference lst =","doubleTheDifference :: [Float] -> Int
doubleTheDifference lst = 
    sum [x * x | x <- map round lst, x > 0, odd x]","
main :: IO ()
main = do
  let candidate = doubleTheDifference
  if candidate [.0] == 0 then pure () else error ""assertion failed""
  if candidate [5.0,4.0] == 25 then pure () else error ""assertion failed""
  if candidate [0.1,0.2,0.3] == 0 then pure () else error ""assertion failed""
  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error ""assertion failed""
  if candidate [0.2,3.0,5.0] == 34 then pure () else error ""assertion failed""
  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error ""assertion failed""
  pure ()"
HumanEval_152,fon_Latn,hs,"--kpɔ́ndéwú: --nùxwɛ ɔ nyí 0 bɔ enyi é nyí ǎ ɔ, nùxwɛ ɔ wɛ nyí vogbingbɔn e ɖò mɛ̀ ɖò nùxwɛ ɔ kpo nǔ e è mɔ é kpo tɛntin é.--lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́ lɛ́--È na we nǔ e è na mɔ ɖò nǔ lɛ mɛ é kpo nǔ e è na ɖɔ é kpo e na nyí ɖokpo ɔ, bɔ nǔ e è na mɔ ɖò nǔ lɛ mɛ é bǐ na sɔgbe.--azɔ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ mɛ ɔ ɖɔ nǔ e é mɔ ɖò nùɖé lɛ mɛ é sɔgbe à jí.--e jɛxa ɖɔ è na wlan bo jlɛ́.--nǔ e jɛ ɔ́ bǐ wɛ è wá tuùn.--Un ɖi ɖɔ mi bǐ wɛ flín nǔ cí nú mɛ hwenu e nǔ e è ko nɔ te kpɔ́n sín tɛgbɛ é ɖé sín vivɔnu wá é.--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]
--  [0,0,0,0,3,3]
--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]
--  [4,4,1,0,0,6]
compare :: [Int] -> [Int] -> [Int]
compare game guess =","compare :: [Int] -> [Int] -> [Int]
compare game guess = zipWith (\g s -> abs (g - s)) game guess","
main :: IO ()
main = do
  let candidate = compare
  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error ""assertion failed""
  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error ""assertion failed""
  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error ""assertion failed""
  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_153,fon_Latn,hs,"--Kpɔ́n: --(kpikpa tɔn nyi -1).--lɛ́ɛ ná lɛ́ wá 'Slices.SErviNGSliCes' ɖó 'SErviNGSliCes' wɛ nyí nukɔ́nkpó e ɖó gǎn hú bǐ é --nùjlɛdonǔwu: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ɔ́, a ɖó ná --¢óå ðùò ôï ""Slices"" åßíáé ç êáôçãïñßá êáé ï ðáßêôçò --sɔ́ ée ɖò nukɔnmɛ ɖò nùwlanwlan ɔ mɛ é.--Enyi è na lɛ́ sɔ́ wè alǒ hú mɔ̌ ɖó hlɔnhlɔn ɖokpo ɔ ɔ́, a ɖó na lɛ́ sɔ́ we ɖó--wèmá: ClassName.StrongestExtensionName. --A na mɔ nukɔnyiyi e syɛn hú bǐ é bo na lɛ́ yí wuntun ɖé dó nùjlɛdonǔwu elɔ mɛ.--ɖo nukɔnyiyi ɔ sín nyikɔ mɛ ɔ, kpodo CAP - SM kpo wɛ è nɔ ɖe hlɔnhlɔn ɔ xlɛ́.--wèmá ɖò extension sín nyikɔ mɛ, bo sɔ́ SM dó ɖó wèmá kpɛví lɛ́ɛ tɔn --hlɔ̌nhlɔ́n nǔ lɛ́ɛ tɔn nyí nǔ elɔ lɛ́ɛ: nú CAP nyí númɛ̀ ɔ́ --Akɔ́n lɛ́ɛ ɔ́, è na zán dó dó azɔ̌ lɛ́ɛ jí nú azɔ̌ lɛ́ɛ.--│A na na we azɔmɛ ɖokpo sín nyikɔ (akɔnnɔ) kpo wema e è na lɛ é kpo.--  >>> strongestExtension ""my_class"" [""AA"",""Be"",""CC""]
--  ""my_class.AA""
strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions =","strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions = class_name ++ ""."" ++ strongestExt
  where
    calculateStrength :: String -> Int
    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)
    
    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)
    
    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)
    maxStrength ext1 ext2
      | snd ext1 > snd ext2 = ext1
      | otherwise           = ext2","
main :: IO ()
main = do
  let candidate = strongestExtension
  if candidate ""Watashi"" [""tEN"",""niNE"",""eIGHt8OKe""] == ""Watashi.eIGHt8OKe"" then pure () else error ""assertion failed""
  if candidate ""Boku123"" [""nani"",""NazeDa"",""YEs.WeCaNe"",""32145tggg""] == ""Boku123.YEs.WeCaNe"" then pure () else error ""assertion failed""
  if candidate ""__YESIMHERE"" [""t"",""eMptY"",""nothing"",""zeR00"",""NuLl__"",""123NoooneB321""] == ""__YESIMHERE.NuLl__"" then pure () else error ""assertion failed""
  if candidate ""K"" [""Ta"",""TAR"",""t234An"",""cosSo""] == ""K.TAR"" then pure () else error ""assertion failed""
  if candidate ""__HAHA"" [""Tab"",""123"",""781345"",""-_-""] == ""__HAHA.123"" then pure () else error ""assertion failed""
  if candidate ""YameRore"" [""HhAas"",""okIWILL123"",""WorkOut"",""Fails"",""-_-""] == ""YameRore.okIWILL123"" then pure () else error ""assertion failed""
  if candidate ""finNNalLLly"" [""Die"",""NowW"",""Wow"",""WoW""] == ""finNNalLLly.WoW"" then pure () else error ""assertion failed""
  if candidate ""_"" [""Bb"",""91245""] == ""_.Bb"" then pure () else error ""assertion failed""
  if candidate ""Sp"" [""671235"",""Bb""] == ""Sp.671235"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_154,fon_Latn,hs,"--̆ È na we xókwin we. A na lɛ́ yí gbè nú true enyi xókwin wegɔ ɔ alǒ xwɛɖuxwɛ tɔn lɛ́ɛ ɖě nyí xwɛɖuxwɛ ɖò xókwin nukɔntɔn ɔ mɛ ɔ.--  >>> cycpatternCheck ""abcd"" ""abd""
--  False
--  >>> cycpatternCheck ""hello"" ""ell""
--  True
--  >>> cycpatternCheck ""whassup"" ""psus""
--  False
--  >>> cycpatternCheck ""abab"" ""baa""
--  True
--  >>> cycpatternCheck ""efef"" ""eeff""
--  False
--  >>> cycpatternCheck ""himenss"" ""simen""
--  True
cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b =","cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b = any (`isInfixOf` a) rotations
  where
    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","
main :: IO ()
main = do
  let candidate = cycpatternCheck
  if candidate ""xyzw"" ""xyw"" == False then pure () else error ""assertion failed""
  if candidate ""yello"" ""ell"" == True then pure () else error ""assertion failed""
  if candidate ""whattup"" ""ptut"" == False then pure () else error ""assertion failed""
  if candidate ""efef"" ""fee"" == True then pure () else error ""assertion failed""
  if candidate ""abab"" ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""winemtt"" ""tinem"" == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_155,fon_Latn,hs,"--Kpɔ́n: --│Nɛ ɔ, e na lɛ́ na nùjlɛ́kpikpa e nɔ ɖó nùjlɛ́kpikpa e nɔ nyí ganxixo é kpo ée nɔ nyí ganxixo ǎ é kpo é.--  >>> evenOddCount (-12)
--  (1, 1)
--  >>> evenOddCount 123
--  (1, 2)
evenOddCount :: Int -> (Int, Int)
evenOddCount num =","evenOddCount :: Int -> (Int, Int)
evenOddCount num = (length evens, length odds)
  where
    digits = map (read . (:[])) . show . abs $ num
    evens = filter even digits
    odds  = filter odd digits","
main :: IO ()
main = do
  let candidate = evenOddCount
  if candidate 7 == (0, 1) then pure () else error ""assertion failed""
  if candidate (-78) == (1, 1) then pure () else error ""assertion failed""
  if candidate 3452 == (2, 2) then pure () else error ""assertion failed""
  if candidate 346211 == (3, 3) then pure () else error ""assertion failed""
  if candidate (-345821) == (3, 3) then pure () else error ""assertion failed""
  if candidate (-2) == (1, 0) then pure () else error ""assertion failed""
  if candidate (-45347) == (2, 3) then pure () else error ""assertion failed""
  if candidate 0 == (1, 0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_156,fon_Latn,hs,"--Kpɔ́ndéwú: --Xwɛsín: 1 <= num <= 1000 --bo sɔ́ wlan e dó wlan xókwín kpɛví ɖé lɛ mɛ é. --¢ñá ðñïóöÝñåé ìéá ðñïóùðéêÞ áóôõíïìßá, ðáñáêïëïõèþ ôçí ðåñßðôùóç ôçò óáí ðëáóôéêü, ¢ñá ðñïóöÝñåé ìéá áóôõíïìßá--  >>> intToMiniRoman 19
--  ""xix""
--  >>> intToMiniRoman 152
--  ""clii""
--  >>> intToMiniRoman 426
--  ""cdxxvi""
intToMiniRoman :: Int -> String
intToMiniRoman number =","intToMiniRoman :: Int -> String
intToMiniRoman number = concatMap (replicateSymbol number) romanNumerals
  where
    romanNumerals = [(1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
                     (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
                     (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""), (1, ""i"")]
    
    replicateSymbol :: Int -> (Int, String) -> String
    replicateSymbol n (value, symbol)
      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)
      | otherwise = """"","
main :: IO ()
main = do
  let candidate = intToMiniRoman
  if candidate 19 == ""xix"" then pure () else error ""assertion failed""
  if candidate 152 == ""clii"" then pure () else error ""assertion failed""
  if candidate 251 == ""ccli"" then pure () else error ""assertion failed""
  if candidate 426 == ""cdxxvi"" then pure () else error ""assertion failed""
  if candidate 500 == ""d"" then pure () else error ""assertion failed""
  if candidate 1 == ""i"" then pure () else error ""assertion failed""
  if candidate 4 == ""iv"" then pure () else error ""assertion failed""
  if candidate 43 == ""xliii"" then pure () else error ""assertion failed""
  if candidate 90 == ""xc"" then pure () else error ""assertion failed""
  if candidate 94 == ""xciv"" then pure () else error ""assertion failed""
  if candidate 532 == ""dxxxii"" then pure () else error ""assertion failed""
  if candidate 900 == ""cm"" then pure () else error ""assertion failed""
  if candidate 994 == ""cmxciv"" then pure () else error ""assertion failed""
  if candidate 1000 == ""m"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_157,fon_Latn,hs,"--Kpɔ́n: --90 degre. --Hwexwetɔn e nɔ ɖó xwɛ ɖagbe é wɛ nyí ɖɔ wexwetɔn e mɛ xwɛ ɖokpo nyí xwɛ ɖagbe é alǒ xwɛ e nyí xwɛ ɖagbe é--ali lɛ nɔ bló atɔnviɖe e nɔ ɖó ganxixo ɖagbe ɖagbe é, bo ma nyí mɔ̌ ǎ ɔ, nǔ e nyí nugbǒ é wɛ.--¢óôáæåé True áí ïé 3 ¢óôáæïõí ôá 3 ðÜíù--  >>> rightAngleTriangle 3 4 5
--  True
--  >>> rightAngleTriangle 1 2 3
--  False
rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c =","rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c = 
    let [x, y, z] = sort [a, b, c]
    in x^2 + y^2 == z^2
    where sort = Data.List.sort","
main :: IO ()
main = do
  let candidate = rightAngleTriangle
  if candidate 3 4 5 == True then pure () else error ""assertion failed""
  if candidate 1 2 3 == False then pure () else error ""assertion failed""
  if candidate 10 6 8 == True then pure () else error ""assertion failed""
  if candidate 2 2 2 == False then pure () else error ""assertion failed""
  if candidate 7 24 25 == True then pure () else error ""assertion failed""
  if candidate 10 5 7 == False then pure () else error ""assertion failed""
  if candidate 5 12 13 == True then pure () else error ""assertion failed""
  if candidate 15 8 17 == True then pure () else error ""assertion failed""
  if candidate 48 55 73 == True then pure () else error ""assertion failed""
  if candidate 1 1 1 == False then pure () else error ""assertion failed""
  if candidate 2 2 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_158,fon_Latn,hs,"--xɛ lɛ, lɛ́ kɔ̀ mɛ e jɛ nukɔn ɖò xókwin-kpàkpàkpà mɛ é.--nú wuntun ɖokpo ɖokpo ɔ ɔ. enyi wuntun ɖokpo ɖokpo ɔ ɖó wuntun ɖokpo ɖokpo ɔ ɔ ɔ--Xógbe vovo wɛ ɖò nùwlanwlan ɔ mɛ. Hwlɛ xógbe e ɖò nùxwásá ɔ mɛ é --◯ Wlan azɔ̀ e nɔ yí gbè nú wuntun lɛ é.--  >>> findMax [""name"",""of"",""string""]
--  ""string""
--  >>> findMax [""name"",""enam"",""game""]
--  ""enam""
--  >>> findMax [""aaaaaaa"",""bb"",""cc""]
--  ""aaaaaaa""
findMax :: [String] -> String
findMax words =","import Data.List (nub, sort)

findMax :: [String] -> String
findMax words = 
    head . sort . map snd . filter (\(n, _) -> n == maxUnique) $ wordUniquePairs
  where
    wordUniquePairs = [(length . nub $ word, word) | word <- words]
    maxUnique = maximum $ map fst wordUniquePairs","
main :: IO ()
main = do
  let candidate = findMax
  if candidate [""name"",""of"",""string""] == ""string"" then pure () else error ""assertion failed""
  if candidate [""name"",""enam"",""game""] == ""enam"" then pure () else error ""assertion failed""
  if candidate [""aaaaaaa"",""bb"",""cc""] == ""aaaaaaa"" then pure () else error ""assertion failed""
  if candidate [""abc"",""cba""] == ""abc"" then pure () else error ""assertion failed""
  if candidate [""play"",""this"",""game"",""of"",""footbott""] == ""footbott"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""gonna"",""rock""] == ""gonna"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""a"",""mad"",""nation""] == ""nation"" then pure () else error ""assertion failed""
  if candidate [""this"",""is"",""a"",""prrk""] == ""this"" then pure () else error ""assertion failed""
  if candidate [""b""] == ""b"" then pure () else error ""assertion failed""
  if candidate [""play"",""play"",""play""] == ""play"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_159,fon_Latn,hs,"--Kpɔ́n: --enyi atín e kpo é ma kpé ǎ ɔ, a na ɖu atín e kpo é kpo é bǐ, amɔ̌ xovɛ́ na lɛ́ sin we.--nùxwlé e ɖò tɔ̀n ɖò nùɖuɖu towe lɛ́ɛ gudo é ] --mi na lɛ́ kɔ́n nùjlɛ́jlɛ́ [ nùjlɛ́jlɛ́ kpò e mi ɖu ɖò nùɖuɖu mitɔn lɛ́ɛ gudo é, --Amɔ̌, din ɔ, a ɖó na ɖu atínkwín gègě bo na dó ɖu nǔ bǐ.--A nyí xɛvi xovɛ́ sin é ɖé, bo ko ɖu atínkwín e è nɔ ylɔ́ ɖɔ ""carrot"" é ɖé,--  >>> eat 5 6 10
--  [11,4]
--  >>> eat 4 8 9
--  [12,1]
--  >>> eat 1 10 10
--  [11,0]
--  >>> eat 2 11 5
--  [7,0]
--  Variables:
--  @number : integer
--  the number of carrots that you have eaten.
--  @need : integer
--  the number of carrots that you need to eat.
--  @remaining : integer
--  the number of remaining carrots thet exist in stock
--  Constrain:
--  * 0 <= number <= 1000
--  * 0 <= need <= 1000
--  * 0 <= remaining <= 1000
--  Have fun :)
eat :: Int -> Int -> Int -> [Int]
eat number need remaining =","eat :: Int -> Int -> Int -> [Int]
eat number need remaining
  | remaining >= need = [number + need, remaining - need]
  | otherwise = [number + remaining, 0]","
main :: IO ()
main = do
  let candidate = eat
  if candidate 5 6 10 == [11,4] then pure () else error ""assertion failed""
  if candidate 4 8 9 == [12,1] then pure () else error ""assertion failed""
  if candidate 1 10 10 == [11,0] then pure () else error ""assertion failed""
  if candidate 2 11 5 == [7,0] then pure () else error ""assertion failed""
  if candidate 4 5 7 == [9,2] then pure () else error ""assertion failed""
  if candidate 4 5 1 == [5,0] then pure () else error ""assertion failed""
  pure ()"
HumanEval_160,fon_Latn,hs,"--azɔwatɔ́ lɛ́ɛ sín wuntun ɖó azɔwatɔ́ ɖokpó ɖò jí, bɔ azɔwatɔ́ lɛ́ɛ sín wuntun ɖó azɔwatɔ́ we ɖò jí.--operand ɔ wɛ nyí nùjlɛ́kpá nùjlɛ́kpá e ma nyí nùɖé ǎ lɛ́ɛ tɔn.--Akɔkpá ɔ́ sín wuntun e è nɔ zán dó wlan nǔ lɛ é ɔ́ sín wuntun ɔ́ sín wuntun e è nɔ zán dó wlan nǔ lɛ é ɔ́ sín wuntun ɔ́ sín wuntun ɔ́.--Akpádo:--=> nǔ e è mɔ é = 9 --nǔ e è mɔ é = 2 + 3 * 4 - 5 --nùxwlé = [2, 3, 4, 5] --azɔwatɔ́ ɔ['+', '*', '-'] --Kpɔ́n: --Nǔɖeji (**) --Xò ɖò xò jí ɔ́ ( //) --Ðɔ nǔ kpɔ́n (*) --Ðèñóíîê ( - ) --Ðɔ nǔ lɛ dó (+) --Nǔ e è nɔ wà dó aljɛbu jí lɛ é: --e nɔ lɛ́ vɔ́ xógbe ɔ́ sín nǔ e è na zán dó mɔ xógbe ɔ́ é.--wema wegɔ ɔ ɔ wɛ nyí nùxwlémɛ lɛ tɔn. zán wema we e è na lɛ é dó gbá algebric ɔ--¢ñá Ý÷åé 2 êáôáóôñïöÝò, êáé Ýíáò óôñáôüò.doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand =","doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand = evaluate operand operator
  where
    evaluate [x] [] = x
    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops
      where
        result = applyOperation op x y

    applyOperation ""+"" a b = a + b
    applyOperation ""-"" a b = a - b
    applyOperation ""*"" a b = a * b
    applyOperation ""//"" a b = a `div` b
    applyOperation ""**"" a b = a ^ b
    applyOperation _ _ _ = error ""Unsupported operation""","
main :: IO ()
main = do
  let candidate = doAlgebra
  if candidate [""**"",""*"",""+""] [2,3,4,5] == 37 then pure () else error ""assertion failed""
  if candidate [""+"",""*"",""-""] [2,3,4,5] == 9 then pure () else error ""assertion failed""
  if candidate [""//"",""*""] [7,3,4] == 8 then pure () else error ""assertion failed""
  pure ()"
HumanEval_161,fon_Latn,hs,"--Kpɔ́ndéwú --azɔ̀ ɔ́ ɖó ná lɛ́ kɔ̀n wèmá e è mɔ é.--Enyi wuntun ɔ ma ɖó wuntun ɖé ǎ ɔ, mi na lɛ́ kɔ́n wuntun ɔ.--é ma nyí mɔ̌ ǎ ɔ́, mi hɛn ɔ́, mi ná nɔ lě e mi ɖe gbɔn é.--enyi s[i] nyí wèmá ɔ, lɛ́ kɔ sín fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó é jí--È na wèmá nú we.--  >>> solve ""1234""
--  ""4321""
--  >>> solve ""ab""
--  ""AB""
--  >>> solve ""#a@C""
--  ""#A@c""
solve :: String -> String
solve s =","solve :: String -> String
solve s
  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s
  | otherwise = reverse s
  where
    toggleCase c
      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char
      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char
      | otherwise = c","
main :: IO ()
main = do
  let candidate = solve
  if candidate ""AsDf"" == ""aSdF"" then pure () else error ""assertion failed""
  if candidate ""1234"" == ""4321"" then pure () else error ""assertion failed""
  if candidate ""ab"" == ""AB"" then pure () else error ""assertion failed""
  if candidate ""#a@C"" == ""#A@c"" then pure () else error ""assertion failed""
  if candidate ""#AsdfW^45"" == ""#aSDFw^45"" then pure () else error ""assertion failed""
  if candidate ""#6@2"" == ""2@6#"" then pure () else error ""assertion failed""
  if candidate ""#$a^D"" == ""#$A^d"" then pure () else error ""assertion failed""
  if candidate ""#ccc"" == ""#CCC"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_162,fon_Latn,hs,"--Enyi 'text' nyí xwɛ̀ nùɖé ǎ ɔ, é na lɛ́ kɔ́ nǔɖé ǎ.--̆ E ná wèmá 'text' ɔ́, lɛ́ yí wèmá e ɖ'emɛ é sín hash md5 ɔ́.--  >>> stringToMd5 ""Hello world""
--  Just (""3e25960a79dbc69b674cd4ec67a72c62"")
stringToMd5 :: String -> Maybe String
stringToMd5 text =","import qualified Data.ByteString.Char8 as C
import qualified Data.Digest.Pure.MD5 as MD5

stringToMd5 :: String -> Maybe String
stringToMd5 text
  | null text = Nothing
  | otherwise = Just $ show $ MD5.md5 $ C.pack text","
main :: IO ()
main = do
  let candidate = stringToMd5
  if candidate ""Hello world"" == Just (""3e25960a79dbc69b674cd4ec67a72c62"") then pure () else error ""assertion failed""
  if candidate """" == Just (Nothing) then pure () else error ""assertion failed""
  if candidate ""A B C"" == Just (""0ef78513b0cb8cef12743f5aeb35f888"") then pure () else error ""assertion failed""
  if candidate ""password"" == Just (""5f4dcc3b5aa765d61d8327deb882cf99"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_163,fon_Latn,hs,"--Ði kpɔ́ndéwú ɔ: --bo b, ɖò nǔ jɛ jí wɛ.--¢óå 2 êáôÜëëçëá êáëÜ ó÷Ýäéá a êáé b, ðáñáêáëþ ôá ðáñáðÜíù ó÷Ýäéá ìåôáîý a --  >>> generateIntegers 2 8
--  [2,4,6,8]
--  >>> generateIntegers 8 2
--  [2,4,6,8]
--  >>> generateIntegers 10 14
--  []
generateIntegers :: Int -> Int -> [Int]
generateIntegers a b =","generateIntegers :: Int -> Int -> [Int]
generateIntegers a b = filter even [min a b .. max a b]","
main :: IO ()
main = do
  let candidate = generateIntegers
  if candidate 2 10 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 10 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 132 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 17 89 == [] then pure () else error ""assertion failed""
  pure ()"
