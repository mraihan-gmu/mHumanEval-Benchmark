[{"task_id":"HumanEval_0","nl":"fon_Latn","pl":"rb","prompt":"kpò è è.Kpɔ́n ɖɔ nùɖé lɛ́ɛ ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ e è ná lɛ́ ná é mɛ bɔ nùjlɛ́jlɛ́ wè lɛ́ ɖò sɛ́dó nú yeɖée hú # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# true\ndef has_close_elements(numbers, threshold)\n","canonical_solution":"def has_close_elements(numbers, threshold)\n  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n  end\nend\n"},{"task_id":"HumanEval_1","nl":"fon_Latn","pl":"rb","prompt":"Mi ma sɔ́ dó nùkwín e mi nɔ zán dó wlan nǔ lɛ é mɛ ó.Ahwan e ɖò yeɖée mɛ lɛ é nɔ ɖò jlɛ̌ jí (ahwan e ɖò yeɖée mɛ lɛ é ɖokpo ɖokpo nɔ ɖò yeɖée mɛ ganji) bɔ ye nɔ nɔ yeɖée mɛ ǎ.ɖè mɛ énɛ́ lɛ́ɛ ɖó kpɔ́ bó ná dó xwɛ̌ nú yě.Nǔ e è nɔ sɔ́ dó azɔ̀ élɔ́ mɛ ɔ́ wɛ nyí xɛ́lɛ́ e nɔ ɖó nùxwléma kpò ɖò mɛ é.# >>> separate_paren_groups.call(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\ndef separate_paren_groups(paren_string)\n","canonical_solution":"def separate_paren_groups(paren_string)\n  # Remove spaces from the string\n  paren_string = paren_string.gsub(\" \", \"\")\n  \n  result = []\n  current_group = \"\"\n  balance = 0\n\n  paren_string.each_char do |char|\n    current_group += char\n    balance += 1 if char == '('\n    balance -= 1 if char == ')'\n\n    if balance == 0 && !current_group.empty?\n      result << current_group\n      current_group = \"\"\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_separate_paren_groups\n    candidate = method(:separate_paren_groups)\n    assert_equal([\"(()())\", \"((()))\", \"()\", \"((())()())\"], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([\"()\", \"(())\", \"((()))\", \"(((())))\"], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([\"(()(())((())))\"], candidate.call(\"(()(())((())))\"))\n    assert_equal([\"()\", \"(())\", \"(()())\"], candidate.call(\"( ) (( )) (( )( ))\"))\n  end\nend\n"},{"task_id":"HumanEval_2","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nú númɛ̀ ɔ́ sín akpáxwé wǒgɔ́dó ɔ́.(kpá e nɔ lɛ́ kpo ɖò mɛ é nɔ ɖò kpɛví hú 1).kpò nú nùxwásún (nùnxwásún ɖaxó e hú nùxwásún e è ná é) kpo nǔxwásún wǒzángbè tɔn lɛ kpo Nú è na sɔ́ nùjlɛ́n e nɔ́ ɖò nǔ jlɔ́ wɛ é ɖé dó nùjlɛ́n e nɔ́ ɖò nǔ jlɔ́ wɛ é ɖé jí ɔ, è na hɛn ɔ́ è na lɛ́ má ɛ dó nǔ  jí.# >>> truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n","canonical_solution":"def truncate_number(number)\n  number - number.to_i\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n  end\nend\n"},{"task_id":"HumanEval_3","nl":"fon_Latn","pl":"rb","prompt":"ɖo finɛ ɔ azɔwan ɔ na lɛ́ kɔ́n true. bo ma nyí mɔ̌ ǎ ɔ é na lɛ́ kɔ́n false.azɔ̀n núwùn tɔn. azɔ̀n towe wɛ nyí ɖɔ a na mɔ̀ nú azɔ̀n núwùn tɔn jɛ̀ núwùn jí ɖò fí ɖebǔ ɔ́, bɔ a na lɛ́ mɔ ɖɔ é jɛ̀ núwùn jí.È na mi nǔ e mi na sɔ́ dó akwɛ́ jí lɛ́ɛ kpo ée mi na ɖe sín akwɛ́ jí lɛ́ɛ kpo ɖò nǔ e nɔ jɛ nukɔn nú nǔ e è nɔ ylɔ ɖɔ  é jí.# >>> below_zero.call([1, 2, 3])\n# false\n# >>> below_zero.call([1, 2, -4, 5])\n# true\ndef below_zero(operations)\n","canonical_solution":"def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_zero\n    candidate = method(:below_zero)\n    assert_equal(false, candidate.call([]))\n    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))\n    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))\n    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))\n    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))\n    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))\n  end\nend\n"},{"task_id":"HumanEval_4","nl":"fon_Latn","pl":"rb","prompt":"MAD = mɛ̀. x - x_méan.nǔɖevi kpo ayijε kpo (nɔntin ɔ ɖo ninɔmɛ elɔ mɛ): Nǔ e nɔ nyí mɛɖesɔhwe mɛtɔn ɔ wɛ nyí mɛɖesɔhwe mɛtɔn e ɖò mɛ we lɛ tɛntin é.e ɖò nǔ e è nɔ mɔ ɖò nǔ e è nɔ mɔ ɖò nǔ e è nɔ mɔ ɖò nǔ e è nɔ mɔ é mɛ é mɛ é.Ɖó nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́# >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n# 1.0\ndef mean_absolute_deviation(numbers)\n","canonical_solution":"def mean_absolute_deviation(numbers)\n  mean = numbers.sum.to_f \/ numbers.size\n  deviations = numbers.map { |num| (num - mean).abs }\n  deviations.sum \/ numbers.size\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0, 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"},{"task_id":"HumanEval_5","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nùjlɛ́kpo 'delimeter' ɖò nǔ e ɖò wè ɖò ali ɖokpo ɔ jí lɛ é bǐ tɛntin nú nùjlɛ́kpo è è nɔ sɔ́ dó mɔ nǔ é ∀numbers' # >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n","canonical_solution":"def intersperse(numbers, delimeter)\n  return numbers if numbers.empty?\n  result = []\n  numbers.each_with_index do |num, index|\n    result << num\n    result << delimeter unless index == numbers.size - 1\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"},{"task_id":"HumanEval_6","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ (() (()) ɖó xɛ̀ wè ɖò gbɛmɛ bɔ ((())) ɖó atɔn. Ɖo kplékplé ɖokpo ɖokpo ɔ mɛ ɔ, ɖè tɛn e mɛ nùɖé lɛ́ɛ nɔ ɖò mɛ é ɖó wuntun lɛ́ɛ mɛ.Nǔ e è nɔ sɔ́ dó azɔ̀ enɛ mɛ é wɛ nyí wuntun e nɔ ɖè tò gègě ɖó nú nùxwléma e è nɔ ɖó wuntun lɛ é bɔ è nɔ klán gbɔn tɛnkpɔn jí é.# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n","canonical_solution":"def parse_nested_parens(paren_string)\n  paren_string.split.map do |group|\n    max_depth = current_depth = 0\n    group.chars.each do |char|\n      if char == '('\n        current_depth += 1\n        max_depth = [max_depth, current_depth].max\n      elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"))\n  end\nend\n"},{"task_id":"HumanEval_7","nl":"fon_Latn","pl":"rb","prompt":"Filter input array of strings for ones that contain given substring # >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\ndef filter_by_substring(strings, substring)\n","canonical_solution":"def filter_by_substring(strings, substring)\n  strings.select { |string| string.include?(substring) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"))\n  end\nend\n"},{"task_id":"HumanEval_8","nl":"fon_Latn","pl":"rb","prompt":"Xwédo e ma ɖó nǔ ɖé ǎ é ɖó na nyí 0 bɔ nǔ e ma ɖó nǔ ɖé ǎ é ɖó na nyí 1.nú nùxwlé lɛ́ɛ sín nùxwlé ɖé ɔ́, ná lɛ́ yí nùxwlé ɖé sín nùxwlé e nyí nùxwlé lɛ́ɛ bǐ sín nùxwlé kpódó nùxwlé lɛ́ɛ bǐ sín nùxwlé kpó é.# >>> sum_product.call([])\n# [0, 1]\n# >>> sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n","canonical_solution":"def sum_product(numbers)\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0], candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"},{"task_id":"HumanEval_9","nl":"fon_Latn","pl":"rb","prompt":"ɖo hunhun ɔ mɛ.Ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ e è ná lɛ́ ná é ɖé mɛ ɔ, è na bló nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ e è na mɔ ɖò hweɖénu é tɔn.# >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n","canonical_solution":"def rolling_max(numbers)\n  max_so_far = numbers.first\n  numbers.map do |num|\n    max_so_far = [max_so_far, num].max\n  end\nend\n\n# Example usage:\n# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"},{"task_id":"HumanEval_10","nl":"fon_Latn","pl":"rb","prompt":"- Zɔ́n wèmá è nɔ́ nyí wèmá-kpò-kpò ɔ́ sín nukɔnmɛ e nɔ́ jɛ nukɔn nú wèmá-kpò-kpò e nɔ nyí wèmá-kpò-kpò é.- Xà postfix mɛxo tɔn e nyí palindrome é ɖò xɛ ɔ mɛ.Alɔgorithm linlin ɔ nyi mε: Mi kpɔ́n palindrome kpɛví e bɛ́ ɖò wuntun e è na é mɛ é.# >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n","canonical_solution":"def make_palindrome(string)\n  return string if string.empty?\n\n  def is_palindrome?(s)\n    s == s.reverse\n  end\n\n  (0...string.length).reverse_each do |i|\n    if is_palindrome?(string[i..-1])\n      return string + string[0...i].reverse\n    end\n  end\n\n  string\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\", candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"},{"task_id":"HumanEval_11","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n xor binary dó nǔ è nɔ byɔ mɛ lɛ́ɛ jí bo lɛ́ lɛ́ wá mɔ̀ nùɖé lɛ́ nyí wuntun ɖé.Nǔ e è nɔ sɔ́ dó mɛ é wɛ nyí xɛ wè a kpo b kpo e mɛ 1 kpo 0 kpo kɛɖɛ wɛ ɖè.# >>> string_xor.call(\"010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n","canonical_solution":"def string_xor(a, b)\n  result = \"\"\n  a.length.times do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"},{"task_id":"HumanEval_12","nl":"fon_Latn","pl":"rb","prompt":"wuntun e nɔ na wuntun ɖokpo ɔ lɛ é. E na lɛ́ lɛ́ wá nú nil nú nùxíxo e è nɔ sɔ́ wuntun ɔ dó ɔ́' ɖò mɛ̀ ǎ ɔ́.Ɖò xwɛ́ e è nɔ ylɔ́ ɖɔ \"array\" ɔ́ mɛ ɔ́, è na lɛ́ yí wuntun e nyí wuntun línlín tɔn é.# >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n","canonical_solution":"def longest(strings)\n  return nil if strings.empty?\n  strings.max_by(&:length)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n    assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n  end\nend\n"},{"task_id":"HumanEval_13","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nùjlɛ́kpà wè e nyí nùjlɛ́kpà a kpódó b kpán tɔn ɖaxó bǐ ɔ́# >>> greatest_common_divisor.call(3, 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a, b)\n","canonical_solution":"def greatest_common_divisor(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3, 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49, 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"},{"task_id":"HumanEval_14","nl":"fon_Latn","pl":"rb","prompt":"E nɔ lɛ́ lɛ́ kɔ̀ nùxwásá lɛ́ɛ bǐ sín wuntun kpɛví ɔ́ jí jɛ wuntun línlín ɔ́ jí.# >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n","canonical_solution":"def all_prefixes(string)\n  (1..string.length).map { |i| string[0, i] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"], candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"WWW\"))\n  end\nend\n"},{"task_id":"HumanEval_15","nl":"fon_Latn","pl":"rb","prompt":"Ðɔ wuntun e mɛ nùxwásá e ɖò tɛntin lɛ́ɛ ɖè é bɛ́ sín 0 jɛ n jí é. # >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n# \"0 1 2 3 4 5\"\ndef string_sequence(n)\n","canonical_solution":"def string_sequence(n)\n  (0..n).to_a.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_16","nl":"fon_Latn","pl":"rb","prompt":"E na sɔ́ wuntun ɖé ɔ́, kpɔ́n ɖɔ wuntun nabí lɛ́ɛ wɛ ɖò wuntun ɔ́ mɛ (e ma kpɔ́n ɖɔ wuntun ɔ́ ɖò wuntun ɖaxó alǒ wuntun kpɛví mɛ ǎ)# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n","canonical_solution":"def count_distinct_characters(string)\n  string.downcase.chars.uniq.count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5, candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"},{"task_id":"HumanEval_17","nl":"fon_Latn","pl":"rb","prompt":"'High' - nǔ e è nɔ ylɔ ɖɔ quater, bɔ é nɔ xɔ̀n azɔn ɖokpo'o saji' - nǔxixo ayizɛ́n, bɔ é nɔ́ nɔ wè'O' - nǔ e è nɔ ylɔ ɖɔ 'o' é bǐ, é nɔ xɔ azɔn ɛnɛNǔ e è ɖɔ dó hwenuxó ɔ wú ɔ ɖíe:é nyí gudo tɔn ǎ.azɔ towe wɛ nyí ɖɔ a na wlan xixo elɔ bo na lɛ́ lɛ́ yí nùxwlé lɛ́ɛ sín nùxwlé e sɔgbe xá azɔn nabí e mɛ ɖokpo ɖokpo na xo éNǔ e è nɔ sɔ́ dó azɔ̀ elɔ mɛ é wɛ nyí wuntun e nɔ xlɛ́ nùxixa lɛ́ɛ ɖò wuntun ɖé mɛ ɖò ASCII.# >>> parse_music.call(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n","canonical_solution":"def parse_music(music_string)\n  # Split the input string into individual notes.\n  notes = music_string.split\n\n  # Map each note to its corresponding number of beats.\n  notes.map do |note|\n    case note\n    when 'o'\n      4\n    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1, 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"},{"task_id":"HumanEval_18","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n azɔn nabi è na mɔ xwɛɖuxwɛ e è na mɔ ɖò xwɛɖuxwɛ ɔ mɛ é. Xà xó e nɔ jɛ kpɔ́n lɛ é.# >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring)\n","canonical_solution":"def how_many_times(string, substring)\n  return 0 if substring.empty?\n  count = 0\n  i = 0\n  while i <= string.length - substring.length\n    if string[i, substring.length] == substring\n      count += 1\n    end\n    i += 1\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\", \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4, candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"john doe\", \"john\"))\n  end\nend\n"},{"task_id":"HumanEval_19","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nùjlɛ́kpo lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé kpɛví bǐ jɛ nùɖé ɖaxó bǐ jí Nǔ e è sixu sɔ́ lɛ́ɛ wɛ nyí 'wǒ', 'ɖokpo', 'we', ' atɔn', 'nɛ', 'atɔ́n', 'sín', 'sínwe', 'zǒzǒ' kpo 'tɔn'. Nǔ e è nɔ sɔ́ dó mɛ é wɛ nyí nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ tɔn e sín akpáxwé e è nɔ sɔ́ dó nǔ lɛ é nɔ́ nyí \"mɛ̌\" jɛ \"tɔn\".# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef sort_numbers(numbers)\n","canonical_solution":"def sort_numbers(numbers)\n  numeral_map = {\n    'zero' => 0,\n    'one' => 1,\n    'two' => 2,\n    'three' => 3,\n    'four' => 4,\n    'five' => 5,\n    'six' => 6,\n    'seven' => 7,\n    'eight' => 8,\n    'nine' => 9\n  }\n\n  number_words = numbers.split\n  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }\n  sorted_numbers.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six five four three two one zero\"))\n  end\nend\n"},{"task_id":"HumanEval_20","nl":"fon_Latn","pl":"rb","prompt":"bo na lɛ́ lɛ́ kɔ́n yě ɖò tito jí (àkwɛ́ kpɛví, àkwɛ́ ɖaxó).Ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ e è na lɛ́ ná é (e na nyí wè ɖò wuntun wè jí) ɔ́, ɖè we e ɖò wè jí lɛ́ɛ, bó lɛ́ lɛ́ lɛ́ yí wè e ɖò wè jí lɛ́ɛ.# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n","canonical_solution":"def find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs\n\n  (1...(sorted_numbers.length - 1)).each do |i|\n    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs\n    if current_difference < min_difference\n      min_difference = current_difference\n      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    end\n  end\n\n  closest_pair\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n"},{"task_id":"HumanEval_21","nl":"fon_Latn","pl":"rb","prompt":"e na zɔ́n bɔ nùxà e ɖò kpɛví hú bǐ é na húzú 0 bɔ nùxà e ɖò ɖaxó hú bǐ é na húzú 1 Nú è na w'azɔ̌ nú nùjlɛ́kpo (e nɔ ɖó nǔ wè ɖò wŭ é) ɔ, è na zán nùjlɛ́kpo e nɔ yí nùjlɛ́kpo ɔ ɖóɖó é ɖé dó nùjlɛ́kpo enɛ jí, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n","canonical_solution":"def rescale_to_unit(numbers)\n  min = numbers.min\n  max = numbers.max\n  range = max - min\n  return numbers.map { |num| (num - min) \/ range.to_f }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\nend\n"},{"task_id":"HumanEval_22","nl":"fon_Latn","pl":"rb","prompt":"Filter nǔxwlé lɛ́ɛ nú nùxwlé lɛ́ɛ kɛ́ɖɛ́# >>> filter_integers.call([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\ndef filter_integers(values)\n","canonical_solution":"def filter_integers(values)\n  values.select { |value| value.is_a?(Integer) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n    assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\nend\n"},{"task_id":"HumanEval_23","nl":"fon_Latn","pl":"rb","prompt":"Hɔn nú wuntun e è ná lɛ́ ná é sín wuntun # >>> strlen.call(\"\")\n# 0\n# >>> strlen.call(\"abc\")\n# 3\ndef strlen(string)\n","canonical_solution":"strlen = lambda do |string|\n  string.length\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"asdasnakj\"))\n  end\nend\n"},{"task_id":"HumanEval_24","nl":"fon_Latn","pl":"rb","prompt":"nú nùxwásùn n ɖé ɔ, mɔ nùxwásùn ɖaxó e má n ɖó wè é, bɔ é hú gǎn n é.# >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n","canonical_solution":"def largest_divisor(n)\n  (n - 1).downto(1) do |i|\n    return i if n % i == 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n  end\nend\n"},{"task_id":"HumanEval_25","nl":"fon_Latn","pl":"rb","prompt":"nùmε e è nɔ sɔ́ dó wlan ɔ ná ɔ na cí nùtɔ́n e è nɔ sɔ́ dó wlan nǔ lɛ bǐ é ɖɔhun.Nǔkpò lɛ ɖokpo ɖokpo ɖó na nyí nùɖé bɔ è na sɔ́ dó nùɖé mɛ azɔn nabi e é nɔ́ jɛ ɖò nǔkpò lɛ mɛ é.E nɔ lɛ́ lɛ́ wá nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ.# >>> factorize.call(8)\n# [2, 2, 2]\n# >>> factorize.call(25)\n# [5, 5]\n# >>> factorize.call(70)\n# [2, 5, 7]\ndef factorize(n)\n","canonical_solution":"def factorize(n)\n  factors = []\n  divisor = 2\n  while n > 1\n    while n % divisor == 0\n      factors << divisor\n      n \/= divisor\n    end\n    divisor += 1\n  end\n  factors\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_factorize\n    candidate = method(:factorize)\n    assert_equal([2], candidate.call(2))\n    assert_equal([2, 2], candidate.call(4))\n    assert_equal([2, 2, 2], candidate.call(8))\n    assert_equal([3, 19], candidate.call(57))\n    assert_equal([3, 3, 19, 19], candidate.call(3249))\n    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))\n    assert_equal([3, 19, 19, 19], candidate.call(20577))\n    assert_equal([2, 3, 3], candidate.call(18))\n  end\nend\n"},{"task_id":"HumanEval_26","nl":"fon_Latn","pl":"rb","prompt":"Mi hɛn nǔ lɛ tɔn lɛ sín tito ɔ ɖesu ɖi lee mi hɛn ye gbɔn ɖò nǔ e mi wlan lɛ é mɛ é ɖɔhun.Ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ lɛ́ɛ tɔn ɖé mɛ ɔ, ɖè nùɖé lɛ́ɛ bǐ e nɔ jɛ azɔn hú ɖokpo é.# >>> remove_duplicates.call([1, 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n","canonical_solution":"def remove_duplicates(numbers)\n  numbers.select { |num| numbers.count(num) == 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"},{"task_id":"HumanEval_27","nl":"fon_Latn","pl":"rb","prompt":"Ɖo wèmá è è ná wèmá ɔ́ mɛ ɔ́, wèmá kpɛví lɛ́ɛ ɖó ná nyí wèmá ɖaxó, bɔ wèmá ɖaxó lɛ́ɛ ɖó ná nyí wèmá kpɛví.# >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n","canonical_solution":"def flip_case(string)\n  string.swapcase\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights have violent ends\"))\n  end\nend\n"},{"task_id":"HumanEval_28","nl":"fon_Latn","pl":"rb","prompt":"Dàn wèmá lɛ́ɛ dó wèmá ɖokpo mɛ̀# >>> concatenate.call([])\n# \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n","canonical_solution":"def concatenate(strings)\n  strings.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"},{"task_id":"HumanEval_29","nl":"fon_Latn","pl":"rb","prompt":"Hɔn nùjlɛ́jlɛ́ e è nɔ ylɔ́ ɖɔ \"string\" lɛ́ɛ é ɖó ná nɔ́ dó nǔ e è nɔ ylɔ́ ɖɔ \"prefix\" lɛ́ɛ jí kpowun.# >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings, prefix)\n","canonical_solution":"def filter_by_prefix(strings, prefix)\n  strings.select { |string| string.start_with?(prefix) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\nend\n"},{"task_id":"HumanEval_30","nl":"fon_Latn","pl":"rb","prompt":"E nɔ lɛ́ lɛ́ yí nùxwɛ́ e ɖò nùjlɛ́kpá ɔ́ mɛ lɛ́ɛ kɛ́ɖɛ́.# >>> get_positive.call([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n","canonical_solution":"get_positive = lambda do |l|\n  l.select { |num| num > 0 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1, -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_31","nl":"fon_Latn","pl":"rb","prompt":"E nɔ lɛ́ lɛ́ yí nùɖé lɛ́ɛ dó nùɖé lɛ́ɛ jí, nú nùɖé lɛ́ɛ nyí nùɖé lɛ́ɛ ɔ́, é nɔ lɛ́ yí nùɖé lɛ́ɛ dó nùɖé lɛ́ɛ jí.# >>> is_prime.call(6)\n# false\n# >>> is_prime.call(101)\n# true\n# >>> is_prime.call(11)\n# true\n# >>> is_prime.call(13441)\n# true\n# >>> is_prime.call(61)\n# true\n# >>> is_prime.call(4)\n# false\n# >>> is_prime.call(1)\n# false\ndef is_prime(n)\n","canonical_solution":"is_prime = lambda do |n|\n  return false if n <= 1\n  return true if n == 2\n  return false if n.even?\n\n  max_divisor = Math.sqrt(n).to_i\n  (3..max_divisor).step(2).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_prime\n    candidate = method(:is_prime)\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(101))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(13441))\n    assert_equal(true, candidate.call(61))\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(1))\n    assert_equal(true, candidate.call(5))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(17))\n    assert_equal(false, candidate.call(85))\n    assert_equal(false, candidate.call(77))\n    assert_equal(false, candidate.call(255379))\n  end\nend\n"},{"task_id":"HumanEval_33","nl":"fon_Latn","pl":"rb","prompt":"e nɔ sɔ́ dó nǔ e è nɔ ylɔ́ ɖɔ \"l\" lɛ́ɛ wu, amɔ̌ è nɔ ɖè ye ɖó vovo.l' cí l ɖɔhun ɖò nǔ e è ma nɔ má ɖó atɔn ǎ lɛ é mɛ, có nùjlɛ́n tɔn lɛ ɖò nǔ e è nɔ má ɖó atɔn lɛ é mɛ ɔ, ɖokpo ɔ wɛ ye nyí azɔ̀ élɔ́ nɔ́ yí nùkwín l bo nɔ́ lɛ́ yí nùkwín l' bɔ̀ # >>> sort_third.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n","canonical_solution":"def sort_third(l)\n  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort\n  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"},{"task_id":"HumanEval_34","nl":"fon_Latn","pl":"rb","prompt":"Zɔ̀n nǔɖòɖó bunɔ e è ɖè ɖò nùta ɖé mɛ lɛ́ɛ é# >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n","canonical_solution":"def unique(l)\n  l.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_35","nl":"fon_Latn","pl":"rb","prompt":"E nɔ lɛ́ lɛ́ vɔ́ nǔ e ɖò nǔ lɛ́ɛ mɛ é bǐ.# >>> max_element.call([1, 2, 3])\n# 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n","canonical_solution":"def max_element(l)\n  l.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2, 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))\n  end\nend\n"},{"task_id":"HumanEval_36","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nú azɔn nabí e wuntun 7 nɔ tɔ́n ɖò nùjlɛ́kpá e ɖò kpò hú n bɔ è sixu má nú 11 alǒ 13. # >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n# 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n","canonical_solution":"def fizz_buzz(n)\n  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 || i % 13 == 0\n      count += i.to_s.count('7')\n    end\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n    assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n    assert_equal(8026, candidate.call(100000))\n  end\nend\n"},{"task_id":"HumanEval_37","nl":"fon_Latn","pl":"rb","prompt":"e nɔ sɔ́ dó nùjlɛ́jlɛ́ e ɖò l jí lɛ́ɛ jí, amɔ̌ è nɔ ɖè ye ɖó alɔkpa ɖé.l' cí l ɖò nùjlɛ́jlɛ́ e nyí nǔɖòɖó ɖé lɛ é mɛ, có nùjlɛ́jlɛ́jlɛ́ tɔn lɛ ɖò nùjlɛ́jlɛ́ e nyí nǔɖòɖó lɛ é mɛ ɔ cí ɖokpo ɔ́ ɖɔhun.azɔ̀ élɔ́ nɔ́ yí nùkwín l bo nɔ́ lɛ́ yí nùkwín l' bɔ̀ # >>> sort_even.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n","canonical_solution":"def sort_even(l)\n  even_indices = l.each_index.select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  \n  even_index = 0\n  l.each_with_index.map do |value, index|\n    if index.even?\n      even_values[even_index].tap { even_index += 1 }\n    else\n      value\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\nend\n"},{"task_id":"HumanEval_39","nl":"fon_Latn","pl":"rb","prompt":"prime_fib nɔ lɛ́ yí nùɖé nú númɛ́gɔ́ e nyí nùɖé nú Fibonacci bɔ é lɔ nyí nùɖé nú númɛ́gɔ́gɔ́.# >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n# 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n","canonical_solution":"def prime_fib(n)\n  require 'prime'\n  \n  fibs = Enumerator.new do |y|\n    a, b = 0, 1\n    loop do\n      a, b = b, a + b\n      y << b\n    end\n  end\n  \n  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }\n  prime_fibs.first(n).last\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n    assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n    assert_equal(433494437, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_40","nl":"fon_Latn","pl":"rb","prompt":"nùɖé ǎ.é nɔ́ lɛ́ kɔ́n nugbǒ nú nùɖé lɛ́ɛ ɖò nùjlɛ́jlɛ́ ɔ́ mɛ bɔ̀ triples_sum_to_zero nɔ sɔ́ nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ dó w'azɔ̌ mɛ.# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n# >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n","canonical_solution":"def triples_sum_to_zero(l)\n  n = l.length\n  (0...n-2).each do |i|\n    ((i+1)...n-1).each do |j|\n      ((j+1)...n).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false, candidate.call([100, 3, 5, -100]))\n  end\nend\n"},{"task_id":"HumanEval_41","nl":"fon_Latn","pl":"rb","prompt":"azɔ̀n élɔ́ nɔ́ sɔ́ nùɖé lɛ́ɛ dó nùɖé lɛ́ɛ mɛ̀.ye nɔ ɖò yiyi wɛ ɖi ɖɔ ye ma ko mɔ yeɖée kpɔ́n gbeɖé ǎ ɖɔhun.Amɔ̌, kɛkɛ́ lɛ́ɛ ɖó hlɔnhlɔn bo lɛ́ ɖó hlɔnhlɔn tawun; enɛ wu ɔ, ye nɔ kpó ɖò yiyi wɛ.hwenu e mɔto e ɖò yiyi wɛ sín amyɔxwé yì ɖisixwé é xò mɔto e ɖò yiyi wɛ sín ɖisixwé yì amyɔxwé é.mɔ̌ wɛ mɛ lɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛ ɖɔ mɔ̌ wɛ mɛ lɛ́ɛ nɔ́ ɖɔ nú mɛye ɖo ali we wɛ.mɔto n nɔ ɖo ali ji wɛ sín amyɔxwé yì ɖisixwé; ɖò hwe ɖokpo ɔ nu ɔ, mɔto vovo lɛ tɔn n nɔ ɖo ali ji wɛKpɔ́n ali e nyí ali ɖagbe e nɔ cí gblógbló é ɖé é dó nukún mɛ.def car_race_collision(n)\n","canonical_solution":"def car_race_collision(n)\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_42","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nùxwléɖókpɔ́ e ɖó nùɖé lɛ́ɛ bɔ è nɔ zín 1.# >>> incr_list.call([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n","canonical_solution":"def incr_list(l)\n  l.map { |x| x + 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_43","nl":"fon_Latn","pl":"rb","prompt":"nùɖé ǎ.é na lɛ́ lɛ́ wá nyí nugbǒ nú nùɖé lɛ́ ɖò nǔ wè mɛ ɖò nǔ e nyí nǔ wè é mɛ é pairs_sum_to_zero nɔ sɔ́ nùxwlé lɛ́ɛ sín nùxwlé lɛ́ɛ dó w'azɔ̌ mɛ.# >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1, 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n# false\ndef pairs_sum_to_zero(l)\n","canonical_solution":"def pairs_sum_to_zero(l)\n  num_set = l.to_set\n  l.each do |num|\n    return true if num != 0 && num_set.include?(-num)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"},{"task_id":"HumanEval_44","nl":"fon_Latn","pl":"rb","prompt":"nùxwásá lɛ́ɛ ɖò hweɖénu hú 10.lɛ́ kɔ́n nùjlɛ́jlɛ́ sín nùjlɛ́jlɛ́ ɔ́.Gǎn nùjùnnúmɛ nú nùjùnnúmɛ x ɔ́ dó nùjùnnúmɛ nú nùjùnnúmɛ ɔ́.# >>> change_base.call(8, 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7, 2)\n# \"111\"\ndef change_base(x, base)\n","canonical_solution":"def change_base(x, base)\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits << (x % base).to_s\n    x \/= base\n  end\n  digits.reverse.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8, 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\", candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7, 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3, 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5, 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7, 8))\n  end\nend\n"},{"task_id":"HumanEval_45","nl":"fon_Latn","pl":"rb","prompt":"E na mɔ akpáxwé tɔn lɛ sín gege kpo fí e è na lɛ́ lɛ́ kɔ́n dó é kpo nú atɔnví ɖé.# >>> triangle_area.call(5, 3)\n# 7.5\ndef triangle_area(a, h)\n","canonical_solution":"def triangle_area(a, h)\n  (a * h) \/ 2.0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(7.5, candidate.call(5, 3))\n    assert_equal(2.0, candidate.call(2, 2))\n    assert_equal(40.0, candidate.call(10, 8))\n  end\nend\n"},{"task_id":"HumanEval_46","nl":"fon_Latn","pl":"rb","prompt":"Mi wlan azɔ̀ ɖé bo na dó mɔ nùɖé lɛ́ɛ ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ fib4 tɔn mɛ. Mi ma zán nǔ e nɔ lɛ́ nyí nǔ lɛ́ɛ é ó.fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 Fib4 nùxwásá ɔ́' nǔxwásá e cí Fibbonacci sín nǔxwásá ɔ́ ɖɔhun é wɛ è ɖè lě: # >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>> fib4.call(7)\n# 14\ndef fib4(n)\n","canonical_solution":"def fib4(n)\n  return 0 if n == 0 || n == 1 || n == 3\n  return 2 if n == 2\n\n  fib4_seq = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n  end\n  fib4_seq[n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28, candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_47","nl":"fon_Latn","pl":"rb","prompt":"Ðɔ nǔ e ɖò nǔ lɛ mɛ é sín mɛxwlé lɛ é sín mɛxwlé l. # >>> median.call([3, 1, 2, 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n","canonical_solution":"def median(l)\n  sorted = l.sort\n  len = sorted.length\n  if len.odd?\n    sorted[len \/ 2]\n  else\n    (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2.0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5, candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"},{"task_id":"HumanEval_48","nl":"fon_Latn","pl":"rb","prompt":"E nɔ kpɔ́n ɖɔ xɛ ɔ nyí palindrome à jí# >>> is_palindrome.call(\"\")\n# true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\")\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n","canonical_solution":"is_palindrome = lambda do |text|\n  text == text.reverse\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true, candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"},{"task_id":"HumanEval_49","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n 2^n modulo p (nùn nú nùjlɛ́kpo lɛ).# >>> modp.call(3, 5)\n# 3\n# >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3, 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n","canonical_solution":"def modp(n, p)\n  return 1 if p == 1\n  2.pow(n, p)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"},{"task_id":"HumanEval_51","nl":"fon_Latn","pl":"rb","prompt":"remove_vowels nyí azɔ̀ e nɔ yí wèmá bó nɔ lɛ́ lɛ́ wèmá e mɛ wèmá ɖě ma ɖè ǎ é.# >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n","canonical_solution":"def remove_vowels(text)\n  text.delete('aeiouAEIOU')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\", candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\", candidate.call(\"ybcd\"))\n  end\nend\n"},{"task_id":"HumanEval_52","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nú nú nùjlɛ́kpo l lɛ́ɛ bǐ ɖò fí e nǔ e è nɔ ylɔ ɖɔ t é ɖè é.# >>> below_threshold.call([1, 2, 4, 10], 100)\n# true\n# >>> below_threshold.call([1, 20, 4, 10], 5)\n# false\ndef below_threshold(l, t)\n","canonical_solution":"def below_threshold(l, t)\n  l.all? { |num| num < t }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_threshold\n    candidate = method(:below_threshold)\n    assert_equal(true, candidate.call([1, 2, 4, 10], 100))\n    assert_equal(false, candidate.call([1, 20, 4, 10], 5))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 21))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 22))\n    assert_equal(true, candidate.call([1, 8, 4, 10], 11))\n    assert_equal(false, candidate.call([1, 8, 4, 10], 10))\n  end\nend\n"},{"task_id":"HumanEval_53","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nùjlɛ́kpo wè x kpo y kpo# >>> add.call(2, 3)\n# 5\n# >>> add.call(5, 7)\n# 12\ndef add(x, y)\n","canonical_solution":"add = ->(x, y) { x + y }","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(1, candidate.call(0, 1))\n    assert_equal(1, candidate.call(1, 0))\n    assert_equal(5, candidate.call(2, 3))\n    assert_equal(12, candidate.call(5, 7))\n    assert_equal(12, candidate.call(7, 5))\n  end\nend\n"},{"task_id":"HumanEval_54","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n ɖɔ xókwin wè lɛ ɖó wuntun ɖokpo ɔ à jí.# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n# >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# false\ndef same_chars(s0, s1)\n","canonical_solution":"def same_chars(s0, s1)\n  s0.chars.uniq.all? { |char| s1.include?(char) } &&\n  s1.chars.uniq.all? { |char| s0.include?(char) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false, candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"))\n  end\nend\n"},{"task_id":"HumanEval_55","nl":"fon_Latn","pl":"rb","prompt":"Ðɔ númɛ Fibonacci tɔn n-ɔ ɔ. # >>> fib.call(10)\n# 55\n# >>> fib.call(1)\n# 1\n# >>> fib.call(8)\n# 21\ndef fib(n)\n","canonical_solution":"def fib(n)\n  return n if n <= 1\n  fib(n - 1) + fib(n - 2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89, candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_56","nl":"fon_Latn","pl":"rb","prompt":"lɛ́ kɔ́n true nú wèmá è nɔ hun ɔ́ ɖokpó ɖokpó ɖó wèmá e nɔ sú ɔ́ ɖokpó. brackets ɔ wɛ nyí wuntun \"<\" kpo \">\" kpo.# >>> correct_bracketing.call(\"<\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"<<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.chars.each do |char|\n    if char == '<'\n      balance += 1\n    elsif char == '>'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"<>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true, candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false, candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n    assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\">\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>>><>\"))\n  end\nend\n"},{"task_id":"HumanEval_57","nl":"fon_Latn","pl":"rb","prompt":"lɛ́ kɔ́n true nyí nùɖé lɛ́ɛ ɖò kpò jí wɛ̀ alǒ ɖò dín wɛ̀.# >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n# false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n","canonical_solution":"def monotonic(l)\n  increasing = true\n  decreasing = true\n\n  (0...l.length - 1).each do |i|\n    if l[i] < l[i + 1]\n      decreasing = false\n    elsif l[i] > l[i + 1]\n      increasing = false\n    end\n  end\n\n  increasing || decreasing\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2, 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false, candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1, 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\nend\n"},{"task_id":"HumanEval_58","nl":"fon_Latn","pl":"rb","prompt":"E nɔ lɛ́ lɛ́ wá nú nǔ e nyí nǔ ɖokpó ɔ́ bɔ è má ɖó ɖò nǔ wè lɛ́ɛ mɛ é.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n","canonical_solution":"def common(l1, l2)\n  (l1 & l2).uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"},{"task_id":"HumanEval_59","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nùx'ákpɔ́n ɖaxó n tɔn ɔ́.# >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n# 2\ndef largest_prime_factor(n)\n","canonical_solution":"def largest_prime_factor(n)\n  factor = 2\n  while factor * factor <= n\n    if n % factor == 0\n      n \/= factor\n    else\n      factor += 1\n    end\n  end\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n  end\nend\n"},{"task_id":"HumanEval_60","nl":"fon_Latn","pl":"rb","prompt":"sum_to_n nyí azɔ̀ e nɔ́ sɔ́ nùxwásá sín 1 jɛ n jí é. # >>> sum_to_n.call(30)\n# 465\n# >>> sum_to_n.call(100)\n# 5050\n# >>> sum_to_n.call(5)\n# 15\n# >>> sum_to_n.call(10)\n# 55\n# >>> sum_to_n.call(1)\n# 1\ndef sum_to_n(n)\n","canonical_solution":"def sum_to_n(n)\n  (1..n).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_61","nl":"fon_Latn","pl":"rb","prompt":"lɛ́ kɔ́n true nú wèmá è nɔ hun ɔ́ ɖokpó ɖokpó ɖó wèmá e nɔ sú ɔ́ ɖokpó. brackets ɔ wɛ nyí wuntun \"(\" kpo \"\") # >>> correct_bracketing.call(\"(\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"(()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.each_char do |char|\n    if char == '('\n      balance += 1\n    elsif char == ')'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true, candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false, candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n    assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\")\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false, candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"()()(()())()))()\"))\n  end\nend\n"},{"task_id":"HumanEval_62","nl":"fon_Latn","pl":"rb","prompt":"Zɔ́n nùjlɛ́nkpó sín nǔ e nyí nùjlɛ́nkpó enɛ tɔn é dó nùjlɛ́nkpó ɖokpo ɔ mɛ.xs[0] + xs[1] * x + xs[2] * x^2 + .... xs nɔte nú nùxíwénú polynomial tɔn lɛ.# >>> derivative.call([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative.call([1, 2, 3])\n# [2, 6]\ndef derivative(xs)\n","canonical_solution":"def derivative(xs)\n  return [] if xs.length < 2\n  xs.each_with_index.map { |coef, index| coef * index }[1..-1]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2, 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_63","nl":"fon_Latn","pl":"rb","prompt":"Mi wlan azɔ̀ ɖé bo na dó mɔ nùɖé lɛ́ɛ ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ ɔ́ mɛ.fεfεfεn (n) == fεfεfεn (n-1) + fεfεfεn (n-2) + fεfεfεn (n-3).fib fib ((2) == 1 fεfεfε)fibfib(0) == 0 FibFib nùxwásá sín nùxwásá ɔ́' nǔxwásá e cí Fibbonacci sín nùxwásá é ɖɔhun bɔ è ɖè ɖɔ̀:# >>> fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef fibfib(n)\n","canonical_solution":"def fibfib(n)\n  return 0 if n == 0 || n == 1\n  return 1 if n == 2\n\n  a, b, c = 0, 0, 1\n  (3..n).each do\n    a, b, c = b, c, a + b + c\n  end\n  c\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0, candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24, candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274, candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"},{"task_id":"HumanEval_64","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: xo ɔ, amɔ̌ enyi é ɖò xógbe e è na é sín vivɔnu ɔ jɛn wɛ ɔ.Hweɖegbe tɔn ɖo fí ɔ ye nyí 'a', 'e', 'i', 'o', 'u'. fí ɔ, 'y' ɔ lɔ nyí a e nɔ sɔ́ xókwin ɖé dó mɔ nǔ è nɔ dó é, bo nɔ lɛ́ lɛ́ ɖó vowel lɛ́ɛ ɖò wuntun ɔ mɛ.Wlǎn azɔ̀nú vowels_count e nɔ yí wèmá e nɔ ɖè # >>> vowels_count.call(\"abcde\")\n# 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n","canonical_solution":"def vowels_count(s)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  \n  s.chars.each_with_index do |char, index|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif char.downcase == 'y' && index == s.length - 1\n      count += 1\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"ACEDY\"))\n  end\nend\n"},{"task_id":"HumanEval_65","nl":"fon_Latn","pl":"rb","prompt":"Nú shift > nùxwásá nú wèmá lɛ́ɛ ɔ́, wèmá lɛ́ɛ ná lɛ́ kɔ́n.bo na lɛ́ lɛ́ wá mɔ nǔ e è mɔ é dó wuntun ɖé mɛ.Zɔ́n nùjlɛ́kpo x tɔn lɛ́ɛ ɖó tɛn lɛ́ɛ jí, zɔ́n nùjlɛ́kpo lɛ́ɛ ɖó tɛn lɛ́ɛ jí.# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12, 2)\n# \"12\"\ndef circular_shift(x, shift)\n","canonical_solution":"def circular_shift(x, shift)\n  digits = x.to_s.chars\n  num_digits = digits.length\n\n  if shift > num_digits\n    return digits.reverse.join\n  else\n    shift = shift % num_digits\n    shifted_digits = digits.rotate(-shift)\n    return shifted_digits.join\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100, 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\", candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"11\", candidate.call(11, 101))\n  end\nend\n"},{"task_id":"HumanEval_66","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: ASCII wèmá lɛ́ɛ.Wlǎn azɔ̀ e nɔ yí wèmá wèmá ɖé dó mɛ bo nɔ lɛ́ lɛ́ yí wèmá wèmá ɖaxó lɛ́ɛ sín nùɖé lɛ́ɛ dó mɛ é' azɔ̌ # >>> digitSum.call(\"\")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n# 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n# 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n","canonical_solution":"def digitSum(s)\n  s.chars.select { |char| char =~ \/[A-Z]\/ }.map(&:ord).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131, candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327, candidate.call(\"You arE Very Smart\"))\n  end\nend\n"},{"task_id":"HumanEval_67","nl":"fon_Latn","pl":"rb","prompt":"nú è ɖò xó ɖɔ wɛ ɔ: ɖo xasun ɔ mɛ ɔ mi na ɖɔ kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n.atinsinsɛn kpo atinsɛn kpo kpo kpodo xwiɖe e nɔte nú atinsɛn lɛ bǐ é kpo e nɔ ɖe nùjlɛdonǔwu e nɔ xlɛ́ ɖɔ nǔ lɛ́ɛ bǐ ɖò kpɔ́ ée è nɔ má dó atínkwɛ́ ɖé mɛ é ɔ́, atínkwɛ́ énɛ́ ɔ́ mɛ wɛ è nɔ mɔ atín tɔn lɛ́ɛ ɖè.Ðò azɔ̌ elɔ mɛ ɔ, è na na we xwɛ e nɔte nú atinsinsinsɛn kpo atinsɛn kpo é ɖokpo ɖokpo.# >>> fruit_distribution.call(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution.call(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution.call(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution.call(\"100 apples and 1 oranges\", 120)\n# 19\ndef fruit_distribution(s, n)\n","canonical_solution":"def fruit_distribution(s, n)\n  numbers = s.scan(\/\\d+\/).map(&:to_i)\n  apples = numbers[0]\n  oranges = numbers[1]\n  total_fruits = n\n  mangos = total_fruits - (apples + oranges)\n  mangos\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fruit_distribution\n    candidate = method(:fruit_distribution)\n    assert_equal(8, candidate.call(\"5 apples and 6 oranges\", 19))\n    assert_equal(10, candidate.call(\"5 apples and 6 oranges\", 21))\n    assert_equal(2, candidate.call(\"0 apples and 1 oranges\", 3))\n    assert_equal(2, candidate.call(\"1 apples and 0 oranges\", 3))\n    assert_equal(95, candidate.call(\"2 apples and 3 oranges\", 100))\n    assert_equal(0, candidate.call(\"2 apples and 3 oranges\", 5))\n    assert_equal(19, candidate.call(\"1 apples and 100 oranges\", 120))\n  end\nend\n"},{"task_id":"HumanEval_68","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndo 1: Nú nùɖé ma ɖò nùɖé jí ǎ alǒ nùɖé ma ɖò nùɖé jí ǎ ɔ, lɛ́ kɔ yì [].e na lɛ́ vɔ́ nùxwlé e è sɔ́ ɖó vo é dó nùxwlé ɖé mɛ, [smallest_value, its index], Nú è mɔ nɔ̀n gègě bo ɖó nùxíɖíɖó e nyí ganxixo kpɛví bǐ é ɖokpó ɔ ɔ, lɛ́ kɔ nú nɔ̀n e ɖó nùxíɖíɖó e nyí ganxixo kpɛví bǐ é. E nɔ nyí nuvo e è nɔ sɔ́ ɖó vo é wɛ nyí nuvo e nɔ ɖó akwɛ́ e nyí ganxixo é.azɔ towe wɛ nyí ɖɔ a na ɖè nukɔ́n ɖokpo bo na lɛ́ sɔ́ ɛ.\"E na bo na w'azɔ̌ e nɔ xlɛ́ alɔkwín atín ɖé tɔn e ɖó nùjlɛ́kpikpa e ma nyí nùjlɛ́kpikpa ǎ lɛ é é # >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>> pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n","canonical_solution":"def pluck(arr)\n  smallest_even = nil\n  smallest_index = nil\n  \n  arr.each_with_index do |value, index|\n    if value.even?\n      if smallest_even.nil? || value < smallest_even\n        smallest_even = value\n        smallest_index = index\n      end\n    end\n  end\n\n  smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"},{"task_id":"HumanEval_69","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Enyi nùɖé ma ɖò finɛ ǎ ɔ, lɛ́ kɔ́n -1.Nǔxixa ɔ́ sín nùxwásá wɛ nyí azɔn nabí e é nɔ tɔ́n ɖò nùxwásá ɔ́ mɛ é.azɔn, bo ɖó hwɛhwɛ e hú alǒ e cí nùxwlémɛ ɔ ɖesu tɔn é.e na lɛ́ ná nùjlɛ́kpó e ma nyí nǔtí ǎ é ɖé lɛ́ɛ we.# >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n","canonical_solution":"def search(lst)\n  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys\n  valid_numbers.empty? ? -1 : valid_numbers.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1, candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1, candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"},{"task_id":"HumanEval_70","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: enɛ ɔ gudo ɔ è na lɛ́ sɔ́ nùjlɛ́kpá e kpo lɛ́ɛ bǐ dó mɔ nùjlɛ́kpá ɖaxó ɔ, bɔ è na lɛ́ sɔ́ nùjlɛ́kpá kpɛví ɔ.E nɔ jɛ̀ nùɖé lɛ jí ɖò nùɖé lɛ jí ǎ, é nɔ nyí ɖɔ è nɔ bɛ́ nùɖé lɛ sín akwɛ́ jí,Nú è na sɔ́ nùxwléma ɔ́ lɛ́ɛ sín nùxwléma ɔ́, è na lɛ́ sɔ́ nùxwléma ɔ́ dó tito e ma sɔgbe ǎ é mɛ.# >>> strange_sort_list.call([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n","canonical_solution":"def strange_sort_list(lst)\n  result = []\n  lst.sort!\n  until lst.empty?\n    result << lst.shift\n    result << lst.pop unless lst.empty?\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\nend\n"},{"task_id":"HumanEval_71","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: e ɖo akpá atɔngɔ ɔ.Xò atɔn lɛ́ɛ nɔ́ bló ɖɔ̀ atɔnví ɔ́ nyí nùɖé, nú è na mɔ ɖɔ̀ wè lɛ́ɛ bǐ sín nǔ e è kplé ɔ́ hú gǎn we ɔ́.E ma nyí mɔ̌ ǎ ɔ́, é ná lɛ́ kɔ́n -1 .azɔmε atɔnvɔn ɔ e wεn ɔ e na wεn ɔ e na wεn ɔ e na wεn ɔ ɔ e na wεn ɔ e na wεn ɔ e na wεn ɔE na bo na w'azɔ̌ atɔn ɔ sín akpáxwé lɛ́ɛ ɔ, w'azɔ̌ ɔ ná lɛ́ yí xó ɔ́ sín fí e é nyí é.# >>> triangle_area.call(3, 4, 5)\n# 6.0\n# >>> triangle_area.call(1, 2, 10)\n# -1\ndef triangle_area(a, b, c)\n","canonical_solution":"def triangle_area(a, b, c)\n  # Check for valid triangle\n  if a + b > c && a + c > b && b + c > a\n    # Calculate the semi-perimeter\n    s = (a + b + c) \/ 2.0\n    # Calculate the area using Heron's formula\n    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Round to 2 decimal points\n    return area.round(2)\n  else\n    return -1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(6.0, candidate.call(3, 4, 5))\n    assert_equal(-1, candidate.call(1, 2, 10))\n    assert_equal(8.18, candidate.call(4, 8, 5))\n    assert_equal(1.73, candidate.call(2, 2, 2))\n    assert_equal(-1, candidate.call(1, 2, 3))\n    assert_equal(16.25, candidate.call(10, 5, 7))\n    assert_equal(-1, candidate.call(2, 6, 3))\n    assert_equal(0.43, candidate.call(1, 1, 1))\n    assert_equal(-1, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_72","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: Nǔ e nɔ nyí q ɔ na zɔn, enyi é ɖò jlɛ̌ jí (e nyí nǔ e nɔ nyí palindromic é) bo nùjɔnú tɔn lɛ sín nùxwásá nɔ vɛwǔ hú alǒ cí nǔ e nɔ nyí w é bǐ é ɖɔhun.Wlǎn nùjlɛ́n e nɔ lɛ́ yí gbè nú xó jɔ xó nú nǔ ɔ́ na yì yì ɔ́, bo nɔ yí gbè nú xó ma nyí mɔ̌ ǎ ɔ́.# >>> will_it_fly.call([1, 2], 5)\n# false\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly.call([3, 2, 3], 1)\n# false\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly.call([3, 2, 3], 9)\n# true\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly.call([3], 5)\n# true\n# # 3 is less than the maximum possible weight, and it's balanced.\ndef will_it_fly(q, w)\n","canonical_solution":"def will_it_fly(q, w)\n  is_palindrome = q == q.reverse\n  total_weight = q.sum\n  is_balanced_and_under_weight = is_palindrome && total_weight <= w\n  is_balanced_and_under_weight\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_will_it_fly\n    candidate = method(:will_it_fly)\n    assert_equal(true, candidate.call([3, 2, 3], 9))\n    assert_equal(false, candidate.call([1, 2], 5))\n    assert_equal(true, candidate.call([3], 5))\n    assert_equal(false, candidate.call([3, 2, 3], 1))\n    assert_equal(false, candidate.call([1, 2, 3], 6))\n    assert_equal(true, candidate.call([5], 5))\n  end\nend\n"},{"task_id":"HumanEval_73","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: e nɔ xa ɖokpo ɔ ɖo gudo kpo nukɔn kpo. Ðò ye na lɛ ɔ, a sixu ɖyɔ nǔɖogbɛ ɖokpo bo na lɛ́ huzu nǔɖogbɛ ɖevo.e na bló bɔ nǔ lɛ na nɔ nyí palindromic. nǔ lɛ nɔ nyí palindromic ɔ wɛ nyí nǔ e nɔ nyí E na bo na mɔ nùxwléma e nyí nùjlɛ́kpá lɛ é sín nùxwléma ɔ, kpɔ́n nùxwléma e nyí nùxwléma lɛ é tɔn # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change.call([1, 2, 3, 2, 1])\n# 0\ndef smallest_change(arr)\n","canonical_solution":"def smallest_change(arr)\n  changes = 0\n  left = 0\n  right = arr.length - 1\n\n  while left < right\n    if arr[left] != arr[right]\n      changes += 1\n    end\n    left += 1\n    right -= 1\n  end\n\n  changes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_smallest_change\n    candidate = method(:smallest_change)\n    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))\n    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))\n    assert_equal(1, candidate.call([1, 4, 2]))\n    assert_equal(1, candidate.call([1, 4, 4, 2]))\n    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))\n    assert_equal(0, candidate.call([3, 1, 1, 3]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(1, candidate.call([0, 1]))\n  end\nend\n"},{"task_id":"HumanEval_74","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú enyi xwɛ ɖokpo ɔ wɛ ɖò xwɛ wè lɛ mɛ ɔ, lɛ́ yí xwɛ nukɔntɔn ɔ.nùxwásá nǔjlɛ́jlɛ́ tɔn ɖò nùjlɛ́jlɛ́ ɔ́ sín xɛ́n lɛ́ɛ bǐ mɛ é dín hú nùjlɛ́jlɛ́ ɔ́ tɔn ɖě.Wlǎn azɔ̀ e nɔ yí gbè nú nùjlɛ́jlɛ́ wè bó nɔ lɛ́ yí nùjlɛ́jlɛ́ e ɖó # >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n","canonical_solution":"def total_match(lst1, lst2)\n  total_chars1 = lst1.map(&:length).sum\n  total_chars2 = lst2.map(&:length).sum\n\n  if total_chars1 < total_chars2\n    lst1\n  elsif total_chars2 < total_chars1\n    lst2\n  else\n    lst1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\", \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n    assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"},{"task_id":"HumanEval_75","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: Nukúnmɛ ɖɔ (a) ɖò kpɛví hú 100.bo lɛ́ nyí nǔvú.Wlǎn nùjlɛ́n e na lɛ́ yí gbè nú nùjlɛ́n e è ná é nyí nùjlɛ́n ta atɔn sín azɔn wɛ é nyí é.# >>> is_multiply_prime.call(30)\n# true\n# 30 = 2 * 3 * 5\ndef is_multiply_prime(a)\n","canonical_solution":"require 'prime'\n\ndef is_multiply_prime(a)\n  return false if a >= 100\n  prime_factors = a.prime_division\n  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_multiply_prime\n    candidate = method(:is_multiply_prime)\n    assert_equal(false, candidate.call(5))\n    assert_equal(true, candidate.call(30))\n    assert_equal(true, candidate.call(8))\n    assert_equal(false, candidate.call(10))\n    assert_equal(true, candidate.call(125))\n    assert_equal(true, candidate.call(105))\n    assert_equal(false, candidate.call(126))\n    assert_equal(false, candidate.call(729))\n    assert_equal(false, candidate.call(891))\n    assert_equal(true, candidate.call(1001))\n  end\nend\n"},{"task_id":"HumanEval_76","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: x nyí nùɖé bɔ è nɔ sɔ́ dó kpá nú n enyi n**int=x nǔ e nyí nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ è nɔ ylɔ ɖɔ nǔ ɔ ǎ é.azɔ towe wɛ nyí ɖɔ a na wlan azɔ̀ e na lɛ́ lɛ́ wá nyí nugbǒ ɔ́ nú nùxà x nyí nùɖé bɔ̀ è nɔ ylɔ ɖɔ nùɖé bɔ̀ è nɔ ylɔ ɖɔ nùɖé é.# >>> is_simple_power.call(1, 4)\n# true\n# >>> is_simple_power.call(2, 2)\n# true\n# >>> is_simple_power.call(8, 2)\n# true\n# >>> is_simple_power.call(3, 2)\n# false\n# >>> is_simple_power.call(3, 1)\n# false\n# >>> is_simple_power.call(5, 3)\n# false\ndef is_simple_power(x, n)\n","canonical_solution":"def is_simple_power(x, n)\n  return false if x <= 0 || n <= 1\n  return true if x == 1\n\n  power = n\n  while power <= x\n    return true if power == x\n    power *= n\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_simple_power\n    candidate = method(:is_simple_power)\n    assert_equal(true, candidate.call(16, 2))\n    assert_equal(false, candidate.call(143214, 16))\n    assert_equal(true, candidate.call(4, 2))\n    assert_equal(true, candidate.call(9, 3))\n    assert_equal(true, candidate.call(16, 4))\n    assert_equal(false, candidate.call(24, 2))\n    assert_equal(false, candidate.call(128, 4))\n    assert_equal(false, candidate.call(12, 6))\n    assert_equal(true, candidate.call(1, 1))\n    assert_equal(true, candidate.call(1, 12))\n  end\nend\n"},{"task_id":"HumanEval_77","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Akpàkpà: a sixu ɖɔ ɖɔ nǔ e è wlan ɔ na nɔ wà hwebǐnu.enyi mɛ e ɖò xixo ɔ nyí xixo nùjlɛ́kpá ɖé tɔn ɔ.Wlǎn azɔ̀ e nɔ yí nùjlɛ́kpá a bo nɔ lɛ́ yí true é# >>> iscube.call(1)\n# true\n# >>> iscube.call(2)\n# false\n# >>> iscube.call(-1)\n# true\n# >>> iscube.call(64)\n# true\n# >>> iscube.call(0)\n# true\n# >>> iscube.call(180)\n# false\ndef iscube(a)\n","canonical_solution":"def iscube(a)\n  cube_root = a.abs**(1.0\/3)\n  cube_root.round**3 == a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_iscube\n    candidate = method(:iscube)\n    assert_equal(true, candidate.call(1))\n    assert_equal(false, candidate.call(2))\n    assert_equal(true, candidate.call(-1))\n    assert_equal(true, candidate.call(64))\n    assert_equal(false, candidate.call(180))\n    assert_equal(true, candidate.call(1000))\n    assert_equal(true, candidate.call(0))\n    assert_equal(false, candidate.call(1729))\n  end\nend\n"},{"task_id":"HumanEval_78","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: akpàkpà lɛ A,B,C,D,E,F ɔ́' è nɔ sɔ́ wèmá ɖaxó dó wèmá lɛ́ɛ.Akpàkpà: mi sixu ɖɔ ɖɔ nǔ e è wlan ɔ sɔgbe hwebǐnu alǒ é nyí xɛ́n ɖé ǎ,B (=mɛ̀gbò 11), D (=mɛ̀gbò 13). N'ò ɔ, a ɖó na kpɔ́n nùjlɛ́kpo e ɖò wuntun elɔ lɛ mɛ lɛ é: 2, 3, 5, 7, Nùxwlémɛ nukɔntɔn lɛ wɛ nyí 2, 3, 5, 7, 11, 13, 17,...Wěma afɔtɔn-nukún-ɖokpo lɛ wɛ nyí 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. e hú 1 bo ma nyí nùjlɛ́kpo nùjlɛ́kpo wè e ɖò kpò é tɔn ǎ é).nùxwásá nùɖé lɛ́ɛ wɛ nyí nùjlɛ́kpá (númɛ́ e nyí nùjlɛ́kpá é ɖé wɛ nyí nùjlɛ́kpá nùjlɛ́kpá ɖé nùxwásùn wǒ-wě-wě tɔn ɖé wɛ nyí xɛ́n ɖé bɔ é nɔ́ xa nùxwásùn wǒ-wě tɔn lɛ́ɛ È byɔ̀ we ɖɔ a ni wlan azɔ̀ e nɔ yí nǔ lɛ é ɖé.# >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n# >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n","canonical_solution":"def hex_key(num)\n  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n  num.chars.count { |digit| prime_hex_digits.include?(digit) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6, candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"},{"task_id":"HumanEval_79","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Akpáxwé e è sɔ́ dó lɛ́ɛ ɖò finɛ bo na d'alɔ ɖò nùwlanwlan ɔ mɛ.E na sɔ́ wuntun kpɛví kpɛví ɖé lɛ́ɛ 'db' ɖò wuntun ɔ́ sín bǐbɛ́mɛ kpo fó tɔn kpo.Akɔdo ɖokpo ɖokpo ɖo xɛ ɔ mɛ ɔ e na nyi '0' alo '1'.binary format. azɔ na lɛ na w'azɔ ɔ, bo na lɛ na w'azɔ ɔ ɖokpo ɖokpo ɔ na nɔte nú binary e na w'azɔn we bɔ a na w'azɔn ɔ na nyi # >>> decimal_to_binary.call(15)\n# \"db1111db\"\n# >>> decimal_to_binary.call(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal)\n","canonical_solution":"def decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"db\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_decimal_to_binary\n    candidate = method(:decimal_to_binary)\n    assert_equal(\"db0db\", candidate.call(0))\n    assert_equal(\"db100000db\", candidate.call(32))\n    assert_equal(\"db1100111db\", candidate.call(103))\n    assert_equal(\"db1111db\", candidate.call(15))\n  end\nend\n"},{"task_id":"HumanEval_80","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: Xò wèmá ɔ́' è nɔ ylɔ́ ɖɔ haprb' enyi wèmá ɔ́' ɖò wèmá 3 jí ɖò hweɖelɛnu bɔ wèmá 3 ɖò wèmá ɔ́ mɛ lɛ́ɛ bǐ nɔ́ nyí nǔ ɖokpo ɔ́.azɔ towe wɛ nyí ɖɔ a na kpɔ́n ɖɔ xɛ ɔ sɔgbe à alǒ e sɔgbe ǎ.e na w'azɔ̌ nú we.# >>> is_happy.call(\"a\")\n# false\n# >>> is_happy.call(\"aa\")\n# false\n# >>> is_happy.call(\"abcd\")\n# true\n# >>> is_happy.call(\"aabb\")\n# false\n# >>> is_happy.call(\"adb\")\n# true\n# >>> is_happy.call(\"xyy\")\n# false\ndef is_happy(s)\n","canonical_solution":"def is_happy(s)\n  return false if s.length < 3\n  \n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  \n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true, candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n    assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"iopaxioi\"))\n  end\nend\n"},{"task_id":"HumanEval_81","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: 0.0 E > 0.0 D- > 0.7 D >1.0 D+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 B- > 2.7 B > 3.0 B+ > 3.3 A- > 3.7 A 4.0 A+ xwi xwi xwi xwi xwi xwiazɔ̀ e sixu ɖè nùjlɛ́jlɛ́ wemaxixa tɔn lɛ tɔn sín nùjlɛ́jlɛ́ ɖé sín nùjlɛ́jlɛ́ dó wemaxɔmɛ e ɖò wuntun elɔ mɛ é jí: É ná nǔ e mɛví lɛ́ɛ nɔ́ mɔ ɖò azɔ̌mɛ é we bɔ a ɖó ná wlan .Kpo ɖokpo ɔ wɛ nyí ɖɔ, é bú wuntun e é nɔ zán dó ɖè nǔ lɛ é.azɔmɛvi ɔ ɖo jijɛ wɛ bo na sɔ́ azɔmɛvi lɛ́ɛ ɖó vo.Azǎn e mɛ̌si ɔ na ɖè azɔ̌ lɛ é sín vivǐ ɔ sín azan gudo tɔn wɛ nyí égbé.# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\ndef numerical_letter_grade(grades)\n","canonical_solution":"def numerical_letter_grade(grades)\n  grades.map do |gpa|\n    case \n    when gpa == 4.0\n      \"A+\"\n    when gpa > 3.7\n      \"A\"\n    when gpa > 3.3\n      \"A-\"\n    when gpa > 3.0\n      \"B+\"\n    when gpa > 2.7\n      \"B\"\n    when gpa > 2.3\n      \"B-\"\n    when gpa > 2.0\n      \"C+\"\n    when gpa > 1.7\n      \"C\"\n    when gpa > 1.3\n      \"C-\"\n    when gpa > 1.0\n      \"D+\"\n    when gpa > 0.7\n      \"D\"\n    when gpa > 0.0\n      \"D-\"\n    else\n      \"E\"\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_numerical_letter_grade\n    candidate = method(:numerical_letter_grade)\n    assert_equal([\"A+\", \"B\", \"C-\", \"C\", \"A-\"], candidate.call([4.0, 3, 1.7, 2, 3.5]))\n    assert_equal([\"D+\"], candidate.call([1.2]))\n    assert_equal([\"D-\"], candidate.call([0.5]))\n    assert_equal([\"E\"], candidate.call([0.0]))\n    assert_equal([\"D\", \"D-\", \"C-\", \"B\", \"B+\"], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))\n    assert_equal([\"E\", \"D-\"], candidate.call([0.0, 0.7]))\n  end\nend\n"},{"task_id":"HumanEval_82","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú long nyí nùjlɔ́mɛnu nukɔntɔn ɖé alǒ nùvú nú é nyí ǎ ɔ Wlǎn azɔ̀ e nɔ yí wèmá wèmá ɖé bó nɔ lɛ́ yí true nú wèmá ɔ́ # >>> prime_length.call(\"Hello\")\n# true\n# >>> prime_length.call(\"abcdcba\")\n# true\n# >>> prime_length.call(\"kittens\")\n# true\n# >>> prime_length.call(\"orange\")\n# false\ndef prime_length(string)\n","canonical_solution":"def prime_length(string)\n  length = string.length\n  return false if length < 2\n\n  (2..Math.sqrt(length)).each do |i|\n    return false if length % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_length\n    candidate = method(:prime_length)\n    assert_equal(true, candidate.call(\"Hello\"))\n    assert_equal(true, candidate.call(\"abcdcba\"))\n    assert_equal(true, candidate.call(\"kittens\"))\n    assert_equal(false, candidate.call(\"orange\"))\n    assert_equal(true, candidate.call(\"wow\"))\n    assert_equal(true, candidate.call(\"world\"))\n    assert_equal(true, candidate.call(\"MadaM\"))\n    assert_equal(true, candidate.call(\"Wow\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"HI\"))\n    assert_equal(true, candidate.call(\"go\"))\n    assert_equal(false, candidate.call(\"gogo\"))\n    assert_equal(false, candidate.call(\"aaaaaaaaaaaaaaa\"))\n    assert_equal(true, candidate.call(\"Madam\"))\n    assert_equal(false, candidate.call(\"M\"))\n    assert_equal(false, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_83","nl":"fon_Latn","pl":"rb","prompt":"nùxwlé lɛ́ɛ e nɔ bɛ́ ɖò 1 jí alǒ nɔ fó ɖò 1 jí é.Ɖó è na w'azɔnkpɔnkpɔn ɖagbe n ɔ, lɛ́n nùxà e nɔ ɖó w'azɔnkpɔnkpɔnkpɔnn n-cicixá lɛ é sín nùxí def starts_one_ends(n)\n","canonical_solution":"def starts_one_ends(n)\n  return 0 if n <= 0\n\n  # Count numbers starting with 1\n  start_with_1 = 9 ** (n - 1)\n\n  # Count numbers ending with 1\n  end_with_1 = 9 ** (n - 1)\n\n  # Adjust for double counting the number that both starts and ends with 1\n  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1\n  \n  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n  end\nend\n"},{"task_id":"HumanEval_84","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú Ɖò nùjlɛ́kpá ɖagbe ɖé N ɔ, na lɛ́ yí nùjlɛ́kpá nùjlɛ́kpá tɔn lɛ́ɛ tɔn dó nùjlɛ́kpá wexwɛ tɔn mɛ. # >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n# >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n","canonical_solution":"def solve(n)\n  sum_of_digits = n.to_s.chars.map(&:to_i).sum\n  sum_of_digits.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n  end\nend\n"},{"task_id":"HumanEval_85","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: E na bo na w'azɔ̌n e nyí nùxwléma e nyí nùɖé ǎ lɛ́ɛ ɔ́, w'azɔ̌n e nyí nùxwléma e nyí nùxwléma ɖò nǔ e nyí nùxwléma é ǎ lɛ́ɛ é.# >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n","canonical_solution":"def add(lst)\n  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0, candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n  end\nend\n"},{"task_id":"HumanEval_86","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: Akpàkpà: A ɖó na hɛn xókwin lɛ kpo tɛn mɛ e ɖò mɛ lɛ é kpo ɖó kpɔ́ ɖò hwɛgbe ɔ mɛ.e nɔ ɖo jijɛ wɛ ɖò nǔ e è nɔ ylɔ ɖɔ ascii é jí.è nɔ sɔ́ xókwin yɔyɔ́ ɖé dó ɖyɔ́ xókwin ɔ́ jí bɔ mɛ e è sɔ́ ɖó tò jí lɛ́ɛ bǐ nɔ́ ɖò Sɛ́n e è ɖè ɖò nǔ lɛ mɛ é ɔ́, wuntun ɖé wɛ bɔ xókwin lɛ́ɛ bǐ (e è nɔ klán ɖó vo) Wlǎn azɔ̀ e nɔ yí wèmá ɖé bó nɔ lɛ́ yí gbè nú wèmá ɔ́ sín lilɛdogbeɖevomɛ ɖé é.# >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n","canonical_solution":"def anti_shuffle(s)\n  s.split(\/(\\s+)\/).map { |word| word.chars.sort.join }.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot. How are you?\"))\n  end\nend\n"},{"task_id":"HumanEval_87","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Bo lɛ́ sɔ́ lɛ́ɛ ɖó kpɔ́ bó ná dó ɖè ɖò nùjlɛ́jlɛ́ jí.Nɔ kpɔn nǔ lɛ gbɔn xota lɛ jí ɖò tito jí.xεn ɖokpo ɖokpo ɔ nyi nukunmεkpɔn - (ahɔn, xεn), bɔ e nɔ bɛ ɔ 0 wɛ.bo na lɛ́ lɛ́ lɛ́ lɛ́ kɔ́n nǔ lɛ́ɛ sín nǔ lɛ́ɛ, [(x1, y1), (x2, y2) ...] mɔ̌ Ɖɔ lst, bo na mɔ x, mɔ x ɖo nùxwlé lɛ mɛ, xota ɖokpo ɖokpo sixu ɖó nùjlɛ́jlɛ́ gǒjímɛ vovo.e cí matrix ɖɔhun, amɔ̌, é cí matrix lɛ ɖɔhun ǎ,È na we nǔ e ɖò we mɛ é, ɖi nǔ e è nɔ dó nǔ lɛ é, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([], 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst, x)\n","canonical_solution":"def get_row(lst, x)\n  result = []\n\n  lst.each_with_index do |row, i|\n    row.each_with_index do |value, j|\n      result << [i, j] if value == x\n    end\n  end\n\n  result.sort_by { |coord| [coord[0], -coord[1]] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"},{"task_id":"HumanEval_88","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: * ma ɖyɔ́ nùjlɛ́jlɛ́ e è na lɛ́ ná é ó.Akpádo:alǒ ɖè é ɖò nùxwásá è ɖò jɛ wɛ é mɛ nú nùxwásá ɔ ((mɛ̀ jɛ nukɔn nú nùxwásá ɔ, mɛ̀ jɛ nukɔn nú nùxwásá ɔ) nyí nùxwásá wè. mi na sɔ́ nùxwlé lɛ́ɛ ɖó alɔkpa jí nú nùxwlé lɛ́ɛ ɔ́ ná nyí nǔ e nɔ́ nyí nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ e è nɔ ylɔ́ ɖɔ nǔ é ǎ é é.E na mɔ nùxwléma e nyí nùɖé ǎ lɛ́ɛ ɔ́, lɛ́ kɔ́n nùxwléma ɔ́ sín wuntun ɖé ɖò nǔ lɛ́ɛ ba wɛ̀, # >>> sort_array.call([])\n# []\n# >>> sort_array.call([5])\n# [5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n","canonical_solution":"def sort_array(array)\n  return array if array.empty? || array.size == 1\n\n  if (array.first + array.last).odd?\n    array.sort\n  else\n    array.sort.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"},{"task_id":"HumanEval_89","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: yì jɛ wè jí azɔn wè yì tɛn wè jí.E na lɛ́ ɖò wlan e è nɔ zán dó wlan nǔ lɛ é mɛ é ɖó na nɔ́ bló gbɔn mɔ̌, bɔ wlan lɛ́ɛ ná nɔ́ nyí:é nɔ́ lɛ́ yí wèmá wèmá ɖé dó wèmá ɔ́ jí.Ðɔ azɔ̀n e nɔ yí nùkwín ɖé dó mɔ nùjlɛ́nkpénúmɛ é ɖé bɔ # >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"et\")\n# \"ix\"\ndef encrypt(s)\n","canonical_solution":"def encrypt(s)\n  s.chars.map do |char|\n    if char =~ \/[a-z]\/\n      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr\n    elsif char =~ \/[A-Z]\/\n      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr\n    else\n      char\n    end\n  end.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"e\", candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_90","nl":"fon_Latn","pl":"rb","prompt":"Na lɛ́ yí nǔ e nyí nil é nú nùɖé ma ɖò finɛ ǎ ɔ.Wlǎn azɔ̀ e nyí next_smallest (a) bó ná lɛ́ lɛ́ lɛ́ kɔ̀n nǔ e nyí nǔ wègɔ́ e nyí nǔ kpɛví bǐ ɖò nùjlɛ́jlɛ́ ɔ́ mɛ é. È na mi nùxwléma nùɖé lɛ́ɛ.# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1, 1])\n# nil\ndef next_smallest(lst)\n","canonical_solution":"def next_smallest(lst)\n  unique_sorted = lst.uniq.sort\n  unique_sorted.length >= 2 ? unique_sorted[1] : nil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"},{"task_id":"HumanEval_91","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: Xò xota lɛ́ɛ jí ɔ, è nɔ sɔ́ \"\", \"?\" alǒ \"!\" dó ɖó dogbó.\"Boredom\" ɔ́ xógbe e nɔ bɛ́ dó \"I\" jí é wɛ.È na sɔ́ xókwin ɖé lɛ dó así nú mi, bɔ azɔ̌ e mi na wa é wɛ nyí ɖɔ mi na xa númɛ ɔ.# >>> is_bored.call(\"Hello world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\ndef is_bored(s)\n","canonical_solution":"def is_bored(s)\n  sentences = s.split(\/(?<=[.?!])\/)\n  sentences.count { |sentence| sentence.strip.start_with?('I') }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1, candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"))\n  end\nend\n"},{"task_id":"HumanEval_92","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú E nɔ lɛ́ lɛ́ wá ɖó nǔvú ɖò ninɔmɛ ɖevo lɛ mɛ.E na lɛ́ lɛ́ wá yì nú nùjlɛ́n lɛ́ɛ ɖokpo ɔ́ na nyí nùjlɛ́n we ɖě lɛ́ɛ sín nǔjlɛ́n, bɔ nùjlɛ́n lɛ́ɛ bǐ na nyí nùjlɛ́n ɔ́.Ðɔ nùxwlémɛ e nɔ yí nùxwlé 3 é.# >>> any_int.call(5, 2, 7)\n# true\n# >>> any_int.call(3, 2, 2)\n# false\n# >>> any_int.call(3, -2, 1)\n# true\n# >>> any_int.call(3.6, -2.2, 2)\n# false\ndef any_int(x, y, z)\n","canonical_solution":"def any_int(x, y, z)\n  if [x, y, z].all? { |n| n.is_a?(Integer) }\n    x == y + z || y == x + z || z == x + y\n  else\n    false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_any_int\n    candidate = method(:any_int)\n    assert_equal(true, candidate.call(2, 3, 1))\n    assert_equal(false, candidate.call(2.5, 2, 3))\n    assert_equal(false, candidate.call(1.5, 5, 3.5))\n    assert_equal(false, candidate.call(2, 6, 2))\n    assert_equal(true, candidate.call(4, 2, 2))\n    assert_equal(false, candidate.call(2.2, 2.2, 2.2))\n    assert_equal(true, candidate.call(-4, 6, 2))\n    assert_equal(true, candidate.call(2, 1, 1))\n    assert_equal(true, candidate.call(3, 4, 7))\n    assert_equal(false, candidate.call(3.0, 4, 7))\n  end\nend\n"},{"task_id":"HumanEval_93","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Mi nɔ sɔ́ wlan lɛ́ɛ kɛɖɛ́ dó mɔ nǔ.xósúsú ɖò wlanwlán e è nɔ dó gbè mɛ é mɛ.wɛn ɔ kpo wèmá e nɔ tɔ́n ɖò tɛn wè nukɔn nú wèmá ɔ kpo e nɔ ɖyɔ́ xókwin lɛ́ɛ bǐ, nɔ ɖyɔ́ xókwin lɛ́ɛ bǐ ɖò  mɛ é.Wlǎn azɔ̀ e nɔ yí wɛn ɖé, bo nɔ wlan dó mɛ # >>> encode.call(\"test\")\n# \"TGST\"\n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n","canonical_solution":"def encode(message)\n  vowels = 'aeiou'\n  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}\n  \n  encoded_message = message.chars.map do |char|\n    if vowels.include?(char.downcase)\n      new_char = swap_vowels[char.downcase]\n      char == char.upcase ? new_char.upcase : new_char.downcase\n    else\n      char == char.upcase ? char.downcase : char.upcase\n    end\n  end\n\n  encoded_message.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"},{"task_id":"HumanEval_94","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: A na mɔ nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ e nyí nùjlɛ́jlɛ́ nukɔn nukɔntɔn ɔ bo na lɛ́ yí nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ tɔn lɛ́ɛ sín nùjlɛ́jlɛ́.È na mi nùxwléma nùɖé lɛ́ɛ.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])\n# 7\ndef skjkasdkd(lst)\n","canonical_solution":"def skjkasdkd(lst)\n  require 'prime'\n\n  # Find the largest prime number in the array\n  largest_prime = lst.select { |num| Prime.prime?(num) }.max\n  \n  # Return 0 if no prime number is found\n  return 0 if largest_prime.nil?\n\n  # Calculate the sum of digits of the largest prime number\n  largest_prime.to_s.chars.map(&:to_i).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_skjkasdkd\n    candidate = method(:skjkasdkd)\n    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))\n    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))\n    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))\n    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))\n    assert_equal(19, candidate.call([8191]))\n    assert_equal(19, candidate.call([8191, 123456, 127, 7]))\n    assert_equal(10, candidate.call([127, 97, 8192]))\n  end\nend\n"},{"task_id":"HumanEval_95","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: azɔ̀ ɔ́ ɖó na lɛ́ kɔ̀ nú nǔvú é nyí ɖɔ nǔkúnmɛ e è ná ɔ́ xú.case alǒ azin lɛ bǐ nyí xɛtɛ lɛ ɖò wema ɖaxó mɛ, nú é ma nyí mɔ̌ ǎ ɔ é na lɛ́ wá nyí false. enyi è na wlan nǔ ɔ ɔ, é na lɛ́ nyí nǔ e è nɔ ylɔ ɖɔ \"true\" é, enyi wlan ɔ lɛ́ɛ bǐ nyí xɛ ɖò lower  mɛ ɔ.# >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n","canonical_solution":"def check_dict_case(dict)\n  return false if dict.empty?\n\n  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }\n  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }\n\n  lowercase_keys || uppercase_keys\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n"},{"task_id":"HumanEval_96","nl":"fon_Latn","pl":"rb","prompt":"kpɔ́ndéwú ɔ: nùxwlé lɛ́ɛ e nyí nùjlɛ́kpá lɛ́ɛ bo ɖò hweɖénu nú n.Zɔ̀ nùɖé e nɔ yí nùɖé e nyí nùɖé ǎ é bo nɔ lɛ́ yí nùɖé e nyí nùɖé ɖò nùɖé lɛ mɛ é sín nùɖé lɛ é dó nùɖé lɛ mɛ.# >>> count_up_to.call(5)\n# [2, 3]\n# >>> count_up_to.call(11)\n# [2, 3, 5, 7]\n# >>> count_up_to.call(0)\n# []\n# >>> count_up_to.call(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to.call(1)\n# []\n# >>> count_up_to.call(18)\n# [2, 3, 5, 7, 11, 13, 17]\ndef count_up_to(n)\n","canonical_solution":"def count_up_to(n)\n  return [] if n <= 2\n  primes = []\n  (2...n).each do |num|\n    is_prime = true\n    (2..Math.sqrt(num)).each do |i|\n      if num % i == 0\n        is_prime = false\n        break\n      end\n    end\n    primes << num if is_prime\n  end\n  primes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([], candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"},{"task_id":"HumanEval_97","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Mi ɖɔ ɖɔ nǔ e è wlan ɔ́ nɔ́ sɔgbe hwebǐnu.nùjlɛ́kpo tɔn yetɔn lɛ sín nǔkúnmɛ.Dǒ nùjlɛ́nkpénúmɛ e nɔ yí nùjlɛ́n wè é dó lɛ́ lɛ́ kɔ́n é# >>> multiply.call(148, 412)\n# 16\n# >>> multiply.call(19, 28)\n# 72\n# >>> multiply.call(2020, 1851)\n# 0\n# >>> multiply.call(14, -15)\n# 20\ndef multiply(a, b)\n","canonical_solution":"def multiply(a, b)\n  a_unit_digit = a.abs % 10\n  b_unit_digit = b.abs % 10\n  a_unit_digit * b_unit_digit\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_multiply\n    candidate = method(:multiply)\n    assert_equal(16, candidate.call(148, 412))\n    assert_equal(72, candidate.call(19, 28))\n    assert_equal(0, candidate.call(2020, 1851))\n    assert_equal(20, candidate.call(14, -15))\n    assert_equal(42, candidate.call(76, 67))\n    assert_equal(49, candidate.call(17, 27))\n    assert_equal(0, candidate.call(0, 1))\n    assert_equal(0, candidate.call(0, 0))\n  end\nend\n"},{"task_id":"HumanEval_98","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: Nú è na sɔ́ wuntun s ɖé ɔ, kpɔ́n nùxwásá xókwin ɖaxó e ɖò wuntun lɛ mɛ lɛ é tɔn. # >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n","canonical_solution":"def count_upper(s)\n  vowels = ['A', 'E', 'I', 'O', 'U']\n  count = 0\n\n  s.chars.each_with_index do |char, index|\n    if index.even? && vowels.include?(char)\n      count += 1\n    end\n  end\n\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"EEEE\"))\n  end\nend\n"},{"task_id":"HumanEval_99","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú sín nùɖé wè lɛ́ɛ jí ɔ́, mi ná lɛ́ lɛ́ dó lɛ́ zɔ́n 0é nɔ́ lɛ́ yí nùjlɛ́kpá e sɛ́dó e é ɖó é. Nú nùjlɛ́kpá ɔ́ ɖò zɔ́n ɖokpó ɔ́ jí ɔ́ Ðɔ azɔ̀ e nɔ yí nùɖé (kpɔn) e nɔ ɖè nùɖé xlɛ́ é ɖé# >>> closest_integer.call(\"10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\ndef closest_integer(value)\n","canonical_solution":"def closest_integer(value)\n  number = value.to_f\n  if number > 0\n    (number + 0.5).floor\n  else\n    (number - 0.5).ceil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_100","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: i nɔte nú awinnya lɛ́ɛ ɖò xù ɔ́ mɛ (i+1).Zɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n- nú n nyí nùjlɛ́n wè ɔ, nú é nyí wè ɔ, nú é nyí wè ɔ.- nú n nyí nùxwɛ́ ɔ́, nú è na ɖɔ ɖɔ nùxwɛ́ e bɔ d'é jí é.Awǐnnya e ɖò xɔ e ɖò nukɔn é mɛ lɛ́ɛ sín nùɖé nyí: Awinnya n wɛ ɖò xɔ nukɔntɔn ɔ mɛ.Nú è na ɖó nùjlɛ́kpá e nyí nǔ ɖagbe é n ɔ, è ɖó na bló awinnya kpíkpé ɖé ɖó kpíkpé n.# >>> make_a_pile.call(3)\n# [3, 5, 7]\ndef make_a_pile(n)\n","canonical_solution":"def make_a_pile(n)\n  result = []\n  current_stones = n\n  n.times do\n    result << current_stones\n    current_stones += 2\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9, 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"},{"task_id":"HumanEval_101","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: bo na klán wuntun ɔ dó xókwin lɛ jí bo na lɛ́ lɛ́ wá xókwin lɛ sín nùxwlé ɖé.È na sɔ́ xókwin lɛ́ɛ dó nùɖé mɛ, bɔ è na ɖó wuntun alǒ tɛn nú ye.# >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n","canonical_solution":"def words_string(s)\n  s.split(\/[\\s,]+\/)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\", \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two, three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"ahmed     , gamal\"))\n  end\nend\n"},{"task_id":"HumanEval_102","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: nú nùjlɛ́nkpa mɔ̌hunkɔtɔn ɖě ma ɖò finɛ ǎ ɔ, azɔ̀ ɔ na lɛ́ lɛ́ kɔ́n -1.nùxwléma ganxixo ɖaxó e ɖò tɛntin [x, y] é.azɔ̀ élɔ́ nɔ́ yí nùxwásá ɖagbe wè x kpo y kpo bó nɔ́ lɛ́ yí nùxwásá ɔ́ sín nùxwásá ɔ́ dó.# >>> choose_num.call(12, 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n","canonical_solution":"def choose_num(x, y)\n  return -1 if x > y\n  # Start looking from the largest number\n  max_even = y.even? ? y : y - 1\n  # Iterate downwards to find the biggest even number\n  max_even.downto(x) do |n|\n    return n if n.even?\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33, 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28, candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1, candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\nend\n"},{"task_id":"HumanEval_103","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: Enyi n hú m ɔ, lɛ́ kɔ́n -1.Zě xósin ɔ yí dó nùxwléma e sɛkpɔ́ mì é jí bo yí dó nùxwléma wexwɛ tɔn mɛ.nùxwlé lɛ sín ayizángbè sín n jɛ m jí (kɔn n kpo m kpo ɖ'emɛ).È na mi nùxwlékpà e nyí nùxwlékpà ɖagbe lɛ́ɛ n kpo m kpo, bɔ azɔ̌ mitɔn wɛ nyí ɖɔ mi na ɖó nùxwlékpà # >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>> rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n# >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n","canonical_solution":"def rounded_avg(n, m)\n  return -1 if n > m\n\n  sum = (n..m).reduce(:+)\n  count = m - n + 1\n  average = (sum.to_f \/ count).round\n  \"0b\" + average.to_i.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1, 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996, 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362, 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7, 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5, 5))\n  end\nend\n"},{"task_id":"HumanEval_104","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: Akpàkpà: Akpàkpà e è na lɛ́ wá é ɔ́, è na sɔ́ dó tito jí.nǔ e ma ɖó nùxixa ɖokpo ǎ é.nùxwléma ɖagbe lɛ́ɛ sín x ɖé ná lɛ́ kɔ́n ɔ́, ná lɛ́ kɔ́n nùxwléma e è ɖè lɛ́ɛ bǐ sín x ɖé.# >>> unique_digits.call([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n","canonical_solution":"def unique_digits(x)\n  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31, 135], candidate.call([135, 103, 31]))\n  end\nend\n"},{"task_id":"HumanEval_105","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: \"Alɔ̌\", \"Hwlɛ\", \"Gbe\", \"Nɔ\", \"Gbɛ\", \"Gbɛtɔ́\", \"Gbɛtɔ́n\", \"Gbɛtɔ́n\", \"Gbɛtɔn\". lɛ́ kɔ́n nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ ɖó tɛn nú nùɖé lɛ́ɛ bǐ ɖò nùɖé lɛ́ɛ mɛ.Nú è na sɔ́ nùjlɛ́kpikpa ɖé dó nùjlɛ́kpikpa ɔ́ mɛ ɔ́, è na ɖè nùjlɛ́kpikpa e ɖò 1 jɛ 9 jí lɛ́ɛ, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length.call([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n","canonical_solution":"def by_length(arr)\n  number_names = {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\"\n  }\n\n  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse\n  filtered_sorted_reversed.map { |num| number_names[num] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"], candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"], candidate.call([9, 4, 8]))\n  end\nend\n"},{"task_id":"HumanEval_106","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: nùxwásá nú i ɔ́ wɛ nyí nùjlɛ́kpo e ɖò 1 jí jɛ i jí é (1 * 2 * ... * i).un bɛ́ sín 1.alǒ nùjlɛ́kpo lɛ sín xota sín 1 jɛ i jí. bo na lɛ́ lɛ́ yí nùjlɛ́jlɛ́ nùjlɛ́jlɛ́n tɔn n tɔn, bɔ nǔ e ɖò nǔjlɛ́jlɛ́ index i tɔn mɛ é nyí nǔjlɛ́jlɛ́ nǔjlɛ́jlɛ́ tɔn i tɔn ɔ́, nú i nyí nǔjlɛ́jlɛ́ nǔjlɛ́jlɛ́ tɔn ɔ́ Zɔ́n azɔ̀ f e nɔ yí n dó nùɖé mɛ é, # >>> f.call(5)\n# [1, 2, 6, 24, 15]\ndef f(n)\n","canonical_solution":"def f(n)\n  (1..n).map do |i|\n    if i.even?\n      (1..i).inject(:*) || 1\n    else\n      (1..i).inject(:+)\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([1, 2, 6, 24, 15], candidate.call(5))\n    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))\n    assert_equal([1], candidate.call(1))\n    assert_equal([1, 2, 6], candidate.call(3))\n  end\nend\n"},{"task_id":"HumanEval_107","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndo 1: nùjlɛ́kpá palindromes e ɖò tɛnkpɔn ɔ mɛ lɛ é wɛ nyí ((1, n), kpodo mɛ lɛ kpo. Nú è na sɔ́ nùjlɛ́kpá e nyí nùjlɛ́kpá ɖagbe é n ɔ, lɛ́ kɔ́n nùjlɛ́kpá e ɖó nùjlɛ́kpá e nyí nùjlɛ́kpá é kpo ée nyí nùjlɛ́kpá ǎ é kpo é # >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\ndef even_odd_palindrome(n)\n","canonical_solution":"def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n\n  [even_count, odd_count]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_108","nl":"fon_Latn","pl":"rb","prompt":"¢óå ð.÷. -123 Ý÷åé ðáñáããåëìáôéêÜ -1, 2 êáé 3. Enyi nùxwásá ɖé nyí nǔglɔ́ ɔ, hǔn wuntun tɔn nukɔntɔn ɔ na nyí nǔglɔ́: nùxwlé lɛ́ɛ e nùxwlé lɛ́ɛ tɔn sín nùxwlé ɔ́ hú 0 é. Wlǎn azɔ̀ count_nums e nɔ yí nùjlɛ́kpà nùjlɛ́kpà lɛ́ɛ tɔn bó nɔ lɛ́ lɛ́ kɔ́n é # >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n# 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n","canonical_solution":"def count_nums(arr)\n  arr.count do |num|\n    num.to_s.chars.map(&:to_i).sum > 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0, 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_109","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: Akpàkpà: Akpàkpà è è ɖè ɔ́ ná ɖó nǔ e nyí nǔɖogbɛ tɔn lɛ é.Nú nùxwlé lɛ́ɛ ma ɖò nǔtí ǎ ɔ́, lɛ́ kɔ yì true jí.bo lɛ́ lɛ́ wá mɔ ɖɔ nǔ ɔ́ nyí nugbǒ; alǒ é lɛ́ wá mɔ ɖɔ nǔ ɔ́ nyí adingban.Nú é kpéwú bo na mɔ nǔ e è ɖè lɛ é gbɔn azɔ̀ e è ɖɔ ɖò tají é gblamɛ ɔ tɛnkpɔn tò tɔn ɖò nùjlɛdonǔwu ɔ mɛ é wɛ nyí nǔɖò 0ɔ ɔ.e na kpò ɖò ali ɖagbe ɔ mɛ.azɔ̀ ɖisiɖisiɖisi ɖokpó sín tinmɛ wɛ nyí ɖɔ è na ɖisi nǔ e ɖò nùjlɛ́jlɛ́ ɔ mɛ lɛ́ɛ bǐ ɖó ɖokpo.A na bló azɔ̀ ɖisiɖisi nú azɔn mɔkpan.azɔ̀ élɔ́ e è nɔ wà dó nǔ e è wlan dó nǔ lɛ́ɛ jí é jí: e sixu mɔ nǔ e è na ɖè nǔ lɛ ɖó alɔkpa ɖé mɛ é gbɔn nǔ elɔ lɛ wiwa gblamɛ:nùxwásá lɛ́ɛ ɖò nùjlɛ́kpá ɔ́ mɛ é ná nyí nùɖé bɔ è na sɔ́ dó nùɖé jí ǎ. azɔ̌ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ ɖɔ Mǐ ɖó nùjlɛ́jlɛ́ 'arr' e nyí nùjlɛ́jlɛ́ nùɖé lɛ́ɛ tɔn N é arr[1], arr[2], ..., arr[N].# >>> move_one_ball.call([3, 4, 5, 1, 2])\n# true\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball.call([3, 5, 4, 1, 2])\n# false\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\ndef move_one_ball(arr)\n","canonical_solution":"def move_one_ball(arr)\n  return true if arr.empty?\n\n  n = arr.size\n  count_rotation_point = 0\n  rotation_index = -1\n\n  (0...n).each do |i|\n    next_index = (i + 1) % n\n    if arr[i] > arr[next_index]\n      count_rotation_point += 1\n      rotation_index = next_index\n    end\n  end\n\n  count_rotation_point <= 1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_move_one_ball\n    candidate = method(:move_one_ball)\n    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))\n    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))\n    assert_equal(false, candidate.call([4, 3, 1, 2]))\n    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))\n    assert_equal(true, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_110","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: E ma nyí mɔ̌ ǎ ɔ, lɛ́ kɔ nú \"ÉÒ\".nú nǔ lɛ́ɛ bǐ ɖò lst1 mɛ ɔ, yí gbè nú \"YES\".Nú è na kpéwú bo ɖyɔ nǔ lɛ ɖò lst1 kpo lst2 kpo tɛntin bo bló bɔ E sɔ́ ɖó dogbó nú nùxámɛ nǔ e è sixu ɖyɔ ɖò lst1 kpo lst2 kpo tɛntin é ǎ.nú è na bló lst1 ɖó nùjlɛ́n e nyí nùjlɛ́n lɛ é sín nùjlɛ́n ɔ kɛɖɛ wɛ é na nyí.bo na ɖɔ ɖɔ emi sixu ɖyɔ nǔ lɛ à jí à jí Ðò nùkanbyɔ elɔ mɛ ɔ, a na bló azɔjlɛ̀ e nɔ yí nùxwlé wè é, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\ndef exchange(lst1, lst2)\n","canonical_solution":"def exchange(lst1, lst2)\n  # Check if lst1 already consists solely of even numbers\n  return \"YES\" if lst1.all?(&:even?)\n\n  # Check if there are at least as many even numbers in lst2\n  # as there are odd numbers in lst1\n  odd_count_lst1 = lst1.count(&:odd?)\n  even_count_lst2 = lst2.count(&:even?)\n\n  odd_count_lst1 <= even_count_lst2 ? \"YES\" : \"NO\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_exchange\n    candidate = method(:exchange)\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))\n    assert_equal(\"NO\", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))\n    assert_equal(\"YES\", candidate.call([5, 7, 3], [2, 6, 4]))\n    assert_equal(\"NO\", candidate.call([5, 7, 3], [2, 6, 3]))\n    assert_equal(\"NO\", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\n    assert_equal(\"YES\", candidate.call([100, 200], [200, 200]))\n  end\nend\n"},{"task_id":"HumanEval_111","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: Enyi wèmá lɛ́ɛ ɖò nǔ ɖokpo ɔ mɛ ɔ, lɛ́ kɔ nú ye bǐ.wema e è nɔ lɛ́ wlan azɔn mɔkpan bɔ è nɔ lɛ́ wlan azɔn mɔkpan é.E na sɔ́ wuntun e nɔ́ xlɛ́ wuntun e è klán ɖó vo nú wuntun kpɛví lɛ́ɛ é ɔ́, lɛ́ yí nǔ e è nɔ ylɔ́ ɖɔ hash é.# >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n","canonical_solution":"def histogram(test)\n  return {} if test.empty?\n\n  count = Hash.new(0)\n\n  test.split.each do |char|\n    count[char] += 1\n  end\n\n  max_count = count.values.max\n  count.select { |_, value| value == max_count }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4}, candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_112","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú A na lɛ́ yí nùkwín e mɛ è na mɔ nǔ e è na mɔ é kpo nǔ e è na mɔ ɖɔ é nyí nugbǒ\/maɖɔmaɖɔ é kpo ɖè é dó kpɔ́n.Hweɖevonu ɔ wɛ è nɔ ylɔ ɖɔ palindrome enyi e nɔ xa gbɔn vo nú ée è nɔ xa gbɔn nukɔn é.bo kpɔ́n ɖɔ xwɛ e è mɔ é nyí palindrome à jí.e na lɛ́ sɔ́ wuntun e ɖò wuntun e ɖò wuntun c mɛ é bǐ dó wuntun s mɛ.azɔ̌ # >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n# >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s, c)\n","canonical_solution":"def reverse_delete(s, c)\n  # Remove all characters in c from s\n  filtered_string = s.delete(c)\n  \n  # Check if the filtered string is a palindrome\n  is_palindrome = filtered_string == filtered_string.reverse\n  \n  # Return the result array\n  [filtered_string, is_palindrome]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\", \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n    assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true], candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"mamma\", \"mia\"))\n  end\nend\n"},{"task_id":"HumanEval_113","nl":"fon_Latn","pl":"rb","prompt":"̆n ɔ́, wuntun e è nɔ ylɔ ɖɔ \"i\" ɔ́ nɔ́ ɖó wuntun e è nɔ ylɔ ɖɔ \"i\" é.wèmá è è ná dó è é.Nǔɖevi ɖokpo ɖokpo i tɔn e è nɔ ɖe tɔ́n é ɖó na nyí nùxíxo nǔɖevi e ɖò nǔɖevi ɔ mɛ é tɔn.E na sɔ́ xɛ́n lɛ́ɛ sín nùxwásá ɖé, bɔ xɛ́n ɖokpo ɖokpo nɔ́ ɖó nùjlɛ́kpo lɛ́ɛ kɛɖɛ, lɛ́ kɔ́n nùxwásá ɖé.# >>> odd_count.call([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n","canonical_solution":"def odd_count(lst)\n  lst.map do |num_str|\n    count = num_str.count('13579')\n    \"the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\", \"314\"]))\n  end\nend\n"},{"task_id":"HumanEval_114","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú nùxwlé lɛ́ɛ.Ɖɔ nùxwléma nùɖé lɛ́ɛ sín nùxwléma ɖé ɔ, kpɔ́n nùxwléma kpɛví kpɛví e nyí nùxwléma e nyí nùxwléma ɖé ǎ é ɖé tɔn é # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n","canonical_solution":"def minSubArraySum(nums)\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    if current_sum > 0\n      current_sum = num\n    else\n      current_sum += num\n    end\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10, candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1, candidate.call([1, -1]))\n  end\nend\n"},{"task_id":"HumanEval_115","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndo 1: Wá azɔn nabi a na dó j'azɔ̌n lɛ́ɛ.azɔ̌ towe wɛ nyí ɖɔ a ni zán kɔ́n lɛ bo dó xú tɔ ɔ́.bo sinkpo lɛ bǐ nɔ ɖó jijɔ ɖokpo ɔ.Hɔn ɖokpo ɖokpo nɔ ɖó go e è sixu zán bo na ɖè sin sín mɛ é,bo 1 ɖokpo ɖokpo ɖo ali ɖokpo ɔ mɛ nɔte nú azɔmɛ ɖokpo sin tɔn.A mɔ tɔjɔtɛn lɛ sín xuxuɖevi ɖokpo ɖokpo.# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n","canonical_solution":"def max_fill(grid, capacity)\n  total_water_units = grid.flatten.sum\n  (total_water_units.to_f \/ capacity).ceil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))\n  end\nend\n"},{"task_id":"HumanEval_116","nl":"fon_Latn","pl":"rb","prompt":"E na bló gbɔn mɔ̀:Nú è na mɔ nú nùjlɛ́jlɛ́ ɖokpo ɔ ɔ́, è na ɖè nǔ lɛ ɖó nǔ e è nɔ ylɔ ɖɔ nǔ wǒzángbè é jí.nùxwásá nú mɛ ɖò nùjlɛ́kpá binary tɔn yetɔn mɛ ɖò nùxwásá jí.Ðò Kata elɔ mɛ ɔ, a ɖó na ɖè nùjlɛ́n e nyí nùjlɛ́n e nyí nùɖé ǎ lɛ é ɖò nùjlɛ́n e nyí nùjlɛ́n e nyí nùjlɛ́n ǎ lɛ é mɛ ɖò nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e nyí nǔ e é nyí nǔ e é nyí nǔ e é nyí nǔ e é nyí nǔ e é nyí nǔ e é nyí nǔ e é nyí nǔ e é nyí é# >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\ndef sort_array(arr)\n","canonical_solution":"def sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"},{"task_id":"HumanEval_117","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Akpàkpà: a sixu ɖɔ ɖɔ xò e è nɔ dó ɔ́ ɖó wlan kpo tɛn kpo kɛɖɛ.Enyi wèmá ɔ́ ɖò mɛ̀ ɔ́, azɔ̀ ɔ́ ɖó na lɛ́ lɛ́ wá ɖó nùɖé ɖò mɛ̀ ǎ.n xó e nɔ ɖò wuntun ɔ mɛ lɛ é, bɔ xógbe enɛ lɛ nɔ wá ɖò wuntun ɔ mɛ s. azɔ̀ e nɔ́ lɛ́ yí xókwín e ɖò wuntun s mɛ lɛ́ɛ bǐ sín nùxwásá ɖé dó éNú è na wlan wuntun s kpo nùxwlémɛ nùjɔnǔ tɔn n kpo ɔ, è na byɔ we ɖɔ a ni bló nǔ elɔ lɛ # >>> select_words.call(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words.call(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words.call(\"simple white space\", 2)\n# []\n# >>> select_words.call(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words.call(\"Uncle sam\", 3)\n# [\"Uncle\"]\ndef select_words(s, n)\n","canonical_solution":"def select_words(s, n)\n  vowels = \"aeiouAEIOU\"\n  words = s.split\n  words.select do |word|\n    consonant_count = word.chars.count { |char| !vowels.include?(char) }\n    consonant_count == n\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([], candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"a b c d e f\", 1))\n  end\nend\n"},{"task_id":"HumanEval_118","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: Mi sixu ɖɔ ɖɔ wuntun e è na é ɔ na ɖó wuntun e è nɔ zán dó wlan xókwin Eŋlisi tɔn lɛ é kɛɖɛ.mɔ̀ xókwin ɖé ɖò xókwin ɔ mɛ bɔ é sɔgbe xá nǔ e ɖò jǐ é.Akɔmasɔgbe ɖo nukɔnmɛ kpo gudo kpo ɔ e nɔ xa ǎ. Bo lɛ́ sɔ́ mɛ e ma nyí mɛ ǎ é.kpɔnnú wè sín akpáxwé ɖisixwé xó ɔ tɔn (wùnnúmɛ e nɔ dó nǔ e ɖò xó ɔ mɛ é wu).È na xó ɖé mi. Azɔ̌ mitɔn wɛ nyí ɖɔ mi na mɔ xókwin e ɖò voxo e ɖò we mɛ é.# >>> get_closest_vowel.call(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n","canonical_solution":"def get_closest_vowel(word)\n  vowels = \"aeiouAEIOU\"\n  (1...word.length - 1).reverse_each do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n      return word[i]\n    end\n  end\n  return \"\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\", candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"Above\"))\n  end\nend\n"},{"task_id":"HumanEval_119","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: E na lɛ́ lɛ́ lɛ́ yí gbè nú xógbe 'Ɛɛn' nú ali ɖé ɖò finɛ bo na bló nùjlɛdonǔwu ɖagbe ɖé ɔ, bo lɛ́ lɛ́ yí gbè nú xógbe 'Ée' nú é ma nyí mɔ̌ ǎ ɔ.\"()) \" nyí ǎ.e nɔ ɖo jlɛjε. ε: xɔntɔn '(()))) ɔ nyɔ, hwenu e xɔntɔn Xò S è nɔ ɖɔ é nyɔ́ nú è na sɔ́ xò S mɛ̀ lɛ́ɛ bǐ dó ganmɛ e na bɔ è na mɔ xɛ ɖagbe ɖé é.azɔ̌ towe wɛ nyí ɖɔ a na kpɔ́n ɖɔ è na kpéwú bo dó wlan xɛ wè lɛ dó wlan mɛ à jíwema e ɖò mɛ é ɖokpo ɖokpo wɛ nɔ nyí \" (\") \"e na wlan wlan we, wlan we lɛ bi ɖo hunhun mɛ# >>> match_parens.call([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n","canonical_solution":"def match_parens(lst)\n  a, b = lst\n\n  # Define a helper method to check if a string is balanced\n  def balanced?(s)\n    count = 0\n    s.each_char do |c|\n      count += 1 if c == '('\n      count -= 1 if c == ')'\n      return false if count < 0\n    end\n    count == 0\n  end\n\n  # Check if either concatenation forms a good string\n  if balanced?(a + b) || balanced?(b + a)\n    \"Yes\"\n  else\n    \"No\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\")())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"(()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n    assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\")(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"},{"task_id":"HumanEval_120","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndo 1: e nɔ nyí k bɔ è nɔ mɔ nú nùjlɛ́kpo k ɖò arr mɛ é.E na sɔ́ nùxwléma e nyí nùjlɛ́kpá lɛ́ɛ sín nǔ lɛ́ɛ dó nùxwléma e nyí nùjlɛ́kpá ɖagbe lɛ́ɛ k ɔ́ jí ɔ́, lɛ́ yí nùxwléma e è ɖè ɖó alɔkpa jí é ɖé dó.# >>> maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n","canonical_solution":"def maximum(arr, k)\n  arr.sort.last(k).sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n    assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10], candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))\n  end\nend\n"},{"task_id":"HumanEval_121","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú E na bo na lɛ́ ná nùjlɛ́kpó e nyí nùjlɛ́kpó e ma nyí nǔtí ǎ é ɔ́, lɛ́ yí nùjlɛ́kpó nǔ e nyí nǔtí ǎ lɛ́ɛ bǐ tɔn e ɖò tɛn e nyí nǔtí ǎ lɛ́ɛ é mɛ é.# >>> solution.call([5, 8, 7, 1])\n# 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24, 321])\n# 0\ndef solution(lst)\n","canonical_solution":"def solution(lst)\n  lst.each_with_index.reduce(0) do |sum, (val, idx)|\n    (idx.even? && val.odd?) ? sum + val : sum\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7, 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0, candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30, 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"},{"task_id":"HumanEval_122","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: nǔ e nɔ́ nyí nǔ e ɖò nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nɔ nyí nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nɔ nyí nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nɔ nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é sín nǔ e nyí nǔ nukɔntɔn ɔ́ mɛ é.E na bo na w'azɔ̌n e nyí nùɖé ǎ é ɖé lɛ́ɛ ɔ́, bo na w'azɔ̌n e nyí nùɖé ǎ lɛ́ɛ ɔ́, bo na lɛ́ w'azɔ̌n e nyí nùɖé ǎ lɛ́ɛ é ɔ́, lɛ́ kɔ yì # >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k)\n","canonical_solution":"def add_elements(arr, k)\n  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"},{"task_id":"HumanEval_123","nl":"fon_Latn","pl":"rb","prompt":"get_odd_collatz(5) lɛ́ lɛ́ kɔ́ [1, 5] # Akɔ́n e è nɔ ylɔ́ ɖɔ collatz nú 5 ɔ́ nyí [5, 16, 8, 4, 2, 1], enɛ ɔ́, nùxwléma e nyí kwín ɖokpo lɛ́ɛ wɛ nyí 1 kpo 5. Ði kpɔ́ndéwú ɔ: 2. è ɖè nùxwlé lɛ́ɛ ɖó alɔkpa ɖò jíjló jí.1. Collatz(1) wɛ nyí [1]. Akpádo:xìnxín + 1 ɔ́' è nɔ ɖɔ ɖɔ nú n' ɖò nǔ ɖebǔ mɛ ɔ' nù lɛ́ɛ nɔ́ yì 1 hwebǐnu.Nú akpáxwé e jɛ nukɔn é nyí nǔmaɖinǔ ɔ, akpáxwé e bɔ d'é jí ɔ nyí 3 azɔn ée jɛ nukɔn é tɔn.nukɔnmɛ tɔn ɔ nɛ: enyi nukɔnmɛ tɔn ɔ nyí ganmɛ ɔ, nukɔnmɛ tɔn ɔ na nyí akpáxwé ɖokpo ɔ tɔne na nyi: bɛ ɔ kpodo xwɛ e nyi nuɖevi n lɛ kpo. Enɛ ɔ gudo ɔ, è na mɔ mɛ ɖokpo ɖokpo sín Collatz sín nùxwlémɛ ɔ wɛ nyí nùxwlémɛ ɖò matimátikunmɛ mɛ bɔ é kan nǔɖevonu ɖé wu.E na mɔ nùxwléma ɖagbe ɖé n ɔ, lɛ́ kɔ́n nùxwléma e è ɖè ɖó alɔkpa tɔn lɛ é ɖó ɖò nùxwléma e ɖò collatz sín tito jí lɛ é mɛ. # >>> get_odd_collatz.call(5)\n# [1, 5]\ndef get_odd_collatz(n)\n","canonical_solution":"def get_odd_collatz(n)\n  collatz_sequence = []\n  while n != 1\n    collatz_sequence << n if n.odd?\n    if n.even?\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n  end\n  collatz_sequence << 1 if n == 1\n\n  collatz_sequence.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_odd_collatz\n    candidate = method(:get_odd_collatz)\n    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))\n    assert_equal([1, 5], candidate.call(5))\n    assert_equal([1, 3, 5], candidate.call(12))\n    assert_equal([1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_124","nl":"fon_Latn","pl":"rb","prompt":"4. Azǎn ɔ ɖó na ɖò wuntun elɔ mɛ: mm-dd-yyyy 3. sun lɛ na nɔ hwe na 1 bo na nɔ syɛn na 12 ǎ.2. ě sɔ́ azǎn lɛ́ɛ ɖò azǎn 1 jí ǎ, alǒ hú azǎn 31 ɖò sun 1,3,5,7,8,10,12 lɛ́ɛ mɛ ǎ. ě sɔ́ azǎn lɛ́ɛ ɖò azǎn 1 jí ǎ, abǐ hú azǎn 30 ɖò sun 4,6,9,11 lɛ́ɛ mɛ ǎ. ě sɔ́ azǎn lɛ́ɛ ɖò azǎn 1 jí ǎ, abǐ hú azǎn 29 ɖò sun 2 mɛ ǎ.1. Azǎn ɔ́ ɖò mɛ̀ ă.Azǎn ɔ na nyí gbè ɖagbe nú è na bló sɔgbe xá nugbodòdó elɔ lɛ bǐ: e na lɛ́ yí gbè nú nugbǒ nú azǎn ɔ sɔgbe é, enyi é ma nyí mɔ̌ ǎ ɔ é na lɛ́ yí gbè nú adingban. A ɖo na wlan azɔ na ɖe hun hun e è na wlan ɔ bo ɖɔ # >>> valid_date.call(\"03-11-2000\")\n# true\n# >>> valid_date.call(\"15-01-2012\")\n# false\n# >>> valid_date.call(\"04-0-2040\")\n# false\n# >>> valid_date.call(\"06-04-2020\")\n# true\n# >>> valid_date.call(\"06\/04\/2020\")\n# false\ndef valid_date(date)\n","canonical_solution":"def valid_date(date)\n  return false if date.nil? || date.empty?\n  \n  # Check if the date format is correct\n  match = date.match(\/^(\\d{2})-(\\d{2})-(\\d{4})$\/)\n  return false unless match\n  \n  month, day, year = match.captures.map(&:to_i)\n  \n  # Check if month is valid\n  return false if month < 1 || month > 12\n  \n  # Check if day is valid according to the month\n  case month\n  when 1, 3, 5, 7, 8, 10, 12\n    return day >= 1 && day <= 31\n  when 4, 6, 9, 11\n    return day >= 1 && day <= 30\n  when 2\n    return day >= 1 && day <= 29\n  else\n    return false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_valid_date\n    candidate = method(:valid_date)\n    assert_equal(true, candidate.call(\"03-11-2000\"))\n    assert_equal(false, candidate.call(\"15-01-2012\"))\n    assert_equal(false, candidate.call(\"04-0-2040\"))\n    assert_equal(true, candidate.call(\"06-04-2020\"))\n    assert_equal(true, candidate.call(\"01-01-2007\"))\n    assert_equal(false, candidate.call(\"03-32-2011\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"04-31-3000\"))\n    assert_equal(true, candidate.call(\"06-06-2005\"))\n    assert_equal(false, candidate.call(\"21-31-2000\"))\n    assert_equal(true, candidate.call(\"04-12-2003\"))\n    assert_equal(false, candidate.call(\"04122003\"))\n    assert_equal(false, candidate.call(\"20030412\"))\n    assert_equal(false, candidate.call(\"2003-04\"))\n    assert_equal(false, candidate.call(\"2003-04-12\"))\n    assert_equal(false, candidate.call(\"04-2003\"))\n  end\nend\n"},{"task_id":"HumanEval_125","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú wlan, wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔ => wlan ɔe ɖó na klán ɖò xwɛ́ ',' nú xwɛ́ ɖě ma ɖò ǎ ɔ, a ɖó na lɛ́ lɛ́ nú xwɛ́ kpɛví kpɛví e ɖò xwɛ́ kpɛví mɛ lɛ́ɛ ɖò xwɛ́ kpɛví mɛ é ɖò xwɛ́ kpɛví mɛ.nùkwín xókwín ɖé ɔ́, na lɛ́ lɛ́ lɛ́ kɔ̀ xókwín ɖé lɛ́ɛ dó nùkwín e è má ɖó nùkwín lɛ́ɛ é jí, nú nùkwín lɛ́ɛ ɖě ma ɖò wèmá e a sɔ́ ɖó ɔ́ mɛ ǎ ɔ́.# >>> split_words.call(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n","canonical_solution":"def split_words(txt)\n  if txt.include?(' ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }\n    return odd_count\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2, candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n    assert_equal(0, candidate.call(\"\"))\n  end\nend\n"},{"task_id":"HumanEval_126","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú nùmε, lɛkɔ false. Nɔ kpɔn ɖɔ nùmε e nyi do ǎ bo na nɔ nyi nuɖeji kpowun.nú nǔ lɛ́ɛ ɖò jí jɛ jí ɔ́, nú nǔ lɛ́ɛ ɖò jí jɛjí hú mɛ ɖokpó ɔ́ ɔ́,Nú è na sɔ́ nùjlɛ́jlɛ́ lɛ́ɛ dó nùxwásá ɔ́ mɛ ɔ́, è na lɛ́ sɔ́ yě dó nùxwásá ɔ́ mɛ à jí ǎ.# >>> is_sorted.call([5])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>> is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n","canonical_solution":"def is_sorted(lst)\n  lst.each_cons(2).with_index do |(a, b), index|\n    return false if a > b\n    return false if index < lst.length - 2 && a == b && lst[index + 2] == b\n  end\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true, candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false, candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_127","nl":"fon_Latn","pl":"rb","prompt":"[kpɔnú\/kpɔnú] kpɔ́n: Enyi tɛnkpɔn wè lɛ ma ɖò nǔ ɖokpo ɔ mɛ ǎ ɔ, lɛ́ kɔ nú \"ÉÒ\".enyi é ma nyí mɔ̌ ǎ ɔ, lɛ́ kɔ nú \"ÉÒ\".Nú wuntun ɔ sín hùn nyí nùjlɛ́jlɛ́ nukɔn nukɔntɔn ɔ, lɛ́ yí gbè nú \"YES\", e nɔ nyí 1 é nyí nùjlɛ́kpo nukɔn nukɔntɔn ɖé ǎ.Kpɔ́ndéwú ɔ, fí e tɛnkpɔn lɛ (1, 3), (2, 4) nɔ gbɔn é wɛ nyí (2, 3) nùxwásá ɖé wɛ nyí númɛ̀ nùjlɛ́jlɛ́ tɔn.azɔ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ̀ ɖɔ̀ we enɛ lɛ sín hùn e ɖekpo wɛ é nyí éƉó nú tɛnkpɔn ɖokpo ɖokpo ɔ, è nɔ ɖi ɖɔ tɛnkpɔn ɔ sín bɛ́ wɛ nyí kpɛví alǒ cí fí e é wá yì é.e nɔ lɛ́ ɖó fí e è jɛ nǔ lɛ é kpo fí e è wá fó é kpo.Hweɖokpo e è na lɛ é na nyí mɛ̀, enɛ ɔ́ wɛ nyí ɖɔ hweɖokpo ɔ (bɛ́, fó) fí e tɛnkpɔnmɛ ɖokpo ɖokpo nyí nùxwɛ́ e nyí nùjlɛ́kpɔnmɛ lɛ é sín wè é. Cɔ́nkpɔnmɛ ɔ, tɛnkpɔnmɛ = (bɛ́, fó) = (1, 2).È na we tɛn wè,# >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\ndef intersection(interval1, interval2)\n","canonical_solution":"def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n\n  if intersection_start > intersection_end\n    return \"NO\"\n  end\n\n  intersection_length = intersection_end - intersection_start + 1\n\n  return \"YES\" if prime?(intersection_length)\n\n  \"NO\"\nend\n\ndef prime?(n)\n  return false if n <= 1\n  return true if n == 2 || n == 3\n\n  (2..Math.sqrt(n).to_i).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1, 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2, 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\", candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2, -2], [-3, -2]))\n  end\nend\n"},{"task_id":"HumanEval_128","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: Akpá: lɛ́ kɔ́n nil nú nùɖé ɖò mɛ ǎ ɔ́.nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú núnùxwásá e nyí nùjlɛ́kpá lɛ́ɛ sín nùjlɛ́kpá e è sɔ́ nùjlɛ́kpá lɛ́ɛ bǐ sín nǔkún dó ná é e na lɛ́ lɛ́ yí nùjlɛ́n e è ná lɛ́ ɖó lɛ́ɛ é sín nùjlɛ́n ɔ́ dó nùjlɛ́n ɔ́ mɛ.# >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n# >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n","canonical_solution":"def prod_signs(arr)\n  return nil if arr.empty?\n  \n  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }\n  sum_magnitudes = arr.map(&:abs).sum\n  \n  product_signs * sum_magnitudes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"},{"task_id":"HumanEval_129","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: E nɔ lɛ́ yí nùɖé lɛ́ɛ sín nùxwlé lɛ́ɛ dó nùxwlé lɛ́ɛ jí bɔ ali e jí è nɔ gbɔn dín é nɔ́ lɛ́ kɔ́n.E nɔ mɔ ɖɔ xósin ɔ nɔ nyí ɖokpo ɔ.lst_A[j] = lst_B[j].e nɔ nyi lst_A[i] < lst_B[i] bo bo na j (1 <= j < i) ɔ e nɔ nyi hú lst_B, ɖò xó ɖevo mɛ ɔ, nùxwlé lɛ́ɛ ɖò nùxwlé lɛ́ɛ mɛ i (1 <= i <= k) lst_A kpo lst_B kpo wɛ mǐ na ylɔ́ ɖɔ lst_A, lst_A ɔ́, xókwin tɔn lɛ́ɛ nɔ́ ɖɔ nǔ kpɛɖé.e na bló nùxwlé lɛ́ɛ ɔ́, nǔ e è na wlan dó xú lɛ́ɛ jí ɔ́, nǔ e è na wlan dó xú lɛ́ɛ jí ɔ́ wɛ nyí ɖɔ A kpo B kpo ná yì Ali e nyí A (e lín dó k é) ɔ è nɔ mɔ ɖɔ é vlɔ́ hú ali e nyí B (e lín dó k é) nú A SƆ́ na bú ɖò fí e è nɔ mɔ nǔ ɖè é ǎ.é nɔ ɖó na nyí nǔ e è sixu ɖè yeɖée sín mɛ é ǎ).Mi nywɛ ɖɔ ali e nyi kpodo ayi kpo kε ɔ na ɖɔ ɖɔ mi na yi bo kpɔ́n bunɔ k (e ma nyí ɖɔ mi na kpɔ́n bunɔ azɔn ɔ.é ɖɔ ɖɔ, a sixu yì nùvò e nɔ ɖó xósusu ɖokpo ɔ xá towe lɛ é mɛbo ɖo tɛn ɖokpo ɖokpo mɛ ɔ a sixu yì tɛn e nɔ sɛkpɔ mɛ é ɖokpo ɖokpo mɛ,A na mɔ ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpodo ali e na yì nukɔn ɖò ali ɔ jí é kpoe nɔ tɔ́n azɔn ɖokpo ɖò xɔ lɛ́ɛ mɛ ɖò nùxwásá ɔ́ mɛ.azɔmε ɖokpo ɖokpo ɖo nuvi ɔ mε ɔ, e nɔ hɛn jijɔ ɖokpo ɖokpo ɖo nuvi ɔ mε.E na bo na w'azɔ̌n e ɖó xota N kpo kpo kpo kpo kpo kpo (N >= 2) bo na ɖó nùjlɛ́kpá e nyí nǔ ɖagbe é k ɔ, # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid, k)\n","canonical_solution":"def minPath(grid, k)\n  n = grid.size\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  min_path = nil\n\n  n.times do |i|\n    n.times do |j|\n      queue = [[[i, j], [grid[i][j]]]]\n      until queue.empty?\n        position, path = queue.shift\n        if path.size == k\n          min_path = path if min_path.nil? || path < min_path\n          next\n        end\n        directions.each do |dx, dy|\n          x, y = position[0] + dx, position[1] + dy\n          if x.between?(0, n-1) && y.between?(0, n-1)\n            queue.push([[x, y], path + [grid[x][y]]])\n          end\n        end\n      end\n    end\n  end\n  min_path\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"},{"task_id":"HumanEval_130","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: nùxwásá n + 1 nukɔntɔn lɛ́ɛ ɖò tito Tribonacci tɔn mɛ.è na na mi nùxwléma e nyí nùɖé ǎ é n, mi ɖó na lɛ́ yí nùxwléma e nyí nùxwléma ɔ tɔn é= 2 + 3 + 3 = 8 3ì3í3÷í3 ôîðìû = 3ì3í3÷í3 ôîðìû + 3ì3í3÷í3 ôîðìû + 3ì3í3÷í3 ôîðìû (4)tri(4) = 3 tri(2) = 1 + (2 \/ 2) = 2 Ði kpɔ́ndéwú ɔ: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), enyi n nyí nùxwlé. tri ((n) = 1 + n \/ 2, enyi n nyí mɛ wè.tri(1) = 3 Tribonacci sín nùxwlé lɛ́ɛ nɔ́ nyí:Amɔ̌, nǔ e mɛ lɛ ma tuùn ǎ ɔ wɛ nyí tito Tribonacci tɔn.Mɛ bǐ tuùn nǔ e è nɔ ylɔ ɖɔ Fibonacci sín nùjlɛ́jlɛ́ é, mɛxwématɔ́n lɛ́ɛ kplɔ́n nǔ dó nǔ enɛ jí ɖò xwè kanweko ɔ mɛ.# >>> tri.call(3)\n# [1, 3, 2, 8]\ndef tri(n)\n","canonical_solution":"def tri(n)\n  sequence = [1, 3]\n  \n  (2..n).each do |i|\n    if i.even?\n      sequence[i] = 1 + i \/ 2\n    else\n      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0\n    end\n  end\n  \n  sequence[0..n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n    assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_131","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: Zɔ́n 0 nú wèmá lɛ́ɛ bǐ nyí ganmɛ. Ɖó è na wlan nùjlɛ́kpá ɖagbe ɖé n ɔ, lɛ́ kɔ́n nùjlɛ́kpá e è nɔ zán nú nùjlɛ́kpá e nyí nǔ ɖokpo lɛ é sín nùjlɛ́kpá. # >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n# 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n","canonical_solution":"def digits(n)\n  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }\n  return 0 if odd_digits.empty?\n  odd_digits.reduce(:*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5, candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5, candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625, candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"},{"task_id":"HumanEval_132","nl":"fon_Latn","pl":"rb","prompt":"e ɖo atɛ ɖokpo ɖo nukun tɔn ɔ mɛ ɔ e nɔ ɖo yeɖée mɛ.azɔ̀ ɔ́ ɖó na lɛ́ kɔ́n true nú è ɖò nùɖé lɛ́ɛ wlan wɛ ɖò wuntun lɛ́ɛ mɛ ɔ́ jɛ́n é ná nyí.Ðɔ azɔ̀ e nɔ yí xɛ̀n e nɔ ɖó wuntun lɛ́ɛ kɛɖɛ dó mɛ é.# >>> is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n# false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n# false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\")\n# true\ndef is_nested(string)\n","canonical_solution":"def is_nested(string)\n  stack = []\n  has_nested = false\n\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n    elsif char == ']'\n      if stack.empty?\n        return false\n      end\n      stack.pop\n      has_nested = true if stack.any?\n    end\n  end\n\n  has_nested\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false, candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n    assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false, candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n    assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"[[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"))\n  end\nend\n"},{"task_id":"HumanEval_133","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: mi na dó lɛ́ɛ́n nǔ lɛ́ɛ ɖokpó ɖokpó dó ta ɔ́ mɛ̀ jɛ̀ ɔ́ jí hwɛ̌.A na lɛ́ yí nùjlɛ́kpo e è sɔ́ dó zɔ́n amyɔ e è ná lɛ́ ná é sín nǔ lɛ́ɛ ɖóɖó, È na nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ ɖé lɛ́ɛ we.# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0, 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4, 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map { |num| (num.ceil)**2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0, 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))\n  end\nend\n"},{"task_id":"HumanEval_134","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Akpá: \"gbe\" ɔ wuntun lɛ sín ahwan wɛ bɔ è nɔ ɖe tɛn ɖó vo nú ye.xó ɖé sín akpáxwé wɛ, bɔ nǔ ɖevo lɛ bǐ nyí nǔvú.wèmá è è wèmá è è wèmá è è wèmá è è wèmá è è wèmá è è wèmá è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è è èÐɔ azɔ̀ e na lɛ́ yí gbè nú nugbǒ nú wuntun gudo tɔn ɔ́ # >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n","canonical_solution":"check_if_last_char_is_a_letter = ->(txt) {\n  return false if txt.strip.empty?\n  words = txt.strip.split(' ')\n  last_word = words.last\n  return false if last_word.empty?\n  last_char = last_word[-1]\n\n  last_char =~ \/[a-zA-Z]\/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')\n}","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false, candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false, candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false, candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple pi e \"))\n  end\nend\n"},{"task_id":"HumanEval_135","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: nùjlɛdonǔwu lɛ́ɛ ɖò wè wè wè.nùɖé tíìn ǎ ɔ́, é ná lɛ́ kɔ́n -1.e nyi nuvεn e ɖo nukɔn tɔn tlolo ɔ a nyi nuvεn e nyi nukɔn tɔn tlolo ɔ a nyi nuvεn e ɖo nukɔn tɔn tlolo ɔ a.Ðɔ azɔ̀ e na lɛ́ lɛ́ sín nǔɖókpɔ́ e nyí nǔɖókpɔ́ ɖaxó hugǎn é ɖé sín nùɖé é# >>> can_arrange.call([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange.call([1, 2, 3])\n# -1\ndef can_arrange(arr)\n","canonical_solution":"def can_arrange(arr)\n  (1...arr.length).reverse_each do |i|\n    return i if arr[i] < arr[i - 1]\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_can_arrange\n    candidate = method(:can_arrange)\n    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))\n    assert_equal(-1, candidate.call([1, 2, 4, 5]))\n    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))\n    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))\n    assert_equal(-1, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_136","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Nú nùɖé ma ɖò nùjlɛ́kpá nú nùɖé ǎ ɔ, è na lɛ́ sɔ́ yě dó ɖó nǔtí ǎ.e nɔ ɖɔ nùxixa ɖagbe lɛ ɖò nùxwléma ɖé mɛ.nùxwléma ayihun lɛ́ɛ bǐ ɔ́' b' wɛ nyí kpɛví ɔ́Ðɔ azɔ̀ e nɔ lɛ́ yí nùxwlé (a, b) ɔ́, fí e 'a' nyí # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n# [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n","canonical_solution":"def largest_smallest_integers(lst)\n  largest_negative = nil\n  smallest_positive = nil\n  \n  lst.each do |num|\n    if num < 0\n      largest_negative = num if largest_negative.nil? || num > largest_negative\n    elsif num > 0\n      smallest_positive = num if smallest_positive.nil? || num < smallest_positive\n    end\n  end\n  \n  [largest_negative, smallest_positive]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil, nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))\n  end\nend\n"},{"task_id":"HumanEval_137","nl":"fon_Latn","pl":"rb","prompt":"Ðɛ́n: Nú è sɔ́ nùjlɛ́kpá ɖé dó ɖè wèmá wèmá ɖé ɖɔhun ɔ, wèmá flífítɔ́ ɔ́ sixu nyí . alǒ , E na lɛ́ lɛ́ yí nǔvò nú nùɖé ǎ nú nùɖé lɛ́ɛ cí. nùjlɛ́kpà lɛ́ɛ, bo na lɛ́ yí nùɖé lɛ́ɛ sín jijɛ ɖò nùɖé lɛ́ɛ sín alɔkpa e è na lɛ́ ná é mɛ.Ðɔ azɔ̀ e nɔ yí nùxixa, nùxà ɖò jɔhɔn jí, alǒ xɛ́ lɛ́ɛ e nɔ ɖè # >>> compare_one.call(1, 2.5)\n# 2.5\n# >>> compare_one.call(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one.call(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one.call(\"1\", 1)\n# nil\ndef compare_one(a, b)\n","canonical_solution":"def compare_one(a, b)\n  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')\n  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')\n\n  if a.is_a?(String) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Float)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Float)\n    a = a.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Integer)\n    b = b.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Float)\n    b = b.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(String)\n    a = a.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  else\n    return nil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare_one\n    candidate = method(:compare_one)\n    assert_equal(2, candidate.call(1, 2))\n    assert_equal(2.5, candidate.call(1, 2.5))\n    assert_equal(3, candidate.call(2, 3))\n    assert_equal(6, candidate.call(5, 6))\n    assert_equal(\"2,3\", candidate.call(1, \"2,3\"))\n    assert_equal(\"6\", candidate.call(\"5,1\", \"6\"))\n    assert_equal(\"2\", candidate.call(\"1\", \"2\"))\n    assert_equal(nil, candidate.call(\"1\", 1))\n  end\nend\n"},{"task_id":"HumanEval_138","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú Kpɔ́n ɖɔ nùjlɔ́mε e è na wlan n ɔ sixu nyí nùjlɔ́mε e è na wlan ɖó nùjlɔ́mε e nyí nùjlɔ́mε wè ɖò jí lɛ é sín nǔxomɔ à jí.# >>> is_equal_to_sum_even.call(4)\n# false\n# >>> is_equal_to_sum_even.call(6)\n# false\n# >>> is_equal_to_sum_even.call(8)\n# true\ndef is_equal_to_sum_even(n)\n","canonical_solution":"def is_equal_to_sum_even(n)\n  return false if n < 8\n  n.even?\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_equal_to_sum_even\n    candidate = method(:is_equal_to_sum_even)\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(8))\n    assert_equal(true, candidate.call(10))\n    assert_equal(false, candidate.call(11))\n    assert_equal(true, candidate.call(12))\n    assert_equal(false, candidate.call(13))\n    assert_equal(true, candidate.call(16))\n  end\nend\n"},{"task_id":"HumanEval_139","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: fí e n > 0 ɖè ébrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! Brazil tɔn ɔ e nɔ ɖɔ ɖɔ: # >>> special_factorial.call(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\ndef special_factorial(n)\n","canonical_solution":"def special_factorial(n)\n  return 1 if n <= 1\n  (1..n).inject(1) { |product, i| product * factorial(i) }\nend\n\ndef factorial(num)\n  return 1 if num <= 1\n  (2..num).inject(1, :*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n    assert_equal(1, candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_140","nl":"fon_Latn","pl":"rb","prompt":"bo sɔ́ -  dó ɖyɔ́ tɛn e ɖò lɛ́ɛ bǐbo enyi xwɛ ɖokpo ɖó tɛnvi wè e nɔ ɖò jijimɛ lɛ é hú ɔ, E na sɔ́ wèmá ɔ́ sín xɛ́ lɛ́ɛ bǐ dó wèmá e è nɔ ɖó wèmá e è nɔ ɖó wèmá e è nɔ ɖó wèmá e è nɔ ɖó wèmá e è nɔ ɖó wèmá e lɛ́ɛ é jí,# >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n","canonical_solution":"def fix_spaces(text)\n  text.strip.gsub(\/\\s{3,}\/, '-').gsub(' ', '_')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2 2 mple\"))\n  end\nend\n"},{"task_id":"HumanEval_141","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: - Hwe e ɖò dot ɔ gudo é ɖó na nyí ɖokpo ɖò elɔ lɛ mɛ: ['txt', 'exe', 'dll'] wèmá-wlámá Latɛ́n tɔn lɛ́ɛ ('a'-'z' kpo 'A'-'Z') - Wema e ɖò nukɔn nú dot ɔ ɖó na nyí nǔtí ǎ, bɔ é ka na bɛ́ ɖò wèmá  tɔn jí.- Hɔnkpɔn ɔ sín nyikɔ ɔ ɖ'akpá ɖokpo ɖokpo mɛ.'- Ðèñóíîê äîëæåí èìåòü íå áîëüøå 3 çíà÷åê (\"0\" - \"9\"). e nɔ kpé: Akɔɖε ɔ sín nyikɔ nɔ nyí ɖagbe enyi bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na bo na.'Ɛɛn' nú nyikɔ ɔ sɔgbe, bo na lɛ́ lɛ́ yí gbè nú 'Ée' nú é ma sɔgbe ǎ.Ðɔ azɔ̀ e nɔ yí wèmá e nɔ ɖè nùxwásá ɔ sín nyikɔ xlɛ́ é, bo nɔ lɛ́ lɛ́ kɔ́n # >>> file_name_check.call(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check.call(\"1example.dll\")\n# \"No\"\ndef file_name_check(file_name)\n","canonical_solution":"def file_name_check(file_name)\n  # Check if there's exactly one dot in the filename\n  return 'No' unless file_name.count('.') == 1\n  \n  # Split the filename into the name and extension\n  name, extension = file_name.split('.')\n  \n  # Check if the name part starts with a letter\n  return 'No' if name.empty? || !name[0].match?(\/[a-zA-Z]\/)\n  \n  # Check if the extension is valid\n  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)\n  \n  # Count digits in the file name\n  digit_count = file_name.count(\"0-9\")\n  \n  # Check if digits are more than three\n  return 'No' if digit_count > 3\n  \n  'Yes'\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_file_name_check\n    candidate = method(:file_name_check)\n    assert_equal(\"Yes\", candidate.call(\"example.txt\"))\n    assert_equal(\"No\", candidate.call(\"1example.dll\"))\n    assert_equal(\"No\", candidate.call(\"s1sdf3.asd\"))\n    assert_equal(\"Yes\", candidate.call(\"K.dll\"))\n    assert_equal(\"Yes\", candidate.call(\"MY16FILE3.exe\"))\n    assert_equal(\"No\", candidate.call(\"His12FILE94.exe\"))\n    assert_equal(\"No\", candidate.call(\"_Y.txt\"))\n    assert_equal(\"No\", candidate.call(\"?aREYA.exe\"))\n    assert_equal(\"No\", candidate.call(\"\/this_is_valid.dll\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.wow\"))\n    assert_equal(\"Yes\", candidate.call(\"this_is_valid.txt\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.txtexe\"))\n    assert_equal(\"No\", candidate.call(\"#this2_i4s_5valid.ten\"))\n    assert_equal(\"No\", candidate.call(\"@this1_is6_valid.exe\"))\n    assert_equal(\"No\", candidate.call(\"this_is_12valid.6exe4.txt\"))\n    assert_equal(\"No\", candidate.call(\"all.exe.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"I563_No.exe\"))\n    assert_equal(\"Yes\", candidate.call(\"Is3youfault.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"no_one#knows.dll\"))\n    assert_equal(\"No\", candidate.call(\"1I563_Yes3.exe\"))\n    assert_equal(\"No\", candidate.call(\"I563_Yes3.txtt\"))\n    assert_equal(\"No\", candidate.call(\"final..txt\"))\n    assert_equal(\"No\", candidate.call(\"final132\"))\n    assert_equal(\"No\", candidate.call(\"_f4indsartal132.\"))\n    assert_equal(\"No\", candidate.call(\".txt\"))\n    assert_equal(\"No\", candidate.call(\"s.\"))\n  end\nend\n"},{"task_id":"HumanEval_142","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: ɖyɔ́ nùjlɛ́n lɛ́ɛ ɖò nùjlɛ́n ɔ́ mɛ bɔ nùjlɛ́n lɛ́ɛ tɔn nyí 3 alǒ 4 sín nùjlɛ́n ǎ. azɔ̀ ɔ́ na lɛ́ lɛ́ kɔ nú nùjlɛ́n lɛ́ɛ bǐ.nùxíɖókpɔ́ 3 tɔn ɔ́' é ná sɔ́ nùxíɖókpɔ́ ɔ́ dó ɖó wuntun nú nùxíɖókpɔ́ ɔ́' nú wuntun tɔn nyí nùxíɖókpɔ́ 4 tɔn é nyí nùxíɖókpɔ́ 3 tɔn ǎ ɔ́' azɔ̀ ɔ́ ná sɔ́ ǎazɔ̀ élɔ́ ná yí nùxwlé lɛ́ɛ sín nùxwlé ɖé. nú nùxwlé lɛ́ɛ bǐ ɔ́, azɔ̀ ɔ́ na sɔ́ nùxwlé lɛ́ɛ sín nùxwlé ɔ́ sín kwɛ́ɛ́ nú nùxwlé ɔ́' nú nùxwlé ɔ́ nyí a.\" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map.with_index do |num, index|\n    if index % 3 == 0\n      num ** 2\n    elsif index % 4 == 0\n      num ** 3\n    else\n      num\n    end\n  end.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(6, candidate.call([1, 2, 3]))\n    assert_equal(14, candidate.call([1, 4, 9]))\n    assert_equal(0, candidate.call([]))\n    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n    assert_equal(0, candidate.call([0]))\n    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))\n    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))\n    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))\n    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))\n    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))\n  end\nend\n"},{"task_id":"HumanEval_143","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndo 1: xókwin lɛ́ɛ ɖò wuntun yɔyɔ́ ɔ́ mɛ́ ɖó ná cí xókwin nukɔntɔn ɔ́ ɖɔhun.e sín hùn nyí nùxwásún nukɔn nukɔntɔn lɛ é, bo na lɛ́ lɛ́ lɛ́ wá xwɛ e mɛ xókwin e ɖò xwɛ ɔ́ mɛ é ɖè é, xókwin ɖé lɛ ɖò nuɖe ɔ mɛ bɔ nuɖe ɔ nɔ zɔ́n nú xókwin ɖé lɛ, È na wlan nùjlɛdonǔwu e nɔte nú xógbe ɖé nú we, # >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n","canonical_solution":"def words_in_sentence(sentence)\n  def is_prime?(num)\n    return false if num <= 1\n    (2..Math.sqrt(num)).none? { |i| num % i == 0 }\n  end\n  \n  words = sentence.split(\" \")\n  prime_length_words = words.select { |word| is_prime?(word.length) }\n  prime_length_words.join(\" \")\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"))\n  end\nend\n"},{"task_id":"HumanEval_144","nl":"fon_Latn","pl":"rb","prompt":"A sixu ɖɔ ɖɔ x, kpo n kpo ɔ nuvò e jɛxa lɛ wɛ bo ma ɖó nuvɔ́ dó nuvò mɛ ǎ.ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèé ðàñïðîñòðàíÿþùèéx kpo n kpo we lɛ ɔ, ye nyi aklunɔzoli nuɖe bo nɔ nyi aklunɔzoli elɔ:x * n. azɔ̀ ɔ́ ná lɛ́ wá nyí nugbǒ nú x * n nɔ́ nyí nùjlɔ́mε ɔ́ bǐ bɔ false azɔ towe wɛ nyí ɖɔ a na bló azɔ̀ e na bló bɔ xógbe ɔ na bɔ́n ɔ́# >>> simplify.call(\"1\/5\", \"5\/1\")\n# true\n# >>> simplify.call(\"1\/6\", \"2\/1\")\n# false\n# >>> simplify.call(\"7\/10\", \"10\/2\")\n# false\ndef simplify(x, n)\n","canonical_solution":"def simplify(x, n)\n  # Convert x and n to numerators and denominators\n  num_x, den_x = x.split('\/').map(&:to_i)\n  num_n, den_n = n.split('\/').map(&:to_i)\n\n  # Multiply fractions: (num_x * num_n) \/ (den_x * den_n)\n  numerator = num_x * num_n\n  denominator = den_x * den_n\n\n  # Check if the result is a whole number\n  numerator % denominator == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_simplify\n    candidate = method(:simplify)\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/6\", \"2\/1\"))\n    assert_equal(true, candidate.call(\"5\/1\", \"3\/1\"))\n    assert_equal(false, candidate.call(\"7\/10\", \"10\/2\"))\n    assert_equal(true, candidate.call(\"2\/10\", \"50\/10\"))\n    assert_equal(true, candidate.call(\"7\/2\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"11\/6\", \"6\/1\"))\n    assert_equal(false, candidate.call(\"2\/3\", \"5\/2\"))\n    assert_equal(false, candidate.call(\"5\/2\", \"3\/5\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"8\/4\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/5\", \"1\/5\"))\n  end\nend\n"},{"task_id":"HumanEval_145","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: ɖŏ wŭ ɖò nùjlɛ́jlɛ́ yetɔn lɛ́ɛ jí ɖò nùjlɛ́jlɛ́ tò ɔ́ tɔn mɛ.Akpá: enyi nǔ e è wlan dó nǔ lɛ jí lɛ é sín nùxwásá cí ɖokpo ɔ ɔ ɔ, ɖo kpɔnkpɔn wɛ ɖò nùxwásá yetɔn lɛ sín nùxwásá jí.Wlǎn nùjlɛ́n e nɔ ɖè nùjlɛ́n nùjlɛ́n e è ná lɛ́ ná é # >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n","canonical_solution":"def order_by_points(nums)\n  nums.sort_by.with_index do |num, index|\n    [num.to_s.chars.map(&:to_i).sum.abs, index]\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"},{"task_id":"HumanEval_146","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: xɔgbe nukɔntɔn kpo gudo tɔn kpo ɔ nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔ nɔnùxwásá nǔɖe ɖò nùxwásá ɔ mɛ e hú 10 é kpo wè lɛ kpo Wlǎn nùjlɛ́n e nɔ yí nùjlɛ́n xixo ɖé dó nǔ è wlan é mɛ bo nɔ lɛ́ lɛ́ wá é# >>> specialFilter.call([15, -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\ndef specialFilter(nums)\n","canonical_solution":"def specialFilter(nums)\n  nums.count do |num|\n    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5, -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_147","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú:bɔ a[i] + a[j] + a[k] nyí nùɖé bɔ è nɔ jlɛ́ dó 3 jí.Zɔ́n nùxwásá atɔnvlɔ́ɖó (a[i], a[j], a[k]) nú a fí e i < j < k, nú mɛ ɖokpo ɖokpo i (1 ≤ i ≤ n) ɔ, akwɛ́ a[i] = i * i - i + 1 tɔn. È na mi xwɛ́ nú nùjlɔ́mɛnu e nyí nùjlɔ́mɛnu ɖagbe é n. Mi ɖó na bló nùjlɔ́mɛnu e nyí nùjlɔ́mɛnu ɖagbe é ɖé sín nùjlɔ́mɛnu e nyí nùjlɔ́mɛnu ɖagbe é n.# >>> get_max_triples.call(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\ndef get_max_triples(n)\n","canonical_solution":"def get_max_triples(n)\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  count = 0\n  \n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      (j+1...n).each do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n    assert_equal(53361, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_148","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú nùjlɛdonǔwu lɛ nyí nùjlɛdonǔwu wɛ ǎ.azɔ ɔ na lɛ́ kɔ́n nùxíɖí ɖé nú planɛ́t1 alǒ planɛ́t2 sun nɔ sɛkpɔ mɛ.e ɖo ayijimɛ planɛti1 tɔn kpo ayijimɛ planɛti2 tɔn kpo tɛntin, bɔ è sɔ́ gbɔn  jíazɔ̀ ɔ́ ɖó na lɛ́ kɔ́n nùxwásá e mɛ̀ nùjlɛ́jlɛ́ lɛ́ɛ bǐ ɖè éWlǎn nùɖé bó ná yí sun wè e nyí planète lɛ é sín nyikɔ dó wuntun planet1 kpo planet2 kpo mɛ.Uranus, Neptune. e nyí Mercury, e bɔ d'ewu ɔ nyí Venus, bɔ Earth, Mars, Jupiter, Saturn, Hwixómɛ tantɔn wɛ ɖò sunzángbe mǐtɔn mɛ: hwe ɔ kpá ɖò hwe ɔ jí.# >>> bf.call(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf.call(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf.call(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\ndef bf(planet1, planet2)\n","canonical_solution":"def bf(planet1, planet2)\n  planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \n  idx1 = planets.index(planet1)\n  idx2 = planets.index(planet2)\n  \n  return [] if idx1.nil? || idx2.nil?\n\n  start_idx, end_idx = [idx1, idx2].sort\n  \n  planets[(start_idx + 1)...end_idx]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_bf\n    candidate = method(:bf)\n    assert_equal([\"Saturn\", \"Uranus\"], candidate.call(\"Jupiter\", \"Neptune\"))\n    assert_equal([\"Venus\"], candidate.call(\"Earth\", \"Mercury\"))\n    assert_equal([\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], candidate.call(\"Mercury\", \"Uranus\"))\n    assert_equal([\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], candidate.call(\"Neptune\", \"Venus\"))\n    assert_equal([], candidate.call(\"Earth\", \"Earth\"))\n    assert_equal([], candidate.call(\"Mars\", \"Earth\"))\n    assert_equal([], candidate.call(\"Jupiter\", \"Makemake\"))\n  end\nend\n"},{"task_id":"HumanEval_149","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: A sixu ɖɔ ɖɔ xógbe lɛ bǐ na ɖó ganxixo ɖokpo ɔ.azɔ̀ ɔ́ ɖó na lɛ́ kɔ̀n wèmá wèmá ɖé lɛ́ɛ ɖò tito jí.Nú xókwin wè lɛ́ɛ ɖò mɔ̌ ɖokpó ɔ́, ɖè nùjlɛdonǔwu lɛ́ɛ ɖó nùjlɛdonǔwu lɛ́ɛ jí.e na lɛ́ na nùxwlé e è wlan dó acɛ enɛ jí é.E na sɔ́ xókwin lɛ́ɛ ɖó ná nɔ́ ɖò jí wɛ ɖò akpáxwé ɖokpo ɖokpo tɔn mɛ.é sixu ɖ'azɔ̌ dó è.Akɔ ɔ nɔ nyí akpoxwín lɛ tɔn tɛgbɛ bo nɔ nyí nùxwín lɛ tɔn tɛgbɛ ǎ.bo na lɛ́ na nùxwlé e è mɔ é kpodo tito tɔn kpo, e nɔ ɖe xɛ e nɔ ɖó ganxixo e nɔ nyí ganxixo é lɛ sín mɛ, Wlǎn azɔ̀ e nɔ yí gbè nú nùjlɛ́jlɛ́ xójlawema tɔn lɛ́ɛ dó nùjlɛ́jlɛ́ ɔ́ mɛ é,# >>> list_sort.call([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n","canonical_solution":"def list_sort(arr)\n  arr.select { |s| s.length.even? }\n     .sort_by { |s| [s.length, s] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\", \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"], candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"},{"task_id":"HumanEval_150","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: e na lɛ́ lɛ́ yí nùɖé nú y.azɔli kpodo azɔli kpo e na lɛ na lɛ na x tɔn nu nu nu n nyí # >>> x_or_y.call(7, 34, 12)\n# 34\n# >>> x_or_y.call(15, 8, 5)\n# 5\ndef x_or_y(n, x, y)\n","canonical_solution":"def x_or_y(n, x, y)\n  require 'prime'\n  n.prime? ? x : y\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_x_or_y\n    candidate = method(:x_or_y)\n    assert_equal(34, candidate.call(7, 34, 12))\n    assert_equal(5, candidate.call(15, 8, 5))\n    assert_equal(33, candidate.call(3, 33, 5212))\n    assert_equal(3, candidate.call(1259, 3, 52))\n    assert_equal(-1, candidate.call(7919, -1, 12))\n    assert_equal(583, candidate.call(3609, 1245, 583))\n    assert_equal(129, candidate.call(91, 56, 129))\n    assert_equal(1234, candidate.call(6, 34, 1234))\n    assert_equal(0, candidate.call(1, 2, 0))\n    assert_equal(2, candidate.call(2, 2, 0))\n  end\nend\n"},{"task_id":"HumanEval_151","nl":"fon_Latn","pl":"rb","prompt":"e nɔ nyí nùɖé ǎ lɛ é ɔ, mi ma nɔ ɖó ayi nùɖé jí ó.Nú è na sɔ́ nùjlɛ́kpo lɛ́ɛ sín nùjlɛ́kpo ɖé ɔ, lɛ́n nùjlɛ́kpo lɛ́ɛ sín kwɛ́ɛ sín nùjlɛ́kpo ɔ́ sín nǔ.# >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1, -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n# 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n","canonical_solution":"def double_the_difference(lst)\n  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }\n     .map { |n| n ** 2 }\n     .sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"},{"task_id":"HumanEval_152","nl":"fon_Latn","pl":"rb","prompt":"kpɔ́ndéwú: nùxwɛ ɔ nyí 0 bɔ enyi é nyí ǎ ɔ, nùxwɛ ɔ wɛ nyí vogbingbɔn e ɖò mɛ̀ ɖò nùxwɛ ɔ kpo nǔ e è mɔ é kpo tɛntin é.lɛ́ kɔ́n nùxíxo ɖokpó ɔ́ dó ɖɔ́ lě e mɛ ɖokpó ɖokpó sín nǔ e è ɖɔ é lín dó mɛ gbɔn é.È na we nǔ e è nɔ mɔ ɖò nǔ lɛ mɛ é kpo nǔ e è nɔ mɔ ɖò nǔ lɛ mɛ é kpo bɔ mɛ ɖokpo ɖokpo ɖó na mɔ nǔ e é nɔ mɔ é.azɔ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ mɛ ɔ ɖɔ nǔ e é mɔ ɖò nùɖé lɛ mɛ é sɔgbe à jí.e jɛxa ɖɔ è na wlan bo jlɛ́.nǔ e jɛ ɔ́ bǐ wɛ è wá tuùn.Un lin ɖɔ mi bǐ wɛ flín nǔ cí nú mɛ hwenu e mɛ e è ko nɔte kpɔ́n sín tɛgbɛ é ɖé wá é# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\ndef compare(game, guess)\n","canonical_solution":"def compare(game, guess)\n  game.zip(guess).map { |score, prediction| (score - prediction).abs }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_153","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: (kpikpa tɔn nyi -1).lɛ́ɛ ná lɛ́ wá 'Slices.SErviNGSliCes' ɖó 'SErviNGSliCes' wɛ nyí nukɔ́nkpó e ɖó gǎn hú bǐ é nùjlɛdonǔwu: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ɔ́, a ɖó ná ě nú è na sɔ́ \"Slices\" dó ɖó azɔ̌mɛví ɔ kpo nǔ e è nɔ ylɔ ɖɔ  ɔ sín nǔ lɛ é kposɔ́ ée ná jɛ nukɔn ɖò nùjlɛdonǔwu ɔ mɛ é.Enyi è na lɛ́ sɔ́ wè alǒ hú mɔ̌ ɖó hlɔnhlɔn ɖokpo ɔ ɔ́, a ɖó na lɛ́ sɔ́ we ɖówèmá: ClassName.StrongestExtensionName. A na mɔ nukɔnyiyi e syɛn hú bǐ é bo na lɛ́ yí wuntun ɖé dó nùjlɛdonǔwu elɔ mɛ.ɖo nukɔnyiyi ɔ sín nyikɔ mɛ ɔ, kpodo CAP - SM kpo wɛ è nɔ ɖe hlɔnhlɔn ɔ xlɛ́.wèmá ɖò extension sín nyikɔ mɛ, bo sɔ́ SM dó ɖó wèmá kpɛví lɛ́ɛ tɔn hlɔ̌nhlɔ́n nǔ lɛ́ɛ tɔn nyí nǔ elɔ lɛ́ɛ: nú CAP nyí númɛ̀ ɔ́ Akɔ́n lɛ́ɛ ɔ́, è na zán dó dó azɔ̌ lɛ́ɛ jí nú azɔ̌ lɛ́ɛ.È na na we azɔmɛ ɖé sín nyikɔ (wɔntin) kpo nǔɖeji lɛ tɔn kpo.# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n","canonical_solution":"def Strongest_Extension(class_name, extensions)\n  strongest_extension = extensions.max_by do |extension|\n    cap_count = extension.count('A-Z')\n    sm_count = extension.count('a-z')\n    cap_count - sm_count\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\", candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\", candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"_\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\", [\"671235\", \"Bb\"]))\n  end\nend\n"},{"task_id":"HumanEval_154","nl":"fon_Latn","pl":"rb","prompt":"È na we xógbe. A na lɛ́ yí gbè nú xó ɔ́ ɖɔ nugbǒ enyi xó wegɔ́ ɔ́ alǒ xɛ̀ tɔn ɖě nyí wuntun ɖò xó nukɔntɔn ɔ́ mɛ ɔ́.# >>> cycpattern_check.call(\"abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n# >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n# >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a, b)\n","canonical_solution":"def cycpattern_check(a, b)\n  (0...b.length).each do |i|\n    rotated_b = b[i..-1] + b[0...i]\n    return true if a.include?(rotated_b)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true, candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"))\n  end\nend\n"},{"task_id":"HumanEval_155","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: é ná nùxwléma ɖé. é ná lɛ́ yí nùxwléma e ɖó nùxwléma e nyí ganxixo é kpo ée nyí ganxixo ǎ é kpo é.# >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n# [1, 2]\ndef even_odd_count(num)\n","canonical_solution":"def even_odd_count(num)\n  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"},{"task_id":"HumanEval_156","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú: Xwɛsín: 1 <= num <= 1000 bo sɔ́ wlan e dó wlan xókwín kpɛví ɖé lɛ mɛ é. E na mɔ nùxwlé ɖagbe ɖé ɔ, mɔ nùxwlé hlɔma tɔn e nɔ nyí xɛ ɔ, # >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n# \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n","canonical_solution":"def int_to_mini_roman(number)\n  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n  result = ''\n  values.each_with_index do |value, index|\n    while number >= value\n      number -= value\n      result += numerals[index]\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"},{"task_id":"HumanEval_157","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: 90 degre. Hwexwetɔn e nɔ ɖó xwɛ ɖagbe é wɛ nyí ɖɔ wexwetɔn e mɛ xwɛ ɖokpo nyí xwɛ ɖagbe é alǒ xwɛ e nyí xwɛ ɖagbe éali lɛ nɔ bló atɔnviɖe e nɔ ɖó ganxixo ɖagbe ɖagbe é, é ma nyí mɔ̌ ǎ.Nú è na sɔ́ xwɛ̌ atɔn lɛ sín hùn lɛ ɔ, é na lɛ́ nyí nugbǒ nú# >>> right_angle_triangle.call(3, 4, 5)\n# true\n# >>> right_angle_triangle.call(1, 2, 3)\n# false\ndef right_angle_triangle(a, b, c)\n","canonical_solution":"def right_angle_triangle(a, b, c)\n  sides = [a, b, c].sort\n  sides[0]**2 + sides[1]**2 == sides[2]**2\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_right_angle_triangle\n    candidate = method(:right_angle_triangle)\n    assert_equal(true, candidate.call(3, 4, 5))\n    assert_equal(false, candidate.call(1, 2, 3))\n    assert_equal(true, candidate.call(10, 6, 8))\n    assert_equal(false, candidate.call(2, 2, 2))\n    assert_equal(true, candidate.call(7, 24, 25))\n    assert_equal(false, candidate.call(10, 5, 7))\n    assert_equal(true, candidate.call(5, 12, 13))\n    assert_equal(true, candidate.call(15, 8, 17))\n    assert_equal(true, candidate.call(48, 55, 73))\n    assert_equal(false, candidate.call(1, 1, 1))\n    assert_equal(false, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_158","nl":"fon_Latn","pl":"rb","prompt":"xɛ lɛ, lɛ́ kɔ̀ mɛ e jɛ nukɔn ɖò xókwin-kpàkpàkpà mɛ é.nú wuntun ɖokpo ɖokpo ɔ ɔ. enyi wuntun ɖokpo ɖokpo ɔ ɖó wuntun ɖokpo ɖokpo ɔ ɔ ɔXó vovo wɛ ɖò nùxwlé ɔ mɛ. Na lɛ́ yí xó ɔ́ ɖó nùxwlé maximal tɔn Wlǎn azɔ̀ e nɔ yí gbè nú nùjlɛ́jlɛ́ xójlawema tɔn lɛ́ɛ é.# >>> find_max.call([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n","canonical_solution":"def find_max(words)\n  # Helper function to count unique characters\n  def unique_char_count(word)\n    word.chars.uniq.size\n  end\n\n  words.max_by { |word| [unique_char_count(word), -word] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n  end\nend\n"},{"task_id":"HumanEval_159","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́n: enyi atín e kpo é ma kpé ǎ ɔ, a na ɖu atín e kpo é kpo é bǐ, amɔ̌ xovɛ́ na lɛ́ sin we.nùxwlé e ɖò tɔ̀n ɖò nùɖuɖu towe lɛ́ɛ gudo é ] mi na lɛ́ sɔ́ nùɖé lɛ́ɛ dó kɔ́ mɛ nú mi [ nùɖé lɛ́ɛ bǐ e mi ɖu ɖò nùɖuɖu mitɔn gudo é, Amɔ̌, din ɔ, a ɖó na ɖu atínkwín gègě bo na dó ɖu nǔ bǐ.A nyí xɛvi xovɛ́ sin wɛ, bo ko ɖu atínkwín e è nɔ ylɔ́ ɖɔ \"carrot\" é ɖé.# >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1, 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number, need, remaining)\n","canonical_solution":"def eat(number, need, remaining)\n  total_eaten = number + [need, remaining].min\n  carrots_left = [remaining - need, 0].max\n  [total_eaten, carrots_left]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1, 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9, 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n  end\nend\n"},{"task_id":"HumanEval_160","nl":"fon_Latn","pl":"rb","prompt":"Akɔkpá ɔ́ ɖó azɔwatɔ́ ɖokpó ɖò bǐbɛ́mɛ, bɔ azɔ̌kpá ɔ́ ɖó azɔ̌kpá we ɖò bǐbɛ́mɛ.Operand ɔ nyi nùxwléma e nyí nùɖé ǎ lɛ é tɔn.Akɔkpá ɔ́ sín hùn cí akɔkpá operand tɔn sín hùn sín mɛ ɖokpó jí.Akpádo:=> nǔ e è mɔ é = 9 nǔ e è mɔ é = 2 + 3 * 4 - 5 nǔxíxo = [2, 3, 4, 5] azɔwatɔ́ ɔ['+', '*', '-'] Kpɔ́n: Nǔɖeji (**) Xò ɖò xò jí ɔ́ ( \/\/) Ðɔ nǔ kpɔ́n (*) Ðèñóíîê ( - ) Ðɔ nǔ lɛ dó (+) Nǔ e è nɔ wà dó aljɛbu jí lɛ é: e nɔ lɛ́ vɔ́ xógbe ɔ́ sín nǔ e è na zán dó mɔ xógbe ɔ́ é.azɔmε wegɔ ɔ nyi xεnxixa e nɔ nyi nuɖeji lɛ ɔ. Zɔ azɔmε we lε bo na blo algebri ɔE na bo na w'azɔ̌tɔ́ nǔxomɔ wè, kpo nǔxomɔ tɔn kpo ɔ, nǔxomɔ nukɔntɔn ɔ ɖó nùxomɔ algebra tɔn taji lɛ, bɔ def do_algebra(operator, operand)\n","canonical_solution":"def do_algebra(operator, operand)\n  expression = operand[0].to_s\n  operator.each_with_index do |op, index|\n    if op == '\/\/'\n      expression += ' \/ ' + operand[index + 1].to_s\n    else\n      expression += ' ' + op + ' ' + operand[index + 1].to_s\n    end\n  end\n  eval(expression)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\", \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\", \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"\/\/\", \"*\"], [7, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_161","nl":"fon_Latn","pl":"rb","prompt":"Kpɔ́ndéwú azɔ̀ ɔ́ ɖó ná lɛ́ kɔ̀n wèmá e è mɔ é.Enyi wuntun ɔ ma ɖó wuntun ɖé ǎ ɔ, mi na lɛ́ kɔ́n wuntun ɔ.é ma nyí mɔ̌ ǎ ɔ́, mi hɛn ɔ́, mi ná nɔ lě e mi ɖe gbɔn é.enyi s[i] nyí wèmá ɔ, lɛ́ kɔ sín fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó é jíe na w'azɔ̌ nú we.# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n","canonical_solution":"def solve(s)\n  if s =~ \/[a-zA-Z]\/\n    s.chars.map { |char| char =~ \/[a-zA-Z]\/ ? char.swapcase : char }.join\n  else\n    s.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\", candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"#$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"},{"task_id":"HumanEval_162","nl":"fon_Latn","pl":"rb","prompt":"Enyi 'text' nyí xwɛ̀ nùɖé ǎ ɔ, lɛ́ kɔ nú nil. E na sɔ́ wèmá 'text' ɖé ɔ́, lɛ́ yí wèmá e ɖ'emɛ é sín hash md5 ɔ́.# >>> string_to_md5.call(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n","canonical_solution":"require 'digest'\n\ndef string_to_md5(text)\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\", candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"))\n  end\nend\n"},{"task_id":"HumanEval_163","nl":"fon_Latn","pl":"rb","prompt":"Ði kpɔ́ndéwú ɔ: bo b, ɖò nǔ jɛ jí wɛ.Nú è na w'azɔnkpɔnkpɔn ɖagbe wè a kpo b kpo ɔ, lɛ́ kɔ nú xwɛxwɛ e ɖò a kpo b kpo tɛntin é.# >>> generate_integers.call(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10, 14)\n# []\ndef generate_integers(a, b)\n","canonical_solution":"def generate_integers(a, b)\n  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2, 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2, 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n  end\nend\n"}]