task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,fon_Latn,rs,"/// nú è na ɖɔ ɔ./// Nɔ kpɔ́n ɖɔ nú nùjlɛ́jlɛ́ wè lɛ́ ɖò nùjlɛ́jlɛ́ wè lɛ́ɛ mɛ ɔ, ye ɖò sɛ́dó nú yeɖée hú /// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)
/// false
/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
/// true
fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
","fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {
    for i in 0..numbers.len() {
        for j in (i + 1)..numbers.len() {
            if (numbers[i] - numbers[j]).abs() < threshold {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = has_close_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
}
"
HumanEval_1,fon_Latn,rs,"/// Nɔ kpɔn bo na dó xɔvi lɛ ɖò xɛ e è nɔ dó é mɛ./// Ahwan e ɖò yeɖée mɛ lɛ́ɛ nɔ ɖò jlɛ̌ jí (ahwan e ɖò yeɖée mɛ lɛ́ɛ ɖokpo ɖokpo nɔ ɖò yeɖée mɛ ganji) bɔ ye nɔ nɔ yeɖée mɛ ǎ./// ɖè mɛ enɛ lɛ ɖó vovo bo na lɛ́ lɛ́ vɔ́ ná wèmá mɛ enɛ lɛ tɔn lɛ́ɛ./// Nǔ e è nɔ sɔ́ dó azɔ̀ élɔ́ mɛ é wɛ nyí xɛ́lɛ́ e nɔ ɖó nùxwásá lɛ́ɛ./// >>> separate_paren_groups(String::from(""( ) (( )) (( )( ))""))
/// vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]
fn separate_paren_groups(paren_string: String) -> Vec<String> {
","fn separate_paren_groups(paren_string: String) -> Vec<String> {
    let mut groups = Vec::new();
    let mut current_group = String::new();
    let mut open_count = 0;

    for char in paren_string.chars() {
        if char == '(' {
            open_count += 1;
            current_group.push(char);
        } else if char == ')' {
            open_count -= 1;
            current_group.push(char);
        }

        if open_count == 0 && !current_group.is_empty() {
            groups.push(current_group.clone());
            current_group.clear();
        }
    }

    groups
}","}

fn main() {
    let candidate = separate_paren_groups;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![String::from(""(()())""), String::from(""((()))""), String::from(""()""), String::from(""((())()())"")]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![String::from(""()""), String::from(""(())""), String::from(""((()))""), String::from(""(((())))"")]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![String::from(""(()(())((())))"")]);
    assert_eq!(candidate(String::from(""( ) (( )) (( )( ))"")), vec![String::from(""()""), String::from(""(())""), String::from(""(()())"")]);
}
"
HumanEval_2,fon_Latn,rs,"/// Hɔn nú nùxwásún ɔ sín akpáxwé wǒzángbè ɔ. /// (kpá e nɔ lɛ́ kpo ɖò mɛ é nɔ ɖò kpɛví hú 1)./// kpo nùxwlé lɛ́ɛ sín akpáxwé (nǔxwlé e ɖò tají hú nùxwlé e è na é) kpo nǔxwlé lɛ́ɛ kpo/// Nú è na sɔ́ nùjlɛ́n e nɔ ɖò nǔ ján wɛ é ɖé dó nùjlɛ́n e nɔ ɖò nǔ ján wɛ é ɖé jí ɔ, è sixu bɛ́ dó nùjlɛ́n /// >>> truncate_number(3.5)
/// 0.5
fn truncate_number(number: f64) -> f64 {
","fn truncate_number(number: f64) -> f64 {
    number - number.floor()
}

fn main() {
    println!(""{}"", truncate_number(3.5)); // 0.5
}","}

fn main() {
    let candidate = truncate_number;
    assert_eq!(candidate(3.5), 0.5);
    assert_eq!(candidate(1.25), 0.25);
    assert_eq!(candidate(123.0), 0.0);
}
"
HumanEval_3,fon_Latn,rs,"/// ɖo finɛ ɔ azɔ̀ ɔ́ ɖó na lɛ́ kɔ́n true.//azɔ towe wɛ nyí ɖɔ a na mɔ ɖɔ azɔkwɛ́ ɔ́ jɛ ayǐ ɖò fí ɖebǔ, bɔ //A mɔ nǔ e è nɔ zán dó wlan akwɛ kpo akwɛ́ è nɔ ɖè sín akwɛ́xwé lɛ é kpo é ɖé ɖò nǔ e nɔ jɛ nukɔn nú nǔ e è nɔ ylɔ ɖɔ  é jí./// >>> below_zero(vec![1, 2, 3])
/// false
/// >>> below_zero(vec![1, 2, -4, 5])
/// true
fn below_zero(operations: Vec<isize>) -> bool {
","fn below_zero(operations: Vec<isize>) -> bool {
    let mut balance = 0;
    for operation in operations {
        balance += operation;
        if balance < 0 {
            return true;
        }
    }
    false
}

fn main() {
    println!(""{}"", below_zero(vec![1, 2, 3])); // false
    println!(""{}"", below_zero(vec![1, 2, -4, 5])); // true
    println!(""{}"", below_zero(vec![1, -1, -1, 2])); // true
}","}

fn main() {
    let candidate = below_zero;
    assert_eq!(candidate(Vec::<isize>::new()), false);
    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);
    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
}
"
HumanEval_4,fon_Latn,rs,"/// MAD = mɛ̀ => x - x_mean =>/// nǔɖevi kpo ayixa kpo (mɛdɛn ɖò ninɔmɛ elɔ mɛ): /// Mean Absolute Deviation ɔ wɛ nyí mɛxomɔ mɛxomɔ tɔn mɛxomɔ tɔn ɖò mɛ wè lɛ tɛntin /// ɖò nǔ e ɖò nùwlanwlan enɛ mɛ é sín ayi mɛ. /// Ɖó nùjlɛ́jlɛ́ è è ná dó nú nùjlɛ́jlɛ́ è è ná dó ɔ́, kpɔ́n nú mɛ̀n e nɔ nyí mɛ̀n jɔ̀n é /// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])
/// 1.0
fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
","fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {
    let n = numbers.len() as f64;
    if n == 0.0 {
        return 0.0;
    }

    let mean: f64 = numbers.iter().sum::<f64>() / n;
    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() / n;
    
    mad
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0];
    println!(""{}"", mean_absolute_deviation(numbers)); // Output: 1.0
}","}

fn main() {
    let candidate = mean_absolute_deviation;
    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);
}
"
HumanEval_5,fon_Latn,rs,"/// Zɔ́n nùjlɛ́kpo 'delimeter' ɖò nǔ wè e ɖò kpɔ́ lɛ é bǐ tɛntin nú nùjlɛ́kpo vector `numbers' /// >>> intersperse(vec![], 4)
/// Vec::<isize>::new()
/// >>> intersperse(vec![1, 2, 3], 4)
/// vec![1, 4, 2, 4, 3]
fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {
","fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {
    if numbers.is_empty() {
        return Vec::new();
    }
    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);
    for (i, &num) in numbers.iter().enumerate() {
        result.push(num);
        if i != numbers.len() - 1 {
            result.push(delimiter);
        }
    }
    result
}

fn main() {
    println!(""{:?}"", intersperse(vec![], 4)); // Output: Vec::<isize>::new()
    println!(""{:?}"", intersperse(vec![1, 2, 3], 4)); // Output: vec![1, 4, 2, 4, 3]
}","}

fn main() {
    let candidate = intersperse;
    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);
    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);
}
"
HumanEval_6,fon_Latn,rs,"/// Ɖo kpɔ́ndéwú ɔ (() (()) ɖó xɛ wè ɖò nǔ e è nɔ dó lɛ é mɛ hwenu e ((())) ɖó atɔn é. /// Bo na mɛ ɖokpo ɖokpo ɔ ɔ ɔ, ɖè tɛn e mɛ nùɖíɖó lɛ nɔ nɔ ɖò mɛ é./// Nǔ e è nɔ sɔ́ dó azɔ̀ enɛ mɛ é wɛ nyí wuntun e nɔ ɖè nùxwlé lɛ́ɛ ɖó kpɔ́ bɔ è nɔ klán ɖó tɛn lɛ́ɛ jí é./// >>> parse_nested_parens(String::from(""(()()) ((())) () ((())()())""))
/// vec![2, 3, 1, 3]
fn parse_nested_parens(paren_string: String) -> Vec<isize> {
","fn parse_nested_parens(paren_string: String) -> Vec<isize> {
    paren_string.split_whitespace().map(|group| {
        let mut max_depth = 0;
        let mut current_depth = 0;
        for char in group.chars() {
            match char {
                '(' => {
                    current_depth += 1;
                    if current_depth > max_depth {
                        max_depth = current_depth;
                    }
                },
                ')' => {
                    current_depth -= 1;
                },
                _ => {}
            }
        }
        max_depth
    }).collect()
}

fn main() {
    let result = parse_nested_parens(String::from(""(()()) ((())) () ((())()())""));
    println!(""{:?}"", result); // Output: [2, 3, 1, 3]
}","}

fn main() {
    let candidate = parse_nested_parens;
    assert_eq!(candidate(String::from(""(()()) ((())) () ((())()())"")), vec![2, 3, 1, 3]);
    assert_eq!(candidate(String::from(""() (()) ((())) (((())))"")), vec![1, 2, 3, 4]);
    assert_eq!(candidate(String::from(""(()(())((())))"")), vec![4]);
}
"
HumanEval_7,fon_Latn,rs,"/// Filter input vector of strings only for ones that contain given substring /// >>> filter_by_substring(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_substring(vec![String::from(""abc""), String::from(""bacd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""bacd""), String::from(""array"")]
fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
","fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {
    strings.into_iter().filter(|s| s.contains(&substring)).collect()
}","}

fn main() {
    let candidate = filter_by_substring;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""aaaxxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xx"")), vec![String::from(""xxx""), String::from(""aaaxxy""), String::from(""xxxAAA""), String::from(""xxx"")]);
    assert_eq!(candidate(vec![String::from(""grunt""), String::from(""trumpet""), String::from(""prune""), String::from(""gruesome"")], String::from(""run"")), vec![String::from(""grunt""), String::from(""prune"")]);
}
"
HumanEval_8,fon_Latn,rs,"/// Nùnina e ɖò mɛ é ɖó na nyí 0 bɔ nǔ e ɖò mɛ é ɖó na nyí 1. /// Ɖó nùxwléma nùɖé lɛ́ɛ tɔn ɔ́, ná lɛ́ yí nùxwléma ɖé sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ./// >>> sum_product(vec![])
/// (0, 1)
/// >>> sum_product(vec![1, 2, 3, 4])
/// (10, 24)
fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
","fn sum_product(numbers: Vec<isize>) -> (isize, isize) {
    let sum = numbers.iter().sum();
    let product = numbers.iter().fold(1, |acc, &x| acc * x);
    (sum, product)
}

fn main() {
    println!(""{:?}"", sum_product(vec![])); // (0, 1)
    println!(""{:?}"", sum_product(vec![1, 2, 3, 4])); // (10, 24)
}","}

fn main() {
    let candidate = sum_product;
    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));
    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));
    assert_eq!(candidate(vec![100, 0]), (100, 0));
    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));
    assert_eq!(candidate(vec![10]), (10, 10));
}
"
HumanEval_9,fon_Latn,rs,"/// ɖò nùxwásá ɔ mɛ./// Ɖò nùxwlé lɛ́ɛ sín vector ɖé mɛ ɔ, ɖè vector ɖé sín nǔ e ɖò jí hú bǐ bɔ è mɔ ɖò hwe enɛ ɔ mɛ é./// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])
/// vec![1, 2, 3, 3, 3, 4, 4]
fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
","fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    let mut current_max = isize::MIN;
    for &num in &numbers {
        if num > current_max {
            current_max = num;
        }
        result.push(current_max);
    }
    result
}","}

fn main() {
    let candidate = rolling_max;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);
    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);
}
"
HumanEval_10,fon_Latn,rs,"/// - Zɔ́n wèmá e nɔ jɛ nukɔn nú wèmá palindromic ɔ́ sín wèmá nú wèmá ɔ́ sín wèmá e nɔ jɛ nukɔn nú wèmá ɔ́ é./// - Kpɔ́n postfix mɛ e lín hú bǐ é ɖò wuntun e è na é mɛ bɔ é nyí palindrome. /// Nǔ e è nɔ dó wuntun lɛ é ɖò wɛn: /// Kpɔ́n palindrome kpɛví e bɛ́ ɖò wuntun e è na é jí é. /// >>> make_palindrome(String::from(""""))
/// String::from("""")
/// >>> make_palindrome(String::from(""cat""))
/// String::from(""catac"")
/// >>> make_palindrome(String::from(""cata""))
/// String::from(""catac"")
fn make_palindrome(string: String) -> String {
","fn make_palindrome(string: String) -> String {
    fn is_palindrome(s: &str) -> bool {
        s.chars().eq(s.chars().rev())
    }

    if string.is_empty() || is_palindrome(&string) {
        return string;
    }

    for i in (0..string.len()).rev() {
        if is_palindrome(&string[i..]) {
            let prefix = &string[..i];
            let reversed_prefix: String = prefix.chars().rev().collect();
            return string + &reversed_prefix;
        }
    }

    string
}

fn main() {
    println!(""{:?}"", make_palindrome(String::from(""""))); // String::from("""")
    println!(""{:?}"", make_palindrome(String::from(""cat""))); // String::from(""catac"")
    println!(""{:?}"", make_palindrome(String::from(""cata""))); // String::from(""catac"")
}","}

fn main() {
    let candidate = make_palindrome;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""x"")), String::from(""x""));
    assert_eq!(candidate(String::from(""xyz"")), String::from(""xyzyx""));
    assert_eq!(candidate(String::from(""xyx"")), String::from(""xyx""));
    assert_eq!(candidate(String::from(""jerry"")), String::from(""jerryrrej""));
}
"
HumanEval_11,fon_Latn,rs,"/// Nɔ bló binary XOR nú nǔ e è nɔ byɔ mɛ lɛ é, bo na lɛ́ lɛ́ wá mɔ nǔ e è nɔ mɔ é ɖò wuntun ɖé mɛ. /// Input ɔ wɛ nyí xɛ wè a kpo b kpo e mɛ 1 kpo 0 kpo kɛɖɛ wɛ ɖè. /// >>> string_xor(String::from(""010""), String::from(""110""))
/// String::from(""100"")
fn string_xor(a: String, b: String) -> String {
","fn string_xor(a: String, b: String) -> String {
    a.chars()
     .zip(b.chars())
     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })
     .collect()
}","}

fn main() {
    let candidate = string_xor;
    assert_eq!(candidate(String::from(""111000""), String::from(""101010"")), String::from(""010010""));
    assert_eq!(candidate(String::from(""1""), String::from(""1"")), String::from(""0""));
    assert_eq!(candidate(String::from(""0101""), String::from(""0000"")), String::from(""0101""));
}
"
HumanEval_12,fon_Latn,rs,"/// strings of the same length. E nɔ lɛ́ kɔ́n None nú mɛ e nɔ sɔ́ nǔ dó mɛ é ma ɖò nǔ ǎ é./// Ɖò nùjlɛ́jlɛ́ vector ɔ́ mɛ ɔ́, na lɛ́ yí mɛ e lín hú mɛ ɖě é. Nú è na lɛ́ yí mɛ nukɔntɔn ɔ́ ɔ́, è na lɛ́ yí mɛ nukɔntɔn ɔ́./// >>> longest(vec![])
/// None
/// >>> longest(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// Some(String::from(""a""))
/// >>> longest(vec![String::from(""a""), String::from(""bb""), String::from(""ccc"")])
/// Some(String::from(""ccc""))
fn longest(strings: Vec<String>) -> Option<String> {
","fn longest(strings: Vec<String>) -> Option<String> {
    strings.into_iter().max_by_key(|s| s.len())
}","}

fn main() {
    let candidate = longest;
    assert_eq!(candidate(Vec::<String>::new()), None);
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), Some(String::from(""x"")));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""yyy""), String::from(""zzzz""), String::from(""www""), String::from(""kkkk""), String::from(""abc"")]), Some(String::from(""zzzz"")));
}
"
HumanEval_13,fon_Latn,rs,"/// Ðɔ nǔ e nɔ zɔ́n bɔ nùɖé lɛ nɔ nyí nǔ e nɔ zɔ́n bɔ nùɖé lɛ nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nyí nǔ ɔ é é é é./// >>> greatest_common_divisor(3, 5)
/// 1
/// >>> greatest_common_divisor(25, 15)
/// 5
fn greatest_common_divisor(a: isize, b: isize) -> isize {
","fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}","}

fn main() {
    let candidate = greatest_common_divisor;
    assert_eq!(candidate(3, 7), 1);
    assert_eq!(candidate(10, 15), 5);
    assert_eq!(candidate(49, 14), 7);
    assert_eq!(candidate(144, 60), 12);
}
"
HumanEval_14,fon_Latn,rs,"/// Ðèñóíêîâûé âåêòîð âñåõ ïðîöåññîâ ó ñàìîé êðóïíåéøåé ê ñàìîé áîëüøîé âõîäíîé ñåðèè /// >>> all_prefixes(String::from(""abc""))
/// vec![String::from(""a""), String::from(""ab""), String::from(""abc"")]
fn all_prefixes(string: String) -> Vec<String> {
","fn all_prefixes(string: String) -> Vec<String> {
    let mut prefixes = Vec::new();
    for i in 1..=string.len() {
        prefixes.push(string[..i].to_string());
    }
    prefixes
}

// Example usage
fn main() {
    let prefixes = all_prefixes(String::from(""abc""));
    println!(""{:?}"", prefixes);
}","}

fn main() {
    let candidate = all_prefixes;
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""asdfgh"")), vec![String::from(""a""), String::from(""as""), String::from(""asd""), String::from(""asdf""), String::from(""asdfg""), String::from(""asdfgh"")]);
    assert_eq!(candidate(String::from(""WWW"")), vec![String::from(""W""), String::from(""WW""), String::from(""WWW"")]);
}
"
HumanEval_15,fon_Latn,rs,"/// É nɔ́ lɛ́ yí nùkwín e ɖò nùjlɛ́jlɛ́ e è ɖó fí e è nɔ sɔ́ nùjlɛ́jlɛ́ lɛ́ɛ dó é jí bɛ́ sín 0 káká yi n jɛ. /// >>> string_sequence(0)
/// String::from(""0"")
/// >>> string_sequence(5)
/// String::from(""0 1 2 3 4 5"")
fn string_sequence(n: isize) -> String {
","fn string_sequence(n: isize) -> String {
    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join("" "")
}","}

fn main() {
    let candidate = string_sequence;
    assert_eq!(candidate(0), String::from(""0""));
    assert_eq!(candidate(3), String::from(""0 1 2 3""));
    assert_eq!(candidate(10), String::from(""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval_16,fon_Latn,rs,"/// Nú è na wèmá wèmá ɖé ɔ, kpɔ́n ɖɔ wèmá alɔkpa nabí lɛ́ɛ wɛ ɖò wèmá ɔ mɛ (n'ɛ nyí wèmá ɖaxó alǒ wèmá kpɛví ɔ wɛ ǎ)/// >>> count_distinct_characters(String::from(""xyzXYZ""))
/// 3
/// >>> count_distinct_characters(String::from(""Jerry""))
/// 4
fn count_distinct_characters(string: String) -> isize {
","use std::collections::HashSet;

fn count_distinct_characters(string: String) -> isize {
    let lowercase_string = string.to_lowercase();
    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();
    distinct_chars.len() as isize
}","}

fn main() {
    let candidate = count_distinct_characters;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abcde"")), 5);
    assert_eq!(candidate(String::from(""abcdecadeCADE"")), 5);
    assert_eq!(candidate(String::from(""aaaaAAAAaaaa"")), 1);
    assert_eq!(candidate(String::from(""Jerry jERRY JeRRRY"")), 5);
}
"
HumanEval_17,fon_Latn,rs,"//""Hǐ"" - nǔ e è nɔ ylɔ ɖɔ ""quater"" é, bɔ é nɔ xɔ̀n gan ɖokpo//'O saide' - nǔ e è nɔ ylɔ ɖɔ 'half note' é nɔ́ nɔ̀ wè/// 'O' - nǔ e è nɔ ylɔ ɖɔ 'w' é bǐ, é nɔ xɔ azɔn ɛnɛ/// Nǔ e è nɔ ɖɔ é ɖíe:/// é nyí gudo tɔn ǎ.//azɔ towe wɛ nyí ɖɔ a na wlan xwɛ elɔ bo na lɛ́ yí nùxwlé lɛ sín vector e sɔgbe xá azɔn nabí e mɛ ɖokpo ɖokpo na xo é/// Nǔ e è nɔ sɔ́ dó azɔ̀ elɔ mɛ é wɛ nyí wuntun e nɔ xlɛ́ nùxixa lɛ ɖò wuntun ɖé mɛ ɖò ASCII. /// >>> parse_music(String::from(""o o| .| o| o| .| .| .| .| o o""))
/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
fn parse_music(music_string: String) -> Vec<isize> {
","fn parse_music(music_string: String) -> Vec<isize> {
    let mut result = Vec::new();
    let notes: Vec<&str> = music_string.split_whitespace().collect();

    for note in notes {
        match note {
            ""o"" => result.push(4),
            ""o|"" => result.push(2),
            "".|"" => result.push(1),
            _ => (),
        }
    }

    result
}

fn main() {
    let music_string = String::from(""o o| .| o| o| .| .| .| .| o o"");
    let beats = parse_music(music_string);
    println!(""{:?}"", beats); // Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
}","}

fn main() {
    let candidate = parse_music;
    assert_eq!(candidate(String::from("""")), Vec::<isize>::new());
    assert_eq!(candidate(String::from(""o o o o"")), vec![4, 4, 4, 4]);
    assert_eq!(candidate(String::from("".| .| .| .|"")), vec![1, 1, 1, 1]);
    assert_eq!(candidate(String::from(""o| o| .| .| o o o o"")), vec![2, 2, 1, 1, 4, 4, 4, 4]);
    assert_eq!(candidate(String::from(""o| .| o| .| o o| o o|"")), vec![2, 1, 2, 1, 4, 2, 4, 2]);
}
"
HumanEval_18,fon_Latn,rs,"/// Kpɔ́n azɔn nabi è na mɔ xwɛɖomɛ e è na mɔ ɖò xwɛɖomɛ ɔ mɛ é. Xà xó e nɔ jɛ kpɔ́n lɛ é. /// >>> how_many_times(String::from(""""), String::from(""a""))
/// 0
/// >>> how_many_times(String::from(""aaa""), String::from(""a""))
/// 3
/// >>> how_many_times(String::from(""aaaa""), String::from(""aa""))
/// 3
fn how_many_times(string: String, substring: String) -> isize {
","fn how_many_times(string: String, substring: String) -> isize {
    if substring.is_empty() || string.is_empty() {
        return 0;
    }

    let mut count = 0;
    let mut position = 0;

    while let Some(pos) = string[position..].find(&substring) {
        count += 1;
        position += pos + 1; // Move to the start of the next potential substring
    }

    count
}

fn main() {
    println!(""{}"", how_many_times(String::from(""""), String::from(""a""))); // 0
    println!(""{}"", how_many_times(String::from(""aaa""), String::from(""a""))); // 3
    println!(""{}"", how_many_times(String::from(""aaaa""), String::from(""aa""))); // 3
}","}

fn main() {
    let candidate = how_many_times;
    assert_eq!(candidate(String::from(""""), String::from(""x"")), 0);
    assert_eq!(candidate(String::from(""xyxyxyx""), String::from(""x"")), 4);
    assert_eq!(candidate(String::from(""cacacacac""), String::from(""cac"")), 4);
    assert_eq!(candidate(String::from(""john doe""), String::from(""john"")), 1);
}
"
HumanEval_19,fon_Latn,rs,"/// É nɔ́ lɛ́ yí nùkwín ɔ́ dó nùxwásá lɛ́ɛ jí sín kpɛví bǐ jí wá ɖaxó bǐ jí /// Nǔ e è sixu sɔ́ lɛ́ɛ wɛ nyí 'wùn', 'ɖokpo', 'we', ' atɔn', 'nɛ', 'atɔ́n', 'atɔn', 'sín', 'síntɔn' kpo 'tɔn' kpo. /// Nǔ e è nɔ sɔ́ dó ɔ́ wɛ nyí nùkwín nùjlɛ́jlɛ́ e sín akpáxwé e è nɔ sɔ́ dó ɔ́ nɔ́ nyí ""mɛ̀"" jɛ ""mɛ̀""./// >>> sort_numbers(String::from(""three one five""))
/// String::from(""one three five"")
fn sort_numbers(numbers: String) -> String {
","fn sort_numbers(numbers: String) -> String {
    let word_to_number = |word: &str| -> u32 {
        match word {
            ""zero"" => 0,
            ""one"" => 1,
            ""two"" => 2,
            ""three"" => 3,
            ""four"" => 4,
            ""five"" => 5,
            ""six"" => 6,
            ""seven"" => 7,
            ""eight"" => 8,
            ""nine"" => 9,
            _ => panic!(""Invalid input""),
        }
    };

    let words: Vec<&str> = numbers.split_whitespace().collect();
    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();

    number_words.sort_by_key(|&(_, number)| number);

    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join("" "")
}","}

fn main() {
    let candidate = sort_numbers;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""three"")), String::from(""three""));
    assert_eq!(candidate(String::from(""three five nine"")), String::from(""three five nine""));
    assert_eq!(candidate(String::from(""five zero four seven nine eight"")), String::from(""zero four five seven eight nine""));
    assert_eq!(candidate(String::from(""six five four three two one zero"")), String::from(""zero one two three four five six""));
}
"
HumanEval_20,fon_Latn,rs,"/// ɖevo lɛ bo lɛ́ lɛ́ kɔ́n ɖò tito mɛ (àkpo kpɛví, àkpo ɖaxó)./// Ɖò nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ e è na lɛ́ ná é mɛ (e na nyí wè ɖò wuntun ɔ́ mɛ é) sɔ́ we e ɖò wè lɛ́ɛ mɛ é, bo lɛ́ lɛ́ yí wè e ɖò wè lɛ́ɛ mɛ é./// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
/// (2.0, 2.2)
/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
/// (2.0, 2.0)
fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {
","fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {
    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());
    let mut min_diff = f64::INFINITY;
    let mut result = (0.0, 0.0);

    for i in 0..(numbers.len() - 1) {
        let diff = numbers[i + 1] - numbers[i];
        if diff < min_diff {
            min_diff = diff;
            result = (numbers[i], numbers[i + 1]);
        }
    }
    
    result
}

fn main() {
    // Example usage
    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];
    let res1 = find_closest_elements(vec1);
    println!(""{:?}"", res1); // (2.0, 2.2)

    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];
    let res2 = find_closest_elements(vec2);
    println!(""{:?}"", res2); // (2.0, 2.0)
}","}

fn main() {
    let candidate = find_closest_elements;
    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));
    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));
    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));
}
"
HumanEval_21,fon_Latn,rs,"/// bɔ xwɛ e ɖò kpɛví hú bǐ ɔ na húzú 0 bɔ xwɛ e ɖò ɖaxó hú bǐ ɔ na húzú 1 /// Nú è na w'azɔ̌ nú nùjlɛ́kpo (e nɔ ɖó nǔ wè ɖò w'azɔ̌ jí ɔ) ɔ, è na zán nùjlɛ́kpo e nɔ j'azɔ̌ jí é ɖé dó w'azɔ̌ enɛ jí, /// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])
/// vec![0.0, 0.25, 0.5, 0.75, 1.0]
fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
","fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {
    if numbers.len() < 2 {
        return numbers;
    }

    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);
    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

    numbers.into_iter().map(|x| (x - min_value) / (max_value - min_value)).collect()
}

fn main() {
    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    let rescaled = rescale_to_unit(numbers);
    println!(""{:?}"", rescaled);
}","}

fn main() {
    let candidate = rescale_to_unit;
    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);
    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);
    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);
}
"
HumanEval_23,fon_Latn,rs,"/// Bo lɛ́ lɛ́ kɔ́n xwɛ e è ná ɔ́ sín wuntun /// >>> strlen(String::from(""""))
/// 0
/// >>> strlen(String::from(""abc""))
/// 3
fn strlen(string: String) -> isize {
","fn strlen(string: String) -> isize {
    string.chars().count() as isize
}

fn main() {
    println!(""{}"", strlen(String::from(""""))); // Output: 0
    println!(""{}"", strlen(String::from(""abc""))); // Output: 3
}","}

fn main() {
    let candidate = strlen;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""x"")), 1);
    assert_eq!(candidate(String::from(""asdasnakj"")), 9);
}
"
HumanEval_24,fon_Latn,rs,"/// nú nùxwlé ɖé n ɔ, mɔ nùxwlé ɖaxó e má n ɖó wè é, e ɖò kpɛví hú n é./// >>> largest_divisor(15)
/// 5
fn largest_divisor(n: isize) -> isize {
","fn largest_divisor(n: isize) -> isize {
    for i in (1..n).rev() {
        if n % i == 0 {
            return i;
        }
    }
    1 // If no other divisor is found, return 1
}

fn main() {
    println!(""{}"", largest_divisor(15)); // Output: 5
}","}

fn main() {
    let candidate = largest_divisor;
    assert_eq!(candidate(3), 1);
    assert_eq!(candidate(7), 1);
    assert_eq!(candidate(10), 5);
    assert_eq!(candidate(100), 50);
    assert_eq!(candidate(49), 7);
}
"
HumanEval_25,fon_Latn,rs,"/// Nùnina ɔ ɖó na cí nǔ e è nɔ lɛ́ wlan dó nǔwiwa lɛ́ɛ bǐ jí é ɖɔhun./// Nǔkpò lɛ ɖokpo ɖokpo ɖó na nyí vectored azɔn nabi e sɔgbe xá azɔn nabi e é nɔ tɔ́n ɖò nǔkpò lɛ mɛ é./// Ðàñõîäíûé âåêòîð ïðîñòûõ ôóíêöèé äàííîãî ïîëíîìî÷èÿ â ðåçóëüòàòå îò ñàìîãî ìàëîãî ê áîëüøîìó. /// >>> factorize(8)
/// vec![2, 2, 2]
/// >>> factorize(25)
/// vec![5, 5]
/// >>> factorize(70)
/// vec![2, 5, 7]
fn factorize(n: isize) -> Vec<isize> {
","fn factorize(mut n: isize) -> Vec<isize> {
    let mut factors = Vec::new();
    let mut divisor = 2;
    while n >= divisor * divisor {
        while n % divisor == 0 {
            factors.push(divisor);
            n /= divisor;
        }
        divisor += 1;
    }
    if n > 1 {
        factors.push(n);
    }
    factors
}

fn main() {
    // Test cases
    println!(""{:?}"", factorize(8));  // Should print: [2, 2, 2]
    println!(""{:?}"", factorize(25)); // Should print: [5, 5]
    println!(""{:?}"", factorize(70)); // Should print: [2, 5, 7]
}","}

fn main() {
    let candidate = factorize;
    assert_eq!(candidate(2), vec![2]);
    assert_eq!(candidate(4), vec![2, 2]);
    assert_eq!(candidate(8), vec![2, 2, 2]);
    assert_eq!(candidate(57), vec![3, 19]);
    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);
    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);
    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);
    assert_eq!(candidate(18), vec![2, 3, 3]);
}
"
HumanEval_26,fon_Latn,rs,"/// Nɔ sɔ́ nǔ lɛ́ɛ ɖó tito ɖokpo ɔ mɛ ɖò nǔ e è wlan lɛ́ɛ mɛ é./// Ɖò nùxwlé lɛ sín nùxwlé lɛ jí ɔ, ɖè nùxwlé lɛ e nɔ jɛ azɔn hú ɖokpo lɛ é bǐ./// >>> remove_duplicates(vec![1, 2, 3, 2, 4])
/// vec![1, 3, 4]
fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
","use std::collections::HashMap;

fn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {
    let mut occurrences = HashMap::new();
    
    // Count occurrences of each number
    for &number in &numbers {
        *occurrences.entry(number).or_insert(0) += 1;
    }

    // Filter out numbers that occur more than once
    numbers.into_iter()
        .filter(|&number| occurrences[&number] == 1)
        .collect()
}","}

fn main() {
    let candidate = remove_duplicates;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);
    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);
}
"
HumanEval_27,fon_Latn,rs,"/// Bo na dó wèmá è è ná wèmá ɔ́ lɛ́ɛ ɔ́, wèmá klewun lɛ́ɛ ɔ́, yí dó wèmá ɖaxó jí, wèmá ɖaxó lɛ́ɛ ɔ́, yí dó wèmá kpɛví jí. /// >>> flip_case(String::from(""Hello""))
/// String::from(""hELLO"")
fn flip_case(string: String) -> String {
","fn flip_case(string: String) -> String {
    string.chars().map(|c| {
        if c.is_lowercase() {
            c.to_ascii_uppercase()
        } else {
            c.to_ascii_lowercase()
        }
    }).collect()
}","}

fn main() {
    let candidate = flip_case;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hello!"")), String::from(""hELLO!""));
    assert_eq!(candidate(String::from(""These violent delights have violent ends"")), String::from(""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval_28,fon_Latn,rs,"/// Kɔnkatɛ́n véktótóo nùjlɛ́jlɛ́ lɛ́ɛ tɔn dó nùjlɛ́jlɛ́ ɖokpo mɛ̀ /// >>> concatenate(vec![])
/// String::from("""")
/// >>> concatenate(vec![String::from(""a""), String::from(""b""), String::from(""c"")])
/// String::from(""abc"")
fn concatenate(strings: Vec<String>) -> String {
","fn concatenate(strings: Vec<String>) -> String {
    strings.concat()
}","}

fn main() {
    let candidate = concatenate;
    assert_eq!(candidate(Vec::<String>::new()), String::from(""""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z"")]), String::from(""xyz""));
    assert_eq!(candidate(vec![String::from(""x""), String::from(""y""), String::from(""z""), String::from(""w""), String::from(""k"")]), String::from(""xyzwk""));
}
"
HumanEval_29,fon_Latn,rs,"/// Filter input vector of strings only for ones that start with a given prefix. /// >>> filter_by_prefix(vec![], String::from(""a""))
/// Vec::<String>::new()
/// >>> filter_by_prefix(vec![String::from(""abc""), String::from(""bcd""), String::from(""cde""), String::from(""array"")], String::from(""a""))
/// vec![String::from(""abc""), String::from(""array"")]
fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
","fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {
    strings.into_iter()
        .filter(|s| s.starts_with(&prefix))
        .collect()
}","}

fn main() {
    let candidate = filter_by_prefix;
    assert_eq!(candidate(Vec::<String>::new(), String::from(""john"")), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""xxx""), String::from(""asd""), String::from(""xxy""), String::from(""john doe""), String::from(""xxxAAA""), String::from(""xxx"")], String::from(""xxx"")), vec![String::from(""xxx""), String::from(""xxxAAA""), String::from(""xxx"")]);
}
"
HumanEval_30,fon_Latn,rs,"/// É nɔ lɛ́ lɛ́ yí nùxwɛ́ ɖagbe lɛ́ɛ kɛ́ɖɛ́ dó nùxwásá ɔ́ mɛ. /// >>> get_positive(vec![-1, 2, -4, 5, 6])
/// vec![2, 5, 6]
/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// vec![5, 3, 2, 3, 9, 123, 1]
fn get_positive(l: Vec<isize>) -> Vec<isize> {
","fn get_positive(l: Vec<isize>) -> Vec<isize> {
    l.into_iter().filter(|&x| x > 0).collect()
}","}

fn main() {
    let candidate = get_positive;
    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);
    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);
    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_31,fon_Latn,rs,"/// Yi lɛ́ kɔ́ nú nùjlɛ́kpo ɖé nyí nùjlɛ́kpo nukɔn nukɔntɔn ɔ, bo lɛ́ kɔ́ nú nùjlɛ́kpo e ma nyí nùjlɛ́kpo ǎ é. /// >>> is_prime(6)
/// false
/// >>> is_prime(101)
/// true
/// >>> is_prime(11)
/// true
/// >>> is_prime(13441)
/// true
/// >>> is_prime(61)
/// true
/// >>> is_prime(4)
/// false
/// >>> is_prime(1)
/// false
fn is_prime(n: isize) -> bool {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}","}

fn main() {
    let candidate = is_prime;
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(101), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(13441), true);
    assert_eq!(candidate(61), true);
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(1), false);
    assert_eq!(candidate(5), true);
    assert_eq!(candidate(11), true);
    assert_eq!(candidate(17), true);
    assert_eq!(candidate(85), false);
    assert_eq!(candidate(77), false);
    assert_eq!(candidate(255379), false);
}
"
HumanEval_33,fon_Latn,rs,"/// nú nùjlɛ́n lɛ́ɛ e ɖò nǔ lɛ́ɛ mɛ é, có è ɖè.///l' cí l ɖɔhun ɖò nǔ e è ma nɔ má ɖó atɔn ǎ lɛ é mɛ, có nùjlɛ́n tɔn lɛ ɖò nǔ e è nɔ má ɖó atɔn lɛ é mɛ ɔ, ɖokpo ɔ wɛ ye nyí /// azɔ̀ élɔ́ nɔ́ yí vectɔ́ l bo nɔ́ lɛ́ yí vectɔ́ l' bɔ̀ /// >>> sort_third(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])
/// vec![2, 6, 3, 4, 8, 9, 5]
fn sort_third(l: Vec<isize>) -> Vec<isize> {
","fn sort_third(l: Vec<isize>) -> Vec<isize> {
    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()
        .enumerate()
        .filter(|&(i, _)| i % 3 == 0)
        .map(|(i, &value)| (i, value))
        .collect();

    // Sort the values that are at indices divisible by 3
    divisible_by_three.sort_by_key(|&(_, value)| value);

    let mut result = l.clone();
    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {
        result[*original_index] = divisible_by_three[sorted_index].1;
    }

    result
}","}

fn main() {
    let candidate = sort_third;
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);
    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);
    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);
    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);
}
"
HumanEval_34,fon_Latn,rs,"/// Na lɛ́ vɔ́ nǔɖogbɛ bunɔ e è ɖè ɖó vo ɖò vectɔ́ ɖé mɛ é lɛ́ɛ./// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![0, 2, 3, 5, 9, 123]
fn unique(l: Vec<isize>) -> Vec<isize> {
","fn unique(mut l: Vec<isize>) -> Vec<isize> {
    l.sort_unstable();
    l.dedup();
    l
}

fn main() {
    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);
    println!(""{:?}"", result);
}","}

fn main() {
    let candidate = unique;
    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);
}
"
HumanEval_35,fon_Latn,rs,"/// Yi nǔ e ɖò vector ɔ mɛ é bǐ lɛ́ɛ. /// >>> max_element(vec![1, 2, 3])
/// 3
/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
/// 123
fn max_element(l: Vec<isize>) -> isize {
","fn max_element(l: Vec<isize>) -> isize {
    l.into_iter().max().unwrap()
}","}

fn main() {
    let candidate = max_element;
    assert_eq!(candidate(vec![1, 2, 3]), 3);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);
}
"
HumanEval_36,fon_Latn,rs,"/// Ðèñóéò ÷èñëî ðàç, êàê íèæíèé 7 âûñòóïàåò â ÷èñëå ÷èñëîâ íèæíåé n êîòîðûå ÷àñòåíû íà 11 èëè 13. /// >>> fizz_buzz(50)
/// 0
/// >>> fizz_buzz(78)
/// 2
/// >>> fizz_buzz(79)
/// 3
fn fizz_buzz(n: isize) -> isize {
","fn fizz_buzz(n: isize) -> isize {
    (0..n)
        .filter(|&x| x % 11 == 0 || x % 13 == 0)
        .flat_map(|x| x.to_string().chars())
        .filter(|&c| c == '7')
        .count() as isize
}","}

fn main() {
    let candidate = fizz_buzz;
    assert_eq!(candidate(50), 0);
    assert_eq!(candidate(78), 2);
    assert_eq!(candidate(79), 3);
    assert_eq!(candidate(100), 3);
    assert_eq!(candidate(200), 6);
    assert_eq!(candidate(4000), 192);
    assert_eq!(candidate(10000), 639);
    assert_eq!(candidate(100000), 8026);
}
"
HumanEval_37,fon_Latn,rs,"/// nú nùjlɛ́nmɛ lɛ́ɛ ɖò l jí, amɔ̌ è ɖè.///l' cí l ɖò nùjlɛ́jlɛ́ e nyí nǔ ɖokpo ɔ ǎ lɛ é mɛ, có nǔ e é nyí ɖò nùjlɛ́jlɛ́ e nyí nǔ ɖokpo ɔ lɛ é mɛ ɔ nɔ cí l ɖɔhun./// azɔ̀ élɔ́ nɔ́ yí vectɔ́ l bo nɔ́ lɛ́ yí vectɔ́ l' bɔ̀ /// >>> sort_even(vec![1, 2, 3])
/// vec![1, 2, 3]
/// >>> sort_even(vec![5, 6, 3, 4])
/// vec![3, 6, 5, 4]
fn sort_even(l: Vec<isize>) -> Vec<isize> {
","fn sort_even(l: Vec<isize>) -> Vec<isize> {
    // Collect even indexed elements and sort them
    let mut even_elements: Vec<isize> = l.iter().enumerate()
        .filter(|&(i, _)| i % 2 == 0)
        .map(|(_, &val)| val)
        .collect();
    even_elements.sort();

    // Reconstruct the vector `l'`
    let mut result = l.clone();
    let mut even_index = 0;

    for i in 0..l.len() {
        if i % 2 == 0 {
            result[i] = even_elements[even_index];
            even_index += 1;
        }
    }
    
    result
}","}

fn main() {
    let candidate = sort_even;
    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);
    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}
"
HumanEval_39,fon_Latn,rs,"/// prime_fib nɔ lɛ́ yí nùɖé nú n-gɔ́ ɔ́ dó nùɖé Fibonacci tɔn ɖé mɛ bɔ é lɔ nyí nùɖé nú prime. /// >>> prime_fib(1)
/// 2
/// >>> prime_fib(2)
/// 3
/// >>> prime_fib(3)
/// 5
/// >>> prime_fib(4)
/// 13
/// >>> prime_fib(5)
/// 89
fn prime_fib(n: isize) -> isize {
","fn prime_fib(n: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        if num <= 3 {
            return true;
        }
        if num % 2 == 0 || num % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= num {
            if num % i == 0 || num % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    fn fibonacci() -> impl Iterator<Item = isize> {
        let mut a: isize = 0;
        let mut b: isize = 1;
        std::iter::from_fn(move || {
            let next = a + b;
            a = b;
            b = next;
            Some(a)
        })
    }

    let mut count = 0;
    for fib_num in fibonacci() {
        if is_prime(fib_num) {
            count += 1;
            if count == n {
                return fib_num;
            }
        }
    }
    -1
}","}

fn main() {
    let candidate = prime_fib;
    assert_eq!(candidate(1), 2);
    assert_eq!(candidate(2), 3);
    assert_eq!(candidate(3), 5);
    assert_eq!(candidate(4), 13);
    assert_eq!(candidate(5), 89);
    assert_eq!(candidate(6), 233);
    assert_eq!(candidate(7), 1597);
    assert_eq!(candidate(8), 28657);
    assert_eq!(candidate(9), 514229);
    assert_eq!(candidate(10), 433494437);
}
"
HumanEval_40,fon_Latn,rs,"/// nǔ e nɔ nyí nǔ ɔ́ nɔ́ nyí nǔ nú ɔ́, nǔ e nɔ nyí nǔ è ma nyí ǎ é./// é nɔ lɛ́ kɔ́n nugbǒ nú nùɖé lɛ́ɛ ɖò vector ɔ́ mɛ bɔ ///triple_sum_to_zero nɔ sɔ́ nùxwlé lɛ sín vector dó wlan nùxwlé lɛ./// >>> triples_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])
/// true
/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])
/// true
/// >>> triples_sum_to_zero(vec![1])
/// false
fn triples_sum_to_zero(l: Vec<isize>) -> bool {
","fn triples_sum_to_zero(l: Vec<isize>) -> bool {
    let n = l.len();
    if n < 3 {
        return false;
    }

    let mut sorted_l = l.clone();
    sorted_l.sort();

    for i in 0..n-2 {
        let a = sorted_l[i];
        let mut left = i + 1;
        let mut right = n - 1;

        while left < right {
            let sum = a + sorted_l[left] + sorted_l[right];
            if sum == 0 {
                return true;
            } else if sum < 0 {
                left += 1;
            } else {
                right -= 1;
            }
        }
    }

    false
}","}

fn main() {
    let candidate = triples_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, 5, -1]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), true);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![1, 2, 5, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![1, 3, 5, -100]), false);
    assert_eq!(candidate(vec![100, 3, 5, -100]), false);
}
"
HumanEval_41,fon_Latn,rs,"/// Azɔ̀n élɔ́ nɔ́ ná nùɖé lɛ́ɛ mɛ̀ nùɖé lɛ́ɛ./// ɖò ali e ye gbɔn wɛ é jí é ɖɔhun, ɖi ɖɔ ye ma xò ye kpɔ́n kpɔ́n ǎ ɖɔhun.//Amɔ̌, kɛkɛ́ lɛ́ɛ ɖó hlɔnhlɔn bo nɔ́ syɛ́n tawun; enɛ wu ɔ́, ye nɔ kpó ɖò yiyi wɛ./// hwenu e mɔto e ɖò yiyi wɛ sín amyɔxwé yì ɖisixwé é xò mɔto e ɖò yiyi wɛ sín ɖisixwé yì amyɔxwé é.//Mɔto lɛ bǐ nɔ zɔn zɔnlin ɖokpo ɔ jí.//E ɖò ali jɛ́n wɛ bɔ mɛ wè lɛ́ɛ ɖò zɔ́n nú mì.///n mɔto lɛ ɖo yiyi wɛ sín amyɔxwé yì ɖisixwé; ɖò hwe ɖokpo ɔ nu ɔ, mɔto lɛ tɔn vovo lɛ nɔ ɖo yiyi wɛ ///Mi vɛdó ɖɔ ali ɖé wɛ nyí ali ɖagbe e nɔ cí gblógbló é ɖé wɛ à.fn car_race_collision(n: isize) -> isize {
","fn car_race_collision(n: isize) -> isize {
    // Since every car moving left to right will collide exactly once
    // with every car moving right to left, the number of collisions is n * n
    n * n
}

fn main() {
    let n = 5;
    println!(""Number of collisions: {}"", car_race_collision(n));
}","}

fn main() {
    let candidate = car_race_collision;
    assert_eq!(candidate(2), 4);
    assert_eq!(candidate(3), 9);
    assert_eq!(candidate(4), 16);
    assert_eq!(candidate(8), 64);
    assert_eq!(candidate(10), 100);
}
"
HumanEval_42,fon_Latn,rs,"/// É nɔ́ lɛ́ kɔ́n nǔ lɛ́ɛ ɖó 1 jí./// >>> incr_list(vec![1, 2, 3])
/// vec![2, 3, 4]
/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])
/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]
fn incr_list(l: Vec<isize>) -> Vec<isize> {
","fn incr_list(l: Vec<isize>) -> Vec<isize> {
    l.iter().map(|&x| x + 1).collect()
}","}

fn main() {
    let candidate = incr_list;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);
    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);
}
"
HumanEval_43,fon_Latn,rs,"/// nǔ e nɔ nyí nǔ ɔ́ nɔ́ nyí nǔ nú ɔ́, nǔ e nɔ nyí nǔ è ma nyí ǎ é./// é nɔ lɛ́ kɔ́n nugbǒ nú nùɖé lɛ́ ɖò vector ɔ́ mɛ bɔ /// pairs_sum_to_zero nɔ sɔ́ nùxwlé lɛ sín vector dó wlan nǔ./// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])
/// false
/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])
/// false
/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])
/// false
/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])
/// true
/// >>> pairs_sum_to_zero(vec![1])
/// false
fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
","fn pairs_sum_to_zero(l: Vec<isize>) -> bool {
    use std::collections::HashSet;
    let mut seen = HashSet::new();
    
    for &num in &l {
        if seen.contains(&-num) {
            return true;
        }
        seen.insert(num);
    }
    false
}

fn main() {
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, 5, 0])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 3, -2, 1])); // false
    println!(""{}"", pairs_sum_to_zero(vec![1, 2, 3, 7])); // false
    println!(""{}"", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); // true
    println!(""{}"", pairs_sum_to_zero(vec![1])); // false
}","}

fn main() {
    let candidate = pairs_sum_to_zero;
    assert_eq!(candidate(vec![1, 3, 5, 0]), false);
    assert_eq!(candidate(vec![1, 3, -2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 3, 7]), false);
    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);
    assert_eq!(candidate(vec![1]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);
    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);
}
"
HumanEval_44,fon_Latn,rs,"/// nùxwásá lɛ́ɛ ɖò hweɖénu hú 10. /// lɛ́ kɔ́n nùjlɛ́jlɛ́ sín nùjlɛ́jlɛ́ ɖò nùjlɛ́jlɛ́ ɔ́ gudo./// Zɔ́n nùjlɛ́jlɛ́ nùjlɛ́jlɛ́ x tɔn dó nùjlɛ́jlɛ́jlɛ́ jí. /// >>> change_base(8, 3)
/// String::from(""22"")
/// >>> change_base(8, 2)
/// String::from(""1000"")
/// >>> change_base(7, 2)
/// String::from(""111"")
fn change_base(x: isize, base: isize) -> String {
","fn change_base(x: isize, base: isize) -> String {
    if base < 2 || base > 9 {
        panic!(""Base must be between 2 and 9"");
    }
    
    if x == 0 {
        return String::from(""0"");
    }
    
    let mut result = String::new();
    let mut number = x;
    
    while number > 0 {
        let remainder = number % base;
        result.push_str(&remainder.to_string());
        number /= base;
    }
    
    result.chars().rev().collect()
}","}

fn main() {
    let candidate = change_base;
    assert_eq!(candidate(8, 3), String::from(""22""));
    assert_eq!(candidate(9, 3), String::from(""100""));
    assert_eq!(candidate(234, 2), String::from(""11101010""));
    assert_eq!(candidate(16, 2), String::from(""10000""));
    assert_eq!(candidate(8, 2), String::from(""1000""));
    assert_eq!(candidate(7, 2), String::from(""111""));
    assert_eq!(candidate(2, 3), String::from(""2""));
    assert_eq!(candidate(3, 4), String::from(""3""));
    assert_eq!(candidate(4, 5), String::from(""4""));
    assert_eq!(candidate(5, 6), String::from(""5""));
    assert_eq!(candidate(6, 7), String::from(""6""));
    assert_eq!(candidate(7, 8), String::from(""7""));
}
"
HumanEval_45,fon_Latn,rs,"///Nɛ è na mɔ akpáxwé ɔ sín gǒjíblánú kpo fí e è na lɛ́ lɛ́ kɔ́n dó é kpo nú atɔnví ɖé./// >>> triangle_area(5, 3)
/// 7.5
fn triangle_area(a: isize, h: isize) -> f64 {
","fn triangle_area(a: isize, h: isize) -> f64 {
    (a as f64 * h as f64) / 2.0
}

fn main() {
    let area = triangle_area(5, 3);
    println!(""{}"", area);
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(5, 3), 7.5);
    assert_eq!(candidate(2, 2), 2.0);
    assert_eq!(candidate(10, 8), 40.0);
}
"
HumanEval_46,fon_Latn,rs,"/// Mi wlan azɔ̀ ɖé bo na dó mɔ nùɖé lɛ́ɛ ɖò nùjlɛ́jlɛ́ fib4 tɔn mɛ. Mi ma zán nǔ lɛ́ɛ dó lɛ́ lɛ́ kɔ́n ó. /// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)./// fib4(3) -> 0 /// fib4(2) -> 2 /// fib4(1) -> 0 /// fib4(0) -> 0 /// Fib4 nùxwásá ɔ́' nǔxwásá e cí Fibbonacci sín nǔxwásá ɔ́ ɖɔhun é wɛ è ɖè ɖɔ: /// >>> fib4(5)
/// 4
/// >>> fib4(6)
/// 8
/// >>> fib4(7)
/// 14
fn fib4(n: isize) -> isize {
","fn fib4(n: isize) -> isize {
    if n < 0 {
        return 0; // Define behavior for negative input
    }

    let mut sequence = vec![0, 0, 2, 0];

    if n < 4 {
        return sequence[n as usize];
    }

    for i in 4..=n {
        let next_value = sequence[(i - 1) as usize] 
                       + sequence[(i - 2) as usize] 
                       + sequence[(i - 3) as usize] 
                       + sequence[(i - 4) as usize];
        sequence.push(next_value);
    }

    sequence[n as usize]
}

fn main() {
    println!(""{}"", fib4(5)); // 4
    println!(""{}"", fib4(6)); // 8
    println!(""{}"", fib4(7)); // 14
}","}

fn main() {
    let candidate = fib4;
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 28);
    assert_eq!(candidate(10), 104);
    assert_eq!(candidate(12), 386);
}
"
HumanEval_47,fon_Latn,rs,"/// Ðàñõîäíûé ñðåäíèé ýëåìåíò ýëåìåíòîâ â âåêòîðå l. /// >>> median(vec![3, 1, 2, 4, 5])
/// 3.0
/// >>> median(vec![-10, 4, 6, 1000, 10, 20])
/// 15.0
fn median(l: Vec<isize>) -> f64 {
","fn median(l: Vec<isize>) -> f64 {
    let mut l = l.clone();
    l.sort();
    let len = l.len();

    if len % 2 == 0 {
        let mid1 = len / 2;
        let mid2 = mid1 - 1;
        ((l[mid1] as f64) + (l[mid2] as f64)) / 2.0
    } else {
        l[len / 2] as f64
    }
}","}

fn main() {
    let candidate = median;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);
    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);
    assert_eq!(candidate(vec![5]), 5.0);
    assert_eq!(candidate(vec![6, 5]), 5.5);
    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);
}
"
HumanEval_48,fon_Latn,rs,"/// Nɔ kpɔ́n ɖɔ xɛ ɔ nyí palindrome à jí /// >>> is_palindrome(String::from(""""))
/// true
/// >>> is_palindrome(String::from(""aba""))
/// true
/// >>> is_palindrome(String::from(""aaaaa""))
/// true
/// >>> is_palindrome(String::from(""zbcd""))
/// false
fn is_palindrome(text: String) -> bool {
","fn is_palindrome(text: String) -> bool {
    let chars: Vec<char> = text.chars().collect();
    let len = chars.len();
    for i in 0..len / 2 {
        if chars[i] != chars[len - 1 - i] {
            return false;
        }
    }
    true
}","}

fn main() {
    let candidate = is_palindrome;
    assert_eq!(candidate(String::from("""")), true);
    assert_eq!(candidate(String::from(""aba"")), true);
    assert_eq!(candidate(String::from(""aaaaa"")), true);
    assert_eq!(candidate(String::from(""zbcd"")), false);
    assert_eq!(candidate(String::from(""xywyx"")), true);
    assert_eq!(candidate(String::from(""xywyz"")), false);
    assert_eq!(candidate(String::from(""xywzx"")), false);
}
"
HumanEval_49,fon_Latn,rs,"/// lɛ́ kɔ́n 2^n modulo p (nǔ nú nùjlɛ́kpo lɛ́ɛ)./// >>> modp(3, 5)
/// 3
/// >>> modp(1101, 101)
/// 2
/// >>> modp(0, 101)
/// 1
/// >>> modp(3, 11)
/// 8
/// >>> modp(100, 101)
/// 1
fn modp(n: isize, p: isize) -> isize {
","fn modp(n: isize, p: isize) -> isize {
    if p == 1 {
        return 0;
    }
    let mut result = 1;
    let mut base = 2 % p;
    let mut exponent = n;
    
    while exponent > 0 {
        if exponent % 2 == 1 {
            result = (result * base) % p;
        }
        base = (base * base) % p;
        exponent /= 2;
    }
    
    result
}","}

fn main() {
    let candidate = modp;
    assert_eq!(candidate(3, 5), 3);
    assert_eq!(candidate(1101, 101), 2);
    assert_eq!(candidate(0, 101), 1);
    assert_eq!(candidate(3, 11), 8);
    assert_eq!(candidate(100, 101), 1);
    assert_eq!(candidate(30, 5), 4);
    assert_eq!(candidate(31, 5), 3);
}
"
HumanEval_51,fon_Latn,rs,"/// remove_vowels nyí azɔ̀ e nɔ yí wèmá bó nɔ lɛ́ lɛ́ wèmá e mɛ wèmá ɖě ma ɖè ǎ é./// >>> remove_vowels(String::from(""""))
/// String::from("""")
/// >>> remove_vowels(String::from(""abcdef""))
/// String::from(""bcdf"")
/// >>> remove_vowels(String::from(""aaaaa""))
/// String::from("""")
/// >>> remove_vowels(String::from(""aaBAA""))
/// String::from(""B"")
/// >>> remove_vowels(String::from(""zbcd""))
/// String::from(""zbcd"")
fn remove_vowels(text: String) -> String {
","fn remove_vowels(text: String) -> String {
    text.chars()
        .filter(|&c| !""aeiouAEIOU"".contains(c))
        .collect()
}","}

fn main() {
    let candidate = remove_vowels;
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""abcdef
ghijklm"")), String::from(""bcdf
ghjklm""));
    assert_eq!(candidate(String::from(""fedcba"")), String::from(""fdcb""));
    assert_eq!(candidate(String::from(""eeeee"")), String::from(""""));
    assert_eq!(candidate(String::from(""acBAA"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""EcBOO"")), String::from(""cB""));
    assert_eq!(candidate(String::from(""ybcd"")), String::from(""ybcd""));
}
"
HumanEval_52,fon_Latn,rs,"/// Yi lɛ́ kɔ́n nugbǒ nú nùxwɛ́ l lɛ́ɛ bǐ ɖò fí e è nɔ ylɔ́ ɖɔ t é. /// >>> below_threshold(vec![1, 2, 4, 10], 100)
/// true
/// >>> below_threshold(vec![1, 20, 4, 10], 5)
/// false
fn below_threshold(l: Vec<isize>, t: isize) -> bool {
","fn below_threshold(l: Vec<isize>, t: isize) -> bool {
    l.iter().all(|&x| x < t)
}

fn main() {
    println!(""{}"", below_threshold(vec![1, 2, 4, 10], 100)); // true
    println!(""{}"", below_threshold(vec![1, 20, 4, 10], 5));  // false
}","}

fn main() {
    let candidate = below_threshold;
    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);
    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);
    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);
    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);
}
"
HumanEval_53,fon_Latn,rs,"/// Kplɔn nùxà wè x kpo y kpo /// >>> add(2, 3)
/// 5
/// >>> add(5, 7)
/// 12
fn add(x: isize, y: isize) -> isize {
","fn add(x: isize, y: isize) -> isize {
    x + y
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(0, 1), 1);
    assert_eq!(candidate(1, 0), 1);
    assert_eq!(candidate(2, 3), 5);
    assert_eq!(candidate(5, 7), 12);
    assert_eq!(candidate(7, 5), 12);
}
"
HumanEval_54,fon_Latn,rs,"/// Kpɔ́n ɖɔ xókwin wè ɖó wuntun ɖokpo ɔ à jí. /// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))
/// true
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabc""))
/// true
/// >>> same_chars(String::from(""dddddddabc""), String::from(""abcd""))
/// true
/// >>> same_chars(String::from(""eabcd""), String::from(""dddddddabc""))
/// false
/// >>> same_chars(String::from(""abcd""), String::from(""dddddddabce""))
/// false
/// >>> same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))
/// false
fn same_chars(s0: String, s1: String) -> bool {
","use std::collections::HashSet;

fn same_chars(s0: String, s1: String) -> bool {
    let set0: HashSet<char> = s0.chars().collect();
    let set1: HashSet<char> = s1.chars().collect();
    set0 == set1
}

fn main() {
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc""))); // true
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabc""))); // true
    println!(""{}"", same_chars(String::from(""dddddddabc""), String::from(""abcd""))); // true
    println!(""{}"", same_chars(String::from(""eabcd""), String::from(""dddddddabc""))); // false
    println!(""{}"", same_chars(String::from(""abcd""), String::from(""dddddddabce""))); // false
    println!(""{}"", same_chars(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc""))); // false
}","}

fn main() {
    let candidate = same_chars;
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddeddabc"")), true);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabc"")), true);
    assert_eq!(candidate(String::from(""dddddddabc""), String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""eabcd""), String::from(""dddddddabc"")), false);
    assert_eq!(candidate(String::from(""abcd""), String::from(""dddddddabcf"")), false);
    assert_eq!(candidate(String::from(""eabcdzzzz""), String::from(""dddzzzzzzzddddabc"")), false);
    assert_eq!(candidate(String::from(""aabb""), String::from(""aaccc"")), false);
}
"
HumanEval_55,fon_Latn,rs,"/// Ðɔ nú Fibonacci nùxwásá n-gɔ́ ɔ. /// >>> fib(10)
/// 55
/// >>> fib(1)
/// 1
/// >>> fib(8)
/// 21
fn fib(n: isize) -> isize {
","fn fib(n: isize) -> isize {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 1) + fib(n - 2),
    }
}

fn main() {
    println!(""{}"", fib(10)); // 55
    println!(""{}"", fib(1));  // 1
    println!(""{}"", fib(8));  // 21
}","}

fn main() {
    let candidate = fib;
    assert_eq!(candidate(10), 55);
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(8), 21);
    assert_eq!(candidate(11), 89);
    assert_eq!(candidate(12), 144);
}
"
HumanEval_56,fon_Latn,rs,"/// lɛ́ kɔ́n true nú alɔnu e nɔ́ hun ɔ́ ɖokpó ɖokpó ɖó alɔnu e nɔ́ sú ɔ́ ɖokpó. /// brackets ɔ wɛ nyí wuntun ""<"" kpo "">"" kpo./// >>> correct_bracketing(String::from(""<""))
/// false
/// >>> correct_bracketing(String::from(""<>""))
/// true
/// >>> correct_bracketing(String::from(""<<><>>""))
/// true
/// >>> correct_bracketing(String::from(""><<>""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for bracket in brackets.chars() {
        if bracket == '<' {
            balance += 1;
        } else if bracket == '>' {
            balance -= 1;
            if balance < 0 {
                return false;
            }
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""<>"")), true);
    assert_eq!(candidate(String::from(""<<><>>"")), true);
    assert_eq!(candidate(String::from(""<><><<><>><>"")), true);
    assert_eq!(candidate(String::from(""<><><<<><><>><>><<><><<>>>"")), true);
    assert_eq!(candidate(String::from(""<<<><>>>>"")), false);
    assert_eq!(candidate(String::from(""><<>"")), false);
    assert_eq!(candidate(String::from(""<"")), false);
    assert_eq!(candidate(String::from(""<<<<"")), false);
    assert_eq!(candidate(String::from("">"")), false);
    assert_eq!(candidate(String::from(""<<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>><<>"")), false);
    assert_eq!(candidate(String::from(""<><><<><>><>>><>"")), false);
}
"
HumanEval_57,fon_Latn,rs,"/// Yi lɛ́ wá true nyí nùɖé lɛ́ ɖò jijɛji wɛ̀ alǒ ɖò dín wɛ̀./// >>> monotonic(vec![1, 2, 4, 20])
/// true
/// >>> monotonic(vec![1, 20, 4, 10])
/// false
/// >>> monotonic(vec![4, 1, 0, -10])
/// true
fn monotonic(l: Vec<isize>) -> bool {
","fn monotonic(l: Vec<isize>) -> bool {
    if l.len() <= 1 {
        return true;
    }
    
    let mut increasing = true;
    let mut decreasing = true;
    
    for i in 0..l.len() - 1 {
        if l[i] < l[i + 1] {
            decreasing = false;
        }
        if l[i] > l[i + 1] {
            increasing = false;
        }
    }
    
    increasing || decreasing
}

fn main() {
    println!(""{}"", monotonic(vec![1, 2, 4, 20])); // true
    println!(""{}"", monotonic(vec![1, 20, 4, 10])); // false
    println!(""{}"", monotonic(vec![4, 1, 0, -10])); // true
}","}

fn main() {
    let candidate = monotonic;
    assert_eq!(candidate(vec![1, 2, 4, 10]), true);
    assert_eq!(candidate(vec![1, 2, 4, 20]), true);
    assert_eq!(candidate(vec![1, 20, 4, 10]), false);
    assert_eq!(candidate(vec![4, 1, 0, -10]), true);
    assert_eq!(candidate(vec![4, 1, 1, 0]), true);
    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);
    assert_eq!(candidate(vec![9, 9, 9, 9]), true);
}
"
HumanEval_58,fon_Latn,rs,"/// É nɔ lɛ́ lɛ́ wá nú nǔ e nyí nǔ ɖokpo ɔ bɔ è nɔ ɖó ɖò vectɔ́ wè lɛ́ɛ mɛ é./// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])
/// vec![1, 5, 653]
/// >>> common(vec![5, 3, 2, 8], vec![3, 2])
/// vec![2, 3]
fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
","use std::collections::HashSet;

fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {
    // Convert both vectors to hash sets to remove duplicates and allow set operations
    let set1: HashSet<_> = l1.into_iter().collect();
    let set2: HashSet<_> = l2.into_iter().collect();

    // Find the intersection of both sets
    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();

    // Convert the intersection set to a sorted vector
    let mut result: Vec<_> = intersection.into_iter().collect();
    result.sort();

    result
}

fn main() {
    // Test cases
    println!(""{:?}"", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); // Should print: [1, 5, 653]
    println!(""{:?}"", common(vec![5, 3, 2, 8], vec![3, 2])); // Should print: [2, 3]
}","}

fn main() {
    let candidate = common;
    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);
    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);
    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);
    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());
}
"
HumanEval_59,fon_Latn,rs,"/// Ðɔ nùxwléma nùjlɛ́jlɛ́ tɔn ɖaxó hugǎn n tɔn. Mi ɖɔ ɖɔ n > 1 bo nyí nùjlɛ́jlɛ́jlɛ́jlɛ́ ɖé ǎ. /// >>> largest_prime_factor(13195)
/// 29
/// >>> largest_prime_factor(2048)
/// 2
fn largest_prime_factor(n: isize) -> isize {
","fn largest_prime_factor(mut n: isize) -> isize {
    let mut largest_factor = 1;

    // Check for number of twos that divide n
    while n % 2 == 0 {
        largest_factor = 2;
        n /= 2;
    }

    // n must be odd at this point, so we can skip even numbers
    let mut factor = 3;
    while factor * factor <= n {
        while n % factor == 0 {
            largest_factor = factor;
            n /= factor;
        }
        factor += 2;
    }

    // If n becomes a prime number greater than 2
    if n > 2 {
        largest_factor = n;
    }

    largest_factor
}

fn main() {
    println!(""{}"", largest_prime_factor(13195));
    println!(""{}"", largest_prime_factor(2048));
}","}

fn main() {
    let candidate = largest_prime_factor;
    assert_eq!(candidate(15), 5);
    assert_eq!(candidate(27), 3);
    assert_eq!(candidate(63), 7);
    assert_eq!(candidate(330), 11);
    assert_eq!(candidate(13195), 29);
}
"
HumanEval_60,fon_Latn,rs,"/// sum_to_n nyí azɔ̀ e nɔ́ sɔ́ nùxwásá sín 1 jɛ n jí é. /// >>> sum_to_n(30)
/// 465
/// >>> sum_to_n(100)
/// 5050
/// >>> sum_to_n(5)
/// 15
/// >>> sum_to_n(10)
/// 55
/// >>> sum_to_n(1)
/// 1
fn sum_to_n(n: isize) -> isize {
","fn sum_to_n(n: isize) -> isize {
    n * (n + 1) / 2
}","}

fn main() {
    let candidate = sum_to_n;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(6), 21);
    assert_eq!(candidate(11), 66);
    assert_eq!(candidate(30), 465);
    assert_eq!(candidate(100), 5050);
}
"
HumanEval_61,fon_Latn,rs,"/// lɛ́ kɔ́n true nú alɔnu e nɔ́ hun ɔ́ ɖokpó ɖokpó ɖó alɔnu e nɔ́ sú ɔ́ ɖokpó. /// brackets ɔ wɛ nyí wuntun ""("" kpo """") /// >>> correct_bracketing(String::from(""(""))
/// false
/// >>> correct_bracketing(String::from(""()""))
/// true
/// >>> correct_bracketing(String::from(""(()())""))
/// true
/// >>> correct_bracketing(String::from("")(()""))
/// false
fn correct_bracketing(brackets: String) -> bool {
","fn correct_bracketing(brackets: String) -> bool {
    let mut balance = 0;
    
    for c in brackets.chars() {
        if c == '(' {
            balance += 1;
        } else if c == ')' {
            balance -= 1;
        }

        if balance < 0 {
            return false;
        }
    }
    
    balance == 0
}","}

fn main() {
    let candidate = correct_bracketing;
    assert_eq!(candidate(String::from(""()"")), true);
    assert_eq!(candidate(String::from(""(()())"")), true);
    assert_eq!(candidate(String::from(""()()(()())()"")), true);
    assert_eq!(candidate(String::from(""()()((()()())())(()()(()))"")), true);
    assert_eq!(candidate(String::from(""((()())))"")), false);
    assert_eq!(candidate(String::from("")(()"")), false);
    assert_eq!(candidate(String::from(""("")), false);
    assert_eq!(candidate(String::from(""(((("")), false);
    assert_eq!(candidate(String::from("")"")), false);
    assert_eq!(candidate(String::from(""(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())())(()"")), false);
    assert_eq!(candidate(String::from(""()()(()())()))()"")), false);
}
"
HumanEval_62,fon_Latn,rs,"/// Zɔ́n nùɖé sín xóɖɔɖókpɔ́ enɛ tɔn dó nùjɔnú ɖokpo ɔ mɛ. /// xs[0] + xs[1] * x + xs[2] * x^2 + .... ///xs nɔ ɖe xlɛ́ nùxwlé lɛ́ɛ nú nùxwlé lɛ́ɛ./// >>> derivative(vec![3, 1, 2, 4, 5])
/// vec![1, 4, 12, 20]
/// >>> derivative(vec![1, 2, 3])
/// vec![2, 6]
fn derivative(xs: Vec<isize>) -> Vec<isize> {
","fn derivative(xs: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::new();
    for (i, &coeff) in xs.iter().enumerate().skip(1) {
        result.push(coeff * i as isize);
    }
    result
}

fn main() {
    let poly1 = vec![3, 1, 2, 4, 5];
    let poly2 = vec![1, 2, 3];
    println!(""{:?}"", derivative(poly1)); // Output: [1, 4, 12, 20]
    println!(""{:?}"", derivative(poly2)); // Output: [2, 6]
}","}

fn main() {
    let candidate = derivative;
    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);
    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);
    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);
    assert_eq!(candidate(vec![1]), Vec::<isize>::new());
}
"
HumanEval_63,fon_Latn,rs,"/// Mi wlan azɔ̀ e ná dó mɔ nùɖé lɛ́ɛ ɔ́ nú mi ná dó mɔ nùɖé lɛ́ɛ ɔ́ nú mi ná dó mɔ nùɖé lɛ́ɛ ɔ́ nú mi ná dó mɔ nùɖé lɛ́ɛ ɔ́ nú mi ná dó mɔ nùɖé lɛ́ɛ ɔ́ nú mi./// fibfib{n) == fibfib{n-1) + fibfib{n-2) + fibfib{n-3)./// fib fib ((2) == 1 /// fib fib ((1) == 0 /// fib fib ((0) == 0 /// FibFib nùxwásá sín nùxwásá ɔ́' nǔxwásá e cí Fibbonacci sín nùxwásá é ɖɔhun bɔ è ɖè ɖɔ̀: /// >>> fibfib(1)
/// 0
/// >>> fibfib(5)
/// 4
/// >>> fibfib(8)
/// 24
fn fibfib(n: isize) -> isize {
","fn fibfib(n: isize) -> isize {
    if n < 0 {
        // Optionally handle negative indices as an error or specific value
        return -1; // Example error indicator
    }
    match n {
        0 => 0,
        1 => 0,
        2 => 1,
        _ => {
            let mut a = 0;
            let mut b = 0;
            let mut c = 1;
            let mut result = 0;
            for _ in 3..=n {
                result = a + b + c;
                a = b;
                b = c;
                c = result;
            }
            result
        }
    }
}","}

fn main() {
    let candidate = fibfib;
    assert_eq!(candidate(2), 1);
    assert_eq!(candidate(1), 0);
    assert_eq!(candidate(5), 4);
    assert_eq!(candidate(8), 24);
    assert_eq!(candidate(10), 81);
    assert_eq!(candidate(12), 274);
    assert_eq!(candidate(14), 927);
}
"
HumanEval_64,fon_Latn,rs,"/// Kpɔ́n: /// vowel, amɔ̌ enyi é ɖò xógbe e è na é sín vivɔnu ɔ jɛn wɛ ɔ./// Wùnnúmɛ ɖò xó elɔ mɛ ɔ wɛ nyí 'a', 'e', 'i', 'o', 'u'. 'y' ɖò fí ɔ lɔ nyí 'a'/// xógbe ɖé dó mɔ nǔ è nɔ dó é bo nɔ lɛ́ lɛ́ nú vowel lɛ́ɛ ɖò wuntun ɔ mɛ./// Wlǎn azɔ̀ vowels_count e nɔ yí wèmá e nɔ ɖè /// >>> vowels_count(String::from(""abcde""))
/// 2
/// >>> vowels_count(String::from(""ACEDY""))
/// 3
fn vowels_count(s: String) -> isize {
","fn vowels_count(s: String) -> isize {
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let s = s.to_lowercase();
    let mut count = 0;

    for (i, c) in s.chars().enumerate() {
        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {
            count += 1;
        }
    }
    
    count
}

fn main() {
    println!(""{}"", vowels_count(String::from(""abcde""))); // Output: 2
    println!(""{}"", vowels_count(String::from(""ACEDY""))); // Output: 3
}","}

fn main() {
    let candidate = vowels_count;
    assert_eq!(candidate(String::from(""abcde"")), 2);
    assert_eq!(candidate(String::from(""Alone"")), 3);
    assert_eq!(candidate(String::from(""key"")), 2);
    assert_eq!(candidate(String::from(""bye"")), 1);
    assert_eq!(candidate(String::from(""keY"")), 2);
    assert_eq!(candidate(String::from(""bYe"")), 1);
    assert_eq!(candidate(String::from(""ACEDY"")), 3);
}
"
HumanEval_65,fon_Latn,rs,"/// Nú shift > nùxwásá nú wèmá lɛ́ɛ ɔ́, wèmá lɛ́ɛ ná lɛ́ kɔ́n./// bo na lɛ́ vɔ́ nǔ e è mɔ é dó wuntun ɖé mɛ./// Nɔ ɖyɔ́ nùjlɛ́kpo x tɔn lɛ́ɛ ɖó zɔ̀n, nɔ ɖyɔ́ nùjlɛ́kpo lɛ́ɛ ɖó ɖisíxwé ɖó zɔ̀n./// >>> circular_shift(12, 1)
/// String::from(""21"")
/// >>> circular_shift(12, 2)
/// String::from(""12"")
fn circular_shift(x: isize, shift: isize) -> String {
","fn circular_shift(x: isize, shift: isize) -> String {
    let mut digits: Vec<char> = x.abs().to_string().chars().collect();
    let len = digits.len() as isize;
    
    if shift > len {
        digits.reverse();
    } else {
        digits.rotate_right(shift as usize % len as usize);
    }
    
    digits.into_iter().collect()
}","}

fn main() {
    let candidate = circular_shift;
    assert_eq!(candidate(100, 2), String::from(""001""));
    assert_eq!(candidate(12, 2), String::from(""12""));
    assert_eq!(candidate(97, 8), String::from(""79""));
    assert_eq!(candidate(12, 1), String::from(""21""));
    assert_eq!(candidate(11, 101), String::from(""11""));
}
"
HumanEval_66,fon_Latn,rs,"/// Kpɔ́ndéwú: /// ASCII wèmá. /// Wlan azɔ̀ e nɔ yí wèmá wèmá ɖé dó mɛ bo nɔ lɛ́ lɛ́ yí wèmá ɖaxó lɛ́ɛ sín nùxwásá dó mɛ é' /// Azɔ̌ /// >>> digitSum(String::from(""""))
/// 0
/// >>> digitSum(String::from(""abAB""))
/// 131
/// >>> digitSum(String::from(""abcCd""))
/// 67
/// >>> digitSum(String::from(""helloE""))
/// 69
/// >>> digitSum(String::from(""woArBld""))
/// 131
/// >>> digitSum(String::from(""aAaaaXa""))
/// 153
fn digitSum(s: String) -> isize {
","fn digitSum(s: String) -> isize {
    s.chars()
     .filter(|c| c.is_uppercase())
     .map(|c| c as isize)
     .sum()
}","}

fn main() {
    let candidate = digitSum;
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""abAB"")), 131);
    assert_eq!(candidate(String::from(""abcCd"")), 67);
    assert_eq!(candidate(String::from(""helloE"")), 69);
    assert_eq!(candidate(String::from(""woArBld"")), 131);
    assert_eq!(candidate(String::from(""aAaaaXa"")), 153);
    assert_eq!(candidate(String::from("" How are yOu?"")), 151);
    assert_eq!(candidate(String::from(""You arE Very Smart"")), 327);
}
"
HumanEval_67,fon_Latn,rs,"/// nú examble: /// ɖò xasun ɔ mɛ ɔ mi na lɛ́ ɖɔ kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n kpɔ́n./// ɔlansi kpo atinsinsɛn kpo kpo kpo kpodo xwiɖe e nɔte nú atinsɛn lɛ bǐ tɔn kpo /// ɔ, è na wlan nùjlɛdonǔwu e nɔ xlɛ́ ɖɔ /// e nɔ ɖò atín sín xasun ɖé mɛ bɔ atín sín xasun enɛ ɔ nɔ ɖò mɛ é /// Ðò azɔ̌ elɔ mɛ ɔ, è na na we xwɛ e nɔte nú atinsinsinsɛn kpo atinsɛn kpo é ɖokpo ɖokpo./// >>> fruit_distribution(String::from(""5 apples and 6 oranges""), 19)
/// 8
/// >>> fruit_distribution(String::from(""0 apples and 1 oranges""), 3)
/// 2
/// >>> fruit_distribution(String::from(""2 apples and 3 oranges""), 100)
/// 95
/// >>> fruit_distribution(String::from(""100 apples and 1 oranges""), 120)
/// 19
fn fruit_distribution(s: String, n: isize) -> isize {
","fn fruit_distribution(s: String, n: isize) -> isize {
    let mut parts = s.split_whitespace();
    let apples: isize = parts.next().unwrap().parse().unwrap();
    parts.next(); // skip ""apples""
    parts.next(); // skip ""and""
    let oranges: isize = parts.next().unwrap().parse().unwrap();
    
    n - (apples + oranges)
}

fn main() {
    assert_eq!(fruit_distribution(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(fruit_distribution(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(fruit_distribution(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(fruit_distribution(String::from(""100 apples and 1 oranges""), 120), 19);
    println!(""All test cases passed!"");
}","}

fn main() {
    let candidate = fruit_distribution;
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 19), 8);
    assert_eq!(candidate(String::from(""5 apples and 6 oranges""), 21), 10);
    assert_eq!(candidate(String::from(""0 apples and 1 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""1 apples and 0 oranges""), 3), 2);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 100), 95);
    assert_eq!(candidate(String::from(""2 apples and 3 oranges""), 5), 0);
    assert_eq!(candidate(String::from(""1 apples and 100 oranges""), 120), 19);
}
"
HumanEval_68,fon_Latn,rs,"//Kpɔ́nmɛ 1: /// Nú nùɖé ma ɖò nùɖé jí ǎ alǒ nùɖé ma ɖò nǔ jí ǎ ɔ, lɛ́ kɔ yì []. /// Nudó e è sɔ́ dó ɔ́ ɖó na lɛ́ kɔ́n dó vector mɛ, [smallest_value, its index], /// Nú è mɔ nɔ̀n gègě bo ɖó nùxíɖíɖó e nyí nǔ e ɖò hweɖenu é ɖokpó ɔ ɔ ɔ, lɛ́ kɔ nú nɔ̀n e ɖó nùxíɖíɖó e nyí nǔ e ɖò hweɖenu é é. /// Nudó e è sɔ́ ɖó vo é wɛ ɖó ná nyí nudó e ɖó akwɛ́ e nyí ganvín é é.//azɔ̌ towe wɛ nyí ɖɔ a na yí nùɖíɖó lɛ ɖokpo bo na lɛ́ wá./// ""Ðåøàÿ âåêòîð ïðåäñòàâëÿþùèé ðàçäåë êðûøè, êîòîðûé èìååò íåïðåâûøàþùèå ïîëîâûå ÷èñëû êîíòðîëåé /// >>> pluck(vec![4, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 2:
/// >>> pluck(vec![1, 2, 3])
/// vec![2, 1]
/// Explanation: 2 has the smallest even value, and 2 has the smallest index.
/// Example 3:
/// >>> pluck(vec![])
/// Vec::<isize>::new()
/// Example 4:
/// >>> pluck(vec![5, 0, 3, 0, 4, 2])
/// vec![0, 1]
/// Explanation: 0 is the smallest value, but  there are two zeros,
/// so we will choose the first zero, which has the smallest index.
/// Constraints:
/// * 1 <= nodes.length <= 10000
/// * 0 <= node.value
fn pluck(arr: Vec<isize>) -> Vec<isize> {
","fn pluck(arr: Vec<isize>) -> Vec<isize> {
    let mut smallest_even: Option<(isize, usize)> = None;

    for (index, &value) in arr.iter().enumerate() {
        if value % 2 == 0 {
            match smallest_even {
                None => smallest_even = Some((value, index)),
                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),
                _ => {}
            }
        }
    }

    match smallest_even {
        Some((value, index)) => vec![value, index as isize],
        None => Vec::new(),
    }
}","}

fn main() {
    let candidate = pluck;
    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);
    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);
    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);
    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);
    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());
}
"
HumanEval_69,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Nú nùɖé ma ɖò finɛ ǎ ɔ, lɛ́ kɔ́n -1./// Nǔxixa nùxwléma ɖé tɔn wɛ nyí azɔn nabí e é nɔ tɔ́n ɖò vectɔ́ ɔ mɛ é./// zéro, è é ɖó nùxwásá e hú alǒ é cí nùxwásá ɔ ɖesu tɔn é.//e na lɛ́ ná we nùxwléma e nyí nùxwléma e nyí nùxwléma ɖagbe lɛ é tɔn ǎ é. lɛ́ yí nùxwléma e nyí nùxwléma ɖaxó hú  é./// >>> search(vec![4, 1, 2, 2, 3, 1])
/// 2
/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])
/// 3
/// >>> search(vec![5, 5, 4, 4, 4])
/// -1
fn search(lst: Vec<isize>) -> isize {
","fn search(lst: Vec<isize>) -> isize {
    use std::collections::HashMap;
    
    let mut frequency_map = HashMap::new();
    
    // Count the frequency of each integer in the vector
    for &num in &lst {
        *frequency_map.entry(num).or_insert(0) += 1;
    }
    
    let mut result = -1;
    
    // Iterate over the map to find the greatest integer with a frequency
    // greater than or equal to its value
    for (&num, &freq) in &frequency_map {
        if freq >= num && num > result {
            result = num;
        }
    }
    
    result
}

// Test cases
fn main() {
    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);
    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);
    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);
}","}

fn main() {
    let candidate = search;
    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);
    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);
    assert_eq!(candidate(vec![3, 3]), -1);
    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);
    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);
    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);
    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);
    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);
    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);
    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);
    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);
    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);
    assert_eq!(candidate(vec![1]), 1);
    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);
    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);
    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);
    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);
    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);
    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);
    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);
    assert_eq!(candidate(vec![10]), -1);
    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);
    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);
    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);
    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);
}
"
HumanEval_70,fon_Latn,rs,"/// Kpɔ́ndéwú: /// ɔ gudo ɔ e na w'azɔ nú nùxwɛ e ɖò kpo lɛ é bǐ, bɔ enɛ gudo ɔ e na w'azɔ nú nùxwɛ e ɖò kpo lɛ é bǐ./// Nǔ e è nɔ ylɔ ɖɔ nǔ e è nɔ tò ɖó alɔkpa ɖé é ɔ́ wɛ nyí ɖɔ è nɔ bɛ́ nǔ e è nɔ tò ɖó alɔkpa ɖé é.///Eyi ɔ, e na lɛ́ sɔ́ nùjlɛ́kpá lɛ́ɛ sín vectɔ́ ɔ́, é na lɛ́ sɔ́ vectɔ́ ɔ́ dó ali ɖé jí./// >>> strange_sort_list(vec![1, 2, 3, 4])
/// vec![1, 4, 2, 3]
/// >>> strange_sort_list(vec![5, 5, 5, 5])
/// vec![5, 5, 5, 5]
/// >>> strange_sort_list(vec![])
/// Vec::<isize>::new()
fn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {
","fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {
    let mut result = Vec::with_capacity(lst.len());
    lst.sort();

    while !lst.is_empty() {
        // Take the smallest element
        if let Some(min) = lst.first().cloned() {
            result.push(min);
            lst.remove(0);
        }
        // Take the largest element
        if let Some(max) = lst.last().cloned() {
            result.push(max);
            lst.pop();
        }
    }

    result
}

fn main() {
    println!(""{:?}"", strange_sort_list(vec![1, 2, 3, 4])); // Output: vec![1, 4, 2, 3]
    println!(""{:?}"", strange_sort_list(vec![5, 5, 5, 5])); // Output: vec![5, 5, 5, 5]
    println!(""{:?}"", strange_sort_list(vec![])); // Output: Vec::<isize>::new()
}","}

fn main() {
    let candidate = strange_sort_list;
    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);
    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);
    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);
    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);
    assert_eq!(candidate(vec![111111]), vec![111111]);
}
"
HumanEval_71,fon_Latn,rs,"/// Kpɔ́n: /// hú akpáxwé atɔngɔ́ ɔ./// Hwexwɛ ɔ́ ɖó akpáxwé atɔn, nú akpáxwé we lɛ́ɛ bǐ sín nǔhɛnnúmɛ hú ɔ́, è nɔ ylɔ ɖɔ atɔnxwɛ ɔ́./// N'ɛ ma nyí mɔ̌ ǎ ɔ lɛ́ kɔ́n yì -1 /// azinkpo ɔ e è blò nú tɛnkpɔnmɛ wè nú akpáxwé atɔn lɛ nyí azinkpo ɖagbe ɖé é. ///Nɛ́ è na mɔ̀ xwɛ̀ atɔn ɔ́ sín akpáxwé lɛ́ɛ ɔ́, è na lɛ́ mɔ̀ xwɛ̀ ɔ́ sín akpáxwé lɛ́ɛ./// >>> triangle_area(3, 4, 5)
/// 6.0
/// >>> triangle_area(1, 2, 10)
/// -1.0
fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
","fn triangle_area(a: isize, b: isize, c: isize) -> f64 {
    if a + b > c && a + c > b && b + c > a {
        let s = (a + b + c) as f64 / 2.0;
        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();
        (area * 100.0).round() / 100.0
    } else {
        -1.0
    }
}

fn main() {
    println!(""{}"", triangle_area(3, 4, 5)); // 6.0
    println!(""{}"", triangle_area(1, 2, 10)); // -1.0
}","}

fn main() {
    let candidate = triangle_area;
    assert_eq!(candidate(3, 4, 5), 6.0);
    assert_eq!(candidate(1, 2, 10), -1.0);
    assert_eq!(candidate(4, 8, 5), 8.18);
    assert_eq!(candidate(2, 2, 2), 1.73);
    assert_eq!(candidate(1, 2, 3), -1.0);
    assert_eq!(candidate(10, 5, 7), 16.25);
    assert_eq!(candidate(2, 6, 3), -1.0);
    assert_eq!(candidate(1, 1, 1), 0.43);
    assert_eq!(candidate(2, 2, 10), -1.0);
}
"
HumanEval_72,fon_Latn,rs,"/// Kpɔ́n: /// Nǔ e nɔ nyí q ɔ na zɔn hwenu e é ɖò jlɛjɛnǔmɛ é (e nyí palindromic vector) bɔ nǔ e ɖò mɛ lɛ é sín nùxwlé ɔ na vlɔ́n hú alǒ na cí wuvɛ̌ e è sixu ɖó é w. /// Wlan azɔ̀ e nɔ lɛ́ yí gbè nú nugbǒ nú nǔ ɔ́ na yì yì ɔ́, bo nɔ yí gbè nú adingban nú nǔ ɔ́. /// >>> will_it_fly(vec![1, 2], 5)
/// false
/// # 1+2 is less than the maximum possible weight, but it's unbalanced.
/// >>> will_it_fly(vec![3, 2, 3], 1)
/// false
/// # it's balanced, but 3+2+3 is more than the maximum possible weight.
/// >>> will_it_fly(vec![3, 2, 3], 9)
/// true
/// # 3+2+3 is less than the maximum possible weight, and it's balanced.
/// >>> will_it_fly(vec![3], 5)
/// true
/// # 3 is less than the maximum possible weight, and it's balanced.
fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
","fn will_it_fly(q: Vec<isize>, w: isize) -> bool {
    let sum: isize = q.iter().sum();
    let is_palindromic = q.iter().eq(q.iter().rev());

    is_palindromic && sum <= w
}

fn main() {
    // Test cases
    println!(""{}"", will_it_fly(vec![1, 2], 5)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 1)); // false
    println!(""{}"", will_it_fly(vec![3, 2, 3], 9)); // true
    println!(""{}"", will_it_fly(vec![3], 5)); // true
}","}

fn main() {
    let candidate = will_it_fly;
    assert_eq!(candidate(vec![3, 2, 3], 9), true);
    assert_eq!(candidate(vec![1, 2], 5), false);
    assert_eq!(candidate(vec![3], 5), true);
    assert_eq!(candidate(vec![3, 2, 3], 1), false);
    assert_eq!(candidate(vec![1, 2, 3], 6), false);
    assert_eq!(candidate(vec![5], 5), true);
}
"
HumanEval_73,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// ɔ nɔ xa ɖokpo ɔ ɖo gudo kpo nukɔn kpo. Ðò huzuhuzu ɖokpo mɛ ɔ, a sixu ɖyɔ nǔɖogbɛ ɖokpo bo sɔ́ ɖě./// è ɖó na ɖyɔ bo na bló bɔ̀ vector ɔ na nyí palindromic./// Ɖó vector arr nùxwɛ́ ɔ́ lɛ́ɛ tɔn ɔ́, mɔ nùxwásá kpɛví bǐ e ɖò nǔ lɛ́ɛ mɛ é/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])
/// 4
/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])
/// 1
/// >>> smallest_change(vec![1, 2, 3, 2, 1])
/// 0
fn smallest_change(arr: Vec<isize>) -> isize {
","fn smallest_change(arr: Vec<isize>) -> isize {
    let mut changes = 0;
    let n = arr.len();
    
    for i in 0..n/2 {
        if arr[i] != arr[n - i - 1] {
            changes += 1;
        }
    }
    
    changes
}

// Example usage:
// fn main() {
//     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);
//     println!(""{}"", result); // Outputs: 4
// }","}

fn main() {
    let candidate = smallest_change;
    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);
    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);
    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);
    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(vec![0, 1]), 1);
}
"
HumanEval_74,fon_Latn,rs,"/// Kpɔ́ndéwú /// nú vector we lɛ́ɛ ɖó nùxíɖíɖó chars ɖokpo ɔ́, lɛ́ kɔ nú vector nukɔntɔn ɔ./// nùxíɖókpɔ́ nú chars ɖò wèmá vector tɔn lɛ́ɛ bǐ mɛ hú vector ɖevo ɔ./// Wlǎn azɔ̀ e nɔ yí gbè nú nùjlɛ́jlɛ́ wè bó nɔ lɛ́ yí gbè nú nùjlɛ́jlɛ́ e ɖó /// >>> total_match(vec![], vec![])
/// Vec::<String>::new()
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")])
/// vec![String::from(""hI""), String::from(""Hi"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")])
/// vec![String::from(""hi""), String::from(""admin"")]
/// >>> total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")])
/// vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]
/// >>> total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")])
/// vec![String::from(""4"")]
fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
","fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {
    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();

    if char_count(&lst1) <= char_count(&lst2) {
        lst1
    } else {
        lst2
    }
}

// Example usage
fn main() {
    let result1 = total_match(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]);
    println!(""{:?}"", result1);

    let result2 = total_match(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]);
    println!(""{:?}"", result2);
}","}

fn main() {
    let candidate = total_match;
    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi"")]), vec![String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hi""), String::from(""hi""), String::from(""admin""), String::from(""project"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(vec![String::from(""4"")], vec![String::from(""1""), String::from(""2""), String::from(""3""), String::from(""4""), String::from(""5"")]), vec![String::from(""4"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""Hi"")]), vec![String::from(""hI""), String::from(""Hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]), vec![String::from(""hI""), String::from(""hi""), String::from(""hi"")]);
    assert_eq!(candidate(vec![String::from(""hi""), String::from(""admin"")], vec![String::from(""hI""), String::from(""hi""), String::from(""hii"")]), vec![String::from(""hi""), String::from(""admin"")]);
    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(""this"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""this"")], Vec::<String>::new()), Vec::<String>::new());
}
"
HumanEval_75,fon_Latn,rs,"/// Kpɔ́n: ///N'í tuùn ɖɔ (a) ɖò kpɛví hú 100. /// bo lɛ́ ɖó nùvú./// Wlǎn nùjlɛ́n e nɔ lɛ́ yí gbè nú nùjlɛ́n e è ná é nyí nùjlɛ́n ta atɔn sín nùjlɛ́n ɔ́ /// >>> is_multiply_prime(30)
/// true
/// 30 = 2 * 3 * 5
fn is_multiply_prime(a: isize) -> bool {
","fn is_multiply_prime(a: isize) -> bool {
    fn is_prime(n: isize) -> bool {
        if n <= 1 {
            return false;
        }
        if n <= 3 {
            return true;
        }
        if n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    if a < 2 {
        return false;
    }

    let mut primes = Vec::new();
    for i in 2..a {
        if is_prime(i) {
            primes.push(i);
        }
    }

    let p_len = primes.len();
    for i in 0..p_len {
        for j in i..p_len {
            for k in j..p_len {
                if primes[i] * primes[j] * primes[k] == a {
                    return true;
                }
            }
        }
    }
    false
}","}

fn main() {
    let candidate = is_multiply_prime;
    assert_eq!(candidate(5), false);
    assert_eq!(candidate(30), true);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), false);
    assert_eq!(candidate(125), true);
    assert_eq!(candidate(105), true);
    assert_eq!(candidate(126), false);
    assert_eq!(candidate(729), false);
    assert_eq!(candidate(891), false);
    assert_eq!(candidate(1001), true);
}
"
HumanEval_76,fon_Latn,rs,"/// Cɔ́n kpɔ́n: ///x nyí nùɖé bɔ è nɔ sɔ́ dó kpá nú n enyi n**int=x /// power of n kpo false kpo ɖo ninɔmɛ ɖevo lɛ mɛ.//azɔ towe wɛ nyí ɖɔ a na wlan azɔ̀ e na lɛ́ lɛ́ wá nyí nugbǒ nú nùxà x ɖé nyí nùɖé bɔ̀ è nɔ ylɔ ɖɔ nùɖé bɔ̀ è nɔ ylɔ ɖɔ nùɖé é/// >>> is_simple_power(1, 4)
/// true
/// >>> is_simple_power(2, 2)
/// true
/// >>> is_simple_power(8, 2)
/// true
/// >>> is_simple_power(3, 2)
/// false
/// >>> is_simple_power(3, 1)
/// false
/// >>> is_simple_power(5, 3)
/// false
fn is_simple_power(x: isize, n: isize) -> bool {
","fn is_simple_power(x: isize, n: isize) -> bool {
    if x <= 0 || n <= 0 {
        return false;
    } else if x == 1 {
        return true;
    } else if n == 1 {
        return x == 1;
    }

    let mut power_n = n;
    while power_n < x {
        power_n *= n;
    }
    power_n == x
}

fn main() {
    println!(""{}"", is_simple_power(1, 4)); // true
    println!(""{}"", is_simple_power(2, 2)); // true
    println!(""{}"", is_simple_power(8, 2)); // true
    println!(""{}"", is_simple_power(3, 2)); // false
    println!(""{}"", is_simple_power(3, 1)); // false
    println!(""{}"", is_simple_power(5, 3)); // false
}","}

fn main() {
    let candidate = is_simple_power;
    assert_eq!(candidate(16, 2), true);
    assert_eq!(candidate(143214, 16), false);
    assert_eq!(candidate(4, 2), true);
    assert_eq!(candidate(9, 3), true);
    assert_eq!(candidate(16, 4), true);
    assert_eq!(candidate(24, 2), false);
    assert_eq!(candidate(128, 4), false);
    assert_eq!(candidate(12, 6), false);
    assert_eq!(candidate(1, 1), true);
    assert_eq!(candidate(1, 12), true);
}
"
HumanEval_77,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Nùjlɛ́n: a sixu ɖɔ ɖɔ nǔ e è wlan ɔ na nɔ wà hwebǐnu. /// enyi mɛ e ɖò mɛ é nyí nùɖé e nyí nùɖé é sín xúxú ɔ./// Wlǎn nùɖé e nɔ yí nùjlɛ́kpá a bo nɔ lɛ́ yí true é /// >>> iscube(1)
/// true
/// >>> iscube(2)
/// false
/// >>> iscube(-1)
/// true
/// >>> iscube(64)
/// true
/// >>> iscube(0)
/// true
/// >>> iscube(180)
/// false
fn iscube(a: isize) -> bool {
","fn iscube(a: isize) -> bool {
    if a < 0 {
        // For negative numbers, take the cube root of the absolute value.
        let cube_root = (-a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    } else {
        let cube_root = (a as f64).cbrt();
        let rounded_cube = cube_root.round() as isize;
        rounded_cube * rounded_cube * rounded_cube == a
    }
}

fn main() {
    println!(""{}"", iscube(1));   // true
    println!(""{}"", iscube(2));   // false
    println!(""{}"", iscube(-1));  // true
    println!(""{}"", iscube(64));  // true
    println!(""{}"", iscube(0));   // true
    println!(""{}"", iscube(180)); // false
}","}

fn main() {
    let candidate = iscube;
    assert_eq!(candidate(1), true);
    assert_eq!(candidate(2), false);
    assert_eq!(candidate(-1), true);
    assert_eq!(candidate(64), true);
    assert_eq!(candidate(180), false);
    assert_eq!(candidate(1000), true);
    assert_eq!(candidate(0), true);
    assert_eq!(candidate(1729), false);
}
"
HumanEval_78,fon_Latn,rs,"/// Kpɔ́ndéwú: /// bo wuntun lɛ A,B,C,D,E,F nɔ nyí wema ɖaxó hwebǐnu. /// ði: a sixu ɖɔ ɖɔ nǔ e è wlan ɔ sɔgbe hwebǐnu alǒ é nyí nǔtí ǎ, /// B (=mɛ̀gbò 11), D (=mɛ̀gbò 13). /// N'ihi ɔ, a na ɖe xwɛ e ɖò wuntun elɔ lɛ mɛ é ɖokpo xlɛ́: 2, 3, 5, 7, /// Nùxwlémɛ nukɔntɔn lɛ wɛ nyí 2, 3, 5, 7, 11, 13, 17,... /// Akwɛ́mɛ́n ayizɛ́ngɔ́n tɔn lɛ́ɛ nyí 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. /// hú 1 e ma nyí nùjlɛ́kpo nùjlɛ́kpo wè e ɖò kpò é tɔn ǎ é)./// nùjlɛ́kpo e nyí nùjlɛ́kpo nukɔn nukɔntɔn lɛ é (númɛ́gɔ́ nukɔntɔn, alǒ nùjlɛ́kpo nukɔn nukɔntɔn ɔ, nùjlɛ́kpá nùjɔnǔ tɔn ɖé wɛ é nyí)/// nùxwásùn wǒ-wǒ-wǒ-wǒ-wǒ ɖé wɛ nyí wuntun ɖé bó nɔ́ xa nùxwásùn wǒ-wǒ-wǒ tɔn lɛ́ɛ/// È byɔ̀ we ɖɔ a ni wlan azɔ̀ e nɔ yí nǔ lɛ é /// >>> hex_key(String::from(""AB""))
/// 1
/// >>> hex_key(String::from(""1077E""))
/// 2
/// >>> hex_key(String::from(""ABED1A33""))
/// 4
/// >>> hex_key(String::from(""123456789ABCDEF0""))
/// 6
/// >>> hex_key(String::from(""2020""))
/// 2
fn hex_key(num: String) -> isize {
","fn hex_key(num: String) -> isize {
    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];
    num.chars()
        .filter(|c| prime_hex_chars.contains(c))
        .count() as isize
}","}

fn main() {
    let candidate = hex_key;
    assert_eq!(candidate(String::from(""AB"")), 1);
    assert_eq!(candidate(String::from(""1077E"")), 2);
    assert_eq!(candidate(String::from(""ABED1A33"")), 4);
    assert_eq!(candidate(String::from(""2020"")), 2);
    assert_eq!(candidate(String::from(""123456789ABCDEF0"")), 6);
    assert_eq!(candidate(String::from(""112233445566778899AABBCCDDEEFF00"")), 12);
}
"
HumanEval_79,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Wemaɖe lɛ́ɛ ɖò finɛ bo na d'alɔ ɖò nùwlanwlan ɔ mɛ./// È na lɛ́ sɔ́ wuntun wè 'db' ɖò tò ɔ́ sín bǐbɛ́mɛ kpo fó tɔn kpo.//Xò wèmá ɖokpo ɖokpo ɖò xɛ ɔ mɛ ɔ ná nyí '0' alǒ '1'./// binary format. azɔ na lɛ na w'azɔ ɔ, bo na lɛ na w'azɔ ɔ ɖokpo ɖokpo ɔ nɔte nú binary /// È na na mi nùxwásá ɖò nùjlɛ́kpá wǒzángbè ɖé mɛ bɔ azɔ̌ mitɔn wɛ nyí ɖɔ mi na yí dó /// >>> decimal_to_binary(15)
/// String::from(""db1111db"")
/// >>> decimal_to_binary(32)
/// String::from(""db100000db"")
fn decimal_to_binary(decimal: isize) -> String {
","fn decimal_to_binary(decimal: isize) -> String {
    let binary_string = format!(""{:b}"", decimal);
    format!(""db{}db"", binary_string)
}

fn main() {
    // Example usage
    let binary_15 = decimal_to_binary(15);
    let binary_32 = decimal_to_binary(32);
    println!(""{}"", binary_15); // Outputs: db1111db
    println!(""{}"", binary_32); // Outputs: db100000db
}","}

fn main() {
    let candidate = decimal_to_binary;
    assert_eq!(candidate(0), String::from(""db0db""));
    assert_eq!(candidate(32), String::from(""db100000db""));
    assert_eq!(candidate(103), String::from(""db1100111db""));
    assert_eq!(candidate(15), String::from(""db1111db""));
}
"
HumanEval_80,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// Sɛ́n ɔ́ nyí xwiɖe nú é nyí amyɔ tɔn nɔ́ nyí 3 bo ɖò wuntun atɔn e ɖò wuntun ɔ́ mɛ lɛ́ɛ bǐ wɛ nɔ́ nyí nǔɖogbɛ̀.//azɔ towe wɛ nyí ɖɔ a na kpɔ́n ɖɔ xwɛ ɔ sɔgbe à alǒ é sɔgbe ǎ./// È na wlan wuntun ɖé nú we. /// >>> is_happy(String::from(""a""))
/// false
/// >>> is_happy(String::from(""aa""))
/// false
/// >>> is_happy(String::from(""abcd""))
/// true
/// >>> is_happy(String::from(""aabb""))
/// false
/// >>> is_happy(String::from(""adb""))
/// true
/// >>> is_happy(String::from(""xyy""))
/// false
fn is_happy(s: String) -> bool {
","fn is_happy(s: String) -> bool {
    if s.len() < 3 {
        return false;
    }

    let chars: Vec<char> = s.chars().collect();
    for i in 0..(chars.len() - 2) {
        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {
            return false;
        }
    }

    true
}

fn main() {
    println!(""{}"", is_happy(String::from(""a""))); // false
    println!(""{}"", is_happy(String::from(""aa""))); // false
    println!(""{}"", is_happy(String::from(""abcd""))); // true
    println!(""{}"", is_happy(String::from(""aabb""))); // false
    println!(""{}"", is_happy(String::from(""adb""))); // true
    println!(""{}"", is_happy(String::from(""xyy""))); // false
}","}

fn main() {
    let candidate = is_happy;
    assert_eq!(candidate(String::from(""a"")), false);
    assert_eq!(candidate(String::from(""aa"")), false);
    assert_eq!(candidate(String::from(""abcd"")), true);
    assert_eq!(candidate(String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""adb"")), true);
    assert_eq!(candidate(String::from(""xyy"")), false);
    assert_eq!(candidate(String::from(""iopaxpoi"")), true);
    assert_eq!(candidate(String::from(""iopaxioi"")), false);
}
"
HumanEval_81,fon_Latn,rs,"/// Kpɔ́n: /// 0.0 E /// > 0.0 D- /// > 0.7 D /// > 1.0 D+ /// > 1.3 C- /// > 1.7 C /// > 2.0 C+ /// > 2.3 B- /// > 2.7 B /// > 3.0 B+ /// > 3.3 A- /// > 3.7 A /// 4.0 A+ /// GPA ̆ ̆ ̆ ̆ ̆ ̆ ̆ ̆ ̆ ̆/// nùxwásá e sixu ɖè nùxwásá wemaxixa tɔn lɛ tɔn sín nùxwásá dó wemafɔ elɔ mɛ: /// É ná nǔ e mɛví lɛ nɔ mɔ nǔ jɛ mɛ é ɖé lɛ nú we bɔ a ɖó na wlan .//Xomɛ ɖokpo e ɖò finɛ wɛ é wɛ nyí ɖɔ, é bú wuntun e é nɔ zán dó ɖè nǔ lɛ é.//azɔmɛvi ɔ ɖo jijɛ wɛ bo na sɔ́ nǔ e é nɔ dó wlan nǔ lɛ é ɖó.//Azǎn e mɛ̌si ɔ na ɖè wě lɛ é sín azǎn gudogudo tɔn wɛ nyí azǎn enɛ./// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])
/// vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]
fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
","fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {
    grades.into_iter().map(|gpa| {
        match gpa {
            4.0 => String::from(""A+""),
            v if v > 3.7 => String::from(""A""),
            v if v > 3.3 => String::from(""A-""),
            v if v > 3.0 => String::from(""B+""),
            v if v > 2.7 => String::from(""B""),
            v if v > 2.3 => String::from(""B-""),
            v if v > 2.0 => String::from(""C+""),
            v if v > 1.7 => String::from(""C""),
            v if v > 1.3 => String::from(""C-""),
            v if v > 1.0 => String::from(""D+""),
            v if v > 0.7 => String::from(""D""),
            v if v > 0.0 => String::from(""D-""),
            _ => String::from(""E""),
        }
    }).collect()
}","}

fn main() {
    let candidate = numerical_letter_grade;
    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(""A+""), String::from(""B""), String::from(""C-""), String::from(""C""), String::from(""A-"")]);
    assert_eq!(candidate(vec![1.2]), vec![String::from(""D+"")]);
    assert_eq!(candidate(vec![0.5]), vec![String::from(""D-"")]);
    assert_eq!(candidate(vec![0.0]), vec![String::from(""E"")]);
    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(""D""), String::from(""D-""), String::from(""C-""), String::from(""B""), String::from(""B+"")]);
    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(""E""), String::from(""D-"")]);
}
"
HumanEval_82,fon_Latn,rs,"/// Kpɔ́ndéwú /// length nyí nùjlɔ́mɛnu nukɔntɔn ɖé alǒ nùvú nú é nyí ǎ ɔ /// Wlǎn azɔ̀ e nɔ yí wèmá wèmá ɖé bó nɔ lɛ́ yí true nú wèmá ɔ /// >>> prime_length(String::from(""Hello""))
/// true
/// >>> prime_length(String::from(""abcdcba""))
/// true
/// >>> prime_length(String::from(""kittens""))
/// true
/// >>> prime_length(String::from(""orange""))
/// false
fn prime_length(string: String) -> bool {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn prime_length(string: String) -> bool {
    let length = string.len();
    is_prime(length)
}

// Example usage
fn main() {
    println!(""{}"", prime_length(String::from(""Hello""))); // true
    println!(""{}"", prime_length(String::from(""abcdcba""))); // true
    println!(""{}"", prime_length(String::from(""kittens""))); // true
    println!(""{}"", prime_length(String::from(""orange""))); // false
}","}

fn main() {
    let candidate = prime_length;
    assert_eq!(candidate(String::from(""Hello"")), true);
    assert_eq!(candidate(String::from(""abcdcba"")), true);
    assert_eq!(candidate(String::from(""kittens"")), true);
    assert_eq!(candidate(String::from(""orange"")), false);
    assert_eq!(candidate(String::from(""wow"")), true);
    assert_eq!(candidate(String::from(""world"")), true);
    assert_eq!(candidate(String::from(""MadaM"")), true);
    assert_eq!(candidate(String::from(""Wow"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""HI"")), true);
    assert_eq!(candidate(String::from(""go"")), true);
    assert_eq!(candidate(String::from(""gogo"")), false);
    assert_eq!(candidate(String::from(""aaaaaaaaaaaaaaa"")), false);
    assert_eq!(candidate(String::from(""Madam"")), true);
    assert_eq!(candidate(String::from(""M"")), false);
    assert_eq!(candidate(String::from(""0"")), false);
}
"
HumanEval_83,fon_Latn,rs,"/// nùxwlékpá ɖagbe e nɔ bɛ́ alǒ nɔ fó ɖò 1. /// Nú è na w'azɔnkpɔnkpɔn ɖagbe n ɔ, lɛ́n nùxwlé e nɔ ɖó w'azɔnkpɔnkpɔnkpɔnn n-gɔ́n ɔ lɛ é sín nùxwlé ɔ fn starts_one_ends(n: isize) -> isize {
","fn starts_one_ends(n: isize) -> isize {
    if n <= 0 {
        return 0;
    }
    if n == 1 {
        return 1; // only '1' satisfies the condition for a single-digit
    }

    // Consider numbers starting with '1' (1XXXX...)
    let start_with_one = 9isize.pow((n-1) as u32);

    // Consider numbers ending with '1' (...XXXX1)
    let end_with_one = 9isize.pow((n-1) as u32);
    
    // Consider numbers both starting and ending with '1' and check overlaps (1XXX1)
    let both_start_end_one = 9isize.pow((n-2) as u32);

    // Total numbers starting or ending with '1'
    start_with_one + end_with_one - both_start_end_one
}

fn main() {
    // Example usage:
    let n = 3;
    println!(""Count of n-digit numbers starting or ending with 1: {}"", starts_one_ends(n));
}","}

fn main() {
    let candidate = starts_one_ends;
    assert_eq!(candidate(1), 1);
    assert_eq!(candidate(2), 18);
    assert_eq!(candidate(3), 180);
    assert_eq!(candidate(4), 1800);
    assert_eq!(candidate(5), 18000);
}
"
HumanEval_84,fon_Latn,rs,"/// Kpɔ́ndéwú /// Nú è na w'azɔnkpɔnkpɔn ɖagbe ɖé N ɔ, na lɛ́ yí nùjlɛ́kpo tɔn lɛ́ɛ bǐ dó binary mɛ. /// >>> solve(1000)
/// String::from(""1"")
/// >>> solve(150)
/// String::from(""110"")
/// >>> solve(147)
/// String::from(""1100"")
/// Variables:
/// @N integer
/// Constraints: 0 ≤ N ≤ 10000.
/// Output:
/// a string of binary number
fn solve(N: isize) -> String {
","fn solve(N: isize) -> String {
    let sum_of_digits: isize = N
        .to_string()
        .chars()
        .map(|c| c.to_digit(10).unwrap() as isize)
        .sum();
    
    format!(""{:b}"", sum_of_digits)
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(1000), String::from(""1""));
    assert_eq!(candidate(150), String::from(""110""));
    assert_eq!(candidate(147), String::from(""1100""));
    assert_eq!(candidate(333), String::from(""1001""));
    assert_eq!(candidate(963), String::from(""10010""));
}
"
HumanEval_85,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Ɖó è na w'azɔ̌ nú nùxwlé lɛ́ɛ e nyí nùɖé ǎ é ɔ́, lst. bɛ́ nùxwlé lɛ́ɛ e ɖò nùxwlé lɛ́ɛ jí lɛ́ɛ ɖó kpɔ́n./// >>> add(vec![4, 2, 6, 7])
/// 2
fn add(lst: Vec<isize>) -> isize {
","fn add(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, _)| i % 2 == 1) // select odd indices
        .map(|(_, &x)| x) // get the values at odd indices
        .filter(|&x| x % 2 == 0) // filter even values
        .sum() // sum the values
}","}

fn main() {
    let candidate = add;
    assert_eq!(candidate(vec![4, 88]), 88);
    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);
    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);
    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);
}
"
HumanEval_86,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// Nùkanbyɔ: A ɖó na hɛn xókwin lɛ kpo tɛn mɛ e ɖò mɛ lɛ é kpo ɖó kpɔ́ ɖò nǔ e a ɖɔ é mɛ. /// kpò ɖò jí wɛ ɖò ascii value jí./// è nɔ sɔ́ xókwin yɔyɔ́ ɖé dó ɖyɔ́ xókwin ɔ́ mɛ bɔ wuntun e è sɔ́ ɖó tò jí lɛ́ɛ bǐ nɔ́ ɖò /// Sɛ́n e è ɖè ɖò nǔ lɛ mɛ é ɔ́ wɛ nyí wuntun e mɛ è nɔ sɔ́ xókwin lɛ bǐ ɖó vo (e è nɔ ɖó tɛn nú é) é./// Wlǎn azɔ̀ e nɔ yí wèmá ɖé bó nɔ lɛ́ yí gbè nú wèmá ɔ́ sín nùxwlémɛ. /// >>> anti_shuffle(String::from(""Hi""))
/// String::from(""Hi"")
/// >>> anti_shuffle(String::from(""hello""))
/// String::from(""ehllo"")
/// >>> anti_shuffle(String::from(""Hello World!!!""))
/// String::from(""Hello !!!Wdlor"")
fn anti_shuffle(s: String) -> String {
","fn anti_shuffle(s: String) -> String {
    let mut result = String::new();
    let mut word = String::new();

    for c in s.chars() {
        if c.is_whitespace() {
            if !word.is_empty() {
                let mut chars: Vec<char> = word.chars().collect();
                chars.sort_unstable();
                result.push_str(&chars.into_iter().collect::<String>());
                word.clear();
            }
            result.push(c);
        } else {
            word.push(c);
        }
    }

    if !word.is_empty() {
        let mut chars: Vec<char> = word.chars().collect();
        chars.sort_unstable();
        result.push_str(&chars.into_iter().collect::<String>());
    }

    result
}

fn main() {
    // Example usages:
    println!(""{}"", anti_shuffle(String::from(""Hi"")));              // ""Hi""
    println!(""{}"", anti_shuffle(String::from(""hello"")));           // ""ehllo""
    println!(""{}"", anti_shuffle(String::from(""Hello World!!!"")));  // ""Hello !!!Wdlor""
}","}

fn main() {
    let candidate = anti_shuffle;
    assert_eq!(candidate(String::from(""Hi"")), String::from(""Hi""));
    assert_eq!(candidate(String::from(""hello"")), String::from(""ehllo""));
    assert_eq!(candidate(String::from(""number"")), String::from(""bemnru""));
    assert_eq!(candidate(String::from(""abcd"")), String::from(""abcd""));
    assert_eq!(candidate(String::from(""Hello World!!!"")), String::from(""Hello !!!Wdlor""));
    assert_eq!(candidate(String::from("""")), String::from(""""));
    assert_eq!(candidate(String::from(""Hi. My name is Mister Robot. How are you?"")), String::from("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval_87,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Ɖò ɔ, ɖè nùxwásá lɛ́ɛ ɖò xósúsú jí gbɔn nùxwásá lɛ́ɛ jí./// Nɔ kpò ɖò tò lɛ mɛ ɖò ali lɛ jí ɖò kpò jí./// kpodo tuple ɖokpo ɖokpo kpo ɔ, nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nyí nǔ e nɔ nɔ nyí nǔ e nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nɔ nyí nǔ e nɔ nɔ nɔ nɔ nɔ nɔ nyí nǔ/// bo na lɛ́ lɛ́ kɔ́n nǔ e è nɔ ylɔ́ ɖɔ tuple lɛ́ɛ é, [(x1, y1), (x2, y2) ...] bɔ ///Nɛ́ è ná lst, nú è ná ná nùxwlékplé x ɔ, è na mɔ nùxwlékplé x ɖò vectɔ́ ɔ mɛ, /// xota ɖokpo ɖokpo sixu ɖó nùjlɛ́jlɛ́ gǒjímɛ vovo.//e cí matrix ɖɔhun, amɔ̌, é cí matrix lɛ ɖɔhun ǎ,/// È na we nǔ e ɖò we mɛ é, ɖi nǔ e è nɔ dó nǔ lɛ é, /// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)
/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
/// >>> get_row(vec![], 1)
/// Vec::<(isize, isize)>::new()
/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)
/// vec![(2, 2)]
fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
","fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {
    let mut result = Vec::new();

    for (row_index, row) in lst.iter().enumerate() {
        let mut found_indices: Vec<isize> = row.iter()
            .enumerate()
            .filter(|&(_, &value)| value == x)
            .map(|(col_index, _)| col_index as isize)
            .collect();

        found_indices.sort_by(|a, b| b.cmp(a)); // Sort column indices in descending order

        for col_index in found_indices {
            result.push((row_index as isize, col_index));
        }
    }

    result
}","}

fn main() {
    let candidate = get_row;
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);
    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());
    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);
}
"
HumanEval_88,fon_Latn,rs,"/// Kpɔ́ndéwú: /// * ma ɖyɔ́ vectɔ́ e è na é ó. /// Nukúnmɛ: /// alǒ ɖè é ɖò nùxwásá è ɖò jɛ wɛ é mɛ nú nùxwásá ɔ ((àzɔ̀n nùxwásá nukɔntɔn ɔ, àzɔ̀n nùxwásá gudo tɔn ɔ) nyí nùxwásá wè. /// a na sɔ́ véktótó ɔ́ dó zɔ́n bɔ é ná nɔ́ ɖò jí wɛ nú nǔ e è kplé ɔ́ (wěkan nǔjlɛ́jlɛ́ nukɔntɔn ɔ́, wěkan nǔjlɛ́jlɛ́ gudo tɔn ɔ́) nyí nǔ e ma nyí wěkan nǔjlɛ́jlɛ́ nukɔntɔn ɔ́ ǎ é, /// È na wèmá nú nùjlɛ́kpá e ma nyí nùɖé ǎ lɛ́ɛ ɔ́, lɛ́ kɔ́n wèmá ɔ́ sín wèmá ɖé ɖò nùjlɛ́kpá ɔ́ mɛ, /// >>> sort_array(vec![])
/// Vec::<isize>::new()
/// >>> sort_array(vec![5])
/// vec![5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])
/// vec![0, 1, 2, 3, 4, 5]
/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])
/// vec![6, 5, 4, 3, 2, 1, 0]
fn sort_array(array: Vec<isize>) -> Vec<isize> {
","fn sort_array(array: Vec<isize>) -> Vec<isize> {
    if array.is_empty() {
        return Vec::<isize>::new();
    }

    let first = array.first().unwrap_or(&0);
    let last = array.last().unwrap_or(&0);
    let sum = first + last;

    let mut sorted_array = array.clone();
    if sum % 2 == 0 {
        sorted_array.sort_by(|a, b| b.cmp(a)); // Descending order
    } else {
        sorted_array.sort(); // Ascending order
    }

    sorted_array
}

fn main() {
    // Test cases
    println!(""{:?}"", sort_array(vec![])); // Vec::<isize>::new()
    println!(""{:?}"", sort_array(vec![5])); // vec![5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5])); // vec![0, 1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); // vec![6, 5, 4, 3, 2, 1, 0]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![5]), vec![5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);
    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);
    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);
    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);
    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);
}
"
HumanEval_89,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// yì jɛ wè jí azɔn wè yì tɛn wè jí./// Alfabɛ ɔ na nɔ ɖyɔ́ ɖò ali ɖé nu bɔ xósusu lɛ na nɔ ɖɔ /// nɔ lɛ́ yí wuntun e è blǒ bɔ è nɔ lɛ́ dó wuntun ɔ́ jí é./// Wà azɔ̀n e nɔ yí nùkwín ɖé dó nùjlɛ́nmɛ mɛ é ɖé/// >>> encrypt(String::from(""hi""))
/// String::from(""lm"")
/// >>> encrypt(String::from(""asdfghjkl""))
/// String::from(""ewhjklnop"")
/// >>> encrypt(String::from(""gf""))
/// String::from(""kj"")
/// >>> encrypt(String::from(""et""))
/// String::from(""ix"")
fn encrypt(s: String) -> String {
","fn encrypt(s: String) -> String {
    s.chars()
        .map(|c| {
            if c.is_ascii_lowercase() {
                let offset = (c as u8 - b'a' + 4) % 26;
                (b'a' + offset) as char
            } else {
                c
            }
        })
        .collect()
}","}

fn main() {
    let candidate = encrypt;
    assert_eq!(candidate(String::from(""hi"")), String::from(""lm""));
    assert_eq!(candidate(String::from(""asdfghjkl"")), String::from(""ewhjklnop""));
    assert_eq!(candidate(String::from(""gf"")), String::from(""kj""));
    assert_eq!(candidate(String::from(""et"")), String::from(""ix""));
    assert_eq!(candidate(String::from(""faewfawefaewg"")), String::from(""jeiajeaijeiak""));
    assert_eq!(candidate(String::from(""hellomyfriend"")), String::from(""lippsqcjvmirh""));
    assert_eq!(candidate(String::from(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")), String::from(""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert_eq!(candidate(String::from(""a"")), String::from(""e""));
}
"
HumanEval_90,fon_Latn,rs,"/// N'a ɖo nu mɔhun mɛ ă ɔ, e na lɛ́ kɔ nú mɛ ă./// Wlǎn azɔ̀ next_smallest (a) e nɔ lɛ́ lɛ́ kɔ̀ nùɖé e nyí nǔ wè ɖò vector ɔ́ mɛ é. /// È na we nùxwlé lɛ sín vector./// >>> next_smallest(vec![1, 2, 3, 4, 5])
/// Some(2)
/// >>> next_smallest(vec![5, 1, 4, 3, 2])
/// Some(2)
/// >>> next_smallest(vec![])
/// None
/// >>> next_smallest(vec![1, 1])
/// None
fn next_smallest(lst: Vec<isize>) -> Option<isize> {
","fn next_smallest(lst: Vec<isize>) -> Option<isize> {
    if lst.len() < 2 {
        return None;
    }
    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();
    if unique_elements.len() < 2 {
        return None;
    }
    unique_elements.sort();
    Some(unique_elements[1])
}

fn main() {
    println!(""{:?}"", next_smallest(vec![1, 2, 3, 4, 5])); // Some(2)
    println!(""{:?}"", next_smallest(vec![5, 1, 4, 3, 2])); // Some(2)
    println!(""{:?}"", next_smallest(vec![])); // None
    println!(""{:?}"", next_smallest(vec![1, 1])); // None
}","}

fn main() {
    let candidate = next_smallest;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));
    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));
    assert_eq!(candidate(vec![1, 1]), None);
    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));
}
"
HumanEval_91,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// Xò xota lɛ́ɛ jí ɔ, è nɔ sɔ́ """", ""?"" alǒ ""!"" dó ɖó dogbó.//""Nyɔ̌nmɛ"" ɔ́ xógbe e nɔ bɛ́ dó ""Un"" jí é wɛ./// È na sɔ́ xógbe lɛ sín xɛ́ dó nú mi, bɔ azɔ̌ mitɔn wɛ nyí ɖɔ mi na xa nú ɔ́./// >>> is_bored(String::from(""Hello world""))
/// 0
/// >>> is_bored(String::from(""The sky is blue. The sun is shining. I love this weather""))
/// 1
fn is_bored(S: String) -> isize {
","fn is_bored(S: String) -> isize {
    S.split(|c| c == '.' || c == '?' || c == '!')
        .filter(|sentence| sentence.trim_start().starts_with(""I""))
        .count() as isize
}","}

fn main() {
    let candidate = is_bored;
    assert_eq!(candidate(String::from(""Hello world"")), 0);
    assert_eq!(candidate(String::from(""Is the sky blue?"")), 0);
    assert_eq!(candidate(String::from(""I love It !"")), 1);
    assert_eq!(candidate(String::from(""bIt"")), 0);
    assert_eq!(candidate(String::from(""I feel good today. I will be productive. will kill It"")), 2);
    assert_eq!(candidate(String::from(""You and I are going for a walk"")), 0);
}
"
HumanEval_92,fon_Latn,rs,"/// Kpɔ́ndéwú /// É nɔ lɛ́ wá yì nǔmaɖinǔ ɖò ninɔmɛ ɖevo lɛ mɛ./// É nɔ lɛ́ yí gbè nú nùjlɛ́n ɔ́' nú nùjlɛ́n ɔ́' ɖokpó ɔ́ wɛ nyí nǔ e è kplé bo ɖó wè lɛ́ɛ é, bɔ nùjlɛ́n lɛ́ɛ bǐ nyí nùjlɛ́n ɔ́' nú ɔ́'///Nɔ azɔ̀ e nɔ yí nùxwásá 3 é./// >>> any_int(5, 2, 7)
/// true
/// >>> any_int(3, 2, 2)
/// false
/// >>> any_int(3, -2, 1)
/// true
/// >>> any_int(3.6, -2.2, 2)
/// false
fn any_int(x: f64, y: f64, z: f64) -> bool {
","fn any_int(x: f64, y: f64, z: f64) -> bool {
    // Check if all the numbers are integers
    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {
        // Convert f64 to i64 because they are integers
        let xi = x as i64;
        let yi = y as i64;
        let zi = z as i64;

        // Check if any one of the numbers is equal to the sum of the other two
        xi == yi + zi || yi == xi + zi || zi == xi + yi
    } else {
        false
    }
}

fn main() {
    // Examples
    println!(""{}"", any_int(5.0, 2.0, 7.0)); // true
    println!(""{}"", any_int(3.0, 2.0, 2.0)); // false
    println!(""{}"", any_int(3.0, -2.0, 1.0)); // true
    println!(""{}"", any_int(3.6, -2.2, 2.0)); // false
}","}

fn main() {
    let candidate = any_int;
    assert_eq!(candidate(2.0, 3.0, 1.0), true);
    assert_eq!(candidate(2.5, 2.0, 3.0), false);
    assert_eq!(candidate(1.5, 5.0, 3.5), false);
    assert_eq!(candidate(2.0, 6.0, 2.0), false);
    assert_eq!(candidate(4.0, 2.0, 2.0), true);
    assert_eq!(candidate(2.2, 2.2, 2.2), false);
    assert_eq!(candidate(-4.0, 6.0, 2.0), true);
    assert_eq!(candidate(2.0, 1.0, 1.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), true);
    assert_eq!(candidate(3.0, 4.0, 7.0), false);
}
"
HumanEval_93,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Nùnina lɛ kɛɖɛ wɛ è nɔ dó./// xókwin ɖò wlanwlán e è nɔ dó gbè mɛ ɖò anglɛkigbe mɛ é mɛ./// wɛn ɔ kpodo wèmá e nɔ tɔ́n ɖò tɛn wè nukɔn nú é kpo /// ɔ ɖyɔ́ xókwin lɛ́ɛ bǐ sín ta, nɔ ɖyɔ́ xókwin lɛ́ɛ bǐ ɖò  mɛ/// Wlǎn azɔ̀ e nɔ yí wɛn ɖé, bo nɔ wlan dó mɛ ɔ mɛ é ɖé./// >>> encode(String::from(""test""))
/// String::from(""TGST"")
/// >>> encode(String::from(""This is a message""))
/// String::from(""tHKS KS C MGSSCGG"")
fn encode(message: String) -> String {
","fn encode(message: String) -> String {
    message.chars().map(|c| {
        match c {
            'a' => 'C',
            'e' => 'G',
            'i' => 'K',
            'o' => 'Q',
            'u' => 'W',
            'A' => 'c',
            'E' => 'g',
            'I' => 'k',
            'O' => 'q',
            'U' => 'w',
            'a'..='z' => c.to_ascii_uppercase(),
            'A'..='Z' => c.to_ascii_lowercase(),
            _ => c,
        }
    }).collect()
}","}

fn main() {
    let candidate = encode;
    assert_eq!(candidate(String::from(""TEST"")), String::from(""tgst""));
    assert_eq!(candidate(String::from(""Mudasir"")), String::from(""mWDCSKR""));
    assert_eq!(candidate(String::from(""YES"")), String::from(""ygs""));
    assert_eq!(candidate(String::from(""This is a message"")), String::from(""tHKS KS C MGSSCGG""));
    assert_eq!(candidate(String::from(""I DoNt KnOw WhAt tO WrItE"")), String::from(""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval_94,fon_Latn,rs,"/// Kpɔ́ndéwú: /// A na mɔ nùxwléma nùjlɛ́jlɛ́ tɔn ɖaxó ɔ bo na lɛ́ yí nùxwléma tɔn lɛ́ɛ sín nùxwléma. /// È na we nùxwlé lɛ sín vector./// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
/// 10
/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
/// 25
/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
/// 13
/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
/// 11
/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])
/// 3
/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])
/// 7
fn skjkasdkd(lst: Vec<isize>) -> isize {
","fn is_prime(n: isize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn digit_sum(n: isize) -> isize {
    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()
}

fn skjkasdkd(lst: Vec<isize>) -> isize {
    match lst.into_iter().filter(is_prime).max() {
        Some(max_prime) => digit_sum(max_prime),
        None => 0,
    }
}","}

fn main() {
    let candidate = skjkasdkd;
    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);
    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);
    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);
    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);
    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);
    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);
    assert_eq!(candidate(vec![8191]), 19);
    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);
    assert_eq!(candidate(vec![127, 97, 8192]), 10);
}
"
HumanEval_95,fon_Latn,rs,"use std::collections::HashMap;

/// Kpɔ́ndéwú: /// Function ɔ na lɛ́ kɔ́n false ɔ́' HashMap ɔ́' nǔtí ǎ./// case alǒ wuntun lɛ bǐ nyí xɛ ɖò wema ɖaxó mɛ, nú é ma nyí mɔ̌ ǎ ɔ é na lɛ́ wá nyí false. /// Nú è na sɔ́ HashMap ɔ́, é na lɛ́ lɛ́ wá nyí nugbǒ nú wuntun lɛ́ɛ bǐ nyí xɛ ɖò lower /// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]))
/// true
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""a""), String::from(""apple"")), (8, String::from(""banana"")), (String::from(""a""), String::from(""apple""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]))
/// false
/// >>> check_dict_case(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]))
/// true
fn check_dict_case(dict: HashMap<String, String>) -> bool {
","use std::collections::HashMap;

fn check_dict_case(dict: HashMap<String, String>) -> bool {
    if dict.is_empty() {
        return false;
    }

    let mut lowercase = true;
    let mut uppercase = true;

    for key in dict.keys() {
        if !key.chars().all(|c| c.is_lowercase()) {
            lowercase = false;
        }
        if !key.chars().all(|c| c.is_uppercase()) {
            uppercase = false;
        }
    }

    lowercase || uppercase
}

fn main() {
    let dict1 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""b""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict1), true);

    let dict2 = HashMap::from([(String::from(""a""), String::from(""apple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))]);
    assert_eq!(check_dict_case(dict2), false);

    let dict3 = HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))]);
    assert_eq!(check_dict_case(dict3), true);

    let dict4 = HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))]);
    assert_eq!(check_dict_case(dict4), false);
}","}

fn main() {
    let candidate = check_dict_case;
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""b""), String::from(""banana""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""A""), String::from(""banana"")), (String::from(""B""), String::from(""banana""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""p""), String::from(""pineapple"")), (String::from(""5""), String::from(""banana"")), (String::from(""a""), String::from(""apple""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""Name""), String::from(""John"")), (String::from(""Age""), String::from(""36"")), (String::from(""City""), String::from(""Houston""))])), false);
    assert_eq!(candidate(HashMap::from([(String::from(""STATE""), String::from(""NC"")), (String::from(""ZIP""), String::from(""12345""))])), true);
    assert_eq!(candidate(HashMap::from([(String::from(""fruit""), String::from(""Orange"")), (String::from(""taste""), String::from(""Sweet""))])), true);
    assert_eq!(candidate(HashMap::from([])), false);
}
"
HumanEval_96,fon_Latn,rs,"/// kpɔ́ndéwú: /// nùxwlé lɛ́ɛ e nyí nùjlɛ́kpá nú nùjlɛ́kpá lɛ́ɛ bo lɛ́ nyí kpɛví hú n. /// Zɔ̀ nùɖé e nɔ yí nùɖé e nyí nùɖé ǎ é bo nɔ lɛ́ yí nùɖé e nyí vector nú nùɖé nukɔntɔn ɔ é./// >>> count_up_to(5)
/// vec![2, 3]
/// >>> count_up_to(11)
/// vec![2, 3, 5, 7]
/// >>> count_up_to(0)
/// Vec::<isize>::new()
/// >>> count_up_to(20)
/// vec![2, 3, 5, 7, 11, 13, 17, 19]
/// >>> count_up_to(1)
/// Vec::<isize>::new()
/// >>> count_up_to(18)
/// vec![2, 3, 5, 7, 11, 13, 17]
fn count_up_to(n: isize) -> Vec<isize> {
","fn count_up_to(n: isize) -> Vec<isize> {
    let mut primes = Vec::new();

    for num in 2..n {
        let mut is_prime = true;

        for divisor in 2..=((num as f64).sqrt() as isize) {
            if num % divisor == 0 {
                is_prime = false;
                break;
            }
        }

        if is_prime {
            primes.push(num);
        }
    }

    primes
}

fn main() {
    println!(""{:?}"", count_up_to(5)); // vec![2, 3]
    println!(""{:?}"", count_up_to(11)); // vec![2, 3, 5, 7]
    println!(""{:?}"", count_up_to(0)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(20)); // vec![2, 3, 5, 7, 11, 13, 17, 19]
    println!(""{:?}"", count_up_to(1)); // Vec::<isize>::new()
    println!(""{:?}"", count_up_to(18)); // vec![2, 3, 5, 7, 11, 13, 17]
}","}

fn main() {
    let candidate = count_up_to;
    assert_eq!(candidate(5), vec![2, 3]);
    assert_eq!(candidate(6), vec![2, 3, 5]);
    assert_eq!(candidate(7), vec![2, 3, 5]);
    assert_eq!(candidate(10), vec![2, 3, 5, 7]);
    assert_eq!(candidate(0), Vec::<isize>::new());
    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);
    assert_eq!(candidate(1), Vec::<isize>::new());
    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}
"
HumanEval_97,fon_Latn,rs,"/// Kpɔ́ndéwú: ///Nɔ ɖɔ nǔ e è wlan ɔ na nɔ wà hwebǐnu./// nùxwásá nú nùjlɛ́kpo yetɔn lɛ tɔn. /// Blɛ́ azɔ̀ e nɔ yí nùxixa wè bó nɔ lɛ́ lɛ́ kɔ́n é/// >>> multiply(148, 412)
/// 16
/// >>> multiply(19, 28)
/// 72
/// >>> multiply(2020, 1851)
/// 0
/// >>> multiply(14, -15)
/// 20
fn multiply(a: isize, b: isize) -> isize {
","fn multiply(a: isize, b: isize) -> isize {
    let unit_digit_a = (a % 10).abs();
    let unit_digit_b = (b % 10).abs();
    unit_digit_a * unit_digit_b
}","}

fn main() {
    let candidate = multiply;
    assert_eq!(candidate(148, 412), 16);
    assert_eq!(candidate(19, 28), 72);
    assert_eq!(candidate(2020, 1851), 0);
    assert_eq!(candidate(14, -15), 20);
    assert_eq!(candidate(76, 67), 42);
    assert_eq!(candidate(17, 27), 49);
    assert_eq!(candidate(0, 1), 0);
    assert_eq!(candidate(0, 0), 0);
}
"
HumanEval_98,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// Nú è na wlan wlan s ɔ, kpɔ́n nùxwásùn xókwin ɖaxó lɛ tɔn ɖò wlan e ɖò wlan ɔ mɛ lɛ é. /// >>> count_upper(String::from(""aBCdEf""))
/// 1
/// >>> count_upper(String::from(""abcdefg""))
/// 0
/// >>> count_upper(String::from(""dBBE""))
/// 0
fn count_upper(s: String) -> isize {
","fn count_upper(s: String) -> isize {
    s.chars().enumerate().filter(|(i, c)| {
        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')
    }).count() as isize
}","}

fn main() {
    let candidate = count_upper;
    assert_eq!(candidate(String::from(""aBCdEf"")), 1);
    assert_eq!(candidate(String::from(""abcdefg"")), 0);
    assert_eq!(candidate(String::from(""dBBE"")), 0);
    assert_eq!(candidate(String::from(""B"")), 0);
    assert_eq!(candidate(String::from(""U"")), 1);
    assert_eq!(candidate(String::from("""")), 0);
    assert_eq!(candidate(String::from(""EEEE"")), 2);
}
"
HumanEval_99,fon_Latn,rs,"/// Kpɔ́ndéwú /// sín nùɖé wè lɛ́ɛ jí ɔ́, mi ná lɛ́ dó lɛ́ zɔ́n 0./// bo na lɛ́ na nùjlɔ́mɛnu e ɖò sɛ́dó é. Nú nùjlɔ́mɛnu ɔ́ ɖò zɔ́n ɖokpo ɔ́ jí ɔ́ /// Wǎ azɔ̀ e nɔ yí nùɖé (kwɛ́n) e nɔ sɔ́ nùɖé lɛ́ɛ xlɛ́ é ɖé/// >>> closest_integer(String::from(""10""))
/// 10
/// >>> closest_integer(String::from(""15.3""))
/// 15
/// Note:
/// Rounding away from zero means that if the given number is equidistant
/// from two integers, the one you should return is the one that is the
/// farthest from zero. For example closest_integer(""14.5"") should
/// return 15 and closest_integer(""-14.5"") should return -15.
fn closest_integer(value: String) -> isize {
","fn closest_integer(value: String) -> isize {
    let num: f64 = value.parse().expect(""Invalid number format"");
    if num.fract().abs() == 0.5 {
        if num.is_sign_positive() {
            num.ceil() as isize
        } else {
            num.floor() as isize
        }
    } else {
        num.round() as isize
    }
}

// Example usage
fn main() {
    println!(""{}"", closest_integer(String::from(""10"")));   // Output: 10
    println!(""{}"", closest_integer(String::from(""15.3""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""14.5""))); // Output: 15
    println!(""{}"", closest_integer(String::from(""-14.5""))); // Output: -15
}","}

fn main() {
    let candidate = closest_integer;
    assert_eq!(candidate(String::from(""10"")), 10);
    assert_eq!(candidate(String::from(""14.5"")), 15);
    assert_eq!(candidate(String::from(""-15.5"")), -16);
    assert_eq!(candidate(String::from(""15.3"")), 15);
    assert_eq!(candidate(String::from(""0"")), 0);
}
"
HumanEval_100,fon_Latn,rs,"/// Kpɔ́ndéwú: ///i nɔte nú awinnya lɛ́ɛ ɖò xù ɔ́ mɛ (i+1)./// Ðèñóåò ÷èñëî êðóãîâ â êàæäîì óðîâíå â ýëåêòðîííîì âèäå, ãäå ýëåìåíò íà íîðìàòèâå /// - nùxwlé e ɖò nukɔn é nú n nyí nùxwlé ɔ. /// - nùxwɛ́ e ɖò nukɔn é nú n nyí nùxwɛ́ ǎ ɔ. /// Akpá e ɖò xota e bɔ d'ewu é mɛ lɛ́ɛ sín nùxwásá nyí: //Awǐnnya lɛ́ɛ ɖò tɛn nukɔntɔn ɔ mɛ./// Nú è na ɖó nùjlɛ́kpá e nyí nǔ ɖagbe é n ɔ, è ɖó na bló awinnya xwixwe n tɔn./// >>> make_a_pile(3)
/// vec![3, 5, 7]
fn make_a_pile(n: isize) -> Vec<isize> {
","fn make_a_pile(n: isize) -> Vec<isize> {
    let mut pile = Vec::new();
    let mut current = n;
    
    for _ in 0..n {
        pile.push(current);
        current = if n % 2 == 1 {
            current + 2
        } else {
            current + 2
        };
    }
    
    pile
}

fn main() {
    let level = make_a_pile(3);
    println!(""{:?}"", level);
}","}

fn main() {
    let candidate = make_a_pile;
    assert_eq!(candidate(3), vec![3, 5, 7]);
    assert_eq!(candidate(4), vec![4, 6, 8, 10]);
    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);
    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);
    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);
}
"
HumanEval_101,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// bo na klán wlan ɔ dó xókwín lɛ jí bo na lɛ́ lɛ́ wá nú xókwín lɛ sín wuntun ɖé.//È na sɔ́ xókwin lɛ́ɛ dó akpáxwé ɖé lɛ́ɛ mɛ, bɔ è na ɖó wuntun alǒ tɛn dó lɛ́ɛ./// >>> words_string(String::from(""Hi, my name is John""))
/// vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]
/// >>> words_string(String::from(""One, two, three, four, five, six""))
/// vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]
fn words_string(s: String) -> Vec<String> {
","fn words_string(s: String) -> Vec<String> {
    s.split(|c: char| c.is_whitespace() || c == ',')
        .filter(|word| !word.is_empty())
        .map(String::from)
        .collect()
}","}

fn main() {
    let candidate = words_string;
    assert_eq!(candidate(String::from(""Hi, my name is John"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name""), String::from(""is""), String::from(""John"")]);
    assert_eq!(candidate(String::from(""One, two, three, four, five, six"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from(""Hi, my name"")), vec![String::from(""Hi""), String::from(""my""), String::from(""name"")]);
    assert_eq!(candidate(String::from(""One,, two, three, four, five, six,"")), vec![String::from(""One""), String::from(""two""), String::from(""three""), String::from(""four""), String::from(""five""), String::from(""six"")]);
    assert_eq!(candidate(String::from("""")), Vec::<String>::new());
    assert_eq!(candidate(String::from(""ahmed     , gamal"")), vec![String::from(""ahmed""), String::from(""gamal"")]);
}
"
HumanEval_102,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// nùxwlé enɛ ɖé ma ɖò finɛ ǎ ɔ, azɔ̀ ɔ na lɛ́ lɛ́ kɔ̀n -1./// nùxwɛ́ e nyí nùxwɛ́ e nyí nùxwɛ́ ɖaxó hugǎn é ɖò tɛntin [x, y] mɛ./// Nǔwiwa elɔ nɔ sɔ́ nùxwɛ́ ɖagbe wè x kpo y kpo bó nɔ lɛ́ yí nùxwɛ́ ɖagbe wè lɛ́ɛ sín nùxwɛ́ /// >>> choose_num(12, 15)
/// 14
/// >>> choose_num(13, 12)
/// -1
fn choose_num(x: isize, y: isize) -> isize {
","fn choose_num(x: isize, y: isize) -> isize {
    let (start, end) = if x < y { (x, y) } else { (y, x) };
    for n in (start..=end).rev() {
        if n % 2 == 0 {
            return n;
        }
    }
    -1
}

fn main() {
    println!(""{}"", choose_num(12, 15)); // 14
    println!(""{}"", choose_num(13, 12)); // -1
}","}

fn main() {
    let candidate = choose_num;
    assert_eq!(candidate(12, 15), 14);
    assert_eq!(candidate(13, 12), -1);
    assert_eq!(candidate(33, 12354), 12354);
    assert_eq!(candidate(5234, 5233), -1);
    assert_eq!(candidate(6, 29), 28);
    assert_eq!(candidate(27, 10), -1);
    assert_eq!(candidate(7, 7), -1);
    assert_eq!(candidate(546, 546), 546);
}
"
HumanEval_104,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// Nùjlɛ́n: Wěxomɛ e è na lɛ́ wá lɛ́ɛ ɔ́, è ɖó na sɔ́ dó tito jí./// nǔ e ma ɖó nùxwásún e nyí gan ɔ ɖě ǎ é./// Nú è na wèmá nú nùjlɛ́kpá ɖagbe lɛ́ɛ x ɔ́, é na lɛ́ vɔ́ wèmá è è ɖè lɛ́ɛ bǐ sín wèmá ɔ́ ná./// >>> unique_digits(vec![15, 33, 1422, 1])
/// vec![1, 15, 33]
/// >>> unique_digits(vec![152, 323, 1422, 10])
/// Vec::<isize>::new()
fn unique_digits(x: Vec<isize>) -> Vec<isize> {
","fn unique_digits(x: Vec<isize>) -> Vec<isize> {
    let mut result: Vec<isize> = x.into_iter()
        .filter(|&num| {
            num.to_string().chars().all(|c| {
                match c {
                    '0' | '2' | '4' | '6' | '8' => false,
                    _ => true,
                }
            })
        })
        .collect();
    result.sort();
    result
}","}

fn main() {
    let candidate = unique_digits;
    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);
    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());
    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);
    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);
}
"
HumanEval_105,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// ""Ðåñòîðàí"", ""Ëèöà"", ""Ì3í"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà"", ""Ëèöà""./// lɛ́ kɔ́n nùxwásá e è mɔ é, bo nɔ́ sɔ́ nùkwín ɖokpo ɖokpo ɖó tɛn tɔn mɛ./// Nú è na w'azɔnmɛju lɛ sín vectɔ́ ɖé ɔ, ɖè nùjlɛ́jlɛ́ lɛ ɖò 1 jɛ 9 mɛ lɛ é, /// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
/// vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]
/// If the vector is empty, return an empty vector:
/// >>> by_length(vec![])
/// Vec::<String>::new()
/// If the vector has any strange number ignore it:
/// >>> by_length(vec![1, -1, 55])
/// vec![String::from(""One"")]
fn by_length(arr: Vec<isize>) -> Vec<String> {
","fn by_length(arr: Vec<isize>) -> Vec<String> {
    let digit_names = [
        ""One"", ""Two"", ""Three"", ""Four"", ""Five"", 
        ""Six"", ""Seven"", ""Eight"", ""Nine"",
    ];

    let mut filtered: Vec<isize> = arr.into_iter()
        .filter(|&x| x >= 1 && x <= 9)
        .collect();

    filtered.sort();
    filtered.reverse();

    filtered.into_iter()
        .map(|x| String::from(digit_names[(x - 1) as usize]))
        .collect()
}","}

fn main() {
    let candidate = by_length;
    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(""Eight""), String::from(""Five""), String::from(""Four""), String::from(""Three""), String::from(""Two""), String::from(""Two""), String::from(""One""), String::from(""One"")]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());
    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(""One"")]);
    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(""Three""), String::from(""Two""), String::from(""One"")]);
    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(""Nine""), String::from(""Eight""), String::from(""Four"")]);
}
"
HumanEval_106,fon_Latn,rs,"/// Kpɔ́n: /// ɔ́' nǔxwlé wɛ nyí nùjlɛ́kpo e ɖò 1 jí jɛ i jí lɛ́ɛ sín nǔxwlé (1 * 2 * ... * i).///i bɛ́ sín 1. /// alǒ nùjlɛ́kpo lɛ sín nǔxixa sín 1 jɛ i jí. /// bo na lɛ́ na nùxwlévéktɔ́ nùxwlévéktɔ́n tɔn n, bɔ nùxwlévéktɔ́n ɔ sín akwɛ́ ɖò nǔxwlévéktɔ́ i tɔn jí ɔ na nyí nǔxwlévéktɔ́ i tɔn tɔn nú i nyí nǔxwlévéktɔ́ ɔ /// Zɔ́n azɔ̀ f e nɔ sɔ́ n dó ɖó nùɖé lɛ́ɛ, /// >>> f(5)
/// vec![1, 2, 6, 24, 15]
fn f(n: isize) -> Vec<isize> {
","fn f(n: isize) -> Vec<isize> {
    fn factorial(x: isize) -> isize {
        (1..=x).product()
    }

    fn sum_up_to(x: isize) -> isize {
        (1..=x).sum()
    }

    (1..=n)
        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })
        .collect()
}","}

fn main() {
    let candidate = f;
    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);
    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);
    assert_eq!(candidate(1), vec![1]);
    assert_eq!(candidate(3), vec![1, 2, 6]);
}
"
HumanEval_107,fon_Latn,rs,"//Kpɔ́nmɛ 1: /// palindromes nùxwásá e ɖò tɛnkpɔn ɔ mɛ lɛ é wɛ nyí ((1, n), kpodo mɛ lɛ bǐ kpo. /// Nú è na w'azɔnkpɔnkpɔn ɖagbe n ɔ, lɛ́ kɔ nú tuple e ɖó nùɖé lɛ́ɛ ɖò w'azɔnkpɔnkpɔnkpɔn kpo w'azɔnkpɔnkpɔn kpo mɛ é /// >>> even_odd_palindrome(3)
/// (1, 2)
/// Explanation:
/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
/// Example 2:
/// >>> even_odd_palindrome(12)
/// (4, 6)
/// Explanation:
/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
/// Note:
/// 1. 1 <= n <= 10^3
/// 2. returned tuple has the number of even and odd integer palindromes respectively.
fn even_odd_palindrome(n: isize) -> (isize, isize) {
","fn is_palindrome(x: isize) -> bool {
    let s = x.to_string();
    s == s.chars().rev().collect::<String>()
}

fn even_odd_palindrome(n: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    
    for i in 1..=n {
        if is_palindrome(i) {
            if i % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_palindrome;
    assert_eq!(candidate(123), (8, 13));
    assert_eq!(candidate(12), (4, 6));
    assert_eq!(candidate(3), (1, 2));
    assert_eq!(candidate(63), (6, 8));
    assert_eq!(candidate(25), (5, 6));
    assert_eq!(candidate(19), (4, 6));
    assert_eq!(candidate(9), (4, 5));
    assert_eq!(candidate(1), (0, 1));
}
"
HumanEval_108,fon_Latn,rs,"///e.g. -123 ɖó wuntun nùjlɛ́kpo -1, 2 kpo 3. /// Nú nùjlɛ́kpo ɖé nyí nǔglɔ́ ɔ, hǔn, wuntun tɔn nukɔntɔn ɔ na nyí nǔglɔ́: /// nùxwlé lɛ́ɛ e nùxwlé lɛ́ɛ tɔn nɔ́ ná nǔ => 0 é. /// Wlǎn azɔ̀ count_nums e nɔ yí nùjlɛ́kpá è nɔ lɛ́ lɛ́ kɔ́n é ɖé/// >>> count_nums(vec![])
/// 0
/// >>> count_nums(vec![-1, 11, -11])
/// 1
/// >>> count_nums(vec![1, 1, 2])
/// 3
fn count_nums(arr: Vec<isize>) -> isize {
","fn count_nums(arr: Vec<isize>) -> isize {
    arr.into_iter()
        .filter(|&num| {
            let mut n = num;
            let mut sum = 0;
            let mut is_first_digit = true;

            while n != 0 {
                let digit = if is_first_digit {
                    is_first_digit = false;
                    n % 10
                } else {
                    (n % 10).abs()
                };
                sum += digit;
                n /= 10;
            }
            sum > 0
        })
        .count() as isize
}","}

fn main() {
    let candidate = count_nums;
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![-1, -2, 0]), 0);
    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);
    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);
    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);
    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);
    assert_eq!(candidate(vec![0, 1]), 1);
    assert_eq!(candidate(vec![1]), 1);
}
"
HumanEval_109,fon_Latn,rs,"/// Cǐwún: /// Nùjlɛ́n: È na d'alɔ ɖɔ akpàkpà na ɖó nǔ e nyí vo lɛ é ɖò vector ɔ mɛ./// Nú vector e è ná é ma ɖò nǔtí ǎ ɔ, é na lɛ́ wá nyí nǔtí./// bo lɛ́ lɛ́ wá mɔ̀ ɔ́, é ná lɛ́ wá mɔ̀ ɖɔ é nyí nǔvú./// Nú é kpéwú bo na mɔ̀ vector e è ɖè ɔ gbɔn azɔ̀ e è wlan ɖò tají é gblamɛ ɔ /// tɛnkpɔn tò ɖò vector ɔ mɛ é wɛ nyí 0th index. /// nɔte ɖò ali ɖagbe ɔ mɛ. Nǔɖeji gudo tɔn ɔ na yì fí e è nɔ ylɔ ɖɔ /// Nùnina ɖisiɖisi ɖokpo ɔ́' é nɔ́ ɖɔ è na zín vector ɔ́ sín nǔ lɛ́ɛ bǐ ɖó ɖokpo.//A na bló azɔ̀ ɖisiɖisi nú azɔn mɔkpan./// azɔ̀ e ɖò sɛ́dó ɔ́ jí é ɖò nùjlɛ́jlɛ́ e è ná é jí: /// é sixu nyí ɖɔ è na ɖè vector ɖé ɖò tito e ma ɖò ɖiɖí wɛ ǎ mɛ gbɔn azɔ̌ e è nɔ bló é gblamɛ //nùxwásá lɛ́ɛ ɖò nùjlɛ́kpó ɔ́ mɛ ɔ́ è na sɔ́ dó nùɖé jí ǎ. azɔ̌ towe wɛ nyí ɖɔ a na kpɔ́n ɖɔ nùxwásá lɛ́ɛ ɖò nùjlɛ́kpó ɔ́ mɛ à jí./// Mǐ ɖó vector 'arr' nú nùxwléma N e nyí arr[1], arr[2], ..., arr[N]./// >>> move_one_ball(vec![3, 4, 5, 1, 2])
/// true
/// Explanation: By performin 2 right shift operations, non-decreasing order can
/// be achieved for the given vector.
/// >>> move_one_ball(vec![3, 5, 4, 1, 2])
/// false
/// Explanation:It is not possible to get non-decreasing order for the given
/// vector by performing any number of right shift operations.
fn move_one_ball(arr: Vec<isize>) -> bool {
","fn move_one_ball(arr: Vec<isize>) -> bool {
    if arr.is_empty() {
        return true; // An empty array is already considered sorted.
    }
    
    let mut break_point = 0;
    let mut break_found = false;
    let len = arr.len();

    for i in 0..len {
        if arr[i] > arr[(i + 1) % len] {
            if break_found {
                return false;  // Found more than one break point, not possible.
            }
            break_point = i + 1;
            break_found = true;
        }
    }
    
    // After finding a single break point, simulate the right shift by 'break_point'
    for i in 0..len {
        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {
            return false; // Not sorted in non-decreasing order with this shift.
        }
    }
    
    true
}

// Example usages:

// This will return true, as we can shift twice to sort it.
assert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);

// This will return false, as we can't sort this by any number of shifts.
assert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","}

fn main() {
    let candidate = move_one_ball;
    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);
    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);
    assert_eq!(candidate(vec![4, 3, 1, 2]), false);
    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
}
"
HumanEval_110,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// Enyi é ma nyí mɔ̌ ǎ ɔ, lɛkɔ nú ""ÉÒ""./// nú nǔ lɛ́ɛ bǐ ɖò lst1 mɛ ɔ, yí gbè nú ""YES""./// N'ɛ́ nyí nǔ e na kpéwú bɔ è na ɖyɔ́ nǔ lɛ ɖò lst1 kpo lst2 kpo tɛntin é ɔ́, è na bló /// E sɔ́ ɖó dogbó nú nùxámɛ nǔ e è sixu ɖyɔ ɖò lst1 kpo lst2 kpo tɛntin é ǎ./// ɖò ye tɛntin bo bló lst1 ɖó nùxwlé lɛ́ɛ ɖokpo ɖokpo sín vectɔ́./// bo nɔ ɖɔ ɖɔ e na kpé bo na ɖyɔ nǔ lɛ é à jí /// Ðò nùkanbyɔ elɔ mɛ ɔ, a na zán azɔ̀ e nɔ yí nùjlɛ́jlɛ́ wè lɛ é, /// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])
/// String::from(""YES"")
/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])
/// String::from(""NO"")
/// It is assumed that the input vectors will be non-empty.
fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
","fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {
    let mut even_in_lst2 = false;
    for &num in &lst2 {
        if num % 2 == 0 {
            even_in_lst2 = true;
            break;
        }
    }

    if even_in_lst2 {
        for &num in &lst1 {
            if num % 2 != 0 {
                return String::from(""YES"");
            }
        }
        return String::from(""YES"");
    }

    String::from(""NO"")
}

fn main() {
    // Example cases
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); // ""YES""
    println!(""{}"", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); // ""NO""
}","}

fn main() {
    let candidate = exchange;
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(""NO""));
    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(""YES""));
    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(""NO""));
    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(""NO""));
    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(""YES""));
}
"
HumanEval_111,fon_Latn,rs,"use std::collections::HashMap;

/// Kpɔ́n: /// Nú wlan ɖokpo ɔ ɖò wemafɔ gègě mɛ ɔ, lɛ̌n bǐ./// wema e nɔ lɛ́ jɛ azɔn gègě é kpo nǔ e è nɔ lɛ́ ɖɔ é kpo./// Nú è na wèmá e nɔ xlɛ́ wèmá kpɛví kpɛví e è klán ɖó vo lɛ é ɔ, lɛ́ kɔ́ HashMap /// >>> histogram(String::from(""a b c""))
/// HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])
/// >>> histogram(String::from(""a b b a""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""a b c a b""))
/// HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])
/// >>> histogram(String::from(""b b b b a""))
/// HashMap::from([(String::from(""b""), 4)])
/// >>> histogram(String::from(""""))
/// HashMap::from([])
fn histogram(test: String) -> HashMap<String, isize> {
","use std::collections::HashMap;

fn histogram(test: String) -> HashMap<String, isize> {
    let mut counts: HashMap<String, isize> = HashMap::new();
    let mut max_count = 0;

    for letter in test.split_whitespace() {
        let count = counts.entry(letter.to_string()).or_insert(0);
        *count += 1;
        if *count > max_count {
            max_count = *count;
        }
    }

    counts.retain(|_, &mut val| val == max_count);
    counts
}

fn main() {
    let result = histogram(String::from(""a b c""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1)])

    let result = histogram(String::from(""a b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""a b c a b""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)])

    let result = histogram(String::from(""b b b b a""));
    println!(""{:?}"", result); // HashMap::from([(String::from(""b""), 4)])

    let result = histogram(String::from(""""));
    println!(""{:?}"", result); // HashMap::from([])
}","}

fn main() {
    let candidate = histogram;
    assert_eq!(candidate(String::from(""a b b a"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c a b"")), HashMap::from([(String::from(""a""), 2), (String::from(""b""), 2)]));
    assert_eq!(candidate(String::from(""a b c d g"")), HashMap::from([(String::from(""a""), 1), (String::from(""b""), 1), (String::from(""c""), 1), (String::from(""d""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from(""b b b b a"")), HashMap::from([(String::from(""b""), 4)]));
    assert_eq!(candidate(String::from(""r t g"")), HashMap::from([(String::from(""r""), 1), (String::from(""t""), 1), (String::from(""g""), 1)]));
    assert_eq!(candidate(String::from("""")), HashMap::from([]));
    assert_eq!(candidate(String::from(""a"")), HashMap::from([(String::from(""a""), 1)]));
}
"
HumanEval_112,fon_Latn,rs,"/// Kpɔ́ndéwú /// A na lɛ́ yí nùɖé dó nùɖé jí, bɔ nǔ e è na mɔ é ná nyí wuntun ɖé bɔ wuntun ɔ na nyí true/false nú kpɔnwun ɔ. /// Sɛ́n e è nɔ ylɔ ɖɔ palindrome ɔ́' é nɔ́ xa nǔ ɖokpo ɔ́ ɖò nukɔn kpo gudo kpo mɛ./// bo kpɔ́n ɖɔ xwɛ e è mɔ é nyí palindrome à jí. /// È na mǐ wuntun we s kpo c kpo, a na ɖè wuntun e ɖò s mɛ lɛ é bǐ e cí wuntun e ɖò c mɛ lɛ é ɖɔhun lɛ é./// Azɔ̌ /// >>> reverse_delete(String::from(""abcde""), String::from(""ae""))
/// (String::from(""bcd""), false)
/// >>> reverse_delete(String::from(""abcdef""), String::from(""b""))
/// (String::from(""acdef""), false)
/// >>> reverse_delete(String::from(""abcdedcba""), String::from(""ab""))
/// (String::from(""cdedc""), true)
fn reverse_delete(s: String, c: String) -> (String, bool) {
","fn reverse_delete(s: String, c: String) -> (String, bool) {
    // Create a set of characters to delete for quick lookup
    let delete_chars: std::collections::HashSet<char> = c.chars().collect();
    
    // Filter the string, keeping only characters not in the delete set
    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();
    
    // Check if the filtered string is a palindrome
    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();
    
    // Return the filtered string and whether it's a palindrome
    (filtered, is_palindrome)
}","}

fn main() {
    let candidate = reverse_delete;
    assert_eq!(candidate(String::from(""abcde""), String::from(""ae"")), (String::from(""bcd""), false));
    assert_eq!(candidate(String::from(""abcdef""), String::from(""b"")), (String::from(""acdef""), false));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""ab"")), (String::from(""cdedc""), true));
    assert_eq!(candidate(String::from(""dwik""), String::from(""w"")), (String::from(""dik""), false));
    assert_eq!(candidate(String::from(""a""), String::from(""a"")), (String::from(""""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from("""")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""abcdedcba""), String::from(""v"")), (String::from(""abcdedcba""), true));
    assert_eq!(candidate(String::from(""vabba""), String::from(""v"")), (String::from(""abba""), true));
    assert_eq!(candidate(String::from(""mamma""), String::from(""mia"")), (String::from(""""), true));
}
"
HumanEval_113,fon_Latn,rs,"/// nú è nɔ mɔ xwɛɖuxwɛ ɖò xwɛɖuxwɛ i'ɔ ɔ mɛ.///n ɔ e ɖo nǔ e è wlan ɔ mɛ é. "" fí e è na sɔ́ nú númɛ  ɔ dó xɔ tɛn nú númɛ lɛ bǐ é./// Nǔɖevi ɖokpo ɖokpo i tɔn e è nɔ ɖe tɔ́n é ɖó na nyí nùxíxo nǔɖevi e ɖò mɛ lɛ é tɔn ɖò nǔɖevi ɔ mɛ./// Nú è na wèmá nú wèmá lɛ́ɛ, bɔ wèmá lɛ́ɛ ɖokpó ɖokpó nɔ́ ɖó wèmá nú wèmá lɛ́ɛ kɛɖɛ́, hǔn lɛ́ vɔ́ wèmá ɔ́./// >>> odd_count(vec![String::from(""1234567"")])
/// vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]
/// >>> odd_count(vec![String::from(""3""), String::from(""11111111"")])
/// vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]
fn odd_count(lst: Vec<String>) -> Vec<String> {
","fn odd_count(lst: Vec<String>) -> Vec<String> {
    lst.iter()
        .map(|s| {
            let odd_count = s.chars().filter(|&c| {
                match c {
                    '1' | '3' | '5' | '7' | '9' => true,
                    _ => false,
                }
            }).count();
            format!(""the number of odd elements {0}n the str{0}ng {0} of the {0}nput."", odd_count)
        })
        .collect()
}

// Example usage:
// fn main() {
//     let result = odd_count(vec![String::from(""1234567"")]);
//     println!(""{:?}"", result);
// 
//     let result = odd_count(vec![String::from(""3""), String::from(""11111111"")]);
//     println!(""{:?}"", result);
// }","}

fn main() {
    let candidate = odd_count;
    assert_eq!(candidate(vec![String::from(""1234567"")]), vec![String::from(""the number of odd elements 4n the str4ng 4 of the 4nput."")]);
    assert_eq!(candidate(vec![String::from(""3""), String::from(""11111111"")]), vec![String::from(""the number of odd elements 1n the str1ng 1 of the 1nput.""), String::from(""the number of odd elements 8n the str8ng 8 of the 8nput."")]);
    assert_eq!(candidate(vec![String::from(""271""), String::from(""137""), String::from(""314"")]), vec![String::from(""the number of odd elements 2n the str2ng 2 of the 2nput.""), String::from(""the number of odd elements 3n the str3ng 3 of the 3nput.""), String::from(""the number of odd elements 2n the str2ng 2 of the 2nput."")]);
}
"
HumanEval_114,fon_Latn,rs,"/// Kpɔ́ndéwú /// nùɖé lɛ́ɛ. /// Ɖò nùxwlé lɛ́ɛ sín nùxwlé ɖé ɔ, mɔ nùxwlé e nyí nùxwlé è ma nyí nǔtí ǎ é ɖé sín nùxwlé kpɛví ɔ /// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])
/// 1
/// >>> minSubArraySum(vec![-1, -2, -3])
/// -6
fn minSubArraySum(nums: Vec<isize>) -> isize {
","fn minSubArraySum(nums: Vec<isize>) -> isize {
    let mut min_sum = nums[0];
    let mut current_sum = nums[0];

    for &num in nums.iter().skip(1) {
        current_sum = current_sum.min(current_sum + num);
        min_sum = min_sum.min(current_sum);
    }

    min_sum
}","}

fn main() {
    let candidate = minSubArraySum;
    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);
    assert_eq!(candidate(vec![-1, -2, -3]), -6);
    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);
    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);
    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);
    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);
    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);
    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);
    assert_eq!(candidate(vec![-10]), -10);
    assert_eq!(candidate(vec![7]), 7);
    assert_eq!(candidate(vec![1, -1]), -1);
}
"
HumanEval_115,fon_Latn,rs,"//Kpɔ́nmɛ 1: /// Nɔ sɔ́ azɔn e a na dó ɖè kɔ́n lɛ́ɛ ɔ́ dó./// Nǔ e mi na wà ɔ́ wɛ nyí ɖɔ mi na zán kɔ́n lɛ bo na dó xú tɔ ɔ́./// bo sinkpo lɛ bǐ ɖó nǔ ɖokpo ɔ. /// Hwe ɖokpo ɖokpo ɖó tɔjihun e è sixu zán dó ɖè sin sín mɛ é, /// bo mɛ ɖokpo ɖokpo ɖo ali ɖokpo ɔ mɛ nɔte nú sin ɖokpo ɖokpo. //A mɔ tɔjɔtɛn e è nɔ mɔ ɖò ali ɖokpo ɖokpo jí lɛ é sín xwɛ̌ ɖé./// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)
/// 6
/// Example 2:
/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)
/// 5
/// Example 3:
/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)
/// 0
/// Constraints:
/// * all wells have the same length
/// * 1 <= grid.length <= 10^2
/// * 1 <= grid[:,1].length <= 10^2
/// * grid[i][j] -> 0 | 1
/// * 1 <= capacity <= 10
fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
","fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {
    let mut total_water_units = 0;

    for row in grid.iter() {
        for &unit in row.iter() {
            total_water_units += unit;
        }
    }

    // Calculate how many times we need to lower the bucket to extract all water units
    (total_water_units + capacity - 1) / capacity
}

fn main() {
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); // 6
    println!(""{}"", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); // 5
    println!(""{}"", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); // 0
}","}

fn main() {
    let candidate = max_fill;
    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);
    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);
    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);
    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);
}
"
HumanEval_116,fon_Latn,rs,"/// É ɖó na nyí mɔ̌: /// Nú è na mɔ nùxíxo e cí ɖokpo ɔ tɔn ɔ, è na ɖè nǔ lɛ ɖò nǔ e è nɔ ylɔ ɖɔ nǔɖogbɛ ɔ jí./// nùxwásá nú mɛ ɖò nùjlɛ́kpá wexwɛ tɔn yetɔn mɛ ɖò nùxwásá jí./// Ðò Kata elɔ mɛ ɔ, a ɖó na ɖè nùxwlé lɛ sín vector e ma nyí nùxwlé e nyí nǔmasɔgbe ǎ lɛ é ɖò nǔ e nyí /// >>> sort_array(vec![1, 5, 2, 3, 4])
/// vec![1, 2, 3, 4, 5]
/// >>> sort_array(vec![-2, -3, -4, -5, -6])
/// vec![-6, -5, -4, -3, -2]
/// >>> sort_array(vec![1, 0, 2, 3, 4])
/// vec![0, 1, 2, 3, 4]
fn sort_array(arr: Vec<isize>) -> Vec<isize> {
","fn sort_array(arr: Vec<isize>) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_by(|&a, &b| {
        let ones_a = a.count_ones();
        let ones_b = b.count_ones();
        if ones_a == ones_b {
            a.cmp(&b)
        } else {
            ones_a.cmp(&ones_b)
        }
    });
    arr
}

fn main() {
    println!(""{:?}"", sort_array(vec![1, 5, 2, 3, 4])); // Output: [1, 2, 3, 4, 5]
    println!(""{:?}"", sort_array(vec![-2, -3, -4, -5, -6])); // Output: [-6, -5, -4, -3, -2]
    println!(""{:?}"", sort_array(vec![1, 0, 2, 3, 4])); // Output: [0, 1, 2, 3, 4]
}","}

fn main() {
    let candidate = sort_array;
    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);
    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);
    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);
}
"
HumanEval_117,fon_Latn,rs,"/// Kpɔ́ndéwú: /// à: a sixu ɖɔ ɖɔ xò e è nɔ dó ɔ́ ɖó wlan kpo tɛn kpo kɛɖɛ. /// Nú wèmá s ɔ mɛ̀ ɖò blǒbló ɔ́ azɔ̀ ɔ́ ɖó na lɛ́ lɛ́ wá ɖó nùɖé dó nùɖé jí ǎ.///n nǔxixa lɛ, bo na ɖɔ xó enɛ lɛ ɖò xɔntɔn s mɛ. /// nùxwásá e nɔ lɛ́ yí xókwín e ɖò xɛ́n s mɛ lɛ́ɛ bǐ sín wektɔ́ ɖé dó é wɛ nyí /// Nú è na wèmá s kpo nùxwásùn n kpo ɔ, è na byɔ we ɖɔ a ni bló /// >>> select_words(String::from(""Mary had a little lamb""), 4)
/// vec![String::from(""little"")]
/// >>> select_words(String::from(""Mary had a little lamb""), 3)
/// vec![String::from(""Mary""), String::from(""lamb"")]
/// >>> select_words(String::from(""simple white space""), 2)
/// Vec::<String>::new()
/// >>> select_words(String::from(""Hello world""), 4)
/// vec![String::from(""world"")]
/// >>> select_words(String::from(""Uncle sam""), 3)
/// vec![String::from(""Uncle"")]
fn select_words(s: String, n: isize) -> Vec<String> {
","fn select_words(s: String, n: isize) -> Vec<String> {
    let consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";
    let mut result = Vec::new();

    for word in s.split_whitespace() {
        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();
        if consonant_count == n as usize {
            result.push(word.to_string());
        }
    }

    result
}","}

fn main() {
    let candidate = select_words;
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 4), vec![String::from(""little"")]);
    assert_eq!(candidate(String::from(""Mary had a little lamb""), 3), vec![String::from(""Mary""), String::from(""lamb"")]);
    assert_eq!(candidate(String::from(""simple white space""), 2), Vec::<String>::new());
    assert_eq!(candidate(String::from(""Hello world""), 4), vec![String::from(""world"")]);
    assert_eq!(candidate(String::from(""Uncle sam""), 3), vec![String::from(""Uncle"")]);
    assert_eq!(candidate(String::from(""""), 4), Vec::<String>::new());
    assert_eq!(candidate(String::from(""a b c d e f""), 1), vec![String::from(""b""), String::from(""c""), String::from(""d""), String::from(""f"")]);
}
"
HumanEval_118,fon_Latn,rs,"/// Kpɔ́n: /// Mi sixu ɖɔ ɖɔ wuntun e è na é ɔ na ɖó wuntun e è nɔ zán dó wlan xókwin Eŋlisi tɔn lɛ é kɛɖɛ./// mɔ̀ gbèɖè ɔ́ ɖě e kpé nǔ e è ɖɔ ɖò tají é wú ǎ.///Vocal ɖò nukɔnmɛ kpo gudo kpo ɔ́ nɔ́ xa ǎ. Nú a ma xa ǎ ɔ́, lɛ́ kɔ̀ wlan mɛ̀ ɔ́./// kpodo xwɛxwɛ we kpo sín akpáxwé ɖisixwé tɔn ɔ tɔn (ɖokpo ɔ nɔ nɔte nú).//È na xó ɖé mi. Azɔ̌ mitɔn wɛ nyí ɖɔ mi na mɔ xókwin e ɖò voxo e ɖò we mɛ é./// >>> get_closest_vowel(String::from(""yogurt""))
/// String::from(""u"")
/// >>> get_closest_vowel(String::from(""FULL""))
/// String::from(""U"")
/// >>> get_closest_vowel(String::from(""quick""))
/// String::from("""")
/// >>> get_closest_vowel(String::from(""ab""))
/// String::from("""")
fn get_closest_vowel(word: String) -> String {
","fn get_closest_vowel(word: String) -> String {
    let vowels = ""aeiouAEIOU"";
    let chars: Vec<char> = word.chars().collect();
    if chars.len() < 3 {
        return String::from("""");
    }

    for i in (1..chars.len() - 1).rev() {
        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {
            return chars[i].to_string();
        }
    }
    String::from("""")
}","}

fn main() {
    let candidate = get_closest_vowel;
    assert_eq!(candidate(String::from(""yogurt"")), String::from(""u""));
    assert_eq!(candidate(String::from(""full"")), String::from(""u""));
    assert_eq!(candidate(String::from(""easy"")), String::from(""""));
    assert_eq!(candidate(String::from(""eAsy"")), String::from(""""));
    assert_eq!(candidate(String::from(""ali"")), String::from(""""));
    assert_eq!(candidate(String::from(""bad"")), String::from(""a""));
    assert_eq!(candidate(String::from(""most"")), String::from(""o""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""""));
    assert_eq!(candidate(String::from(""ba"")), String::from(""""));
    assert_eq!(candidate(String::from(""quick"")), String::from(""""));
    assert_eq!(candidate(String::from(""anime"")), String::from(""i""));
    assert_eq!(candidate(String::from(""Asia"")), String::from(""""));
    assert_eq!(candidate(String::from(""Above"")), String::from(""o""));
}
"
HumanEval_119,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Yi 'Yì' bo na lɛ́ lɛ́ mɔ ali ɖé bo na bló wuntun ɖagbe ɖé, bo lɛ́ yi 'Ée' bo na lɛ́ lɛ́ mɔ ali ɖé bo na lɛ́ lɛ́ lɛ́ mɔ ali ɖagbe ɖé./// ""()) ' e nyí ǎ./// nɔ ɖò jlɛjε. ε: xɛ '(())))' nyɔ́, hwenu e xɛ /// Wěma S tɔn ɔ è nɔ ɖɔ é nyɔ́ nú é nyí ɖɔ akpàkpà e ɖò S mɛ lɛ é bǐ wɛ nyí nǔ ɖagbe /// nǔ ɖé lɛ́ɛ ná ɖò nǔ e è wlan é mɛ, bɔ é ná nyí nǔ ɖagbe ɖé.//azɔ̌ towe wɛ nyí ɖɔ a ni kpɔ́n ɖɔ è sixu dó wuntun wè lɛ dó wuntun ɔ mɛ à jí/// nú è sɔ́ wuntun "" (("") dó wuntun lɛ́ɛ mɛ kpowun ɔ́, è nɔ sɔ́ wuntun lɛ́ɛ dó wuntun lɛ́ɛ mɛ => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => => =>/// È na we wexwɛ we wexwɛ, wexwɛ we lɛ nɔ nyí hunhun /// >>> match_parens(vec![String::from(""()(""), String::from("")"")])
/// String::from(""Yes"")
/// >>> match_parens(vec![String::from("")""), String::from("")"")])
/// String::from(""No"")
fn match_parens(lst: Vec<String>) -> String {
","fn match_parens(lst: Vec<String>) -> String {
    fn is_balanced(s: &str) -> bool {
        let mut balance = 0;
        for ch in s.chars() {
            if ch == '(' {
                balance += 1;
            } else {
                balance -= 1;
            }
            if balance < 0 {
                return false;
            }
        }
        balance == 0
    }

    if lst.len() != 2 {
        return ""No"".to_string();
    }

    let s1 = &lst[0];
    let s2 = &lst[1];

    let combined1 = format!(""{}{}"", s1, s2);
    let combined2 = format!(""{}{}"", s2, s1);

    if is_balanced(&combined1) || is_balanced(&combined2) {
        ""Yes"".to_string()
    } else {
        ""No"".to_string()
    }
}","}

fn main() {
    let candidate = match_parens;
    assert_eq!(candidate(vec![String::from(""()(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from("")"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(())""), String::from(""())())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")())""), String::from(""(()()("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""(())))""), String::from(""(()())(("")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""()""), String::from(""())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(()(""), String::from(""()))()"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from(""((((""), String::from(""((())"")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(()""), String::from(""(()("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from("")(""), String::from("")("")]), String::from(""No""));
    assert_eq!(candidate(vec![String::from(""(""), String::from("")"")]), String::from(""Yes""));
    assert_eq!(candidate(vec![String::from("")""), String::from(""("")]), String::from(""Yes""));
}
"
HumanEval_120,fon_Latn,rs,"//Kpɔ́nmɛ 1: /// e nɔ ɖi ga k bɔ è nɔ mɔ nú nùxwásún e nɔ ɖò xwɛ ɔ mɛ lɛ é bǐ ɖò xwɛ ɔ mɛ./// Ɖó è na ná vector arr nùxwɛ́ ɔ́ bǐ lɛ́ɛ tɔn kpódó nùxwɛ́ ɖagbe ɔ́ bǐ k ɖé kpó ɔ́, lɛ́ kɔ́ vector e è sɔ́ ɖó alɔkpa tɔn mɛ é ɖé /// >>> maximum(vec![-3, -4, 5], 3)
/// vec![-4, -3, 5]
/// Example 2:
/// >>> maximum(vec![4, -4, 4], 2)
/// vec![4, 4]
/// Example 3:
/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)
/// vec![2]
/// Note:
/// 1. The length of the vector will be in the range of [1, 1000].
/// 2. The elements in the vector will be in the range of [-1000, 1000].
/// 3. 0 <= k <= len(arr)
fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
","fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {
    let mut arr = arr;
    arr.sort_unstable_by(|a, b| b.cmp(a));
    let k = k as usize;
    let mut result: Vec<isize> = arr.into_iter().take(k).collect();
    result.sort_unstable();
    result
}

fn main() {
    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
}","}

fn main() {
    let candidate = maximum;
    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);
    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);
    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);
    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);
    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);
    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);
    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);
    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());
}
"
HumanEval_121,fon_Latn,rs,"/// Kpɔ́ndéwú /// Nú è na wèmá nú nùjlɛ́kpá e nyí nùjlɛ́kpá ǎ lɛ́ɛ ɔ́, lɛ́ kɔ nú nǔ e nyí nǔmɛsɛn e ɖò tɛn e nyí nǔmɛsɛn lɛ́ɛ tɔn é bǐ tɔn é. /// >>> solution(vec![5, 8, 7, 1])
/// 12
/// >>> solution(vec![3, 3, 3, 3, 3])
/// 9
/// >>> solution(vec![30, 13, 24, 321])
/// 0
fn solution(lst: Vec<isize>) -> isize {
","fn solution(lst: Vec<isize>) -> isize {
    lst.iter()
        .enumerate()
        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)
        .map(|(_, &x)| x)
        .sum()
}","}

fn main() {
    let candidate = solution;
    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);
    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);
    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);
    assert_eq!(candidate(vec![5, 9]), 5);
    assert_eq!(candidate(vec![2, 4, 8]), 0);
    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);
    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);
}
"
HumanEval_122,fon_Latn,rs,"/// Kpɔ́n: /// nùtínmɛ lɛ́ɛ sín nǔ e nɔ́ ɖó wuntun we ɖò nǔtínmɛ nukɔntɔn lɛ́ɛ mɛ é sín nǔtínmɛ lɛ́ɛ sín nǔtínmɛ wɛ nyí nǔtínmɛ lɛ́ɛ./// Nú è na wèmá nú nùxwlé lɛ́ɛ e nyí nùɖé ǎ lɛ́ɛ ɔ́ arr kpo nùxwlé k kpo ɔ́, lɛ́ kɔ yì /// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
/// 24
/// Constraints:
/// 1. 1 <= len(arr) <= 100
/// 2. 1 <= k <= len(arr)
fn add_elements(arr: Vec<isize>, k: isize) -> isize {
","fn add_elements(arr: Vec<isize>, k: isize) -> isize {
    arr.iter()
        .take(k as usize)
        .filter(|&&x| x > -100 && x < 100)
        .sum()
}

fn main() {
    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);
    println!(""{}"", result);  // Output: 24
}","}

fn main() {
    let candidate = add_elements;
    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);
    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
    assert_eq!(candidate(vec![1], 1), 1);
}
"
HumanEval_123,fon_Latn,rs,"/// get_odd_collatz(5) lɛ́ lɛ́ kɔ́ [1, 5] # Akɔ́n e è nɔ ylɔ́ ɖɔ collatz nú 5 ɔ́ nyí [5, 16, 8, 4, 2, 1], enɛ ɔ́, nú è na ɖɔ ɖɔ nùxwlé lɛ́ɛ ɔ́, 1 kpo 5 kpo kɛ́ɖɛ́ wɛ è na mɔ./// Cɔ́n kpɔ́n: /// 2. è ɖè vector e è lɛ́ wá é ɖó zɔ́n bɔ é ɖò jijɛji wɛ./// 1. Collatz(1) wɛ nyí [1]. /// Akpádo: /// term plus 1. Nǔ e è nɔ ɖɔ é wɛ nyí ɖɔ enyi n na ɖó akwɛ alɔkpa ɖebǔ ɔ, nùxwlé lɛ na nɔ na 1 hwebǐnu.//Nú akpáxwé e jɛ nukɔn é nyí nǔmaɖinǔ ɔ, akpáxwé e bɔ d'ewu é nyí nǔmaɖinǔ e jɛ nukɔn é sín azɔn 3/// ɔ ɖ'ayǐ ɔ nɛ: enyi mɛ e ɖ'ayǐ ɔ nyí mɛ wè ɔ, mɛ e bɔ d'ewu ɔ nyí mɛ wè ɔ sín akpáxwé ɖokpo/// lee é nɔ nyí gbɔn é: bɛ́ nùxwɛ́ e nyí nùxwɛ́ ɖagbe é n. Enɛ ɔ́, è nɔ mɔ xókwin ɖokpo ɖokpo sín nùxwɛ́  ɔ mɛ./// Collatz sín nùxwlémɛ wɛ nyí nùxwlémɛ ɖò matimátikunmɛ e nɔ kàn nǔ e è ɖɔ é ɖé é ./// Nú è na w'azɔnkpɔnkpɔn ɖagbe n ɔ, lɛ́ kɔ́n vector e è ɖè lɛ́ɛ ɖó nùxwásúnnúmɛ e ɖò collatz sín nùxwásúnnu lɛ́ɛ é. /// >>> get_odd_collatz(5)
/// vec![1, 5]
fn get_odd_collatz(n: isize) -> Vec<isize> {
","fn get_odd_collatz(n: isize) -> Vec<isize> {
    let mut sequence = Vec::new();
    let mut current = n;

    while current != 1 {
        if current % 2 != 0 {
            sequence.push(current);
        }

        if current % 2 == 0 {
            current /= 2;
        } else {
            current = 3 * current + 1;
        }
    }
    
    // Add the final odd number 1 if n is 1
    sequence.push(1);

    sequence.sort();
    sequence
}

fn main() {
    let result = get_odd_collatz(5);
    println!(""{:?}"", result); // Outputs: [1, 5]
}","}

fn main() {
    let candidate = get_odd_collatz;
    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);
    assert_eq!(candidate(5), vec![1, 5]);
    assert_eq!(candidate(12), vec![1, 3, 5]);
    assert_eq!(candidate(1), vec![1]);
}
"
HumanEval_124,fon_Latn,rs,"/// 4. Azǎn ɔ ɖó na ɖò wuntun elɔ mɛ: mm-dd-yyyy /// 3. sun lɛ na nɔ hwe na 1 bo na nɔ syɛn na 12 ǎ.//Azǎn lɛ́ɛ kún ná dín dó azǎn 1 jí ó, é má lɛ́ hú azǎn 31 ó nú sun 1,3,5,7,8,10,12. Azǎn lɛ́ɛ kún ná dín dó azǎn 1 jí ó, é má lɛ́ hú azǎn 30 ó nú sun 4,6,9,11. Azǎn lɛ́ɛ kún ná dín dó azǎn 1 jí ó, é má lɛ́ hú azǎn 29 ó nú sun 2./// 1. Azǎn ɔ́ ɖò mɛ̀ ă./// Azǎn ɔ na nyí gbè ɖagbe nú è na bló nǔ e ɖò sɛ́n elɔ lɛ mɛ lɛ é bǐ: /// nɔ lɛ́ yí gbè nú nugbǒ nú azǎn ɔ́ sɔgbe é ɔ́, é nɔ lɛ́ yí gbè nú adingban. /// A na wlan azɔ̀ e na sɔ́ azǎn sín xɛ́n ɖé dó mɔ nǔ jɛ mɛ é ɖé bó ɖɔ /// >>> valid_date(String::from(""03-11-2000""))
/// true
/// >>> valid_date(String::from(""15-01-2012""))
/// false
/// >>> valid_date(String::from(""04-0-2040""))
/// false
/// >>> valid_date(String::from(""06-04-2020""))
/// true
/// >>> valid_date(String::from(""06/04/2020""))
/// false
fn valid_date(date: String) -> bool {
","fn valid_date(date: String) -> bool {
    if date.is_empty() {
        return false;
    }

    let parts: Vec<&str> = date.split('-').collect();
    if parts.len() != 3 {
        return false;
    }

    let maybe_month = parts[0].parse::<u32>();
    let maybe_day = parts[1].parse::<u32>();
    let maybe_year = parts[2].parse::<u32>();

    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {
        return false;
    }

    let month = maybe_month.unwrap();
    let day = maybe_day.unwrap();

    if month < 1 || month > 12 {
        return false;
    }

    match month {
        1 | 3 | 5 | 7 | 8 | 10 | 12 => {
            if day < 1 || day > 31 {
                return false;
            }
        }
        4 | 6 | 9 | 11 => {
            if day < 1 || day > 30 {
                return false;
            }
        }
        2 => {
            if day < 1 || day > 29 {
                return false;
            }
        }
        _ => return false, // This case should never be reached
    }

    true
}","}

fn main() {
    let candidate = valid_date;
    assert_eq!(candidate(String::from(""03-11-2000"")), true);
    assert_eq!(candidate(String::from(""15-01-2012"")), false);
    assert_eq!(candidate(String::from(""04-0-2040"")), false);
    assert_eq!(candidate(String::from(""06-04-2020"")), true);
    assert_eq!(candidate(String::from(""01-01-2007"")), true);
    assert_eq!(candidate(String::from(""03-32-2011"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""04-31-3000"")), false);
    assert_eq!(candidate(String::from(""06-06-2005"")), true);
    assert_eq!(candidate(String::from(""21-31-2000"")), false);
    assert_eq!(candidate(String::from(""04-12-2003"")), true);
    assert_eq!(candidate(String::from(""04122003"")), false);
    assert_eq!(candidate(String::from(""20030412"")), false);
    assert_eq!(candidate(String::from(""2003-04"")), false);
    assert_eq!(candidate(String::from(""2003-04-12"")), false);
    assert_eq!(candidate(String::from(""04-2003"")), false);
}
"
HumanEval_126,fon_Latn,rs,"/// Kpɔ́ndéwú ///number, return false. Nɔ sɔ́ nùxwɛ́ e nyí nùɖé ǎ lɛ́ɛ dó nùɖé ǎ, nú è na ɖɔ ɔ́, nùxwɛ́ e nyí nùɖé lɛ́ɛ kɛ́ɖɛ́ wɛ è na sɔ́ dó nùɖé lɛ́ɛ mɛ./// ɖò nǔ lɛ́ɛ jí./// Nú è na wèmá nú nùjlɛ́kpo ɖé ɔ́, è na lɛ́ yí nùjlɛ́kpo ɔ́ dó nú è ɖè lɛ́ɛ é alǒ è ma ɖè ǎ é./// >>> is_sorted(vec![5])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5])
/// false
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])
/// true
/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])
/// true
/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])
/// false
/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])
/// true
/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])
/// false
fn is_sorted(lst: Vec<isize>) -> bool {
","fn is_sorted(lst: Vec<isize>) -> bool {
    if lst.is_empty() || lst.len() == 1 {
        return true;
    }
    
    let mut previous = lst[0];
    let mut repeat_count = 0;

    for &current in &lst[1..] {
        if current < previous {
            return false;
        }
        if current == previous {
            repeat_count += 1;
            if repeat_count >= 2 {
                return false;
            }
        } else {
            repeat_count = 0;
        }
        previous = current;
    }

    true
}","}

fn main() {
    let candidate = is_sorted;
    assert_eq!(candidate(vec![5]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);
    assert_eq!(candidate(Vec::<isize>::new()), true);
    assert_eq!(candidate(vec![1]), true);
    assert_eq!(candidate(vec![3, 2, 1]), false);
    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);
    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);
    assert_eq!(candidate(vec![1, 2, 3, 4]), true);
}
"
HumanEval_127,fon_Latn,rs,"/// [kpɔnú/kpɔnú] kpɔ́n: /// Nú tɛnkpɔn wè lɛ ma ɖò nǔ ɖokpo ɔ mɛ ǎ ɔ, lɛ́ yí gbè nú ""ÉÒ""./// enyi é ma nyí mɔ̌ ǎ ɔ, lɛ́ kɔ nú ""ÉÒ""./// Nú wuntun ɔ sín hùn nyí nùjlɛ́jlɛ́ nukɔn nukɔntɔn ɔ, lɛ́ yí gbè nú ""YES"", /// e sín hùn nyí 1, bɔ é nyí nùjlɛ́kpo nukɔn nukɔntɔn ǎ é./// Kpɔ́ndéwú ɔ, tɛnkpɔn (1, 3), (2, 4) lɛ tɔn wɛ nyí (2, 3) /// intervals ɔ wɛ nyí nùjlɛ́nkpo nukɔntɔn ɖé. //azɔ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ̀ ɖɔ̀ we enɛ lɛ sín hùn wɛ nyí /// Ɖó tɛnkpɔn ɖokpo ɖokpo ɔ, è nɔ ɖi ɖɔ tɛnkpɔn ɔ sín bɛ́ wɛ nyí kpɛví alǒ cí fí e é wá yì é ɖɔhun./// é nɔ́ lɛ́ dó bǐbɛ́mɛ kpo vivɔ kpo./// Hweɖokpo e è na lɛ é kpo mɛ e è na lɛ é kpo ɖò xwi ɖí wɛ, enɛ wɛ nyí ɖɔ hweɖokpo ɔ (bɛ́, fó) /// fí e tɛnkpɔnmɛ ɖokpo ɖokpo nyí nùxwɛ́ ɔ́ wè é. Ɖɔ́nkpɔnmɛ = (bɛ́, fó) = (1, 2)./// È na we tɛn wè,/// >>> intersection((1, 2), (2, 3))
/// String::from(""NO"")
/// >>> intersection((-1, 1), (0, 4))
/// String::from(""NO"")
/// >>> intersection((-3, -1), (-5, 5))
/// String::from(""YES"")
fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {
    let (start1, end1) = interval1;
    let (start2, end2) = interval2;
    let start_intersection = std::cmp::max(start1, start2);
    let end_intersection = std::cmp::min(end1, end2);

    if start_intersection <= end_intersection {
        let length = (end_intersection - start_intersection + 1) as usize;
        if is_prime(length) {
            return String::from(""YES"");
        }
    }
    String::from(""NO"")
}

// Example usage
fn main() {
    println!(""{}"", intersection((1, 2), (2, 3))); // ""NO""
    println!(""{}"", intersection((-1, 1), (0, 4))); // ""NO""
    println!(""{}"", intersection((-3, -1), (-5, 5))); // ""YES""
}","}

fn main() {
    let candidate = intersection;
    assert_eq!(candidate((1, 2), (2, 3)), String::from(""NO""));
    assert_eq!(candidate((-1, 1), (0, 4)), String::from(""NO""));
    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(""YES""));
    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(""YES""));
    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (3, 5)), String::from(""NO""));
    assert_eq!(candidate((1, 2), (1, 2)), String::from(""NO""));
    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(""NO""));
}
"
HumanEval_128,fon_Latn,rs,"/// Kpɔ́n: /// Akpá: é na lɛ́ lɛ́ vɔ́ nǔɖé nú nùɖé ǎ./// nú nùxwásá ɖokpo ɖokpo ɖò vector ɔ mɛ, bo nɔte nú 1, -1 alǒ 0. /// nùjlɛ́kpo e è nɔ ylɔ́ ɖɔ nùjlɛ́kpá ɔ́ bǐ sín nùjlɛ́kpá e è nɔ ylɔ́ ɖɔ nǔjlɛ́kpá ɔ́ bǐ tɔn é sín nùjlɛ́kpá /// È na we vector arr nú nùxwlémɛ̀ lɛ́ɛ bɔ a ɖó na lɛ́ kɔ́n /// >>> prod_signs(vec![1, 2, 2, -4])
/// Some(9)
/// >>> prod_signs(vec![0, 1])
/// Some(0)
/// >>> prod_signs(vec![])
/// None
fn prod_signs(arr: Vec<isize>) -> Option<isize> {
","fn prod_signs(arr: Vec<isize>) -> Option<isize> {
    if arr.is_empty() {
        return None;
    }

    let mut sum_of_magnitudes = 0;
    let mut product_of_signs = 1;

    for &num in &arr {
        sum_of_magnitudes += num.abs();
        if num == 0 {
            product_of_signs = 0;
            break;
        } else if num > 0 {
            product_of_signs *= 1;
        } else {
            product_of_signs *= -1;
        }
    }

    Some(sum_of_magnitudes * product_of_signs)
}","}

fn main() {
    let candidate = prod_signs;
    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));
    assert_eq!(candidate(vec![0, 1]), Some(0));
    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));
    assert_eq!(candidate(Vec::<isize>::new()), None);
    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));
    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));
    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));
    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));
}
"
HumanEval_129,fon_Latn,rs,"/// Kpɔ́ndéwú: /// É nɔ́ lɛ́ yí nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ./// É ɖò dandan ɖɔ xósin ɔ na nyí ɖokpo./// lst_A[j] = lst_B[j]./// bɔ lst_A[i] < lst_B[i] bo nú j (1 <= j < i) ɔ mǐ ɖó /// hú lst_B, ɖò xó ɖevo mɛ ɔ, nùxwlé lɛ́ɛ ɖò nùxwlé lɛ́ɛ mɛ bɔ nùxwlé lɛ́ɛ nɔ́ nyí i (1 <= i <= k) /// gbɔn (mí na ylɔ ye ɖɔ lst_A kpo lst_B kpo), lst_A ɔ ɖ'emɛ ɖò xókwin mɛ /// ée è na bló nùxwásá lɛ́ɛ sín nùxwásá lɛ́ɛ ɖò xɔ lɛ́ɛ jí ɔ́, A kpo B kpo nɔ yì /// Ali e nyí A (e lín dó k é) ɔ nɔ vɛwǔ hú ali e nyí B (e lín dó k é) ɔ nú /// A SƆ́ na yì kpò ɖò fí e è nɔ mɔ nǔ ɖè é ǎ./// nɔ ɖó na ɖò vo)./// Mi nywɛ ɖɔ ali e nɔ ɖi ga k ɔ nɔ byɔ bo na yì bunɔ k (e nyí ɖɔ /// xɔ ɔ́. //ði xógbe ɖevo lɛ mɛ ɔ, a sixu yì nǔɖòɖó e nɔ ɖó xósusu xá we lɛ é mɛ./// sín xɔvi ɖokpo ɖokpo mɛ, bɔ ɖò ali ɖokpo ɖokpo mɛ ɔ a sixu yì xɔvi e ɖò tò ɔ kpá é ɖokpo ɖokpo mɛ, //A na mɔ ali e na nɔ nukɔn nú wezun e nyí k é ɖò xuxu ɔ mɛ.///inclusive nɔ tɔ́n azɔn ɖokpo ɖò xɔ lɛ́ɛ mɛ ɖò nùxwásá ɔ́ mɛ./// azinkpo ɖokpo ɖokpo ɖo xuxu ɔ mɛ. azin ɖokpo ɖokpo ɖo range [1, N * N] mɛ./// È na nùxwlé ɖé e ɖó xota N kpo kpo kpo kpo kpo kpo (N >= 2) bo ɖó nùjlɛ́kpá ɖagbe ɖé k ɔ, /// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)
/// vec![1, 2, 1]
/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)
/// vec![1]
fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
","fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {
    let n = grid.len();
    let mut best_path = vec![];
    let mut best_values = vec![isize::MAX; k as usize];
    
    fn dfs(
        grid: &Vec<Vec<isize>>, 
        row: usize, 
        col: usize, 
        path: &mut Vec<(usize, usize)>, 
        values: &mut Vec<isize>, 
        k: isize, 
        best_values: &mut Vec<isize>
    ) {
        if path.len() == k as usize {
            if values < best_values {
                best_values.clone_from(values);
            }
            return;
        }
        
        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];
        for &(dr, dc) in directions.iter() {
            let new_row = row as isize + dr;
            let new_col = col as isize + dc;
            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {
                path.push((new_row as usize, new_col as usize));
                values.push(grid[new_row as usize][new_col as usize]);
                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);
                values.pop();
                path.pop();
            }
        }
    }

    for r in 0..n {
        for c in 0..n {
            let mut path = vec![(r, c)];
            let mut values = vec![grid[r][c]];
            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);
        }
    }

    best_values
}","}

fn main() {
    let candidate = minPath;
    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);
    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);
    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);
    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);
    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);
    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);
    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);
    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}
"
HumanEval_130,fon_Latn,rs,"/// Kpɔ́ndéwú: /// nùxwlé nukɔntɔn n + 1 tɔn Tribonacci tɔn lɛ tɔn. /// È na mi nú nú númɛ̀ e nyí nùɖé ǎ é n, mi ɖó na lɛ́ yí vector ɔ sín nùɖé lɛ́ɛ./// = 2 + 3 + 3 = 8 ///tri(3) = tri(2) + tri(1) + tri(4) ///tri(4) = 3 ///tri(2) = 1 + (2 / 2) = 2 /// Cɔ́n kpɔ́n: ///tri(n) =tri(n - 1) +tri(n - 2) +tri(n + 1), enyi n nyí nùxwlé. ///tri{n} = 1 + n / 2, enyi n nyí mɛ wè.///tri(1) = 3 /// Tribonacci sín nùxwlé lɛ́ɛ nɔ́ nyí: //Amɔ̌, nǔ e mɛ lɛ ma tuùn ǎ ɔ wɛ nyí ɖɔ nǔ e è nɔ ylɔ ɖɔ Tribonacci sín nùɖé é.//Mɛ bǐ nɔ tuùn nǔ e è nɔ ylɔ ɖɔ fibonacci é, mɛ e nɔ kplɔ́n akɔnta lɛ é nɔ dó wuntun enɛ wu tawun ɖò xwè kanweko ɔ mɛ./// >>> tri(3)
/// vec![1, 3, 2, 8]
fn tri(n: isize) -> Vec<isize> {
","fn tri(n: isize) -> Vec<isize> {
    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {
        if n < memo.len() as isize {
            return memo[n as usize];
        }

        let result = if n == 1 {
            3
        } else if n % 2 == 0 {
            1 + n / 2
        } else {
            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)
        };

        if n as usize >= memo.len() {
            memo.resize(n as usize + 1, 0);
        }
        memo[n as usize] = result;
        result
    }

    let mut sequence = Vec::new();
    let mut memo = Vec::new();

    for i in 0..=n {
        sequence.push(tribonacci(i, &mut memo));
    }

    sequence
}","}

fn main() {
    let candidate = tri;
    assert_eq!(candidate(3), vec![1, 3, 2, 8]);
    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);
    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);
    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);
    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);
    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
    assert_eq!(candidate(0), vec![1]);
    assert_eq!(candidate(1), vec![1, 3]);
}
"
HumanEval_131,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// N'ɛ ɔ, nú xwɛ ɔ bǐ ɔ, é na lɛ́ lɛ́ nyí 0. /// Nú è na w'azɔnkpɔnkpɔn ɖagbe n ɔ, lɛ́ kɔ́n nùkwín w'azɔnkpɔnkpɔnkpɔn tɔn lɛ sín nǔkwín ɔ. /// >>> digits(1)
/// 1
/// >>> digits(4)
/// 0
/// >>> digits(235)
/// 15
fn digits(n: isize) -> isize {
","fn digits(n: isize) -> isize {
    let mut product = 1;
    let mut has_odd = false;
    let mut num = n;

    while num > 0 {
        let digit = num % 10;
        if digit % 2 != 0 {
            product *= digit;
            has_odd = true;
        }
        num /= 10;
    }

    if has_odd {
        product
    } else {
        0
    }
}

fn main() {
    println!(""{}"", digits(1));  // 1
    println!(""{}"", digits(4));  // 0
    println!(""{}"", digits(235)); // 15
}","}

fn main() {
    let candidate = digits;
    assert_eq!(candidate(5), 5);
    assert_eq!(candidate(54), 5);
    assert_eq!(candidate(120), 1);
    assert_eq!(candidate(5014), 5);
    assert_eq!(candidate(98765), 315);
    assert_eq!(candidate(5576543), 2625);
    assert_eq!(candidate(2468), 0);
}
"
HumanEval_132,fon_Latn,rs,"/// e mɛ nuɖevi ɖokpo ɖo nukun tɔn ɔ mɛ ɔ e nɔ nyi mɛ./// azɔ̀ ɔ́ ɖó ná lɛ́ kɔ́n true nú è mɔ̀ nú è mɔ̀ nú è mɔ̀ nú è mɔ̀ nú è mɔ̀ nú è mɔ̀ nú è mɔ nú è mɔ nú è mɔ nú è mɔ nú è mɔ nú è mɔ nú è mɔ nú è mɔ nú/// Wà azɔ̀ e nɔ yí xɛ̀n dó nǔ e mɛ è nɔ sɔ́ akpàkpà lɛ́ɛ dó é mɛ é./// >>> is_nested(String::from(""[[]]""))
/// true
/// >>> is_nested(String::from(""[]]]]]]][[[[[]""))
/// false
/// >>> is_nested(String::from(""[][]""))
/// false
/// >>> is_nested(String::from(""[]""))
/// false
/// >>> is_nested(String::from(""[[][]]""))
/// true
/// >>> is_nested(String::from(""[[]][[""))
/// true
fn is_nested(string: String) -> bool {
","fn is_nested(string: String) -> bool {
    let mut stack = Vec::new();
    let mut nested = false;

    for bracket in string.chars() {
        if bracket == '[' {
            stack.push(bracket);
        } else if bracket == ']' {
            if let Some(_) = stack.pop() {
                if !stack.is_empty() {
                    nested = true;
                }
            } else {
                return false;
            }
        }
    }

    nested
}

fn main() {
    println!(""{}"", is_nested(String::from(""[[]]""))); // true
    println!(""{}"", is_nested(String::from(""[]]]]]]][[[[[]""))); // false
    println!(""{}"", is_nested(String::from(""[][]""))); // false
    println!(""{}"", is_nested(String::from(""[]""))); // false
    println!(""{}"", is_nested(String::from(""[[][]]""))); // true
    println!(""{}"", is_nested(String::from(""[[]][[""))); // true
}","}

fn main() {
    let candidate = is_nested;
    assert_eq!(candidate(String::from(""[[]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]][[[[[]"")), false);
    assert_eq!(candidate(String::from(""[][]"")), false);
    assert_eq!(candidate(String::from(""[]"")), false);
    assert_eq!(candidate(String::from(""[[[[]]]]"")), true);
    assert_eq!(candidate(String::from(""[]]]]]]]]]]"")), false);
    assert_eq!(candidate(String::from(""[][][[]]"")), true);
    assert_eq!(candidate(String::from(""[[]"")), false);
    assert_eq!(candidate(String::from(""[]]"")), false);
    assert_eq!(candidate(String::from(""[[]][["")), true);
    assert_eq!(candidate(String::from(""[[][]]"")), true);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""[[[[[[[["")), false);
    assert_eq!(candidate(String::from(""]]]]]]]]"")), false);
}
"
HumanEval_133,fon_Latn,rs,"/// Kpɔ́ndéwú: /// kpò nǔ lɛ́ɛ bǐ dó xù ɔ́ jí hwɛ̌.//A na lɛ́ yí nùjlɛ́kpo e è sɔ́ dó zɔ́n amyɔxwé nú nùjlɛ́kpo e ɖò vectɔ́ ɔ́ mɛ é sín nùjlɛ́kpo lɛ́ɛ sín nùjlɛ́kpo lɛ́ɛ./// È na mi nùxwlé lɛ sín vectɔ́ ɖé./// >>> lst(vec![1.0, 2.0, 3.0])
/// 14
/// >>> lst(vec![1.0, 4.0, 9.0])
/// 98
/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])
/// 84
/// >>> lst(vec![1.4, 4.2, 0.0])
/// 29
/// >>> lst(vec![-2.4, 1.0, 1.0])
/// 6
fn sum_squares(lst: Vec<f64>) -> isize {
","fn sum_squares(lst: Vec<f64>) -> isize {
    lst.iter()
        .map(|&x| x.ceil() as isize)  // Round each element to the nearest upper integer
        .map(|x| x * x)               // Square each element
        .sum()                        // Sum all the squared elements
}

fn main() {
    println!(""{}"", sum_squares(vec![1.0, 2.0, 3.0])); // 14
    println!(""{}"", sum_squares(vec![1.0, 4.0, 9.0])); // 98
    println!(""{}"", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); // 84
    println!(""{}"", sum_squares(vec![1.4, 4.2, 0.0])); // 29
    println!(""{}"", sum_squares(vec![-2.4, 1.0, 1.0])); // 6
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);
    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);
    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);
    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);
    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);
    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);
    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);
    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
    assert_eq!(candidate(vec![0.0]), 0);
    assert_eq!(candidate(vec![-1.0]), 1);
    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);
}
"
HumanEval_134,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Nùjlɛ́n: ""gbe"" ɔ́' wuntun lɛ́ɛ sín nùɖé wɛ bɔ̀ è nɔ ɖó tɛn ɖò ye mɛ̀./// nǔ e ɖò xógbe ɖé mɛ é ɖé wɛ, bɔ nǔ e ɖò xógbe ɔ mɛ é bǐ nyí nǔvú./// nú wuntun ɖé ɔ wuntun alɛ́fébiti tɔn wɛ bɔ é nyí  ǎ/// Wǎ azɔ̀n e na lɛ́ yí gbè nú true nú wuntun gudo tɔn ɔ́ nyí /// >>> check_if_last_char_is_a_letter(String::from(""apple pie""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e""))
/// true
/// >>> check_if_last_char_is_a_letter(String::from(""apple pi e ""))
/// false
/// >>> check_if_last_char_is_a_letter(String::from(""""))
/// false
fn check_if_last_char_is_a_letter(txt: String) -> bool {
","fn check_if_last_char_is_a_letter(txt: String) -> bool {
    if let Some(c) = txt.trim().chars().rev().next() {
        if c.is_alphabetic() {
            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {
                return !prev_char.is_alphabetic();
            }
        }
    }
    false
}

fn main() {
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pie"")));  // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e""))); // true
    println!(""{}"", check_if_last_char_is_a_letter(String::from(""apple pi e ""))); // false
    println!(""{}"", check_if_last_char_is_a_letter(String::from("""")));           // false
}","}

fn main() {
    let candidate = check_if_last_char_is_a_letter;
    assert_eq!(candidate(String::from(""apple"")), false);
    assert_eq!(candidate(String::from(""apple pi e"")), true);
    assert_eq!(candidate(String::from(""eeeee"")), false);
    assert_eq!(candidate(String::from(""A"")), true);
    assert_eq!(candidate(String::from(""Pumpkin pie "")), false);
    assert_eq!(candidate(String::from(""Pumpkin pie 1"")), false);
    assert_eq!(candidate(String::from("""")), false);
    assert_eq!(candidate(String::from(""eeeee e "")), false);
    assert_eq!(candidate(String::from(""apple pie"")), false);
    assert_eq!(candidate(String::from(""apple pi e "")), false);
}
"
HumanEval_135,fon_Latn,rs,"/// Kpɔ́ndéwú: /// nùɖé lɛ́ ɖò mɛ wè./// nú nǔ enɛ ɖě ma ɖò ǎ ɔ, é na lɛ́ kɔ́n -1./// nɔ nyi alo nɔ nyi ɖokpo ɔ kpodo nǔɖe nɔ jɛ nukɔn na e tlolo kpo ǎ./// Wà azɔ̀ e nɔ lɛ́ lɛ́ sín nǔɖókpɔ́ ɖaxó ɖé sín nǔɖókpɔ́ e nyí /// >>> can_arrange(vec![1, 2, 4, 3, 5])
/// 3
/// >>> can_arrange(vec![1, 2, 3])
/// -1
fn can_arrange(arr: Vec<isize>) -> isize {
","fn can_arrange(arr: Vec<isize>) -> isize {
    for i in (1..arr.len()).rev() {
        if arr[i] < arr[i - 1] {
            return i as isize;
        }
    }
    -1
}

// Example usage:
// fn main() {
//     println!(""{}"", can_arrange(vec![1, 2, 4, 3, 5])); // Outputs: 3
//     println!(""{}"", can_arrange(vec![1, 2, 3])); // Outputs: -1
// }","}

fn main() {
    let candidate = can_arrange;
    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);
    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);
    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);
    assert_eq!(candidate(Vec::<isize>::new()), -1);
}
"
HumanEval_136,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Nú nùɖé ma ɖò nùɖé jí ǎ ɔ, è na lɛ́ sɔ́ nùɖé ǎ./// nú è na mɔ nùxwlémɛ e ɖò vectɔ́ ɖé mɛ lɛ é./// ɔ wɛ nyí nùxwléma ɖaxó hugǎn ɖò nùxwléma e nyí nǔmasɔgbe lɛ é mɛ, bɔ 'b' ɔ wɛ nyí nùxwléma e nyí nǔmasɔgbe lɛ é mɛ /// Wà azɔ̀ e nɔ lɛ́ yí nùɖé lɛ́ɛ sín nùɖé lɛ́ɛ (a, b), fí e 'a' nyí /// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])
/// (None, Some(1))
/// >>> largest_smallest_integers(vec![])
/// (None, None)
/// >>> largest_smallest_integers(vec![0])
/// (None, None)
fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
","fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {
    let mut largest_negative: Option<isize> = None;
    let mut smallest_positive: Option<isize> = None;

    for &num in &lst {
        if num < 0 {
            largest_negative = match largest_negative {
                Some(largest) => Some(largest.max(num)),
                None => Some(num),
            };
        } else if num > 0 {
            smallest_positive = match smallest_positive {
                Some(smallest) => Some(smallest.min(num)),
                None => Some(num),
            };
        }
    }

    (largest_negative, smallest_positive)
}

fn main() {
    println!(""{:?}"", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); // (None, Some(1))
    println!(""{:?}"", largest_smallest_integers(vec![])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![0])); // (None, None)
    println!(""{:?}"", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); // (Some(-1), Some(2))
}","}

fn main() {
    let candidate = largest_smallest_integers;
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));
    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));
    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));
    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));
    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));
    assert_eq!(candidate(Vec::<isize>::new()), (None, None));
    assert_eq!(candidate(vec![0]), (None, None));
    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));
    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));
    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));
    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));
}
"
HumanEval_138,fon_Latn,rs,"/// Kpɔ́ndéwú /// Nɔ kpɔ́n ɖɔ nùjlɛ́kpo n e è na lɛ́ ná é sixu nyí nùjlɛ́kpo e è na wlan dó nùjlɛ́kpo e nyí nùjlɛ́kpo è è ná lɛ́ ɖó é 4 jí é /// >>> is_equal_to_sum_even(4)
/// false
/// >>> is_equal_to_sum_even(6)
/// false
/// >>> is_equal_to_sum_even(8)
/// true
fn is_equal_to_sum_even(n: isize) -> bool {
","fn is_equal_to_sum_even(n: isize) -> bool {
    // A number n can be expressed as the sum of 4 positive even numbers if and only if
    // it is greater than or equal to 8 and even
    n >= 8 && n % 2 == 0
}

// Test cases
fn main() {
    println!(""{}"", is_equal_to_sum_even(4));  // false
    println!(""{}"", is_equal_to_sum_even(6));  // false
    println!(""{}"", is_equal_to_sum_even(8));  // true
}","}

fn main() {
    let candidate = is_equal_to_sum_even;
    assert_eq!(candidate(4), false);
    assert_eq!(candidate(6), false);
    assert_eq!(candidate(8), true);
    assert_eq!(candidate(10), true);
    assert_eq!(candidate(11), false);
    assert_eq!(candidate(12), true);
    assert_eq!(candidate(13), false);
    assert_eq!(candidate(16), true);
}
"
HumanEval_139,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// fí e n > 0 ɖè é /// brazilian_factorial{n) = n! * (n-1)! * (n-2)! * ... * 1! /// Brazil tɔn ɔ è nɔ ɖɔ ɖɔ: /// >>> special_factorial(4)
/// 288
/// The function will receive an integer as input and should return the special
/// factorial of this integer.
fn special_factorial(n: isize) -> isize {
","fn factorial(n: isize) -> isize {
    (1..=n).product()
}

fn special_factorial(n: isize) -> isize {
    (1..=n).map(factorial).product()
}

fn main() {
    let result = special_factorial(4);
    println!(""{}"", result);
}","}

fn main() {
    let candidate = special_factorial;
    assert_eq!(candidate(4), 288);
    assert_eq!(candidate(5), 34560);
    assert_eq!(candidate(7), 125411328000);
    assert_eq!(candidate(1), 1);
}
"
HumanEval_140,fon_Latn,rs,"/// bo sɔ́ -  dó ɖyɔ́ tɛn e ɖò lɛ́ɛ bǐ/// bo enyi xwɛ ɖokpo ɔ ɖó tɛn e nɔ lɛ́ zɔ́n yeɖee lɛ́ɛ hú we ɔ, /// Nú è na wlan wuntun ɔ ɔ, è na sɔ́ wuntun e ɖò glɔ́ lɛ́ɛ dó ɖyɔ́ wuntun e ɖò gudo lɛ́ɛ bǐ, /// >>> fix_spaces(String::from("" Example""))
/// String::from(""Example"")
/// >>> fix_spaces(String::from("" Example 1""))
/// String::from(""Example_1"")
/// >>> fix_spaces(String::from("" Example 2""))
/// String::from(""_Example_2"")
/// >>> fix_spaces(String::from("" Example 3""))
/// String::from(""_Example-3"")
fn fix_spaces(text: String) -> String {
","fn fix_spaces(text: String) -> String {
    let mut result = String::new();
    let mut space_count = 0;

    for c in text.chars() {
        if c == ' ' {
            space_count += 1;
        } else {
            if space_count > 2 {
                result.push('-');
            } else if space_count > 0 {
                result.push_str(&""_"".repeat(space_count));
            }
            result.push(c);
            space_count = 0;
        }
    }

    if space_count > 2 {
        result.push('-');
    } else if space_count > 0 {
        result.push_str(&""_"".repeat(space_count));
    }
    
    result
}","}

fn main() {
    let candidate = fix_spaces;
    assert_eq!(candidate(String::from(""Example"")), String::from(""Example""));
    assert_eq!(candidate(String::from(""Mudasir Hanif "")), String::from(""Mudasir_Hanif_""));
    assert_eq!(candidate(String::from(""Yellow Yellow  Dirty  Fellow"")), String::from(""Yellow_Yellow__Dirty__Fellow""));
    assert_eq!(candidate(String::from(""Exa   mple"")), String::from(""Exa-mple""));
    assert_eq!(candidate(String::from(""   Exa 1 2 2 mple"")), String::from(""-Exa_1_2_2_mple""));
}
"
HumanEval_141,fon_Latn,rs,"/// Kpɔ́ndéwú: /// - Hwe e ɖò dot ɔ gudo é ɖó na nyí ɖokpo ɖò elɔ lɛ mɛ: ['txt', 'exe', 'dll'] /// alɛpátín latín tɔn ɔ ('a'-'z' kpo 'A'-'Z') /// - Wema e ɖò dot ɔ nukɔn ɔ ɖó na nyí nǔtí ǎ, bɔ é ka na bɛ́ ɖò wèmá  tɔn jí./// - Nùnina ɔ sín nyikɔ ɔ ɖ'akpá ɖokpo '.' /// - Nùnina ɔ ɖó na nyí nùɖé hú nùɖé atɔn ǎ ('0'-'9') ɖò nùɖé lɛ mɛ. /// è kpé: /// È nɔ ɖɔ ɖɔ nùwlanwlan ɔ sɔgbe nú nǔ e ɖò d'ewu lɛ é bǐ /// 'Ɛɛn' nú nyikɔ ɔ sɔgbe, bo na lɛ́ lɛ́ yí gbè nú 'Ée' nú é ma sɔgbe ǎ./// Zɔ̀ nùɖé e nɔ yí nùkwín e nɔ ɖè nùkínnúmɛ ɔ sín nyikɔ xlɛ́ é bo nɔ lɛ́ lɛ́ kɔ́n /// >>> file_name_check(String::from(""example.txt""))
/// String::from(""Yes"")
/// >>> file_name_check(String::from(""1example.dll""))
/// String::from(""No"")
fn file_name_check(file_name: String) -> String {
","fn file_name_check(file_name: String) -> String {
    let parts: Vec<&str> = file_name.split('.').collect();

    if parts.len() != 2 {
        return String::from(""No"");
    }

    let before_dot = parts[0];
    let after_dot = parts[1];

    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {
        return String::from(""No"");
    }

    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();
    if digit_count > 3 {
        return String::from(""No"");
    }

    match after_dot {
        ""txt"" | ""exe"" | ""dll"" => String::from(""Yes""),
        _ => String::from(""No""),
    }
}","}

fn main() {
    let candidate = file_name_check;
    assert_eq!(candidate(String::from(""example.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1example.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s1sdf3.asd"")), String::from(""No""));
    assert_eq!(candidate(String::from(""K.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""MY16FILE3.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""His12FILE94.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_Y.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""?aREYA.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""/this_is_valid.dll"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.wow"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_valid.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""this_is_valid.txtexe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""#this2_i4s_5valid.ten"")), String::from(""No""));
    assert_eq!(candidate(String::from(""@this1_is6_valid.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""this_is_12valid.6exe4.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""all.exe.txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_No.exe"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""Is3youfault.txt"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""no_one#knows.dll"")), String::from(""Yes""));
    assert_eq!(candidate(String::from(""1I563_Yes3.exe"")), String::from(""No""));
    assert_eq!(candidate(String::from(""I563_Yes3.txtt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final..txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""final132"")), String::from(""No""));
    assert_eq!(candidate(String::from(""_f4indsartal132."")), String::from(""No""));
    assert_eq!(candidate(String::from("".txt"")), String::from(""No""));
    assert_eq!(candidate(String::from(""s."")), String::from(""No""));
}
"
HumanEval_142,fon_Latn,rs,"/// Kpɔ́ndéwú: /// ɖyɔ́ nǔ e ɖò vector ɔ mɛ lɛ́ɛ e sín nǔ lɛ́ɛ ma nyí 3 alǒ 4 sín nǔɖɔɖókpɔ́ ǎ é. Azɔ̌ ɔ na lɛ́ lɛ́ kɔ nú nǔ e ɖò vector ɔ mɛ lɛ́ɛ bǐ./// èíòåðíåò 3 è áóäåò ðàñïðîñòðàíÿòü ïîëîâîé íîìåð, åñëè åãî èíòåðíåò-ñõåìà áóäåò ðàñïðîñòðàíÿòüñÿ íà 4 è íå íà 3./// azɔ̀ élɔ́ ná yí nùxwlé lɛ́ɛ sín nùxwlé ɖé. nú nùxwlé lɛ́ɛ bǐ ɔ́, azɔ̀ ɔ́ na sɔ́ nùxwlé lɛ́ɛ sín nùxwlé ɔ́ sín alɔgwé ɖó wè jí nú nùxwlé ɔ́ sín alɔgwé nyí a./// "" /// >>> lst
/// vec![1, 2, 3]
/// >>> lst
/// vec![]
/// >>> lst
/// vec![-1, -5, 2, -1, -5]
fn sum_squares(lst: Vec<isize>) -> isize {
","fn sum_squares(lst: Vec<isize>) -> isize {
    lst.into_iter()
        .enumerate()
        .map(|(i, value)| {
            if i % 3 == 0 {
                value * value
            } else if i % 4 == 0 {
                value * value * value
            } else {
                value
            }
        })
        .sum()
}

fn main() {
    let lst = vec![1, 2, 3];
    println!(""{}"", sum_squares(lst)); // Outputs: 14

    let lst = vec![];
    println!(""{}"", sum_squares(lst)); // Outputs: 0

    let lst = vec![-1, -5, 2, -1, -5];
    println!(""{}"", sum_squares(lst)); // Outputs: 112
}","}

fn main() {
    let candidate = sum_squares;
    assert_eq!(candidate(vec![1, 2, 3]), 6);
    assert_eq!(candidate(vec![1, 4, 9]), 14);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);
    assert_eq!(candidate(vec![0]), 0);
    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);
    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);
    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);
    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);
}
"
HumanEval_143,fon_Latn,rs,"//Kpɔ́nmɛ 1: /// xókwin lɛ́ɛ ɖò wuntun yɔyɔ́ ɔ́ mɛ́ ɖó ná cí xókwin nukɔntɔn ɔ́ ɖɔhun./// e sín hùn nyí nùxwásúnxó lɛ é, /// bo na lɛ́ lɛ́ yí wuntun e mɛ xógbe e ɖò xota ɔ mɛ lɛ́ɛ ɖè é,/// xógbe ɖé lɛ ɖò xota ɔ mɛ bɔ è nɔ ɖó ganmɛ ɖò ye tɛntin, /// È na wuntun e nɔte nú xógbe ɖé we, /// >>> words_in_sentence(String::from(""This is a test""))
/// String::from(""is"")
/// Example 2:
/// >>> words_in_sentence(String::from(""lets go for swimming""))
/// String::from(""go for"")
/// Constraints:
/// * 1 <= len(sentence) <= 100
/// * sentence contains only letters
fn words_in_sentence(sentence: String) -> String {
","fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

fn words_in_sentence(sentence: String) -> String {
    let words: Vec<&str> = sentence.split_whitespace().collect();
    let prime_length_words: Vec<&str> = words
        .iter()
        .filter(|&&word| is_prime(word.len()))
        .cloned()
        .collect();
    prime_length_words.join("" "")
}

fn main() {
    assert_eq!(
        words_in_sentence(String::from(""This is a test"")),
        String::from(""is"")
    );
    assert_eq!(
        words_in_sentence(String::from(""lets go for swimming"")),
        String::from(""go for"")
    );
}","}

fn main() {
    let candidate = words_in_sentence;
    assert_eq!(candidate(String::from(""This is a test"")), String::from(""is""));
    assert_eq!(candidate(String::from(""lets go for swimming"")), String::from(""go for""));
    assert_eq!(candidate(String::from(""there is no place available here"")), String::from(""there is no place""));
    assert_eq!(candidate(String::from(""Hi I am Hussein"")), String::from(""Hi am Hussein""));
    assert_eq!(candidate(String::from(""go for it"")), String::from(""go for it""));
    assert_eq!(candidate(String::from(""here"")), String::from(""""));
    assert_eq!(candidate(String::from(""here is"")), String::from(""is""));
}
"
HumanEval_144,fon_Latn,rs,"/// A sixu ɖɔ ɖɔ x, kpo n kpo ɔ nuvò e jɛxa lɛ wɛ bo ma ɖó nuvɔ́ dó nuvò mɛ ǎ./// <numerator>/<denominator> fí e nùxwlátɔ́ kpo mɛ̀tɔ́tɔ́ ɔ́ kpó nyí nùxwlátɔ́ e nyí nùjlɛ́n ɖagbe lɛ é./// àëëè. x kpo n kpo we lɛ bǐ wɛ nyí nùjlɛdonǔwu nùɖé tɔn, bɔ ye ɖó wuntun elɔ: /// x * n. Function ɔ na lɛ́ kɔ́n true nú x * n nɔ́ nyí nùjlɔ́mε ɔ́' bo nɔ́ nyí false //azɔ̀ towe wɛ nyí ɖɔ nà bló azɔ̀ e ná bló bɔ xógbe ɔ na nyí nǔtí ǎ é ɖé é/// >>> simplify(String::from(""1/5""), String::from(""5/1""))
/// true
/// >>> simplify(String::from(""1/6""), String::from(""2/1""))
/// false
/// >>> simplify(String::from(""7/10""), String::from(""10/2""))
/// false
fn simplify(x: String, n: String) -> bool {
","fn gcd(a: u32, b: u32) -> u32 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

fn simplify(x: String, n: String) -> bool {
    let x_parts: Vec<&str> = x.split('/').collect();
    let n_parts: Vec<&str> = n.split('/').collect();
    
    let x_num: u32 = x_parts[0].parse().unwrap();
    let x_den: u32 = x_parts[1].parse().unwrap();
    let n_num: u32 = n_parts[0].parse().unwrap();
    let n_den: u32 = n_parts[1].parse().unwrap();
    
    let result_num = x_num * n_num;
    let result_den = x_den * n_den;
    
    let gcd_value = gcd(result_num, result_den);
    
    result_den / gcd_value == 1
}","}

fn main() {
    let candidate = simplify;
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/6""), String::from(""2/1"")), false);
    assert_eq!(candidate(String::from(""5/1""), String::from(""3/1"")), true);
    assert_eq!(candidate(String::from(""7/10""), String::from(""10/2"")), false);
    assert_eq!(candidate(String::from(""2/10""), String::from(""50/10"")), true);
    assert_eq!(candidate(String::from(""7/2""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""11/6""), String::from(""6/1"")), true);
    assert_eq!(candidate(String::from(""2/3""), String::from(""5/2"")), false);
    assert_eq!(candidate(String::from(""5/2""), String::from(""3/5"")), false);
    assert_eq!(candidate(String::from(""2/4""), String::from(""8/4"")), true);
    assert_eq!(candidate(String::from(""2/4""), String::from(""4/2"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""5/1"")), true);
    assert_eq!(candidate(String::from(""1/5""), String::from(""1/5"")), false);
}
"
HumanEval_145,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// ɖè ye ɖó nùtínmɛ yetɔn ɖò nùjlɛ́jlɛ́jlɛ́jlɛ́jlɛ́jlɛ́jlɛ́jlɛ́jlɛ́./// Nukúnmɛ: enyi nùɖé lɛ́ ɖò wuntun ɔ́ mɛ bɔ nùjlɛ́kpo yetɔn lɛ́ɛ sín nǔ e cí ɖokpo ɔ é ɔ́, /// ɖò nùxwásá jí ɖò nùxwásá jí ɖò nùxwásá jí./// Wlǎn nùɖé e nɔ ɖè nùjlɛ́nmɛ e è ná lɛ́ ná é sín nùjlɛ́nmɛ /// >>> order_by_points(vec![1, 11, -1, -11, -12])
/// vec![-1, -11, 1, -12, 11]
/// >>> order_by_points(vec![])
/// Vec::<isize>::new()
fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
","fn order_by_points(nums: Vec<isize>) -> Vec<isize> {
    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();

    nums_with_indices.sort_by_key(|&(num, index)| {
        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();
        (sum_of_digits, index)
    });

    nums_with_indices.iter().map(|&(num, _)| num).collect()
}

fn main() {
    // Example usage
    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);
    println!(""{:?}"", sorted); // Output: [-1, -11, 1, -12, 11]
}","}

fn main() {
    let candidate = order_by_points;
    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);
    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());
    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);
}
"
HumanEval_146,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// nùxwásún nukɔntɔn ɔ kpo gudo tɔn ɔ kpo nyí nùxwásún e nyí nǔ ɖokpo é (1, 3, 5, 7, 9)./// nùxíxo nǔɖe ɖò vector ɔ mɛ e hú 10 bo lɛ́ ɖò wè lɛ́ɛ mɛ é /// Wlǎn nùjlɛ́n e nɔ yí nùjlɛ́n lɛ sín wektɔ́ ɖé dó mɛ bo nɔ lɛ́ lɛ́ kɔ́n é /// >>> specialFilter(vec![15, -73, 14, -15])
/// 1
/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])
/// 2
fn specialFilter(nums: Vec<isize>) -> isize {
","fn specialFilter(nums: Vec<isize>) -> isize {
    nums.into_iter().filter(|&num| {
        let abs_num = num.abs();
        abs_num > 10 && {
            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();
            let first_digit = digits.first().unwrap();
            let last_digit = digits.last().unwrap();
            first_digit % 2 == 1 && last_digit % 2 == 1
        }
    }).count() as isize
}

// Example usage:
// fn main() {
//     let result1 = specialFilter(vec![15, -73, 14, -15]);
//     println!(""{}"", result1); // Output: 1

//     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);
//     println!(""{}"", result2); // Output: 2
// }","}

fn main() {
    let candidate = specialFilter;
    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);
    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);
    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);
    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);
    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);
    assert_eq!(candidate(vec![1]), 0);
    assert_eq!(candidate(Vec::<isize>::new()), 0);
}
"
HumanEval_147,fon_Latn,rs,"/// Kpɔ́ndéwú: /// bo a[i] + a[j] + a[k] nyí nùɖé bɔ è nɔ mlɛ́ 3 é. /// Ðèñóéò ÷èñëî òðåõíîòíûõ (a[i], a[j], a[k]) áàêà, â êîòîðîì i < j < k, /// Bo na mɛ ɖokpo ɖokpo i (1 ≤ i ≤ n) ɔ, akwɛ a[i] = i * i - i + 1. /// È na mi xwɛ́ nú nùjlɔ́mɛnu e nyí nùjlɔ́mɛnu ɖagbe é n. Mi ɖó na bló nùjlɔ́mɛnu vector a tɔn e nyí n tɔn é. /// >>> get_max_triples(5)
/// 1
/// Explanation: 
/// a = [1, 3, 7, 13, 21]
/// The only valid triple is (1, 7, 13).
fn get_max_triples(n: isize) -> isize {
","fn get_max_triples(n: isize) -> isize {
    let mut a = Vec::new();
    for i in 1..=n {
        a.push(i * i - i + 1);
    }
    
    let mut count = 0;
    for i in 0..n {
        for j in i+1..n {
            for k in j+1..n {
                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {
                    count += 1;
                }
            }
        }
    }
    count
}

fn main() {
    println!(""{}"", get_max_triples(5)); // Output: 1
}","}

fn main() {
    let candidate = get_max_triples;
    assert_eq!(candidate(5), 1);
    assert_eq!(candidate(6), 4);
    assert_eq!(candidate(10), 36);
    assert_eq!(candidate(100), 53361);
}
"
HumanEval_149,fon_Latn,rs,"/// Cɔ́n kpɔ́n: //A sixu lin ɖɔ xógbe lɛ bǐ na ɖó ganxixo ɖokpo ɔ./// azɔ̀ ɔ́ ɖó na lɛ́ kɔ̀n wèmá wèmá ɖé lɛ́ɛ ɖò tito jí. /// Nú xókwin wè lɛ́ ɖó wuntun ɖokpo ɔ ɔ́, bo ɖ'acɛ nú vector ɔ́ ɖò alɛ́bwé jí./// ɖó na lɛ́ kɔ́n vector e è ɖè ɖó alɔkpa mɛ gbɔn acɛkpikpa enɛ mɛ é. /// Nǔ e è na wlan dó wèmá ɔ́ jí ɔ́ ɖó na nɔ jɛ jǐ ɖò xókwin ɖokpo ɖokpo sín wuntun jí, bɔ mi na nɔ ɖɔ./// bo sixu ɖó wema e nɔ lɛ́ nyí ɖokpo é./// Vector ɔ nɔ nyí vector nùxixa tɔn tɛgbɛ bo nɔ nyí vector nùxwɛ tɔn tɛgbɛ ǎ, /// bo na lɛ́ na nùxwlévéktɔ́ e è mɔ é ɖò tito jí, /// nɔ ɖe wuntun e nɔ ɖó wuntun e nɔ nyí nǔ ɖokpo lɛ é sín wuntun ɔ mɛ, /// Wlǎn azɔ̀ e nɔ yí gbè nú nùjlɛ́jlɛ́ sín nùjlɛ́jlɛ́ ɖé dó nùjlɛ́jlɛ́ tɔn jí é, /// >>> list_sort(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")])
/// vec![String::from(""aa"")]
/// >>> list_sort(vec![String::from(""ab""), String::from(""a""), String::from(""aaa""), String::from(""cd"")])
/// vec![String::from(""ab""), String::from(""cd"")]
fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
","fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {
    let mut even_length_strings: Vec<String> = lst
        .into_iter()
        .filter(|s| s.len() % 2 == 0)
        .collect();
    
    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));
    
    even_length_strings
}

fn main() {
    let result = sorted_list_sum(vec![
        String::from(""aa""),
        String::from(""a""),
        String::from(""aaa""),
    ]);
    println!(""{:?}"", result); // Should print: [""aa""]

    let result = sorted_list_sum(vec![
        String::from(""ab""),
        String::from(""a""),
        String::from(""aaa""),
        String::from(""cd""),
    ]);
    println!(""{:?}"", result); // Should print: [""ab"", ""cd""]
}","}

fn main() {
    let candidate = sorted_list_sum;
    assert_eq!(candidate(vec![String::from(""aa""), String::from(""a""), String::from(""aaa"")]), vec![String::from(""aa"")]);
    assert_eq!(candidate(vec![String::from(""school""), String::from(""AI""), String::from(""asdf""), String::from(""b"")]), vec![String::from(""AI""), String::from(""asdf""), String::from(""school"")]);
    assert_eq!(candidate(vec![String::from(""d""), String::from(""b""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""d""), String::from(""dcba""), String::from(""abcd""), String::from(""a"")]), vec![String::from(""abcd""), String::from(""dcba"")]);
    assert_eq!(candidate(vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]), vec![String::from(""AI""), String::from(""ai""), String::from(""au"")]);
    assert_eq!(candidate(vec![String::from(""a""), String::from(""b""), String::from(""b""), String::from(""c""), String::from(""c""), String::from(""a"")]), Vec::<String>::new());
    assert_eq!(candidate(vec![String::from(""aaaa""), String::from(""bbbb""), String::from(""dd""), String::from(""cc"")]), vec![String::from(""cc""), String::from(""dd""), String::from(""aaaa""), String::from(""bbbb"")]);
}
"
HumanEval_150,fon_Latn,rs,"/// Kpɔ́ndéwú: /// nùxwásá númɛ́gɔ́ tɔn ɖé wɛ bɔ é ɖó na lɛ́ lɛ́ yí nùxwásá y tɔn dó nùxwásá ɖevo mɛ./// Nùkplɔnmɛ kpò e na lɛ́ yí x tɔn dó nú n nyí /// >>> x_or_y(7, 34, 12)
/// 34
/// >>> x_or_y(15, 8, 5)
/// 5
fn x_or_y(n: isize, x: isize, y: isize) -> isize {
","fn x_or_y(n: isize, x: isize, y: isize) -> isize {
    fn is_prime(num: isize) -> bool {
        if num <= 1 {
            return false;
        }
        for i in 2..=((num as f64).sqrt() as isize) {
            if num % i == 0 {
                return false;
            }
        }
        true
    }
    
    if is_prime(n) {
        x
    } else {
        y
    }
}

fn main() {
    println!(""{}"", x_or_y(7, 34, 12)); // Output: 34
    println!(""{}"", x_or_y(15, 8, 5)); // Output: 5
}","}

fn main() {
    let candidate = x_or_y;
    assert_eq!(candidate(7, 34, 12), 34);
    assert_eq!(candidate(15, 8, 5), 5);
    assert_eq!(candidate(3, 33, 5212), 33);
    assert_eq!(candidate(1259, 3, 52), 3);
    assert_eq!(candidate(7919, -1, 12), -1);
    assert_eq!(candidate(3609, 1245, 583), 583);
    assert_eq!(candidate(91, 56, 129), 129);
    assert_eq!(candidate(6, 34, 1234), 1234);
    assert_eq!(candidate(1, 2, 0), 0);
    assert_eq!(candidate(2, 2, 0), 2);
}
"
HumanEval_151,fon_Latn,rs,"/// ɖò nùxwlé lɛ mɛ. ma sɔ́ dó nùxwlé e nyí nùɖé ǎ lɛ é jí ó./// Nú è na wèmá nú nùjlɛ́kpo ɖé ɔ, lɛ́ kɔ nú nùjlɛ́kpo lɛ́ɛ sín kwɛ́ɛ sín nùjlɛ́kpo ɔ́ /// >>> double_the_difference(vec![1, 3, 2, 0])
/// 10
/// >>> double_the_difference(vec![-1, -2, 0])
/// 0
/// >>> double_the_difference(vec![9, -2])
/// 81
/// >>> double_the_difference(vec![0])
/// 0
/// If the input vector is empty, return 0.
fn double_the_difference(lst: Vec<f64>) -> isize {
","fn double_the_difference(lst: Vec<f64>) -> isize {
    lst.iter()
        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)
        .map(|&x| (x as isize).pow(2))
        .sum()
}

fn main() {
    println!(""{}"", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); // 10
    println!(""{}"", double_the_difference(vec![-1.0, -2.0, 0.0])); // 0
    println!(""{}"", double_the_difference(vec![9.0, -2.0])); // 81
    println!(""{}"", double_the_difference(vec![0.0])); // 0
    println!(""{}"", double_the_difference(vec![])); // 0
}","}

fn main() {
    let candidate = double_the_difference;
    assert_eq!(candidate(Vec::<f64>::new()), 0);
    assert_eq!(candidate(vec![5.0, 4.0]), 25);
    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);
    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);
    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);
    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);
    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);
}
"
HumanEval_152,fon_Latn,rs,"/// kpɔ́ndéwú: /// nùxíwùn ɔ nyí 0 bɔ enyi é nyí ǎ ɔ, nùxíwùn ɔ nyí vogbingbɔn e ɖò mɛ̀ nú nùxíwùn ɔ kpo nǔ e è mɔ é kpo tɛntin é./// lɛ́ kɔ́n vector e ɖò hùn ɖokpó ɔ́ jí é xlɛ́ lee mɛ ɖokpó ɖokpó kpò gbɔn é. Nú ye kpò ganji ɔ́,/// È na we azɔmɛvi kpɔnkpɔn kpo nǔ kpɔnkpɔn kpo tɔn we bɔ mɛ ɖokpo ɖokpo nɔ ɖɔ nǔ e é ɖɔ é ɖokpo ɔ.//azɔ towe wɛ nyí ɖɔ a na ɖɔ ɖɔ mɛ ɔ ɖɔ nǔ e é mɔ ɖò nùɖé lɛ mɛ é sɔgbe à jí./// é jɛxa tawun ɖɔ è ni wlan nǔ lɛ bo jlɛ́. //Nǔwiwa ɔ wá jɛ bɔ è wá tuùn nǔ e ɖò jijɛ wɛ é kpo linlin e ɖò ayi towe mɛ ɖò hwe enɛ ɔ mɛ é kpo./// Un ɖi ɖɔ mi bǐ wɛ flín nǔ cí nú mɛ hwenu e mɛ e è ko nɔte kpɔ́n sín tɛgbɛ é ɖé wá é/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])
/// vec![0, 0, 0, 0, 3, 3]
/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])
/// vec![4, 4, 1, 0, 0, 6]
fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
","fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {
    game.iter()
        .zip(guess.iter())
        .map(|(g, gss)| (g - gss).abs())
        .collect()
}

fn main() {
    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);
    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);
    println!(""{:?}"", result1); // Output: [0, 0, 0, 0, 3, 3]
    println!(""{:?}"", result2); // Output: [4, 4, 1, 0, 0, 6]
}","}

fn main() {
    let candidate = compare;
    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);
    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);
    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);
}
"
HumanEval_153,fon_Latn,rs,"/// Kpɔ́n: /// (kpikpa tɔn nyí -1). /// é ná lɛ́ kɔ́n ""Slices.SErviNGSliCes"" ɖó ""SErviNGSliCes"" wɛ nyí nukɔ́nkpó e ɖó gǎn hú bǐ é /// extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ɔ mi ɖo na ɖɔ ɖɔ /// Ɖɔ kpɔ́ndéwú ɔ, enyi è na ""Slices"" we dó azɔ̌mɛmɛ e nyí vector ɔ tɔn ɔ wu ɔ /// un sɔ́ mɛ e jɛ nukɔn ɖò vector ɔ mɛ é.//Enyi è ɖó wuntun wè alǒ hú mɔ̌ bo ɖó hlɔnhlɔn ɖokpo ɔ ɔ, a ɖó na lɛ́ sɔ́ wuntun ɔ dó wuntun ɔ mɛ./// format: ClassName.StrongestExtensionName. //A na mɔ nukɔnyiyi e syɛn hú bǐ é bo na lɛ́ sɔ́ wuntun ɖé dó nù elɔ mɛ./// ɖò nùjlɛ́nkpá ɔ́ sín nyikɔ mɛ ɔ́, kpò e è nɔ ylɔ ɖɔ CAP - SM é wɛ nɔ xlɛ́ gǎnjɛwú ɔ́. /// wema ɖo extension ɔ sín nyikɔ mɛ, bo na sɔ́ SM dó ɖó wema kpɛví lɛ́ɛ tɔn /// hlɔ̀nhlɔ́n nùjlɛ́jlɛ́ ɔ́ tɔn nyí lě e é nɔ nyí gbɔn é: nú CAP nyí númɛ̀ ɔ́ ɖò wuntun ɖaxó ɔ́ mɛ /// Akɔ́n lɛ́ɛ ɔ́' è na zán dó zín azɔ̌mɛ̀ ɖevo lɛ́ɛ dó azɔ̌mɛ̀ ɔ́ wú./// È na na we azɔmɛ ɖé sín nyikɔ (wɔntin) kpo nǔɖeji lɛ sín vectɔ́ ɖé kpo./// >>> Strongest_Extension(String::from(""my_class""), vec![String::from(""AA""), String::from(""Be""), String::from(""CC"")])
/// String::from(""my_class.AA"")
fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
","fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {
    let mut strongest_extension = String::new();
    let mut max_strength = i32::MIN;

    for extension in extensions {
        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;
        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;
        let strength = cap_count - sm_count;

        if strength > max_strength {
            max_strength = strength;
            strongest_extension = extension;
        }
    }

    format!(""{}.{}"", class_name, strongest_extension)
}","}

fn main() {
    let candidate = Strongest_Extension;
    assert_eq!(candidate(String::from(""Watashi""), vec![String::from(""tEN""), String::from(""niNE""), String::from(""eIGHt8OKe"")]), String::from(""Watashi.eIGHt8OKe""));
    assert_eq!(candidate(String::from(""Boku123""), vec![String::from(""nani""), String::from(""NazeDa""), String::from(""YEs.WeCaNe""), String::from(""32145tggg"")]), String::from(""Boku123.YEs.WeCaNe""));
    assert_eq!(candidate(String::from(""__YESIMHERE""), vec![String::from(""t""), String::from(""eMptY""), String::from(""nothing""), String::from(""zeR00""), String::from(""NuLl__""), String::from(""123NoooneB321"")]), String::from(""__YESIMHERE.NuLl__""));
    assert_eq!(candidate(String::from(""K""), vec![String::from(""Ta""), String::from(""TAR""), String::from(""t234An""), String::from(""cosSo"")]), String::from(""K.TAR""));
    assert_eq!(candidate(String::from(""__HAHA""), vec![String::from(""Tab""), String::from(""123""), String::from(""781345""), String::from(""-_-"")]), String::from(""__HAHA.123""));
    assert_eq!(candidate(String::from(""YameRore""), vec![String::from(""HhAas""), String::from(""okIWILL123""), String::from(""WorkOut""), String::from(""Fails""), String::from(""-_-"")]), String::from(""YameRore.okIWILL123""));
    assert_eq!(candidate(String::from(""finNNalLLly""), vec![String::from(""Die""), String::from(""NowW""), String::from(""Wow""), String::from(""WoW"")]), String::from(""finNNalLLly.WoW""));
    assert_eq!(candidate(String::from(""_""), vec![String::from(""Bb""), String::from(""91245"")]), String::from(""_.Bb""));
    assert_eq!(candidate(String::from(""Sp""), vec![String::from(""671235""), String::from(""Bb"")]), String::from(""Sp.671235""));
}
"
HumanEval_154,fon_Latn,rs,"//E na lɛ́ sɔ́ xókwin wè dó nùɖé mɛ. Nú xókwin wegɔ́ ɔ alǒ nùɖé ɖò xókwin nukɔntɔn ɔ mɛ ɔ, è ɖó na lɛ́ sɔ́ true dó nùɖé mɛ./// >>> cycpattern_check(String::from(""abcd""), String::from(""abd""))
/// false
/// >>> cycpattern_check(String::from(""hello""), String::from(""ell""))
/// true
/// >>> cycpattern_check(String::from(""whassup""), String::from(""psus""))
/// false
/// >>> cycpattern_check(String::from(""abab""), String::from(""baa""))
/// true
/// >>> cycpattern_check(String::from(""efef""), String::from(""eeff""))
/// false
/// >>> cycpattern_check(String::from(""himenss""), String::from(""simen""))
/// true
fn cycpattern_check(a: String, b: String) -> bool {
","fn cycpattern_check(a: String, b: String) -> bool {
    let len_b = b.len();
    if len_b == 0 {
        return true;
    }
    let doubled_b = b.clone() + &b;
    for i in 0..len_b {
        if let Some(sub) = doubled_b.get(i..i + len_b) {
            if a.contains(sub) {
                return true;
            }
        }
    }
    false
}","}

fn main() {
    let candidate = cycpattern_check;
    assert_eq!(candidate(String::from(""xyzw""), String::from(""xyw"")), false);
    assert_eq!(candidate(String::from(""yello""), String::from(""ell"")), true);
    assert_eq!(candidate(String::from(""whattup""), String::from(""ptut"")), false);
    assert_eq!(candidate(String::from(""efef""), String::from(""fee"")), true);
    assert_eq!(candidate(String::from(""abab""), String::from(""aabb"")), false);
    assert_eq!(candidate(String::from(""winemtt""), String::from(""tinem"")), true);
}
"
HumanEval_155,fon_Latn,rs,"/// Kpɔ́n: /// Nú è na wlan nú nùjlɛ́kpá ɖé ɔ́, é na lɛ́ lɛ́ wá nú nùjlɛ́kpá e ɖó nùjlɛ́kpá e nyí nǔwíwá é kpo ée nyí nǔwíwá ǎ é kpo é. /// >>> even_odd_count(-12)
/// (1, 1)
/// >>> even_odd_count(123)
/// (1, 2)
fn even_odd_count(num: isize) -> (isize, isize) {
","fn even_odd_count(num: isize) -> (isize, isize) {
    let mut even_count = 0;
    let mut odd_count = 0;
    let num_str = num.abs().to_string();
    
    for ch in num_str.chars() {
        if let Some(digit) = ch.to_digit(10) {
            if digit % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }
    
    (even_count, odd_count)
}","}

fn main() {
    let candidate = even_odd_count;
    assert_eq!(candidate(7), (0, 1));
    assert_eq!(candidate(-78), (1, 1));
    assert_eq!(candidate(3452), (2, 2));
    assert_eq!(candidate(346211), (3, 3));
    assert_eq!(candidate(-345821), (3, 3));
    assert_eq!(candidate(-2), (1, 0));
    assert_eq!(candidate(-45347), (2, 3));
    assert_eq!(candidate(0), (1, 0));
}
"
HumanEval_156,fon_Latn,rs,"/// Kpɔ́ndéwú: /// Hɔnnu lɛ: 1 <= num <= 1000 /// bo sɔ́ wlan e dó wlan mɛ é dó wlan mɛ./// Nú è na w'azɔnkpɔnkpɔn ɖagbe ɖé ɔ, mɔ nùjlɛ́n e nɔ nyí nùjlɛ́n hlɔmanu tɔn é ɖò w'azɔnkpɔnkpɔnkpɔn ɖé mɛ, /// >>> int_to_mini_roman(19)
/// String::from(""xix"")
/// >>> int_to_mini_roman(152)
/// String::from(""clii"")
/// >>> int_to_mini_roman(426)
/// String::from(""cdxxvi"")
fn int_to_mini_roman(number: isize) -> String {
","fn int_to_mini_roman(mut number: isize) -> String {
    let roman_numerals = [
        (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
        (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
        (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
        (1, ""i""),
    ];
    
    let mut result = String::new();
    
    for &(value, symbol) in roman_numerals.iter() {
        while number >= value {
            number -= value;
            result.push_str(symbol);
        }
    }
    
    result
}","}

fn main() {
    let candidate = int_to_mini_roman;
    assert_eq!(candidate(19), String::from(""xix""));
    assert_eq!(candidate(152), String::from(""clii""));
    assert_eq!(candidate(251), String::from(""ccli""));
    assert_eq!(candidate(426), String::from(""cdxxvi""));
    assert_eq!(candidate(500), String::from(""d""));
    assert_eq!(candidate(1), String::from(""i""));
    assert_eq!(candidate(4), String::from(""iv""));
    assert_eq!(candidate(43), String::from(""xliii""));
    assert_eq!(candidate(90), String::from(""xc""));
    assert_eq!(candidate(94), String::from(""xciv""));
    assert_eq!(candidate(532), String::from(""dxxxii""));
    assert_eq!(candidate(900), String::from(""cm""));
    assert_eq!(candidate(994), String::from(""cmxciv""));
    assert_eq!(candidate(1000), String::from(""m""));
}
"
HumanEval_157,fon_Latn,rs,"/// Kpɔ́n: /// 90 degre. /// Hwexwetɔn e nɔ ɖó xwɛ ɖagbe é wɛ nyí wexwetɔn e mɛ xwɛ ɖokpo nyí xwɛ ɖagbe é alǒ ///kpá lɛ nɔ bló atɔnvi-kwɛ́n ɖíɖá-ɖíɖá ɖé, é nyí nùvú ɖò ali ɖevo lɛ. //E na lɛ́ ná mɔ ɖɔ xwɛ̌ atɔn ɔ́ sín akpáxwé lɛ́ɛ nyí xwɛ̌ atɔn ɔ́, é ná lɛ́ nyí nugbǒ./// >>> right_angle_triangle(3, 4, 5)
/// true
/// >>> right_angle_triangle(1, 2, 3)
/// false
fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
","fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {
    let mut sides = [a, b, c];
    sides.sort_unstable();

    let [x, y, z] = sides;
    x * x + y * y == z * z
}","}

fn main() {
    let candidate = right_angle_triangle;
    assert_eq!(candidate(3, 4, 5), true);
    assert_eq!(candidate(1, 2, 3), false);
    assert_eq!(candidate(10, 6, 8), true);
    assert_eq!(candidate(2, 2, 2), false);
    assert_eq!(candidate(7, 24, 25), true);
    assert_eq!(candidate(10, 5, 7), false);
    assert_eq!(candidate(5, 12, 13), true);
    assert_eq!(candidate(15, 8, 17), true);
    assert_eq!(candidate(48, 55, 73), true);
    assert_eq!(candidate(1, 1, 1), false);
    assert_eq!(candidate(2, 2, 10), false);
}
"
HumanEval_158,fon_Latn,rs,"/// nǔwɔnú lɛ́ɛ ɔ́, lɛ́ kɔ nú mɛ e jɛ nukɔn ɖò nǔwɔnú lɛ́ɛ sín nùjlɛ́jlɛ́ mɛ é. /// sín nǔɖeɖevonu lɛ́ɛ. Nú wuntun gègě ɖó nǔɖevonu lɛ́ɛ ɔ́,/// Xó vovo wɛ ɖò vector ɔ mɛ. lɛ́ kɔ xó ɔ kpò nú mɛ /// Wlǎn azɔ̀ e nɔ yí gbè nú nùjlɛ́n xwɛ́ lɛ́ɛ tɔn é. /// >>> find_max(vec![String::from(""name""), String::from(""of""), String::from(""string"")])
/// String::from(""string"")
/// >>> find_max(vec![String::from(""name""), String::from(""enam""), String::from(""game"")])
/// String::from(""enam"")
/// >>> find_max(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")])
/// String::from(""aaaaaaa"")
fn find_max(words: Vec<String>) -> String {
","fn find_max(words: Vec<String>) -> String {
    fn unique_char_count(s: &str) -> usize {
        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();
        for c in s.chars() {
            chars.insert(c);
        }
        chars.len()
    }

    words
        .into_iter()
        .max_by(|a, b| {
            let count_a = unique_char_count(a);
            let count_b = unique_char_count(b);
            count_a.cmp(&count_b).then_with(|| a.cmp(b))
        })
        .unwrap()
}","}

fn main() {
    let candidate = find_max;
    assert_eq!(candidate(vec![String::from(""name""), String::from(""of""), String::from(""string"")]), String::from(""string""));
    assert_eq!(candidate(vec![String::from(""name""), String::from(""enam""), String::from(""game"")]), String::from(""enam""));
    assert_eq!(candidate(vec![String::from(""aaaaaaa""), String::from(""bb""), String::from(""cc"")]), String::from(""aaaaaaa""));
    assert_eq!(candidate(vec![String::from(""abc""), String::from(""cba"")]), String::from(""abc""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""this""), String::from(""game""), String::from(""of""), String::from(""footbott"")]), String::from(""footbott""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""gonna""), String::from(""rock"")]), String::from(""gonna""));
    assert_eq!(candidate(vec![String::from(""we""), String::from(""are""), String::from(""a""), String::from(""mad""), String::from(""nation"")]), String::from(""nation""));
    assert_eq!(candidate(vec![String::from(""this""), String::from(""is""), String::from(""a""), String::from(""prrk"")]), String::from(""this""));
    assert_eq!(candidate(vec![String::from(""b"")]), String::from(""b""));
    assert_eq!(candidate(vec![String::from(""play""), String::from(""play""), String::from(""play"")]), String::from(""play""));
}
"
HumanEval_159,fon_Latn,rs,"/// Kpɔ́n: /// enyi atín e kpo é ma kpé ǎ ɔ, a na ɖu atín e kpo é bǐ, amɔ̌ xovɛ́ na lɛ́ sin we. /// nùjlɛ̌n kwɛ́ e ɖò mɛtɔn jí hwenu e é ɖu nǔ é ] /// mi na lɛ́ kɔ́n nùjlɛ́jlɛ́ e nyí [ nùjlɛ́jlɛ́ kpò e mi ɖu ɖò nùɖuɖu mitɔn gudo é, //Amɔ̌ din ɔ́, a ɖó na ɖu atínkpo hú mɔ̌, bó ná dó sú nùɖuɖu e è nɔ ɖu ɖò kéze ɔ mɛ é sín kún.//A nyí xɛvi xovɛ́ sin wɛ, bo ko ɖu atínkwín e è nɔ ylɔ́ ɖɔ ""carrot"" é ɖé./// >>> eat(5, 6, 10)
/// vec![11, 4]
/// >>> eat(4, 8, 9)
/// vec![12, 1]
/// >>> eat(1, 10, 10)
/// vec![11, 0]
/// >>> eat(2, 11, 5)
/// vec![7, 0]
/// Variables:
/// @number : integer
/// the number of carrots that you have eaten.
/// @need : integer
/// the number of carrots that you need to eat.
/// @remaining : integer
/// the number of remaining carrots thet exist in stock
/// Constrain:
/// * 0 <= number <= 1000
/// * 0 <= need <= 1000
/// * 0 <= remaining <= 1000
/// Have fun :)
fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
","fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {
    let to_eat = if need <= remaining { need } else { remaining };
    vec![number + to_eat, remaining - to_eat]
}","}

fn main() {
    let candidate = eat;
    assert_eq!(candidate(5, 6, 10), vec![11, 4]);
    assert_eq!(candidate(4, 8, 9), vec![12, 1]);
    assert_eq!(candidate(1, 10, 10), vec![11, 0]);
    assert_eq!(candidate(2, 11, 5), vec![7, 0]);
    assert_eq!(candidate(4, 5, 7), vec![9, 2]);
    assert_eq!(candidate(4, 5, 1), vec![5, 0]);
}
"
HumanEval_160,fon_Latn,rs,"/// Operator vector ɖó operator ɖokpó ɖò bǐbɛ̌, bɔ operand vector ɖó operands we ɖò bǐbɛ̌.///Operand ɔ nyí vector nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú nú/// Zɔ́n ɔ́' operand vector sín zɔ́n ɔ́' operand vector sín zɔ́n ɔ́' mínus ɖokpó wɛ./// Nukúnmɛ: /// => nǔ e è mɔ é = 9 /// nǔ e è nɔ mɔ é = 2 + 3 * 4 - 5 /// vector = [2, 3, 4, 5] /// azɔwatɔ́ ['+', '*', '-'] /// Kpɔ́n: /// Akɔnkpɔnkpɔn (**) /// Hɔnmɛ̀ ɔ́ ɖò x'ɛ́ ( //) /// Hɔnúmɛ (*) /// Hɔn nú ( - ) /// Ðɔ nǔ lɛ dó ( +) /// Nǔ e è nɔ wà dó aljɛbu jí lɛ é: /// xógbe bo na lɛ́ yí xógbe enɛ sín kpɔ́n./// vector wegɔ ɔ ɔ nyi vector nú nùxwɛ́ e nyí nǔxixa lɛ é tɔn./// È na wεvivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivivifn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
","fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {
    let mut result = operand[0];
    
    for i in 0..operator.len() {
        match operator[i].as_str() {
            ""+"" => result += operand[i+1],
            ""-"" => result -= operand[i+1],
            ""*"" => result *= operand[i+1],
            ""//"" => result /= operand[i+1],
            ""**"" => result = result.pow(operand[i+1] as u32),
            _ => panic!(""Unexpected operator""),
        }
    }
    
    result
}

fn main() {
    let operators = vec![""+"",""*"",""-""].iter().map(|s| s.to_string()).collect();
    let operands = vec![2, 3, 4, 5];
    let result = do_algebra(operators, operands);
    println!(""Result: {}"", result);
}","}

fn main() {
    let candidate = do_algebra;
    assert_eq!(candidate(vec![String::from(""**""), String::from(""*""), String::from(""+"")], vec![2, 3, 4, 5]), 37);
    assert_eq!(candidate(vec![String::from(""+""), String::from(""*""), String::from(""-"")], vec![2, 3, 4, 5]), 9);
    assert_eq!(candidate(vec![String::from(""//""), String::from(""*"")], vec![7, 3, 4]), 8);
}
"
HumanEval_161,fon_Latn,rs,"/// Kpɔ́ndéwú /// azɔ̀ ɔ́ ɖó ná lɛ́ kɔ̀n wuntun e è mɔ é. /// Nú wlan ɔ kún ɖó wlan ɖé ó ɔ, mi lɛ́ wlan ɔ./// bo ma nyí mɔ̌ ǎ ɔ́, nɔ lě e é ɖe gbɔn é./// enyi s[i] nyí wèmá ɔ, lɛ́ kɔ sín fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó jɛ fí e è nɔ sɔ́ wèmá ɔ ɖó é jí,/// È na wlan wuntun ɖé nú we. /// >>> solve(String::from(""1234""))
/// String::from(""4321"")
/// >>> solve(String::from(""ab""))
/// String::from(""AB"")
/// >>> solve(String::from(""#a@C""))
/// String::from(""#A@c"")
fn solve(s: String) -> String {
","fn solve(s: String) -> String {
    if s.chars().all(|c| !c.is_alphabetic()) {
        s.chars().rev().collect()
    } else {
        s.chars()
            .map(|c| {
                if c.is_lowercase() {
                    c.to_ascii_uppercase()
                } else if c.is_uppercase() {
                    c.to_ascii_lowercase()
                } else {
                    c
                }
            })
            .collect()
    }
}","}

fn main() {
    let candidate = solve;
    assert_eq!(candidate(String::from(""AsDf"")), String::from(""aSdF""));
    assert_eq!(candidate(String::from(""1234"")), String::from(""4321""));
    assert_eq!(candidate(String::from(""ab"")), String::from(""AB""));
    assert_eq!(candidate(String::from(""#a@C"")), String::from(""#A@c""));
    assert_eq!(candidate(String::from(""#AsdfW^45"")), String::from(""#aSDFw^45""));
    assert_eq!(candidate(String::from(""#6@2"")), String::from(""2@6#""));
    assert_eq!(candidate(String::from(""#$a^D"")), String::from(""#$A^d""));
    assert_eq!(candidate(String::from(""#ccc"")), String::from(""#CCC""));
}
"
HumanEval_162,fon_Latn,rs,"/// Nú 'text' nyí xwɛ́ ɔ́, é ná lɛ́ kɔ́n nǔɖé ǎ./// Nú è na wèmá 'text' ɔ, lɛ́ kɔ wèmá e ɖ'emɛ é sín hash md5 ɔ. /// >>> string_to_md5(String::from(""Hello world""))
/// Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62""))
fn string_to_md5(text: String) -> Option<String> {
","use md5;

fn string_to_md5(text: String) -> Option<String> {
    if text.is_empty() {
        return None;
    }
    let digest = md5::compute(text);
    Some(format!(""{:x}"", digest))
}","}

fn main() {
    let candidate = string_to_md5;
    assert_eq!(candidate(String::from(""Hello world"")), Some(String::from(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert_eq!(candidate(String::from("""")), None);
    assert_eq!(candidate(String::from(""A B C"")), Some(String::from(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert_eq!(candidate(String::from(""password"")), Some(String::from(""5f4dcc3b5aa765d61d8327deb882cf99"")));
}
"
HumanEval_163,fon_Latn,rs,"/// Cɔ́n kpɔ́n: /// kpo b kpo, bo na nɔ ɖò jijɛji wɛ. /// Nú è na w'azɔnkpɔnkpɔn ɖagbe wè a kpo b kpo ɔ, lɛ́ kɔ nú xwɛxwɛ e ɖò a kpo b kpo tɛntin é /// >>> generate_integers(2, 8)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(8, 2)
/// vec![2, 4, 6, 8]
/// >>> generate_integers(10, 14)
/// Vec::<isize>::new()
fn generate_integers(a: isize, b: isize) -> Vec<isize> {
","fn generate_integers(a: isize, b: isize) -> Vec<isize> {
    let (start, end) = if a < b { (a, b) } else { (b, a) };
    (start..=end).filter(|&x| x % 2 == 0).collect()
}

fn main() {
    let result1 = generate_integers(2, 8);
    println!(""{:?}"", result1); // Output: vec![2, 4, 6, 8]

    let result2 = generate_integers(8, 2);
    println!(""{:?}"", result2); // Output: vec![2, 4, 6, 8]

    let result3 = generate_integers(10, 14);
    println!(""{:?}"", result3); // Output: vec![10, 12, 14]
}","}

fn main() {
    let candidate = generate_integers;
    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);
    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);
    assert_eq!(candidate(17, 89), Vec::<isize>::new());
}
"
