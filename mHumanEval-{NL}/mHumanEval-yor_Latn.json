[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \u1e62ay\u1eb9wo boya ninu akoj\u1ecd ti aw\u1ecdn n\u1ecdmba ti a fun, eyikeyi aw\u1ecdn n\u1ecdmba meji sunm\u1ecd ara w\u1ecdn ju opin ti a fun.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \u00c0k\u1ecds\u00edl\u1eb9\u0300 f\u00fan i\u1e63\u1eb9\u0301 y\u00ec\u00ed j\u1eb9\u0301 \u00ecl\u00e0 t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn \u1eb9gb\u1eb9\u0301 \u1ecd\u0300p\u1ecd\u0300l\u1ecdp\u1ecd\u0300 ti \u00e0w\u1ecdn \u00e0l\u00e9\u00e9f\u00e0 t\u00ed \u00f3 w\u00e0 n\u00edn\u00fa \u00ecl\u00e0. \u00ccl\u00e9pa r\u1eb9 ni l\u00e1ti p\u00edn \u00e0w\u1ecdn \u1eb9gb\u1eb9\u0301 w\u1ecd\u0300ny\u00ed s\u00ed \u00ecl\u00e0 \u1ecd\u0300t\u1ecd\u0300\u1ecd\u0300t\u1ecd\u0300 k\u00ed o s\u00ec d\u00e1 \u00e0w\u1ecdn \u00ecl\u00e0 w\u1ecd\u0300ny\u00ed pad\u00e0. \u00c0w\u1ecdn \u1eb9gb\u1eb9\u0301 \u1ecd\u0300t\u1ecd\u0300\u1ecd\u0300t\u1ecd\u0300 ni \u00f3 w\u00e0 n\u00ed \u00ecm\u00fad\u00f3j\u00fagba (gbogbo \u00ecl\u00e0 \u1ecd\u0300t\u1ecd\u0300\u1ecd\u0300t\u1ecd\u0300 t\u00ed \u00f3 w\u00e0 n\u00ed \u00ecm\u00fad\u00f3j\u00fagba ni a ti pa t\u00ec d\u00e1ad\u00e1a) \u00e0ti p\u00e9 w\u1ecdn k\u00f2 s\u00ed n\u00ed \u00ecl\u00e0 n\u00edn\u00fa ara w\u1ecdn. Y\u1eb9\u0300y\u1eb9\u0301 \u00e0w\u1ecdn \u00e0l\u00e0 n\u00ed \u00ecl\u00e0 \u00ecl\u00e0 \u00ecl\u00e0 \u00ecl\u00e0. \u00c0p\u1eb9\u1eb9r\u1eb9:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Ti a ba fun n\u1ecdmba ti o ni iyat\u1ecd iyat\u1ecd, o le wa ni pipin sinu ati apakan odidi (odidi ti o tobi jul\u1ecd kere ju n\u1ecdmba ti a fun) ati aw\u1ecdn decimals (apakan ti o ku nigbagbogbo kere ju 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" O ti wa ni fi fun a akoj\u1ecd ti idogo ati yiy\u1ecd aw\u1ecdn i\u1e63\u1eb9 lori a ifowo iroyin ti o b\u1eb9r\u1eb9 p\u1eb9lu odo iwontunwonsi. r\u1eb9 ise ni lati \u1e63e awari ti o ba ni eyikeyi ojuami ti iwontunwonsi ti iroyin falls lab\u1eb9 odo, ati ni wipe ojuami i\u1e63\u1eb9 y\u1eb9 ki o pada Otit\u1ecd. bib\u1eb9k\u1ecd ti o y\u1eb9 ki o pada False. apeere:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Fun akoj\u1ecd ti a fun ti aw\u1ecdn n\u1ecdmba tit\u1eb9si, \u1e63e i\u1e63iro Iyat\u1ecd Pataki Apap\u1ecd ni ayika apap\u1ecd ti data yii. Iyat\u1ecd Pataki Apap\u1ecd j\u1eb9 apap\u1ecd iyat\u1ecd pipe laarin eroja k\u1ecd\u1ecdkan ati aarin aarin (apap\u1ecd ninu \u1ecdran yii): MAD = apap\u1ecd  x - x_mean  \u00c0p\u1eb9\u1eb9r\u1eb9:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Fi n\u1ecdmba 'delimeter' laarin aw\u1ecdn eroja meji ti o t\u1eb9le ara ti akoj\u1ecd input \u2200numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces. fun k\u1ecd\u1ecdkan ti aw\u1ecdn \u1eb9gb\u1eb9, output aw\u1ecdn jinle ipele ti nesting ti parentheses. eg (() (()) ni o ni o p\u1ecdju meji aw\u1ecdn ipele ti nesting nigba ti ((())) ni o ni m\u1eb9ta.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \u1e62\u00e0t\u00fan\u1e63e \u00e0k\u00f3j\u1ecd \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 n\u00ed \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 w\u00e0 n\u00ed \u00ecs\u00e0l\u1eb9\u0300\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Fun akoj\u1ecd ti a fun ti aw\u1ecdn integers, pada a tuple ti o ni a akoj\u1ecdp\u1ecd ati a \u1ecdja ti gbogbo aw\u1ecdn integers ninu akoj\u1ecd kan. \u1e63ofo akoj\u1ecd y\u1eb9 ki o j\u1eb9 dogba si 0 ati ki o \u1e63ofo \u1ecdja y\u1eb9 ki o j\u1eb9 dogba si 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Lati inu akoj\u1ecd ti a fun ti aw\u1ecdn n\u1ecdmba odidi, \u1e63e akoj\u1ecd ti aw\u1ecdn eroja ti o p\u1ecdju ti o wa titi di akoko ti a fun ni l\u1eb9s\u1eb9s\u1eb9.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" \u00c0d\u00e1nw\u00f2 b\u00ed \u00ecl\u00e0 t\u00ed a f\u00fan b\u00e1 j\u1eb9\u0301 palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input ni aw\u1ecdn okun meji a ati b ti o ni aw\u1ecdn 1s ati 0s nikan. \u1e62i\u1e63e XOR alakomeji lori aw\u1ecdn ohun elo w\u1ecdny\u1eb9n ati esi pada tun bi okun.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" L\u00e1ti in\u00fa \u00e0k\u00f3j\u1ecd \u00e0w\u1ecdn \u00f2p\u00f3, d\u00e1 \u00e8y\u00ed t\u00f3 g\u00f9n j\u00f9l\u1ecd pad\u00e0. D\u00e1 \u00e8y\u00ed \u00e0k\u1ecd\u0301k\u1ecd\u0301 pad\u00e0 n\u00edn\u00fa \u1ecd\u0300r\u00e0n \u00e0w\u1ecdn \u00f2p\u00f3 p\u00fap\u1ecd\u0300 t\u00ed \u00f3 g\u00f9n b\u00e1kan n\u00e1\u00e0. M\u00e1 d\u00e1 K\u00f2 s\u00ed pad\u00e0 n\u00edn\u00fa \u1ecd\u0300r\u00e0n t\u00ed \u00e0k\u00f3j\u1ecd \u00ecs\u1ecdf\u00fanni t\u00ed a fi w\u1ecdl\u00e9 k\u00f2 b\u00e1 s\u00ed.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Y\u00edpad\u00e0 \u00e0w\u1ecdn \u00e0pap\u1ecd\u0300 \u00e0pap\u1ecd\u0300 t\u00ed \u00f3 t\u00f3bi j\u00f9l\u1ecd n\u00edn\u00fa \u00e0w\u1ecdn iye p\u00edp\u00e9 m\u00e9j\u00ec a \u00e0ti b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" \u00c0t\u00f2j\u1ecd \u00ecpad\u00e0b\u1ecd\u0300 gbogbo \u00e0w\u1ecdn \u00e0fik\u00fan l\u00e1ti k\u00far\u00fa s\u00ed g\u00edg\u00f9n j\u00f9l\u1ecd n\u00edn\u00fa \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed \u00ecs\u1ecd\u0300r\u00ed\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Y\u00edpad\u00e0 \u00f2p\u00f3 t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn iye t\u00ed \u00f3 n\u00ed \u00e0l\u00e0fo \u00e0l\u00e0fo t\u00ed \u00f3 b\u1eb9\u0300r\u1eb9\u0300 l\u00e1ti 0 t\u00edt\u00ed d\u00e9 n.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Ti a ba fun \u1ecd ni okun kan, wa iye aw\u1ecdn ohun kik\u1ecd ti o yat\u1ecd (laibikita \u1ecdran) ti o ni\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" input si i\u1e63\u1eb9 yi ni a okun ti o n\u1e63afihan aw\u1ecdn orin ak\u1ecdsil\u1eb9 ni a pataki ascii kika. r\u1eb9 ise ni lati parse yi okun ki o si pada akoj\u1ecd ti aw\u1ecdn integers ni ibamu si bi \u1ecdp\u1ecdl\u1ecdp\u1ecd aw\u1ecdn beats ti k\u1ecd\u1ecdkan ko ni k\u1eb9hin. nibi ni a itan: 'o' - gbogbo ak\u1ecdsil\u1eb9, k\u1eb9hin m\u1eb9rin beats 'o\" - idaji ak\u1ecdsil\u1eb9, k\u1eb9hin meji beats '. \"i\" - quater ak\u1ecdsil\u1eb9, k\u1eb9hin \u1ecdkan beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" W\u00e1 iye \u00ecgb\u00e0 t\u00ed a l\u00e8 r\u00ed \u00ecs\u00f3k\u00e8-\u00f2k\u00e8 kan n\u00edn\u00fa \u00ecs\u00f3k\u00e8-\u00f2k\u00e8 \u00e0k\u1ecd\u0301k\u1ecd\u0301. Ka \u00e0w\u1ecdn \u00ecgb\u00e0 t\u00ed \u00f3 b\u00e1 \u0144 bo ara w\u1ecdn.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input j\u1eb9 a aaye-delimited okun ti numerals lati 'ero' to 'k\u1eb9\u1eb9san'. Valid yiyan ni 'k\u1eb9\u1eb9san', 'kan','meji','m\u1eb9ta','m\u1eb9rin','marun','mefa', '\u1eb9\u1eb9\u1eb9dogun','m\u1eb9j\u1ecd' ati 'k\u1eb9\u1eb9san'. Pada aw\u1ecdn okun p\u1eb9lu aw\u1ecdn n\u1ecdmba ti o yan lati kere si tobi\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Lati inu akoj\u1ecd ti a pese ti aw\u1ecdn n\u1ecdmba (ti ipari ko kere ju meji l\u1ecd) yan ki o pada meji ti o sunm\u1ecd jul\u1ecd si ara w\u1ecdn ki o pada w\u1ecdn ni a\u1e63\u1eb9 (n\u1ecdmba kekere, n\u1ecdmba nla).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Ti a ba fun ni akoj\u1ecd aw\u1ecdn n\u1ecdmba (ti o kere ju aw\u1ecdn eroja meji), lo iyipada ila kan si akoj\u1ecd y\u1eb9n, iru pe n\u1ecdmba ti o kere jul\u1ecd yoo di 0 ati pe n\u1ecdmba ti o tobi jul\u1ecd yoo di 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \u1e62\u00e0t\u00fan\u1e63e \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 t\u00ed a f\u00fan n\u00ed \u00e0w\u1ecdn iye Python f\u00fan \u00e0w\u1ecdn iye odidi n\u00eckan\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Gbigba pada ipari ti okun ti a fun\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Fun n\u1ecdmba kan n, wa n\u1ecdmba ti o tobi julo ti o pin n bakanna, ti o kere ju n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in order from smallest to largest. Olukuluku ninu aw\u1ecdn ifosiwewe y\u1eb9 ki o wa ni akoj\u1ecd n\u1ecdmba ti igba ti o baamu si bi \u1ecdp\u1ecdl\u1ecdp\u1ecd igba ti o han ni factorization. Input n\u1ecdmba y\u1eb9 ki o j\u1eb9 dogba si aw\u1ecdn \u1ecdja ti gbogbo aw\u1ecdn ifosiwewe\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Lati inu akoj\u1ecd aw\u1ecdn n\u1ecdmba odidi, y\u1ecd gbogbo aw\u1ecdn eroja ti o waye ju \u1eb9\u1eb9kan l\u1ecd. Pa a\u1e63\u1eb9 ti aw\u1ecdn eroja sil\u1eb9 kanna bi ninu ohun ti o w\u1ecdle.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Fun okun ti a fun, yi aw\u1ecdn ohun kik\u1ecd kekere pada si nla ati nla si kekere.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" \u1e62\u1eb9da akoj\u1ecd aw\u1ecdn okun sinu okun kan\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" \u1e62\u00e0t\u00fan\u1e63e \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 w\u00e0 n\u00edn\u00fa \u00ecs\u1ecdf\u00fanni t\u00ed a fi s\u00edn\u00fa \u00ecs\u1ecdf\u00fanni f\u00fan \u00e0w\u1ecdn \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 b\u1eb9\u0300r\u1eb9\u0300 p\u1eb9\u0300l\u00fa \u00e0l\u00e9\u00e9b\u00f9 kan.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"\u00d3 \u0144 d\u00e1 \u00e0w\u1ecdn iye t\u00f3 b\u00e1 d\u00e1ra n\u00edn\u00fa \u00e0k\u1ecds\u00edl\u1eb9\u0300 pad\u00e0.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Y\u00edpad\u00e0 \u00f2t\u00edt\u1ecd\u0301 b\u00ed iye t\u00ed a f\u00fan n\u00ed j\u1eb9\u0301 iye \u00e0k\u1ecd\u0301k\u1ecd\u0301, \u00e0ti \u00e8k\u00e9 b\u00ed k\u00f2 b\u00e1 \u1e63e b\u1eb9\u0301\u1eb9\u0300.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u00d3 \u0144 \u1e63e \u00e0gb\u00e9y\u00e8\u0323w\u00f2 polynomial p\u1eb9\u0300l\u00fa \u00e0w\u1ecdn k\u00f3\u00f2t\u00edf\u00eds\u00ecn xs n\u00ed ibi x. pad\u00e0 xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"I\u1e63\u1eb9\u0301 y\u00ec\u00ed gba \u00e0k\u00f3j\u1ecd l \u00f3 s\u00ec d\u00e1 \u00e0k\u00f3j\u1ecd l' pad\u00e0 t\u00ed l' b\u00e1 b\u00e1 l mu n\u00edn\u00fa \u00e0w\u1ecdn \u00e0m\u00ec t\u00ed k\u00f2 \u1e63e\u00e9 p\u00edn s\u00ed m\u1eb9\u0301ta, n\u00edgb\u00e0 t\u00ed iye r\u1eb9\u0300 n\u00ed \u00e0w\u1ecdn \u00e0m\u00ec t\u00ed a l\u00e8 p\u00edn s\u00ed m\u1eb9\u0301ta b\u00e1 iye \u00e0w\u1ecdn \u00e0m\u00ec t\u00ed \u00f3 b\u00e1 d\u1ecd\u0300gba f\u00fan l, \u1e63\u00f9gb\u1ecd\u0301n t\u00ed a \u1e63\u00e8t\u00f2.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Y\u00edpad\u00e0 \u00e0w\u1ecdn \u00e8r\u00f2j\u00e0 \u00e0r\u00e0 \u1ecd\u0300t\u1ecd\u0300 t\u00ed a ti \u1e63\u00e8t\u00f2 n\u00edn\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Y\u00edpad\u00e0 ohun t\u00ed \u00f3 p\u1ecd\u0300 j\u00f9l\u1ecd n\u00edn\u00fa \u00e0k\u00f3j\u1ecd.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Y\u00ed iye \u00ecgb\u00e0 t\u00ed d\u00edg\u00ed 7 fara h\u00e0n n\u00edn\u00fa \u00e0w\u1ecdn iye t\u00ed \u00f3 k\u00e9r\u00e9 ju n t\u00ed \u00f3 \u1e63e\u00e9 p\u00edn s\u00ed 11 t\u00e0b\u00ed 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"I\u1e63\u1eb9\u0301 y\u00ec\u00ed gba \u00e0k\u00f3j\u1ecd l \u00f3 s\u00ec d\u00e1 \u00e0k\u00f3j\u1ecd l' pad\u00e0 t\u00ed l' b\u00e1 j\u1eb9\u0301 b\u00e1kan n\u00e1\u00e0 p\u1eb9\u0300l\u00fa l n\u00edn\u00fa \u00e0w\u1ecdn \u00e0m\u00ec t\u00ed k\u00f2 b\u00e1ra mu, n\u00edgb\u00e0 t\u00ed iye r\u1eb9\u0300 n\u00ed \u00e0w\u1ecdn \u00e0m\u00ec t\u00ed \u00f3 b\u00e1ra mu b\u00e1 iye \u00e0w\u1ecdn \u00e0m\u00ec t\u00ed \u00f3 b\u00e1ra mu ti l, \u1e63\u00f9gb\u1ecd\u0301n t\u00ed a \u1e63\u00e8t\u00f2.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    \u00f3 \u0144 d\u00e1 \u00ecl\u00e0 t\u00ed a fi k\u1ecd\u0301k\u1ecd\u0301r\u1ecd\u0301 s\u00ed pad\u00e0 n\u00edpa l\u00edlo \u00e0w\u1ecdn \u1eb9gb\u1eb9\u0301 on\u00edp\u00f2 k\u1eb9\u0300k\u1eb9\u0301 t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn \u00e0m\u00ec m\u1eb9\u0301ta.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib y\u00f3\u00f2 d\u00e1 iye n-th t\u00ed \u00f3 j\u1eb9\u0301 iye Fibonacci pad\u00e0 t\u00ed \u00f3 s\u00ec t\u00fan j\u1eb9\u0301 iye \u00e0k\u1ecd\u0301k\u1ecd\u0301.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero gba akoj\u1ecd aw\u1ecdn iye odidi bi ohun ti a fi sinu. o pada si Otit\u1ecd ti o ba j\u1eb9 pe aw\u1ecdn eroja ori\u1e63iri\u1e63i m\u1eb9ta wa ninu akoj\u1ecd ti o \u1e63aj\u1ecd si odo, ati eke bib\u1eb9k\u1ecd.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    foj\u00fa in\u00fa wo oj\u00fa \u1ecd\u0300n\u00e0 kan t\u00f3 g\u00f9n d\u00e9 \u00f2pin. n \u1ecdk\u1ecd\u0300 \u0144 wak\u1ecd\u0300 l\u00e1ti \u00f2s\u00ec s\u00ed \u1ecd\u0300t\u00fan; n\u00ed \u00e0k\u00f3k\u00f2 kan n\u00e1\u00e0, \u00e0w\u00f9j\u1ecd \u1ecdk\u1ecd\u0300 n m\u00ec\u00edr\u00e0n \u0144 wak\u1ecd\u0300 l\u00e1ti \u00f2s\u00ec s\u00ed \u1ecd\u0300t\u00fan. \u00e0w\u00f9j\u1ecd \u1ecdk\u1ecd\u0300 m\u00e9j\u00ec n\u00e1\u00e0 b\u1eb9\u0300r\u1eb9\u0300 l\u00e1tor\u00ed p\u00e9 w\u1ecd\u0301n j\u00ecnn\u00e0 s\u00edra w\u1ecdn gan-an. gbogbo \u1ecdk\u1ecd\u0300 \u0144 r\u00ecn n\u00ed iyara kan n\u00e1\u00e0. a s\u1ecd p\u00e9 \u1ecdk\u1ecd\u0300 m\u00e9j\u00ec \u0144 k\u1ecdlu ara w\u1ecdn n\u00edgb\u00e0 t\u00ed \u1ecdk\u1ecd\u0300 kan t\u00f3 \u0144 l\u1ecd l\u00e1ti \u00f2s\u00ec s\u00ed \u1ecd\u0300t\u00fan b\u00e1 k\u1ecdlu \u1ecdk\u1ecd\u0300 kan t\u00f3 \u0144 l\u1ecd l\u00e1ti \u00f2s\u00ec s\u00ed \u1ecd\u0300t\u00fan. \u1e63\u00f9gb\u1ecd\u0301n, \u00e0w\u1ecdn \u1ecdk\u1ecd\u0300 n\u00e1\u00e0 l\u00e1gb\u00e1ra d\u00e9 \u00f2pin; n\u00edtor\u00ed n\u00e1\u00e0, w\u1ecd\u0301n \u0144 b\u00e1 \u00ecr\u00ecn w\u1ecdn l\u1ecd b\u00ed \u1eb9ni p\u00e9 w\u1ecdn k\u00f2 k\u1ecdlu ara w\u1ecdn. i\u1e63\u1eb9\u0301 y\u00ec\u00ed \u0144 s\u1ecd iye ir\u00fa \u00eck\u1ecdl\u00f9 b\u1eb9\u0301\u1eb9\u0300 j\u00e1de.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"\u00c0t\u00f2j\u1ecd \u00ecpad\u00e0b\u1ecd\u0300 p\u1eb9\u0300l\u00fa \u00e0w\u1ecdn \u00e8r\u00f2j\u00e0 t\u00ed a fi 1 k\u00fan un.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero gba akoj\u1ecd aw\u1ecdn iye odidi bi ohun ti a fi sinu. o pada si Otit\u1ecd ti o ba j\u1eb9 pe aw\u1ecdn eroja meji ti o yat\u1ecd ni akoj\u1ecd ti o \u1e63aj\u1ecd si odo, ati eke bib\u1eb9k\u1ecd.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Yi n\u1ecdmba ipil\u1eb9 ti n\u1ecdmba tit\u1eb9si x pada si ipil\u1eb9. pada a\u1e63oju okun l\u1eb9hin iyipada. aw\u1ecdn n\u1ecdmba ipil\u1eb9 kere ju 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"A f\u00fan w\u1ecdn n\u00ed g\u00edg\u00f9n \u1eb9\u0300gb\u1eb9\u0301 \u00e0ti \u00e0y\u00e8 \u00ecpad\u00e0b\u1ecd\u0300 g\u00edga f\u00fan \u1eb9\u0300\u1eb9\u0300m\u1eb9\u0301ta.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"\u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"\u1e62e \u00e0t\u00fan\u1e63e s\u00ed \u00e0l\u00e0fo \u00e0w\u1ecdn eroja n\u00edn\u00fa \u00e0k\u1ecds\u00edl\u1eb9\u0300 l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    \u00d3 \u0144 \u1e63ay\u1eb9wo b\u00f3y\u00e1 \u00ecl\u00e0 t\u00ed a f\u00fan ni palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Yi pada 2^n modulo p (m\u00e1a m\u1ecd\u0300 n\u00edpa \u00e0w\u1ecdn n\u00f3m\u00edr\u00edk\u00ec).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    \u00f3 \u0144 pad\u00e0 s\u00ed \u00ecl\u00e0 t\u00ed a fi k\u1ecd\u0300\u01f9p\u00fat\u00e0 s\u00ed n\u00edpa f\u00edfi 5 y\u00ed gbogbo \u00e0w\u1ecdn \u00e0m\u00ec in\u00fa \u00e1l\u00edf\u00e1b\u1eb9\u0301\u1eb9\u0300t\u00ec pad\u00e0.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels j\u1eb9\u0301 i\u1e63\u1eb9\u0301 t\u00ed \u00f3 gba \u00ecl\u00e0 t\u00ed \u00f3 s\u00ec d\u00e1 \u00ecl\u00e0 pad\u00e0 l\u00e1\u00ec n\u00ed \u00e0w\u1ecdn on\u00edr\u00f3.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True ti gbogbo aw\u1ecdn n\u1ecdmba ninu akoj\u1ecd l wa ni isal\u1eb9 ti \u00e0l\u00e0fo t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Fi iye meji x ati y k\u00fan un\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    W\u00e1 a w\u00f2 b\u00f3y\u00e1 \u00e0w\u1ecdn \u00f2\u0323r\u00f2\u0323 m\u00e9j\u00ec kan n\u00e1\u00e0 ni w\u00f3\u0323n \u0144 k\u1ecd.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Y\u00edpad\u00e0 n-th iye Fibonacci.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets j\u1eb9 \u00ecl\u00e0 ti \"<\" \u00e0ti \">\". return True b\u00ed gbogbo bracket \u00ecb\u00e8\u00e8r\u00e8 b\u00e1 n\u00ed bracket \u00ecpar\u00ed t\u00f3 b\u00e1 a mu.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True j\u1eb9 aw\u1ecdn eroja akoj\u1ecd ti n p\u1ecd si tabi dinku monotonically.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Y\u00edpad\u00e0 \u00e0w\u1ecdn ohun t\u00ed \u00f3 w\u00e0 n\u00edp\u00f2 f\u00fan \u00e0w\u1ecdn \u00e0k\u00f3j\u1ecd m\u00e9j\u00ec.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Pada aw\u1ecdn tobi ak\u1ecdk\u1ecd ifosiwewe ti n. Ro n > 1 ati ki o j\u1eb9 ko kan ak\u1ecdk\u1ecd.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n j\u1eb9\u0301 i\u1e63\u1eb9\u0301 t\u00ed \u00f3 \u0144 \u1e63e \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn iye l\u00e1ti 1 s\u00ed n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets j\u1eb9 \u00ecl\u00e0 ti \"(\" \u00e0ti \")\". return True b\u00ed gbogbo bracket \u1e63\u00ed\u1e63\u00ed b\u00e1 n\u00ed bracket \u00ecpar\u00ed t\u00f3 b\u00e1 a mu.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs d\u00far\u00f3 f\u00fan \u00e0w\u1ecdn k\u00f3\u00f2t\u00edf\u00edt\u00e1n\u00ec ti \u00f2p\u00f2p\u00f2p\u00f2. xs[0] + xs[1] * x + xs[2] * x^2 +.... Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"\u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9 \u00e0w\u00f2r\u00e1n \u00c0k\u1ecdl\u00e9\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nFi \u00e0w\u1ecdn \u00e0y\u00e8\u0323w\u00f2 m\u00ec\u00edr\u00e0n k\u00fan un.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Circular shift aw\u1ecdn n\u1ecdmba ti aw\u1ecdn odidi x, gbe aw\u1ecdn n\u1ecdmba \u1ecdtun nipa gbigbe ati ki o pada aw\u1ecdn esi bi a okun. Ti o ba ti gbigbe > n\u1ecdmba ti aw\u1ecdn n\u1ecdmba, pada aw\u1ecdn n\u1ecdmba ti o pada.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"I\u1e63\u1eb9\u0301 K\u1ecd i\u1e63\u1eb9\u0301 t\u00ed \u00f3 gba \u00ecl\u00e0 g\u1eb9\u0301g\u1eb9\u0301 b\u00ed \u00ecs\u1ecdf\u00fanni t\u00ed \u00f3 s\u00ec d\u00e1 \u00e0pap\u1ecd\u0300 \u00e0w\u1ecdn \u00e0m\u00ec \u00f2k\u00e8 pad\u00e0. \u00c0p\u1eb9\u1eb9r\u1eb9: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Ni yi ise, o yoo wa ni fi a okun ti o duro fun n\u1ecdmba kan ti apples ati osan ti o ti wa ni pinpin ni a agb\u1ecdn ti eso yi agb\u1ecdn ni o ni apples, osan, ati mango eso. Fi fun aw\u1ecdn okun ti o duro fun aw\u1ecdn lapap\u1ecd n\u1ecdmba ti aw\u1ecdn osan ati apples ati kan integer ti o duro fun aw\u1ecdn lapap\u1ecd n\u1ecdmba ti aw\u1ecdn eso ni agb\u1ecdn pada aw\u1ecdn n\u1ecdmba ti aw\u1ecdn eso mango ninu agb\u1ecdn. fun examble: fruit_distribution\"5(apples ati 6 osan\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 apples ati 1 osan\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 apples ati 3 osan\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 apples ati 1 osan\",1 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"G\u1eb9\u0301g\u1eb9\u0301 b\u00ed \u00e0t\u1eb9\u0301l\u1eb9w\u1ecd\u0301 t\u00ed \u00f3 \u0144\u1e63oj\u00fa f\u00fan \u1eb9\u0300ka igi t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn \u00f2p\u00f3 t\u00ed k\u00ec \u00ed \u1e63e \u00e0b\u00f9k\u00f9, i\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti m\u00fa \u1ecd\u0300kan n\u00edn\u00fa \u00e0w\u1ecdn \u00f2p\u00f3 n\u00e1\u00e0 k\u00ed o s\u00ec d\u00e1 a pad\u00e0. \u00d2p\u00f3 t\u00ed a m\u00fa y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 \u00f2p\u00f3 t\u00ed \u00f3 n\u00ed iye t\u00f3 k\u00e9r\u00e9 j\u00f9 l\u1ecd. B\u00ed a b\u00e1 r\u00ed \u1ecd\u0300p\u1ecd\u0300l\u1ecdp\u1ecd\u0300 \u00f2p\u00f3 t\u00ed iye w\u1ecdn k\u00e9r\u00e9 j\u00f9 l\u1ecd b\u00e1kan n\u00e1\u00e0, d\u00e1 \u00f2p\u00f3 t\u00ed \u00f3 n\u00ed \u00ecl\u00e0j\u00fa t\u00f3 k\u00e9r\u00e9 j\u00f9l\u1ecd pad\u00e0. \u00d2p\u00f3 t\u00ed a m\u00fa y\u1eb9 k\u00ed a d\u00e1 pad\u00e0 n\u00edn\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300, [small_value, its index], B\u00ed k\u00f2 b\u00e1 s\u00ed iye t\u00f3 j\u1eb9\u0301 \u00f2p\u00f3 t\u00e0b\u00ed t\u00ed \u00e0t\u1eb9\u0301l\u1eb9w\u1ecd\u0301 t\u00ed a f\u00fan n\u00ed k\u00f2 s\u00ed, d\u00e1 []. \u00c0p\u1eb9\u1eb9r\u1eb9 1: \u00ccw\u1ecd\u0300n: [4,2,3] \u00ccw\u1ecd\u0300n: [2, 1] \u00c0l\u00e0y\u00e9:\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Fun array kan ti aw\u1ecdn n\u1ecdmba odidi, wa n\u1ecdmba ti o kere ju ti aw\u1ecdn eroja ti o nilo lati yipada lati j\u1eb9 ki array naa j\u1eb9 palindromic. A palindromic array j\u1eb9 ohun elo ti o ka kanna pada ati siwaju. Ni iyipada kan, o le yi eroja kan pada si eyikeyi eroja miiran. Fun ap\u1eb9\u1eb9r\u1eb9: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 kan ti o pada otit\u1ecd ti n\u1ecdmba ti a fun ni o j\u1eb9 igbasil\u1eb9 ti aw\u1ecdn n\u1ecdmba ak\u1ecdk\u1ecd 3 ati eke bib\u1eb9k\u1ecd. M\u1ecd pe (a) j\u1eb9 kere ju 100. Ap\u1eb9\u1eb9r\u1eb9: is_multiply_prime(30) == Otit\u1ecd 30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"I\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti k\u1ecd\u0301 i\u1e63\u1eb9\u0301 t\u00ed \u00f3 pad\u00e0 s\u00ed \u00f2t\u00edt\u1ecd\u0301 b\u00ed iye x b\u00e1 j\u1eb9\u0301 agb\u00e1ra kan t\u00ed \u00f3 r\u1ecdr\u00f9n l\u00e1ti fi n \u1e63e \u00e0ti \u00e8k\u00e9 n\u00edn\u00fa \u00e0w\u1ecdn \u1ecd\u0300r\u00e0n m\u00ec\u00edr\u00e0n. x j\u1eb9\u0301 agb\u00e1ra kan t\u00ed \u00f3 r\u1ecdr\u00f9n l\u00e1ti fi n \u1e63e b\u00ed n**int=x B\u00ed \u00e0p\u1eb9\u1eb9r\u1eb9: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"O ti wa ni tasked lati k\u1ecd a i\u1e63\u1eb9 ti o gba a hexadecimal n\u1ecdmba bi a okun ati ki o ka aw\u1ecdn n\u1ecdmba ti hexadecimal aw\u1ecdn oniwe-primu (primu n\u1ecdmba, tabi a ak\u1ecdk\u1ecd, ni a adayeba n\u1ecdmba ti o tobi ju 1 ti o ni ko kan \u1ecdja ti meji kere adayeba aw\u1ecdn n\u1ecdmba). hexadecimal aw\u1ecdn oniwe-primu ni o wa 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prime n\u1ecdmba ni o wa 2, 3, 5, 7, 11, 13, 17,... Nitorina o ni lati m\u1ecd a n\u1ecdmba ti aw\u1ecdn w\u1ecdnyi oniwe-primu: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13). Ak\u1ecdsil\u1eb9: o le ro pe aw\u1ecdn input j\u1eb9 nigbagbogbo t\u1ecd tabi ofo, ati aw\u1ecdn aami A,B,C,D,E,F, ti wa ni nigbagbogbo uppercase. Ap\u1eb9\u1eb9r\u1eb9: Fun num\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"A \u00f3 f\u00fan \u1ecd n\u00ed n\u1ecd\u0301\u0144b\u00e0 kan n\u00ed \u1ecd\u0300n\u00e0 d\u00ed\u1eb9\u0300m\u00edl\u00e0 \u00e0ti i\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti y\u00ed i pad\u00e0 s\u00ed \u1ecd\u0300n\u00e0 \u00eck\u1ecd\u0301l\u00e9. i\u1e63\u1eb9\u0301 n\u00e1\u00e0 y\u00f3\u00f2 d\u00e1 \u00ecl\u00e0 pad\u00e0, p\u1eb9\u0300l\u00fa k\u00edk\u1ecd\u0301k\u1ecd\u0300\u1ecd\u0300kan t\u00ed \u00f3 d\u00far\u00f3 f\u00fan n\u1ecd\u0301\u0144b\u00e0 \u00eck\u1ecd\u0301l\u00e9. k\u00e1luk\u00fa n\u00edn\u00fa \u00ecl\u00e0 n\u00e1\u00e0 y\u00f3\u00f2 j\u1eb9\u0301 '0' t\u00e0b\u00ed '1'. y\u00f3\u00f2 w\u00e0 n\u00ed \u00e0w\u1ecdn \u00e0m\u00ec m\u00e9j\u00ec \u00e0fik\u00fan 'db' n\u00ed \u00ecb\u1eb9\u0300r\u1eb9\u0300 \u00e0ti n\u00ed \u00f2pin \u00ecl\u00e0 n\u00e1\u00e0. \u00e0w\u1ecdn \u00e0m\u00ec \u00e0fik\u00fan n\u00e1\u00e0 w\u00e0 n\u00edb\u1eb9\u0300 l\u00e1ti r\u00e0n \u1ecd\u0301 l\u1ecd\u0301w\u1ecd\u0301 p\u1eb9\u0300l\u00fa \u1ecd\u0300n\u00e0 \u00eck\u1ecd\u0301l\u00e9. \u00c0p\u1eb9\u1eb9r\u1eb9: decimal_to_binary(15) # \u0144 d\u00e1 \"db1111db\" pad\u00e0 decimal_to_binary32) # \u0144 d\u00e1 \"db100000db\" pad\u00e0\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"A f\u00fan \u1ecd n\u00ed \u00ecl\u00e0 s. I\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti \u1e63\u00e0y\u1eb9\u0300w\u00f2 b\u00f3y\u00e1 \u00ecl\u00e0 n\u00e1\u00e0 d\u00f9n t\u00e0b\u00ed k\u00f2 d\u00f9n. \u00ccl\u00e0 kan d\u00f9n b\u00ed g\u00edg\u00f9n r\u1eb9\u0300 b\u00e1 j\u1eb9\u0301 \u00f3 k\u00e9r\u00e9 t\u00e1n 3 \u00e0ti gbogbo l\u1eb9\u0301t\u00e0 3 l\u1eb9\u0301s\u1eb9\u0300k\u1eb9s\u1eb9\u0300 j\u1eb9\u0301 \u00ecy\u00e0t\u1ecd\u0300 f\u00fanra w\u1ecdn \u00c0p\u1eb9\u1eb9r\u1eb9: is_happy(a) => False is_happy(aa) => False is_happy(abcd) => True is_happy(aabb) => False is_happy(adb) => True is_happy(xyy) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"O ti wa ni k\u1eb9hin \u1ecds\u1eb9 ti aw\u1ecdn k\u1eb9fa ati aw\u1ecdn oluk\u1ecd ni lati fi aw\u1ecdn kilasi si aw\u1ecdn akekoo. aw\u1ecdn oluk\u1ecd ti a ti \u1e63i\u1e63e aw\u1ecdn oniwe-ara algorithm fun grading. aw\u1ecdn nikan isoro ni, o ti s\u1ecdnu aw\u1ecdn koodu ti o lo fun grading. o ti fi fun o kan akoj\u1ecd ti GPAs fun di\u1eb9 ninu aw\u1ecdn akekoo ati aw\u1ecdn ti o ni lati k\u1ecd a i\u1e63\u1eb9 ti o le gbe jade kan akoj\u1ecd ti l\u1eb9ta kilasi lilo aw\u1ecdn w\u1ecdnyi tabili: GPA. l\u1eb9ta kilasi 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', '\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 ti o gba okun kan ki o pada si Otit\u1ecd ti gigun okun ba j\u1eb9 n\u1ecdmba ak\u1ecdk\u1ecd tabi eke bib\u1eb9k\u1ecd ti Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9 prime_length (('Hello') == O daju prime_length (('abcdcba') == O daju prime_length (('kittens') == O daju prime_length (('orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Ti a fun ni iye odidi rere n, pada iye iye aw\u1ecdn n\u1ecdmba ti aw\u1ecdn n\u1ecdmba odidi rere n-digit ti o b\u1eb9r\u1eb9 tabi pari p\u1eb9lu 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Fun a rere integer N, pada aw\u1ecdn lapap\u1ecd iye ti aw\u1ecdn oniwe-digits ni alakomeji. Ap\u1eb9\u1eb9r\u1eb9 Fun N = 1000, aw\u1ecdn iye ti aw\u1ecdn oniwe-digits yoo j\u1eb9 1 aw\u1ecdn i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 \"1\". Fun N = 150, aw\u1ecdn iye ti aw\u1ecdn oniwe-digits yoo j\u1eb9 6 aw\u1ecdn i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 \"110\". Fun N = 147, aw\u1ecdn iye ti aw\u1ecdn oniwe-digits yoo j\u1eb9 12 aw\u1ecdn i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 \"1100\".\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Ti a ba fun ni akoj\u1ecd ti ko ni ofo ti aw\u1ecdn n\u1ecdmba lst. fi aw\u1ecdn eroja paapaa ti o wa ni aw\u1ecdn it\u1ecdka ti o ni iyat\u1ecd.. Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9: fi kun (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    K\u1ecd i\u1e63\u1eb9 kan ti o gba okun kan ki o si pada \u1eb9ya ti a pa\u1e63\u1eb9 ti o. \u1eb8ya ti a pa\u1e63\u1eb9 ti okun, j\u1eb9 okun kan nibiti gbogbo aw\u1ecdn \u1ecdr\u1ecd (ti a pin nipas\u1eb9 aaye) ti r\u1ecdpo nipas\u1eb9 \u1ecdr\u1ecd tuntun nibiti gbogbo aw\u1ecdn ohun kik\u1ecd ti a \u1e63eto ni a\u1e63\u1eb9 ti o nl\u1ecd si oke ti o da lori iye ascii. Ak\u1ecdsil\u1eb9: O y\u1eb9 ki o t\u1ecdju a\u1e63\u1eb9 ti aw\u1ecdn \u1ecdr\u1ecd ati aw\u1ecdn aaye ofo ni gbolohun naa. Fun ap\u1eb9\u1eb9r\u1eb9: anti_shuffle ((('Hi') pada 'Hi' anti_shuffle ((('hello') pada 'ehllo' anti_shuffle (('Hello World!!!') pada 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    O ti wa ni fifun a 2 dimensional data, bi a nested akoj\u1ecd, eyi ti o j\u1eb9 iru si matrix, sib\u1eb9sib\u1eb9, ko bi matrices, k\u1ecd\u1ecdkan ila le ni o ni o yat\u1ecd si n\u1ecdmba ti \u1ecdw\u1ecdn. Fi fun lst, ati odidi x, ri integers x ninu aw\u1ecdn akoj\u1ecd, ati ki o pada akoj\u1ecd ti tuples, [(x1, y1), (x2, y2)...] iru ti k\u1ecd\u1ecdkan tuple j\u1eb9 a ipoidojuko - (igbe, \u1ecdw\u1ecdn), b\u1eb9r\u1eb9 p\u1eb9lu 0.\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Ti a ba fun ni aw\u1ecdn n\u1ecdmba ti ko ni id\u1ecdti, pada \u1eb9da ti aw\u1ecdn ti a fun ni aw\u1ecdn l\u1eb9s\u1eb9s\u1eb9 l\u1eb9hin ti sis\u1ecd, iw\u1ecd yoo yan aw\u1ecdn ti a fun ni aw\u1ecdn l\u1eb9s\u1eb9s\u1eb9 ni ibere ti o ba ti aw\u1ecdn iye ((ni ak\u1ecdk\u1ecd iye at\u1ecdka, k\u1eb9hin iye at\u1ecdka) j\u1eb9 odd, tabi yan o ni ibere ti o ba ti aw\u1ecdn iye ((ni ak\u1ecdk\u1ecd iye at\u1ecdka, k\u1eb9hin iye at\u1ecdka) j\u1eb9 ani. Ak\u1ecdsil\u1eb9: * ma \u1e63e yi aw\u1ecdn ti a fun ni aw\u1ecdn l\u1eb9s\u1eb9s\u1eb9. Ap\u1eb9\u1eb9r\u1eb9: * sort_array[(]) => [] * sort_array[]] => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"\u1e62\u1eb9da i\u1e63\u1eb9 encrypt ti o gba okun bi ariyanjiyan ati pada okun ti o ni ifib\u1ecd p\u1eb9lu abuku ti o wa ni yiyi. Aw\u1ecdn abuku y\u1eb9 ki o wa ni yiyi ni \u1ecdna ti aw\u1ecdn l\u1eb9ta naa gbe l\u1ecd sil\u1eb9 nipas\u1eb9 meji ti o p\u1ecd si aw\u1ecdn aaye meji. Fun ap\u1eb9\u1eb9r\u1eb9: encrypt (('hi') pada 'lm' encrypt (('asdfghjkl') pada 'ewhjklnop' encrypt (('gf') pada 'kj' encrypt (('et') pada 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    O ti fun \u1ecd ni akoj\u1ecd aw\u1ecdn n\u1ecdmba odidi. K\u1ecd i\u1e63\u1eb9 next_smallest (() ti o pada si nkan keji ti o kere jul\u1ecd ninu akoj\u1ecd naa. Pada None ti ko ba si iru nkan b\u1eb9\u1eb9. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == Ko si next_smallest (([1, 1]) == Ko si\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    A \u00f3 f\u00fan \u1ecd n\u00ed \u00ecl\u00e0 \u00e0w\u1ecdn \u1ecd\u0300r\u1ecd\u0300, i\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti ka iye \u00e0w\u1ecdn \u00ecnira. \u00ccnira j\u1eb9\u0301 gb\u00f3l\u00f3h\u00f9n t\u00ed \u00f3 b\u1eb9\u0300r\u1eb9\u0300 p\u1eb9\u0300l\u00fa \u1ecd\u0300r\u1ecd\u0300 \"I\". \u00c0w\u1ecdn gb\u00f3l\u00f3h\u00f9n ni a fi '.', '?' t\u00e0b\u00ed '!' s\u00e1p\u00e1. B\u00ed \u00e0p\u1eb9\u1eb9r\u1eb9:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    K\u1ecd i\u1e63\u1eb9 ti o gba ifiran\u1e63\u1eb9 kan, ati \u1e63e akoj\u1ecdp\u1ecd ni \u1ecdna ti o \u1e63e iyipada aw\u1ecdn l\u1eb9ta ti gbogbo aw\u1ecdn l\u1eb9ta, r\u1ecdpo gbogbo aw\u1ecdn vowels ninu ifiran\u1e63\u1eb9 p\u1eb9lu l\u1eb9ta ti o han ni aw\u1ecdn aaye 2 niwaju vowel naa ni alfabeti G\u1eb9\u1eb9si. Gbigba aw\u1ecdn l\u1eb9ta nikan. Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"O ni a fun o kan akoj\u1ecd ti aw\u1ecdn integers. O nilo lati wa ni tobi ak\u1ecdk\u1ecd iye ati ki o pada aw\u1ecdn iye ti aw\u1ecdn oniwe-digits. apeere: Fun lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] aw\u1ecdn ohun elo ti o y\u1eb9 ki o wa 10 Fun lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] aw\u1ecdn ohun elo ti o y\u1eb9 ki o wa 25 Fun lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] aw\u1ecdn ohun elo ti o y\u1eb9 ki o wa 13 Fun lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] aw\u1ecdn ohun elo ti o y\u1eb9 ki o wa 11 Fun lst =\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Ti a ba fun \u1ecd\u0300r\u1ecd\u0300-\u00ecw\u00e9 kan, pada si Otit\u1ecd ti gbogbo aw\u1ecdn b\u1ecdtini ba j\u1eb9 aw\u1ecdn okun ni kekere tabi gbogbo aw\u1ecdn b\u1ecdtini ba j\u1eb9 aw\u1ecdn okun ni nla, bib\u1eb9k\u1ecd ti o pada si Ir\u1ecd. I\u1e63\u1eb9 naa y\u1eb9 ki o pada si Ir\u1ecd j\u1eb9 \u1ecdr\u1ecd-\u1ecdr\u1ecd ti a fun ni \u1e63ofo. Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) y\u1eb9 ki o pada si Otit\u1ecd. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) y\u1eb9 ki o pada si Ir\u1ecd. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) y\u1eb9 ki o pada si Ir\u1ecd. check_dict_case{\"oruk\u1ecd\":\"John\", \"\u1eccj\u1ecd\":\"36\",\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"\u1e62\u1eb9da i\u1e63\u1eb9 ti o gba n\u1ecdmba ti kii \u1e63e odi ati pada si aw\u1ecdn i\u1e63iro ti aw\u1ecdn n\u1ecdmba ak\u1ecdk\u1ecd ti o j\u1eb9 aw\u1ecdn n\u1ecdmba ak\u1ecdk\u1ecd ati kere ju n. fun ap\u1eb9\u1eb9r\u1eb9: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"pari i\u1e63\u1eb9 ti o gba aw\u1ecdn n\u1ecdmba odidi meji ati ki o pada aw\u1ecdn \u1ecdja ti w\u1ecdn sipo oni n\u1ecdmba. ro pe aw\u1ecdn tit\u1eb9si j\u1eb9 nigbagbogbo wulo. aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9: multiply(148, 412) y\u1eb9 ki o pada 16. multiply(19, 28) y\u1eb9 ki o pada 72. multiply(2020, 1851) y\u1eb9 ki o pada 0. multiply(14,-15) y\u1eb9 ki o pada 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Fun okun s, ka iye aw\u1ecdn vowels uppercase ni aw\u1ecdn at\u1ecdka paapaa. Fun ap\u1eb9\u1eb9r\u1eb9: count_upper (('aBCdEf') n pada 1 count_upper (('abcdefg') n pada 0 count_upper (('dBBE') n pada 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Fun iye kan ti o ni idaniloju n, o ni lati \u1e63e akoj\u1ecdp\u1ecd ti aw\u1ecdn ipele ti aw\u1ecdn okuta. ipele ak\u1ecdk\u1ecd ni aw\u1ecdn okuta n. n\u1ecdmba aw\u1ecdn okuta ni ipele ti o t\u1eb9le ni: - n\u1ecdmba ti o t\u1eb9le ti o t\u1eb9le ti o ba j\u1eb9 n j\u1eb9 odd. - n\u1ecdmba ti o t\u1eb9le ti o t\u1eb9le ti o ba j\u1eb9 n j\u1eb9 paapaa. pada n\u1ecdmba aw\u1ecdn okuta ni ipele k\u1ecd\u1ecdkan ninu akoj\u1ecd kan, nibiti eroja ni it\u1ecdka i \u1e63e a\u1e63oju n\u1ecdmba aw\u1ecdn okuta ni ipele (i + 1).\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    O ni a yoo fun \u1ecd ni a okun ti aw\u1ecdn \u1ecdr\u1ecd ya s\u1ecdt\u1ecd nipas\u1eb9 aw\u1ecdn commas tabi aw\u1ecdn aaye. r\u1eb9 ise ni lati pin aw\u1ecdn okun sinu aw\u1ecdn \u1ecdr\u1ecd ki o si pada ohun array ti aw\u1ecdn \u1ecdr\u1ecd. fun ap\u1eb9\u1eb9r\u1eb9: words_string ((\"Hi, oruk\u1ecd mi ni John\") == [\"Hi\", \"mi\", \"oruk\u1ecd\", \"ni\", \"John\"] words_string ((\"\u1ecckan, meji, m\u1eb9ta, m\u1eb9rin, marun, m\u1eb9fa\") == [\"\u1ecckan\", \"meji\", \"m\u1eb9ta\", \"m\u1eb9rin\", \"marun\", \"mefa\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"If\u00e1 y\u00ec\u00ed gba \u00e0w\u1ecdn iye t\u00f3 d\u00e1ra m\u00e9j\u00ec x \u00e0ti y \u00f3 s\u00ec d\u00e1 iye t\u00f3 t\u00f3bi j\u00f9l\u1ecd t\u00ed \u00f3 w\u00e0 n\u00edn\u00fa \u00e0l\u00e0fo [x, y] t\u00ed \u00f3 n\u00ed n\u00edn\u00fa. B\u00ed k\u00f2 b\u00e1 s\u00ed ir\u00fa iye b\u1eb9\u0301\u1eb9\u0300, n\u00edgb\u00e0 n\u00e1\u00e0 ni i\u1e63\u1eb9\u0301 n\u00e1\u00e0 y\u00f3\u00f2 d\u00e1 -1. B\u00ed \u00e0p\u1eb9\u1eb9r\u1eb9: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"A f\u00fan \u1ecd n\u00ed \u00e0w\u1ecdn \u00e0gb\u00e1ye m\u00e9j\u00ec t\u00ed \u00f3 j\u1eb9\u0301 \u00e0gb\u00e1ye n \u00e0ti m, i\u1e63\u1eb9\u0301 r\u1eb9\u0300 s\u00ec ni l\u00e1ti \u1e63e \u00e0r\u00f2p\u1ecd\u0300 \u00e0w\u1ecdn \u00e0gb\u00e1ye l\u00e1ti n d\u00e9 m (p\u1eb9\u0300l\u00fa n \u00e0ti m). y\u00ed \u00ecd\u00e1h\u00f9n n\u00e1\u00e0 k\u00e1 s\u00ed iye t\u00f3 s\u00fanm\u1ecd\u0301 \u1ecdn\u00e0 n\u00e1\u00e0, k\u00ed o s\u00ec y\u00ed i pad\u00e0 s\u00ed iye m\u00e9j\u00ec. b\u00ed n b\u00e1 t\u00f3bi ju m l\u1ecd, d\u00e1 -1. \u00c0p\u1eb9\u1eb9r\u1eb9: rounded_avg(1, 5) => \"0b11\" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => \"0b1111\" rounded_avg(20, => 33) \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Ti a fun ni akoj\u1ecd kan ti aw\u1ecdn n\u1ecdmba odidi rere x. pada akoj\u1ecd ti a \u1e63eto ti gbogbo aw\u1ecdn eroja ti ko ni eyikeyi n\u1ecdmba paapaa. Ak\u1ecdsil\u1eb9: Akoj\u1ecd ti a pada y\u1eb9 ki o wa ni tito l\u1eb9s\u1eb9s\u1eb9 ni il\u1ecdsiwaju. Fun ap\u1eb9\u1eb9r\u1eb9:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Fun aw\u1ecdn ti a ti fi fun a array ti aw\u1ecdn integers, yan aw\u1ecdn integers ti o wa laarin 1 ati 9 p\u1eb9lu, yipo aw\u1ecdn esi array, ati ki o si r\u1ecdpo k\u1ecd\u1ecdkan oni n\u1ecdmba nipa aw\u1ecdn oniwe-o baamu oruk\u1ecd lati \"\u1ecckan\", \"Meji\", \"M\u1eb9ta\", \"M\u1eb9rin\", \"Meje\", \"Mefa\", \"Meje\", \"M\u1eb9j\u1ecd\", \"M\u1eb9san\". Fun ap\u1eb9\u1eb9r\u1eb9: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> yan arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> tan arr -> [8, 5, 4, 3, 2, 2, 1, 1] pada [\"Eight\", \"Five\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"] Ti o ba ti aw\u1ecdn array j\u1eb9 ofo, a pada: arr = [] pada [] Ti o ba ti aw\u1ecdn array ni eyikeyi ajeji n\u1ecdmba foju r\u1eb9: yan arr =\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" \u1e62\u1eb9da i\u1e63\u1eb9 f ti o gba n bi paramita, ati pada akoj\u1ecd ti iw\u1ecdn n, iru pe iye ti eroja ni it\u1ecdka i j\u1eb9 factorial ti i ti o ba j\u1eb9 paapaa tabi iye aw\u1ecdn n\u1ecdmba lati 1 si i bib\u1eb9k\u1ecd. i b\u1eb9r\u1eb9 lati 1. factorial ti i ni isodipupo aw\u1ecdn n\u1ecdmba lati 1 si i (1 * 2 *... * i). Ap\u1eb9\u1eb9r\u1eb9: f ((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Fun a rere integer n, pada a tuple ti o ni aw\u1ecdn n\u1ecdmba ti ani ati odd integer palindromes ti o \u1e63ubu laarin aw\u1ecdn ibiti o ((1, n), p\u1eb9lu. Ap\u1eb9\u1eb9r\u1eb91: Input: 3 Output: (1, 2) \u00c0l\u00e0y\u00e9: Integer palindrome ni o wa 1, 2, 3. \u1ecdkan ninu w\u1ecdn ni o wa ani, ati meji ninu w\u1ecdn ni o wa odd. Ap\u1eb9\u1eb9r\u1eb92: Input: 12 Output: (4, 6) \u00c0l\u00e0y\u00e9: Integer palindrome ni o wa 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. m\u1eb9rin ninu w\u1ecdn ni o wa ani, ati 6 ninu w\u1ecdn ni o wa odd. Ak\u1ecdsil\u1eb9: 1. 1 <= n <= 10^3 2. tuple ti pada aw\u1ecdn n\u1ecdmba ti ani ati odd integer palindromes l\u1eb9s\u1eb9s\u1eb9.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    K\u1ecd i\u1e63\u1eb9 count_nums eyi ti o gba aw\u1ecdn i\u1e63iro ti aw\u1ecdn n\u1ecdmba odidi ati ki o pada aw\u1ecdn n\u1ecdmba ti aw\u1ecdn eroja ti o ni kan iye ti aw\u1ecdn oni n\u1ecdmba > 0. Ti o ba ti a n\u1ecdmba j\u1eb9 odi, ki o si aw\u1ecdn oniwe-ak\u1ecdk\u1ecd ami ami yoo j\u1eb9 odi: eg -123 ti a ti ami ami -1, 2, ati 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"A n\u00ed array 'arr' ti N integers arr[1], arr[2],..., arr[N].\u00c0w\u1ecdn n\u1ecd\u0301mb\u00e0 in\u00fa array n\u00e1\u00e0 ni a \u00f3 p\u00e0\u1e63\u1eb9 l\u1ecd\u0301n\u00e0 \u00e0b\u00e1y\u1ecd. I\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti m\u1ecd\u0300 b\u00f3y\u00e1 \u00f3 \u1e63e\u00e9 \u1e63e l\u00e1ti r\u00ed array t\u00ed a \u00f3 p\u00e0\u1e63\u1eb9 n\u00ed \u00f2p\u00f3 t\u00ed k\u00f2 d\u00ednk\u00f9 n\u00edpa \u1e63\u00ed\u1e63e \u00e0w\u1ecdn i\u1e63\u1eb9\u0301 t\u00ed \u00f3 t\u1eb9\u0300l\u00e9 l\u00f3r\u00ed array n\u00e1\u00e0: O gba \u1ecd l\u00e1y\u00e8 l\u00e1ti \u1e63e \u00e0w\u1ecdn i\u1e63\u1eb9\u0301 \u00ecy\u00edpad\u00e0 s\u00ed \u1ecd\u0300t\u00fan n\u00ed \u00ecgb\u00e0 m\u00e9l\u00f2\u00f3 kan. \u00ccy\u00edpad\u00e0 s\u00ed \u1ecd\u0300t\u00fan kan t\u00fam\u1ecd\u0300 s\u00ed y\u00edpad\u00e0 gbogbo \u00e0w\u1ecdn ohun t\u00f3 w\u00e0 n\u00edn\u00fa array n\u00e1\u00e0 n\u00ed ip\u00f2 kan n\u00ed \u1ecd\u0300n\u00e0 t\u00ed \u00f3 t\u1ecd\u0301. Ohun t\u00f3 k\u1eb9\u0301y\u00ecn n\u00edn\u00fa array n\u00e1\u00e0 ni a \u00f3 y\u00ed pad\u00e0 s\u00ed ip\u00f2 t\u00ed \u00f3 b\u1eb9\u0300r\u1eb9\u0300 n\u00edn\u00fa array n\u00e1\u00e0, \u00ecy\u1eb9n 0th index. B\u00ed \u00f3 b\u00e1 \u1e63e\u00e9 \u1e63e l\u00e1ti r\u00ed array t\u00ed a p\u00e0\u1e63\u1eb9 n\u00ed \u1e63\u00ed\u1e63e \u00e0w\u1ecdn i\u1e63\u1eb9\u0301 t\u00ed \u00f3 w\u00e0 l\u00f3k\u00e8 y\u00ec\u00ed, n\u00edgb\u00e0 n\u00e1\u00e0, pad\u00e0 s\u00ed True, n\u00edgb\u00e0\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"n\u00edn\u00fa \u00ec\u1e63\u00f2ro y\u00ec\u00ed, \u1eb9 \u00f3o \u1e63e \u00e0\u1e63epar\u00ed i\u1e63\u1eb9\u0301 t\u00ed \u00f3 gba \u00e0w\u1ecdn \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 iye m\u00e9j\u00ec, t\u00ed y\u00f3\u00f2 s\u00ec pinnu b\u00f3y\u00e1 \u00f3 \u1e63e\u00e9 \u1e63e l\u00e1ti \u1e63e p\u00e0\u1e63\u00edp\u00e0\u00e0r\u1ecd\u0300 \u00e0w\u1ecdn ohun kan l\u00e1\u00e0rin w\u1ecdn l\u00e1ti s\u1ecd lst1 di \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 iye kan t\u00ed \u00f3 j\u1eb9\u0301 iye kan. k\u00f2 s\u00ed \u00e0\u00e0l\u00e0 l\u00f3r\u00ed iye \u00e0w\u1ecdn ohun t\u00ed a p\u00e0\u1e63\u00edp\u00e0\u00e0r\u1ecd\u0300 l\u00e1\u00e0rin lst1 \u00e0ti lst2. b\u00ed \u00f3 b\u00e1 \u1e63e\u00e9 \u1e63e l\u00e1ti p\u00e0\u1e63\u00edp\u00e0\u00e0r\u1ecd\u0300 \u00e0w\u1ecdn ohun kan l\u00e1\u00e0rin lst1 \u00e0ti lst2 l\u00e1ti m\u00fa k\u00ed gbogbo \u00e0w\u1ecdn ohun t\u00ed \u00f3 w\u00e0 n\u00edn\u00fa lst1 j\u1eb9\u0301 iye kan, d\u00e1 \"YES\" pad\u00e0. b\u00ed b\u1eb9\u0301\u1eb9\u0300 k\u1ecd\u0301, d\u00e1 \"NO\" pad\u00e0. f\u00fan \u00e0p\u1eb9\u1eb9r\u1eb9: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" A gb\u00e0 p\u00e9 \u00e0w\u1ecdn\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Ti a ba fun \u1ecd ni okun ti o \u1e63e a\u1e63oju aw\u1ecdn l\u1eb9ta kekere ti a pin si aaye, pada \u1ecdr\u1ecd-\u1ecdr\u1ecd ti l\u1eb9ta p\u1eb9lu atunwi pup\u1ecd jul\u1ecd ati ti o ni n\u1ecdmba ti o baamu. Ti aw\u1ecdn l\u1eb9ta pup\u1ecd ba ni i\u1e63\u1eb9l\u1eb9 kanna, pada gbogbo w\u1ecdn. Ap\u1eb9\u1eb9r\u1eb9: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4}': histogram (((')) == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"I\u1e63\u1eb9\u0301 A f\u00fan wa n\u00ed \u00e0w\u1ecdn \u00ecl\u00e0 m\u00e9j\u00ec s \u00e0ti c, o n\u00ed l\u00e1ti pa gbogbo \u00e0w\u1ecdn \u00e0m\u00ec n\u00edn\u00fa s t\u00ed \u00f3 b\u00e1 d\u1ecd\u0301gba s\u00ed \u00e0w\u1ecdn \u00e0m\u00ec n\u00edn\u00fa c l\u1eb9\u0301y\u00ecn n\u00e1\u00e0 \u1e63\u00e0y\u1eb9\u0300w\u00f2 b\u00f3y\u00e1 \u00ecl\u00e0 t\u00ed \u00f3 j\u1eb9\u0301 \u00e0b\u00e1j\u00e1de j\u1eb9\u0301 palindrome. \u00ccl\u00e0 ni a p\u00e8 n\u00ed palindrome b\u00ed \u00f3 b\u00e1 k\u00e0 b\u00e1kan n\u00e1\u00e0 s'\u00f3j\u00fa \u1ecd\u0300t\u00fan \u00e0ti s'\u00f3j\u00fa \u00f2s\u00ec. O y\u1eb9 k\u00ed o d\u00e1 tuple t\u00ed \u00f3 n\u00ed \u00ecl\u00e0 t\u00ed \u00f3 j\u1eb9\u0301 \u00e0b\u00e1j\u00e1de \u00e0ti True\/False pad\u00e0 f\u00fan \u00e0y\u1eb9\u0300w\u00f2 n\u00e1\u00e0. \u00c0p\u1eb9\u1eb9r\u1eb9 f\u00fan s = \"abcde\", c = \"ae\", \u00e0b\u00e1j\u00e1de n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9 ('bcd', False) f\u00fan s = \"abcdef\", c = \"b\" \u00e0b\u00e1j\u00e1de n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 ('acdef', False) f\u00fan s = \"abcdedcba\", c = \"ab\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Fun akoj\u1ecd aw\u1ecdn okun, nibi ti okun k\u1ecd\u1ecdkan ti wa ni aw\u1ecdn n\u1ecdmba nikan, pada akoj\u1ecd kan. K\u1ecd\u1ecdkan eroja i ti i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 \"n\u1ecdmba aw\u1ecdn eroja ti ko ni iyat\u1ecd ninu okun i ti ohun elo. \" nibi ti gbogbo aw\u1ecdn i y\u1eb9 ki o r\u1ecdpo nipas\u1eb9 n\u1ecdmba aw\u1ecdn n\u1ecdmba ti ko ni iyat\u1ecd ninu okun i'th ti ohun elo.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Ti a ba fun ni aw\u1ecdn n\u1ecdmba ti aw\u1ecdn n\u1ecdmba, wa iye ti o kere jul\u1ecd ti eyikeyi aw\u1ecdn n\u1ecdmba ti ko ni ofo. Ap\u1eb9r\u1eb9 minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    O ti wa ni fi fun a onigun m\u1eb9rin grid ti aw\u1ecdn daradara. k\u1ecd\u1ecdkan ila duro fun a nikan daradara, ati k\u1ecd\u1ecdkan 1 ni a ila duro fun a nikan kan sipo ti omi. k\u1ecd\u1ecdkan daradara ni o ni kan ti o baamu bucket ti o le \u1e63ee lo lati ya omi lati o, ati gbogbo aw\u1ecdn buckets ni o ni aw\u1ecdn kanna agbara. r\u1eb9 ise ni lati lo aw\u1ecdn buckets lati \u1e63ofo aw\u1ecdn daradara. Orisun aw\u1ecdn n\u1ecdmba ti igba ti o nilo lati isal\u1eb9 aw\u1ecdn buckets. Ap\u1eb9\u1eb9r\u1eb9 1: Input: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Orisun: 62: Input: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Orisun: 53: Ap\u1eb9\u1eb9r\u1eb9: Input: [[:0,0,0], [\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Ninu Kata yii, o ni lati yan aw\u1ecdn n\u1ecdmba ti ko ni id\u1ecdti g\u1eb9g\u1eb9bi n\u1ecdmba aw\u1ecdn kan ninu a\u1e63oju meji w\u1ecdn ni a\u1e63\u1eb9 ti o nl\u1ecd. Fun n\u1ecdmba ti o j\u1ecdra ti aw\u1ecdn kan, yan da lori iye iye. O gb\u1ecdd\u1ecd wa ni imuse bi eleyi:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Ti a fun \u1ecd ni okun s ati n\u1ecdmba adayeba n, a ti fi \u1ecd si i\u1e63\u1eb9 kan ti o pada akoj\u1ecd kan ti gbogbo aw\u1ecdn \u1ecdr\u1ecd lati okun s ti o ni aw\u1ecdn ohun kik\u1ecd gangan n, ni ibere pe aw\u1ecdn \u1ecdr\u1ecd w\u1ecdnyi han ninu okun s. Ti okun s ba \u1e63ofo l\u1eb9hinna i\u1e63\u1eb9 naa y\u1eb9 ki o pada akoj\u1ecd kan ti o \u1e63ofo. Ak\u1ecdsil\u1eb9: o le ro pe okun tit\u1eb9 ti o ni aw\u1ecdn l\u1eb9ta ati aw\u1ecdn aaye nikan. Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9: select_words ((\"Mary had a little lamb\", 4) ==> [\"little\"] select_words ((\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words\" (((simple white space\", 2) ==> [] select_words ((\"Hello world\", 4) ==> [\"world\"] select_words ((\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"O ti fi \u1ecd\u0300r\u1ecd\u0300 kan. I\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti w\u00e1 oh\u00f9n t\u00f3 s\u00fanm\u1ecd\u0301 ara r\u1eb9 j\u00f9l\u1ecd t\u00ed \u00f3 w\u00e0 l\u00e1\u00e0rin \u00e0w\u1ecdn \u00f2\u01f9k\u00e0 oh\u00f9n m\u00e9j\u00ec l\u00e1ti ap\u00e1 \u1ecd\u0300t\u00fan \u1ecd\u0300r\u1ecd\u0300 n\u00e1\u00e0 (\u00ecm\u1ecd\u0300r\u00e0n n\u00edpa \u1ecd\u0300r\u1ecd\u0300-\u00ecm\u1ecd\u0300r\u00e0n). \u00c0w\u1ecdn oh\u00f9n-\u00ecm\u1ecd\u0300r\u00e0n n\u00ed \u00ecb\u1eb9\u0300r\u1eb9\u0300 \u00e0ti \u00f2pin k\u00f2 k\u00e0. Y\u00ed \u00f2\u01f9k\u00e0 t\u00ed k\u00f2 n\u00ed \u00e0l\u00e0fo pad\u00e0 b\u00ed o k\u00f2 b\u00e1 r\u00ed oh\u00f9n-\u00ecm\u1ecd\u0300r\u00e0n kankan t\u00ed \u00f3 b\u00e1 p\u00e0d\u00e9 ip\u00f2 t\u00ed \u00f3 w\u00e0 l\u00f3k\u00e8 y\u00ec\u00ed. O l\u00e8 r\u00f2 w\u00edp\u00e9 \u00f2\u01f9k\u00e0 t\u00ed a f\u00fan n\u00ed l\u00e9d\u00e8 G\u1eb9\u0300\u1eb9\u0301s\u00ec n\u00eckan. \u00c0p\u1eb9\u1eb9r\u1eb9: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"UULL\" get_closest_vowel (((\"quick\") ==\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Fun a array ti aw\u1ecdn n\u1ecdmba odidi ati kan rere odidi k, pada a ti yan akoj\u1ecd ti ipari k p\u1eb9lu aw\u1ecdn ti o p\u1ecdju k aw\u1ecdn n\u1ecdmba ni arr. Ap\u1eb9\u1eb9r\u1eb91: Wiw\u1ecdle: arr = [-3, -4, 5], k = 3 Orisun: [-4, -3, 5] Ap\u1eb9\u1eb9r\u1eb92: Wiw\u1ecdle: arr = [4, -4, 4], k = 2 Orisun: [4, 4] Ap\u1eb9\u1eb9r\u1eb93: Wiw\u1ecdle: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Orisun: [2] Ak\u1ecdsil\u1eb9: 1. Aw\u1ecdn ipari ti aw\u1ecdn array yoo wa ni aw\u1ecdn ibiti o ti [1, 1000]. 2. aw\u1ecdn eroja ninu aw\u1ecdn array yoo wa ni aw\u1ecdn ibiti o ti [-1000, 1000]. 3. 0 <= k <= len ((arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Ti a ba fun ni akoj\u1ecd ti ko ni ofo ti aw\u1ecdn n\u1ecdmba odidi, pada ni iye ti gbogbo aw\u1ecdn eroja ti o ni aw\u1ecdn ipo paapaa. Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9 ojutu (([5, 8, 7, 1]) ==> 12 ojutu (([3, 3, 3, 3, 3]) ==> 9 ojutu (([30, 13, 24, 321]) ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Fun a ti kii-fowo ti aw\u1ecdn integer arr ati kan integer k, pada aw\u1ecdn iye ti aw\u1ecdn eroja p\u1eb9lu ni o kere meji aw\u1ecdn oni n\u1ecdmba lati aw\u1ecdn ak\u1ecdk\u1ecd k eroja ti arr. Ap\u1eb9\u1eb9r\u1eb9: Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Output: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    f\u00fan iye kan n, fi \u00e0t\u00f2j\u1ecd t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn iye t\u00ed k\u00f2 d\u1ecd\u0301gba s\u00edn\u00fa \u00ect\u00f2l\u1eb9\u0301s\u1eb9\u1eb9s\u1eb9 collatz. \u00ecr\u00f2ye collatz j\u1eb9\u0301 \u00e0t\u00f2j\u1ecd n\u00edn\u00fa \u00ec\u1e63ir\u00f2 t\u00ed \u00f3 n\u00ed \u00ed \u1e63e p\u1eb9\u0300l\u00fa \u00ect\u00f2l\u1eb9\u0301s\u1eb9\u1eb9s\u1eb9 t\u00ed a \u1e63e \u00e0l\u00e0y\u00e9 r\u1eb9\u0300 b\u00e1y\u00ec\u00ed: b\u1eb9\u0300r\u1eb9\u0300 p\u1eb9\u0300l\u00fa iye t\u00f3 d\u1ecd\u0301gba n. l\u1eb9\u0301y\u00ecn n\u00e1\u00e0 a gba gbogbo \u00ecr\u00f2ye l\u00e1ti \u00ecr\u00f2ye t\u00f3 \u1e63\u00e1\u00e1j\u00fa b\u00ed \u00e8y\u00ed: b\u00ed \u00ecr\u00f2ye t\u00f3 \u1e63\u00e1\u00e1j\u00fa b\u00e1 j\u1eb9\u0301 p\u00e1r\u00e0, \u00ecr\u00f2ye t\u00f3 t\u1eb9\u0300l\u00e9 e j\u1eb9\u0301 \u00ecdaj\u00ec \u00ecr\u00f2ye t\u00f3 \u1e63\u00e1\u00e1j\u00fa. b\u00ed \u00ecr\u00f2ye t\u00f3 \u1e63\u00e1\u00e1j\u00fa b\u00e1 j\u1eb9\u0301 al\u00e1\u00ecl\u00f3\u01f9k\u00e0, \u00ecr\u00f2ye t\u00f3 t\u1eb9\u0300l\u00e9 e j\u1eb9\u0301 \u00ecl\u00f3\u01f9k\u00e0 3 ti \u00ecr\u00f2ye t\u00f3 \u1e63\u00e1\u00e1j\u00fa p\u1eb9\u0300l\u00fa 1. \u00ecr\u00f2ye n\u00e1\u00e0 ni p\u00e9 l\u00e1\u00ecka iye n t\u00f3 j\u1eb9\u0301, \u00ect\u00f2l\u1eb9\u0301s\u1eb9\u1eb9s\u1eb9 n\u00e1\u00e0 y\u00f3\u00f2 d\u00e9 1. \u00e0\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"O n\u00ed l\u00e1ti k\u1ecd i\u1e63\u1eb9\u0301 t\u00ed \u00f3 \u1e63\u00e8t\u1eb9\u0301w\u1ecd\u0301gb\u00e0 \u00ecl\u00e0 \u1ecdj\u1ecd\u0301 kan t\u00ed \u00f3 s\u00ec pad\u00e0 s\u00ed \u00d2\u00f3t\u1ecd\u0301 b\u00ed \u1ecdj\u1ecd\u0301 n\u00e1\u00e0 b\u00e1 \u1e63e t\u1ecd\u0301 t\u00e0b\u00ed \u00c8k\u00e9. \u1ecc\u0300n\u00e0 t\u00ed \u1ecdj\u1ecd\u0301 n\u00e1\u00e0 gb\u00e0 t\u1ecd\u0301 ni p\u00e9 gbogbo \u00f2fin t\u00f3 w\u00e0 n\u00eds\u00e0l\u1eb9\u0300 y\u00ec\u00ed ni \u00f3 t\u1eb9\u0300l\u00e9: 1. \u00ccl\u00e0 \u1ecdj\u1ecd\u0301 n\u00e1\u00e0 k\u00f2 n\u00ed j\u1eb9\u0301 \u00f2fo. 2. Iye \u1ecdj\u1ecd\u0301 k\u00f2 d\u00edn n\u00ed 1 t\u00e0b\u00ed ju 31 \u1ecdj\u1ecd\u0301 l\u1ecd f\u00fan o\u1e63\u00f9 1,3,5,7,8,10,12. \u00c0ti p\u00e9 iye \u1ecdj\u1ecd\u0301 k\u00f2 d\u00edn n\u00ed 1 t\u00e0b\u00ed ju 30 \u1ecdj\u1ecd\u0301 l\u1ecd f\u00fan o\u1e63\u00f9 4,6,9,11. \u00c0ti p\u00e9, iye \u1ecdj\u1ecd\u0301 k\u00f2 d\u00edn n\u00ed 1 t\u00e0b\u00ed ju 29 l\u1ecd f\u00fan o\u1e63\u00f9 2. 3. \u00c0w\u1ecdn o\u1e63\u00f9 k\u00f2 gb\u1ecdd\u1ecd\u0300 d\u00edn n\u00ed 1 t\u00e0b\u00ed ju 12. 4. \u1ecc\u0300n\u00e0 t\u00ed \u1ecdj\u1ecd\u0301 n\u00e1\u00e0 gb\u00e0 y\u1eb9 k\u00ed \u00f3 w\u00e0 ni: mm-dd-yyyy b\u00ed \u00e0p\u1eb9\u1eb9r\u1eb9: valid_date (('03-11-2000') => True_valid_date (('15-0\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"A f\u00fan \u1ecd n\u00ed \u00e0l\u00e0fo m\u00e9j\u00ec, n\u00edbi t\u00ed \u00e0l\u00e0fo k\u1ecd\u0300\u1ecd\u0300kan j\u1eb9\u0301 \u00ecj\u00e1p\u1ecd\u0300 \u00e0w\u1ecdn iye \u00e0pap\u1ecd\u0300. \u00c0p\u1eb9\u1eb9r\u1eb9, \u00e0l\u00e0fo = (\u00ecb\u1eb9\u0300r\u1eb9\u0300, \u00f2pin) = (1, 2). \u00c0l\u00e0fo t\u00ed a f\u00fan wa ni a ti pa, \u00e8y\u00ed t\u00fam\u1ecd\u0300 s\u00ed p\u00e9 \u00e0l\u00e0fo (\u00ecb\u1eb9\u0300r\u1eb9\u0300, \u00f2pin) n\u00ed \u00ecb\u1eb9\u0300r\u1eb9\u0300 \u00e0ti \u00f2pin. f\u00fan \u00e0l\u00e0fo k\u1ecd\u0300\u1ecd\u0300kan, a gb\u00e0 p\u00e9 \u00ecb\u1eb9\u0300r\u1eb9\u0300 r\u1eb9\u0300 k\u00e9r\u00e9 s\u00ed t\u00e0b\u00ed d\u1ecd\u0301gba s\u00ed \u00f2pin r\u1eb9\u0300. I\u1e63\u1eb9\u0301 r\u1eb9\u0300 ni l\u00e1ti m\u1ecd\u0300 b\u00f3y\u00e1 g\u00edg\u00f9n \u00e0l\u00e0fo m\u00e9j\u00e8\u00e8j\u00ec y\u00ec\u00ed j\u1eb9\u0301 iye \u00e0k\u1ecd\u0301k\u1ecd\u0301. \u00c0p\u1eb9\u1eb9r\u1eb9, \u00ecsop\u1ecd\u0300 \u00e0l\u00e0fo (1, 3), (2, 4) j\u1eb9\u0301 (2, 3) t\u00ed g\u00edg\u00f9n r\u1eb9\u0300 j\u1eb9\u0301 1, t\u00ed k\u00ec \u00ed \u1e63e iye \u00e0k\u1ecd\u0301k\u1ecd\u0301. B\u00ed g\u00edg\u00f9n \u00e0l\u00e0\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    O ti fun \u1ecd ni aw\u1ecdn n\u1ecdmba ar\u1ecd ti o ni iye ati pe o nilo lati pada ni iye ti aw\u1ecdn titobi ti aw\u1ecdn n\u1ecdmba gbogbo ti o p\u1ecd nipas\u1eb9 \u1ecdja ti gbogbo aw\u1ecdn ami ti n\u1ecdmba k\u1ecd\u1ecdkan ninu aw\u1ecdn i\u1e63iro, ti o \u1e63e a\u1e63oju nipas\u1eb9 1, -1 tabi 0. Ak\u1ecdsil\u1eb9: pada Ko si fun ar\u1ecd ti o \u1e63ofo. Ap\u1eb9\u1eb9r\u1eb9:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    O le b\u1eb9r\u1eb9 lati eyikeyi s\u1eb9\u1eb9li, ati ni k\u1ecd\u1ecdkan igbese ti o le gbe si eyikeyi ti aw\u1ecdn aladugbo s\u1eb9\u1eb9li, ni aw\u1ecdn \u1ecdr\u1ecd miiran, o le l\u1ecd si eyikeyi aw\u1ecdn s\u1eb9\u1eb9li ti o pin eti p\u1eb9lu r\u1eb9 l\u1ecdw\u1ecdl\u1ecdw\u1ecd s\u1eb9\u1eb9li. J\u1ecdw\u1ecd \u1e63e akiyesi pe \u1ecdna ti ipari k tum\u1ecd si lil\u1ecd si gangan k aw\u1ecdn s\u1eb9\u1eb9li (ko \u1e63e dandan yat\u1ecd). O KO LE l\u1ecd kuro ni grid. A \u1ecdna A (ti ipari k) ni a k\u00e0 kere ju \u1ecdna B (ti ipari k) ti o ba l\u1eb9hin \u1e63i\u1e63e aw\u1ecdn akoj\u1ecd ti a pa\u1e63\u1eb9 ti aw\u1ecdn iye lori aw\u1ecdn s\u1eb9\u1eb9li ti A ati B (j\u1eb9 ki a pe w\u1ecdn lA_st ati lA_stB), lA_stB j\u1eb9 lexically kere ju lA_stB, ni aw\u1ecdn \u1ecdr\u1ecd miiran, a le l\u1ecd si eyikeyi aw\u1ecdn s\u1eb9\u1eb9li aladugbo, ni aw\u1ecdn \u1ecdr\u1ecd miiran, a le l\u1ecd si eyikeyi aw\u1ecdn s\u1eb9\u1eb9li ti o ni\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Gbogbo \u00e8n\u00ecy\u00e0n m\u1ecd\u0300 n\u00edpa \u00ect\u00f2l\u1eb9\u0301s\u1eb9\u1eb9s\u1eb9 fibonacci, \u00e0w\u1ecdn on\u00edm\u1ecd\u0300 \u00ec\u1e63ir\u00f2 ti k\u1eb9\u0301k\u1ecd\u0300\u1ecd\u0301 r\u1eb9\u0300 jinl\u1eb9\u0300 n\u00ed \u00e0w\u1ecdn \u1ecdg\u1ecd\u0301r\u00f9n-\u00fan \u1ecdd\u00fan m\u00e9j\u00ec t\u00f3 k\u1ecdj\u00e1. \u1e63\u00f9gb\u1ecd\u0301n, ohun t\u00ed \u00e0w\u1ecdn \u00e8n\u00ecy\u00e0n k\u00f2 m\u1ecd\u0300 ni \u00ect\u00f2l\u1eb9\u0301s\u1eb9\u1eb9s\u1eb9 tribonacci. \u00ect\u00f2l\u1eb9\u0301s\u1eb9\u1eb9s\u1eb9 tribonacci ni a \u1e63e \u00e0l\u00e0y\u00e9 n\u00edpa \u00e0t\u00fan\u1e63e: tri(1) = 3 tri(n) = 1 + n \/ 2, b\u00ed n b\u00e1 j\u1eb9\u0301 p\u00e1r\u00e0. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), b\u00ed n b\u00e1 j\u1eb9\u0301 al\u00e1\u00ecl\u00f3\u01f9k\u00e0. f\u00fan \u00e0p\u1eb9\u1eb9r\u1eb9: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 a f\u00fan \u1ecd n\u00ed iye t\u00ed k\u00f2 j\u1eb9\u0301 \u00e8\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Fun n\u1ecdmba kan ti o ni idunnu n, pada si \u1ecdja ti aw\u1ecdn n\u1ecdmba ti o ni iyat\u1ecd. Pada 0 ti gbogbo aw\u1ecdn n\u1ecdmba ba j\u1eb9 paapaa. Fun ap\u1eb9\u1eb9r\u1eb9: aw\u1ecdn n\u1ecdmba ((1) == 1 aw\u1ecdn n\u1ecdmba ((4) == 0 aw\u1ecdn n\u1ecdmba ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"O ti wa ni fi fun o kan akoj\u1ecd ti aw\u1ecdn n\u1ecdmba. O nilo lati pada aw\u1ecdn akoj\u1ecdp\u1ecd ti square aw\u1ecdn n\u1ecdmba ninu aw\u1ecdn fun akoj\u1ecd, yika k\u1ecd\u1ecdkan eroja ninu aw\u1ecdn akoj\u1ecd to oke int ((Ipele) ak\u1ecdk\u1ecd. Ap\u1eb9\u1eb9r\u1eb9: Fun lst = [1,2,3] aw\u1ecdn ti o jade y\u1eb9 ki o j\u1eb9 14 Fun lst = [1,4,9] aw\u1ecdn ti o jade y\u1eb9 ki o j\u1eb9 98 Fun lst = [1,3,5,7] aw\u1ecdn ti o jade y\u1eb9 ki o j\u1eb9 84 Fun lst = [1.4,4.2,0] aw\u1ecdn ti o jade y\u1eb9 ki o j\u1eb9 29 Fun lst = [-2.4,1,1] aw\u1ecdn ti o jade y\u1eb9 ki o j\u1eb9 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"\u1e62\u1eb9da i\u1e63\u1eb9 kan ti o pada aw\u1ecdn tobi it\u1ecdka ti ohun kan ti o j\u1eb9 ko tobi ju tabi dogba si aw\u1ecdn ohun kan l\u1eb9s\u1eb9k\u1eb9s\u1eb9 \u1e63aaju ki o to. Ti ko ba si iru ohun kan ti o wa l\u1eb9hinna pada -1. aw\u1ecdn ti a fi fun array yoo ko ni aw\u1ecdn iye duplicate. Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    \u1e62\u1eb9da i\u1e63\u1eb9 kan ti o gba aw\u1ecdn n\u1ecdmba odidi, aw\u1ecdn floats, tabi aw\u1ecdn okun ti o \u1e63e a\u1e63oju aw\u1ecdn n\u1ecdmba gidi, ati pada aw\u1ecdn oniwe-nla ti o tobi ni iru iyipada ti a fun. Pada None ti aw\u1ecdn iye ba j\u1eb9 dogba. Ak\u1ecdsil\u1eb9: Ti a ba \u1e63e a\u1e63oju n\u1ecdmba gidi bi okun, aaye iy\u1eb9wu le j\u1eb9. tabi, compare_one, 2.5) \u00e2 -> 2.5 compare_one, \"2,3\") \u00e2 -> \"2,3\" compare_one, \"5,1\", \"6\") \u00e2 -> \"6\" compare_one, \"1\", 1) \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"\u1e62e ay\u1eb9wo boya n\u1ecdmba ti a fun n le k\u1ecd bi idap\u1ecd ti aw\u1ecdn n\u1ecdmba paapaa rere 4 gangan Ap\u1eb9\u1eb9r\u1eb9 j\u1eb9_id\u1ecdgba_si_id\u1ecdgba_ti o d\u1ecdgba (a) == False j\u1eb9_id\u1ecdgba_si_id\u1ecdgba (a) == False j\u1eb9_id\u1ecdgba_ti o d\u1ecdgba (a) == True\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"A \u1e63e \u00e0l\u00e0y\u00e9 \u00ecs\u1ecd\u0300r\u00ed Brazil b\u00ed: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! n\u00edbi t\u00ed n > 0 B\u00ed \u00e0p\u1eb9\u1eb9r\u1eb9:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Ti a ba fun \u1ecd ni \u1ecdr\u1ecd okun, r\u1ecdpo gbogbo aw\u1ecdn aaye ninu r\u1eb9 p\u1eb9lu aw\u1ecdn aami kekere, ati pe ti okun ba ni aw\u1ecdn aaye ti o ju 2 l\u1ecd, l\u1eb9hinna r\u1ecdpo gbogbo aw\u1ecdn aaye ti o t\u1eb9le p\u1eb9lu - fix_spaces ((\"Aya\") == \"Aya\" fix_spaces (((\"Aya1\") == \"Aya1\") fix_spaces (((\"Aya2\") == \"Aya2\") fix_spaces (((\"Aya 3\") == \"Aya-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"\u1e62\u1eb9da i\u1e63\u1eb9 ti o gba okun ti o \u1e63e a\u1e63oju oruk\u1ecd faili kan, o si pada 'B\u1eb9\u1eb9ni' ti oruk\u1ecd faili ba wulo, o si pada 'B\u1eb9b\u1eb9' bib\u1eb9k\u1ecd. A k\u00e0 oruk\u1ecd faili kan si wulo ti o ba j\u1eb9 pe ati nikan ti gbogbo aw\u1ecdn ipo w\u1ecdnyi ba pade: - Ko y\u1eb9 ki o wa ju aw\u1ecdn n\u1ecdmba m\u1eb9ta l\u1ecd ('0'-'9') ni oruk\u1ecd faili naa. - Oruk\u1ecd faili naa ni o ni gangan kan dot '.' - Aw\u1ecdn substring \u1e63aaju ki o to dot y\u1eb9 ki o ko ni \u1e63ofo, ati pe o b\u1eb9r\u1eb9 p\u1eb9lu l\u1eb9ta lati inu alfabeti Latin ('a'-'z' ati 'A'Z'). - Aw\u1ecdn substring l\u1eb9hin ti dot y\u1eb9 ki o j\u1eb9 \u1ecdkan ninu aw\u1ecdn w\u1ecdnyi: ['txt', 'exe', 'll'd'] Ap\u1eb9\u1eb9r\u1eb9: file_name_check\"(example.txt\") # => 'B\u1eb9\u1eb9ni' file_name_\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\"\u00ec\u1e63ir\u00f2 y\u00ec\u00ed y\u00f3\u00f2 gba \u00e0k\u00f3j\u1ecd \u00e0w\u1ecdn iye t\u00ed \u00f3 w\u00e0 n\u00edn\u00fa \u00e0k\u00f3j\u1ecd n\u00e1\u00e0. f\u00fan gbogbo \u00e0w\u1ecdn \u00e0k\u1ecds\u00edl\u1eb9\u0300 in\u00fa \u00e0k\u00f3j\u1ecd n\u00e1\u00e0, i\u1e63\u1eb9\u0301 n\u00e1\u00e0 y\u00f3\u00f2 fi \u00e0l\u00e9b\u00e0b\u00e0 \u00e0l\u00e9b\u00e0 t\u00ed \u00f3 b\u00e1 j\u1eb9\u0301 \u00ecd\u00ecp\u1ecd\u0300 3 s\u00edl\u00e9, y\u00f3\u00f2 s\u00ec fi \u00e0l\u00e9b\u00e0 \u00e0l\u00e9b\u00e0 t\u00ed \u00f3 b\u00e1 j\u1eb9\u0301 \u00ecd\u00ecp\u1ecd\u0300 4 s\u00edl\u00e9. i\u1e63\u1eb9\u0301 n\u00e1\u00e0 k\u00f2 n\u00ed y\u00ed \u00e0w\u1ecdn \u00e0k\u1ecds\u00edl\u1eb9\u0300 in\u00fa \u00e0k\u00f3j\u1ecd t\u00ed \u00e0w\u1ecdn \u00ecd\u00ecp\u1ecd\u0300 w\u1ecdn k\u00f2 j\u1eb9\u0301 \u00ecd\u00ecp\u1ecd\u0300 3 t\u00e0b\u00ed 4. i\u1e63\u1eb9\u0301 n\u00e1\u00e0 y\u00f3\u00f2 w\u00e1 d\u00e1 \u00e0pap\u1ecd\u0300 gbogbo \u00e0k\u1ecds\u00edl\u1eb9\u0300 pad\u00e0. \u00e0p\u1eb9\u1eb9r\u1eb9: f\u00fan lst = [1,2,3] \u00ecj\u00e1de n\u00e1\u00e0 y\u00f3\u00f2 j\u1eb9\u0301 6 f\u00fan lst = [] \u00ecj\u00e1de n\u00e1\u00e0 y\u00f3\u00f2 j\u1eb9\u0301 0 f\u00fan lst = [-1,-5,2,-1,-5] \u00ecj\u00e1de n\u00e1\u00e0 y\u00f3\u00f2 j\u1eb9\u0301 -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    O ti wa ni fifun a okun ti o duro fun a gbolohun, aw\u1ecdn gbolohun ni o ni di\u1eb9 ninu aw\u1ecdn \u1ecdr\u1ecd ya s\u1ecdt\u1ecd nipas\u1eb9 a aaye, ati aw\u1ecdn ti o ni lati pada a okun ti o ni aw\u1ecdn \u1ecdr\u1ecd lati aw\u1ecdn atil\u1eb9ba gbolohun, ti aw\u1ecdn ipari ti wa ni ak\u1ecdk\u1ecd aw\u1ecdn n\u1ecdmba, aw\u1ecdn a\u1e63\u1eb9 ti aw\u1ecdn \u1ecdr\u1ecd ninu aw\u1ecdn titun okun y\u1eb9 ki o j\u1eb9 kanna bi aw\u1ecdn atil\u1eb9ba \u1ecdkan. Example1: Input: gbolohun = \"Eyi ni a igbeyewo\" Output: \"ni\" Example2: Input: gbolohun = \"j\u1eb9 ki l\u1ecd fun swimming\" Output: \"l\u1ecd fun\" Iw\u1ecdn: * 1 <= len(sentence) <= 100 * gbolohun ni o ni aw\u1ecdn l\u1eb9ta nikan\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"I\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti \u1e63e i\u1e63\u1eb9\u0301 kan t\u00ed y\u00f3\u00f2 m\u00fa k\u00ed \u00ectum\u1ecd\u0300 x * n r\u1ecdr\u00f9n. I\u1e63\u1eb9\u0301 n\u00e1\u00e0 y\u00f3\u00f2 d\u00e1 True pad\u00e0 b\u00ed x * n b\u00e1 \u1e63e \u00e0gb\u00e9y\u00e8\u0323w\u00f2 s\u00ed iye kan t\u00ed \u00f3 j\u1eb9\u0301 odidi \u00e0ti False b\u00ed k\u00f2 b\u00e1 \u1e63e b\u1eb9\u0301\u1eb9\u0300. \u00c0w\u1ecdn m\u00e9j\u00e8\u00e8j\u00ec, x \u00e0ti n, j\u1eb9\u0301 \u00ecl\u00e0 \u00ecfih\u00e0n ti \u00ecp\u00edn kan, t\u00ed w\u1ecd\u0301n s\u00ec n\u00ed \u00e0d\u00e0k\u1ecd t\u00ed \u00f3 t\u1eb9\u0300l\u00e9, <numerator>\/<denominator> n\u00edbi t\u00ed \u00e0w\u1ecdn m\u00e9j\u00e8\u00e8j\u00ec, ol\u00f9ka \u00e0ti ol\u00f9k\u00f3r\u00fak\u1ecd j\u1eb9\u0301 \u00e0w\u1ecdn iye odidi t\u00ed \u00f3 j\u1eb9\u0301 \u00e8r\u00e8. O l\u00e8 gb\u00e0 p\u00e9 x, \u00e0ti n j\u1eb9\u0301 \u00e0w\u1ecdn \u00ecp\u00edn t\u00f3 b\u00e1 a mu, t\u00ed w\u1ecdn k\u00f2 s\u00ec n\u00ed z\u00e9r\u00f2 g\u1eb9\u0301g\u1eb9\u0301 b\u00ed ol\u00f9k\u00f3r\u00fak\u1ecd. simplify \" 1\/5\", \"5\/1\") = True simplify \" 1\/6\", \"2\/1\") = False simplify \" 7\/10\", \"10\/2\")\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    K\u1ecd i\u1e63\u1eb9 kan ti o \u1e63e akoj\u1ecd aw\u1ecdn akoj\u1ecd ti a fun ti aw\u1ecdn n\u1ecdmba ni a\u1e63\u1eb9 ti o p\u1ecd si g\u1eb9g\u1eb9bi iye ti aw\u1ecdn oniwe-n\u1ecdmba w\u1ecdn. Ak\u1ecdsil\u1eb9: ti o ba wa ni aw\u1ecdn ohun kan p\u1eb9lu iye kanna ti aw\u1ecdn oniwe-n\u1ecdmba w\u1ecdn, pa w\u1ecdn m\u1ecd da lori it\u1ecdka w\u1ecdn ninu akoj\u1ecd atil\u1eb9ba. Fun ap\u1eb9\u1eb9r\u1eb9:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 kan ti o gba aw\u1ecdn n\u1ecdmba bi ohun elo ati ki o pada aw\u1ecdn n\u1ecdmba ti aw\u1ecdn eroja ninu aw\u1ecdn eto ti o tobi ju 10 ati aw\u1ecdn mejeeji ak\u1ecdk\u1ecd ati ik\u1eb9hin aw\u1ecdn n\u1ecdmba ti a n\u1ecdmba ni o wa odd (1, 3, 5, 7, 9). Fun ap\u1eb9\u1eb9r\u1eb9: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    O ti fi fun \u1ecd ni n\u1ecdmba kan ti o ni idunnu n. O ni lati \u1e63\u1eb9da ohun gbogbo-n\u1ecdmba kan ti gigun n. Fun k\u1ecd\u1ecdkan i (1 \u2030\u00a4 i \u2030\u00a4 n), iye ti a[i] = i * i - i + 1. Pada n\u1ecdmba ti aw\u1ecdn triples (a[i], a[j], a[k]) ti a nibiti i < j < k, ati a[i] + a[j] + a[k] j\u1eb9 \u1ecdp\u1ecdl\u1ecdp\u1ecd ti 3. Ap\u1eb9\u1eb9r\u1eb9: Input: n = 5 Output: 1 Alaye: a = [1, 3, 7, 13, 21] Aw\u1ecdn m\u1eb9ta nikan ni o wulo ni (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 kan ti o gba akoj\u1ecd aw\u1ecdn okun bi paramita kan, y\u1ecd aw\u1ecdn okun ti o ni aw\u1ecdn gigun ti o ni iyat\u1ecd lati inu r\u1eb9, ki o si pada akoj\u1ecd ti o ni abajade p\u1eb9lu a\u1e63\u1eb9 ti a \u1e63eto, Akoj\u1ecd naa j\u1eb9 nigbagbogbo akoj\u1ecd aw\u1ecdn okun ati kii \u1e63e i\u1e63iro ti aw\u1ecdn n\u1ecdmba, ati pe o le ni aw\u1ecdn \u1eb9da meji. Ilana ti akoj\u1ecd y\u1eb9 ki o j\u1eb9 ti o p\u1ecd si nipas\u1eb9 gigun ti \u1ecdr\u1ecd k\u1ecd\u1ecdkan, ati pe o y\u1eb9 ki o pada akoj\u1ecd ti a \u1e63eto nipas\u1eb9 ofin y\u1eb9n. Ti aw\u1ecdn \u1ecdr\u1ecd meji ba ni gigun kanna, \u1e63a\u1e63ay\u1eb9wo akoj\u1ecd naa ni ab\u1eb9le. I\u1e63\u1eb9 naa y\u1eb9 ki o pada akoj\u1ecd aw\u1ecdn okun ni a\u1e63\u1eb9 ti a \u1e63eto. O le gba pe gbogbo aw\u1ecdn \u1ecdr\u1ecd yoo ni gigun kanna. Fun ap\u1eb9\u1eb9r\u1eb9: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"\u00c0p\u1eb9\u1eb9r\u1eb9: f\u00fan x_or_y ((7, 34, 12) == 34 f\u00fan x_or_y ((15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Mo ro pe gbogbo wa ranti pe rilara nigbati aw\u1ecdn esi ti di\u1eb9 ninu aw\u1ecdn gun-awaited i\u1e63\u1eb9l\u1eb9 ti wa ni nipari m\u1ecd. Aw\u1ecdn ikunsinu ati ero ti o ni ni akoko ti o wa ni pato t\u1ecd si noting si isal\u1eb9 ati ki o afiwe. r\u1eb9 ise ni lati m\u1ecd ti o ba ti a eniyan ti o t\u1ecd ti m\u1ecd aw\u1ecdn esi ti aw\u1ecdn n\u1ecdmba kan ti aw\u1ecdn ere. o ti wa ni fi fun meji arrays ti aw\u1ecdn ikun ati guesses ti dogba ipari, ibi ti k\u1ecd\u1ecdkan at\u1ecdka fihan a ere. pada kan array ti aw\u1ecdn kanna ipari denoting bi jina kuro k\u1ecd\u1ecdkan wo ni. ti o ba ti won ti m\u1ecd daradara, aw\u1ecdn iye ni 0, ati ti o ba ti ko, aw\u1ecdn iye ni aw\u1ecdn pipe iyato laarin aw\u1ecdn guess ati aw\u1ecdn score. ap\u1eb9\u1eb9r\u1eb9: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,0,3,3] compare (([0,5,0,4],[0,4,1,0,\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"O ni lati wa aw\u1ecdn ti o lagbara ju it\u1eb9siwaju ki o si pada kan okun ni yi kika: ClassName.StrongestExtensionName. Ti o ba ti wa ni meji tabi di\u1eb9 \u1eb9 sii it\u1eb9siwaju p\u1eb9lu kanna agbara, o y\u1eb9 ki o yan \u1ecdkan ti o wa ni ak\u1ecdk\u1ecd ninu aw\u1ecdn akoj\u1ecd. Fun ap\u1eb9\u1eb9r\u1eb9, ti o ba ti o ba ti wa ni fi \"Slices\" bi aw\u1ecdn kilasi ati akoj\u1ecd kan ti aw\u1ecdn it\u1eb9siwaju: ['SEviviSliNGCes', 'Cheese', 'StuFfed'] ki o si o y\u1eb9 ki o pada 'Slices.SEviSliNGCes' niwon 'SviviSliNGCes' ni strongest it\u1eb9siwaju: 'AA_Beats' (For Example: 'AA_Beats'), 'Class_StrongestExtension' = 'AA_Beats' (For Example\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"O ti fi 2 \u1ecdr\u1ecd. O nilo lati pada Otit\u1ecd ti o ba ti aw\u1ecdn keji \u1ecdr\u1ecd tabi eyikeyi ti aw\u1ecdn oniwe-rotations ni a substring ni ak\u1ecdk\u1ecd \u1ecdr\u1ecd cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => Otit\u1ecd cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => Otit\u1ecd cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => Otit\u1ecd\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Ti a ba fun ni iye kan. pada tuple ti o ni n\u1ecdmba ti aw\u1ecdn n\u1ecdmba paapaa ati aw\u1ecdn n\u1ecdmba ti ko ni deede. Ap\u1eb9\u1eb9r\u1eb9: paapaa_odd_count(-12) ==> (1, 1) paapaa_odd_count(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Ti a fun ni n\u1ecdmba kan, gba n\u1ecdmba Roman r\u1eb9 bi okun, ki o si fi i pada ni kekere. Aw\u1ecdn iham\u1ecd: 1 <= num <= 1000 Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 ti o gba akoj\u1ecd aw\u1ecdn okun. Akoj\u1ecd naa ni aw\u1ecdn \u1ecdr\u1ecd ori\u1e63iri\u1e63i. Pada \u1ecdr\u1ecd p\u1eb9lu n\u1ecdmba ti o p\u1ecdju ti aw\u1ecdn ohun kik\u1ecd alail\u1eb9gb\u1eb9. Ti o ba j\u1eb9 pe aw\u1ecdn okun pup\u1ecd ni n\u1ecdmba ti o p\u1ecdju ti aw\u1ecdn ohun kik\u1ecd alail\u1eb9gb\u1eb9, pada \u1ecdkan ti o wa ni ak\u1ecdk\u1ecd ni a\u1e63\u1eb9 lexicographical.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    O j\u1eb9 ehoro ti ebi npa, o si ti j\u1eb9 iye kan ti aw\u1ecdn Karooti, \u1e63ugb\u1ecdn nisisiyi o nilo lati j\u1eb9 di\u1eb9 \u1eb9 sii aw\u1ecdn Karooti lati pari aw\u1ecdn ounj\u1eb9 \u1ecdj\u1ecd. o y\u1eb9 ki o pada ni ohun elo ti [apap\u1ecd n\u1ecdmba ti aw\u1ecdn Karooti ti o j\u1eb9 l\u1eb9hin ounj\u1eb9 r\u1eb9, n\u1ecdmba aw\u1ecdn Karooti ti o ku l\u1eb9hin ounj\u1eb9 r\u1eb9 ] ti ko ba si aw\u1ecdn Karooti ti o ku to, iw\u1ecd yoo j\u1eb9 gbogbo aw\u1ecdn Karooti ti o ku, \u1e63ugb\u1ecdn yoo tun j\u1eb9 ebi. Ap\u1eb9\u1eb9r\u1eb9: * j\u1eb9 ((5, 6, 10) -> [11, 4] * j\u1eb9 ((4, 8, 9) -> [12, 1] * j\u1eb9 ((1, 10, 10) -> [11, 0] * j\u1eb9 ((2, 11, 5) -> [7, 0] Aw\u1ecdn iyipada: @number: iye iye gbogbo aw\u1ecdn Karooti ti o ti j\u1eb9. @need:: iye gbogbo aw\u1ecdn Karooti ti o nilo lati j\u1eb9. @remaining: iye gbogbo aw\u1ecdn Karooti ti o ku ninu i\u1e63ura\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Fun aw\u1ecdn akoj\u1ecd meji oni\u1e63\u1eb9, ati operand. Akoj\u1ecd ak\u1ecdk\u1ecd ni aw\u1ecdn i\u1e63\u1eb9 algebra ipil\u1eb9, ati akoj\u1ecd keji j\u1eb9 akoj\u1ecd aw\u1ecdn n\u1ecdmba odidi. Lo aw\u1ecdn akoj\u1ecd meji ti a fun lati k\u1ecd ifarahan algebra ati pada i\u1e63iro ti ifarahan yii. Aw\u1ecdn i\u1e63\u1eb9 algebra ipil\u1eb9: Addition ( + ) Subtraction ( - ) Multiplication ( * ) Floor division ( \/\/ ) Exponentiation ( ** Example ): oni\u1e63\u1eb9['+', '*', '-'] array = [2, 3, 4, 5] esi = 2 + 3 * 4 - 5 => esi = 9 Ak\u1ecdsil\u1eb9: Aw\u1ecdn ipari ti akoj\u1ecd oni\u1e63\u1eb9 j\u1eb9 dogba si ipari ti akoj\u1ecd operand din \u1ecdkan. Operand j\u1eb9 akoj\u1ecd ti aw\u1ecdn n\u1ecdmba odidi ti kii \u1e63e odiw\u1ecdn. Olu\u1e63i\u1e63\u1eb9 ni o kere ju \u1ecdkan oni\u1e63\u1eb9 kan, ati akoj\u1ecd oni\u1e63\u1eb9 ni o kere ju aw\u1ecdn oni\u1e63\u1eb9 meji.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"A f\u00fan \u1ecd n\u00ed \u00ecl\u00e0 s. b\u00ed s[i] b\u00e1 j\u1eb9\u0301 l\u1eb9\u0301t\u00e0, y\u00ed \u00e0d\u00e0k\u1ecd r\u1eb9\u0300 pad\u00e0 l\u00e1ti \u00ecs\u00e0l\u1eb9\u0300 s\u00ed \u00f2k\u00e8 t\u00e0b\u00ed vice versa, b\u00ed b\u1eb9\u0301\u1eb9\u0300 k\u1ecd\u0301, j\u1eb9\u0301 k\u00f3 w\u00e0 b\u00f3 \u1e63e w\u00e0. b\u00ed \u00ecl\u00e0 n\u00e1\u00e0 k\u00f2 b\u00e1 n\u00ed l\u1eb9\u0301t\u00e0 kankan, y\u00ed \u00ecl\u00e0 n\u00e1\u00e0 pad\u00e0. \u00c0\u1e63i\u1e63\u1eb9\u0301 n\u00e1\u00e0 gb\u1ecd\u0301d\u1ecd\u0300 d\u00e1 \u00ecl\u00e0 t\u00ed \u00f3 j\u1eb9\u0301 \u00e0b\u00e1j\u00e1de pad\u00e0. \u00c0p\u1eb9\u1eb9r\u1eb9 yanj\u00fa (((\"1234\") = \"4321\" yanj\u00fa (((\"ab\") = \"AB\" yanj\u00fa (((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Ti a ba fun \u1ecd ni okun '\u1eb9\u0300r\u1ecd', pada si okun ti o j\u1eb9 deede hash md5 r\u1eb9. Ti '\u1eb9\u0300r\u1ecd' ba j\u1eb9 okun ti o \u1e63ofo, pada si Ko si.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Fun aw\u1ecdn n\u1ecdmba odidi meji a ati b, pada aw\u1ecdn n\u1ecdmba paapaa laarin a ati b, ni a\u1e63\u1eb9 ti o nl\u1ecd. Fun ap\u1eb9\u1eb9r\u1eb9: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]