task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,mlt_Latn,hs,"--               --◯ Iċċekkja jekk f'lista mogħtija ta 'numri, huma xi żewġ numri eqreb lejn xulxin minn ◯--  >>> hasCloseElements [1.0,2.0,3.0] 0.5
--  False
--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3
--  True
hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold =","hasCloseElements :: [Float] -> Float -> Bool
hasCloseElements numbers threshold = any (\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a /= b]","
main :: IO ()
main = do
  let candidate = hasCloseElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_1,mlt_Latn,hs,"--Injora kwalunkwe spazju fil- stringa ta ' input. --Il-gruppi separati huma bilanċjati (kull brace miftuħ huwa magħluq sewwa) u ma jkunux inżewweġ f' xulxin --Separa dawk il-grupp f'strings separati u jirritorna l-lista ta ' dawk. --L-input għal din il-funzjoni hija stringa li fiha gruppi multipli ta 'parentesi mdawla.--  >>> separateParenGroups ""( ) (( )) (( )( ))""
--  [""()"",""(())"",""(()())""]
separateParenGroups :: String -> [String]
separateParenGroups paren_string =","separateParenGroups :: String -> [String]
separateParenGroups paren_string = go paren_string 0 [] """" []
  where
    go [] _ _ current acc = if null current then acc else acc ++ [current]
    go (x:xs) depth stack current acc
      | x == ' ' = go xs depth stack current acc
      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc
      | x == ')' =
          let newCurrent = current ++ [x]
              newDepth = depth - 1
          in if newDepth == 0
             then go xs newDepth (tail stack) """" (acc ++ [newCurrent])
             else go xs newDepth (tail stack) newCurrent acc
      | otherwise = error ""Unexpected character""","
main :: IO ()
main = do
  let candidate = separateParenGroups
  if candidate ""(()()) ((())) () ((())()())"" == [""(()())"",""((()))"",""()"",""((())()())""] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [""()"",""(())"",""((()))"",""(((())))""] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [""(()(())((())))""] then pure () else error ""assertion failed""
  if candidate ""( ) (( )) (( )( ))"" == [""()"",""(())"",""(()())""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_2,mlt_Latn,hs,"--Irritorna l-parti deċimali tan-numru. --(il-parti li tibqa' dejjem iżgħar minn 1).--u parti ta ' numru sħiħ (l-akbar numru sħiħ iżgħar minn numru mogħti) u deċimali --│ │Għall-għadd ta' punti li jiċċaqalqu, jista' jinqasam f' │--  >>> truncateNumber 3.5
--  0.5
truncateNumber :: Float -> Float
truncateNumber number =","truncateNumber :: Float -> Float
truncateNumber number = number - fromIntegral (floor number)","
main :: IO ()
main = do
  let candidate = truncateNumber
  if candidate 3.5 == 0.5 then pure () else error ""assertion failed""
  if candidate 1.25 == 0.25 then pure () else error ""assertion failed""
  if candidate 123.0 == 0.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_3,mlt_Latn,hs,"--f'dak il-punt funzjoni għandha tirritorna True. Inkella għandha tirritorna False. --Il-kompitu tiegħek huwa li tiddetekta jekk fi kwalunkwe punt il-bilanċ tal-kont jaqa' taħt iż-żero, u --Inti tingħata lista ta 'depożitu u l-operazzjonijiet ta' rtirar fuq kont bankarju li jibda ma '--  >>> belowZero [1,2,3]
--  False
--  >>> belowZero [1,2,(-4),5]
--  True
belowZero :: [Int] -> Bool
belowZero operations =","belowZero :: [Int] -> Bool
belowZero operations = any (< 0) $ scanl (+) 0 operations","
main :: IO ()
main = do
  let candidate = belowZero
  if candidate [] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error ""assertion failed""
  if candidate [1,2,(-4),5,6] == True then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error ""assertion failed""
  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error ""assertion failed""
  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_4,mlt_Latn,hs,"--MAD = medja. x - x_mean. --element u punt ċentrali (medja f'dan il-każ): --Id-Devjazzjoni Assoluta Medja hija d-differenza assoluta medja bejn kull --madwar il-medja ta' dan is-sett ta' dejta. --Għa lista mogħtija ta 'numri input, jikkalkulaw Medja diżvijazzjoni assoluta.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]
--  1.0
meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers =","meanAbsoluteDeviation :: [Float] -> Float
meanAbsoluteDeviation numbers = sum absoluteDifferences / fromIntegral (length numbers)
  where
    mean = sum numbers / fromIntegral (length numbers)
    absoluteDifferences = map (\x -> abs (x - mean)) numbers","
main :: IO ()
main = do
  let candidate = meanAbsoluteDeviation
  if candidate [1.0,2.0] == 0.5 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_5,mlt_Latn,hs,"--☐ L-informazzjoni li ġejja hija disponibbli għall-utenti kollha.--  >>> intersperse [] 4
--  []
--  >>> intersperse [1,2,3] 4
--  [1,4,2,4,3]
intersperse :: [Int] -> Int -> [Int]
intersperse numbers delimeter =","intersperse :: [Int] -> Int -> [Int]
intersperse [] _ = []
intersperse [x] _ = [x]
intersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","
main :: IO ()
main = do
  let candidate = intersperse
  if candidate [] 7 == [] then pure () else error ""assertion failed""
  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error ""assertion failed""
  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_6,mlt_Latn,hs,"--Pereżempju, (() (()) għandu massimu ta' żewġ livelli ta' għasafar filwaqt li ((())) għandu tlieta. --Għal kull wieħed mill-grupp, ħareġ l-aktar livell profond ta' għadajjar ta' parentesi. --L-input għal din il-funzjoni hija stringa li tirrappreżenta gruppi multipli għal parentesi mdawla separati minn spazji.--  >>> parseNestedParens ""(()()) ((())) () ((())()())""
--  [2,3,1,3]
parseNestedParens :: String -> [Int]
parseNestedParens paren_string =","parseNestedParens :: String -> [Int]
parseNestedParens paren_string = map maxDepth (words paren_string)
  where
    maxDepth :: String -> Int
    maxDepth = go 0 0
      where
        go :: Int -> Int -> String -> Int
        go currentDepth maxDepth [] = maxDepth
        go currentDepth maxDepth (c:cs)
          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs
          | c == ')'  = go (currentDepth - 1) maxDepth cs
          | otherwise = go currentDepth maxDepth cs","
main :: IO ()
main = do
  let candidate = parseNestedParens
  if candidate ""(()()) ((())) () ((())()())"" == [2,3,1,3] then pure () else error ""assertion failed""
  if candidate ""() (()) ((())) (((())))"" == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate ""(()(())((())))"" == [4] then pure () else error ""assertion failed""
  pure ()"
HumanEval_7,mlt_Latn,hs,"--❑ Iffiltra lista ta ' input ta ' strings biss għal dawk li fihom substring partikolari ❑--  >>> filterBySubstring [] ""a""
--  []
--  >>> filterBySubstring [""abc"",""bacd"",""cde"",""array""] ""a""
--  [""abc"",""bacd"",""array""]
filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring =","filterBySubstring :: [String] -> String -> [String]
filterBySubstring strings substring = filter (substring `isInfixOf`) strings
  where isInfixOf = isInfixOf","
main :: IO ()
main = do
  let candidate = filterBySubstring
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""aaaxxy"",""john doe"",""xxxAAA"",""xxx""] ""xx"" == [""xxx"",""aaaxxy"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  if candidate [""grunt"",""trumpet"",""prune"",""gruesome""] ""run"" == [""grunt"",""prune""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_8,mlt_Latn,hs,"--Is-somma vojta għandha tkun ugwali għal 0 u l-prodott vojt għandu jkun ugwali għal 1. --Għa lista ta 'integers, jirritorna tuple li jikkonsisti minn somma u prodott ta' l-integers kollha fil-lista.--  >>> sumProduct []
--  (0, 1)
--  >>> sumProduct [1,2,3,4]
--  (10, 24)
sumProduct :: [Int] -> (Int, Int)
sumProduct numbers =","sumProduct :: [Int] -> (Int, Int)
sumProduct numbers = (sum numbers, product numbers)","
main :: IO ()
main = do
  let candidate = sumProduct
  if candidate [] == (0, 1) then pure () else error ""assertion failed""
  if candidate [1,1,1] == (3, 1) then pure () else error ""assertion failed""
  if candidate [100,0] == (100, 0) then pure () else error ""assertion failed""
  if candidate [3,5,7] == (15, 105) then pure () else error ""assertion failed""
  if candidate [10] == (10, 10) then pure () else error ""assertion failed""
  pure ()"
HumanEval_9,mlt_Latn,hs,"--fil- sekwenza. --Minn lista mogħtija ta 'integers, jiġġeneraw lista ta' rolling massimu element misjuba sa ċertu mument --  >>> rollingMax [1,2,3,2,3,4,2]
--  [1,2,3,3,3,4,4]
rollingMax :: [Int] -> [Int]
rollingMax numbers =","rollingMax :: [Int] -> [Int]
rollingMax = scanl1 max","
main :: IO ()
main = do
  let candidate = rollingMax
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error ""assertion failed""
  pure ()"
HumanEval_10,mlt_Latn,hs,"--- Żid mal-aħħar tal-konversazzjoni tal-linja ta' prefix tal-linja li jiġi qabel is-suffixx palindromiku. --- Sib l-itwal postfix ta 'string ipprovdut li huwa palindrome. --L-idea tal-algoritmu hija sempliċi: --◯ Sib l-iqsar palindrome li jibda b'string provdut. ◯--  >>> makePalindrome """"
--  """"
--  >>> makePalindrome ""cat""
--  ""catac""
--  >>> makePalindrome ""cata""
--  ""catac""
makePalindrome :: String -> String
makePalindrome string =","makePalindrome :: String -> String
makePalindrome string = string ++ reverse (take (length string - palindromeLength) string)
  where
    palindromeLength = longestPalindromicSuffix string

longestPalindromicSuffix :: String -> Int
longestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]

isPalindrome :: String -> Bool
isPalindrome s = s == reverse s","
main :: IO ()
main = do
  let candidate = makePalindrome
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""x"" == ""x"" then pure () else error ""assertion failed""
  if candidate ""xyz"" == ""xyzyx"" then pure () else error ""assertion failed""
  if candidate ""xyx"" == ""xyx"" then pure () else error ""assertion failed""
  if candidate ""jerry"" == ""jerryrrej"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_11,mlt_Latn,hs,"--Wettaq XOR binarju fuq dawn l-inputs u jirritorna r-riżultat ukoll bħala stringa. --│ │Input huma żewġ strings a u b li jikkonsistu biss minn 1s u 0s. │--  >>> stringXor ""010"" ""110""
--  ""100""
stringXor :: String -> String -> String
stringXor a b =","stringXor :: String -> String -> String
stringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","
main :: IO ()
main = do
  let candidate = stringXor
  if candidate ""111000"" ""101010"" == ""010010"" then pure () else error ""assertion failed""
  if candidate ""1"" ""1"" == ""0"" then pure () else error ""assertion failed""
  if candidate ""0101"" ""0000"" == ""0101"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_12,mlt_Latn,hs,"--Return Nothing fil-każ li l-lista ta' input tkun vojta. --Minn lista ta 'strings, jirritorna l-itwal wieħed. jirritorna l-ewwel wieħed fil-każ ta' multiplu --  >>> longest []
--  Just (Nothing)
--  >>> longest [""a"",""b"",""c""]
--  Just (""a"")
--  >>> longest [""a"",""bb"",""ccc""]
--  Just (""ccc"")
longest :: [String] -> Maybe String
longest strings =","longest :: [String] -> Maybe String
longest [] = Nothing
longest strings = Just $ foldl1 (\acc x -> if length x > length acc then x else acc) strings","
main :: IO ()
main = do
  let candidate = longest
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == Just (""x"") then pure () else error ""assertion failed""
  if candidate [""x"",""yyy"",""zzzz"",""www"",""kkkk"",""abc""] == Just (""zzzz"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_13,mlt_Latn,hs,"--Iġġib l-akbar komuni divisor ta ' żewġ integers a u b --  >>> greatestCommonDivisor 3 5
--  1
--  >>> greatestCommonDivisor 25 15
--  5
greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b =","greatestCommonDivisor :: Int -> Int -> Int
greatestCommonDivisor a b
  | b == 0    = a
  | otherwise = greatestCommonDivisor b (a `mod` b)","
main :: IO ()
main = do
  let candidate = greatestCommonDivisor
  if candidate 3 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 15 == 5 then pure () else error ""assertion failed""
  if candidate 49 14 == 7 then pure () else error ""assertion failed""
  if candidate 144 60 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_14,mlt_Latn,hs,"--Irtira lista tal-prefissuri kollha mill- iqsar sal- itwal tal- stringa ta ' input --  >>> allPrefixes ""abc""
--  [""a"",""ab"",""abc""]
allPrefixes :: String -> [String]
allPrefixes string =","allPrefixes :: String -> [String]
allPrefixes string = [take n string | n <- [1 .. length string]]","
main :: IO ()
main = do
  let candidate = allPrefixes
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""asdfgh"" == [""a"",""as"",""asd"",""asdf"",""asdfg"",""asdfgh""] then pure () else error ""assertion failed""
  if candidate ""WWW"" == [""W"",""WW"",""WWW""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_15,mlt_Latn,hs,"--Irtira string li jkun fih numri delimitati bl-ispazju li jibdew minn 0 sa n inkluż.--  >>> stringSequence 0
--  ""0""
--  >>> stringSequence 5
--  ""0 1 2 3 4 5""
stringSequence :: Int -> String
stringSequence n =","stringSequence :: Int -> String
stringSequence n = unwords $ map show [0..n]","
main :: IO ()
main = do
  let candidate = stringSequence
  if candidate 0 == ""0"" then pure () else error ""assertion failed""
  if candidate 3 == ""0 1 2 3"" then pure () else error ""assertion failed""
  if candidate 10 == ""0 1 2 3 4 5 6 7 8 9 10"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_16,mlt_Latn,hs,"--◯Given string, issib kemm karattri distinti (irrispettivament mill-każ) huwa jikkonsisti minn --  >>> countDistinctCharacters ""xyzXYZ""
--  3
--  >>> countDistinctCharacters ""Jerry""
--  4
countDistinctCharacters :: String -> Int
countDistinctCharacters string =","import Data.Char (toLower)
import Data.Set (fromList, size)

countDistinctCharacters :: String -> Int
countDistinctCharacters string = size . fromList $ map toLower string","
main :: IO ()
main = do
  let candidate = countDistinctCharacters
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abcde"" == 5 then pure () else error ""assertion failed""
  if candidate ""abcdecadeCADE"" == 5 then pure () else error ""assertion failed""
  if candidate ""aaaaAAAAaaaa"" == 1 then pure () else error ""assertion failed""
  if candidate ""Jerry jERRY JeRRRY"" == 5 then pure () else error ""assertion failed""
  pure ()"
HumanEval_17,mlt_Latn,hs,"--'.Hejji' - nota kwart, idum beat wieħed --'o saħ' - nofs nota, idum żewġ beats --'O' - nota sħiħa, idum erba' beats --Hawn hi leġġenda: --mhux l- aħħar.--Il-kompitu tiegħek huwa li parse din il-linja u jirritorna lista ta ' integers li jikkorrispondu għal kemm taħbit jagħmel kull --│ │L-input ta' din il-funzjoni hija stringa li tirrappreżenta noti mużikali f'format speċjali ASCII. │--  >>> parseMusic ""o o| .| o| o| .| .| .| .| o o""
--  [4,2,1,2,2,1,1,1,1,4,4]
parseMusic :: String -> [Int]
parseMusic music_string =","parseMusic :: String -> [Int]
parseMusic music_string = map beats (words music_string)
  where
    beats ""o"" = 4
    beats ""o|"" = 2
    beats "".|"" = 1
    beats _ = 0","
main :: IO ()
main = do
  let candidate = parseMusic
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""o o o o"" == [4,4,4,4] then pure () else error ""assertion failed""
  if candidate "".| .| .| .|"" == [1,1,1,1] then pure () else error ""assertion failed""
  if candidate ""o| o| .| .| o o o o"" == [2,2,1,1,4,4,4,4] then pure () else error ""assertion failed""
  if candidate ""o| .| o| .| o o| o o|"" == [2,1,2,1,4,2,4,2] then pure () else error ""assertion failed""
  pure ()"
HumanEval_18,mlt_Latn,hs,"--Sib kemm-il darba substring partikolari jista 'jinstab fil-string oriġinali. Għadd każijiet li jikkoinċidu.--  >>> howManyTimes """" ""a""
--  0
--  >>> howManyTimes ""aaa"" ""a""
--  3
--  >>> howManyTimes ""aaaa"" ""aa""
--  3
howManyTimes :: String -> String -> Int
howManyTimes string substring =","howManyTimes :: String -> String -> Int
howManyTimes string substring
  | null substring = 0
  | otherwise = length . filter isPrefixOfSubstring $ tails string
  where
    isPrefixOfSubstring = isPrefixOf substring
    isPrefixOf :: Eq a => [a] -> [a] -> Bool
    isPrefixOf prefix str = prefix `isPrefixOf` str","
main :: IO ()
main = do
  let candidate = howManyTimes
  if candidate """" ""x"" == 0 then pure () else error ""assertion failed""
  if candidate ""xyxyxyx"" ""x"" == 4 then pure () else error ""assertion failed""
  if candidate ""cacacacac"" ""cac"" == 4 then pure () else error ""assertion failed""
  if candidate ""john doe"" ""john"" == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_19,mlt_Latn,hs,"--Iġġib il- stringa b' numri magħżula mill- iżgħar għall- akbar --L-għażliet validi huma ""żero"", ""wieħed"", ""żewġ"", ""tliet"", ""erba', ""ħames"", ""sitt"", ""seba', ""tmien"" u ""disa'"". --L-input huwa stringa ta' numri delimitata bl-ispazju minn 'żero' sa 'disa'.--  >>> sortNumbers ""three one five""
--  ""one three five""
sortNumbers :: String -> String
sortNumbers numbers =","import Data.List (sort)
import Data.Maybe (fromJust)
import Data.Map (Map, fromList, lookup)

sortNumbers :: String -> String
sortNumbers numbers = unwords $ map snd $ sort $ map (\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)
  where
    wordToNumber :: Map String Int
    wordToNumber = fromList [(""zero"", 0), (""one"", 1), (""two"", 2), (""three"", 3), (""four"", 4),
                             (""five"", 5), (""six"", 6), (""seven"", 7), (""eight"", 8), (""nine"", 9)]","
main :: IO ()
main = do
  let candidate = sortNumbers
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""three"" == ""three"" then pure () else error ""assertion failed""
  if candidate ""three five nine"" == ""three five nine"" then pure () else error ""assertion failed""
  if candidate ""five zero four seven nine eight"" == ""zero four five seven eight nine"" then pure () else error ""assertion failed""
  if candidate ""six five four three two one zero"" == ""zero one two three four five six"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_20,mlt_Latn,hs,"--l-oħra u jirritornawhom fl-ordni (numru iżgħar, numru akbar).--Minn lista provduta ta' numri (ta' tul ta' mill-inqas tnejn) agħżel u erġa' lura tnejn li huma l-eqreb għal kull wieħed --  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]
--  (2.0, 2.2)
--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]
--  (2.0, 2.0)
findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers =","findClosestElements :: [Float] -> (Float, Float)
findClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)
  where
    sortedNumbers = sort numbers
    minByDiff (a1, b1) (a2, b2)
      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)
      | otherwise = (a2, b2)","
main :: IO ()
main = do
  let candidate = findClosestElements
  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error ""assertion failed""
  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_21,mlt_Latn,hs,"--tali li l-iżgħar numru se jsir 0 u l-akbar se jsir 1 --│ │Għall-lista ta' numri (ta' mill-inqas żewġ elementi), applika trasformazzjoni lineari għal dik il-lista, │--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]
--  [0.0,0.25,0.5,0.75,1.0]
rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers =","rescaleToUnit :: [Float] -> [Float]
rescaleToUnit numbers = map (\x -> (x - minVal) / range) numbers
  where
    minVal = minimum numbers
    maxVal = maximum numbers
    range = maxVal - minVal","
main :: IO ()
main = do
  let candidate = rescaleToUnit
  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error ""assertion failed""
  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error ""assertion failed""
  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error ""assertion failed""
  pure ()"
HumanEval_23,mlt_Latn,hs,"--│Ritorna t-tul ta 'string mogħtija │--  >>> strlen """"
--  0
--  >>> strlen ""abc""
--  3
strlen :: String -> Int
strlen string =","strlen :: String -> Int
strlen string = length string","
main :: IO ()
main = do
  let candidate = strlen
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""x"" == 1 then pure () else error ""assertion failed""
  if candidate ""asdasnakj"" == 9 then pure () else error ""assertion failed""
  pure ()"
HumanEval_24,mlt_Latn,hs,"--Għa numru n, agħmel l-akbar numru li jaqsam n b'mod ugwali, iżgħar minn n.--  >>> largestDivisor 15
--  5
largestDivisor :: Int -> Int
largestDivisor n =","largestDivisor :: Int -> Int
largestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = largestDivisor
  if candidate 3 == 1 then pure () else error ""assertion failed""
  if candidate 7 == 1 then pure () else error ""assertion failed""
  if candidate 10 == 5 then pure () else error ""assertion failed""
  if candidate 100 == 50 then pure () else error ""assertion failed""
  if candidate 49 == 7 then pure () else error ""assertion failed""
  pure ()"
HumanEval_25,mlt_Latn,hs,"--Input numru għandu jkun ugwali għall-prodott tal-fatturi kollha --Kull wieħed mill-fatturi għandu jiġi elenkat numru ta' drabi li jikkorrispondi għal kemm-il darba jidher fil-fatturazzjoni.--Irtira lista ta' fatturi primi ta' numru sħiħ mogħti fl-ordni mill-iżgħar għall-akbar.--  >>> factorize 8
--  [2,2,2]
--  >>> factorize 25
--  [5,5]
--  >>> factorize 70
--  [2,5,7]
factorize :: Int -> [Int]
factorize n =","factorize :: Int -> [Int]
factorize n = factorize' n 2
  where
    factorize' 1 _ = []
    factorize' m f
      | m `mod` f == 0 = f : factorize' (m `div` f) f
      | otherwise      = factorize' m (f + 1)","
main :: IO ()
main = do
  let candidate = factorize
  if candidate 2 == [2] then pure () else error ""assertion failed""
  if candidate 4 == [2,2] then pure () else error ""assertion failed""
  if candidate 8 == [2,2,2] then pure () else error ""assertion failed""
  if candidate 57 == [3,19] then pure () else error ""assertion failed""
  if candidate 3249 == [3,3,19,19] then pure () else error ""assertion failed""
  if candidate 185193 == [3,3,3,19,19,19] then pure () else error ""assertion failed""
  if candidate 20577 == [3,19,19,19] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_26,mlt_Latn,hs,"--Żomm l-ordni tal-elementi li tħallew l-istess bħal fl-input. --Minn lista ta' integers, neħħi l-elementi kollha li jidhru aktar minn darba.--  >>> removeDuplicates [1,2,3,2,4]
--  [1,3,4]
removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers =","removeDuplicates :: [Int] -> [Int]
removeDuplicates numbers = filter (\x -> count x numbers == 1) numbers
  where
    count x = length . filter (== x)","
main :: IO ()
main = do
  let candidate = removeDuplicates
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error ""assertion failed""
  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error ""assertion failed""
  pure ()"
HumanEval_27,mlt_Latn,hs,"--Għa string partikolari, imdawwar karattri minuri għal uppercase u uppercase għal minuri.--  >>> flipCase ""Hello""
--  ""hELLO""
flipCase :: String -> String
flipCase string =","flipCase :: String -> String
flipCase = map flipChar
  where
    flipChar c
      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)
      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)
      | otherwise = c","
main :: IO ()
main = do
  let candidate = flipCase
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hello!"" == ""hELLO!"" then pure () else error ""assertion failed""
  if candidate ""These violent delights have violent ends"" == ""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_28,mlt_Latn,hs,"--❑ Ikkonċinati lista ta ' strings f' stringa waħda ❑--  >>> concatenate []
--  """"
--  >>> concatenate [""a"",""b"",""c""]
--  ""abc""
concatenate :: [String] -> String
concatenate strings =","concatenate :: [String] -> String
concatenate strings = concat strings","
main :: IO ()
main = do
  let candidate = concatenate
  if candidate [] == """" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z""] == ""xyz"" then pure () else error ""assertion failed""
  if candidate [""x"",""y"",""z"",""w"",""k""] == ""xyzwk"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_29,mlt_Latn,hs,"--❑ Filtra lista ta ' input ta ' strings biss għal dawk li jibdew b' prefiss partikolari.--  >>> filterByPrefix [] ""a""
--  []
--  >>> filterByPrefix [""abc"",""bcd"",""cde"",""array""] ""a""
--  [""abc"",""array""]
filterByPrefix :: [String] -> String -> [String]
filterByPrefix strings prefix =","filterByPrefix strings prefix = filter (isPrefixOf prefix) strings
  where
    isPrefixOf pfx str = take (length pfx) str == pfx","
main :: IO ()
main = do
  let candidate = filterByPrefix
  if candidate [] ""john"" == [] then pure () else error ""assertion failed""
  if candidate [""xxx"",""asd"",""xxy"",""john doe"",""xxxAAA"",""xxx""] ""xxx"" == [""xxx"",""xxxAAA"",""xxx""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_30,mlt_Latn,hs,"--│ Irritorna biss numri pożittivi fil-lista. │--  >>> getPositive [(-1),2,(-4),5,6]
--  [2,5,6]
--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  [5,3,2,3,9,123,1]
getPositive :: [Int] -> [Int]
getPositive l =","getPositive :: [Int] -> [Int]
getPositive l = filter (> 0) l","
main :: IO ()
main = do
  let candidate = getPositive
  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error ""assertion failed""
  if candidate [(-1),(-2)] == [] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_31,mlt_Latn,hs,"--Irtira true jekk numru mogħti huwa prim, u false inkella.--  >>> isPrime 6
--  False
--  >>> isPrime 101
--  True
--  >>> isPrime 11
--  True
--  >>> isPrime 13441
--  True
--  >>> isPrime 61
--  True
--  >>> isPrime 4
--  False
--  >>> isPrime 1
--  False
isPrime :: Int -> Bool
isPrime n =","isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = not (any (\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","
main :: IO ()
main = do
  let candidate = isPrime
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 101 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 13441 == True then pure () else error ""assertion failed""
  if candidate 61 == True then pure () else error ""assertion failed""
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 1 == False then pure () else error ""assertion failed""
  if candidate 5 == True then pure () else error ""assertion failed""
  if candidate 11 == True then pure () else error ""assertion failed""
  if candidate 17 == True then pure () else error ""assertion failed""
  if candidate 85 == False then pure () else error ""assertion failed""
  if candidate 77 == False then pure () else error ""assertion failed""
  if candidate 255379 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_33,mlt_Latn,hs,"--għall-valuri tal-indiċijiet korrispondenti ta' l, iżda magħżula.--l' huwa identiku għal l fl-indiċijiet li mhumiex diviżibbli bi tlieta, filwaqt li l-valuri tiegħu fl-indiċijiet li huma diviżibbli bi tlieta huma ugwali --Din il-funzjoni tieħu lista l u tirritorna lista l bħal dik li --  >>> sortThird [1,2,3]
--  [1,2,3]
--  >>> sortThird [5,6,3,4,8,9,2]
--  [2,6,3,4,8,9,5]
sortThird :: [Int] -> [Int]
sortThird l =","sortThird :: [Int] -> [Int]
sortThird l = map selectElem indexed
  where
    indexed = zip [0..] l
    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]
    sortedThirdElems = sortedElems thirdIndicesElems
    sortedElems = id -- or List.sort if imported
    selectElem (i, x)
      | i `mod` 3 == 0 = head sortedThirdElems
      | otherwise = x
    replaceSortedElem xs sorted = map selectElem indexed
      where
        replaceElem i (x:xs)
          | i == 0 = x:xs
          | otherwise = replaceElem (i - 1) xs
        selectElem (i, x)
          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)
          | otherwise = x","
main :: IO ()
main = do
  let candidate = sortThird
  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error ""assertion failed""
  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error ""assertion failed""
  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error ""assertion failed""
  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_34,mlt_Latn,hs,"--☐ Għajnuna għall-għażla ta' elementi uniċi f'lista ☐ Għajnuna għall-għażla ta' elementi uniċi f'lista ☐ Għajnuna għall-għażla ta' elementi uniċi f'lista ☐--  >>> unique [5,3,5,2,3,3,9,0,123]
--  [0,2,3,5,9,123]
unique :: [Int] -> [Int]
unique l =","unique :: [Int] -> [Int]
unique l = sort $ nub l
  where
    -- | Remove duplicate elements from a list.
    nub :: (Eq a) => [a] -> [a]
    nub [] = []
    nub (x:xs) = x : nub (filter (/= x) xs)

    -- | Sort a list of elements (using QuickSort algorithm).
    sort :: (Ord a) => [a] -> [a]
    sort [] = []
    sort (x:xs) =
      let smallerSorted = sort [a | a <- xs, a <= x]
          biggerSorted = sort [a | a <- xs, a > x]
      in  smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = unique
  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error ""assertion failed""
  pure ()"
HumanEval_35,mlt_Latn,hs,"--│ Jitressaq l-element massimu fil-lista. │--  >>> maxElement [1,2,3]
--  3
--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]
--  123
maxElement :: [Int] -> Int
maxElement l =","maxElement :: [Int] -> Int
maxElement [] = error ""List cannot be empty""
maxElement (x:xs) = maxElementHelper xs x
  where
    maxElementHelper [] currentMax = currentMax
    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","
main :: IO ()
main = do
  let candidate = maxElement
  if candidate [1,2,3] == 3 then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error ""assertion failed""
  pure ()"
HumanEval_36,mlt_Latn,hs,"--Iġġib in-numru ta' drabi li d-diġitu 7 jidher f'inteġers inqas minn n li huma diviżibbli b'11 jew 13.--  >>> fizzBuzz 50
--  0
--  >>> fizzBuzz 78
--  2
--  >>> fizzBuzz 79
--  3
fizzBuzz :: Int -> Int
fizzBuzz n =","fizzBuzz :: Int -> Int
fizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","
main :: IO ()
main = do
  let candidate = fizzBuzz
  if candidate 50 == 0 then pure () else error ""assertion failed""
  if candidate 78 == 2 then pure () else error ""assertion failed""
  if candidate 79 == 3 then pure () else error ""assertion failed""
  if candidate 100 == 3 then pure () else error ""assertion failed""
  if candidate 200 == 6 then pure () else error ""assertion failed""
  if candidate 4000 == 192 then pure () else error ""assertion failed""
  if candidate 10000 == 639 then pure () else error ""assertion failed""
  if candidate 100000 == 8026 then pure () else error ""assertion failed""
  pure ()"
HumanEval_37,mlt_Latn,hs,"--għall-valuri tal-indiċijiet pari ta' l, iżda magħżula. --l' huwa identiku għal l fl-indiċijiet parzjali, filwaqt li l-valuri tiegħu fl-indiċijiet pari huma ugwali --Din il-funzjoni tieħu lista l u tirritorna lista l bħal dik li --  >>> sortEven [1,2,3]
--  [1,2,3]
--  >>> sortEven [5,6,3,4]
--  [3,6,5,4]
sortEven :: [Int] -> [Int]
sortEven l =","sortEven :: [Int] -> [Int]
sortEven l = merge odds sortedEvens
  where
    (odds, evens) = partitionList l
    sortedEvens = sort evens

    partitionList :: [Int] -> ([Int], [Int])
    partitionList [] = ([], [])
    partitionList [x] = ([x], [])
    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)
      where
        (xsOdds, xsEvens) = partitionList xs

    merge :: [Int] -> [Int] -> [Int]
    merge [] ys = ys
    merge (x:xs) [] = x:xs
    merge (x:xs) (y:ys) = x:y:merge xs ys","
main :: IO ()
main = do
  let candidate = sortEven
  if candidate [1,2,3] == [1,2,3] then pure () else error ""assertion failed""
  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error ""assertion failed""
  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_39,mlt_Latn,hs,"--Ħalli n-numru li huwa numru ta' Fibonacci u huwa wkoll primjum.--  >>> primeFib 1
--  2
--  >>> primeFib 2
--  3
--  >>> primeFib 3
--  5
--  >>> primeFib 4
--  13
--  >>> primeFib 5
--  89
primeFib :: Int -> Int
primeFib n =","primeFib :: Int -> Int
primeFib n = primeFibs !! (n - 1)
  where
    primeFibs = filter isPrime fibs
    fibs = map fst $ iterate (\(a, b) -> (b, a + b)) (0, 1)

isPrime :: Int -> Bool
isPrime k
  | k < 2 = False
  | k == 2 = True
  | even k = False
  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]
  where
    upperLimit = floor . sqrt $ fromIntegral k","
main :: IO ()
main = do
  let candidate = primeFib
  if candidate 1 == 2 then pure () else error ""assertion failed""
  if candidate 2 == 3 then pure () else error ""assertion failed""
  if candidate 3 == 5 then pure () else error ""assertion failed""
  if candidate 4 == 13 then pure () else error ""assertion failed""
  if candidate 5 == 89 then pure () else error ""assertion failed""
  if candidate 6 == 233 then pure () else error ""assertion failed""
  if candidate 7 == 1597 then pure () else error ""assertion failed""
  if candidate 8 == 28657 then pure () else error ""assertion failed""
  if candidate 9 == 514229 then pure () else error ""assertion failed""
  if candidate 10 == 433494437 then pure () else error ""assertion failed""
  pure ()"
HumanEval_40,mlt_Latn,hs,"--somma għal żero, u False inkella. --jirritorna True jekk hemm tliet elementi distinti fil-lista li -- triples_sum_to_zero jieħu lista ta' enteri bħala input. --  >>> triplesSumToZero [1,3,5,0]
--  False
--  >>> triplesSumToZero [1,3,(-2),1]
--  True
--  >>> triplesSumToZero [1,2,3,7]
--  False
--  >>> triplesSumToZero [2,4,(-5),3,9,7]
--  True
--  >>> triplesSumToZero [1]
--  False
triplesSumToZero :: [Int] -> Bool
triplesSumToZero l =","triplesSumToZero :: [Int] -> Bool
triplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]
  where
    tails [] = []
    tails xs@(_:xs') = xs : tails xs'","
main :: IO ()
main = do
  let candidate = triplesSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-1)] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [1,2,5,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,9,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [1,3,5,(-100)] == False then pure () else error ""assertion failed""
  if candidate [100,3,5,(-100)] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_41,mlt_Latn,hs,"--Din il-funzjoni toħroġ in-numru ta' dawn il-kolliżjonijiet. --fil-trajettorja tagħhom bħallikieku ma ħabbatx. --Madankollu, il-karozzi huma b'saħħithom u b'saħħithom bla tarf; b'riżultat ta' dan, jibqgħu jiċċaqilqu --meta karozza li qed tiċċaqlaq mix-xellug lejn il-lemin tolqot karozza li qed tiċċaqlaq minn dritt lejn ix-xellug.--kull karozza li timxi bl-istess veloċità żewġ karozzi jingħad li jgħaqqdu--L-ewwel żewġ settijiet ta' karozzi jibdew bil-bogħod ħafna minn --n karozzi qed isuq lejn ix-xellug lejn il-lemin; simultanjament, sett differenti ta ' n karozzi --Ħa niftakru triq li hija linja perfettament dritta u infinitament twila.carRaceCollision :: Int -> Int
carRaceCollision n =","carRaceCollision :: Int -> Int
carRaceCollision n = n","
main :: IO ()
main = do
  let candidate = carRaceCollision
  if candidate 2 == 4 then pure () else error ""assertion failed""
  if candidate 3 == 9 then pure () else error ""assertion failed""
  if candidate 4 == 16 then pure () else error ""assertion failed""
  if candidate 8 == 64 then pure () else error ""assertion failed""
  if candidate 10 == 100 then pure () else error ""assertion failed""
  pure ()"
HumanEval_42,mlt_Latn,hs,"--Irtira lista b'elementi miżjuda b'1.--  >>> incrList [1,2,3]
--  [2,3,4]
--  >>> incrList [5,3,5,2,3,3,9,0,123]
--  [6,4,6,3,4,4,10,1,124]
incrList :: [Int] -> [Int]
incrList l =","incrList :: [Int] -> [Int]
incrList l = map (+1) l","
main :: IO ()
main = do
  let candidate = incrList
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [4,3,2] then pure () else error ""assertion failed""
  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error ""assertion failed""
  pure ()"
HumanEval_43,mlt_Latn,hs,"--somma għal żero, u False inkella. --jirritorna True jekk hemm żewġ elementi distinti fil-lista li --Pairs_sum_to_zero jieħu lista ta' enteri bħala input.--  >>> pairsSumToZero [1,3,5,0]
--  False
--  >>> pairsSumToZero [1,3,(-2),1]
--  False
--  >>> pairsSumToZero [1,2,3,7]
--  False
--  >>> pairsSumToZero [2,4,(-5),3,5,7]
--  True
--  >>> pairsSumToZero [1]
--  False
pairsSumToZero :: [Int] -> Bool
pairsSumToZero l =","pairsSumToZero :: [Int] -> Bool
pairsSumToZero l = any (\x -> -x `elem` l) l && (length l > 1)","
main :: IO ()
main = do
  let candidate = pairsSumToZero
  if candidate [1,3,5,0] == False then pure () else error ""assertion failed""
  if candidate [1,3,(-2),1] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,7] == False then pure () else error ""assertion failed""
  if candidate [2,4,(-5),3,5,7] == True then pure () else error ""assertion failed""
  if candidate [1] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error ""assertion failed""
  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_44,mlt_Latn,hs,"--in-numri tal-bażi huma inqas minn 10.--jirritornaw ir-rappreżentazzjoni tal-ktajjen wara l-konverżjoni. --❑ Bidla l-bażi numerika tan-numru tal-input x għal bażi.--  >>> changeBase 8 3
--  ""22""
--  >>> changeBase 8 2
--  ""1000""
--  >>> changeBase 7 2
--  ""111""
changeBase :: Int -> Int -> String
changeBase x base =","changeBase :: Int -> Int -> String
changeBase x base
  | x < base  = show x
  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","
main :: IO ()
main = do
  let candidate = changeBase
  if candidate 8 3 == ""22"" then pure () else error ""assertion failed""
  if candidate 9 3 == ""100"" then pure () else error ""assertion failed""
  if candidate 234 2 == ""11101010"" then pure () else error ""assertion failed""
  if candidate 16 2 == ""10000"" then pure () else error ""assertion failed""
  if candidate 8 2 == ""1000"" then pure () else error ""assertion failed""
  if candidate 7 2 == ""111"" then pure () else error ""assertion failed""
  if candidate 2 3 == ""2"" then pure () else error ""assertion failed""
  if candidate 3 4 == ""3"" then pure () else error ""assertion failed""
  if candidate 4 5 == ""4"" then pure () else error ""assertion failed""
  if candidate 5 6 == ""5"" then pure () else error ""assertion failed""
  if candidate 6 7 == ""6"" then pure () else error ""assertion failed""
  if candidate 7 8 == ""7"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_45,mlt_Latn,hs,"--│Meta ngħaddu mit-tul ta' naħa u l-ogħla żona ta' ritorn ta' triangolu.--  >>> triangleArea 5 3
--  7.5
triangleArea :: Int -> Int -> Float
triangleArea a h =","triangleArea :: Int -> Int -> Float
triangleArea a h = 0.5 * fromIntegral a * fromIntegral h","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 5 3 == 7.5 then pure () else error ""assertion failed""
  if candidate 2 2 == 2.0 then pure () else error ""assertion failed""
  if candidate 10 8 == 40.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_46,mlt_Latn,hs,"--Jekk jogħġbok ikteb funzjoni biex tikkalkula b'mod effiċjenti l-element n-ta' sekwenza ta' numri fib4. Tużax rikorsjoni. --fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). --fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4 ((0) -> 0 --Is-sekwenza tan-numri Fib4 hija sekwenza simili għas-sekwenza ta' Fibbonacci li hija definita kif ġej:--  >>> fib4 5
--  4
--  >>> fib4 6
--  8
--  >>> fib4 7
--  14
fib4 :: Int -> Int
fib4 n =","fib4 :: Int -> Int
fib4 n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 2
  | n == 3 = 0
  | otherwise = iter 0 0 2 0 n
  where
    iter a b c d 4 = a + b + c + d
    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","
main :: IO ()
main = do
  let candidate = fib4
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 28 then pure () else error ""assertion failed""
  if candidate 10 == 104 then pure () else error ""assertion failed""
  if candidate 12 == 386 then pure () else error ""assertion failed""
  pure ()"
HumanEval_47,mlt_Latn,hs,"--Irtira medjan ta ' elementi fil- lista l. --  >>> median [3,1,2,4,5]
--  3.0
--  >>> median [(-10),4,6,1000,10,20]
--  15.0
median :: [Int] -> Float
median l =","median :: [Int] -> Float
median l 
  | odd n     = fromIntegral $ sorted !! mid
  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) / 2
  where
    sorted = sort l
    n = length l
    mid = n `div` 2
    sort = sortBy compare","
main :: IO ()
main = do
  let candidate = median
  if candidate [3,1,2,4,5] == 3.0 then pure () else error ""assertion failed""
  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error ""assertion failed""
  if candidate [5] == 5.0 then pure () else error ""assertion failed""
  if candidate [6,5] == 5.5 then pure () else error ""assertion failed""
  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_48,mlt_Latn,hs,"--Iċċekkja jekk stringa mogħtija hija palindrome --  >>> isPalindrome """"
--  True
--  >>> isPalindrome ""aba""
--  True
--  >>> isPalindrome ""aaaaa""
--  True
--  >>> isPalindrome ""zbcd""
--  False
isPalindrome :: String -> Bool
isPalindrome text =","isPalindrome :: String -> Bool
isPalindrome text = text == reverse text","
main :: IO ()
main = do
  let candidate = isPalindrome
  if candidate """" == True then pure () else error ""assertion failed""
  if candidate ""aba"" == True then pure () else error ""assertion failed""
  if candidate ""aaaaa"" == True then pure () else error ""assertion failed""
  if candidate ""zbcd"" == False then pure () else error ""assertion failed""
  if candidate ""xywyx"" == True then pure () else error ""assertion failed""
  if candidate ""xywyz"" == False then pure () else error ""assertion failed""
  if candidate ""xywzx"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_49,mlt_Latn,hs,"--Irtira 2^n modulo p (kun konxju tan-numeriċi).--  >>> modp 3 5
--  3
--  >>> modp 1101 101
--  2
--  >>> modp 0 101
--  1
--  >>> modp 3 11
--  8
--  >>> modp 100 101
--  1
modp :: Int -> Int -> Int
modp n p =","modp :: Int -> Int -> Int
modp n p = powMod 2 n p

powMod :: Int -> Int -> Int -> Int
powMod base exp modulus
  | modulus == 1 = 0
  | exp == 0     = 1
  | exp == 1     = base `mod` modulus
  | otherwise    = if odd exp
                   then (base * halfExp * halfExp) `mod` modulus
                   else (halfExp * halfExp) `mod` modulus
  where
    halfExp = powMod base (exp `div` 2) modulus","
main :: IO ()
main = do
  let candidate = modp
  if candidate 3 5 == 3 then pure () else error ""assertion failed""
  if candidate 1101 101 == 2 then pure () else error ""assertion failed""
  if candidate 0 101 == 1 then pure () else error ""assertion failed""
  if candidate 3 11 == 8 then pure () else error ""assertion failed""
  if candidate 100 101 == 1 then pure () else error ""assertion failed""
  if candidate 30 5 == 4 then pure () else error ""assertion failed""
  if candidate 31 5 == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_51,mlt_Latn,hs,"-- remove_vowels hija funzjoni li tieħu string u jirritorna string mingħajr vokali. --  >>> removeVowels """"
--  """"
--  >>> removeVowels ""abcdef""
--  ""bcdf""
--  >>> removeVowels ""aaaaa""
--  """"
--  >>> removeVowels ""aaBAA""
--  ""B""
--  >>> removeVowels ""zbcd""
--  ""zbcd""
removeVowels :: String -> String
removeVowels text =","removeVowels :: String -> String
removeVowels text = filter (`notElem` ""aeiouAEIOU"") text","
main :: IO ()
main = do
  let candidate = removeVowels
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""abcdef
ghijklm"" == ""bcdf
ghjklm"" then pure () else error ""assertion failed""
  if candidate ""fedcba"" == ""fdcb"" then pure () else error ""assertion failed""
  if candidate ""eeeee"" == """" then pure () else error ""assertion failed""
  if candidate ""acBAA"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""EcBOO"" == ""cB"" then pure () else error ""assertion failed""
  if candidate ""ybcd"" == ""ybcd"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_52,mlt_Latn,hs,"--Irtira True jekk in-numri kollha fil-lista l huma taħt il-limitu t.--  >>> belowThreshold [1,2,4,10] 100
--  True
--  >>> belowThreshold [1,20,4,10] 5
--  False
belowThreshold :: [Int] -> Int -> Bool
belowThreshold l t =",belowThreshold l t = all (< t) l,"
main :: IO ()
main = do
  let candidate = belowThreshold
  if candidate [1,2,4,10] 100 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 5 == False then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 21 == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] 22 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 11 == True then pure () else error ""assertion failed""
  if candidate [1,8,4,10] 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_53,mlt_Latn,hs,"--Żid żewġ numri x u y.--  >>> add 2 3
--  5
--  >>> add 5 7
--  12
add :: Int -> Int -> Int
add x y =","add :: Int -> Int -> Int
add x y = x + y","
main :: IO ()
main = do
  let candidate = add
  if candidate 0 1 == 1 then pure () else error ""assertion failed""
  if candidate 1 0 == 1 then pure () else error ""assertion failed""
  if candidate 2 3 == 5 then pure () else error ""assertion failed""
  if candidate 5 7 == 12 then pure () else error ""assertion failed""
  if candidate 7 5 == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_54,mlt_Latn,hs,"--◯ Iċċekkja jekk żewġ kelmiet għandhomx l-istess karattri. ◯--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddeddabc""
--  True
--  >>> sameChars ""abcd"" ""dddddddabc""
--  True
--  >>> sameChars ""dddddddabc"" ""abcd""
--  True
--  >>> sameChars ""eabcd"" ""dddddddabc""
--  False
--  >>> sameChars ""abcd"" ""dddddddabce""
--  False
--  >>> sameChars ""eabcdzzzz"" ""dddzzzzzzzddddabc""
--  False
sameChars :: String -> String -> Bool
sameChars s0 s1 =","import Data.List (nub, sort)

sameChars :: String -> String -> Bool
sameChars s0 s1 = sort (nub s0) == sort (nub s1)","
main :: IO ()
main = do
  let candidate = sameChars
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddeddabc"" == True then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabc"" == True then pure () else error ""assertion failed""
  if candidate ""dddddddabc"" ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""eabcd"" ""dddddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" ""dddddddabcf"" == False then pure () else error ""assertion failed""
  if candidate ""eabcdzzzz"" ""dddzzzzzzzddddabc"" == False then pure () else error ""assertion failed""
  if candidate ""aabb"" ""aaccc"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_55,mlt_Latn,hs,"--│ Irritorna n-numru Fibonacci. │--  >>> fib 10
--  55
--  >>> fib 1
--  1
--  >>> fib 8
--  21
fib :: Int -> Int
fib n =","fib :: Int -> Int
fib n = fibHelper 0 1 n
  where
    fibHelper a _ 0 = a
    fibHelper a b n = fibHelper b (a + b) (n - 1)","
main :: IO ()
main = do
  let candidate = fib
  if candidate 10 == 55 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 8 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 89 then pure () else error ""assertion failed""
  if candidate 12 == 144 then pure () else error ""assertion failed""
  pure ()"
HumanEval_56,mlt_Latn,hs,"--return True jekk kull bracket tal-ftuħ ikollu bracket tal-għeluq korrispondenti. -- parentesi hija string ta ""<"" u "">"". --  >>> correctBracketing ""<""
--  False
--  >>> correctBracketing ""<>""
--  True
--  >>> correctBracketing ""<<><>>""
--  True
--  >>> correctBracketing ""><<>""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBrackets brackets 0 == 0

checkBrackets :: String -> Int -> Int
checkBrackets [] n = n
checkBrackets (x:xs) n
  | n < 0 = -1
  | x == '<' = checkBrackets xs (n + 1)
  | x == '>' = checkBrackets xs (n - 1)
  | otherwise = checkBrackets xs n","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""<>"" == True then pure () else error ""assertion failed""
  if candidate ""<<><>>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>"" == True then pure () else error ""assertion failed""
  if candidate ""<><><<<><><>><>><<><><<>>>"" == True then pure () else error ""assertion failed""
  if candidate ""<<<><>>>>"" == False then pure () else error ""assertion failed""
  if candidate ""><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<"" == False then pure () else error ""assertion failed""
  if candidate ""<<<<"" == False then pure () else error ""assertion failed""
  if candidate "">"" == False then pure () else error ""assertion failed""
  if candidate ""<<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>><<>"" == False then pure () else error ""assertion failed""
  if candidate ""<><><<><>><>>><>"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_57,mlt_Latn,hs,"--Ħallas True huwa element tal-lista huma monotonically jiżdiedu jew jonqsu.--  >>> monotonic [1,2,4,20]
--  True
--  >>> monotonic [1,20,4,10]
--  False
--  >>> monotonic [4,1,0,(-10)]
--  True
monotonic :: [Int] -> Bool
monotonic l =","monotonic :: [Int] -> Bool
monotonic l = increasing l || decreasing l
  where
    increasing xs = all (uncurry (<=)) (zip xs (tail xs))
    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","
main :: IO ()
main = do
  let candidate = monotonic
  if candidate [1,2,4,10] == True then pure () else error ""assertion failed""
  if candidate [1,2,4,20] == True then pure () else error ""assertion failed""
  if candidate [1,20,4,10] == False then pure () else error ""assertion failed""
  if candidate [4,1,0,(-10)] == True then pure () else error ""assertion failed""
  if candidate [4,1,1,0] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,2,5,60] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,60] == True then pure () else error ""assertion failed""
  if candidate [9,9,9,9] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_58,mlt_Latn,hs,"--│ Irritorna elementi komuni magħżula unika għal żewġ listi. │--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]
--  [1,5,653]
--  >>> common [5,3,2,8] [3,2]
--  [2,3]
common :: [Int] -> [Int] -> [Int]
common l1 l2 =","common :: [Int] -> [Int] -> [Int]
common l1 l2 = uniqueSortedCommon
  where
    commonElements = filter (`elem` l2) l1
    uniqueCommon = removeDuplicates commonElements
    uniqueSortedCommon = sort uniqueCommon

    removeDuplicates :: [Int] -> [Int]
    removeDuplicates = foldr (\x seen -> if x `elem` seen then seen else x : seen) []

    sort :: [Int] -> [Int]
    sort [] = []
    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)
      where
        lesser  = filter (< p) xs
        greater = filter (>= p) xs","
main :: IO ()
main = do
  let candidate = common
  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error ""assertion failed""
  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error ""assertion failed""
  if candidate [4,3,2,8] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_59,mlt_Latn,hs,"--Ħalli n > 1 u mhux prim.--  >>> largestPrimeFactor 13195
--  29
--  >>> largestPrimeFactor 2048
--  2
largestPrimeFactor :: Int -> Int
largestPrimeFactor n =","largestPrimeFactor :: Int -> Int
largestPrimeFactor n = helper n 2
  where
    helper n factor
      | factor * factor > n = n
      | n `mod` factor == 0 = helper (n `div` factor) factor
      | otherwise = helper n (factor + 1)","
main :: IO ()
main = do
  let candidate = largestPrimeFactor
  if candidate 15 == 5 then pure () else error ""assertion failed""
  if candidate 27 == 3 then pure () else error ""assertion failed""
  if candidate 63 == 7 then pure () else error ""assertion failed""
  if candidate 330 == 11 then pure () else error ""assertion failed""
  if candidate 13195 == 29 then pure () else error ""assertion failed""
  pure ()"
HumanEval_60,mlt_Latn,hs,"--Sum_to_n hija funzjoni li ssemmi numri minn 1 sa n.--  >>> sumToN 30
--  465
--  >>> sumToN 100
--  5050
--  >>> sumToN 5
--  15
--  >>> sumToN 10
--  55
--  >>> sumToN 1
--  1
sumToN :: Int -> Int
sumToN n =","sumToN :: Int -> Int
sumToN n = sum [1..n]","
main :: IO ()
main = do
  let candidate = sumToN
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 21 then pure () else error ""assertion failed""
  if candidate 11 == 66 then pure () else error ""assertion failed""
  if candidate 30 == 465 then pure () else error ""assertion failed""
  if candidate 100 == 5050 then pure () else error ""assertion failed""
  pure ()"
HumanEval_61,mlt_Latn,hs,"--return True jekk kull bracket tal-ftuħ ikollu bracket tal-għeluq korrispondenti. --│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │--  >>> correctBracketing ""(""
--  False
--  >>> correctBracketing ""()""
--  True
--  >>> correctBracketing ""(()())""
--  True
--  >>> correctBracketing "")(()""
--  False
correctBracketing :: String -> Bool
correctBracketing brackets =","correctBracketing :: String -> Bool
correctBracketing brackets = checkBalance brackets 0
  where
    checkBalance [] 0 = True
    checkBalance [] _ = False
    checkBalance (x:xs) n
      | x == '('  = checkBalance xs (n + 1)
      | x == ')' && n > 0 = checkBalance xs (n - 1)
      | otherwise = False","
main :: IO ()
main = do
  let candidate = correctBracketing
  if candidate ""()"" == True then pure () else error ""assertion failed""
  if candidate ""(()())"" == True then pure () else error ""assertion failed""
  if candidate ""()()(()())()"" == True then pure () else error ""assertion failed""
  if candidate ""()()((()()())())(()()(()))"" == True then pure () else error ""assertion failed""
  if candidate ""((()())))"" == False then pure () else error ""assertion failed""
  if candidate "")(()"" == False then pure () else error ""assertion failed""
  if candidate ""("" == False then pure () else error ""assertion failed""
  if candidate ""(((("" == False then pure () else error ""assertion failed""
  if candidate "")"" == False then pure () else error ""assertion failed""
  if candidate ""(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())())(()"" == False then pure () else error ""assertion failed""
  if candidate ""()()(()())()))()"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_62,mlt_Latn,hs,"--Irritorna d-derivattiva ta' dan il-polinom fl-istess forma. --xs[0] + xs[1] * x + xs[2] * x^2 + .... --│ │ xs jirrappreżentaw koefffiċjenti ta ' polinomi. │--  >>> derivative [3,1,2,4,5]
--  [1,4,12,20]
--  >>> derivative [1,2,3]
--  [2,6]
derivative :: [Int] -> [Int]
derivative xs =","derivative :: [Int] -> [Int]
derivative xs = zipWith (*) (tail xs) [1..]","
main :: IO ()
main = do
  let candidate = derivative
  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,6] then pure () else error ""assertion failed""
  if candidate [3,2,1] == [2,2] then pure () else error ""assertion failed""
  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error ""assertion failed""
  if candidate [1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_63,mlt_Latn,hs,"--Jekk jogħġbok ikteb funzjoni biex tikkalkula b'mod effiċjenti l-element n-ta' sekwenza ta' numri fibfib. --fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). --fib fib ((2) == 1 --fibfib ((1) == 0 --fibfib ((0) == 0 --Is-sekwenza tan-numri FibFib hija sekwenza simili għas-sekwenza ta' Fibbonacci li hija definita kif ġej:--  >>> fibfib 1
--  0
--  >>> fibfib 5
--  4
--  >>> fibfib 8
--  24
fibfib :: Int -> Int
fibfib n =","fibfib :: Int -> Int
fibfib n
  | n == 0 = 0
  | n == 1 = 0
  | n == 2 = 1
  | otherwise = fibs !! n
  where
    fibs = 0 : 0 : 1 : zipWith3 (\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","
main :: IO ()
main = do
  let candidate = fibfib
  if candidate 2 == 1 then pure () else error ""assertion failed""
  if candidate 1 == 0 then pure () else error ""assertion failed""
  if candidate 5 == 4 then pure () else error ""assertion failed""
  if candidate 8 == 24 then pure () else error ""assertion failed""
  if candidate 10 == 81 then pure () else error ""assertion failed""
  if candidate 12 == 274 then pure () else error ""assertion failed""
  if candidate 14 == 927 then pure () else error ""assertion failed""
  pure ()"
HumanEval_64,mlt_Latn,hs,"--Eżempju: --vokali, iżda biss meta tkun fi tmiem il-kelma mogħtija. --Il-vokali f'dan il-każ huma 'a', 'e', 'i', 'o', 'u'. Hawnhekk, 'y' hija wkoll a --kelma bħala input u jirritorna n-numru ta ' vokali fil-string. --Għidilna funzjoni vowels_count li tieħu stringa li tirrappreżenta --  >>> vowelsCount ""abcde""
--  2
--  >>> vowelsCount ""ACEDY""
--  3
vowelsCount :: String -> Int
vowelsCount s =","vowelsCount :: String -> Int
vowelsCount s = length $ filter isVowel $ zip s [1..]
  where
    isVowel (c, pos) =
      let lowercaseC = toLower c
          isRegularVowel = lowercaseC `elem` ""aeiou""
          isLastCharY = lowercaseC == 'y' && pos == length s
      in isRegularVowel || isLastCharY","
main :: IO ()
main = do
  let candidate = vowelsCount
  if candidate ""abcde"" == 2 then pure () else error ""assertion failed""
  if candidate ""Alone"" == 3 then pure () else error ""assertion failed""
  if candidate ""key"" == 2 then pure () else error ""assertion failed""
  if candidate ""bye"" == 1 then pure () else error ""assertion failed""
  if candidate ""keY"" == 2 then pure () else error ""assertion failed""
  if candidate ""bYe"" == 1 then pure () else error ""assertion failed""
  if candidate ""ACEDY"" == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_65,mlt_Latn,hs,"--Jekk shift > numru ta' ċifri, id-diġiti ta' ritorn jinbidlu. --u jirritorna r-riżultat bħala stringa. --│ │Iċ-ċirkuli jbiddel iċ-ċifri tal-integer x, iċċaqlaq iċ-ċifri dritt b'xi bidla │--  >>> circularShift 12 1
--  ""21""
--  >>> circularShift 12 2
--  ""12""
circularShift :: Int -> Int -> String
circularShift x shift =","circularShift :: Int -> Int -> String
circularShift x shift =
  let digits = show x
      len = length digits
      effectiveShift = shift `mod` len
  in if shift > len
     then reverse digits
     else let (begin, end) = splitAt (len - effectiveShift) digits
          in end ++ begin","
main :: IO ()
main = do
  let candidate = circularShift
  if candidate 100 2 == ""001"" then pure () else error ""assertion failed""
  if candidate 12 2 == ""12"" then pure () else error ""assertion failed""
  if candidate 97 8 == ""79"" then pure () else error ""assertion failed""
  if candidate 12 1 == ""21"" then pure () else error ""assertion failed""
  if candidate 11 101 == ""11"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_66,mlt_Latn,hs,"--Eżempji: --Kodiċijiet ASCII. --Ikteb funzjoni li tieħu stringa bħala input u tirritorna s-somma tal-karattri ta 'fuq biss' --Xogħol.--  >>> digitsum """"
--  0
--  >>> digitsum ""abAB""
--  131
--  >>> digitsum ""abcCd""
--  67
--  >>> digitsum ""helloE""
--  69
--  >>> digitsum ""woArBld""
--  131
--  >>> digitsum ""aAaaaXa""
--  153
digitsum :: String -> Int
digitsum s =","digitsum :: String -> Int
digitsum s = sum $ map fromEnum $ filter isUpper s","
main :: IO ()
main = do
  let candidate = digitsum
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""abAB"" == 131 then pure () else error ""assertion failed""
  if candidate ""abcCd"" == 67 then pure () else error ""assertion failed""
  if candidate ""helloE"" == 69 then pure () else error ""assertion failed""
  if candidate ""woArBld"" == 131 then pure () else error ""assertion failed""
  if candidate ""aAaaaXa"" == 153 then pure () else error ""assertion failed""
  if candidate "" How are yOu?"" == 151 then pure () else error ""assertion failed""
  if candidate ""You arE Very Smart"" == 327 then pure () else error ""assertion failed""
  pure ()"
HumanEval_67,mlt_Latn,hs,"--għal examble: --fil-basket jirritorna n-numru ta' frott tal-manga fil-basket. --l-oranġji u l-tuffieħ u numru sħiħ li jirrappreżenta n-numru totali tal-frott --Apples, oranġji, u frott tal-manga. Given il-string li jirrappreżenta l-għadd totali ta ' --li huma mqassma f' bastiment ta ' frott li dan l-apparat fih --F'din il-kompitu, inti se tingħata string li jirrappreżenta numru ta 'tuffieħ u oranġji.--  >>> fruitDistribution ""5 apples and 6 oranges"" 19
--  8
--  >>> fruitDistribution ""0 apples and 1 oranges"" 3
--  2
--  >>> fruitDistribution ""2 apples and 3 oranges"" 100
--  95
--  >>> fruitDistribution ""100 apples and 1 oranges"" 120
--  19
fruitDistribution :: String -> Int -> Int
fruitDistribution s n =","import Text.Read (readMaybe)

fruitDistribution :: String -> Int -> Int
fruitDistribution s n = n - totalApplesOranges
  where
    totalApplesOranges = sum $ map (readNumber . words) [""apples"", ""oranges""]
    readNumber keyword = case dropWhile (not . (=="" "") . dropWhile (/=' ')) $ words s of
      [] -> 0
      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","
main :: IO ()
main = do
  let candidate = fruitDistribution
  if candidate ""5 apples and 6 oranges"" 19 == 8 then pure () else error ""assertion failed""
  if candidate ""5 apples and 6 oranges"" 21 == 10 then pure () else error ""assertion failed""
  if candidate ""0 apples and 1 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""1 apples and 0 oranges"" 3 == 2 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 100 == 95 then pure () else error ""assertion failed""
  if candidate ""2 apples and 3 oranges"" 5 == 0 then pure () else error ""assertion failed""
  if candidate ""1 apples and 100 oranges"" 120 == 19 then pure () else error ""assertion failed""
  pure ()"
HumanEval_68,mlt_Latn,hs,"--Eżempju 1: --Jekk ma jkunx hemm valuri pari jew il-lista mogħtija tkun vojta, irritorna []. --Il-nodu miġbud għandu jiġi ritornat f'lista, [ smalest_value, l-indiċi tiegħu ], --Jekk jinstabu nodi multipli bl-istess valur pari l-iżgħar, irritorna n-nodu li għandu l-iżgħar indiċi. --Il-mekkaniżmu ta' kontroll tal-prestazzjoni għandu jkun li l-magna tkun qed taħdem b'mod effiċjenti.--l-kompitu tiegħek huwa li taqta 'wieħed mill-nodes u jirritornawh. --""Meta tingħata lista li tirrappreżenta fergħa ta 'siġra li għandha nodi ta' numru sħiħ mhux negattiv --  >>> pluck [4,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 2:
--  >>> pluck [1,2,3]
--  [2,1]
--  Explanation: 2 has the smallest even value, and 2 has the smallest index.
--  Example 3:
--  >>> pluck []
--  []
--  Example 4:
--  >>> pluck [5,0,3,0,4,2]
--  [0,1]
--  Explanation: 0 is the smallest value, but  there are two zeros,
--  so we will choose the first zero, which has the smallest index.
--  Constraints:
--  * 1 <= nodes.length <= 10000
--  * 0 <= node.value
pluck :: [Int] -> [Int]
pluck arr =","pluck :: [Int] -> [Int]
pluck arr = case filter (\(x, _) -> even x) (zip arr [0..]) of
    [] -> []
    evens -> let (value, index) = minimum evens in [value, index]","
main :: IO ()
main = do
  let candidate = pluck
  if candidate [4,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [1,2,3] == [2,1] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error ""assertion failed""
  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error ""assertion failed""
  if candidate [5,4,8,4,8] == [4,1] then pure () else error ""assertion failed""
  if candidate [7,6,7,1] == [6,1] then pure () else error ""assertion failed""
  if candidate [7,9,7,1] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_69,mlt_Latn,hs,"--Eżempji: --Jekk ma jeżistix valur bħal dan, jirritorna -1. --Il-frekwenza ta' numru sħiħ hija n-numru ta' drabi li jidher fil-lista. --żero, u għandu frekwenza akbar minn jew ugwali għall-valur tal-inteġer innifsu. --Inti tingħata lista mhux vojta ta 'integers pożittivi. jirritorna l-akbar numru sħiħ li huwa akbar minn --  >>> search [4,1,2,2,3,1]
--  2
--  >>> search [1,2,2,3,3,3,4,4,4]
--  3
--  >>> search [5,5,4,4,4]
--  (-1)
search :: [Int] -> Int
search lst =","import Data.List (group, sort)
import Data.Ord (comparing)

search :: [Int] -> Int
search lst = 
    let frequencies = map (\g -> (head g, length g)) . group . sort $ lst
        candidates = filter (\(val, freq) -> freq >= val) frequencies
    in case candidates of
         [] -> -1
         _  -> fst . maximum $ candidates","
main :: IO ()
main = do
  let candidate = search
  if candidate [5,5,5,5,1] == 1 then pure () else error ""assertion failed""
  if candidate [4,1,4,1,4,4] == 4 then pure () else error ""assertion failed""
  if candidate [3,3] == (-1) then pure () else error ""assertion failed""
  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error ""assertion failed""
  if candidate [2,3,3,2,2] == 2 then pure () else error ""assertion failed""
  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error ""assertion failed""
  if candidate [3,2,8,2] == 2 then pure () else error ""assertion failed""
  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error ""assertion failed""
  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error ""assertion failed""
  if candidate [1,9,10,1,3] == 1 then pure () else error ""assertion failed""
  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error ""assertion failed""
  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error ""assertion failed""
  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error ""assertion failed""
  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error ""assertion failed""
  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error ""assertion failed""
  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error ""assertion failed""
  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error ""assertion failed""
  if candidate [10] == (-1) then pure () else error ""assertion failed""
  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error ""assertion failed""
  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error ""assertion failed""
  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error ""assertion failed""
  if candidate [3,10,10,9,2] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_70,mlt_Latn,hs,"--Eżempji: --allura massimu tal-inteġers li jifdal, allura minimu u hekk 'il quddiem. --Strange sorting, huwa meta inti tibda bil-valur minimu, --│ │Għall-lista ta' intjeri, tirritorna lista f'ordni stramba.--  >>> strangeSortList [1,2,3,4]
--  [1,4,2,3]
--  >>> strangeSortList [5,5,5,5]
--  [5,5,5,5]
--  >>> strangeSortList []
--  []
strangeSortList :: [Int] -> [Int]
strangeSortList lst =","strangeSortList :: [Int] -> [Int]
strangeSortList [] = []
strangeSortList lst = go (sort lst) True
  where
    go [] _ = []
    go xs toggle
      | toggle    = head xs : go (tail xs) False
      | otherwise = last xs : go (init xs) True","
main :: IO ()
main = do
  let candidate = strangeSortList
  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error ""assertion failed""
  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error ""assertion failed""
  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error ""assertion failed""
  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error ""assertion failed""
  if candidate [111111] == [111111] then pure () else error ""assertion failed""
  pure ()"
HumanEval_71,mlt_Latn,hs,"--Eżempju: --minn naħa tat-tielet.--Tliet naħat jagħmlu trijangolu validu meta s-somma ta ' kwalunkwe żewġ naħat tkun akbar --Inkella jirritorna -1 --it-triangolu mqarreb għal 2 punti deċimali jekk it-tliet naħat jiffurmaw triangolu validu. --Meta ngħidu t-tul tat-tliet naħat ta 'triangolu, irridu nħarsu lejn l-erja ta'--  >>> triangleArea 3 4 5
--  6.0
--  >>> triangleArea 1 2 10
--  (-1).0
triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c =","import Text.Printf (printf)

triangleArea :: Int -> Int -> Int -> Float
triangleArea a b c
    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))
    | otherwise = -1
  where
    s = (fromIntegral (a + b + c)) / 2
    isValidTriangle x y z = x + y > z && x + z > y && y + z > x
    roundToTwoDecimals x = read (printf ""%.2f"" x) :: Float","
main :: IO ()
main = do
  let candidate = triangleArea
  if candidate 3 4 5 == 6.0 then pure () else error ""assertion failed""
  if candidate 1 2 10 == (-1).0 then pure () else error ""assertion failed""
  if candidate 4 8 5 == 8.18 then pure () else error ""assertion failed""
  if candidate 2 2 2 == 1.73 then pure () else error ""assertion failed""
  if candidate 1 2 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 10 5 7 == 16.25 then pure () else error ""assertion failed""
  if candidate 2 6 3 == (-1).0 then pure () else error ""assertion failed""
  if candidate 1 1 1 == 0.43 then pure () else error ""assertion failed""
  if candidate 2 2 10 == (-1).0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_72,mlt_Latn,hs,"--Eżempju: --L-oġġett q se jtir jekk ikun bilanċjat (hija lista palindroma) u s-somma tal-elementi tagħha tkun inqas minn jew ugwali għall-piż massimu possibbli w.--Ħu l-funzjoni li tirritorna True jekk l-oġġett q se jtir, u False inkella.--  >>> willItFly [1,2] 5
--  False
--  # 1+2 is less than the maximum possible weight, but it's unbalanced.
--  >>> willItFly [3,2,3] 1
--  False
--  # it's balanced, but 3+2+3 is more than the maximum possible weight.
--  >>> willItFly [3,2,3] 9
--  True
--  # 3+2+3 is less than the maximum possible weight, and it's balanced.
--  >>> willItFly [3] 5
--  True
--  # 3 is less than the maximum possible weight, and it's balanced.
willItFly :: [Int] -> Int -> Bool
willItFly q w =","willItFly :: [Int] -> Int -> Bool
willItFly q w = isPalindrome q && sum q <= w

isPalindrome :: Eq a => [a] -> Bool
isPalindrome xs = xs == reverse xs","
main :: IO ()
main = do
  let candidate = willItFly
  if candidate [3,2,3] 9 == True then pure () else error ""assertion failed""
  if candidate [1,2] 5 == False then pure () else error ""assertion failed""
  if candidate [3] 5 == True then pure () else error ""assertion failed""
  if candidate [3,2,3] 1 == False then pure () else error ""assertion failed""
  if candidate [1,2,3] 6 == False then pure () else error ""assertion failed""
  if candidate [5] 5 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_73,mlt_Latn,hs,"--Pereżempju: --L-istess element jista' jinbidel f'kull element ieħor.--lista palindroma hija lista li --Meta tingħata lista arr ta 'integers, issib l-għadd minimu ta' elementi li --  >>> smallestChange [1,2,3,5,4,7,9,6]
--  4
--  >>> smallestChange [1,2,3,4,3,2,2]
--  1
--  >>> smallestChange [1,2,3,2,1]
--  0
smallestChange :: [Int] -> Int
smallestChange arr =","smallestChange :: [Int] -> Int
smallestChange arr = sum $ zipWith (\x y -> if x /= y then 1 else 0) arr (reverse arr)","
main :: IO ()
main = do
  let candidate = smallestChange
  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error ""assertion failed""
  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,4,4,2] == 1 then pure () else error ""assertion failed""
  if candidate [1,2,3,2,1] == 0 then pure () else error ""assertion failed""
  if candidate [3,1,1,3] == 0 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_74,mlt_Latn,hs,"--Eżempji --jekk iż-żewġ listi jkollhom l-istess numru ta' karri, irritorna l-ewwel lista. --in-numru totali ta' karri fil-ktajjen kollha tal-lista inqas mill-lista l-oħra. --Għandek tikteb funzjoni li taċċetta żewġ listi ta ' strings u tirritorna l- lista li għandha --  >>> totalMatch [] []
--  []
--  >>> totalMatch [""hi"",""admin""] [""hI"",""Hi""]
--  [""hI"",""Hi""]
--  >>> totalMatch [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""]
--  [""hi"",""admin""]
--  >>> totalMatch [""hi"",""admin""] [""hI"",""hi"",""hi""]
--  [""hI"",""hi"",""hi""]
--  >>> totalMatch [""4""] [""1"",""2"",""3"",""4"",""5""]
--  [""4""]
totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2 =","totalMatch :: [String] -> [String] -> [String]
totalMatch lst1 lst2
  | totalChars lst1 < totalChars lst2 = lst1
  | totalChars lst1 > totalChars lst2 = lst2
  | otherwise = lst1
  where
    totalChars = sum . map length","
main :: IO ()
main = do
  let candidate = totalMatch
  if candidate [] [] == [] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi""] == [""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hi"",""hi"",""admin"",""project""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [""4""] [""1"",""2"",""3"",""4"",""5""] == [""4""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""Hi""] == [""hI"",""Hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hi""] == [""hI"",""hi"",""hi""] then pure () else error ""assertion failed""
  if candidate [""hi"",""admin""] [""hI"",""hi"",""hii""] == [""hi"",""admin""] then pure () else error ""assertion failed""
  if candidate [] [""this""] == [] then pure () else error ""assertion failed""
  if candidate [""this""] [] == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_75,mlt_Latn,hs,"--Eżempju: --Meta tkun taf li (a) huwa inqas minn 100. --u falza jekk ma jkunx hekk. --Għajnuna biex tikteb funzjoni li tirritorna vera jekk in-numru mogħti huwa l-multiplikazzjoni ta ' 3 numri primi.--  >>> isMultiplyPrime 30
--  True
--  30 = 2 * 3 * 5
isMultiplyPrime :: Int -> Bool
isMultiplyPrime a =","isMultiplyPrime :: Int -> Bool
isMultiplyPrime a = any isTriplePrimeProduct primeTriples
  where
    primes = filter isPrime [2..99]
    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]
    isTriplePrimeProduct (x, y, z) = x * y * z == a

isPrime :: Int -> Bool
isPrime n 
  | n < 2     = False
  | otherwise = not (any (\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","
main :: IO ()
main = do
  let candidate = isMultiplyPrime
  if candidate 5 == False then pure () else error ""assertion failed""
  if candidate 30 == True then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == False then pure () else error ""assertion failed""
  if candidate 125 == True then pure () else error ""assertion failed""
  if candidate 105 == True then pure () else error ""assertion failed""
  if candidate 126 == False then pure () else error ""assertion failed""
  if candidate 729 == False then pure () else error ""assertion failed""
  if candidate 891 == False then pure () else error ""assertion failed""
  if candidate 1001 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_76,mlt_Latn,hs,"--Pereżempju: --x huwa qawwa sempliċi ta ' n jekk n**int=x --qawwa ta' n u false f'każijiet oħra. --Għandek tikteb funzjoni li tirritorna true jekk numru x hu sempliċi.--  >>> isSimplePower 1 4
--  True
--  >>> isSimplePower 2 2
--  True
--  >>> isSimplePower 8 2
--  True
--  >>> isSimplePower 3 2
--  False
--  >>> isSimplePower 3 1
--  False
--  >>> isSimplePower 5 3
--  False
isSimplePower :: Int -> Int -> Bool
isSimplePower x n =","isSimplePower :: Int -> Int -> Bool
isSimplePower x n
  | x < 1 || n < 1 = False
  | n == 1 = x == 1
  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","
main :: IO ()
main = do
  let candidate = isSimplePower
  if candidate 16 2 == True then pure () else error ""assertion failed""
  if candidate 143214 16 == False then pure () else error ""assertion failed""
  if candidate 4 2 == True then pure () else error ""assertion failed""
  if candidate 9 3 == True then pure () else error ""assertion failed""
  if candidate 16 4 == True then pure () else error ""assertion failed""
  if candidate 24 2 == False then pure () else error ""assertion failed""
  if candidate 128 4 == False then pure () else error ""assertion failed""
  if candidate 12 6 == False then pure () else error ""assertion failed""
  if candidate 1 1 == True then pure () else error ""assertion failed""
  if candidate 1 12 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_77,mlt_Latn,hs,"--Eżempji: --Nota: tista' tassumi li l-input huwa dejjem validu. --jekk dan ingeger huwa kubju ta ' xi numru sħiħ. --Ikteb funzjoni li tieħu numru sħiħ a u jirritorna True.--  >>> iscube 1
--  True
--  >>> iscube 2
--  False
--  >>> iscube (-1)
--  True
--  >>> iscube 64
--  True
--  >>> iscube 0
--  True
--  >>> iscube 180
--  False
iscube :: Int -> Bool
iscube a =","iscube :: Int -> Bool
iscube a = let n = round (fromIntegral a ** (1/3)) in n^3 == a","
main :: IO ()
main = do
  let candidate = iscube
  if candidate 1 == True then pure () else error ""assertion failed""
  if candidate 2 == False then pure () else error ""assertion failed""
  if candidate (-1) == True then pure () else error ""assertion failed""
  if candidate 64 == True then pure () else error ""assertion failed""
  if candidate 180 == False then pure () else error ""assertion failed""
  if candidate 1000 == True then pure () else error ""assertion failed""
  if candidate 0 == True then pure () else error ""assertion failed""
  if candidate 1729 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_78,mlt_Latn,hs,"--Eżempji: --u s-simboli A,B,C,D,E,F huma dejjem bil-kotba kbar. --Nota: tista 'taċċetta li l-input huwa dejjem korrett jew stringa vojta, --B (= deċimali 11), D (= deċimali 13). --Allura inti għandek biex jiddeterminaw numru ta ' l-diġiti li ġejjin: 2, 3, 5, 7, --Numri primi huma 2, 3, 5, 7, 11, 13, 17,... --L-għadd ta' ċifri eżadeċimali huwa 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. --akbar minn 1 li ma jkunx prodott ta ' żewġ numri naturali iżgħar).--ċifri li huma primes (numru prim, jew prim, huwa numru naturali --numru eżadeċimali bħala stringa u jgħodd in-numru ta ' eżadeċimali --Inti ġew inkarigati biex jiktbu funzjoni li tirċievi --  >>> hexKey ""AB""
--  1
--  >>> hexKey ""1077E""
--  2
--  >>> hexKey ""ABED1A33""
--  4
--  >>> hexKey ""123456789ABCDEF0""
--  6
--  >>> hexKey ""2020""
--  2
hexKey :: String -> Int
hexKey num =","hexKey :: String -> Int
hexKey num = length . filter (`elem` primeHexDigits) $ num
  where
    primeHexDigits = ""2357BD""","
main :: IO ()
main = do
  let candidate = hexKey
  if candidate ""AB"" == 1 then pure () else error ""assertion failed""
  if candidate ""1077E"" == 2 then pure () else error ""assertion failed""
  if candidate ""ABED1A33"" == 4 then pure () else error ""assertion failed""
  if candidate ""2020"" == 2 then pure () else error ""assertion failed""
  if candidate ""123456789ABCDEF0"" == 6 then pure () else error ""assertion failed""
  if candidate ""112233445566778899AABBCCDDEEFF00"" == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_79,mlt_Latn,hs,"--Eżempji: --Il-karattri żejda huma hemm biex jgħinu fil-format. --Se jkun hemm ftit karattri żejda 'db' fil-bidu u fit-tmiem tal-string. --Kull karattru fil-ktajjen se jkun ""0"" jew ""1"".--Il-funzjoni għandha tirritorna stringa, b'kull karattru li jirrappreżenta binarju --Inti se tingħata numru f'forma deċimali u l-kompitu tiegħek huwa li jikkonverti li --  >>> decimalToBinary 15
--  ""db1111db""
--  >>> decimalToBinary 32
--  ""db100000db""
decimalToBinary :: Int -> String
decimalToBinary decimal =","decimalToBinary :: Int -> String
decimalToBinary decimal = ""db"" ++ toBinary decimal ++ ""db""
  where
    toBinary 0 = ""0""
    toBinary n = reverse (binaryHelper n)

    binaryHelper 0 = """"
    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","
main :: IO ()
main = do
  let candidate = decimalToBinary
  if candidate 0 == ""db0db"" then pure () else error ""assertion failed""
  if candidate 32 == ""db100000db"" then pure () else error ""assertion failed""
  if candidate 103 == ""db1100111db"" then pure () else error ""assertion failed""
  if candidate 15 == ""db1111db"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_80,mlt_Latn,hs,"--Pereżempju: --Stringa hija haphs jekk it-tul tagħha huwa mill-inqas 3 u kull 3 ittri konsekuttivi huma distinti --L-għan tiegħek huwa li tiċċekkja jekk il-ktajjen huma haphs jew le.--Inti tingħata string s. --  >>> isHappy ""a""
--  False
--  >>> isHappy ""aa""
--  False
--  >>> isHappy ""abcd""
--  True
--  >>> isHappy ""aabb""
--  False
--  >>> isHappy ""adb""
--  True
--  >>> isHappy ""xyy""
--  False
isHappy :: String -> Bool
isHappy s =","isHappy :: String -> Bool
isHappy s
  | length s < 3 = False
  | otherwise = all distinctTriples (windows 3 s)
  where
    distinctTriples [x, y, z] = x /= y && y /= z && x /= z
    distinctTriples _ = False
    windows n xs
      | length xs < n = []
      | otherwise = take n xs : windows n (tail xs)","
main :: IO ()
main = do
  let candidate = isHappy
  if candidate ""a"" == False then pure () else error ""assertion failed""
  if candidate ""aa"" == False then pure () else error ""assertion failed""
  if candidate ""abcd"" == True then pure () else error ""assertion failed""
  if candidate ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""adb"" == True then pure () else error ""assertion failed""
  if candidate ""xyy"" == False then pure () else error ""assertion failed""
  if candidate ""iopaxpoi"" == True then pure () else error ""assertion failed""
  if candidate ""iopaxioi"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_81,mlt_Latn,hs,"--Eżempju: --0.0 E --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 B+ --> 3.3 A- --> 3.7 A --4.0 A+ --GPA. Grad ta' ittri.--funzjoni li tista ' toħroġ lista ta ' gradi ta ' ittri bl-użu tat-tabella li ġejja: --Hija tatlek lista ta ' GPAs għal xi studenti u għandek tikteb --L-unika problema hija li hija tilfet il-kodiċi li kienet tuża għall-gradjar.--L-għalliema kienet qed tagħmel l-algoritmu tagħha stess għall-klassifikazzjoni.--Hija l-aħħar ġimgħa tas-semestru u l-għalliema għandhom jagħtu l-gradi.--  >>> gradeEquation [4.0,3,1.7,2,3.5]
--  [""A+"",""B"",""C-"",""C"",""A-""]
numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades =","numericalLetterGrade :: [Float] -> [String]
numericalLetterGrade grades = map gpaToLetterGrade grades
  where
    gpaToLetterGrade gpa
      | gpa == 4.0 = ""A+""
      | gpa > 3.7  = ""A""
      | gpa > 3.3  = ""A-""
      | gpa > 3.0  = ""B+""
      | gpa > 2.7  = ""B""
      | gpa > 2.3  = ""B-""
      | gpa > 2.0  = ""C+""
      | gpa > 1.7  = ""C""
      | gpa > 1.3  = ""C-""
      | gpa > 1.0  = ""D+""
      | gpa > 0.7  = ""D""
      | gpa > 0.0  = ""D-""
      | otherwise  = ""E""","
main :: IO ()
main = do
  let candidate = numericalLetterGrade
  if candidate [4.0,3,1.7,2,3.5] == [""A+"",""B"",""C-"",""C"",""A-""] then pure () else error ""assertion failed""
  if candidate [1.2] == [""D+""] then pure () else error ""assertion failed""
  if candidate [0.5] == [""D-""] then pure () else error ""assertion failed""
  if candidate [0.0] == [""E""] then pure () else error ""assertion failed""
  if candidate [1.0,0.3,1.5,2.8,3.3] == [""D"",""D-"",""C-"",""B"",""B+""] then pure () else error ""assertion failed""
  if candidate [0.0,0.7] == [""E"",""D-""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_82,mlt_Latn,hs,"--Eżempji --it-tul huwa numru primarju jew False inkella --Għandek tikteb funzjoni li tieħu stringa u tirritorna True jekk il- stringa --  >>> primeLength ""Hello""
--  True
--  >>> primeLength ""abcdcba""
--  True
--  >>> primeLength ""kittens""
--  True
--  >>> primeLength ""orange""
--  False
primeLength :: String -> Bool
primeLength string =","primeLength :: String -> Bool
primeLength string = isPrime (length string)

isPrime :: Int -> Bool
isPrime n
  | n < 2     = False
  | n == 2    = True
  | even n    = False
  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = primeLength
  if candidate ""Hello"" == True then pure () else error ""assertion failed""
  if candidate ""abcdcba"" == True then pure () else error ""assertion failed""
  if candidate ""kittens"" == True then pure () else error ""assertion failed""
  if candidate ""orange"" == False then pure () else error ""assertion failed""
  if candidate ""wow"" == True then pure () else error ""assertion failed""
  if candidate ""world"" == True then pure () else error ""assertion failed""
  if candidate ""MadaM"" == True then pure () else error ""assertion failed""
  if candidate ""Wow"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""HI"" == True then pure () else error ""assertion failed""
  if candidate ""go"" == True then pure () else error ""assertion failed""
  if candidate ""gogo"" == False then pure () else error ""assertion failed""
  if candidate ""aaaaaaaaaaaaaaa"" == False then pure () else error ""assertion failed""
  if candidate ""Madam"" == True then pure () else error ""assertion failed""
  if candidate ""M"" == False then pure () else error ""assertion failed""
  if candidate ""0"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_83,mlt_Latn,hs,"--L-għadd ta' numri enteri pożittivi li jibdew jew jispiċċaw b'1.--│ │Għall-għadd ta' numri b'n-digit │startsOneEnds :: Int -> Int
startsOneEnds n =","startsOneEnds :: Int -> Int
startsOneEnds n
  | n <= 0    = 0
  | n == 1    = 1
  | otherwise = 18 * 10^(n-2)","
main :: IO ()
main = do
  let candidate = startsOneEnds
  if candidate 1 == 1 then pure () else error ""assertion failed""
  if candidate 2 == 18 then pure () else error ""assertion failed""
  if candidate 3 == 180 then pure () else error ""assertion failed""
  if candidate 4 == 1800 then pure () else error ""assertion failed""
  if candidate 5 == 18000 then pure () else error ""assertion failed""
  pure ()"
HumanEval_84,mlt_Latn,hs,"--Eżempju --│ │Għall-għadd sħiħ pożittiv N, irridu n-numru totali ta' ċifri tiegħu f'forma binarja. │--  >>> solve 1000
--  ""1""
--  >>> solve 150
--  ""110""
--  >>> solve 147
--  ""1100""
--  Variables:
--  @N integer
--  Constraints: 0 ≤ N ≤ 10000.
--  Output:
--  a string of binary number
solve :: Int -> String
solve N =","solve :: Int -> String
solve N = toBinary (sumOfDigits N)
  where
    sumOfDigits 0 = 0
    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)

    toBinary 0 = ""0""
    toBinary n = reverse (toBinary' n)
      where
        toBinary' 0 = """"
        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","
main :: IO ()
main = do
  let candidate = solve
  if candidate 1000 == ""1"" then pure () else error ""assertion failed""
  if candidate 150 == ""110"" then pure () else error ""assertion failed""
  if candidate 147 == ""1100"" then pure () else error ""assertion failed""
  if candidate 333 == ""1001"" then pure () else error ""assertion failed""
  if candidate 963 == ""10010"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_85,mlt_Latn,hs,"--Eżempji: --Ħalli lista mhux vojta ta 'integers lst. żid l-elementi pari li huma fl-indiċijiet mhux komuni .. --  >>> add [4,2,6,7]
--  2
add :: [Int] -> Int
add lst =","add :: [Int] -> Int
add lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","
main :: IO ()
main = do
  let candidate = add
  if candidate [4,88] == 88 then pure () else error ""assertion failed""
  if candidate [4,5,6,7,2,122] == 122 then pure () else error ""assertion failed""
  if candidate [4,0,6,7] == 0 then pure () else error ""assertion failed""
  if candidate [4,4,6,8] == 12 then pure () else error ""assertion failed""
  pure ()"
HumanEval_86,mlt_Latn,hs,"--Pereżempju: --Nota: Għandek iżżomm l-ordni tal-kliem u l-ispazji vojta fis-sentenza. --ordni li jitla' abbażi tal-valur ASCII. --huma sostitwiti b' kelma ġdida fejn il-karattri kollha rranġati fi --Verżjoni ordnata ta ' stringa, hija stringa fejn il-kliem kollha (separati minn spazju) --❑ Ikteb funzjoni li tieħu stringa u tirritorna verżjoni ordnata tagħha.--  >>> antiShuffle ""Hi""
--  ""Hi""
--  >>> antiShuffle ""hello""
--  ""ehllo""
--  >>> antiShuffle ""Hello World!!!""
--  ""Hello !!!Wdlor""
antiShuffle :: String -> String
antiShuffle s =","import Data.List (sort)
import Data.Char (isAlpha)

antiShuffle :: String -> String
antiShuffle s = unwords $ map sortWord (wordsAndSpaces s)
  where
    sortWord word = if all isAlpha word then sort word else word
    wordsAndSpaces [] = []
    wordsAndSpaces xs = if head xs == ' ' 
                        then "" "" : wordsAndSpaces (dropWhile (== ' ') xs)
                        else let (word, rest) = break (== ' ') xs
                             in word : wordsAndSpaces rest","
main :: IO ()
main = do
  let candidate = antiShuffle
  if candidate ""Hi"" == ""Hi"" then pure () else error ""assertion failed""
  if candidate ""hello"" == ""ehllo"" then pure () else error ""assertion failed""
  if candidate ""number"" == ""bemnru"" then pure () else error ""assertion failed""
  if candidate ""abcd"" == ""abcd"" then pure () else error ""assertion failed""
  if candidate ""Hello World!!!"" == ""Hello !!!Wdlor"" then pure () else error ""assertion failed""
  if candidate """" == """" then pure () else error ""assertion failed""
  if candidate ""Hi. My name is Mister Robot. How are you?"" == "".Hi My aemn is Meirst .Rboot How aer ?ouy"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_87,mlt_Latn,hs,"--Eżempji: --Barra minn hekk, issortja l-koordinati tar-ringiela skont il-kolonni f'ordni dixxendenti. --Irranġa l-koordinati inizjalment bil-linji f'ordni li jikber. --kull tuple huwa koordinata - (ringiela, kolonni), li tibda b'0. --u jirritorna lista ta ' tuples, [(x1, y1), (x2, y2) ...] bħal --Minħabba lst, u l-integer x, isibu l-integers x fil-lista, --kull riġla tista' tinkludi numru differenti ta' kolonni. --li huwa simili għal matrix, madankollu, b'differenza matriċi, --Inti tingħata dejta bidimensjonali, bħala listi mdawra, --  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1
--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]
--  >>> getRow [] 1
--  []
--  >>> getRow [[],[1],[1,2,3]] 3
--  [(2, 2)]
getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x =","getRow :: [[Int]] -> Int -> [(Int, Int)]
getRow lst x = concatMap processRow (zip [0..] lst)
  where
    processRow (rowIndex, row) = 
      let colIndices = reverse $ findIndices (== x) row
      in [(rowIndex, colIndex) | colIndex <- colIndices]

findIndices :: (a -> Bool) -> [a] -> [Int]
findIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","
main :: IO ()
main = do
  let candidate = getRow
  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error ""assertion failed""
  if candidate [] 1 == [] then pure () else error ""assertion failed""
  if candidate [[1]] 2 == [] then pure () else error ""assertion failed""
  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_88,mlt_Latn,hs,"--Eżempji: --* ma tibdelx il-lista mogħtija. --Nota: --jew issortjaha f'ordni dixxendenti jekk is-somma ((l-ewwel valur tal-indiċi, l-aħħar valur tal-indiċi) tkun pari. --se ssorta l-lista mogħtija f'ordni li tiżdied jekk is-somma ((l-ewwel valur tal-indiċi, l-aħħar valur tal-indiċi) tkun mhux ugwali, --│ │Għall-lista ta' lentieri mhux negattivi, │ares a cohs tal-lista mogħtija wara li tiġġieled, │--  >>> sortArray []
--  []
--  >>> sortArray [5]
--  [5]
--  >>> sortArray [2,4,3,0,1,5]
--  [0,1,2,3,4,5]
--  >>> sortArray [2,4,3,0,1,5,6]
--  [6,5,4,3,2,1,0]
sortArray :: [Int] -> [Int]
sortArray array =","sortArray :: [Int] -> [Int]
sortArray array
  | null array = array
  | otherwise =
    let first = head array
        last = last array
        sumFirstLast = first + last
    in if odd sumFirstLast
       then sort array
       else reverse (sort array)","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [5] == [5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error ""assertion failed""
  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error ""assertion failed""
  if candidate [2,1] == [1,2] then pure () else error ""assertion failed""
  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error ""assertion failed""
  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error ""assertion failed""
  pure ()"
HumanEval_89,mlt_Latn,hs,"--Pereżempju: --l-għoli ta' l-għoli ta' l-għoli ta' l-għoli ta' l-għoli ta' l-għoli ta' l-għoli--L-alfabett għandu jiġi rrotat b'mod li l-ittri --jirritorna stringa kodifikata bl-alfabett li qed jiġi rrotat. --│ Ħolqien ta ' funzjoni encrypt li tieħu stringa bħala argument u │--  >>> encrypt ""hi""
--  ""lm""
--  >>> encrypt ""asdfghjkl""
--  ""ewhjklnop""
--  >>> encrypt ""gf""
--  ""kj""
--  >>> encrypt ""et""
--  ""ix""
encrypt :: String -> String
encrypt s =","encrypt :: String -> String
encrypt s = map shiftChar s
  where
    shiftChar c
      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')
      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')
      | otherwise = c","
main :: IO ()
main = do
  let candidate = encrypt
  if candidate ""hi"" == ""lm"" then pure () else error ""assertion failed""
  if candidate ""asdfghjkl"" == ""ewhjklnop"" then pure () else error ""assertion failed""
  if candidate ""gf"" == ""kj"" then pure () else error ""assertion failed""
  if candidate ""et"" == ""ix"" then pure () else error ""assertion failed""
  if candidate ""faewfawefaewg"" == ""jeiajeaijeiak"" then pure () else error ""assertion failed""
  if candidate ""hellomyfriend"" == ""lippsqcjvmirh"" then pure () else error ""assertion failed""
  if candidate ""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"" == ""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"" then pure () else error ""assertion failed""
  if candidate ""a"" == ""e"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_90,mlt_Latn,hs,"--Irritorna xejn jekk ma jkunx hemm tali element. --Ikteb funzjoni next_smallest (() li tirritorna t-tieni l-iżgħar element tal-lista. --Inti tingħata lista ta 'integers.--  >>> nextSmallest [1,2,3,4,5]
--  Just (2)
--  >>> nextSmallest [5,1,4,3,2]
--  Just (2)
--  >>> nextSmallest []
--  Just (Nothing)
--  >>> nextSmallest [1,1]
--  Just (Nothing)
nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =","nextSmallest :: [Int] -> Maybe Int
nextSmallest lst =
  let uniqueSorted = removeDuplicates $ quicksort lst
  in if length uniqueSorted < 2
     then Nothing
     else Just (uniqueSorted !! 1)

removeDuplicates :: (Ord a) => [a] -> [a]
removeDuplicates = foldr (\x acc -> if x `elem` acc then acc else x : acc) []

quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
  let smallerSorted = quicksort [a | a <- xs, a <= x]
      biggerSorted = quicksort [a | a <- xs, a > x]
  in smallerSorted ++ [x] ++ biggerSorted","
main :: IO ()
main = do
  let candidate = nextSmallest
  if candidate [1,2,3,4,5] == Just (2) then pure () else error ""assertion failed""
  if candidate [5,1,4,3,2] == Just (2) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [1,1,1,1,0] == Just (1) then pure () else error ""assertion failed""
  if candidate [1,1] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error ""assertion failed""
  pure ()"
HumanEval_91,mlt_Latn,hs,"--Pereżempju: --Is-sentenzi huma delimitati b' """"., ""?' jew ""!"". --A boredom hija sentenza li tibda bil-kelma ""I"". --◯ Int se tingħata sensiela ta' kliem, u l-kompitu tiegħek hu li tgħodd in-numru ◯--  >>> isBored ""Hello world""
--  0
--  >>> isBored ""The sky is blue. The sun is shining. I love this weather""
--  1
isBored :: String -> Int
isBored S =","isBored :: String -> Int
isBored s = length $ filter (startsWithI . words) $ splitSentences s
  where
    splitSentences :: String -> [String]
    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters "".?!""
    
    splitOnDelimiters :: String -> String -> [String]
    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of
      """" -> []
      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''
    
    startsWithI :: [String] -> Bool
    startsWithI [] = False
    startsWithI (x:_) = map toLower x == ""i""","
main :: IO ()
main = do
  let candidate = isBored
  if candidate ""Hello world"" == 0 then pure () else error ""assertion failed""
  if candidate ""Is the sky blue?"" == 0 then pure () else error ""assertion failed""
  if candidate ""I love It !"" == 1 then pure () else error ""assertion failed""
  if candidate ""bIt"" == 0 then pure () else error ""assertion failed""
  if candidate ""I feel good today. I will be productive. will kill It"" == 2 then pure () else error ""assertion failed""
  if candidate ""You and I are going for a walk"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_92,mlt_Latn,hs,"--Eżempji --Jirritorna false f'kull każ ieħor. --Jirritorna true jekk wieħed min-numri jkun ugwali għas-somma tat-tnejn l-oħra, u n-numri kollha jkunu integers. --◯ Ħolqien ta 'funzjoni li tieħu 3 numri. ◯--  >>> anyInt 5 2 7
--  True
--  >>> anyInt 3 2 2
--  False
--  >>> anyInt 3 (-2) 1
--  True
--  >>> anyInt 3.6 -2.2 2
--  False
anyInt :: Float -> Float -> Float -> Bool
anyInt x y z =","anyInt :: Float -> Float -> Float -> Bool
anyInt x y z
  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =
      x == y + z || y == x + z || z == x + y
  | otherwise = False","
main :: IO ()
main = do
  let candidate = anyInt
  if candidate 2.0 3.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 2.5 2.0 3.0 == False then pure () else error ""assertion failed""
  if candidate 1.5 5.0 3.5 == False then pure () else error ""assertion failed""
  if candidate 2.0 6.0 2.0 == False then pure () else error ""assertion failed""
  if candidate 4.0 2.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.2 2.2 2.2 == False then pure () else error ""assertion failed""
  if candidate (-4).0 6.0 2.0 == True then pure () else error ""assertion failed""
  if candidate 2.0 1.0 1.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == True then pure () else error ""assertion failed""
  if candidate 3.0 4.0 7.0 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_93,mlt_Latn,hs,"--Eżempji: --Assumi li jkun hemm biss ittri.--vokali fl- alfabet Ingliż. --il-messaġġ bil-ittra li tidher żewġ postijiet ' il quddiem minn dik --mod li huwa swaps każ ta 'l-ittri kollha, jissostitwixxi l-vokali kollha fil --Ikteb funzjoni li tieħu messaġġ, u kodiċijiet f'tali --  >>> encode ""test""
--  ""TGST""
--  >>> encode ""This is a message""
--  ""tHKS KS C MGSSCGG""
encode :: String -> String
encode message =","encode :: String -> String
encode = map transformChar
  where
    transformChar :: Char -> Char
    transformChar c
      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c
      | otherwise      = swapCase c c
      where
        lowerC = toLower c

    isVowel :: Char -> Bool
    isVowel c = c `elem` ""aeiou""

    swapCase :: Char -> Char -> Char
    swapCase origC c
      | isUpper origC = toLower c
      | otherwise     = toUpper c","
main :: IO ()
main = do
  let candidate = encode
  if candidate ""TEST"" == ""tgst"" then pure () else error ""assertion failed""
  if candidate ""Mudasir"" == ""mWDCSKR"" then pure () else error ""assertion failed""
  if candidate ""YES"" == ""ygs"" then pure () else error ""assertion failed""
  if candidate ""This is a message"" == ""tHKS KS C MGSSCGG"" then pure () else error ""assertion failed""
  if candidate ""I DoNt KnOw WhAt tO WrItE"" == ""k dQnT kNqW wHcT Tq wRkTg"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_94,mlt_Latn,hs,"--Eżempji: --Għandek bżonn issib l-akbar valur primarju u jirritornaw is-somma tad-diġiti tagħha.--Inti tingħata lista ta 'integers.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]
--  10
--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]
--  25
--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]
--  13
--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]
--  11
--  >>> skjkasdkd [0,81,12,3,1,21]
--  3
--  >>> skjkasdkd [0,8,1,2,1,7]
--  7
skjkasdkd :: [Int] -> Int
skjkasdkd lst =","skjkasdkd :: [Int] -> Int
skjkasdkd lst = sumDigits (largestPrime lst)

-- Function to check if a number is prime
isPrime :: Int -> Bool
isPrime n
  | n <= 1 = False
  | n == 2 = True
  | even n = False
  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]

-- Integer square root using binary search, O(log n)
isqrt :: Int -> Int
isqrt n = floor . sqrt $ fromIntegral n

-- Function to find the largest prime in the list
largestPrime :: [Int] -> Int
largestPrime = foldr (\x acc -> if isPrime x && x > acc then x else acc) 0

-- Function to calculate the sum of the digits of a number
sumDigits :: Int -> Int
sumDigits 0 = 0
sumDigits n = n `mod` 10 + sumDigits (n `div` 10)","
main :: IO ()
main = do
  let candidate = skjkasdkd
  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error ""assertion failed""
  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error ""assertion failed""
  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error ""assertion failed""
  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error ""assertion failed""
  if candidate [0,81,12,3,1,21] == 3 then pure () else error ""assertion failed""
  if candidate [0,8,1,2,1,7] == 7 then pure () else error ""assertion failed""
  if candidate [8191] == 19 then pure () else error ""assertion failed""
  if candidate [8191,123456,127,7] == 19 then pure () else error ""assertion failed""
  if candidate [127,97,8192] == 10 then pure () else error ""assertion failed""
  pure ()"
HumanEval_95,mlt_Latn,hs,"--Eżempji: --Il-funzjoni għandha tirritorna False jekk il-lista ta' assoċjazzjonijiet mogħtija tkun vojta. --Jekk il-kodiċi huwa f'każ jew il-kodiċi kollha huma strings f'każ kbir, inkella jirritorna False.--☐ Għażla ta 'l-għażla ta' l-għażla ta' l-għażla--  >>> checkDictCase [(""a"", ""apple""), (""b"", ""banana"")]
--  True
--  >>> checkDictCase [(""a"", ""apple""), (""A"", ""banana""), (""B"", ""banana"")]
--  False
--  >>> checkDictCase [(""a"", ""apple""), (8, ""banana""), (""a"", ""apple"")]
--  False
--  >>> checkDictCase [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")]
--  False
--  >>> checkDictCase [(""STATE"", ""NC""), (""ZIP"", ""12345"")]
--  True
checkDictCase :: [(String, String)] -> Bool
checkDictCase dict =","import Data.Char (isUpper, isLower)

checkDictCase :: [(String, String)] -> Bool
checkDictCase [] = False
checkDictCase dict = all isLower allKeys || all isUpper allKeys
  where
    allKeys = concatMap fst dict","
main :: IO ()
main = do
  let candidate = checkDictCase
  if candidate [(""p"", ""pineapple""), (""b"", ""banana"")] == True then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""A"", ""banana""), (""B"", ""banana"")] == False then pure () else error ""assertion failed""
  if candidate [(""p"", ""pineapple""), (""5"", ""banana""), (""a"", ""apple"")] == False then pure () else error ""assertion failed""
  if candidate [(""Name"", ""John""), (""Age"", ""36""), (""City"", ""Houston"")] == False then pure () else error ""assertion failed""
  if candidate [(""STATE"", ""NC""), (""ZIP"", ""12345"")] == True then pure () else error ""assertion failed""
  if candidate [(""fruit"", ""Orange""), (""taste"", ""Sweet"")] == True then pure () else error ""assertion failed""
  if candidate [] == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_96,mlt_Latn,hs,"--pereżempju: --in-numru sħiħ li huwa numru primarju u inqas minn n. --Implementa funzjoni li tieħu numru sħiħ mhux negattiv u tirritorna lista ta ' l-ewwel n --  >>> countUpTo 5
--  [2,3]
--  >>> countUpTo 11
--  [2,3,5,7]
--  >>> countUpTo 0
--  []
--  >>> countUpTo 20
--  [2,3,5,7,11,13,17,19]
--  >>> countUpTo 1
--  []
--  >>> countUpTo 18
--  [2,3,5,7,11,13,17]
countUpTo :: Int -> [Int]
countUpTo n =","countUpTo :: Int -> [Int]
countUpTo n = filter isPrime [2..n-1]

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = countUpTo
  if candidate 5 == [2,3] then pure () else error ""assertion failed""
  if candidate 6 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 7 == [2,3,5] then pure () else error ""assertion failed""
  if candidate 10 == [2,3,5,7] then pure () else error ""assertion failed""
  if candidate 0 == [] then pure () else error ""assertion failed""
  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error ""assertion failed""
  if candidate 1 == [] then pure () else error ""assertion failed""
  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error ""assertion failed""
  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error ""assertion failed""
  pure ()"
HumanEval_97,mlt_Latn,hs,"--Eżempji: --Assumi li l-input huwa dejjem validu.--il-prodott tad-diġiti ta' l-unità tagħhom. --◯ Ikkompleta l-funzjoni li tieħu żewġ integers u tirritorna ◯--  >>> multiply 148 412
--  16
--  >>> multiply 19 28
--  72
--  >>> multiply 2020 1851
--  0
--  >>> multiply 14 (-15)
--  20
multiply :: Int -> Int -> Int
multiply a b =","multiply :: Int -> Int -> Int
multiply a b = (abs a `mod` 10) * (abs b `mod` 10)","
main :: IO ()
main = do
  let candidate = multiply
  if candidate 148 412 == 16 then pure () else error ""assertion failed""
  if candidate 19 28 == 72 then pure () else error ""assertion failed""
  if candidate 2020 1851 == 0 then pure () else error ""assertion failed""
  if candidate 14 (-15) == 20 then pure () else error ""assertion failed""
  if candidate 76 67 == 42 then pure () else error ""assertion failed""
  if candidate 17 27 == 49 then pure () else error ""assertion failed""
  if candidate 0 1 == 0 then pure () else error ""assertion failed""
  if candidate 0 0 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_98,mlt_Latn,hs,"--Pereżempju: --❑ Meta tingħata string s, inkalkula n-numru ta' vokali kbar f'indiċijiet pari.--  >>> countUpper ""aBCdEf""
--  1
--  >>> countUpper ""abcdefg""
--  0
--  >>> countUpper ""dBBE""
--  0
countUpper :: String -> Int
countUpper s =","countUpper :: String -> Int
countUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` ""AEIOU""]","
main :: IO ()
main = do
  let candidate = countUpper
  if candidate ""aBCdEf"" == 1 then pure () else error ""assertion failed""
  if candidate ""abcdefg"" == 0 then pure () else error ""assertion failed""
  if candidate ""dBBE"" == 0 then pure () else error ""assertion failed""
  if candidate ""B"" == 0 then pure () else error ""assertion failed""
  if candidate ""U"" == 1 then pure () else error ""assertion failed""
  if candidate """" == 0 then pure () else error ""assertion failed""
  if candidate ""EEEE"" == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_99,mlt_Latn,hs,"--Eżempji --minn żewġ integers, tqarreb 'il bogħod minn żero. --u jirritorna l-eqreb numru sħiħ li huwa. Jekk in-numru huwa equidistant --☐ Ħolqien ta ' funzjoni li tieħu valur (string) li jirrappreżenta numru --  >>> closestInteger ""10""
--  10
--  >>> closestInteger ""15.3""
--  15
--  Note:
--  Rounding away from zero means that if the given number is equidistant
--  from two integers, the one you should return is the one that is the
--  farthest from zero. For example closest_integer(""14.5"") should
--  return 15 and closest_integer(""-14.5"") should return -15.
closestInteger :: String -> Int
closestInteger value =","closestInteger :: String -> Int
closestInteger value = 
  let n = read value :: Double
  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","
main :: IO ()
main = do
  let candidate = closestInteger
  if candidate ""10"" == 10 then pure () else error ""assertion failed""
  if candidate ""14.5"" == 15 then pure () else error ""assertion failed""
  if candidate ""-15.5"" == (-16) then pure () else error ""assertion failed""
  if candidate ""15.3"" == 15 then pure () else error ""assertion failed""
  if candidate ""0"" == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_100,mlt_Latn,hs,"--Eżempji: --i jirrappreżenta n-numru ta' ġebel fil-livell (i+1). --Irtira n-numru ta' ġebel f'kull livell f'lista, fejn l-element fl-indiċi --- l-għadd pari li jmiss jekk n ikun pari. --- l-għadd mhux par li jmiss jekk n huwa mhux par. --In-numru ta ' ġebel fil-livell li jmiss huwa: --L-ewwel livell għandu n ġebel.--│Għall-għadd sħiħ pożittiv n, għandek tagħmel munzell ta' livelli n ta' ġebel.--  >>> makeAPile 3
--  [3,5,7]
makeAPile :: Int -> [Int]
makeAPile n =","makeAPile :: Int -> [Int]
makeAPile n = take n [n, n + 2 ..]","
main :: IO ()
main = do
  let candidate = makeAPile
  if candidate 3 == [3,5,7] then pure () else error ""assertion failed""
  if candidate 4 == [4,6,8,10] then pure () else error ""assertion failed""
  if candidate 5 == [5,7,9,11,13] then pure () else error ""assertion failed""
  if candidate 6 == [6,8,10,12,14,16] then pure () else error ""assertion failed""
  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error ""assertion failed""
  pure ()"
HumanEval_101,mlt_Latn,hs,"--Pereżempju: --biex taqsam il-ktajjen f'kliem u tirritorna lista tal-kliem. --◯ Int se tingħata ċinga ta' kliem separati minn kommi jew spazji.--  >>> wordsString ""Hi, my name is John""
--  [""Hi"",""my"",""name"",""is"",""John""]
--  >>> wordsString ""One, two, three, four, five, six""
--  [""One"",""two"",""three"",""four"",""five"",""six""]
wordsString :: String -> [String]
wordsString s =","wordsString :: String -> [String]
wordsString s = words $ map (\c -> if c == ',' then ' ' else c) s","
main :: IO ()
main = do
  let candidate = wordsString
  if candidate ""Hi, my name is John"" == [""Hi"",""my"",""name"",""is"",""John""] then pure () else error ""assertion failed""
  if candidate ""One, two, three, four, five, six"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate ""Hi, my name"" == [""Hi"",""my"",""name""] then pure () else error ""assertion failed""
  if candidate ""One,, two, three, four, five, six,"" == [""One"",""two"",""three"",""four"",""five"",""six""] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""ahmed     , gamal"" == [""ahmed"",""gamal""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_102,mlt_Latn,hs,"--Pereżempju: --hemm l-ebda numru bħal dan, allura l-funzjoni għandha jirritorna -1. --L-akbar numru sħiħ pari li huwa fil-medda [x, y] inkluż. Jekk --Din il-funzjoni tieħu żewġ numri pożittivi x u y u tirritorna l- --  >>> chooseNum 12 15
--  14
--  >>> chooseNum 13 12
--  (-1)
chooseNum :: Int -> Int -> Int
chooseNum x y =","chooseNum :: Int -> Int -> Int
chooseNum x y
    | x > y = -1
    | even upperBound = upperBound
    | even (upperBound - 1) = upperBound - 1
    | otherwise = -1
  where
    upperBound = max x y","
main :: IO ()
main = do
  let candidate = chooseNum
  if candidate 12 15 == 14 then pure () else error ""assertion failed""
  if candidate 13 12 == (-1) then pure () else error ""assertion failed""
  if candidate 33 12354 == 12354 then pure () else error ""assertion failed""
  if candidate 5234 5233 == (-1) then pure () else error ""assertion failed""
  if candidate 6 29 == 28 then pure () else error ""assertion failed""
  if candidate 27 10 == (-1) then pure () else error ""assertion failed""
  if candidate 7 7 == (-1) then pure () else error ""assertion failed""
  if candidate 546 546 == 546 then pure () else error ""assertion failed""
  pure ()"
HumanEval_104,mlt_Latn,hs,"--Pereżempju: --Nota: Il-lista li tiġi lura għandha tiġi ssortjata f'ordni li jikber.--elementi li ma jkollhom ebda ċifra pari. --│ │Għall-lista ta' lentieri pożittivi x.--  >>> uniqueDigits [15,33,1422,1]
--  [1,15,33]
--  >>> uniqueDigits [152,323,1422,10]
--  []
uniqueDigits :: [Int] -> [Int]
uniqueDigits x =","uniqueDigits :: [Int] -> [Int]
uniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","
main :: IO ()
main = do
  let candidate = uniqueDigits
  if candidate [15,33,1422,1] == [1,15,33] then pure () else error ""assertion failed""
  if candidate [152,323,1422,10] == [] then pure () else error ""assertion failed""
  if candidate [12345,2033,111,151] == [111,151] then pure () else error ""assertion failed""
  if candidate [135,103,31] == [31,135] then pure () else error ""assertion failed""
  pure ()"
HumanEval_105,mlt_Latn,hs,"--Pereżempju: --""Waħda"", ""Tnejn"", ""Tlieta"", ""Erba', ""Ħames"", ""Sitt"", ""Seba', ""Tmien"", ""Disa'"". --irriversja l-lista li tirriżulta, u mbagħad ibdel kull ċifra bl-isem korrispondenti tagħha minn --│ │G¢at lista ta' numri g¢al │add, │add il-integers li huma bejn 1 u 9 inklużivi, │--  >>> byLength [2,1,1,4,5,8,2,3]
--  [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""]
--  If the list is empty, return an empty list:
--  >>> byLength []
--  []
--  If the list has any strange number ignore it:
--  >>> byLength [1,(-1),55]
--  [""One""]
byLength :: [Int] -> [String]
byLength arr =","byLength :: [Int] -> [String]
byLength arr = map digitName . reverse . sort . filter isValid $ arr
  where
    isValid x = x >= 1 && x <= 9
    digitName x = case x of
      1 -> ""One""
      2 -> ""Two""
      3 -> ""Three""
      4 -> ""Four""
      5 -> ""Five""
      6 -> ""Six""
      7 -> ""Seven""
      8 -> ""Eight""
      9 -> ""Nine""
      _ -> error ""Unexpected number""","
main :: IO ()
main = do
  let candidate = byLength
  if candidate [2,1,1,4,5,8,2,3] == [""Eight"",""Five"",""Four"",""Three"",""Two"",""Two"",""One"",""One""] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-1),55] == [""One""] then pure () else error ""assertion failed""
  if candidate [1,(-1),3,2] == [""Three"",""Two"",""One""] then pure () else error ""assertion failed""
  if candidate [9,4,8] == [""Nine"",""Eight"",""Four""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_106,mlt_Latn,hs,"--Eżempju: --il-fatturjali ta ' i hija l-multiplikazzjoni tan-numri minn 1 sa i (1 * 2 * ... * i). --i jibda minn 1. --jew is-somma tan-numri minn 1 sa i inkella. --u jirritorna lista ta 'daqs n, tali li l-valur tal-element fl-indiċi i huwa l-fatturjali ta' i jekk i huwa pari --Implimenta l-funzjoni f li tieħu n bħala parametru, --  >>> f 5
--  [1,2,6,24,15]
f :: Int -> [Int]
f n =","f :: Int -> [Int]
f n = map g [1..n]
  where
    g i
      | even i    = factorial i
      | otherwise = sum [1..i]
    
    factorial 0 = 1
    factorial m = product [1..m]","
main :: IO ()
main = do
  let candidate = f
  if candidate 5 == [1,2,6,24,15] then pure () else error ""assertion failed""
  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  if candidate 3 == [1,2,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_107,mlt_Latn,hs,"--Eżempju 1: --Palindromi ta' numri sħaħ li jaqgħu fil-medda ((1, n), inkluż. --Given a integer pożittiv n, jirritorna a tuple li għandu l-għadd ta ' anke u mhux ugwali --  >>> evenOddPalindrome 3
--  (1, 2)
--  Explanation:
--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
--  Example 2:
--  >>> evenOddPalindrome 12
--  (4, 6)
--  Explanation:
--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
--  Note:
--  1. 1 <= n <= 10^3
--  2. returned tuple has the number of even and odd integer palindromes respectively.
evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n =","evenOddPalindrome :: Int -> (Int, Int)
evenOddPalindrome n = (length evens, length odds)
  where
    isPalindrome x = show x == reverse (show x)
    palindromes = filter isPalindrome [1..n]
    evens = filter even palindromes
    odds  = filter odd palindromes","
main :: IO ()
main = do
  let candidate = evenOddPalindrome
  if candidate 123 == (8, 13) then pure () else error ""assertion failed""
  if candidate 12 == (4, 6) then pure () else error ""assertion failed""
  if candidate 3 == (1, 2) then pure () else error ""assertion failed""
  if candidate 63 == (6, 8) then pure () else error ""assertion failed""
  if candidate 25 == (5, 6) then pure () else error ""assertion failed""
  if candidate 19 == (4, 6) then pure () else error ""assertion failed""
  if candidate 9 == (4, 5) then pure () else error ""assertion failed""
  if candidate 1 == (0, 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_108,mlt_Latn,hs,"--eż. -123 għandu d-diġiti ffirmati -1, 2, u 3. --Jekk numru huwa negattiv, allura l-ewwel ċifra ffirmata tiegħu tkun negattiva: --in-numru ta' elementi li għandu somma ta' ċifri > 0. --Għajnuna biex tikteb funzjoni count_nums li tieħu lista ta 'integers u tirritorna --  >>> countNums []
--  0
--  >>> countNums [(-1),11,(-11)]
--  1
--  >>> countNums [1,1,2]
--  3
countNums :: [Int] -> Int
countNums arr =","countNums :: [Int] -> Int
countNums arr = length $ filter ((> 0) . sumDigits) arr
  where
    sumDigits 0 = 0
    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)
                  in sum digits","
main :: IO ()
main = do
  let candidate = countNums
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),0] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error ""assertion failed""
  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error ""assertion failed""
  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error ""assertion failed""
  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error ""assertion failed""
  if candidate [0,1] == 1 then pure () else error ""assertion failed""
  if candidate [1] == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_109,mlt_Latn,hs,"--Pereżempju: --Nota: Il-lista mogħtija hija garantita li jkollha elementi uniċi.--Jekk il-lista mogħtija hija vojta allura jirritorna True. --Imbagħad, ir-ritorn huwa TRUE jew ir-ritorn huwa False.--Jekk ikun possibbli li tinkiseb il-lista magħżula billi ssir l-operazzjoni ta' hawn fuq --il-pożizzjoni tal-bidu fil-lista jiġifieri l-indiċi 0th. --L- aħħar element tal- lista se jiġi mċaqlaq għal --Operazzjoni waħda ta "" ċaqliq lejn il-lemin tfisser li l-elementi kollha tal-lista jiġu ċaqlaq b' waħda .--Tista' twettaq operazzjoni ta' bidla lejn il-lemin kull numru ta' drabi.--l-operazzjoni li ġejja fil-lista mogħtija: --huwa possibbli li lista tiġi ssortjata f'ordni li ma tonqosx billi ssir --L-għadd ta' numri fil-lista se jkun ordnat b'mod każwali.--Għandek lista ta' N numru sħiħ arr[1], arr[2], ..., arr[N].--  >>> moveOneBall [3,4,5,1,2]
--  True
--  Explanation: By performin 2 right shift operations, non-decreasing order can
--  be achieved for the given list.
--  >>> moveOneBall [3,5,4,1,2]
--  False
--  Explanation:It is not possible to get non-decreasing order for the given
--  list by performing any number of right shift operations.
moveOneBall :: [Int] -> Bool
moveOneBall arr =","moveOneBall :: [Int] -> Bool
moveOneBall [] = True
moveOneBall arr = canBeSorted (arr ++ arr)
  where
    n = length arr
    canBeSorted xs = any isSorted (take n <$> tails xs)
    isSorted ys = and $ zipWith (<=) ys (tail ys)
    tails [] = []
    tails l@(_:xs) = l : tails xs","
main :: IO ()
main = do
  let candidate = moveOneBall
  if candidate [3,4,5,1,2] == True then pure () else error ""assertion failed""
  if candidate [3,5,10,1,2] == True then pure () else error ""assertion failed""
  if candidate [4,3,1,2] == False then pure () else error ""assertion failed""
  if candidate [3,5,4,1,2] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_110,mlt_Latn,hs,"--Pereżempju: --Inkella, irritorna ""LE"". --l-elementi kollha ta' lst1 ikunu pari, jirritorna ""Iva"". --Jekk ikun possibbli li jiġu skambjati elementi bejn lst1 u lst2 biex isiru --M'hemm l-ebda limitu fuq in-numru ta' elementi skambjati bejn lst1 u lst2. --bejnhom biex tagħmel lst1 lista ta' numri pari biss. --u jiddetermina jekk hux possibbli li jsir skambju ta "" elementi --F'din il-problema, int se timplimenta funzjoni li tieħu żewġ listi ta' numri, --  >>> exchange [1,2,3,4] [1,2,3,4]
--  ""YES""
--  >>> exchange [1,2,3,4] [1,5,3,4]
--  ""NO""
--  It is assumed that the input lists will be non-empty.
exchange :: [Int] -> [Int] -> String
exchange lst1 lst2 =","exchange :: [Int] -> [Int] -> String
exchange lst1 lst2
  | all even lst1 = ""YES""
  | null oddLst1 || null evenLst2 = ""NO""
  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)
                in if possibility then ""YES"" else ""NO""
  where
    oddLst1 = filter odd lst1
    evenLst2 = filter even lst2","
main :: IO ()
main = do
  let candidate = exchange
  if candidate [1,2,3,4] [1,2,3,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [1,5,3,4] == ""NO"" then pure () else error ""assertion failed""
  if candidate [1,2,3,4] [2,1,4,3] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,4] == ""YES"" then pure () else error ""assertion failed""
  if candidate [5,7,3] [2,6,3] == ""NO"" then pure () else error ""assertion failed""
  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == ""NO"" then pure () else error ""assertion failed""
  if candidate [100,200] [200,200] == ""YES"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_111,mlt_Latn,hs,"--Eżempju: --Jekk diversi ittri jkollhom l-istess okkorrenza, irritornahom kollha. --tal-ittra bl-aktar ripetizzjoni u li fiha l-għadd korrispondenti. --Given a string li jirrappreżentaw l-ittri żgħar separati spazju, jirritornaw lista assoċjazzjoni --  >>> histogram ""a b c""
--  [(""a"", 1), (""b"", 1), (""c"", 1)]
--  >>> histogram ""a b b a""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""a b c a b""
--  [(""a"", 2), (""b"", 2)]
--  >>> histogram ""b b b b a""
--  [(""b"", 4)]
--  >>> histogram """"
--  []
histogram :: String -> [(String, Int)]
histogram test =","import Data.List (group, sort)
import Data.Ord (comparing)

histogram :: String -> [(String, Int)]
histogram input =
  let wordsList = words input
      grouped = group $ sort wordsList
      countList = map (\ws -> (head ws, length ws)) grouped
      maxCount = if null countList then 0 else maximum $ map snd countList
  in filter ((== maxCount) . snd) countList","
main :: IO ()
main = do
  let candidate = histogram
  if candidate ""a b b a"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c a b"" == [(""a"", 2), (""b"", 2)] then pure () else error ""assertion failed""
  if candidate ""a b c d g"" == [(""a"", 1), (""b"", 1), (""c"", 1), (""d"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate ""b b b b a"" == [(""b"", 4)] then pure () else error ""assertion failed""
  if candidate ""r t g"" == [(""r"", 1), (""t"", 1), (""g"", 1)] then pure () else error ""assertion failed""
  if candidate """" == [] then pure () else error ""assertion failed""
  if candidate ""a"" == [(""a"", 1)] then pure () else error ""assertion failed""
  pure ()"
HumanEval_112,mlt_Latn,hs,"--Eżempju --Għandek tirritorna tuple li jkun fih il-string tar-riżultat u True/False għall-verifika. --String jissejjaħ palindromu jekk jinqara l-istess lura kif quddiem. --imbagħad iċċekkja jekk il-string tar-riżultat hux palindromju. --Aħna ngħataw żewġ strings s u c, inti għandek tħassar l-karattri kollha fil s li huma ugwali għal kwalunkwe karattru fil c --Xogħol.--  >>> reverseDelete ""abcde"" ""ae""
--  (""bcd"", False)
--  >>> reverseDelete ""abcdef"" ""b""
--  (""acdef"", False)
--  >>> reverseDelete ""abcdedcba"" ""ab""
--  (""cdedc"", True)
reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =","import Data.List (filter)

reverseDelete :: String -> String -> (String, Bool)
reverseDelete s c =
  let result = filter (`notElem` c) s
  in (result, result == reverse result)","
main :: IO ()
main = do
  let candidate = reverseDelete
  if candidate ""abcde"" ""ae"" == (""bcd"", False) then pure () else error ""assertion failed""
  if candidate ""abcdef"" ""b"" == (""acdef"", False) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""ab"" == (""cdedc"", True) then pure () else error ""assertion failed""
  if candidate ""dwik"" ""w"" == (""dik"", False) then pure () else error ""assertion failed""
  if candidate ""a"" ""a"" == ("""", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" """" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""abcdedcba"" ""v"" == (""abcdedcba"", True) then pure () else error ""assertion failed""
  if candidate ""vabba"" ""v"" == (""abba"", True) then pure () else error ""assertion failed""
  if candidate ""mamma"" ""mia"" == ("""", True) then pure () else error ""assertion failed""
  pure ()"
HumanEval_113,mlt_Latn,hs,"--ta 'diġiti mhux parzjali fil-string i'th tal-input. --fejn l-i kollha għandhom jiġu sostitwiti bin-numru --Kull element i tal-output għandu jkun ""in-numru ta' elementi mhux inkrementali fil- --│ │Għall-lista ta' strings, fejn kull stringa tikkonsisti biss f'diġiti, tirritorna lista.--  >>> oddCount [""1234567""]
--  [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
--  >>> oddCount [""3"",""11111111""]
--  [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""]
oddCount :: [String] -> [String]
oddCount lst =","oddCount :: [String] -> [String]
oddCount lst = map formatString lst
  where
    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""

    countOdds :: String -> Int
    countOdds str = length $ filter isOddDigit str

    formatString :: String -> String
    formatString str =
      let oddCount = countOdds str in
      ""the number of odd elements "" ++ show oddCount ++ 
      ""n the str"" ++ show oddCount ++ ""ng "" ++ show oddCount ++
      "" of the "" ++ show oddCount ++ ""nput.""","
main :: IO ()
main = do
  let candidate = oddCount
  if candidate [""1234567""] == [""the number of odd elements 4n the str4ng 4 of the 4nput.""] then pure () else error ""assertion failed""
  if candidate [""3"",""11111111""] == [""the number of odd elements 1n the str1ng 1 of the 1nput."",""the number of odd elements 8n the str8ng 8 of the 8nput.""] then pure () else error ""assertion failed""
  if candidate [""271"",""137"",""314""] == [""the number of odd elements 2n the str2ng 2 of the 2nput."",""the number of odd elements 3n the str3ng 3 of the 3nput."",""the number of odd elements 2n the str2ng 2 of the 2nput.""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_114,mlt_Latn,hs,"--Eżempju --ta' nums. --Meta tingħata lista ta' numri enteri, agħżel is-somma minima ta' kull sub-lista mhux vojta.--  >>> minsubarraysum [2,3,4,1,2,4]
--  1
--  >>> minsubarraysum [(-1),(-2),(-3)]
--  (-6)
minsubarraysum :: [Int] -> Int
minsubarraysum nums =","minsubarraysum :: [Int] -> Int
minsubarraysum nums = minimum $ scanl1 (\acc x -> min x (acc + x)) nums","
main :: IO ()
main = do
  let candidate = minsubarraysum
  if candidate [2,3,4,1,2,4] == 1 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error ""assertion failed""
  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error ""assertion failed""
  if candidate [0,10,20,1000000] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error ""assertion failed""
  if candidate [10,11,13,8,3,4] == 3 then pure () else error ""assertion failed""
  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error ""assertion failed""
  if candidate [(-10)] == (-10) then pure () else error ""assertion failed""
  if candidate [7] == 7 then pure () else error ""assertion failed""
  if candidate [1,(-1)] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_115,mlt_Latn,hs,"--Eżempju 1: --Agħti l-għadd ta' drabi li għandek bżonn biex tbaxxi l-bakketti. --L-għan tiegħek hu li tuża l-barmil biex timbotta l-bir.--u l-bakketti kollha għandhom l-istess kapaċità. --Kull bir għandu baħar korrispondenti li jista' jintuża biex jiġi estratt l-ilma minnu, --u kull 1 f'ringiela tirrappreżenta unità waħda ta' ilma. --Inti tingħata grid rettangolari ta 'bjar. Kull linja tirrappreżenta bir wieħed, --  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1
--  6
--  Example 2:
--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2
--  5
--  Example 3:
--  >>> maxFill [[0,0,0],[0,0,0]] 5
--  0
--  Constraints:
--  * all wells have the same length
--  * 1 <= grid.length <= 10^2
--  * 1 <= grid[:,1].length <= 10^2
--  * grid[i][j] -> 0 | 1
--  * 1 <= capacity <= 10
maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity =","maxFill :: [[Int]] -> Int -> Int
maxFill grid capacity = ceiling (fromIntegral totalWater / fromIntegral capacity)
  where
    totalWater = sum (map sum grid)","
main :: IO ()
main = do
  let candidate = maxFill
  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error ""assertion failed""
  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error ""assertion failed""
  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error ""assertion failed""
  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_116,mlt_Latn,hs,"--Għandu jiġi implimentat kif ġej: --Għal numru simili ta' waħedhom, issortja abbażi tal-valur deċimali. --L-għadd ta' wieħed fir-rappreżentazzjoni binarja tagħhom f'ordni li jikber. --F'dan il-kata, inti għandek biex issorda lista ta 'integers mhux negattivi skond--  >>> sortArray [1,5,2,3,4]
--  [1,2,3,4,5]
--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]
--  [(-6),(-5),(-4),(-3),(-2)]
--  >>> sortArray [1,0,2,3,4]
--  [0,1,2,3,4]
sortArray :: [Int] -> [Int]
sortArray arr =","import Data.Bits (popCount)
import Data.List (sortBy)

sortArray :: [Int] -> [Int]
sortArray arr = sortBy compareOnesAndValues arr
  where
    compareOnesAndValues x y =
      let onesX = popCount x
          onesY = popCount y
      in if onesX == onesY
         then compare x y
         else compare onesX onesY","
main :: IO ()
main = do
  let candidate = sortArray
  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error ""assertion failed""
  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error ""assertion failed""
  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error ""assertion failed""
  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error ""assertion failed""
  pure ()"
HumanEval_117,mlt_Latn,hs,"--Eżempji: --Nota: tista 'taċċetta li l- string input fih biss ittri u spazji.--Jekk il-string s huwa vojt allura l-funzjoni għandha tirritorna lista vojta. --n konsonanti, sabiex dawn il-kliem jidhru fil-linja s. --funzjoni li tirritorna lista tal-kliem kollha minn string s li fihom eżattament --☐ Given a string s u numru naturali n, inti ġew inkarigati biex jimplimentaw ☐--  >>> selectWords ""Mary had a little lamb"" 4
--  [""little""]
--  >>> selectWords ""Mary had a little lamb"" 3
--  [""Mary"",""lamb""]
--  >>> selectWords ""simple white space"" 2
--  []
--  >>> selectWords ""Hello world"" 4
--  [""world""]
--  >>> selectWords ""Uncle sam"" 3
--  [""Uncle""]
selectWords :: String -> Int -> [String]
selectWords s n =","selectWords :: String -> Int -> [String]
selectWords s n = filter (\word -> countConsonants word == n) (words s)
  where
    countConsonants = length . filter (`elem` consonants)
    consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ""","
main :: IO ()
main = do
  let candidate = selectWords
  if candidate ""Mary had a little lamb"" 4 == [""little""] then pure () else error ""assertion failed""
  if candidate ""Mary had a little lamb"" 3 == [""Mary"",""lamb""] then pure () else error ""assertion failed""
  if candidate ""simple white space"" 2 == [] then pure () else error ""assertion failed""
  if candidate ""Hello world"" 4 == [""world""] then pure () else error ""assertion failed""
  if candidate ""Uncle sam"" 3 == [""Uncle""] then pure () else error ""assertion failed""
  if candidate """" 4 == [] then pure () else error ""assertion failed""
  if candidate ""a b c d e f"" 1 == [""b"",""c"",""d"",""f""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_118,mlt_Latn,hs,"--Eżempju: --Tista 'taċċetta li l-string mogħtija fih ittra Ingliża biss. --issib kwalunkwe vokali li tissodisfa l-kundizzjoni ta' hawn fuq. --Il-vokali fil-bidu u l-aħħar ma jgħoddux.--żewġ konsonanti min-naħa tal-lemin tal-kelma (sensittiv għall-każi). --Għandek kelma. L-isforz tiegħek hu li ssib l-eqreb vokali li tinsab bejn --  >>> getClosestVowel ""yogurt""
--  ""u""
--  >>> getClosestVowel ""FULL""
--  ""U""
--  >>> getClosestVowel ""quick""
--  """"
--  >>> getClosestVowel ""ab""
--  """"
getClosestVowel :: String -> String
getClosestVowel word =","getClosestVowel :: String -> String
getClosestVowel word = go (reverse word) False
  where
    vowels = ""aeiouAEIOU""
    go [] _ = """"
    go (x:xs) lastWasConsonant
      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False
      | x `notElem` vowels = go xs True
      | otherwise = go xs False","
main :: IO ()
main = do
  let candidate = getClosestVowel
  if candidate ""yogurt"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""full"" == ""u"" then pure () else error ""assertion failed""
  if candidate ""easy"" == """" then pure () else error ""assertion failed""
  if candidate ""eAsy"" == """" then pure () else error ""assertion failed""
  if candidate ""ali"" == """" then pure () else error ""assertion failed""
  if candidate ""bad"" == ""a"" then pure () else error ""assertion failed""
  if candidate ""most"" == ""o"" then pure () else error ""assertion failed""
  if candidate ""ab"" == """" then pure () else error ""assertion failed""
  if candidate ""ba"" == """" then pure () else error ""assertion failed""
  if candidate ""quick"" == """" then pure () else error ""assertion failed""
  if candidate ""anime"" == ""i"" then pure () else error ""assertion failed""
  if candidate ""Asia"" == """" then pure () else error ""assertion failed""
  if candidate ""Above"" == ""o"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_119,mlt_Latn,hs,"--Eżempji: --Irritorna 'Iva' jekk hemm mod kif tagħmel string tajba, u jirritorna 'Le' inkella. --"" (()) "" m'huwiex. --Pereżempju: il-ktajjen '(()))) ' huma tajbin, filwaqt li l-ktajjen --String S huwa meqjus bħala tajjeb jekk u biss jekk il-parentesi kollha f'S --xi ordni, li l-string li tirriżulta se jkun tajjeb. --Xogħol tiegħek huwa li tivverifika jekk huwiex possibbli li l-konkatena żewġ strings fil --il-parentesi ""("" jew il-parentesi ta' ħdejn il-parentesi "") "" biss. --Inti tingħata lista ta 'żewġ strings, it-tnejn li huma strings jikkonsistu ta' miftuħa.--  >>> matchParens [""()("","")""]
--  ""Yes""
--  >>> matchParens ["")"","")""]
--  ""No""
matchParens :: [String] -> String
matchParens lst =","matchParens :: [String] -> String
matchParens [a, b] =
    if isValid (a ++ b) || isValid (b ++ a) then ""Yes"" else ""No""
  where
    isValid :: String -> Bool
    isValid = go 0
      where
        go 0 [] = True
        go _ [] = False
        go n (x:xs)
            | x == '('  = go (n + 1) xs
            | x == ')'  = n > 0 && go (n - 1) xs
    isValid _ = False","
main :: IO ()
main = do
  let candidate = matchParens
  if candidate [""()("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"","")""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()(())"",""())())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")())"",""(()()(""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(())))"",""(()())((""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""()"",""())""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""(()("",""()))()""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate [""(((("",""((())""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")(()"",""(()(""] == ""No"" then pure () else error ""assertion failed""
  if candidate ["")("","")(""] == ""No"" then pure () else error ""assertion failed""
  if candidate [""("","")""] == ""Yes"" then pure () else error ""assertion failed""
  if candidate ["")"",""(""] == ""Yes"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_120,mlt_Latn,hs,"--Eżempju 1: --ta' tul k b'għadd massimu ta' k numri f'arr. --Given lista arr ta 'integers u k integer pożittiv, jirritorna lista ordnat --  >>> maximum [(-3),(-4),5] 3
--  [(-4),(-3),5]
--  Example 2:
--  >>> maximum [4,(-4),4] 2
--  [4,4]
--  Example 3:
--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1
--  [2]
--  Note:
--  1. The length of the list will be in the range of [1, 1000].
--  2. The elements in the list will be in the range of [-1000, 1000].
--  3. 0 <= k <= len(arr)
maximum :: [Int] -> Int -> [Int]
maximum arr k =","maximum :: [Int] -> Int -> [Int]
maximum arr k = take k $ reverse $ sort arr","
main :: IO ()
main = do
  let candidate = maximum
  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error ""assertion failed""
  if candidate [4,(-4),4] 2 == [4,4] then pure () else error ""assertion failed""
  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error ""assertion failed""
  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error ""assertion failed""
  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error ""assertion failed""
  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error ""assertion failed""
  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error ""assertion failed""
  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error ""assertion failed""
  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error ""assertion failed""
  if candidate [(-10),10] 2 == [(-10),10] then pure () else error ""assertion failed""
  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error ""assertion failed""
  pure ()"
HumanEval_121,mlt_Latn,hs,"--Eżempji --Given a list mhux vojta ta 'integers, jirritornaw is-somma ta' l-elementi kollha mhux tas-soltu li huma fil-pożizzjonijiet anke.--  >>> solution [5,8,7,1]
--  12
--  >>> solution [3,3,3,3,3]
--  9
--  >>> solution [30,13,24,321]
--  0
solution :: [Int] -> Int
solution lst =","solution :: [Int] -> Int
solution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","
main :: IO ()
main = do
  let candidate = solution
  if candidate [5,8,7,1] == 12 then pure () else error ""assertion failed""
  if candidate [3,3,3,3,3] == 9 then pure () else error ""assertion failed""
  if candidate [30,13,24,321] == 0 then pure () else error ""assertion failed""
  if candidate [5,9] == 5 then pure () else error ""assertion failed""
  if candidate [2,4,8] == 0 then pure () else error ""assertion failed""
  if candidate [30,13,23,32] == 23 then pure () else error ""assertion failed""
  if candidate [3,13,2,9] == 3 then pure () else error ""assertion failed""
  pure ()"
HumanEval_122,mlt_Latn,hs,"--Eżempju: --is-somma tal-elementi b'mhux aktar minn żewġ ċifri mill-ewwel k elementi ta' arr. --Meta tingħata lista mhux vojta ta' intjeri arr u intjeri k, return --  >>> addElements [111,21,3,4000,5,6,7,8,9] 4
--  24
--  Constraints:
--  1. 1 <= len(arr) <= 100
--  2. 1 <= k <= len(arr)
addElements :: [Int] -> Int -> Int
addElements arr k =","addElements :: [Int] -> Int -> Int
addElements arr k = sum $ filter (\x -> x >= -99 && x <= 99) $ take k arr","
main :: IO ()
main = do
  let candidate = addElements
  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error ""assertion failed""
  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error ""assertion failed""
  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error ""assertion failed""
  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error ""assertion failed""
  if candidate [1] 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_123,mlt_Latn,hs,"--get_odd_collatz(5) jirritorna [1, 5] # Is-sekwenza ta 'kollatz għal 5 hija [5, 16, 8, 4, 2, 1], allura n-numri mhux parzjali huma biss 1, u 5. --Pereżempju: --2. lista li ġiet lura, iġġenerata f'ordni li jikber. --1. Collatz ((1) huwa [1]. --Nota: --term plus 1. Il-konjetura hija li irrispettivament minn liema valur ta' n, is-sekwenza dejjem tilħaq 1. --Jekk it-terminu preċedenti huwa mhux ugwali, it-terminu li jmiss huwa 3 darbiet it-terminu preċedenti.--terminu preċedenti kif ġej: jekk it-terminu preċedenti huwa pari, it-terminu li jmiss huwa nofs --kif ġej: ibda b'kull numru sħiħ pożittiv n. Imbagħad kull terminu jinkiseb mill- --Il-kunjetura ta ' Collatz hija kunjetura fil-matematika li tikkonċerna sekwenza definita --│ Gћal numru sħiħ pożittiv n, jirritorna lista ordnata li għandha l-numri mhux tas-soltu fis-sekwenza Collatz. │--  >>> getOddCollatz 5
--  [1,5]
getOddCollatz :: Int -> [Int]
getOddCollatz n =","getOddCollatz :: Int -> [Int]
getOddCollatz n = sort . filter odd $ collatzSequence n
  where
    collatzSequence 1 = [1]
    collatzSequence x
      | even x    = x : collatzSequence (x `div` 2)
      | otherwise = x : collatzSequence (3 * x + 1)","
main :: IO ()
main = do
  let candidate = getOddCollatz
  if candidate 14 == [1,5,7,11,13,17] then pure () else error ""assertion failed""
  if candidate 5 == [1,5] then pure () else error ""assertion failed""
  if candidate 12 == [1,3,5] then pure () else error ""assertion failed""
  if candidate 1 == [1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_124,mlt_Latn,hs,"--4. Id-data għandha tkun fil-format: mm-dd-yyyy --3. Il- xhur m'għandhomx ikunu inqas minn 1 u ogħla minn 12.--2. In-numru ta' jiem ma jkunx inqas minn 1 jew ogħla minn 31 jum għal xhur 1,3,5,7,8,10,12. U n-numru ta' jiem ma jkunx inqas minn 1 jew ogħla minn 30 jum għal xhur 4,6,9,11. U, in-numru ta' jiem ma jkunx inqas minn 1 jew ogħla minn 29 jum għal xahar 2.--1. Il- stringa tad- data mhix vojta. --Id-data hija valida jekk ir-regoli kollha li ġejjin ikunu sodisfatti: --jirritorna True jekk id-data hija valida inkella False. --Għandek tikteb funzjoni li tivvalida data data stringa u --  >>> validDate ""03-11-2000""
--  True
--  >>> validDate ""15-01-2012""
--  False
--  >>> validDate ""04-0-2040""
--  False
--  >>> validDate ""06-04-2020""
--  True
--  >>> validDate ""06/04/2020""
--  False
validDate :: String -> Bool
validDate date =","import Text.Read (readMaybe)
import Data.List.Split (splitOn)

validDate :: String -> Bool
validDate date =
    case splitOn ""-"" date of
        [m, d, y] -> isValidMonthDayYear m d y
        _         -> False

isValidMonthDayYear :: String -> String -> String -> Bool
isValidMonthDayYear m d y =
    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of
        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day
        _ -> False

isValidMonth :: Int -> Bool
isValidMonth month = month >= 1 && month <= 12

isValidDay :: Int -> Int -> Bool
isValidDay month day
    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31
    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30
    | month == 2                           = day >= 1 && day <= 29
    | otherwise                            = False","
main :: IO ()
main = do
  let candidate = validDate
  if candidate ""03-11-2000"" == True then pure () else error ""assertion failed""
  if candidate ""15-01-2012"" == False then pure () else error ""assertion failed""
  if candidate ""04-0-2040"" == False then pure () else error ""assertion failed""
  if candidate ""06-04-2020"" == True then pure () else error ""assertion failed""
  if candidate ""01-01-2007"" == True then pure () else error ""assertion failed""
  if candidate ""03-32-2011"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""04-31-3000"" == False then pure () else error ""assertion failed""
  if candidate ""06-06-2005"" == True then pure () else error ""assertion failed""
  if candidate ""21-31-2000"" == False then pure () else error ""assertion failed""
  if candidate ""04-12-2003"" == True then pure () else error ""assertion failed""
  if candidate ""04122003"" == False then pure () else error ""assertion failed""
  if candidate ""20030412"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04"" == False then pure () else error ""assertion failed""
  if candidate ""2003-04-12"" == False then pure () else error ""assertion failed""
  if candidate ""04-2003"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_126,mlt_Latn,hs,"--Eżempji --Numru, jirritorna False. Assumi li m'hemm l-ebda numru negattiv u biss in-numru sħiħ.--Jekk il-lista jkollha aktar minn kopja waħda tal-istess --◯ Meta tingħata lista ta' numri, tirritorna jekk humiex issortjati jew le ◯--  >>> isSorted [5]
--  True
--  >>> isSorted [1,2,3,4,5]
--  True
--  >>> isSorted [1,3,2,4,5]
--  False
--  >>> isSorted [1,2,3,4,5,6]
--  True
--  >>> isSorted [1,2,3,4,5,6,7]
--  True
--  >>> isSorted [1,3,2,4,5,6,7]
--  False
--  >>> isSorted [1,2,2,3,3,4]
--  True
--  >>> isSorted [1,2,2,2,3,4]
--  False
isSorted :: [Int] -> Bool
isSorted lst =","isSorted :: [Int] -> Bool
isSorted lst = go lst Nothing
  where
    go [] _ = True
    go [x] _ = True
    go (x:y:xs) prev
      | x > y = False
      | x == y && prev == Just x = False
      | otherwise = go (y:xs) (Just x)","
main :: IO ()
main = do
  let candidate = isSorted
  if candidate [5] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7] == True then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,7] == False then pure () else error ""assertion failed""
  if candidate [] == True then pure () else error ""assertion failed""
  if candidate [1] == True then pure () else error ""assertion failed""
  if candidate [3,2,1] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,2,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,3,3,3,4] == False then pure () else error ""assertion failed""
  if candidate [1,2,2,3,3,4] == True then pure () else error ""assertion failed""
  if candidate [1,2,3,4] == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_127,mlt_Latn,hs,"--[input/output] kampjuni: --Jekk iż-żewġ intervalli ma jaqbżux, jirritorna ""LE"". --inkella, jirritorna ""LE"". --Jekk it-tul tal-intersezzjoni huwa numru primarju, erġa' iġġib ""Iva"", --li t-tul tagħha huwa 1, li mhux numru primarju. --Eżempju, l-intersezzjoni tal-intervalli (1, 3), (2, 4) hija (2, 3) --Intervalli huwa numru primarju. --Il-kompitu tiegħek huwa li tiddetermina jekk it-tul ta ' intersezzjoni ta ' dawn iż-żewġ --Għal kull intervall mogħti, huwa preżunt li l-bidu tiegħu huwa inqas jew ugwali għat-tmiem tiegħu. --jinkludi kemm il-bidu kif ukoll it-tmiem. --L-intervalli mogħtija huma magħluqa li jfisser li l-intervall (bidu, tmiem) --fejn kull intervall huwa par ta' numri sħaħ. Per eżempju, intervall = (bidu, tmiem) = (1, 2).--Inti tingħata żewġ intervalli, --  >>> intersection (1, 2) (2, 3)
--  ""NO""
--  >>> intersection ((-1), 1) (0, 4)
--  ""NO""
--  >>> intersection ((-3), (-1)) ((-5), 5)
--  ""YES""
intersection :: (Int, Int) -> (Int, Int) -> String
intersection interval1 interval2 =","intersection :: (Int, Int) -> (Int, Int) -> String
intersection (start1, end1) (start2, end2) = 
    if intersectionLength > 0 && isPrime intersectionLength
    then ""YES""
    else ""NO""
  where
    intersectionStart = max start1 start2
    intersectionEnd = min end1 end2
    intersectionLength = intersectionEnd - intersectionStart + 1
    
    isPrime :: Int -> Bool
    isPrime n
      | n <= 1 = False
      | n == 2 = True
      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","
main :: IO ()
main = do
  let candidate = intersection
  if candidate (1, 2) (2, 3) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-1), 1) (0, 4) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-3), (-1)) ((-5), 5) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-2), 2) ((-4), 0) == ""YES"" then pure () else error ""assertion failed""
  if candidate ((-11), 2) ((-1), (-1)) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (3, 5) == ""NO"" then pure () else error ""assertion failed""
  if candidate (1, 2) (1, 2) == ""NO"" then pure () else error ""assertion failed""
  if candidate ((-2), (-2)) ((-3), (-2)) == ""NO"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_128,mlt_Latn,hs,"--Eżempju: --Nota: ma jirritorna xejn għal arr vojt. --ta' kull numru fil-lista, rappreżentat b'1, -1 jew 0. --somma ta ' magnitudini ta ' numri sħaħ immultiplikata bil-prodott tas-sinjali kollha --Inti tingħata lista arr ta 'integers u inti għandek bżonn li jirritornaw --  >>> prodSigns [1,2,2,(-4)]
--  Just (9)
--  >>> prodSigns [0,1]
--  Just (0)
--  >>> prodSigns []
--  Just (Nothing)
prodSigns :: [Int] -> Maybe Int
prodSigns arr =","prodSigns :: [Int] -> Maybe Int
prodSigns [] = Nothing
prodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","
main :: IO ()
main = do
  let candidate = prodSigns
  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error ""assertion failed""
  if candidate [0,1] == Just (0) then pure () else error ""assertion failed""
  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error ""assertion failed""
  if candidate [] == Just (Nothing) then pure () else error ""assertion failed""
  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error ""assertion failed""
  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error ""assertion failed""
  if candidate [(-1),1,1,0] == Just (0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_129,mlt_Latn,hs,"--Eżempji: --Irtira lista ordnata tal-valuri fuq iċ-ċelloli li jgħaddi minnhom il-passaġġ minimu. --Huwa garantit li t-tweġiba hija unika. --L-ewwel_A[j] = l-ewwel_B[j]. --tali li lst_A[i] < lst_B[i] u għal kwalunkwe j (1 <= j < i) għandna --minn lst_B, fi kliem ieħor, hemm indiċi ta' numru sħiħ i (1 <= i <= k) --permezz ta' (aħna nsejħulhom lst_A u lst_B), lst_A huwa leksikografikament inqas --wara li jagħmlu l-listi ordnati tal-valuri fuq iċ-ċelloli li A u B jmorru --It-tul tal-passaġġ A (tal-tul k) jitqies li huwa inqas mit-tul tal-passaġġ B (tal-tul k) jekk --M' TISTAQX tmur barra mill- grid. --necessarjament distinti).--Jekk jogħġbok innota li mogħdija ta ' tul k tfisser li tkun żaret eżattament k ċelloli (mhux --ċellulari. --fi kliem ieħor, inti tista ' tmur għal ċelloli li jaqsmu tarf ma ' tiegħek kurrenti --minn kwalunkwe ċellula, u f'kull pass inti tista 'timxi għal kwalunkwe ċellula ġirien, --Inti għandek issib l-mogħdija minima ta 'tul k fil-grilja. Inti tista 'tibda --""Inclusive"" jidher eżatt darba fuq iċ-ċelloli tal-grilja. --kull ċellula tal-grilja fiha valur. Kull numru sħiħ fil-medda [1, N * N] --∆iena ngħaddu minn grilja b'N-ringieli u N-kolonni (N >= 2) u numru sħiħ k pożittiv, --  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3
--  [1,2,1]
--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1
--  [1]
minpath :: [[Int]] -> Int -> [Int]
minpath grid k =","import Data.List (sort, sortBy)
import Data.Ord (comparing)
import Control.Monad (guard)

minpath :: [[Int]] -> Int -> [Int]
minpath grid k = head $ sort paths
  where
    n = length grid
    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]
    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
      where
        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n
    value (r, c) = grid !! r !! c
    paths = do
      start <- cells
      findPaths k [start]
    findPaths 1 path = return $ map value path
    findPaths l path@(current:_) = do
      next <- neighbors current
      findPaths (l-1) (next : path)","
main :: IO ()
main = do
  let candidate = minpath
  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error ""assertion failed""
  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error ""assertion failed""
  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error ""assertion failed""
  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error ""assertion failed""
  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error ""assertion failed""
  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error ""assertion failed""
  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error ""assertion failed""
  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error ""assertion failed""
  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_130,mlt_Latn,hs,"--Eżempji: --l-ewwel n + 1 numri tas-sekwenza ta' Tribonacci. --Inti tingħata numru sħiħ mhux negattiv n, inti għandek għal a jirritorna lista ta 'l- --= 2 + 3 + 3 = 8 --tri(3) = tri(2) + tri(1) + tri(4) --tri(4) = 3 --tri(2) = 1 + (2 / 2) = 2 --Pereżempju: --tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), jekk n huwa mhux parzjali. --tri (n) = 1 + n / 2, jekk n huwa pari. --tri(1) = 3 --Is-sekwenza ta ' Tribonacci hija definita mir-rikorrenza: --Madankollu, dak li n-nies ma jafux huwa sekwenza Tribonacci.--Kulħadd jaf is-sekwenza ta' Fibonacci, kienet studjata fil-fond mill-matematisti fl-Ewropa.--  >>> tri 3
--  [1,3,2,8]
tri :: Int -> [Int]
tri n =","tri :: Int -> [Int]
tri n = map tribonacci [0..n]
  where
    -- Define the recursive function to calculate the tribonacci value for a given n
    tribonacci :: Int -> Int
    tribonacci 0 = 1
    tribonacci 1 = 3
    tribonacci x
      | even x    = 1 + x `div` 2
      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","
main :: IO ()
main = do
  let candidate = tri
  if candidate 3 == [1,3,2,8] then pure () else error ""assertion failed""
  if candidate 4 == [1,3,2,8,3] then pure () else error ""assertion failed""
  if candidate 5 == [1,3,2,8,3,15] then pure () else error ""assertion failed""
  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error ""assertion failed""
  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error ""assertion failed""
  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error ""assertion failed""
  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error ""assertion failed""
  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error ""assertion failed""
  if candidate 0 == [1] then pure () else error ""assertion failed""
  if candidate 1 == [1,3] then pure () else error ""assertion failed""
  pure ()"
HumanEval_131,mlt_Latn,hs,"--Pereżempju: --Iġġib 0 jekk id-diġiti kollha jkunu pari. --Ħalli n, u tirritorna l-prodott ta' l-odd digits.--  >>> digits 1
--  1
--  >>> digits 4
--  0
--  >>> digits 235
--  15
digits :: Int -> Int
digits n =","digits :: Int -> Int
digits n
  | null oddDigits = 0
  | otherwise      = product oddDigits
  where
    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","
main :: IO ()
main = do
  let candidate = digits
  if candidate 5 == 5 then pure () else error ""assertion failed""
  if candidate 54 == 5 then pure () else error ""assertion failed""
  if candidate 120 == 1 then pure () else error ""assertion failed""
  if candidate 5014 == 5 then pure () else error ""assertion failed""
  if candidate 98765 == 315 then pure () else error ""assertion failed""
  if candidate 5576543 == 2625 then pure () else error ""assertion failed""
  if candidate 2468 == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_132,mlt_Latn,hs,"--fejn mill-inqas kurett wieħed fis-subsekwenza jkun innestat. --Il-funzjoni għandha tirritorna True jekk u biss jekk hemm sottosekwenza valida ta ' kurakketti --Ħolqien ta 'funzjoni li tieħu string bħala input li fih biss parentessi kwadri.--  >>> isNested ""[[]]""
--  True
--  >>> isNested ""[]]]]]]][[[[[]""
--  False
--  >>> isNested ""[][]""
--  False
--  >>> isNested ""[]""
--  False
--  >>> isNested ""[[][]]""
--  True
--  >>> isNested ""[[]][[""
--  True
isNested :: String -> Bool
isNested string =","isNested :: String -> Bool
isNested string = go string 0 False
  where
    go [] _ nested = nested
    go (x:xs) depth nested
      | x == '['  = go xs (depth + 1) (nested || depth >= 1)
      | x == ']' && depth > 0 = go xs (depth - 1) nested
      | otherwise = go xs depth nested","
main :: IO ()
main = do
  let candidate = isNested
  if candidate ""[[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]][[[[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[][]"" == False then pure () else error ""assertion failed""
  if candidate ""[]"" == False then pure () else error ""assertion failed""
  if candidate ""[[[[]]]]"" == True then pure () else error ""assertion failed""
  if candidate ""[]]]]]]]]]]"" == False then pure () else error ""assertion failed""
  if candidate ""[][][[]]"" == True then pure () else error ""assertion failed""
  if candidate ""[[]"" == False then pure () else error ""assertion failed""
  if candidate ""[]]"" == False then pure () else error ""assertion failed""
  if candidate ""[[]][["" == True then pure () else error ""assertion failed""
  if candidate ""[[][]]"" == True then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""[[[[[[[["" == False then pure () else error ""assertion failed""
  if candidate ""]]]]]]]]"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_133,mlt_Latn,hs,"--Eżempji: --Agħlaq kull element fil-lista sal-ogħla int ((Il-limitu massimu) l-ewwel. --Għandek bżonn li jirritornaw is-somma ta ' numri kwadrati fil-lista mogħtija, --◯ Inti tingħata lista ta 'numri. ◯--  >>> lst [1.0,2.0,3.0]
--  14
--  >>> lst [1.0,4.0,9.0]
--  98
--  >>> lst [1.0,3.0,5.0,7.0]
--  84
--  >>> lst [1.4,4.2,0.0]
--  29
--  >>> lst [-2.4,1.0,1.0]
--  6
sumSquares :: [Float] -> Int
sumSquares lst =","import Data.List (foldl')
import Prelude hiding (sum)

sumSquares :: [Float] -> Int
sumSquares lst = foldl' (\acc x -> acc + ceiling x ^ 2) 0 lst","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,2.0,3.0] == 14 then pure () else error ""assertion failed""
  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error ""assertion failed""
  if candidate [1.4,4.2,0.0] == 29 then pure () else error ""assertion failed""
  if candidate [-2.4,1.0,1.0] == 6 then pure () else error ""assertion failed""
  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error ""assertion failed""
  if candidate [10000.0,10000.0] == 200000000 then pure () else error ""assertion failed""
  if candidate [-1.4,4.6,6.3] == 75 then pure () else error ""assertion failed""
  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error ""assertion failed""
  if candidate [0.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0] == 1 then pure () else error ""assertion failed""
  if candidate [-1.0,1.0,0.0] == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_134,mlt_Latn,hs,"--Eżempji: --Nota: ""kelma"" hija grupp ta' karattri separati b'ispazju. --parti minn kelma, u falza inkella. --ta ' stringa partikolari hija karattru alfabetiku u mhux --Ħol funzjoni li tirritorna True jekk l- aħħar karattru --  >>> checkIfLastCharIsALetter ""apple pie""
--  False
--  >>> checkIfLastCharIsALetter ""apple pi e""
--  True
--  >>> checkIfLastCharIsALetter ""apple pi e ""
--  False
--  >>> checkIfLastCharIsALetter """"
--  False
checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt =","checkIfLastCharIsALetter :: String -> Bool
checkIfLastCharIsALetter txt = 
    let trimmed = reverse . dropWhile (== ' ') $ reverse txt
    in case trimmed of
        [] -> False
        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","
main :: IO ()
main = do
  let candidate = checkIfLastCharIsALetter
  if candidate ""apple"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e"" == True then pure () else error ""assertion failed""
  if candidate ""eeeee"" == False then pure () else error ""assertion failed""
  if candidate ""A"" == True then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie "" == False then pure () else error ""assertion failed""
  if candidate ""Pumpkin pie 1"" == False then pure () else error ""assertion failed""
  if candidate """" == False then pure () else error ""assertion failed""
  if candidate ""eeeee e "" == False then pure () else error ""assertion failed""
  if candidate ""apple pie"" == False then pure () else error ""assertion failed""
  if candidate ""apple pi e "" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_135,mlt_Latn,hs,"--Eżempji: --valuri doppji. --ma jeżisti l-ebda element bħal dan allura jirritorna -1. Il-lista mogħtija ma jkollhiex --ma jkunx akbar minn jew ugwali għall-element li jkun eżatt qabel.--Ħol funzjoni li tirritorna l-akbar indiċi ta ' element li --  >>> canArrange [1,2,4,3,5]
--  3
--  >>> canArrange [1,2,3]
--  (-1)
canArrange :: [Int] -> Int
canArrange arr =","canArrange :: [Int] -> Int
canArrange arr = go arr (-1) 0
  where
    go [] maxIdx _ = maxIdx
    go [_] maxIdx _ = maxIdx
    go (x:y:xs) maxIdx idx
      | x >= y    = go (y:xs) idx (idx + 1)
      | otherwise = go (y:xs) maxIdx (idx + 1)","
main :: IO ()
main = do
  let candidate = canArrange
  if candidate [1,2,4,3,5] == 3 then pure () else error ""assertion failed""
  if candidate [1,2,4,5] == (-1) then pure () else error ""assertion failed""
  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error ""assertion failed""
  if candidate [4,8,5,7,3] == 4 then pure () else error ""assertion failed""
  if candidate [] == (-1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_136,mlt_Latn,hs,"--Eżempji: --Jekk ma jkun hemm l-ebda numru sħiħ negattiv jew pożittiv, jirritornawhom bħala xejn.--ta' numri sħaħ pożittivi f'lista. --l-akbar ta 'inteġers negattivi, u ""b"" huwa l-iżgħar --Ħol funzjoni li jirritorna tuple (a, b), fejn 'a' huwa --  >>> largestSmallestIntegers [2,4,1,3,5,7]
--  (Nothing, 1)
--  >>> largestSmallestIntegers []
--  (Nothing, Nothing)
--  >>> largestSmallestIntegers [0]
--  (Nothing, Nothing)
largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst =","largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)
largestSmallestIntegers lst = (largestNegative, smallestPositive)
  where
    negatives = filter (< 0) lst
    positives = filter (> 0) lst
    largestNegative = if null negatives then Nothing else Just (maximum negatives)
    smallestPositive = if null positives then Nothing else Just (minimum positives)","
main :: IO ()
main = do
  let candidate = largestSmallestIntegers
  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error ""assertion failed""
  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error ""assertion failed""
  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error ""assertion failed""
  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error ""assertion failed""
  if candidate [] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [0] == (Nothing, Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error ""assertion failed""
  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error ""assertion failed""
  pure ()"
HumanEval_138,mlt_Latn,hs,"--Eżempju --❑ Evalwa jekk in-numru mogħti n jistax jinkiteb bħala s-somma ta' eżattament 4 numri pari pożittivi.--  >>> isEqualToSumEven 4
--  False
--  >>> isEqualToSumEven 6
--  False
--  >>> isEqualToSumEven 8
--  True
isEqualToSumEven :: Int -> Bool
isEqualToSumEven n =","isEqualToSumEven :: Int -> Bool
isEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","
main :: IO ()
main = do
  let candidate = isEqualToSumEven
  if candidate 4 == False then pure () else error ""assertion failed""
  if candidate 6 == False then pure () else error ""assertion failed""
  if candidate 8 == True then pure () else error ""assertion failed""
  if candidate 10 == True then pure () else error ""assertion failed""
  if candidate 11 == False then pure () else error ""assertion failed""
  if candidate 12 == True then pure () else error ""assertion failed""
  if candidate 13 == False then pure () else error ""assertion failed""
  if candidate 16 == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_139,mlt_Latn,hs,"--Pereżempju: --fejn n > 0 --brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! --Il-fatturjali Brażiljan huwa definit bħala:--  >>> specialFactorial 4
--  288
--  The function will receive an integer as input and should return the special
--  factorial of this integer.
specialFactorial :: Int -> Int
specialFactorial n =","specialFactorial :: Int -> Int
specialFactorial n = product [factorial x | x <- [1..n]]
  where
    factorial 0 = 1
    factorial k = k * factorial (k - 1)","
main :: IO ()
main = do
  let candidate = specialFactorial
  if candidate 4 == 288 then pure () else error ""assertion failed""
  if candidate 5 == 34560 then pure () else error ""assertion failed""
  if candidate 7 == 125411328000 then pure () else error ""assertion failed""
  if candidate 1 == 1 then pure () else error ""assertion failed""
  pure ()"
HumanEval_140,mlt_Latn,hs,"--imbagħad ibdel l-ispazji konsekuttivi kollha b' - --u jekk string għandu aktar minn 2 spazji konsekuttivi, --❑ Meta tingħata stringa ta' test, ibdel l-ispazji kollha fiha b'sottoskritti, ❑--  >>> fixSpaces "" Example""
--  ""Example""
--  >>> fixSpaces "" Example 1""
--  ""Example_1""
--  >>> fixSpaces "" Example 2""
--  ""_Example_2""
--  >>> fixSpaces "" Example 3""
--  ""_Example-3""
fixSpaces :: String -> String
fixSpaces text =","fixSpaces :: String -> String
fixSpaces text = concatMap replaceSpaces (groupSpaces text)
  where
    groupSpaces :: String -> [String]
    groupSpaces [] = []
    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest

    replaceSpaces :: String -> String
    replaceSpaces spaces@(x:_)
      | x == ' ' && length spaces > 2 = ""-""
      | x == ' ' = replicate (length spaces) '_'
      | otherwise = spaces","
main :: IO ()
main = do
  let candidate = fixSpaces
  if candidate ""Example"" == ""Example"" then pure () else error ""assertion failed""
  if candidate ""Mudasir Hanif "" == ""Mudasir_Hanif_"" then pure () else error ""assertion failed""
  if candidate ""Yellow Yellow  Dirty  Fellow"" == ""Yellow_Yellow__Dirty__Fellow"" then pure () else error ""assertion failed""
  if candidate ""Exa   mple"" == ""Exa-mple"" then pure () else error ""assertion failed""
  if candidate ""   Exa 1 2 2 mple"" == ""-Exa_1_2_2_mple"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_141,mlt_Latn,hs,"--Eżempji: --- Is-substring wara l-punt għandu jkun wieħed minn dawn: ['txt', 'exe', 'dll'] --il-alfabett Latin ('a'-'z' u 'A'-'Z'). --- Is-substring qabel il-punt m'għandux ikun vojt, u jibda b'ittra minn --- L-isem tal-fajl fih eżattament punt wieħed '.' --- L-isem tal-fajl m'għandux ikun fih aktar minn tliet ċifri ('0'-'9'). --huma sodisfatti: --L-isem ta' fajl jitqies bħala validu jekk u biss jekk il-kundizzjonijiet kollha li ġejjin ikunu ssodisfati --""Iva"" jekk l-isem tal-fajl huwa validu, u jirritorna ""Le"" inkella. --◯ Ħolqien ta' funzjoni li tieħu stringa li tirrappreżenta l-isem ta' fajl, u tirritorna ◯--  >>> fileNameCheck ""example.txt""
--  ""Yes""
--  >>> fileNameCheck ""1example.dll""
--  ""No""
fileNameCheck :: String -> String
fileNameCheck file_name =","import Data.Char (isDigit, isLetter)

fileNameCheck :: String -> String
fileNameCheck file_name 
  | countDots /= 1 = ""No""
  | length digits > 3 = ""No""
  | null beforeDot || not (isLetter (head beforeDot)) = ""No""
  | afterDot `notElem` validExtensions = ""No""
  | otherwise = ""Yes""
  where 
    (beforeDot, afterDot) = span (/= '.') file_name
    countDots = length $ filter (== '.') file_name
    digits = filter isDigit file_name
    validExtensions = [""txt"", ""exe"", ""dll""]
    afterDot = if null dotAndAfter then """" else tail dotAndAfter
    dotAndAfter = dropWhile (/= '.') file_name","
main :: IO ()
main = do
  let candidate = fileNameCheck
  if candidate ""example.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1example.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s1sdf3.asd"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""K.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""MY16FILE3.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""His12FILE94.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_Y.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""?aREYA.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""/this_is_valid.dll"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.wow"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""this_is_valid.txtexe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""#this2_i4s_5valid.ten"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""@this1_is6_valid.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""this_is_12valid.6exe4.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""all.exe.txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_No.exe"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""Is3youfault.txt"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""no_one#knows.dll"" == ""Yes"" then pure () else error ""assertion failed""
  if candidate ""1I563_Yes3.exe"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""I563_Yes3.txtt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final..txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""final132"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""_f4indsartal132."" == ""No"" then pure () else error ""assertion failed""
  if candidate "".txt"" == ""No"" then pure () else error ""assertion failed""
  if candidate ""s."" == ""No"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_142,mlt_Latn,hs,"--Eżempji: --tibdel l-entrati fil-lista li l-indiċi tagħhom ma jkunx multiplu ta' 3 jew 4. Il-funzjoni mbagħad għandha tirritorna s-somma tal-entrati kollha. --multiplu ta' 3 u se jkupaw l-entrata ta' l-intjer jekk l-indiċi tiegħu huwa multiplu ta' 4 u mhux multiplu ta' 3. Il-funzjoni ma --Din il-funzjoni se tieħu lista ta' numri sħaħ. Għall-entrati kollha fil-lista, il-funzjoni għandha tikkwadra l-entrata ta' numru sħaħ jekk l-indiċi tagħha huwa a --"" --  >>> lst
--  [1,2,3]
--  >>> lst
--  []
--  >>> lst
--  [(-1),(-5),2,(-1),(-5)]
sumSquares :: [Int] -> Int
sumSquares lst =","sumSquares :: [Int] -> Int
sumSquares lst = sum $ zipWith transform [0..] lst
  where
    transform idx x
      | idx `mod` 3 == 0 = x * x
      | idx `mod` 4 == 0 = x * x * x
      | otherwise        = x","
main :: IO ()
main = do
  let candidate = sumSquares
  if candidate [1,2,3] == 6 then pure () else error ""assertion failed""
  if candidate [1,4,9] == 14 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error ""assertion failed""
  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error ""assertion failed""
  if candidate [0] == 0 then pure () else error ""assertion failed""
  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error ""assertion failed""
  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error ""assertion failed""
  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error ""assertion failed""
  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error ""assertion failed""
  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error ""assertion failed""
  pure ()"
HumanEval_143,mlt_Latn,hs,"--Eżempju 1: --l-ordni tal-kliem fil-linja l-ġdida għandu jkun l-istess bħal dak oriġinali. --li t-tul tagħhom huma numri primi, --u inti għandek biex jirritornaw string li fih il-kliem mill-sentenza oriġinali, --il-frażi fiha xi kliem separati b'ispazju, --Inti tingħata string li jirrappreżenta sentenza, --  >>> wordsInSentence ""This is a test""
--  ""is""
--  Example 2:
--  >>> wordsInSentence ""lets go for swimming""
--  ""go for""
--  Constraints:
--  * 1 <= len(sentence) <= 100
--  * sentence contains only letters
wordsInSentence :: String -> String
wordsInSentence sentence =","import Data.List (intercalate)

wordsInSentence :: String -> String
wordsInSentence sentence = intercalate "" "" $ filter (isPrime . length) (words sentence)

isPrime :: Int -> Bool
isPrime n | n < 2     = False
          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]

isqrt :: Int -> Int
isqrt = floor . sqrt . fromIntegral","
main :: IO ()
main = do
  let candidate = wordsInSentence
  if candidate ""This is a test"" == ""is"" then pure () else error ""assertion failed""
  if candidate ""lets go for swimming"" == ""go for"" then pure () else error ""assertion failed""
  if candidate ""there is no place available here"" == ""there is no place"" then pure () else error ""assertion failed""
  if candidate ""Hi I am Hussein"" == ""Hi am Hussein"" then pure () else error ""assertion failed""
  if candidate ""go for it"" == ""go for it"" then pure () else error ""assertion failed""
  if candidate ""here"" == """" then pure () else error ""assertion failed""
  if candidate ""here is"" == ""is"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_144,mlt_Latn,hs,"--Tista 'taċċetta li x, u n huma frazzjonijiet validi, u ma jkollhomx żero bħala denominatur. --<numeratur>/<denominatur> fejn kemm in-numeratur kif ukoll id-denominatur huma numri sħaħ pożittivi. --kemm x u n, huma rappreżentazzjoni ta' stringa ta' frakzzjoni, u għandhom il-format li ġej, --x * n. Il-funzjoni tirritorna True jekk x * n jiġi evalwat għal numru sħiħ u False --❑ Il-kompitu tiegħek huwa li timplimenta funzjoni li se jissimplifika l-espressjoni.--  >>> simplify ""1/5"" ""5/1""
--  True
--  >>> simplify ""1/6"" ""2/1""
--  False
--  >>> simplify ""7/10"" ""10/2""
--  False
simplify :: String -> String -> Bool
simplify x n =","import Data.Ratio (denominator, numerator, (%))

simplify :: String -> String -> Bool
simplify x n =
  let (xNum, xDen) = toFraction x
      (nNum, nDen) = toFraction n
      result = (xNum * nNum) % (xDen * nDen)
  in denominator result == 1

toFraction :: String -> (Integer, Integer)
toFraction s =
  let (numStr, _:denStr) = break (=='/') s
  in (read numStr, read denStr)","
main :: IO ()
main = do
  let candidate = simplify
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/6"" ""2/1"" == False then pure () else error ""assertion failed""
  if candidate ""5/1"" ""3/1"" == True then pure () else error ""assertion failed""
  if candidate ""7/10"" ""10/2"" == False then pure () else error ""assertion failed""
  if candidate ""2/10"" ""50/10"" == True then pure () else error ""assertion failed""
  if candidate ""7/2"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""11/6"" ""6/1"" == True then pure () else error ""assertion failed""
  if candidate ""2/3"" ""5/2"" == False then pure () else error ""assertion failed""
  if candidate ""5/2"" ""3/5"" == False then pure () else error ""assertion failed""
  if candidate ""2/4"" ""8/4"" == True then pure () else error ""assertion failed""
  if candidate ""2/4"" ""4/2"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""5/1"" == True then pure () else error ""assertion failed""
  if candidate ""1/5"" ""1/5"" == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_145,mlt_Latn,hs,"--Pereżempju: --jirranġahom abbażi tal-indiċi tagħhom fil-lista oriġinali.--Nota: jekk hemm diversi entrati b'somma simili tad-diġiti tagħhom, --f'ordni li jikber skont is-somma tad-diġiti tagħhom. --Għandek tikteb funzjoni li ssordi l-lista mogħtija ta 'integers.--  >>> orderByPoints [1,11,(-1),(-11),(-12)]
--  [(-1),(-11),1,(-12),11]
--  >>> orderByPoints []
--  []
orderByPoints :: [Int] -> [Int]
orderByPoints nums =","import Data.List (sortBy)
import Data.Function (on)

orderByPoints :: [Int] -> [Int]
orderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums
  where
    sumOfDigits :: Int -> Int
    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)
    
    indexedNums :: [(Int, Int)]
    indexedNums = zip (map sumOfDigits nums) nums","
main :: IO ()
main = do
  let candidate = orderByPoints
  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error ""assertion failed""
  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error ""assertion failed""
  if candidate [] == [] then pure () else error ""assertion failed""
  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error ""assertion failed""
  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error ""assertion failed""
  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error ""assertion failed""
  pure ()"
HumanEval_146,mlt_Latn,hs,"--Pereżempju: --L-ewwel u l-aħħar ċifri ta' numru huma mhux par (1, 3, 5, 7, 9). --in-numru ta ' elementi fil-lista li huma akbar minn 10 u t-tnejn --Għandek tikteb funzjoni li tieħu lista ta 'numri bħala input u tirritorna --  >>> specialfilter [15,(-73),14,(-15)]
--  1
--  >>> specialfilter [33,(-2),(-3),45,21,109]
--  2
specialfilter :: [Int] -> Int
specialfilter nums =","specialfilter :: [Int] -> Int
specialfilter nums = length $ filter isSpecial nums
  where
    isSpecial n = n > 10 && isOddFirstAndLast (abs n)

    isOddFirstAndLast :: Int -> Bool
    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit
      where
        xStr = show x
        firstDigit = head xStr
        lastDigit = last xStr

    isOddDigit :: Char -> Bool
    isOddDigit c = c `elem` ""13579""","
main :: IO ()
main = do
  let candidate = specialfilter
  if candidate [5,(-2),1,(-5)] == 0 then pure () else error ""assertion failed""
  if candidate [15,(-73),14,(-15)] == 1 then pure () else error ""assertion failed""
  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error ""assertion failed""
  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error ""assertion failed""
  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error ""assertion failed""
  if candidate [1] == 0 then pure () else error ""assertion failed""
  if candidate [] == 0 then pure () else error ""assertion failed""
  pure ()"
HumanEval_147,mlt_Latn,hs,"--Eżempju: --u a[i] + a[j] + a[k] huwa multiplu ta ' 3. --Irtira n-numru ta' triples (a[i], a[j], a[k]) ta' a fejn i < j < k, --Għal kull i (1 ≤ i ≤ n), il-valur ta' a[i] = i * i - i + 1. --Inti tingħata numru sħiħ pożittiv n. Inti għandek toħloq lista ta 'interji ta' tul n. --  >>> getMaxTriples 5
--  1
--  Explanation: 
--  a = [1, 3, 7, 13, 21]
--  The only valid triple is (1, 7, 13).
getMaxTriples :: Int -> Int
getMaxTriples n =","getMaxTriples :: Int -> Int
getMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]
  where
    a = [i * i - i + 1 | i <- [1..n]]","
main :: IO ()
main = do
  let candidate = getMaxTriples
  if candidate 5 == 1 then pure () else error ""assertion failed""
  if candidate 6 == 4 then pure () else error ""assertion failed""
  if candidate 10 == 36 then pure () else error ""assertion failed""
  if candidate 100 == 53361 then pure () else error ""assertion failed""
  pure ()"
HumanEval_149,mlt_Latn,hs,"--Pereżempju: --Tista' tassumi li l-kliem kollha jkollhom l-istess tul. --Il-funzjoni għandha tirritorna lista ta ' strings f'ordni ordnat. --Jekk żewġ kelmiet ikollhom l-istess tul, issortja l-lista skont l-alfabet. --għandha tirritorna l-lista magħżula b'dik ir-regola. --L-ordni tal-lista għandha tkun li titla' bil-tul ta' kull kelma, u inti --u jista' jkun fih duplikati. --Il-lista hija dejjem lista ta 'strings u qatt lista ta' numri, --u jirritorna l-lista li tirriżulta b'ordni magħżula, --tħassar il-ktajjen li għandhom tul mhux ugwali minnha, --Ħu l-funzjoni li taċċetta lista ta 'strings bħala parametru, --  >>> listSort [""aa"",""a"",""aaa""]
--  [""aa""]
--  >>> listSort [""ab"",""a"",""aaa"",""cd""]
--  [""ab"",""cd""]
sortedListSum :: [String] -> [String]
sortedListSum lst =","sortedListSum :: [String] -> [String]
sortedListSum lst = sortBy compareStrings (filter evenLength lst)
  where
    evenLength s = even (length s)
    compareStrings s1 s2
      | length s1 == length s2 = compare s1 s2
      | otherwise = compare (length s1) (length s2)","
main :: IO ()
main = do
  let candidate = sortedListSum
  if candidate [""aa"",""a"",""aaa""] == [""aa""] then pure () else error ""assertion failed""
  if candidate [""school"",""AI"",""asdf"",""b""] == [""AI"",""asdf"",""school""] then pure () else error ""assertion failed""
  if candidate [""d"",""b"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""d"",""dcba"",""abcd"",""a""] == [""abcd"",""dcba""] then pure () else error ""assertion failed""
  if candidate [""AI"",""ai"",""au""] == [""AI"",""ai"",""au""] then pure () else error ""assertion failed""
  if candidate [""a"",""b"",""b"",""c"",""c"",""a""] == [] then pure () else error ""assertion failed""
  if candidate [""aaaa"",""bbbb"",""dd"",""cc""] == [""cc"",""dd"",""aaaa"",""bbbb""] then pure () else error ""assertion failed""
  pure ()"
HumanEval_150,mlt_Latn,hs,"--Eżempji: --numru prim u għandu jirritorna l-valur ta ' y inkella. --Programm sempliċi li għandu jirritorna l-valur ta 'x jekk n huwa --  >>> xOrY 7 34 12
--  34
--  >>> xOrY 15 8 5
--  5
xOrY :: Int -> Int -> Int -> Int
xOrY n x y =","xOrY :: Int -> Int -> Int -> Int
xOrY n x y = if isPrime n then x else y

isPrime :: Int -> Bool
isPrime k
  | k < 2     = False
  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","
main :: IO ()
main = do
  let candidate = xOrY
  if candidate 7 34 12 == 34 then pure () else error ""assertion failed""
  if candidate 15 8 5 == 5 then pure () else error ""assertion failed""
  if candidate 3 33 5212 == 33 then pure () else error ""assertion failed""
  if candidate 1259 3 52 == 3 then pure () else error ""assertion failed""
  if candidate 7919 (-1) 12 == (-1) then pure () else error ""assertion failed""
  if candidate 3609 1245 583 == 583 then pure () else error ""assertion failed""
  if candidate 91 56 129 == 129 then pure () else error ""assertion failed""
  if candidate 6 34 1234 == 1234 then pure () else error ""assertion failed""
  if candidate 1 2 0 == 0 then pure () else error ""assertion failed""
  if candidate 2 2 0 == 2 then pure () else error ""assertion failed""
  pure ()"
HumanEval_151,mlt_Latn,hs,"--Fil-lista li huma mhux par. Iġġornat numri li huma negattivi jew mhux integers. --Meta tingħata lista ta' numri, irritorna s-somma tal-kwartieri tan-numri.--  >>> doubleTheDifference [1,3,2,0]
--  10
--  >>> doubleTheDifference [(-1),(-2),0]
--  0
--  >>> doubleTheDifference [9,(-2)]
--  81
--  >>> doubleTheDifference [0]
--  0
--  If the input list is empty, return 0.
doubleTheDifference :: [Float] -> Int
doubleTheDifference lst =","doubleTheDifference :: [Float] -> Int
doubleTheDifference lst = 
    sum [x * x | x <- map round lst, x > 0, odd x]","
main :: IO ()
main = do
  let candidate = doubleTheDifference
  if candidate [.0] == 0 then pure () else error ""assertion failed""
  if candidate [5.0,4.0] == 25 then pure () else error ""assertion failed""
  if candidate [0.1,0.2,0.3] == 0 then pure () else error ""assertion failed""
  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error ""assertion failed""
  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error ""assertion failed""
  if candidate [0.2,3.0,5.0] == 34 then pure () else error ""assertion failed""
  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error ""assertion failed""
  pure ()"
HumanEval_152,mlt_Latn,hs,"--eżempju: --il-valur huwa 0, u jekk le, il-valur huwa d-differenza assoluta bejn il-ħsieb u l-punteġġ. --Irritorna lista tal-istess tul li tindika kemm kien bogħod kull ħsieb. Jekk ħassru sewwa, --Inti tingħata żewġ listi ta' punteġġi u ħsibijiet ta' tul ugwali, fejn kull indiċi juri taqbil. --Il-kompitu tiegħek huwa li tiddetermina jekk persuna ħassitxx b'mod korrett ir-riżultati ta' numru ta' logħbiet.--definittivament ta' min jinnota u jqabbel. --l-avveniment huwa finalment magħruf.--Naħseb li lkoll niftakru f'dik is-sentiment meta r-riżultat ta' xi ħaġa li ilna nistennew--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]
--  [0,0,0,0,3,3]
--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]
--  [4,4,1,0,0,6]
compare :: [Int] -> [Int] -> [Int]
compare game guess =","compare :: [Int] -> [Int] -> [Int]
compare game guess = zipWith (\g s -> abs (g - s)) game guess","
main :: IO ()
main = do
  let candidate = compare
  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error ""assertion failed""
  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error ""assertion failed""
  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error ""assertion failed""
  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error ""assertion failed""
  pure ()"
HumanEval_153,mlt_Latn,hs,"--Eżempju: --(il- qawwa tagħha hija -1). --jirritorna ""Slices.SErviNGSliCes"" peress li ""SErviNGSliCes"" hija l-aktar estensjoni b'saħħitha --['SErviNGSliCes', 'Cheese', 'StuFfed'] allura għandek --Pereżempju, jekk inti tingħata ""Slices"" bħala l-klassi u lista ta ' l- --Agħżel l-ewwel waħda mil-lista.--Jekk hemm żewġ estensjonijiet jew aktar bl- istess qawwa, għandek --format: ClassName.StrongestExtensionName. --Għandek issib l-aktar estensjoni b'saħħitha u tirritorna string f'dan --fl-isem tal-estensjoni, il-qawwa tingħata mill-frazzjoni CAP - SM. --ittri fl-isem tal-estensjoni, u SM ikun in-numru ta' ittri żgħar --il-qawwa tal-estensjoni hija kif ġej: Ħalli CAP tkun in-numru tal-karattri kbar --L-estensjonijiet għandhom jintużaw biex jitgħabbew klassijiet addizzjonali għall-klassi.--❑ Int se tingħata l-isem ta 'klassi (string) u lista ta' estensjonijiet.--  >>> strongestExtension ""my_class"" [""AA"",""Be"",""CC""]
--  ""my_class.AA""
strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions =","strongestExtension :: String -> [String] -> String
strongestExtension class_name extensions = class_name ++ ""."" ++ strongestExt
  where
    calculateStrength :: String -> Int
    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)
    
    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)
    
    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)
    maxStrength ext1 ext2
      | snd ext1 > snd ext2 = ext1
      | otherwise           = ext2","
main :: IO ()
main = do
  let candidate = strongestExtension
  if candidate ""Watashi"" [""tEN"",""niNE"",""eIGHt8OKe""] == ""Watashi.eIGHt8OKe"" then pure () else error ""assertion failed""
  if candidate ""Boku123"" [""nani"",""NazeDa"",""YEs.WeCaNe"",""32145tggg""] == ""Boku123.YEs.WeCaNe"" then pure () else error ""assertion failed""
  if candidate ""__YESIMHERE"" [""t"",""eMptY"",""nothing"",""zeR00"",""NuLl__"",""123NoooneB321""] == ""__YESIMHERE.NuLl__"" then pure () else error ""assertion failed""
  if candidate ""K"" [""Ta"",""TAR"",""t234An"",""cosSo""] == ""K.TAR"" then pure () else error ""assertion failed""
  if candidate ""__HAHA"" [""Tab"",""123"",""781345"",""-_-""] == ""__HAHA.123"" then pure () else error ""assertion failed""
  if candidate ""YameRore"" [""HhAas"",""okIWILL123"",""WorkOut"",""Fails"",""-_-""] == ""YameRore.okIWILL123"" then pure () else error ""assertion failed""
  if candidate ""finNNalLLly"" [""Die"",""NowW"",""Wow"",""WoW""] == ""finNNalLLly.WoW"" then pure () else error ""assertion failed""
  if candidate ""_"" [""Bb"",""91245""] == ""_.Bb"" then pure () else error ""assertion failed""
  if candidate ""Sp"" [""671235"",""Bb""] == ""Sp.671235"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_154,mlt_Latn,hs,"--Inti tingħata 2 kliem. għandek bżonn li jirritorna True jekk it-tieni kelma jew xi wieħed mill-rotazzjoni tagħha hija substring fl-ewwel kelma.--  >>> cycpatternCheck ""abcd"" ""abd""
--  False
--  >>> cycpatternCheck ""hello"" ""ell""
--  True
--  >>> cycpatternCheck ""whassup"" ""psus""
--  False
--  >>> cycpatternCheck ""abab"" ""baa""
--  True
--  >>> cycpatternCheck ""efef"" ""eeff""
--  False
--  >>> cycpatternCheck ""himenss"" ""simen""
--  True
cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b =","cycpatternCheck :: String -> String -> Bool
cycpatternCheck a b = any (`isInfixOf` a) rotations
  where
    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","
main :: IO ()
main = do
  let candidate = cycpatternCheck
  if candidate ""xyzw"" ""xyw"" == False then pure () else error ""assertion failed""
  if candidate ""yello"" ""ell"" == True then pure () else error ""assertion failed""
  if candidate ""whattup"" ""ptut"" == False then pure () else error ""assertion failed""
  if candidate ""efef"" ""fee"" == True then pure () else error ""assertion failed""
  if candidate ""abab"" ""aabb"" == False then pure () else error ""assertion failed""
  if candidate ""winemtt"" ""tinem"" == True then pure () else error ""assertion failed""
  pure ()"
HumanEval_155,mlt_Latn,hs,"--Eżempju: --Ħalli numru sħiħ. jirritorna tuple li għandu n-numru ta 'diġiti pari u mhux par rispettivament.--  >>> evenOddCount (-12)
--  (1, 1)
--  >>> evenOddCount 123
--  (1, 2)
evenOddCount :: Int -> (Int, Int)
evenOddCount num =","evenOddCount :: Int -> (Int, Int)
evenOddCount num = (length evens, length odds)
  where
    digits = map (read . (:[])) . show . abs $ num
    evens = filter even digits
    odds  = filter odd digits","
main :: IO ()
main = do
  let candidate = evenOddCount
  if candidate 7 == (0, 1) then pure () else error ""assertion failed""
  if candidate (-78) == (1, 1) then pure () else error ""assertion failed""
  if candidate 3452 == (2, 2) then pure () else error ""assertion failed""
  if candidate 346211 == (3, 3) then pure () else error ""assertion failed""
  if candidate (-345821) == (3, 3) then pure () else error ""assertion failed""
  if candidate (-2) == (1, 0) then pure () else error ""assertion failed""
  if candidate (-45347) == (2, 3) then pure () else error ""assertion failed""
  if candidate 0 == (1, 0) then pure () else error ""assertion failed""
  pure ()"
HumanEval_156,mlt_Latn,hs,"--Eżempji: --Restrizzjonijiet: 1 <= num <= 1000 --u jirritornah b'ittri żgħar. --│ │G¢al numru sħiħ pożittiv, tikseb l-ekwivalenti tiegħu f'numri Rumani bħala stringa, │--  >>> intToMiniRoman 19
--  ""xix""
--  >>> intToMiniRoman 152
--  ""clii""
--  >>> intToMiniRoman 426
--  ""cdxxvi""
intToMiniRoman :: Int -> String
intToMiniRoman number =","intToMiniRoman :: Int -> String
intToMiniRoman number = concatMap (replicateSymbol number) romanNumerals
  where
    romanNumerals = [(1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
                     (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
                     (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""), (1, ""i"")]
    
    replicateSymbol :: Int -> (Int, String) -> String
    replicateSymbol n (value, symbol)
      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)
      | otherwise = """"","
main :: IO ()
main = do
  let candidate = intToMiniRoman
  if candidate 19 == ""xix"" then pure () else error ""assertion failed""
  if candidate 152 == ""clii"" then pure () else error ""assertion failed""
  if candidate 251 == ""ccli"" then pure () else error ""assertion failed""
  if candidate 426 == ""cdxxvi"" then pure () else error ""assertion failed""
  if candidate 500 == ""d"" then pure () else error ""assertion failed""
  if candidate 1 == ""i"" then pure () else error ""assertion failed""
  if candidate 4 == ""iv"" then pure () else error ""assertion failed""
  if candidate 43 == ""xliii"" then pure () else error ""assertion failed""
  if candidate 90 == ""xc"" then pure () else error ""assertion failed""
  if candidate 94 == ""xciv"" then pure () else error ""assertion failed""
  if candidate 532 == ""dxxxii"" then pure () else error ""assertion failed""
  if candidate 900 == ""cm"" then pure () else error ""assertion failed""
  if candidate 994 == ""cmxciv"" then pure () else error ""assertion failed""
  if candidate 1000 == ""m"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_157,mlt_Latn,hs,"--Eżempju: --90 grad. --Triangolu rettangolari huwa triangolu li fih angolu wieħed huwa rettangolu jew --Il-partijiet ta' triangolu b'angolu rett, jekk le, Falsi.--Meta tingħata t-tul tat-tliet naħat ta 'triangolu. jirritorna True jekk it-tliet --  >>> rightAngleTriangle 3 4 5
--  True
--  >>> rightAngleTriangle 1 2 3
--  False
rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c =","rightAngleTriangle :: Int -> Int -> Int -> Bool
rightAngleTriangle a b c = 
    let [x, y, z] = sort [a, b, c]
    in x^2 + y^2 == z^2
    where sort = Data.List.sort","
main :: IO ()
main = do
  let candidate = rightAngleTriangle
  if candidate 3 4 5 == True then pure () else error ""assertion failed""
  if candidate 1 2 3 == False then pure () else error ""assertion failed""
  if candidate 10 6 8 == True then pure () else error ""assertion failed""
  if candidate 2 2 2 == False then pure () else error ""assertion failed""
  if candidate 7 24 25 == True then pure () else error ""assertion failed""
  if candidate 10 5 7 == False then pure () else error ""assertion failed""
  if candidate 5 12 13 == True then pure () else error ""assertion failed""
  if candidate 15 8 17 == True then pure () else error ""assertion failed""
  if candidate 48 55 73 == True then pure () else error ""assertion failed""
  if candidate 1 1 1 == False then pure () else error ""assertion failed""
  if candidate 2 2 10 == False then pure () else error ""assertion failed""
  pure ()"
HumanEval_158,mlt_Latn,hs,"--Karattri, jirritornaw dak li jiġi l-ewwel fl-ordni leksikografika. --Jekk strings multipli jkollhom numru massimu ta ' karattri uniċi --Il-lista fiha kliem differenti.--Ħu l-logħba tiegħek.--  >>> findMax [""name"",""of"",""string""]
--  ""string""
--  >>> findMax [""name"",""enam"",""game""]
--  ""enam""
--  >>> findMax [""aaaaaaa"",""bb"",""cc""]
--  ""aaaaaaa""
findMax :: [String] -> String
findMax words =","import Data.List (nub, sort)

findMax :: [String] -> String
findMax words = 
    head . sort . map snd . filter (\(n, _) -> n == maxUnique) $ wordUniquePairs
  where
    wordUniquePairs = [(length . nub $ word, word) | word <- words]
    maxUnique = maximum $ map fst wordUniquePairs","
main :: IO ()
main = do
  let candidate = findMax
  if candidate [""name"",""of"",""string""] == ""string"" then pure () else error ""assertion failed""
  if candidate [""name"",""enam"",""game""] == ""enam"" then pure () else error ""assertion failed""
  if candidate [""aaaaaaa"",""bb"",""cc""] == ""aaaaaaa"" then pure () else error ""assertion failed""
  if candidate [""abc"",""cba""] == ""abc"" then pure () else error ""assertion failed""
  if candidate [""play"",""this"",""game"",""of"",""footbott""] == ""footbott"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""gonna"",""rock""] == ""gonna"" then pure () else error ""assertion failed""
  if candidate [""we"",""are"",""a"",""mad"",""nation""] == ""nation"" then pure () else error ""assertion failed""
  if candidate [""this"",""is"",""a"",""prrk""] == ""this"" then pure () else error ""assertion failed""
  if candidate [""b""] == ""b"" then pure () else error ""assertion failed""
  if candidate [""play"",""play"",""play""] == ""play"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_159,mlt_Latn,hs,"--Eżempju: --jekk ma jkunx hemm biżżejjed ġebel li jkun baqa', int tiekol il-ġebel kollu li jkun baqa', imma xorta tkun bil-ġuħ.--in- numru ta ' ġebel li jibqa ' wara l- ikliet tiegħek ] --għandek tirritorna lista ta ' [ in- numru totali ta ' ġebel miksub wara l- ikliet tiegħek, --imma issa għandek bżonn tiekol iktar ġebel biex tlesti l- ikliet tal- ġurnata.--Inti ħanin bil-ġuħ, u inti diġà tiekol ċertu numru ta 'karrotti,--  >>> eat 5 6 10
--  [11,4]
--  >>> eat 4 8 9
--  [12,1]
--  >>> eat 1 10 10
--  [11,0]
--  >>> eat 2 11 5
--  [7,0]
--  Variables:
--  @number : integer
--  the number of carrots that you have eaten.
--  @need : integer
--  the number of carrots that you need to eat.
--  @remaining : integer
--  the number of remaining carrots thet exist in stock
--  Constrain:
--  * 0 <= number <= 1000
--  * 0 <= need <= 1000
--  * 0 <= remaining <= 1000
--  Have fun :)
eat :: Int -> Int -> Int -> [Int]
eat number need remaining =","eat :: Int -> Int -> Int -> [Int]
eat number need remaining
  | remaining >= need = [number + need, remaining - need]
  | otherwise = [number + remaining, 0]","
main :: IO ()
main = do
  let candidate = eat
  if candidate 5 6 10 == [11,4] then pure () else error ""assertion failed""
  if candidate 4 8 9 == [12,1] then pure () else error ""assertion failed""
  if candidate 1 10 10 == [11,0] then pure () else error ""assertion failed""
  if candidate 2 11 5 == [7,0] then pure () else error ""assertion failed""
  if candidate 4 5 7 == [9,2] then pure () else error ""assertion failed""
  if candidate 4 5 1 == [5,0] then pure () else error ""assertion failed""
  pure ()"
HumanEval_160,mlt_Latn,hs,"--Lista ta' operaturi għandha mill-inqas operatur wieħed, u lista ta' operandi għandha mill-inqas żewġ operandi. --Operand hija lista ta' integers mhux negattivi.--It-tul tal-lista ta' operaturi huwa ugwali għat-tul tal-lista ta' operandi nieqes wieħed. --Nota: --=> riżultat = 9 --ir-riżultat = 2 + 3 * 4 - 5 --lista = [2, 3, 4, 5] --operatur['+', '*', '-'] --Eżempju: --Esponenzazzjoni (**) --Diviżjoni tal-art ( //) --Multiplikazzjoni ( *) --Tnaqqis ( - ) --Żieda (+) --L-operazzjonijiet bażiċi tal-alġebra: --espressjoni u jirritorna l-evalwazzjoni ta' din l-espressjoni. --It-tieni lista hija lista ta' numri sħaħ. Uża ż-żewġ listi mogħtija biex tibni l-alġebra.--Meta tingħata żewġ listi operatur, u operand. L-ewwel lista għandha operazzjonijiet bażiċi alġebra, u doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand =","doAlgebra :: [String] -> [Int] -> Int
doAlgebra operator operand = evaluate operand operator
  where
    evaluate [x] [] = x
    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops
      where
        result = applyOperation op x y

    applyOperation ""+"" a b = a + b
    applyOperation ""-"" a b = a - b
    applyOperation ""*"" a b = a * b
    applyOperation ""//"" a b = a `div` b
    applyOperation ""**"" a b = a ^ b
    applyOperation _ _ _ = error ""Unsupported operation""","
main :: IO ()
main = do
  let candidate = doAlgebra
  if candidate [""**"",""*"",""+""] [2,3,4,5] == 37 then pure () else error ""assertion failed""
  if candidate [""+"",""*"",""-""] [2,3,4,5] == 9 then pure () else error ""assertion failed""
  if candidate [""//"",""*""] [7,3,4] == 8 then pure () else error ""assertion failed""
  pure ()"
HumanEval_161,mlt_Latn,hs,"--Eżempji --Il- funzjoni għandha tirritorna l- stringa li tirriżulta. --Jekk il-ktajjen ma jkun fihom l-ebda ittri, irriversja l-ktajjen.--inkella żommha kif inhi.--jekk s[i] hija ittra, invertit il-każ tagħha minn isfel għal fuq jew viċi versa, --Inti tingħata string s. --  >>> solve ""1234""
--  ""4321""
--  >>> solve ""ab""
--  ""AB""
--  >>> solve ""#a@C""
--  ""#A@c""
solve :: String -> String
solve s =","solve :: String -> String
solve s
  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s
  | otherwise = reverse s
  where
    toggleCase c
      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char
      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char
      | otherwise = c","
main :: IO ()
main = do
  let candidate = solve
  if candidate ""AsDf"" == ""aSdF"" then pure () else error ""assertion failed""
  if candidate ""1234"" == ""4321"" then pure () else error ""assertion failed""
  if candidate ""ab"" == ""AB"" then pure () else error ""assertion failed""
  if candidate ""#a@C"" == ""#A@c"" then pure () else error ""assertion failed""
  if candidate ""#AsdfW^45"" == ""#aSDFw^45"" then pure () else error ""assertion failed""
  if candidate ""#6@2"" == ""2@6#"" then pure () else error ""assertion failed""
  if candidate ""#$a^D"" == ""#$A^d"" then pure () else error ""assertion failed""
  if candidate ""#ccc"" == ""#CCC"" then pure () else error ""assertion failed""
  pure ()"
HumanEval_162,mlt_Latn,hs,"--Jekk 'text' hija stringa vojta, erġa' lura xejn. --☐ Għad-data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data ta' data--  >>> stringToMd5 ""Hello world""
--  Just (""3e25960a79dbc69b674cd4ec67a72c62"")
stringToMd5 :: String -> Maybe String
stringToMd5 text =","import qualified Data.ByteString.Char8 as C
import qualified Data.Digest.Pure.MD5 as MD5

stringToMd5 :: String -> Maybe String
stringToMd5 text
  | null text = Nothing
  | otherwise = Just $ show $ MD5.md5 $ C.pack text","
main :: IO ()
main = do
  let candidate = stringToMd5
  if candidate ""Hello world"" == Just (""3e25960a79dbc69b674cd4ec67a72c62"") then pure () else error ""assertion failed""
  if candidate """" == Just (Nothing) then pure () else error ""assertion failed""
  if candidate ""A B C"" == Just (""0ef78513b0cb8cef12743f5aeb35f888"") then pure () else error ""assertion failed""
  if candidate ""password"" == Just (""5f4dcc3b5aa765d61d8327deb882cf99"") then pure () else error ""assertion failed""
  pure ()"
HumanEval_163,mlt_Latn,hs,"--Pereżempju: --u b, f'ordni li jikber. --Given żewġ integers pożittivi a u b, jirritornaw l-eċċezzjonijiet anke bejn a --  >>> generateIntegers 2 8
--  [2,4,6,8]
--  >>> generateIntegers 8 2
--  [2,4,6,8]
--  >>> generateIntegers 10 14
--  []
generateIntegers :: Int -> Int -> [Int]
generateIntegers a b =","generateIntegers :: Int -> Int -> [Int]
generateIntegers a b = filter even [min a b .. max a b]","
main :: IO ()
main = do
  let candidate = generateIntegers
  if candidate 2 10 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 10 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 132 2 == [2,4,6,8] then pure () else error ""assertion failed""
  if candidate 17 89 == [] then pure () else error ""assertion failed""
  pure ()"
