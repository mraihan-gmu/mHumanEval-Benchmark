task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,spa_Latn,js,"/ en el umbral dado. /Comprueba si en una matriz de números dada, hay dos números más cercanos entre sí que // >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
// false
// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
// true
function has_close_elements(numbers, threshold){
","function has_close_elements(numbers, threshold) {
    // First, sort the array to ensure we check adjacency for closest elements
    numbers.sort((a, b) => a - b);

    // Iterate through the sorted list and check differences between successive elements
    for (let i = 0; i < numbers.length - 1; i++) {
        if (Math.abs(numbers[i] - numbers[i + 1]) < threshold) {
            return true;
        }
    }

    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = has_close_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),true);
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),false);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95),true);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8),false);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0),true);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5),false);
}

test();"
HumanEval_1,spa_Latn,js,"/ Ignore cualquier espacio en la cadena de entrada. / Los grupos separados están equilibrados (cada braza abierta está debidamente cerrada) y no anidados entre sí / separar esos grupos en cadenas separadas y devolver el conjunto de los. /La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidadas.// >>> separate_paren_groups(""( ) (( )) (( )( ))"")
// [""()"", ""(())"", ""(()())""]
function separate_paren_groups(paren_string){
","function separate_paren_groups(paren_string) {
    paren_string = paren_string.replace(/\s+/g, ''); // Remove spaces
    const groups = [];
    let balance = 0;
    let currentGroup = '';

    for (let char of paren_string) {
        currentGroup += char;
        if (char === '(') {
            balance++;
        } else if (char === ')') {
            balance--;
        }
        
        if (balance === 0) {
            groups.push(currentGroup);
            currentGroup = '';
        }
    }

    return groups;
}","const assert = require('node:assert');


function test() {
  let candidate = separate_paren_groups;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[""(()())"", ""((()))"", ""()"", ""((())()())""]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[""()"", ""(())"", ""((()))"", ""(((())))""]);
  assert.deepEqual(candidate(""(()(())((())))""),[""(()(())((())))""]);
  assert.deepEqual(candidate(""( ) (( )) (( )( ))""),[""()"", ""(())"", ""(()())""]);
}

test();"
HumanEval_2,spa_Latn,js,"/ Devuelve la parte decimal del número. / (la parte sobrante siempre es menor que 1). / y la parte entera (integer más grande más pequeño que el número dado) y decimales /Dado un número de punto flotante positivo, se puede descomponer en // >>> truncate_number(3.5)
// 0.5
function truncate_number(number){
","function truncate_number(number) {
    return number - Math.floor(number);
}","const assert = require('node:assert');


function test() {
  let candidate = truncate_number;
  assert.deepEqual(candidate(3.5),0.5);
  assert.deepEqual(candidate(1.25),0.25);
  assert.deepEqual(candidate(123.0),0.0);
}

test();"
HumanEval_3,spa_Latn,js,"/ en ese punto la función debe devolver verdadero. de lo contrario debe devolver falso. Su tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y Se le da una serie de operaciones de depósito y retiro en una cuenta bancaria que comienza con// >>> below_zero([1, 2, 3])
// false
// >>> below_zero([1, 2, -4, 5])
// true
function below_zero(operations){
","function below_zero(operations) {
    let balance = 0;
    for (let i = 0; i < operations.length; i++) {
        balance += operations[i];
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = below_zero;
  assert.deepEqual(candidate([]),false);
  assert.deepEqual(candidate([1, 2, -3, 1, 2, -3]),false);
  assert.deepEqual(candidate([1, 2, -4, 5, 6]),true);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -4]),false);
  assert.deepEqual(candidate([1, -1, 2, -2, 5, -5, 4, -5]),true);
  assert.deepEqual(candidate([1, -2, 2, -2, 5, -5, 4, -4]),true);
}

test();"
HumanEval_4,spa_Latn,js,"/ MAD = promedio  x - x_mean / elemento y un punto central (media en este caso): / La desviación absoluta media es la diferencia absoluta media entre cada / alrededor de la media de este conjunto de datos. / Para una matriz dada de números de entrada, calcule la desviación absoluta media // >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
// 1.0
function mean_absolute_deviation(numbers){
","function mean_absolute_deviation(numbers) {
    const n = numbers.length;
    if (n === 0) return 0;

    const mean = numbers.reduce((acc, val) => acc + val, 0) / n;
    const deviations = numbers.map(num => Math.abs(num - mean));
    const mad = deviations.reduce((acc, val) => acc + val, 0) / n;

    return mad;
}

// Example usage:
console.log(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])); // Output: 1.0","const assert = require('node:assert');


function test() {
  let candidate = mean_absolute_deviation;
  assert.deepEqual(candidate([1.0, 2.0]),0.5);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0]),1.0);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),1.2);
}

test();"
HumanEval_5,spa_Latn,js,"/Inserte un número ""delimitador"" entre cada dos elementos consecutivos de la matriz de entrada ∀numbers"" // >>> intersperse([], 4)
// []
// >>> intersperse([1, 2, 3], 4)
// [1, 4, 2, 4, 3]
function intersperse(numbers, delimeter){
","function intersperse(numbers, delimiter) {
    if (numbers.length === 0) return [];
    
    const result = [];
    for (let i = 0; i < numbers.length - 1; i++) {
        result.push(numbers[i]);
        result.push(delimiter);
    }
    result.push(numbers[numbers.length - 1]);

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = intersperse;
  assert.deepEqual(candidate([], 7),[]);
  assert.deepEqual(candidate([5, 6, 3, 2], 8),[5, 8, 6, 8, 3, 8, 2]);
  assert.deepEqual(candidate([2, 2, 2], 2),[2, 2, 2, 2, 2]);
}

test();"
HumanEval_6,spa_Latn,js,"/ Por ejemplo, (() (()) tiene un máximo de dos niveles de anidación, mientras que ((())) tiene tres. / Para cada uno de los grupos, emita el nivel más profundo de anidación de paréntesis. / La entrada de esta función es una cadena representada por múltiples grupos para paréntesis anidadas separadas por espacios. // >>> parse_nested_parens(""(()()) ((())) () ((())()())"")
// [2, 3, 1, 3]
function parse_nested_parens(paren_string){
","function parse_nested_parens(paren_string) {
    // Split the input string into groups based on spaces
    const groups = paren_string.split(' ');
    // Map each group to its maximum nesting depth
    return groups.map(group => {
        let maxDepth = 0;
        let currentDepth = 0;

        // Iterate through each character in the group
        for (let char of group) {
            if (char === '(') {
                // Increment current depth for '('
                currentDepth++;
                // Update max depth if it's greater than the previous max
                if (currentDepth > maxDepth) {
                    maxDepth = currentDepth;
                }
            } else if (char === ')') {
                // Decrement current depth for ')'
                currentDepth--;
            }
        }
        
        return maxDepth; // Return max depth of this group
    });
}","const assert = require('node:assert');


function test() {
  let candidate = parse_nested_parens;
  assert.deepEqual(candidate(""(()()) ((())) () ((())()())""),[2, 3, 1, 3]);
  assert.deepEqual(candidate(""() (()) ((())) (((())))""),[1, 2, 3, 4]);
  assert.deepEqual(candidate(""(()(())((())))""),[4]);
}

test();"
HumanEval_7,spa_Latn,js,"/Filtrar una matriz de entrada de cadenas sólo para los que contienen la subred dada // >>> filter_by_substring([], ""a"")
// []
// >>> filter_by_substring([""abc"", ""bacd"", ""cde"", ""array""], ""a"")
// [""abc"", ""bacd"", ""array""]
function filter_by_substring(strings, substring){
","function filter_by_substring(strings, substring) {
    return strings.filter(str => str.includes(substring));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_by_substring;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xx""),[""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""]);
  assert.deepEqual(candidate([""grunt"", ""trumpet"", ""prune"", ""gruesome""], ""run""),[""grunt"", ""prune""]);
}

test();"
HumanEval_8,spa_Latn,js,"/ La suma vacía debe ser igual a 0 y el producto vacío debe ser igual a 1. / Para una matriz de enteros dada, devuelve una matriz que consiste en una suma y un producto de todos los enteros en una matriz. // >>> sum_product([])
// [0, 1]
// >>> sum_product([1, 2, 3, 4])
// [10, 24]
function sum_product(numbers){
","function sum_product(numbers) {
    let sum = 0;
    let product = 1;

    for (let i = 0; i < numbers.length; i++) {
        sum += numbers[i];
        product *= numbers[i];
    }

    return [sum, product];
}","const assert = require('node:assert');


function test() {
  let candidate = sum_product;
  assert.deepEqual(candidate([]),[0, 1]);
  assert.deepEqual(candidate([1, 1, 1]),[3, 1]);
  assert.deepEqual(candidate([100, 0]),[100, 0]);
  assert.deepEqual(candidate([3, 5, 7]),[15, 105]);
  assert.deepEqual(candidate([10]),[10, 10]);
}

test();"
HumanEval_9,spa_Latn,js,"- En la secuencia./De una matriz de enteros dada, genera una matriz de elemento máximo rodante encontrado hasta el momento dado // >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
// [1, 2, 3, 3, 3, 4, 4]
function rolling_max(numbers){
","function rolling_max(numbers) {
    let result = [];
    let currentMax = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < numbers.length; i++) {
        currentMax = Math.max(currentMax, numbers[i]);
        result.push(currentMax);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = rolling_max;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 1]),[4, 4, 4, 4]);
  assert.deepEqual(candidate([3, 2, 3, 100, 3]),[3, 3, 3, 100, 100]);
}

test();"
HumanEval_10,spa_Latn,js,"/ - Añadir al final de la cadena inversa de un prefijo de cadena que viene antes del sufijo palindromo. / - Encuentre el postfix más largo de la cadena suministrada que sea un palíndromo. La idea del algoritmo es simple:/Encuentra el palíndromo más corto que comience con una cadena suministrada. // >>> make_palindrome("""")
// """"
// >>> make_palindrome(""cat"")
// ""catac""
// >>> make_palindrome(""cata"")
// ""catac""
function make_palindrome(string){
","function make_palindrome(string) {
    // Helper function to check if a string is a palindrome
    function isPalindrome(s) {
        let left = 0;
        let right = s.length - 1;
        while (left < right) {
            if (s[left] !== s[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    // Find the longest palindromic suffix
    let longestPalindromicSuffixLength = 0;
    for (let i = 0; i < string.length; i++) {
        if (isPalindrome(string.slice(i))) {
            longestPalindromicSuffixLength = string.length - i;
            break;
        }
    }

    // Create the shortest palindrome
    const prefixToReverse = string.slice(0, string.length - longestPalindromicSuffixLength);
    const reversedPrefix = prefixToReverse.split('').reverse().join('');
    return string + reversedPrefix;
}

// Examples
console.log(make_palindrome(""""));     // """"
console.log(make_palindrome(""cat""));  // ""catac""
console.log(make_palindrome(""cata"")); // ""catac""","const assert = require('node:assert');


function test() {
  let candidate = make_palindrome;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""x""),""x"");
  assert.deepEqual(candidate(""xyz""),""xyzyx"");
  assert.deepEqual(candidate(""xyx""),""xyx"");
  assert.deepEqual(candidate(""jerry""),""jerryrrej"");
}

test();"
HumanEval_11,spa_Latn,js,"/ Ejecutar XOR binario en estas entradas y devolver el resultado también como una cadena. /Input son dos cadenas a y b que consisten sólo en 1s y 0s. // >>> string_xor(""010"", ""110"")
// ""100""
function string_xor(a, b){
","function string_xor(a, b) {
    let result = """";
    for (let i = 0; i < a.length; i++) {
        result += (a[i] === b[i]) ? ""0"" : ""1"";
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = string_xor;
  assert.deepEqual(candidate(""111000"", ""101010""),""010010"");
  assert.deepEqual(candidate(""1"", ""1""),""0"");
  assert.deepEqual(candidate(""0101"", ""0000""),""0101"");
}

test();"
HumanEval_12,spa_Latn,js,"/ cadenas de la misma longitud. Devuelve indefinido en caso de que la matriz de entrada esté vacía. / Fuera de la matriz de cadenas, devuelve la más larga. devuelve la primera en caso de múltiples // >>> longest([])
// undefined
// >>> longest([""a"", ""b"", ""c""])
// ""a""
// >>> longest([""a"", ""bb"", ""ccc""])
// ""ccc""
function longest(strings){
","function longest(strings) {
    if (strings.length === 0) return undefined;
    let longestString = strings[0];

    for (let i = 1; i < strings.length; i++) {
        if (strings[i].length > longestString.length) {
            longestString = strings[i];
        }
    }

    return longestString;
}","const assert = require('node:assert');


function test() {
  let candidate = longest;
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""x"");
  assert.deepEqual(candidate([""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""]),""zzzz"");
}

test();"
HumanEval_13,spa_Latn,js,"/Devuelve un mayor común divisor de dos enteros a y b // >>> greatest_common_divisor(3, 5)
// 1
// >>> greatest_common_divisor(25, 15)
// 5
function greatest_common_divisor(a, b){
","function greatest_common_divisor(a, b) {
    while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}","const assert = require('node:assert');


function test() {
  let candidate = greatest_common_divisor;
  assert.deepEqual(candidate(3, 7),1);
  assert.deepEqual(candidate(10, 15),5);
  assert.deepEqual(candidate(49, 14),7);
  assert.deepEqual(candidate(144, 60),12);
}

test();"
HumanEval_14,spa_Latn,js,"/Return array de todos los prefijos de más corto a más largo de la cadena de entrada // >>> all_prefixes(""abc"")
// [""a"", ""ab"", ""abc""]
function all_prefixes(string){
","function all_prefixes(string) {
    let prefixes = [];
    for (let i = 1; i <= string.length; i++) {
        prefixes.push(string.substring(0, i));
    }
    return prefixes;
}","const assert = require('node:assert');


function test() {
  let candidate = all_prefixes;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""asdfgh""),[""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""]);
  assert.deepEqual(candidate(""WWW""),[""W"", ""WW"", ""WWW""]);
}

test();"
HumanEval_15,spa_Latn,js,"/Devuelve una cadena que contiene números delimitados por espacio que comienzan desde 0 hasta n inclusive. // >>> string_sequence(0)
// ""0""
// >>> string_sequence(5)
// ""0 1 2 3 4 5""
function string_sequence(n){
","function string_sequence(n) {
    let result = [];
    for (let i = 0; i <= n; i++) {
        result.push(i);
    }
    return result.join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = string_sequence;
  assert.deepEqual(candidate(0),""0"");
  assert.deepEqual(candidate(3),""0 1 2 3"");
  assert.deepEqual(candidate(10),""0 1 2 3 4 5 6 7 8 9 10"");
}

test();"
HumanEval_16,spa_Latn,js,"/Dada una cadena, averigua de cuántos caracteres distintos (independientemente de la casilla) se compone // >>> count_distinct_characters(""xyzXYZ"")
// 3
// >>> count_distinct_characters(""Jerry"")
// 4
function count_distinct_characters(string){
","function count_distinct_characters(string) {
    // Convert the string to lowercase to ignore case differences
    const lowercaseString = string.toLowerCase();
    // Create a Set to store distinct characters
    const distinctChars = new Set();
    // Iterate over each character in the string
    for (let char of lowercaseString) {
        distinctChars.add(char); // Add character to the set
    }
    // Return the size of the set which represents the number of distinct characters
    return distinctChars.size;
}","const assert = require('node:assert');


function test() {
  let candidate = count_distinct_characters;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abcde""),5);
  assert.deepEqual(candidate(""abcdecadeCADE""),5);
  assert.deepEqual(candidate(""aaaaAAAAaaaa""),1);
  assert.deepEqual(candidate(""Jerry jERRY JeRRRY""),5);
}

test();"
HumanEval_17,spa_Latn,js,"""Hacía"" - nota de cuarto, dura un latido.""O"" hace media nota, dura dos tiempos./ 'O' - nota entera, tiene cuatro tiempos Aquí hay una leyenda:- No el último./ Su tarea es analizar esta cadena y devolver una matriz de enteros correspondientes a cuántos latidos hace cada uno /La entrada de esta función es una cadena que representa notas musicales en un formato ASCII especial. // >>> parse_music(""o o| .| o| o| .| .| .| .| o o"")
// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
function parse_music(music_string){
","function parse_music(music_string) {
    let notes = music_string.split("" "");
    let beats = [];

    for (let note of notes) {
        switch (note) {
            case 'o':
                beats.push(4);
                break;
            case 'o|':
                beats.push(2);
                break;
            case '.|':
                beats.push(1);
                break;
            default:
                // Handle unexpected notes if necessary
                break;
        }
    }
    return beats;
}

// Example usage:
// console.log(parse_music(""o o| .| o| o| .| .| .| .| o o"")); 
// Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]","const assert = require('node:assert');


function test() {
  let candidate = parse_music;
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""o o o o""),[4, 4, 4, 4]);
  assert.deepEqual(candidate("".| .| .| .|""),[1, 1, 1, 1]);
  assert.deepEqual(candidate(""o| o| .| .| o o o o""),[2, 2, 1, 1, 4, 4, 4, 4]);
  assert.deepEqual(candidate(""o| .| o| .| o o| o o|""),[2, 1, 2, 1, 4, 2, 4, 2]);
}

test();"
HumanEval_18,spa_Latn,js,"/Encuentra cuántas veces se puede encontrar una subcadena dada en la cadena original. Cuenta los casos superpuestos. // >>> how_many_times("""", ""a"")
// 0
// >>> how_many_times(""aaa"", ""a"")
// 3
// >>> how_many_times(""aaaa"", ""aa"")
// 3
function how_many_times(string, substring){
","function how_many_times(string, substring) {
  if (substring.length === 0) return 0;
  
  let count = 0;
  let position = 0;
  
  while ((position = string.indexOf(substring, position)) !== -1) {
    count++;
    position++;
  }
  
  return count;
}","const assert = require('node:assert');


function test() {
  let candidate = how_many_times;
  assert.deepEqual(candidate("""", ""x""),0);
  assert.deepEqual(candidate(""xyxyxyx"", ""x""),4);
  assert.deepEqual(candidate(""cacacacac"", ""cac""),4);
  assert.deepEqual(candidate(""john doe"", ""john""),1);
}

test();"
HumanEval_19,spa_Latn,js,"/ Devuelve la cadena con los números ordenados de menor a mayor / Las opciones válidas son cero, uno, dos, tres, cuatro, cinco, seis, siete, ocho y nueve. /La entrada es una cadena de números delimitada por espacio desde el ""cero"" hasta el ""nueve"".// >>> sort_numbers(""three one five"")
// ""one three five""
function sort_numbers(numbers){
","function sort_numbers(numbers) {
    const numberWords = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
    
    return numbers
        .split(' ')
        .sort((a, b) => numberWords.indexOf(a) - numberWords.indexOf(b))
        .join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = sort_numbers;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""three""),""three"");
  assert.deepEqual(candidate(""three five nine""),""three five nine"");
  assert.deepEqual(candidate(""five zero four seven nine eight""),""zero four five seven eight nine"");
  assert.deepEqual(candidate(""six five four three two one zero""),""zero one two three four five six"");
}

test();"
HumanEval_20,spa_Latn,js,"/ otros y los devuelve por orden (menor número, mayor número)./De una matriz de números suministrada (de longitud al menos dos) seleccione y devuelva dos que estén más cerca de cada uno // >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
// [2.0, 2.2]
// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
// [2.0, 2.0]
function find_closest_elements(numbers){
","function find_closest_elements(numbers) {
    if (numbers.length < 2) {
        throw new Error('Array must contain at least two elements.');
    }
    
    numbers.sort((a, b) => a - b);

    let minDiff = Infinity;
    let closestPair = [numbers[0], numbers[1]];

    for (let i = 0; i < numbers.length - 1; i++) {
        let diff = numbers[i + 1] - numbers[i];
        if (diff < minDiff) {
            minDiff = diff;
            closestPair = [numbers[i], numbers[i + 1]];
        }
    }

    return closestPair;
}","const assert = require('node:assert');


function test() {
  let candidate = find_closest_elements;
  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);
  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0, 5.9]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);
  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);
}

test();"
HumanEval_21,spa_Latn,js,"/ de tal manera que el número más pequeño se convertirá en 0 y el más grande se convertirá en 1 /Dada una matriz de números (de al menos dos elementos), aplique una transformación lineal a esa matriz, // >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
// [0.0, 0.25, 0.5, 0.75, 1.0]
function rescale_to_unit(numbers){
","function rescale_to_unit(numbers) {
    if (numbers.length < 2) {
        throw new Error(""Array must contain at least two elements."");
    }
    
    let min = Math.min(...numbers);
    let max = Math.max(...numbers);
    
    return numbers.map(num => (num - min) / (max - min));
}

// Example usage
console.log(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])); // [0.0, 0.25, 0.5, 0.75, 1.0]","const assert = require('node:assert');


function test() {
  let candidate = rescale_to_unit;
  assert.deepEqual(candidate([2.0, 49.9]),[0.0, 1.0]);
  assert.deepEqual(candidate([100.0, 49.9]),[1.0, 0.0]);
  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5, 0.75, 1.0]);
  assert.deepEqual(candidate([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
  assert.deepEqual(candidate([12.0, 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75]);
}

test();"
HumanEval_22,spa_Latn,js,"/Filtrar dado matriz de cualquier jsthon valores sólo para enteros // >>> filter_integers([""a"", 3.14, 5])
// [5]
// >>> filter_integers([1, 2, 3, ""abc"", {}, []])
// [1, 2, 3]
function filter_integers(values){
","function filter_integers(values) {
    return values.filter(value => Number.isInteger(value));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_integers;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([4, {}, [], 23.2, 9, ""adasd""]),[4, 9]);
  assert.deepEqual(candidate([3, ""c"", 3, 3, ""a"", ""b""]),[3, 3, 3]);
}

test();"
HumanEval_23,spa_Latn,js,"/Devuelve la longitud de la cadena dada // >>> strlen("""")
// 0
// >>> strlen(""abc"")
// 3
function strlen(string){
","function strlen(string) {
    return string.length;
}","const assert = require('node:assert');


function test() {
  let candidate = strlen;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""x""),1);
  assert.deepEqual(candidate(""asdasnakj""),9);
}

test();"
HumanEval_24,spa_Latn,js,"/ Para un número dado n, encuentre el número más grande que divide n de manera uniforme, más pequeño que n // >>> largest_divisor(15)
// 5
function largest_divisor(n){
","function largest_divisor(n) {
    for (let i = n - 1; i > 0; i--) {
        if (n % i === 0) {
            return i;
        }
    }
    return 1; // for the edge case where n is 1
}","const assert = require('node:assert');


function test() {
  let candidate = largest_divisor;
  assert.deepEqual(candidate(3),1);
  assert.deepEqual(candidate(7),1);
  assert.deepEqual(candidate(10),5);
  assert.deepEqual(candidate(100),50);
  assert.deepEqual(candidate(49),7);
}

test();"
HumanEval_25,spa_Latn,js,"/ El número de entrada debe ser igual al producto de todos los factores / Cada uno de los factores debe ser ordenado número de veces correspondiente a cuántas veces aparece en la factorización. /Devuelve una matriz de factores primos de un número entero dado en orden de menor a mayor. // >>> factorize(8)
// [2, 2, 2]
// >>> factorize(25)
// [5, 5]
// >>> factorize(70)
// [2, 5, 7]
function factorize(n){
","function factorize(n) {
    const factors = [];
    let divisor = 2;

    while (n >= 2) {
        if (n % divisor === 0) {
            factors.push(divisor);
            n /= divisor;
        } else {
            divisor++;
        }
    }

    return factors;
}","const assert = require('node:assert');


function test() {
  let candidate = factorize;
  assert.deepEqual(candidate(2),[2]);
  assert.deepEqual(candidate(4),[2, 2]);
  assert.deepEqual(candidate(8),[2, 2, 2]);
  assert.deepEqual(candidate(57),[3, 19]);
  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);
  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);
  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);
  assert.deepEqual(candidate(18),[2, 3, 3]);
}

test();"
HumanEval_26,spa_Latn,js,"/ Mantenga el orden de los elementos de la izquierda igual que en la entrada. / De una matriz de enteros, elimine todos los elementos que ocurren más de una vez. // >>> remove_duplicates([1, 2, 3, 2, 4])
// [1, 3, 4]
function remove_duplicates(numbers){
","function remove_duplicates(numbers) {
    const frequency = {};
    // Count occurrences of each number
    numbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });

    // Filter out numbers that occur more than once
    return numbers.filter(num => frequency[num] === 1);
}","const assert = require('node:assert');


function test() {
  let candidate = remove_duplicates;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 2, 3, 4]);
  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1, 4, 5]);
}

test();"
HumanEval_27,spa_Latn,js,"/Para una cadena dada, cambie los caracteres minúsculos a mayúsculas y mayúsculas a minúsculas. // >>> flip_case(""Hello"")
// ""hELLO""
function flip_case(string){
","function flip_case(string) {
    let flippedString = '';
    for (let i = 0; i < string.length; i++) {
        const char = string[i];
        if (char === char.toLowerCase()) {
            flippedString += char.toUpperCase();
        } else {
            flippedString += char.toLowerCase();
        }
    }
    return flippedString;
}","const assert = require('node:assert');


function test() {
  let candidate = flip_case;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hello!""),""hELLO!"");
  assert.deepEqual(candidate(""These violent delights have violent ends""),""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"");
}

test();"
HumanEval_28,spa_Latn,js,"/Concatenate matriz de cadenas en una sola cadena // >>> concatenate([])
// """"
// >>> concatenate([""a"", ""b"", ""c""])
// ""abc""
function concatenate(strings){
","function concatenate(strings) {
    return strings.join('');
}","const assert = require('node:assert');


function test() {
  let candidate = concatenate;
  assert.deepEqual(candidate([]),"""");
  assert.deepEqual(candidate([""x"", ""y"", ""z""]),""xyz"");
  assert.deepEqual(candidate([""x"", ""y"", ""z"", ""w"", ""k""]),""xyzwk"");
}

test();"
HumanEval_29,spa_Latn,js,"/Filtrar una matriz de entrada de cadenas sólo para los que comienzan con un prefijo dado. // >>> filter_by_prefix([], ""a"")
// []
// >>> filter_by_prefix([""abc"", ""bcd"", ""cde"", ""array""], ""a"")
// [""abc"", ""array""]
function filter_by_prefix(strings, prefix){
","function filter_by_prefix(strings, prefix) {
    return strings.filter(str => str.startsWith(prefix));
}","const assert = require('node:assert');


function test() {
  let candidate = filter_by_prefix;
  assert.deepEqual(candidate([], ""john""),[]);
  assert.deepEqual(candidate([""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx""], ""xxx""),[""xxx"", ""xxxAAA"", ""xxx""]);
}

test();"
HumanEval_30,spa_Latn,js,"/Devuelve sólo los números positivos en la matriz. // >>> get_positive([-1, 2, -4, 5, 6])
// [2, 5, 6]
// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// [5, 3, 2, 3, 9, 123, 1]
function get_positive(l){
","function get_positive(l) {
    return l.filter(function(num) {
        return num > 0;
    });
}","const assert = require('node:assert');


function test() {
  let candidate = get_positive;
  assert.deepEqual(candidate([-1, -2, 4, 5, 6]),[4, 5, 6]);
  assert.deepEqual(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1]);
  assert.deepEqual(candidate([-1, -2]),[]);
  assert.deepEqual(candidate([]),[]);
}

test();"
HumanEval_31,spa_Latn,js,"/Devuelve verdad si un número dado es primo, y falso de lo contrario. // >>> is_prime(6)
// false
// >>> is_prime(101)
// true
// >>> is_prime(11)
// true
// >>> is_prime(13441)
// true
// >>> is_prime(61)
// true
// >>> is_prime(4)
// false
// >>> is_prime(1)
// false
function is_prime(n){
","function is_prime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
  
    if (n % 2 === 0 || n % 3 === 0) return false;
  
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
  
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_prime;
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(101),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(13441),true);
  assert.deepEqual(candidate(61),true);
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(1),false);
  assert.deepEqual(candidate(5),true);
  assert.deepEqual(candidate(11),true);
  assert.deepEqual(candidate(17),true);
  assert.deepEqual(candidate(85),false);
  assert.deepEqual(candidate(77),false);
  assert.deepEqual(candidate(255379),false);
}

test();"
HumanEval_33,spa_Latn,js,"/ a los valores de los índices correspondientes de l, pero ordenados./ l' es idéntico a l en los índices que no son divisible por tres, mientras que sus valores en los índices que son divisible por tres son iguales /Esta función toma un array l y devuelve un array l' tal que // >>> sort_third([1, 2, 3])
// [1, 2, 3]
// >>> sort_third([5, 6, 3, 4, 8, 9, 2])
// [2, 6, 3, 4, 8, 9, 5]
function sort_third(l){
","function sort_third(l) {
    // Extract the elements at indices divisible by 3
    const elementsToSort = [];
    for (let i = 0; i < l.length; i++) {
        if (i % 3 === 0) {
            elementsToSort.push(l[i]);
        }
    }
    
    // Sort the extracted elements
    elementsToSort.sort((a, b) => a - b);

    // Place the sorted elements back into their original positions
    let sortedIndex = 0;
    for (let i = 0; i < l.length; i++) {
        if (i % 3 === 0) {
            l[i] = elementsToSort[sortedIndex++];
        }
    }
    
    return l;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_third;
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2]),[2, 6, 3, 4, 8, 9, 5]);
  assert.deepEqual(candidate([5, 8, 3, 4, 6, 9, 2]),[2, 8, 3, 4, 6, 9, 5]);
  assert.deepEqual(candidate([5, 6, 9, 4, 8, 3, 2]),[2, 6, 9, 4, 8, 3, 5]);
  assert.deepEqual(candidate([5, 6, 3, 4, 8, 9, 2, 1]),[2, 6, 3, 4, 8, 9, 5, 1]);
}

test();"
HumanEval_34,spa_Latn,js,"/Devuelve elementos únicos ordenados en una matriz // >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [0, 2, 3, 5, 9, 123]
function unique(l){
","function unique(l) {
    // Use a Set to remove duplicates and then spread into an array
    const uniqueElements = [...new Set(l)];
    // Sort the array in ascending order
    uniqueElements.sort((a, b) => a - b);
    return uniqueElements;
}","const assert = require('node:assert');


function test() {
  let candidate = unique;
  assert.deepEqual(candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);
}

test();"
HumanEval_35,spa_Latn,js,"/Devuelve el elemento máximo en el array. // >>> max_element([1, 2, 3])
// 3
// >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
// 123
function max_element(l){
","function max_element(l) {
    if (l.length === 0) return undefined; // Return undefined if the array is empty
    return Math.max(...l);
}","const assert = require('node:assert');


function test() {
  let candidate = max_element;
  assert.deepEqual(candidate([1, 2, 3]),3);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]),124);
}

test();"
HumanEval_36,spa_Latn,js,"/Devuelve el número de veces que aparece el dígito 7 en enteros menores que n que son divisible por 11 o 13. // >>> fizz_buzz(50)
// 0
// >>> fizz_buzz(78)
// 2
// >>> fizz_buzz(79)
// 3
function fizz_buzz(n){
","function fizz_buzz(n) {
    let count = 0;
    
    for (let i = 1; i < n; i++) {
        if (i % 11 === 0 || i % 13 === 0) {
            let numStr = i.toString();
            for (let char of numStr) {
                if (char === '7') {
                    count++;
                }
            }
        }
    }
    
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = fizz_buzz;
  assert.deepEqual(candidate(50),0);
  assert.deepEqual(candidate(78),2);
  assert.deepEqual(candidate(79),3);
  assert.deepEqual(candidate(100),3);
  assert.deepEqual(candidate(200),6);
  assert.deepEqual(candidate(4000),192);
  assert.deepEqual(candidate(10000),639);
  assert.deepEqual(candidate(100000),8026);
}

test();"
HumanEval_37,spa_Latn,js,"/ a los valores de los índices pares de l, pero ordenados. / l' es idéntico a l en los índices impares, mientras que sus valores en los índices pares son iguales /Esta función toma un array l y devuelve un array l' tal que // >>> sort_even([1, 2, 3])
// [1, 2, 3]
// >>> sort_even([5, 6, 3, 4])
// [3, 6, 5, 4]
function sort_even(l){
","function sort_even(l) {
    // Extract the elements at even indices
    let evenElements = [];
    for (let i = 0; i < l.length; i += 2) {
        evenElements.push(l[i]);
    }

    // Sort the even elements
    evenElements.sort((a, b) => a - b);

    // Reconstruct the array with sorted even indices
    let result = [];
    let evenIndex = 0;
    for (let i = 0; i < l.length; i++) {
        if (i % 2 === 0) {
            result.push(evenElements[evenIndex]);
            evenIndex++;
        } else {
            result.push(l[i]);
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_even;
  assert.deepEqual(candidate([1, 2, 3]),[1, 2, 3]);
  assert.deepEqual(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);
  assert.deepEqual(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);
}

test();"
HumanEval_39,spa_Latn,js,"/prime_fib devuelve el n-ésimo número que es un número de Fibonacci y también es primo. // >>> prime_fib(1)
// 2
// >>> prime_fib(2)
// 3
// >>> prime_fib(3)
// 5
// >>> prime_fib(4)
// 13
// >>> prime_fib(5)
// 89
function prime_fib(n){
","function prime_fib(n) {
    function isPrime(num) {
        if (num < 2) return false;
        for (let i = 2; i * i <= num; i++) {
            if (num % i === 0) return false;
        }
        return true;
    }
    
    function fibonacci() {
        let a = 0, b = 1;
        return function() {
            const next = a + b;
            a = b;
            b = next;
            return a;
        };
    }

    const fib = fibonacci();
    let count = 0;
    let primeFibNum;

    while (count < n) {
        const fibNum = fib();
        if (isPrime(fibNum)) {
            count++;
            primeFibNum = fibNum;
        }
    }

    return primeFibNum;
}","const assert = require('node:assert');


function test() {
  let candidate = prime_fib;
  assert.deepEqual(candidate(1),2);
  assert.deepEqual(candidate(2),3);
  assert.deepEqual(candidate(3),5);
  assert.deepEqual(candidate(4),13);
  assert.deepEqual(candidate(5),89);
  assert.deepEqual(candidate(6),233);
  assert.deepEqual(candidate(7),1597);
  assert.deepEqual(candidate(8),28657);
  assert.deepEqual(candidate(9),514229);
  assert.deepEqual(candidate(10),433494437);
}

test();"
HumanEval_40,spa_Latn,js,"/ suma a cero, y falso de lo contrario. / devuelve verdad si hay tres elementos distintos en el array que /triple_sum_to_zero toma una matriz de enteros como entrada.// >>> triples_sum_to_zero([1, 3, 5, 0])
// false
// >>> triples_sum_to_zero([1, 3, -2, 1])
// true
// >>> triples_sum_to_zero([1, 2, 3, 7])
// false
// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
// true
// >>> triples_sum_to_zero([1])
// false
function triples_sum_to_zero(l){
","function triples_sum_to_zero(l) {
    // Sort the array first
    l.sort((a, b) => a - b);
    // Iterate through each element in the array
    for (let i = 0; i < l.length - 2; i++) {
        // Use two pointers to find the other two elements
        let left = i + 1;
        let right = l.length - 1;
        while (left < right) {
            const sum = l[i] + l[left] + l[right];
            if (sum === 0) {
                return true;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = triples_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, 5, -1]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),true);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([1, 2, 5, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 9, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([1, 3, 5, -100]),false);
  assert.deepEqual(candidate([100, 3, 5, -100]),false);
}

test();"
HumanEval_41,spa_Latn,js,"/ Esta función produce el número de estas colisiones. / en su trayectoria como si no chocaran. Sin embargo, los coches son infinitamente robustos y fuertes; como resultado, continúan moviéndose./ Cuando un coche que se mueve de izquierda a derecha golpea a un coche que se mueve de derecha a izquierda. Todos los coches se mueven a la misma velocidad.Los dos pares de coches comienzan a estar muy lejos de la carretera./ n coches están conduciendo de izquierda a derecha; simultáneamente, un conjunto diferente de n coches Imagina una carretera que es una línea perfectamente recta de longitud infinita.function car_race_collision(n){
","function car_race_collision(n) {
    // Each car moving left to right will collide with each car moving right to left exactly once.
    // Therefore, the number of collisions is n * n.
    return n * n;
}","const assert = require('node:assert');


function test() {
  let candidate = car_race_collision;
  assert.deepEqual(candidate(2),4);
  assert.deepEqual(candidate(3),9);
  assert.deepEqual(candidate(4),16);
  assert.deepEqual(candidate(8),64);
  assert.deepEqual(candidate(10),100);
}

test();"
HumanEval_42,spa_Latn,js,"/Return array con elementos incrementados por 1. // >>> incr_list([1, 2, 3])
// [2, 3, 4]
// >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
// [6, 4, 6, 3, 4, 4, 10, 1, 124]
function incr_list(l){
","function incr_list(l) {
    return l.map(element => element + 1);
}","const assert = require('node:assert');


function test() {
  let candidate = incr_list;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([3, 2, 1]),[4, 3, 2]);
  assert.deepEqual(candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]),[6, 3, 6, 3, 4, 4, 10, 1, 124]);
}

test();"
HumanEval_43,spa_Latn,js,"/ suma a cero, y falso de lo contrario. / devuelve verdad si hay dos elementos distintos en el array que /pairs_sum_to_zero toma una matriz de enteros como una entrada.// >>> pairs_sum_to_zero([1, 3, 5, 0])
// false
// >>> pairs_sum_to_zero([1, 3, -2, 1])
// false
// >>> pairs_sum_to_zero([1, 2, 3, 7])
// false
// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
// true
// >>> pairs_sum_to_zero([1])
// false
function pairs_sum_to_zero(l){
","function pairs_sum_to_zero(l) {
    const seen = new Set();
    
    for (const num of l) {
        if (seen.has(-num)) {
            return true;
        }
        seen.add(num);
    }
    
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = pairs_sum_to_zero;
  assert.deepEqual(candidate([1, 3, 5, 0]),false);
  assert.deepEqual(candidate([1, 3, -2, 1]),false);
  assert.deepEqual(candidate([1, 2, 3, 7]),false);
  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);
  assert.deepEqual(candidate([1]),false);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 30]),true);
  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);
  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 31]),false);
}

test();"
HumanEval_44,spa_Latn,js,"/ los números de base son menores a 10. / regresa la representación de la cadena después de la conversión. /Cambiar la base numérica del número de entrada x a la base. // >>> change_base(8, 3)
// ""22""
// >>> change_base(8, 2)
// ""1000""
// >>> change_base(7, 2)
// ""111""
function change_base(x, base){
","function change_base(x, base) {
    if (base < 2 || base > 9) {
        throw new Error(""Base must be between 2 and 9."");
    }

    if (x === 0) {
        return ""0"";
    }

    let result = '';
    while (x > 0) {
        result = (x % base) + result;
        x = Math.floor(x / base);
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = change_base;
  assert.deepEqual(candidate(8, 3),""22"");
  assert.deepEqual(candidate(9, 3),""100"");
  assert.deepEqual(candidate(234, 2),""11101010"");
  assert.deepEqual(candidate(16, 2),""10000"");
  assert.deepEqual(candidate(8, 2),""1000"");
  assert.deepEqual(candidate(7, 2),""111"");
  assert.deepEqual(candidate(2, 3),""2"");
  assert.deepEqual(candidate(3, 4),""3"");
  assert.deepEqual(candidate(4, 5),""4"");
  assert.deepEqual(candidate(5, 6),""5"");
  assert.deepEqual(candidate(6, 7),""6"");
  assert.deepEqual(candidate(7, 8),""7"");
}

test();"
HumanEval_45,spa_Latn,js,"/Dada la longitud de un lado y el área de retorno alto para un triángulo. // >>> triangle_area(5, 3)
// 7.5
function triangle_area(a, h){
","function triangle_area(a, h) {
    return 0.5 * a * h;
}","const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(5, 3),7.5);
  assert.deepEqual(candidate(2, 2),2.0);
  assert.deepEqual(candidate(10, 8),40.0);
}

test();"
HumanEval_46,spa_Latn,js,"/ Por favor escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números fib4. No use la recursión. / fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). / fib4(3) -> 0 / fib4(2) -> 2 / fib4(1) -> 0 / fib4(0) -> 0 /La secuencia numérica Fib4 es una secuencia similar a la secuencia de Fibbonacci que se define de la siguiente manera: // >>> fib4(5)
// 4
// >>> fib4(6)
// 8
// >>> fib4(7)
// 14
function fib4(n){
","function fib4(n) {
    if (n === 0) return 0;
    if (n === 1) return 0;
    if (n === 2) return 2;
    if (n === 3) return 0;
    
    let fibs = [0, 0, 2, 0];
    
    for (let i = 4; i <= n; i++) {
        let nextFib = fibs[0] + fibs[1] + fibs[2] + fibs[3];
        fibs.shift(); // Remove the first element
        fibs.push(nextFib); // Add the new element to the end
    }
    
    return fibs[3];
}","const assert = require('node:assert');


function test() {
  let candidate = fib4;
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),28);
  assert.deepEqual(candidate(10),104);
  assert.deepEqual(candidate(12),386);
}

test();"
HumanEval_47,spa_Latn,js,"/Devuelve la mediana de los elementos en la matriz l. // >>> median([3, 1, 2, 4, 5])
// 3
// >>> median([-10, 4, 6, 1000, 10, 20])
// 15.0
function median(l){
","function median(l) {
    // First, sort the array
    l.sort((a, b) => a - b);

    // Calculate the middle index
    const mid = Math.floor(l.length / 2);

    // If array length is odd, return the middle element
    if (l.length % 2 !== 0) {
        return l[mid];
    }
    // If array length is even, return the average of the two middle elements
    else {
        return (l[mid - 1] + l[mid]) / 2;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = median;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),3);
  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);
  assert.deepEqual(candidate([5]),5);
  assert.deepEqual(candidate([6, 5]),5.5);
  assert.deepEqual(candidate([8, 1, 3, 9, 9, 2, 7]),7);
}

test();"
HumanEval_48,spa_Latn,js,"/ Comprueba si la cadena dada es un palíndromo // >>> is_palindrome("""")
// true
// >>> is_palindrome(""aba"")
// true
// >>> is_palindrome(""aaaaa"")
// true
// >>> is_palindrome(""zbcd"")
// false
function is_palindrome(text){
","function is_palindrome(text){
    // Remove non-alphanumeric characters and convert to lower case
    const cleanedText = text.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    // Reverse the cleaned text
    const reversedText = cleanedText.split('').reverse().join('');
    // Check if the cleaned text is equal to its reverse
    return cleanedText === reversedText;
}","const assert = require('node:assert');


function test() {
  let candidate = is_palindrome;
  assert.deepEqual(candidate(""""),true);
  assert.deepEqual(candidate(""aba""),true);
  assert.deepEqual(candidate(""aaaaa""),true);
  assert.deepEqual(candidate(""zbcd""),false);
  assert.deepEqual(candidate(""xywyx""),true);
  assert.deepEqual(candidate(""xywyz""),false);
  assert.deepEqual(candidate(""xywzx""),false);
}

test();"
HumanEval_49,spa_Latn,js,"/Devuelve 2^n módulo p (tenga en cuenta los números).// >>> modp(3, 5)
// 3
// >>> modp(1101, 101)
// 2
// >>> modp(0, 101)
// 1
// >>> modp(3, 11)
// 8
// >>> modp(100, 101)
// 1
function modp(n, p){
","function modp(n, p) {
    if (p === 1) return 0; // Base case when p is 1

    // Initialize result
    let result = 1;
    let base = 2;

    while (n > 0) {
        // If n is odd, multiply base with result
        if (n % 2 === 1) {
            result = (result * base) % p;
        }

        // n must be even now
        n = Math.floor(n / 2);
        base = (base * base) % p; 
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = modp;
  assert.deepEqual(candidate(3, 5),3);
  assert.deepEqual(candidate(1101, 101),2);
  assert.deepEqual(candidate(0, 101),1);
  assert.deepEqual(candidate(3, 11),8);
  assert.deepEqual(candidate(100, 101),1);
  assert.deepEqual(candidate(30, 5),4);
  assert.deepEqual(candidate(31, 5),3);
}

test();"
HumanEval_51,spa_Latn,js,"/remove_vowels es una función que toma cadena y devuelve cadena sin vocales. // >>> remove_vowels("""")
// """"
// >>> remove_vowels(""abcdef"")
// ""bcdf""
// >>> remove_vowels(""aaaaa"")
// """"
// >>> remove_vowels(""aaBAA"")
// ""B""
// >>> remove_vowels(""zbcd"")
// ""zbcd""
function remove_vowels(text){
","function remove_vowels(text) {
    return text.replace(/[aeiouAEIOU]/g, '');
}","const assert = require('node:assert');


function test() {
  let candidate = remove_vowels;
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""abcdef
ghijklm""),""bcdf
ghjklm"");
  assert.deepEqual(candidate(""fedcba""),""fdcb"");
  assert.deepEqual(candidate(""eeeee""),"""");
  assert.deepEqual(candidate(""acBAA""),""cB"");
  assert.deepEqual(candidate(""EcBOO""),""cB"");
  assert.deepEqual(candidate(""ybcd""),""ybcd"");
}

test();"
HumanEval_52,spa_Latn,js,"/Devuelve true si todos los números en la matriz l están por debajo del umbral t. // >>> below_threshold([1, 2, 4, 10], 100)
// true
// >>> below_threshold([1, 20, 4, 10], 5)
// false
function below_threshold(l, t){
","function below_threshold(l, t) {
    return l.every(num => num < t);
}","const assert = require('node:assert');


function test() {
  let candidate = below_threshold;
  assert.deepEqual(candidate([1, 2, 4, 10], 100),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 5),false);
  assert.deepEqual(candidate([1, 20, 4, 10], 21),true);
  assert.deepEqual(candidate([1, 20, 4, 10], 22),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 11),true);
  assert.deepEqual(candidate([1, 8, 4, 10], 10),false);
}

test();"
HumanEval_53,spa_Latn,js,"/Añade dos números x y y // >>> add(2, 3)
// 5
// >>> add(5, 7)
// 12
function add(x, y){
","function add(x, y) {
    return x + y;
}","const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate(0, 1),1);
  assert.deepEqual(candidate(1, 0),1);
  assert.deepEqual(candidate(2, 3),5);
  assert.deepEqual(candidate(5, 7),12);
  assert.deepEqual(candidate(7, 5),12);
}

test();"
HumanEval_54,spa_Latn,js,"/Comprueba si dos palabras tienen los mismos caracteres. // >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddeddabc"")
// true
// >>> same_chars(""abcd"", ""dddddddabc"")
// true
// >>> same_chars(""dddddddabc"", ""abcd"")
// true
// >>> same_chars(""eabcd"", ""dddddddabc"")
// false
// >>> same_chars(""abcd"", ""dddddddabce"")
// false
// >>> same_chars(""eabcdzzzz"", ""dddzzzzzzzddddabc"")
// false
function same_chars(s0, s1){
","function same_chars(s0, s1) {
    const charSet0 = new Set(s0);
    const charSet1 = new Set(s1);

    if (charSet0.size !== charSet1.size) return false;

    for (let char of charSet0) {
        if (!charSet1.has(char)) return false;
    }

    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = same_chars;
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddeddabc""),true);
  assert.deepEqual(candidate(""abcd"", ""dddddddabc""),true);
  assert.deepEqual(candidate(""dddddddabc"", ""abcd""),true);
  assert.deepEqual(candidate(""eabcd"", ""dddddddabc""),false);
  assert.deepEqual(candidate(""abcd"", ""dddddddabcf""),false);
  assert.deepEqual(candidate(""eabcdzzzz"", ""dddzzzzzzzddddabc""),false);
  assert.deepEqual(candidate(""aabb"", ""aaccc""),false);
}

test();"
HumanEval_55,spa_Latn,js,"Devuelve el número n de Fibonacci.// >>> fib(10)
// 55
// >>> fib(1)
// 1
// >>> fib(8)
// 21
function fib(n){
","function fib(n) {
    if (n <= 1) return n;
    let a = 0, b = 1, result = 1;
    for (let i = 2; i <= n; i++) {
        result = a + b;
        a = b;
        b = result;
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = fib;
  assert.deepEqual(candidate(10),55);
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(8),21);
  assert.deepEqual(candidate(11),89);
  assert.deepEqual(candidate(12),144);
}

test();"
HumanEval_56,spa_Latn,js,"/ devuelve verdad si cada bracket de apertura tiene un bracket de cierre correspondiente. /brackets es una cadena de ""<"" y "">"". // >>> correct_bracketing(""<"")
// false
// >>> correct_bracketing(""<>"")
// true
// >>> correct_bracketing(""<<><>>"")
// true
// >>> correct_bracketing(""><<>"")
// false
function correct_bracketing(brackets){
","function correct_bracketing(brackets) {
    let balance = 0;
    for (let char of brackets) {
        if (char === '<') {
            balance += 1;
        } else if (char === '>') {
            balance -= 1;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""<>""),true);
  assert.deepEqual(candidate(""<<><>>""),true);
  assert.deepEqual(candidate(""<><><<><>><>""),true);
  assert.deepEqual(candidate(""<><><<<><><>><>><<><><<>>>""),true);
  assert.deepEqual(candidate(""<<<><>>>>""),false);
  assert.deepEqual(candidate(""><<>""),false);
  assert.deepEqual(candidate(""<""),false);
  assert.deepEqual(candidate(""<<<<""),false);
  assert.deepEqual(candidate("">""),false);
  assert.deepEqual(candidate(""<<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>><<>""),false);
  assert.deepEqual(candidate(""<><><<><>><>>><>""),false);
}

test();"
HumanEval_57,spa_Latn,js,"/Devuelve verdad si los elementos del array están aumentando o disminuyendo monotónicamente. // >>> monotonic([1, 2, 4, 20])
// true
// >>> monotonic([1, 20, 4, 10])
// false
// >>> monotonic([4, 1, 0, -10])
// true
function monotonic(l){
","function monotonic(l) {
    if (l.length <= 1) return true;
    let isIncreasing = true;
    let isDecreasing = true;
    
    for (let i = 1; i < l.length; i++) {
        if (l[i] > l[i - 1]) {
            isDecreasing = false;
        } else if (l[i] < l[i - 1]) {
            isIncreasing = false;
        }
        
        if (!isIncreasing && !isDecreasing) return false;
    }
    
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = monotonic;
  assert.deepEqual(candidate([1, 2, 4, 10]),true);
  assert.deepEqual(candidate([1, 2, 4, 20]),true);
  assert.deepEqual(candidate([1, 20, 4, 10]),false);
  assert.deepEqual(candidate([4, 1, 0, -10]),true);
  assert.deepEqual(candidate([4, 1, 1, 0]),true);
  assert.deepEqual(candidate([1, 2, 3, 2, 5, 60]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 60]),true);
  assert.deepEqual(candidate([9, 9, 9, 9]),true);
}

test();"
HumanEval_58,spa_Latn,js,"/Devuelve elementos comunes únicos ordenados para dos matrices. // >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
// [1, 5, 653]
// >>> common([5, 3, 2, 8], [3, 2])
// [2, 3]
function common(l1, l2){
","function common(l1, l2) {
    const set1 = new Set(l1);
    const set2 = new Set(l2);
    const result = [...set1].filter(item => set2.has(item));
    return result.sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = common;
  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);
  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2, 3]);
  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);
  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);
}

test();"
HumanEval_59,spa_Latn,js,"/Devuelve el mayor factor primo de n. Suponga que n > 1 y no es un primo. // >>> largest_prime_factor(13195)
// 29
// >>> largest_prime_factor(2048)
// 2
function largest_prime_factor(n){
","function largest_prime_factor(n) {
  let largest = -1;
  while (n % 2 === 0) {
    largest = 2;
    n /= 2;
  }
  
  for (let factor = 3; factor * factor <= n; factor += 2) {
    while (n % factor === 0) {
      largest = factor;
      n /= factor;
    }
  }
  
  if (n > 2) {
    largest = n;
  }
  
  return largest;
}","const assert = require('node:assert');


function test() {
  let candidate = largest_prime_factor;
  assert.deepEqual(candidate(15),5);
  assert.deepEqual(candidate(27),3);
  assert.deepEqual(candidate(63),7);
  assert.deepEqual(candidate(330),11);
  assert.deepEqual(candidate(13195),29);
}

test();"
HumanEval_60,spa_Latn,js,"/sum_to_n es una función que suma números de 1 a n. // >>> sum_to_n(30)
// 465
// >>> sum_to_n(100)
// 5050
// >>> sum_to_n(5)
// 15
// >>> sum_to_n(10)
// 55
// >>> sum_to_n(1)
// 1
function sum_to_n(n){
","function sum_to_n(n) {
    return n * (n + 1) / 2;
}","const assert = require('node:assert');


function test() {
  let candidate = sum_to_n;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(6),21);
  assert.deepEqual(candidate(11),66);
  assert.deepEqual(candidate(30),465);
  assert.deepEqual(candidate(100),5050);
}

test();"
HumanEval_61,spa_Latn,js,"/ devuelve verdad si cada bracket de apertura tiene un bracket de cierre correspondiente. /brackets es una cadena de ""("" y "")"". // >>> correct_bracketing(""("")
// false
// >>> correct_bracketing(""()"")
// true
// >>> correct_bracketing(""(()())"")
// true
// >>> correct_bracketing("")(()"")
// false
function correct_bracketing(brackets){
","function correct_bracketing(brackets) {
    let balance = 0;
    for (let i = 0; i < brackets.length; i++) {
        if (brackets[i] === '(') {
            balance++;
        } else if (brackets[i] === ')') {
            balance--;
        }
        if (balance < 0) {
            return false;
        }
    }
    return balance === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = correct_bracketing;
  assert.deepEqual(candidate(""()""),true);
  assert.deepEqual(candidate(""(()())""),true);
  assert.deepEqual(candidate(""()()(()())()""),true);
  assert.deepEqual(candidate(""()()((()()())())(()()(()))""),true);
  assert.deepEqual(candidate(""((()())))""),false);
  assert.deepEqual(candidate("")(()""),false);
  assert.deepEqual(candidate(""(""),false);
  assert.deepEqual(candidate(""((((""),false);
  assert.deepEqual(candidate("")""),false);
  assert.deepEqual(candidate(""(()""),false);
  assert.deepEqual(candidate(""()()(()())())(()""),false);
  assert.deepEqual(candidate(""()()(()())()))()""),false);
}

test();"
HumanEval_62,spa_Latn,js,"/ Devuelve la derivada de este polinomio en la misma forma. / xs[0] + xs[1] * x + xs[2] * x^2 + .... /xs representan los coeficientes de un polinomio.// >>> derivative([3, 1, 2, 4, 5])
// [1, 4, 12, 20]
// >>> derivative([1, 2, 3])
// [2, 6]
function derivative(xs){
","function derivative(xs) {
    const result = [];
    for (let i = 1; i < xs.length; i++) {
        result.push(xs[i] * i);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = derivative;
  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);
  assert.deepEqual(candidate([3, 2, 1]),[2, 2]);
  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);
  assert.deepEqual(candidate([1]),[]);
}

test();"
HumanEval_63,spa_Latn,js,"/ Por favor escriba una función para calcular eficientemente el n-ésimo elemento de la secuencia de números fibfib. / fibfib (n) == fibfib (n-1) + fibfib (n-2) + fib (n-3). / fib fib ({2) } == 1 / fib fib ({1) } == 0 / fib fib ({0) } == 0 /La secuencia de números FibFib es una secuencia similar a la secuencia de Fibbonacci que se define de la siguiente manera: // >>> fibfib(1)
// 0
// >>> fibfib(5)
// 4
// >>> fibfib(8)
// 24
function fibfib(n){
","function fibfib(n) {
    if (n === 0 || n === 1) return 0;
    if (n === 2) return 1;
    
    let a = 0, b = 0, c = 1, d;

    for (let i = 3; i <= n; i++) {
        d = a + b + c;
        a = b;
        b = c;
        c = d;
    }
    
    return c;
}","const assert = require('node:assert');


function test() {
  let candidate = fibfib;
  assert.deepEqual(candidate(2),1);
  assert.deepEqual(candidate(1),0);
  assert.deepEqual(candidate(5),4);
  assert.deepEqual(candidate(8),24);
  assert.deepEqual(candidate(10),81);
  assert.deepEqual(candidate(12),274);
  assert.deepEqual(candidate(14),927);
}

test();"
HumanEval_64,spa_Latn,js,"/ Ejemplo: / vocal, pero sólo cuando está al final de la palabra dada. / Las vocales en este caso son 'a', 'e', 'i', 'o', 'u'. Aquí, 'y' es también un / una palabra como entrada y devuelve el número de vocales en la cadena. /Escribe una función vowels_count que toma una cadena que representa // >>> vowels_count(""abcde"")
// 2
// >>> vowels_count(""ACEDY"")
// 3
function vowels_count(s){
","function vowels_count(s) {
    const vowels = 'aeiou';
    let count = 0;
    s = s.toLowerCase();
    
    for (let i = 0; i < s.length; i++) {
        if (vowels.includes(s[i]) || (i === s.length - 1 && s[i] === 'y')) {
            count++;
        }
    }

    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = vowels_count;
  assert.deepEqual(candidate(""abcde""),2);
  assert.deepEqual(candidate(""Alone""),3);
  assert.deepEqual(candidate(""key""),2);
  assert.deepEqual(candidate(""bye""),1);
  assert.deepEqual(candidate(""keY""),2);
  assert.deepEqual(candidate(""bYe""),1);
  assert.deepEqual(candidate(""ACEDY""),3);
}

test();"
HumanEval_65,spa_Latn,js,"/ Si el desplazamiento es > número de dígitos, los dígitos de retorno se invierten. / y devuelve el resultado como una cadena. / Circular desplazar los dígitos del número entero x, desplazar los dígitos a la derecha por el desplazamiento // >>> circular_shift(12, 1)
// ""21""
// >>> circular_shift(12, 2)
// ""12""
function circular_shift(x, shift){
","function circular_shift(x, shift) {
    let numStr = x.toString();
    let length = numStr.length;

    if (shift > length) {
        return numStr.split('').reverse().join('');
    } else {
        let endPart = numStr.slice(-shift);
        let startPart = numStr.slice(0, length - shift);
        return endPart + startPart;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = circular_shift;
  assert.deepEqual(candidate(100, 2),""001"");
  assert.deepEqual(candidate(12, 2),""12"");
  assert.deepEqual(candidate(97, 8),""79"");
  assert.deepEqual(candidate(12, 1),""21"");
  assert.deepEqual(candidate(11, 101),""11"");
}

test();"
HumanEval_66,spa_Latn,js,"/ Ejemplos: / Códigos ASCII. / Escriba una función que toma una cadena como entrada y devuelve la suma de los caracteres superiores sólo' - ¿Qué es lo que quieres?// >>> digitSum("""")
// 0
// >>> digitSum(""abAB"")
// 131
// >>> digitSum(""abcCd"")
// 67
// >>> digitSum(""helloE"")
// 69
// >>> digitSum(""woArBld"")
// 131
// >>> digitSum(""aAaaaXa"")
// 153
function digitSum(s){
","function digitSum(s) {
    let sum = 0;
    for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (char >= 'A' && char <= 'Z') {
            sum += char.charCodeAt(0);
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = digitSum;
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""abAB""),131);
  assert.deepEqual(candidate(""abcCd""),67);
  assert.deepEqual(candidate(""helloE""),69);
  assert.deepEqual(candidate(""woArBld""),131);
  assert.deepEqual(candidate(""aAaaaXa""),153);
  assert.deepEqual(candidate("" How are yOu?""),151);
  assert.deepEqual(candidate(""You arE Very Smart""),327);
}

test();"
HumanEval_67,spa_Latn,js,"/ para el exámbulo: / en la cesta devuelve el número de frutos de mango en la cesta. / las naranjas y las manzanas y un número entero que represente el número total de frutos / manzanas, naranjas y frutos de mango. dada la cadena que representa el número total de / que se distribuyen en una canasta de frutas que contiene esta canasta En esta tarea, se te dará una cadena que representa un número de manzanas y naranjas.// >>> fruit_distribution(""5 apples and 6 oranges"", 19)
// 8
// >>> fruit_distribution(""0 apples and 1 oranges"", 3)
// 2
// >>> fruit_distribution(""2 apples and 3 oranges"", 100)
// 95
// >>> fruit_distribution(""100 apples and 1 oranges"", 120)
// 19
function fruit_distribution(s, n){
","function fruit_distribution(s, n) {
    let apples = 0;
    let oranges = 0;
    
    // Regular expressions to extract the number of apples and oranges from the string
    const applesMatch = s.match(/(\d+)\s*apples/);
    const orangesMatch = s.match(/(\d+)\s*oranges/);
    
    // If a match is found, parse the number
    if (applesMatch) {
        apples = parseInt(applesMatch[1], 10);
    }
    if (orangesMatch) {
        oranges = parseInt(orangesMatch[1], 10);
    }
    
    // Calculate the number of mangoes
    const mangoes = n - (apples + oranges);
    return mangoes;
}","const assert = require('node:assert');


function test() {
  let candidate = fruit_distribution;
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 19),8);
  assert.deepEqual(candidate(""5 apples and 6 oranges"", 21),10);
  assert.deepEqual(candidate(""0 apples and 1 oranges"", 3),2);
  assert.deepEqual(candidate(""1 apples and 0 oranges"", 3),2);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 100),95);
  assert.deepEqual(candidate(""2 apples and 3 oranges"", 5),0);
  assert.deepEqual(candidate(""1 apples and 100 oranges"", 120),19);
}

test();"
HumanEval_68,spa_Latn,js,"Ejemplo 1:/ Si no hay valores pares o la matriz dada está vacía, devuelve []. / El nodo arrancado debe ser devuelto en una matriz, [smallest_value, su índice], / Si se encuentran múltiples nodos con el mismo valor par más pequeño, devuelve el nodo que tiene el índice más pequeño. / El nodo arrancado debe ser el nodo con el valor par más pequeño. / su tarea es arrancar uno de los nodos y devolverlo. /""Dado un array que representa una rama de un árbol que tiene nodos enteros no negativos // >>> pluck([4, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 2:
// >>> pluck([1, 2, 3])
// [2, 1]
// Explanation: 2 has the smallest even value, and 2 has the smallest index.
// Example 3:
// >>> pluck([])
// []
// Example 4:
// >>> pluck([5, 0, 3, 0, 4, 2])
// [0, 1]
// Explanation: 0 is the smallest value, but  there are two zeros,
// so we will choose the first zero, which has the smallest index.
// Constraints:
// * 1 <= nodes.length <= 10000
// * 0 <= node.value
function pluck(arr){
","function pluck(arr) {
    let smallestEvenValue = Infinity;
    let smallestEvenIndex = -1;

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 === 0) {
            if (arr[i] < smallestEvenValue) {
                smallestEvenValue = arr[i];
                smallestEvenIndex = i;
            }
        }
    }

    return smallestEvenIndex === -1 ? [] : [smallestEvenValue, smallestEvenIndex];
}","const assert = require('node:assert');


function test() {
  let candidate = pluck;
  assert.deepEqual(candidate([4, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);
  assert.deepEqual(candidate([1, 2, 3, 0, 5, 3]),[0, 3]);
  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);
  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);
  assert.deepEqual(candidate([7, 9, 7, 1]),[]);
}

test();"
HumanEval_69,spa_Latn,js,"/ Ejemplos: / Si no existe tal valor, devuelve -1. / La frecuencia de un entero es el número de veces que aparece en la matriz. / cero, y tiene una frecuencia mayor o igual al valor del propio número entero. /Se le da una matriz no vacía de enteros positivos. Devuelve el mayor entero que es mayor que // >>> search([4, 1, 2, 2, 3, 1])
// 2
// >>> search([1, 2, 2, 3, 3, 3, 4, 4, 4])
// 3
// >>> search([5, 5, 4, 4, 4])
// -1
function search(lst){
","function search(lst) {
    const frequencyMap = new Map();

    lst.forEach(num => {
        frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);
    });

    let result = -1;

    frequencyMap.forEach((count, num) => {
        if (count >= num && num > 0 && num > result) {
            result = num;
        }
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = search;
  assert.deepEqual(candidate([5, 5, 5, 5, 1]),1);
  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);
  assert.deepEqual(candidate([3, 3]),-1);
  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);
  assert.deepEqual(candidate([2, 3, 3, 2, 2]),2);
  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);
  assert.deepEqual(candidate([3, 2, 8, 2]),2);
  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);
  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);
  assert.deepEqual(candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);
  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);
  assert.deepEqual(candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);
  assert.deepEqual(candidate([1]),1);
  assert.deepEqual(candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);
  assert.deepEqual(candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);
  assert.deepEqual(candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);
  assert.deepEqual(candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]),4);
  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);
  assert.deepEqual(candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);
  assert.deepEqual(candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);
  assert.deepEqual(candidate([10]),-1);
  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);
  assert.deepEqual(candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);
  assert.deepEqual(candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);
  assert.deepEqual(candidate([3, 10, 10, 9, 2]),-1);
}

test();"
HumanEval_70,spa_Latn,js,"/ Ejemplos: / entonces máximo de los enteros restantes, luego mínimo y así sucesivamente. / Extraña clasificación, es cuando se comienza con el valor mínimo, /Dada una matriz de enteros, devuelve la matriz en orden extraño. // >>> strange_sort_list([1, 2, 3, 4])
// [1, 4, 2, 3]
// >>> strange_sort_list([5, 5, 5, 5])
// [5, 5, 5, 5]
// >>> strange_sort_list([])
// []
function strange_sort_list(lst){
","function strange_sort_list(lst) {
    let result = [];
    lst.sort((a, b) => a - b); // Sort the array in ascending order

    while (lst.length) {
        result.push(lst.shift()); // Add the minimum element
        if (lst.length) {
            result.push(lst.pop()); // Add the maximum element
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = strange_sort_list;
  assert.deepEqual(candidate([1, 2, 3, 4]),[1, 4, 2, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9]),[5, 9, 6, 8, 7]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),[1, 5, 2, 4, 3]);
  assert.deepEqual(candidate([5, 6, 7, 8, 9, 1]),[1, 9, 5, 8, 6, 7]);
  assert.deepEqual(candidate([5, 5, 5, 5]),[5, 5, 5, 5]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8]),[1, 8, 2, 7, 3, 6, 4, 5]);
  assert.deepEqual(candidate([0, 2, 2, 2, 5, 5, -5, -5]),[-5, 5, -5, 5, 0, 2, 2, 2]);
  assert.deepEqual(candidate([111111]),[111111]);
}

test();"
HumanEval_71,spa_Latn,js,"/ Ejemplo: / que el tercer lado. / Tres lados hacen un triángulo válido cuando la suma de cualquiera de los dos lados es mayor ./ De lo contrario regresa -1 / el triángulo redondeado a 2 décimas si los tres lados forman un triángulo válido. Dadas las longitudes de los tres lados de un triángulo, devuelve el área de // >>> triangle_area(3, 4, 5)
// 6.0
// >>> triangle_area(1, 2, 10)
// -1
function triangle_area(a, b, c){
","function triangle_area(a, b, c) {
    // Check if the sides form a valid triangle
    if (a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area
        const s = (a + b + c) / 2;
        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        // Return the area rounded to 2 decimal places
        return Math.round(area * 100) / 100;
    } else {
        // Return -1 for an invalid triangle
        return -1;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = triangle_area;
  assert.deepEqual(candidate(3, 4, 5),6.0);
  assert.deepEqual(candidate(1, 2, 10),-1);
  assert.deepEqual(candidate(4, 8, 5),8.18);
  assert.deepEqual(candidate(2, 2, 2),1.73);
  assert.deepEqual(candidate(1, 2, 3),-1);
  assert.deepEqual(candidate(10, 5, 7),16.25);
  assert.deepEqual(candidate(2, 6, 3),-1);
  assert.deepEqual(candidate(1, 1, 1),0.43);
  assert.deepEqual(candidate(2, 2, 10),-1);
}

test();"
HumanEval_72,spa_Latn,js,"/ Ejemplo: / El objeto q volará si está equilibrado (es una matriz palindromica) y la suma de sus elementos es menor o igual al peso máximo posible w. /Escribe una función que devuelve verdadero si el objeto q volará, y falso de lo contrario. // >>> will_it_fly([1, 2], 5)
// false
// # 1+2 is less than the maximum possible weight, but it's unbalanced.
// >>> will_it_fly([3, 2, 3], 1)
// false
// # it's balanced, but 3+2+3 is more than the maximum possible weight.
// >>> will_it_fly([3, 2, 3], 9)
// true
// # 3+2+3 is less than the maximum possible weight, and it's balanced.
// >>> will_it_fly([3], 5)
// true
// # 3 is less than the maximum possible weight, and it's balanced.
function will_it_fly(q, w){
","function will_it_fly(q, w) {
    // Check if q is a palindromic array
    function isPalindromic(arr) {
        for (let i = 0; i < Math.floor(arr.length / 2); i++) {
            if (arr[i] !== arr[arr.length - 1 - i]) {
                return false;
            }
        }
        return true;
    }

    // Calculate the sum of the array
    function sumArray(arr) {
        return arr.reduce((acc, val) => acc + val, 0);
    }

    // Check if the array is balanced and the sum is within the limit
    return isPalindromic(q) && sumArray(q) <= w;
}","const assert = require('node:assert');


function test() {
  let candidate = will_it_fly;
  assert.deepEqual(candidate([3, 2, 3], 9),true);
  assert.deepEqual(candidate([1, 2], 5),false);
  assert.deepEqual(candidate([3], 5),true);
  assert.deepEqual(candidate([3, 2, 3], 1),false);
  assert.deepEqual(candidate([1, 2, 3], 6),false);
  assert.deepEqual(candidate([5], 5),true);
}

test();"
HumanEval_73,spa_Latn,js,"Por ejemplo:/ se lee de la misma manera hacia atrás y hacia adelante. En un cambio, puede cambiar un elemento a cualquier otro elemento. / necesita ser cambiado para hacer que la matriz sea palindromica. Una matriz palindromica es una matriz que / Dado un array arr de enteros, encuentre el número mínimo de elementos que // >>> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])
// 4
// >>> smallest_change([1, 2, 3, 4, 3, 2, 2])
// 1
// >>> smallest_change([1, 2, 3, 2, 1])
// 0
function smallest_change(arr){
","function smallest_change(arr) {
    let changes = 0;
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {
        if (arr[left] !== arr[right]) {
            changes++;
        }
        left++;
        right--;
    }

    return changes;
}","const assert = require('node:assert');


function test() {
  let candidate = smallest_change;
  assert.deepEqual(candidate([1, 2, 3, 5, 4, 7, 9, 6]),4);
  assert.deepEqual(candidate([1, 2, 3, 4, 3, 2, 2]),1);
  assert.deepEqual(candidate([1, 4, 2]),1);
  assert.deepEqual(candidate([1, 4, 4, 2]),1);
  assert.deepEqual(candidate([1, 2, 3, 2, 1]),0);
  assert.deepEqual(candidate([3, 1, 1, 3]),0);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([0, 1]),1);
}

test();"
HumanEval_74,spa_Latn,js,"/ Ejemplos / si las dos matrices tienen el mismo número de caracteres, devuelve la primera matriz. / número total de caracteres en todas las cadenas de la matriz menos que la otra matriz. /Escribe una función que acepta dos matrices de cadenas y devuelve la matriz que tiene // >>> total_match([], [])
// []
// >>> total_match([""hi"", ""admin""], [""hI"", ""Hi""])
// [""hI"", ""Hi""]
// >>> total_match([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""])
// [""hi"", ""admin""]
// >>> total_match([""hi"", ""admin""], [""hI"", ""hi"", ""hi""])
// [""hI"", ""hi"", ""hi""]
// >>> total_match([""4""], [""1"", ""2"", ""3"", ""4"", ""5""])
// [""4""]
function total_match(lst1, lst2){
","function total_match(lst1, lst2) {
    // Helper function to calculate total characters in an array of strings
    const totalChars = (arr) => arr.reduce((sum, str) => sum + str.length, 0);

    const total1 = totalChars(lst1);
    const total2 = totalChars(lst2);

    if (total1 < total2) {
        return lst1;
    } else {
        return lst2;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = total_match;
  assert.deepEqual(candidate([], []),[]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi""]),[""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hi"", ""hi"", ""admin"", ""project""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([""4""], [""1"", ""2"", ""3"", ""4"", ""5""]),[""4""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""Hi""]),[""hI"", ""Hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hi""]),[""hI"", ""hi"", ""hi""]);
  assert.deepEqual(candidate([""hi"", ""admin""], [""hI"", ""hi"", ""hii""]),[""hi"", ""admin""]);
  assert.deepEqual(candidate([], [""this""]),[]);
  assert.deepEqual(candidate([""this""], []),[]);
}

test();"
HumanEval_75,spa_Latn,js,"/ Ejemplo: / Sabiendo que (a) es menor que 100. / y falso de otra manera. /Escribe una función que devuelve verdadero si el número dado es la multiplicación de 3 números primos // >>> is_multiply_prime(30)
// true
// 30 = 2 * 3 * 5
function is_multiply_prime(a){
","function is_prime(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
}

function generate_primes(upper_limit) {
    const primes = [];
    for (let num = 2; num < upper_limit; num++) {
        if (is_prime(num)) {
            primes.push(num);
        }
    }
    return primes;
}

function is_multiply_prime(a) {
    if (a < 2) return false;
    const primes = generate_primes(100);
    const primesLength = primes.length;

    for (let i = 0; i < primesLength; i++) {
        for (let j = i; j < primesLength; j++) {
            for (let k = j; k < primesLength; k++) {
                if (primes[i] * primes[j] * primes[k] === a) {
                    return true;
                }
            }
        }
    }

    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = is_multiply_prime;
  assert.deepEqual(candidate(5),false);
  assert.deepEqual(candidate(30),true);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),false);
  assert.deepEqual(candidate(125),true);
  assert.deepEqual(candidate(105),true);
  assert.deepEqual(candidate(126),false);
  assert.deepEqual(candidate(729),false);
  assert.deepEqual(candidate(891),false);
  assert.deepEqual(candidate(1001),true);
}

test();"
HumanEval_76,spa_Latn,js,"Por ejemplo:/ x es una potencia simple de n si n ** int = x / potencia de n y falso en otros casos. /Su tarea es escribir una función que devuelve verdad si un número x es un simple // >>> is_simple_power(1, 4)
// true
// >>> is_simple_power(2, 2)
// true
// >>> is_simple_power(8, 2)
// true
// >>> is_simple_power(3, 2)
// false
// >>> is_simple_power(3, 1)
// false
// >>> is_simple_power(5, 3)
// false
function is_simple_power(x, n){
","function is_simple_power(x, n) {
    if (x === 1) return true;  // Any number to the power of zero is 1
    if (n <= 1) return false;  // n must be greater than 1 to have simple powers other than itself

    let power = n;
    while (power < x) {
        power *= n;
    }

    return power === x;
}","const assert = require('node:assert');


function test() {
  let candidate = is_simple_power;
  assert.deepEqual(candidate(16, 2),true);
  assert.deepEqual(candidate(143214, 16),false);
  assert.deepEqual(candidate(4, 2),true);
  assert.deepEqual(candidate(9, 3),true);
  assert.deepEqual(candidate(16, 4),true);
  assert.deepEqual(candidate(24, 2),false);
  assert.deepEqual(candidate(128, 4),false);
  assert.deepEqual(candidate(12, 6),false);
  assert.deepEqual(candidate(1, 1),true);
  assert.deepEqual(candidate(1, 12),true);
}

test();"
HumanEval_77,spa_Latn,js,"/ Ejemplos: / Nota: puede asumir que la entrada siempre es válida. / si este ingeger es un cubo de algún número entero. /Escribe una función que toma un entero a y devuelve true // >>> iscube(1)
// true
// >>> iscube(2)
// false
// >>> iscube(-1)
// true
// >>> iscube(64)
// true
// >>> iscube(0)
// true
// >>> iscube(180)
// false
function iscube(a){
","function iscube(a) {
    if (a < 0) a = -a;
    let cubeRoot = Math.round(Math.pow(a, 1/3));
    return cubeRoot * cubeRoot * cubeRoot === a;
}","const assert = require('node:assert');


function test() {
  let candidate = iscube;
  assert.deepEqual(candidate(1),true);
  assert.deepEqual(candidate(2),false);
  assert.deepEqual(candidate(-1),true);
  assert.deepEqual(candidate(64),true);
  assert.deepEqual(candidate(180),false);
  assert.deepEqual(candidate(1000),true);
  assert.deepEqual(candidate(0),true);
  assert.deepEqual(candidate(1729),false);
}

test();"
HumanEval_78,spa_Latn,js,"/ Ejemplos: / y los símbolos A, B, C, D, E, F son siempre mayúsculas. / Nota: puede asumir que la entrada es siempre correcta o una cadena vacía, / B (= decimal 11), D (= decimal 13) / Así que tienes que determinar un número de los siguientes dígitos: 2, 3, 5, 7, Los números primos son 2, 3, 5, 7, 11, 13, 17.../ Los dígitos hexadecimales son 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. / mayor que 1 que no es un producto de dos números naturales más pequeños)./ dígitos que son primos (número primo, o un primo, es un número natural / un número hexadecimal como una cadena y cuenta el número de hexadecimal /Se le ha encargado escribir una función que recibe // >>> hex_key(""AB"")
// 1
// >>> hex_key(""1077E"")
// 2
// >>> hex_key(""ABED1A33"")
// 4
// >>> hex_key(""123456789ABCDEF0"")
// 6
// >>> hex_key(""2020"")
// 2
function hex_key(num){
","function hex_key(num) {
    // Define a set of hexadecimal digits that are prime numbers
    const primeHexDigits = new Set(['2', '3', '5', '7', 'B', 'D']);
    
    // Initialize a count variable to track the number of prime digits
    let count = 0;
    
    // Iterate over each character in the input string
    for (let char of num) {
        // Check if the character is in the set of prime hexadecimal digits
        if (primeHexDigits.has(char)) {
            // Increment the count if the character is a prime digit
            count++;
        }
    }
    
    // Return the total count of prime hexadecimal digits
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = hex_key;
  assert.deepEqual(candidate(""AB""),1);
  assert.deepEqual(candidate(""1077E""),2);
  assert.deepEqual(candidate(""ABED1A33""),4);
  assert.deepEqual(candidate(""2020""),2);
  assert.deepEqual(candidate(""123456789ABCDEF0""),6);
  assert.deepEqual(candidate(""112233445566778899AABBCCDDEEFF00""),12);
}

test();"
HumanEval_79,spa_Latn,js,"/ Ejemplos: / Los caracteres adicionales están ahí para ayudar con el formato. / Habrá un par de caracteres adicionales 'db' al principio y al final de la cadena. Cada carácter en la cadena será '0' o '1'./ formato binario. La función debe devolver una cadena, con cada carácter que representa un binario /Se le dará un número en forma decimal y su tarea es convertirlo a // >>> decimal_to_binary(15)
// ""db1111db""
// >>> decimal_to_binary(32)
// ""db100000db""
function decimal_to_binary(decimal){
","function decimal_to_binary(decimal) {
    // Convert the decimal number to a binary string
    let binaryString = decimal.toString(2);
    // Add 'db' at the beginning and end of the binary string
    return 'db' + binaryString + 'db';
}","const assert = require('node:assert');


function test() {
  let candidate = decimal_to_binary;
  assert.deepEqual(candidate(0),""db0db"");
  assert.deepEqual(candidate(32),""db100000db"");
  assert.deepEqual(candidate(103),""db1100111db"");
  assert.deepEqual(candidate(15),""db1111db"");
}

test();"
HumanEval_80,spa_Latn,js,"Por ejemplo:/ Una cadena es feliz si su longitud es de al menos 3 y cada 3 letras consecutivas son distintas / Su tarea es comprobar si la cadena es hapjs o no. Se le da una cadena de s.// >>> is_happy(""a"")
// false
// >>> is_happy(""aa"")
// false
// >>> is_happy(""abcd"")
// true
// >>> is_happy(""aabb"")
// false
// >>> is_happy(""adb"")
// true
// >>> is_happy(""xyy"")
// false
function is_happy(s){
","function is_happy(s) {
    if (s.length < 3) return false;
    for (let i = 0; i < s.length - 2; i++) {
        if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {
            return false;
        }
    }
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_happy;
  assert.deepEqual(candidate(""a""),false);
  assert.deepEqual(candidate(""aa""),false);
  assert.deepEqual(candidate(""abcd""),true);
  assert.deepEqual(candidate(""aabb""),false);
  assert.deepEqual(candidate(""adb""),true);
  assert.deepEqual(candidate(""xyy""),false);
  assert.deepEqual(candidate(""iopaxpoi""),true);
  assert.deepEqual(candidate(""iopaxioi""),false);
}

test();"
HumanEval_81,spa_Latn,js,"/ Ejemplo: / 0,0 E / > 0,0 D- / > 0,7 D / > 1,0 D+ / > 1.3 C- / > 1,7 C / > 2,0 C+ / > 2.3 B- / > 2,7 B / > 3,0 B+ / > 3.3 A- / > 3.7 A - ¿Qué es eso?- El promedio de calificaciones./ una función que puede producir una matriz de calificaciones de letras utilizando la siguiente tabla: Te ha dado una serie de promedios para algunos estudiantes y tienes que escribir .El único problema es que ha perdido el código que usaba para calificar.La maestra ha estado haciendo su propio algoritmo para la calificación.Es la última semana del semestre y el profesor tiene que dar las calificaciones.// >>> grade_equation([4.0, 3, 1.7, 2, 3.5])
// [""A+"", ""B"", ""C-"", ""C"", ""A-""]
function numerical_letter_grade(grades){
","function numerical_letter_grade(grades){
    return grades.map(gpa => {
        if (gpa === 4.0) return ""A+"";
        else if (gpa > 3.7) return ""A"";
        else if (gpa > 3.3) return ""A-"";
        else if (gpa > 3.0) return ""B+"";
        else if (gpa > 2.7) return ""B"";
        else if (gpa > 2.3) return ""B-"";
        else if (gpa > 2.0) return ""C+"";
        else if (gpa > 1.7) return ""C"";
        else if (gpa > 1.3) return ""C-"";
        else if (gpa > 1.0) return ""D+"";
        else if (gpa > 0.7) return ""D"";
        else if (gpa > 0.0) return ""D-"";
        else return ""E"";
    });
}","const assert = require('node:assert');


function test() {
  let candidate = numerical_letter_grade;
  assert.deepEqual(candidate([4.0, 3, 1.7, 2, 3.5]),[""A+"", ""B"", ""C-"", ""C"", ""A-""]);
  assert.deepEqual(candidate([1.2]),[""D+""]);
  assert.deepEqual(candidate([0.5]),[""D-""]);
  assert.deepEqual(candidate([0.0]),[""E""]);
  assert.deepEqual(candidate([1.0, 0.3, 1.5, 2.8, 3.3]),[""D"", ""D-"", ""C-"", ""B"", ""B+""]);
  assert.deepEqual(candidate([0.0, 0.7]),[""E"", ""D-""]);
}

test();"
HumanEval_82,spa_Latn,js,"/ Ejemplos / longitud es un número primo o falso de lo contrario /Escribe una función que toma una cadena y devuelve true si la cadena // >>> prime_length(""Hello"")
// true
// >>> prime_length(""abcdcba"")
// true
// >>> prime_length(""kittens"")
// true
// >>> prime_length(""orange"")
// false
function prime_length(string){
","function prime_length(string) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }
    
    return isPrime(string.length);
}","const assert = require('node:assert');


function test() {
  let candidate = prime_length;
  assert.deepEqual(candidate(""Hello""),true);
  assert.deepEqual(candidate(""abcdcba""),true);
  assert.deepEqual(candidate(""kittens""),true);
  assert.deepEqual(candidate(""orange""),false);
  assert.deepEqual(candidate(""wow""),true);
  assert.deepEqual(candidate(""world""),true);
  assert.deepEqual(candidate(""MadaM""),true);
  assert.deepEqual(candidate(""Wow""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""HI""),true);
  assert.deepEqual(candidate(""go""),true);
  assert.deepEqual(candidate(""gogo""),false);
  assert.deepEqual(candidate(""aaaaaaaaaaaaaaa""),false);
  assert.deepEqual(candidate(""Madam""),true);
  assert.deepEqual(candidate(""M""),false);
  assert.deepEqual(candidate(""0""),false);
}

test();"
HumanEval_83,spa_Latn,js,"/ enteros positivos que comienzan o terminan con 1. /Dado un entero positivo n, devuelve el recuento de los números de n dígitos function starts_one_ends(n){
","function starts_one_ends(n) {
    if (n === 1) return 1; // For n = 1, only number is 1 itself

    // Calculate the number of n-digit numbers that either start or end with 1
    // Total n-digit numbers: 9 * 10^(n-1) (ranging from 10^(n-1) to 10^n - 1)

    let totalCount = 9 * Math.pow(10, n - 1);

    // Numbers that both start and end with 1: 10^(n-2) (e.g., 101, 111, 121, ..., 191 if n=3)
    let bothStartAndEndWithOne = Math.pow(10, n - 2);

    // Numbers that start with 1: 10^(n-1)
    let startWithOne = Math.pow(10, n - 1);

    // Numbers that end with 1: 9 * 10^(n-1) / 10 = 10^(n-1) (because we're counting 1 - 1, 11, 21, ..., 91)
    let endWithOne = Math.pow(10, n - 1);

    // Use inclusion-exclusion principle: number starts with 1 + numbers end with 1 - numbers that both start and end with 1
    return startWithOne + endWithOne - bothStartAndEndWithOne;
}","const assert = require('node:assert');


function test() {
  let candidate = starts_one_ends;
  assert.deepEqual(candidate(1),1);
  assert.deepEqual(candidate(2),18);
  assert.deepEqual(candidate(3),180);
  assert.deepEqual(candidate(4),1800);
  assert.deepEqual(candidate(5),18000);
}

test();"
HumanEval_84,spa_Latn,js,"- Ejemplo ./Dado un entero positivo N, devuelve la suma total de sus dígitos en binario. // >>> solve(1000)
// ""1""
// >>> solve(150)
// ""110""
// >>> solve(147)
// ""1100""
// Variables:
// @N integer
// Constraints: 0 ≤ N ≤ 10000.
// Output:
// a string of binary number
function solve(N){
","function solve(N) {
    // Convert the number to a string and split into individual characters (digits)
    let digits = N.toString().split('');
    // Calculate the sum of all digits
    let sum = digits.reduce((acc, digit) => acc + Number(digit), 0);
    // Convert the sum to a binary string and return
    return sum.toString(2);
}","const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(1000),""1"");
  assert.deepEqual(candidate(150),""110"");
  assert.deepEqual(candidate(147),""1100"");
  assert.deepEqual(candidate(333),""1001"");
  assert.deepEqual(candidate(963),""10010"");
}

test();"
HumanEval_85,spa_Latn,js,"/ Ejemplos: /Dado un conjunto de enteros no vacíos primero. Añadir los elementos pares que están en índices impares .. // >>> add([4, 2, 6, 7])
// 2
function add(lst){
","function add(lst) {
    let sum = 0;
    for (let i = 1; i < lst.length; i += 2) {
        if (lst[i] % 2 === 0) {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = add;
  assert.deepEqual(candidate([4, 88]),88);
  assert.deepEqual(candidate([4, 5, 6, 7, 2, 122]),122);
  assert.deepEqual(candidate([4, 0, 6, 7]),0);
  assert.deepEqual(candidate([4, 4, 6, 8]),12);
}

test();"
HumanEval_86,spa_Latn,js,"Por ejemplo:/ Nota: Debe mantener el orden de las palabras y los espacios en blanco en la oración. / orden ascendente basado en el valor ASCII. / se sustituyen por una nueva palabra en la que todos los caracteres ordenados en / Versión ordenada de la cadena, es una cadena donde todas las palabras (separadas por espacio) /Escribe una función que toma una cadena y devuelve una versión ordenada de la misma. // >>> anti_shuffle(""Hi"")
// ""Hi""
// >>> anti_shuffle(""hello"")
// ""ehllo""
// >>> anti_shuffle(""Hello World!!!"")
// ""Hello !!!Wdlor""
function anti_shuffle(s){
","function anti_shuffle(s) {
    return s.split(' ').map(word => {
        return word.split('').sort().join('');
    }).join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = anti_shuffle;
  assert.deepEqual(candidate(""Hi""),""Hi"");
  assert.deepEqual(candidate(""hello""),""ehllo"");
  assert.deepEqual(candidate(""number""),""bemnru"");
  assert.deepEqual(candidate(""abcd""),""abcd"");
  assert.deepEqual(candidate(""Hello World!!!""),""Hello !!!Wdlor"");
  assert.deepEqual(candidate(""""),"""");
  assert.deepEqual(candidate(""Hi. My name is Mister Robot. How are you?""),"".Hi My aemn is Meirst .Rboot How aer ?ouy"");
}

test();"
HumanEval_87,spa_Latn,js,"/ Ejemplos: / También, ordenar las coordenadas de la fila por columnas en orden descendente. / Ordenar las coordenadas inicialmente por filas en orden ascendente. / cada matriz es una coordenada - (fila, columnas), comenzando con 0. / y devuelve matriz de matrices, [(x1, y1), (x2, y2) ...] tal que / Dado lst, y entero x, encontrar enteros x en la matriz, / cada fila puede contener un número diferente de columnas./ que es similar a la matriz, sin embargo, a diferencia de las matrices, /Se le da un 2 datos dimensionales, como una matriz anidada, // >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]
// >>> get_row([], 1)
// []
// >>> get_row([[], [1], [1, 2, 3]], 3)
// [[2, 2]]
function get_row(lst, x){
","function get_row(lst, x) {
    const result = [];

    for (let i = 0; i < lst.length; i++) {
        for (let j = 0; j < lst[i].length; j++) {
            if (lst[i][j] === x) {
                result.push([i, j]);
            }
        }
    }

    result.sort((a, b) => {
        if (a[0] === b[0]) {
            return b[1] - a[1]; // Sort by columns in descending order for the same row
        }
        return a[0] - b[0]; // Sort by rows in ascending order
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = get_row;
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);
  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);
  assert.deepEqual(candidate([], 1),[]);
  assert.deepEqual(candidate([[1]], 2),[]);
  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);
}

test();"
HumanEval_88,spa_Latn,js,"/ Ejemplos: / * no cambien la matriz dada. / Nota: / o ordenarlo en orden descendente si la suma ((primer valor del índice, último valor del índice) es par. / usted ordenará la matriz dada en orden ascendente si la suma ((el primer valor del índice, el último valor del índice) es impar, /Dado un conjunto de enteros no negativos, devuelve un cojs del conjunto dado después de ordenar, // >>> sort_array([])
// []
// >>> sort_array([5])
// [5]
// >>> sort_array([2, 4, 3, 0, 1, 5])
// [0, 1, 2, 3, 4, 5]
// >>> sort_array([2, 4, 3, 0, 1, 5, 6])
// [6, 5, 4, 3, 2, 1, 0]
function sort_array(array){
","function sort_array(array) {
    if (array.length === 0) return [];

    let firstValue = array[0];
    let lastValue = array[array.length - 1];
    let sum = firstValue + lastValue;
    
    let sortedArray = [...array]; // Clone the array to avoid modifying the original

    if (sum % 2 === 0) {
        // Even sum: sort in descending order
        sortedArray.sort((a, b) => b - a);
    } else {
        // Odd sum: sort in ascending order
        sortedArray.sort((a, b) => a - b);
    }

    return sortedArray;
}","const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([5]),[5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5]),[0, 1, 2, 3, 4, 5]);
  assert.deepEqual(candidate([2, 4, 3, 0, 1, 5, 6]),[6, 5, 4, 3, 2, 1, 0]);
  assert.deepEqual(candidate([2, 1]),[1, 2]);
  assert.deepEqual(candidate([15, 42, 87, 32, 11, 0]),[0, 11, 15, 32, 42, 87]);
  assert.deepEqual(candidate([21, 14, 23, 11]),[23, 21, 14, 11]);
}

test();"
HumanEval_89,spa_Latn,js,"Por ejemplo:/ desplazarse hacia abajo por dos multiplicado por dos lugares. / El alfabeto debe girarse de tal manera que las letras / devuelve una cadena cifrada con el alfabeto girando. /Crear una función de cifrado que toma una cadena como argumento y // >>> encrypt(""hi"")
// ""lm""
// >>> encrypt(""asdfghjkl"")
// ""ewhjklnop""
// >>> encrypt(""gf"")
// ""kj""
// >>> encrypt(""et"")
// ""ix""
function encrypt(s){
","function encrypt(s) {
    const shift = 2 * 2; // shift down by two multiplied by two places
    let encrypted = '';
    for (let i = 0; i < s.length; i++) {
        let charCode = s.charCodeAt(i);
        let newCharCode = ((charCode - 97 + shift) % 26) + 97; // wrap around within 'a' to 'z'
        encrypted += String.fromCharCode(newCharCode);
    }
    return encrypted;
}","const assert = require('node:assert');


function test() {
  let candidate = encrypt;
  assert.deepEqual(candidate(""hi""),""lm"");
  assert.deepEqual(candidate(""asdfghjkl""),""ewhjklnop"");
  assert.deepEqual(candidate(""gf""),""kj"");
  assert.deepEqual(candidate(""et""),""ix"");
  assert.deepEqual(candidate(""faewfawefaewg""),""jeiajeaijeiak"");
  assert.deepEqual(candidate(""hellomyfriend""),""lippsqcjvmirh"");
  assert.deepEqual(candidate(""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh""),""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"");
  assert.deepEqual(candidate(""a""),""e"");
}

test();"
HumanEval_90,spa_Latn,js,"/ Devuelve indefinido si no hay tal elemento. / Escriba una función next_smallest (en inglés) que devuelva el segundo elemento más pequeño de la matriz. /Se le da una matriz de números enteros. // >>> next_smallest([1, 2, 3, 4, 5])
// 2
// >>> next_smallest([5, 1, 4, 3, 2])
// 2
// >>> next_smallest([])
// undefined
// >>> next_smallest([1, 1])
// undefined
function next_smallest(lst){
","function next_smallest(lst) {
    if (lst.length < 2) return undefined;
    
    let firstSmallest = Infinity;
    let secondSmallest = Infinity;
    
    for (let num of lst) {
        if (num < firstSmallest) {
            secondSmallest = firstSmallest;
            firstSmallest = num;
        } else if (num < secondSmallest && num != firstSmallest) {
            secondSmallest = num;
        }
    }
    
    return secondSmallest === Infinity ? undefined : secondSmallest;
}","const assert = require('node:assert');


function test() {
  let candidate = next_smallest;
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),2);
  assert.deepEqual(candidate([5, 1, 4, 3, 2]),2);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([1, 1, 1, 1, 0]),1);
  assert.deepEqual(candidate([1, 1]),undefined);
  assert.deepEqual(candidate([-35, 34, 12, -45]),-35);
}

test();"
HumanEval_91,spa_Latn,js,"Por ejemplo:/ Las frases se delimitan con '.', '?' o '!'. Un aburrimiento es una frase que comienza con la palabra ""yo""./Se te dará una cadena de palabras, y tu tarea es contar el número.// >>> is_bored(""Hello world"")
// 0
// >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
// 1
function is_bored(S){
","function is_bored(S) {
    // Split the string into sentences using '.', '?', and '!' as delimiters
    const sentences = S.split(/[.!?]/);
    
    // Initialize boredom count
    let boredomCount = 0;
    
    // Iterate over each sentence
    sentences.forEach(sentence => {
        // Trim any whitespace from the beginning of the sentence and check if it starts with ""I""
        if (sentence.trim().startsWith(""I"")) {
            boredomCount++;
        }
    });
    
    return boredomCount;
}","const assert = require('node:assert');


function test() {
  let candidate = is_bored;
  assert.deepEqual(candidate(""Hello world""),0);
  assert.deepEqual(candidate(""Is the sky blue?""),0);
  assert.deepEqual(candidate(""I love It !""),1);
  assert.deepEqual(candidate(""bIt""),0);
  assert.deepEqual(candidate(""I feel good today. I will be productive. will kill It""),2);
  assert.deepEqual(candidate(""You and I are going for a walk""),0);
}

test();"
HumanEval_92,spa_Latn,js,"/ Ejemplos / Devuelve falso en cualquier otro caso. / Devuelve verdad si uno de los números es igual a la suma de los otros dos, y todos los números son enteros. /Crear una función que toma 3 números. // >>> any_int(5, 2, 7)
// true
// >>> any_int(3, 2, 2)
// false
// >>> any_int(3, -2, 1)
// true
// >>> any_int(3.6, -2.2, 2)
// false
function any_int(x, y, z){
","function any_int(x, y, z) {
    // Check if all numbers are integers
    if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {
        // Check if any number is the sum of the other two
        return x === y + z || y === x + z || z === x + y;
    }
    // Return false if not all numbers are integers
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = any_int;
  assert.deepEqual(candidate(2, 3, 1),true);
  assert.deepEqual(candidate(2.5, 2, 3),false);
  assert.deepEqual(candidate(1.5, 5, 3.5),false);
  assert.deepEqual(candidate(2, 6, 2),false);
  assert.deepEqual(candidate(4, 2, 2),true);
  assert.deepEqual(candidate(2.2, 2.2, 2.2),false);
  assert.deepEqual(candidate(-4, 6, 2),true);
  assert.deepEqual(candidate(2, 1, 1),true);
  assert.deepEqual(candidate(3, 4, 7),true);
  assert.deepEqual(candidate(3.0, 4, 7),false);
}

test();"
HumanEval_93,spa_Latn,js,"/ Ejemplos: - Sólo las letras./ Vocal en el alfabeto inglés./ el mensaje con la letra que aparece 2 lugares por delante de eso / manera que cambia de caso de todas las letras, sustituye todas las vocales en /Escribe una función que toma un mensaje, y codifica en tal // >>> encode(""test"")
// ""TGST""
// >>> encode(""This is a message"")
// ""tHKS KS C MGSSCGG""
function encode(message){
","function encode(message) {
    // Helper function to swap the case of a character
    function swapCase(char) {
        if (char === char.toLowerCase()) {
            return char.toUpperCase();
        } else {
            return char.toLowerCase();
        }
    }

    // Vowel mapping
    const vowelMap = {
        'a': 'c',
        'e': 'g',
        'i': 'k',
        'o': 'q',
        'u': 'w',
        'A': 'C',
        'E': 'G',
        'I': 'K',
        'O': 'Q',
        'U': 'W'
    };

    // Encode the message
    let encodedMessage = '';
    
    for (let char of message) {
        if (/[aeiouAEIOU]/.test(char)) {
            // Replace vowel with appropriate letter
            encodedMessage += vowelMap[char];
        } else {
            // Swap case for non-vowel letters
            encodedMessage += swapCase(char);
        }
    }
    
    return encodedMessage;
}","const assert = require('node:assert');


function test() {
  let candidate = encode;
  assert.deepEqual(candidate(""TEST""),""tgst"");
  assert.deepEqual(candidate(""Mudasir""),""mWDCSKR"");
  assert.deepEqual(candidate(""YES""),""ygs"");
  assert.deepEqual(candidate(""This is a message""),""tHKS KS C MGSSCGG"");
  assert.deepEqual(candidate(""I DoNt KnOw WhAt tO WrItE""),""k dQnT kNqW wHcT Tq wRkTg"");
}

test();"
HumanEval_94,spa_Latn,js,"/ Ejemplos: / Necesitas encontrar el valor primo más grande y devolver la suma de sus dígitos. /Se le da una matriz de números enteros. // >>> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
// 10
// >>> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
// 25
// >>> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
// 13
// >>> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
// 11
// >>> skjkasdkd([0, 81, 12, 3, 1, 21])
// 3
// >>> skjkasdkd([0, 8, 1, 2, 1, 7])
// 7
function skjkasdkd(lst){
","function skjkasdkd(lst) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    function sumOfDigits(num) {
        return num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }

    let largestPrime = -1;

    for (let num of lst) {
        if (isPrime(num) && num > largestPrime) {
            largestPrime = num;
        }
    }
    
    return largestPrime !== -1 ? sumOfDigits(largestPrime) : 0;
}","const assert = require('node:assert');


function test() {
  let candidate = skjkasdkd;
  assert.deepEqual(candidate([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]),10);
  assert.deepEqual(candidate([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]),25);
  assert.deepEqual(candidate([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]),13);
  assert.deepEqual(candidate([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]),11);
  assert.deepEqual(candidate([0, 81, 12, 3, 1, 21]),3);
  assert.deepEqual(candidate([0, 8, 1, 2, 1, 7]),7);
  assert.deepEqual(candidate([8191]),19);
  assert.deepEqual(candidate([8191, 123456, 127, 7]),19);
  assert.deepEqual(candidate([127, 97, 8192]),10);
}

test();"
HumanEval_95,spa_Latn,js,"/ Ejemplos: / La función debe devolver false si el objeto dado está vacío. / caso o todas las claves son cadenas en mayúscula, de lo contrario devuelve false. /Dado un objeto, devuelve verdad si todas las teclas son cadenas en menor // >>> check_dict_case({""a"": ""apple"", ""b"": ""banana""})
// true
// >>> check_dict_case({""a"": ""apple"", ""A"": ""banana"", ""B"": ""banana""})
// false
// >>> check_dict_case({""a"": ""apple"", 8: ""banana"", ""a"": ""apple""})
// false
// >>> check_dict_case({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""})
// false
// >>> check_dict_case({""STATE"": ""NC"", ""ZIP"": ""12345""})
// true
function check_dict_case(dict){
","function check_dict_case(dict) {
    const keys = Object.keys(dict);

    if (keys.length === 0) return false;

    const allLowerCase = keys.every(key => typeof key === 'string' && key === key.toLowerCase());
    const allUpperCase = keys.every(key => typeof key === 'string' && key === key.toUpperCase());

    return allLowerCase || allUpperCase;
}","const assert = require('node:assert');


function test() {
  let candidate = check_dict_case;
  assert.deepEqual(candidate({""p"": ""pineapple"", ""b"": ""banana""}),true);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""A"": ""banana"", ""B"": ""banana""}),false);
  assert.deepEqual(candidate({""p"": ""pineapple"", ""5"": ""banana"", ""a"": ""apple""}),false);
  assert.deepEqual(candidate({""Name"": ""John"", ""Age"": ""36"", ""City"": ""Houston""}),false);
  assert.deepEqual(candidate({""STATE"": ""NC"", ""ZIP"": ""12345""}),true);
  assert.deepEqual(candidate({""fruit"": ""Orange"", ""taste"": ""Sweet""}),true);
  assert.deepEqual(candidate({}),false);
}

test();"
HumanEval_96,spa_Latn,js,"/ por ejemplo: / enteros que son números primos y menores que n. / Implementar una función que toma un entero no negativo y devuelve una matriz de la primera n // >>> count_up_to(5)
// [2, 3]
// >>> count_up_to(11)
// [2, 3, 5, 7]
// >>> count_up_to(0)
// []
// >>> count_up_to(20)
// [2, 3, 5, 7, 11, 13, 17, 19]
// >>> count_up_to(1)
// []
// >>> count_up_to(18)
// [2, 3, 5, 7, 11, 13, 17]
function count_up_to(n){
","function count_up_to(n) {
    function isPrime(num) {
        if (num < 2) return false;
        for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {
            if (num % i === 0) return false;
        }
        return true;
    }

    const primes = [];
    for (let i = 2; i < n; i++) {
        if (isPrime(i)) {
            primes.push(i);
        }
    }
    return primes;
}","const assert = require('node:assert');


function test() {
  let candidate = count_up_to;
  assert.deepEqual(candidate(5),[2, 3]);
  assert.deepEqual(candidate(6),[2, 3, 5]);
  assert.deepEqual(candidate(7),[2, 3, 5]);
  assert.deepEqual(candidate(10),[2, 3, 5, 7]);
  assert.deepEqual(candidate(0),[]);
  assert.deepEqual(candidate(22),[2, 3, 5, 7, 11, 13, 17, 19]);
  assert.deepEqual(candidate(1),[]);
  assert.deepEqual(candidate(18),[2, 3, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(47),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
  assert.deepEqual(candidate(101),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
}

test();"
HumanEval_97,spa_Latn,js,"/ Ejemplos: / Asumir que la entrada es siempre válida. / el producto de sus dígitos unitarios. /Complete la función que toma dos enteros y devuelve // >>> multiply(148, 412)
// 16
// >>> multiply(19, 28)
// 72
// >>> multiply(2020, 1851)
// 0
// >>> multiply(14, -15)
// 20
function multiply(a, b){
","function multiply(a, b) {
    // Get the absolute value of each number
    a = Math.abs(a);
    b = Math.abs(b);

    // Extract the unit digit of each number
    let unitDigitA = a % 10;
    let unitDigitB = b % 10;

    // Return the product of the unit digits
    return unitDigitA * unitDigitB;
}","const assert = require('node:assert');


function test() {
  let candidate = multiply;
  assert.deepEqual(candidate(148, 412),16);
  assert.deepEqual(candidate(19, 28),72);
  assert.deepEqual(candidate(2020, 1851),0);
  assert.deepEqual(candidate(14, -15),20);
  assert.deepEqual(candidate(76, 67),42);
  assert.deepEqual(candidate(17, 27),49);
  assert.deepEqual(candidate(0, 1),0);
  assert.deepEqual(candidate(0, 0),0);
}

test();"
HumanEval_98,spa_Latn,js,"Por ejemplo:/Dada una cadena s, cuenta el número de vocales mayúsculas en índices pares. // >>> count_upper(""aBCdEf"")
// 1
// >>> count_upper(""abcdefg"")
// 0
// >>> count_upper(""dBBE"")
// 0
function count_upper(s){
","function count_upper(s) {
    const vowels = new Set(['A', 'E', 'I', 'O', 'U']);
    let count = 0;
    for (let i = 0; i < s.length; i += 2) {
        if (vowels.has(s[i])) {
            count++;
        }
    }
    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = count_upper;
  assert.deepEqual(candidate(""aBCdEf""),1);
  assert.deepEqual(candidate(""abcdefg""),0);
  assert.deepEqual(candidate(""dBBE""),0);
  assert.deepEqual(candidate(""B""),0);
  assert.deepEqual(candidate(""U""),1);
  assert.deepEqual(candidate(""""),0);
  assert.deepEqual(candidate(""EEEE""),2);
}

test();"
HumanEval_99,spa_Latn,js,"/ Ejemplos / de dos enteros, redondearlo lejos de cero. / y devuelve el número entero más cercano a él. Si el número es equidistante /Crear una función que toma un valor (cadena) que representa un número // >>> closest_integer(""10"")
// 10
// >>> closest_integer(""15.3"")
// 15
// Note:
// Rounding away from zero means that if the given number is equidistant
// from two integers, the one you should return is the one that is the
// farthest from zero. For example closest_integer(""14.5"") should
// return 15 and closest_integer(""-14.5"") should return -15.
function closest_integer(value){
","function closest_integer(value) {
    let num = parseFloat(value);
    if (num > 0) {
        return Math.floor(num + 0.5);
    } else {
        return Math.ceil(num - 0.5);
    }
}","const assert = require('node:assert');


function test() {
  let candidate = closest_integer;
  assert.deepEqual(candidate(""10""),10);
  assert.deepEqual(candidate(""14.5""),15);
  assert.deepEqual(candidate(""-15.5""),-16);
  assert.deepEqual(candidate(""15.3""),15);
  assert.deepEqual(candidate(""0""),0);
}

test();"
HumanEval_100,spa_Latn,js,"/ Ejemplos: / i representa el número de piedras en el nivel (i+1). / Devuelve el número de piedras en cada nivel en una matriz, donde el elemento en el índice / - el siguiente número par si n es par. / - el siguiente número impar si n es impar. El número de piedras en el siguiente nivel es:El primer nivel tiene n piedras./Dado un entero positivo n, tienes que hacer una pila de n niveles de piedras. // >>> make_a_pile(3)
// [3, 5, 7]
function make_a_pile(n){
","function make_a_pile(n) {
    const pile = [];
    let currentStones = n;
    
    for (let i = 0; i < n; i++) {
        pile.push(currentStones);
        currentStones += (currentStones % 2 === 0) ? 2 : 2;
    }

    return pile;
}","const assert = require('node:assert');


function test() {
  let candidate = make_a_pile;
  assert.deepEqual(candidate(3),[3, 5, 7]);
  assert.deepEqual(candidate(4),[4, 6, 8, 10]);
  assert.deepEqual(candidate(5),[5, 7, 9, 11, 13]);
  assert.deepEqual(candidate(6),[6, 8, 10, 12, 14, 16]);
  assert.deepEqual(candidate(8),[8, 10, 12, 14, 16, 18, 20, 22]);
}

test();"
HumanEval_101,spa_Latn,js,"Por ejemplo:/ para dividir la cadena en palabras y devolver una matriz de las palabras. Se le dará una cadena de palabras separadas por comas o espacios.// >>> words_string(""Hi, my name is John"")
// [""Hi"", ""my"", ""name"", ""is"", ""John""]
// >>> words_string(""One, two, three, four, five, six"")
// [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
function words_string(s){
","function words_string(s) {
    // Split the string by removing commas and spaces, filter out any empty strings
    return s.split(/[\s,]+/).filter(Boolean);
}","const assert = require('node:assert');


function test() {
  let candidate = words_string;
  assert.deepEqual(candidate(""Hi, my name is John""),[""Hi"", ""my"", ""name"", ""is"", ""John""]);
  assert.deepEqual(candidate(""One, two, three, four, five, six""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""Hi, my name""),[""Hi"", ""my"", ""name""]);
  assert.deepEqual(candidate(""One,, two, three, four, five, six,""),[""One"", ""two"", ""three"", ""four"", ""five"", ""six""]);
  assert.deepEqual(candidate(""""),[]);
  assert.deepEqual(candidate(""ahmed     , gamal""),[""ahmed"", ""gamal""]);
}

test();"
HumanEval_102,spa_Latn,js,"Por ejemplo:/ no hay tal número, entonces la función debe devolver -1. / mayor número entero par que está en el rango [x, y] inclusive. Si /Esta función toma dos números positivos x y y devuelve el // >>> choose_num(12, 15)
// 14
// >>> choose_num(13, 12)
// -1
function choose_num(x, y){
","function choose_num(x, y) {
    if (x > y) {
        return -1;
    }
    for (let i = y; i >= x; i--) {
        if (i % 2 === 0) {
            return i;
        }
    }
    return -1;
}","const assert = require('node:assert');


function test() {
  let candidate = choose_num;
  assert.deepEqual(candidate(12, 15),14);
  assert.deepEqual(candidate(13, 12),-1);
  assert.deepEqual(candidate(33, 12354),12354);
  assert.deepEqual(candidate(5234, 5233),-1);
  assert.deepEqual(candidate(6, 29),28);
  assert.deepEqual(candidate(27, 10),-1);
  assert.deepEqual(candidate(7, 7),-1);
  assert.deepEqual(candidate(546, 546),546);
}

test();"
HumanEval_103,spa_Latn,js,"/ Ejemplo: / Si n es mayor que m, devuelve -1. / Redondear la respuesta al número entero más cercano y convertirlo a binario. / media de los enteros de n a m (incluidos n y m). /Se le dan dos enteros positivos n y m, y su tarea es calcular el // >>> rounded_avg(1, 5)
// ""0b11""
// >>> rounded_avg(7, 5)
// -1
// >>> rounded_avg(10, 20)
// ""0b1111""
// >>> rounded_avg(20, 33)
// ""0b11010""
function rounded_avg(n, m){
","function rounded_avg(n, m) {
    if (n > m) {
        return -1;
    }
    
    let sum = 0;
    let count = 0;
    
    for (let i = n; i <= m; i++) {
        sum += i;
        count++;
    }
    
    let average = sum / count;
    let roundedAverage = Math.round(average);
    return ""0b"" + roundedAverage.toString(2);
}

// Example Usage
console.log(rounded_avg(1, 5));   // ""0b11""
console.log(rounded_avg(7, 5));   // -1
console.log(rounded_avg(10, 20)); // ""0b1111""
console.log(rounded_avg(20, 33)); // ""0b11010""","const assert = require('node:assert');


function test() {
  let candidate = rounded_avg;
  assert.deepEqual(candidate(1, 5),""0b11"");
  assert.deepEqual(candidate(7, 13),""0b1010"");
  assert.deepEqual(candidate(964, 977),""0b1111001010"");
  assert.deepEqual(candidate(996, 997),""0b1111100100"");
  assert.deepEqual(candidate(560, 851),""0b1011000010"");
  assert.deepEqual(candidate(185, 546),""0b101101110"");
  assert.deepEqual(candidate(362, 496),""0b110101101"");
  assert.deepEqual(candidate(350, 902),""0b1001110010"");
  assert.deepEqual(candidate(197, 233),""0b11010111"");
  assert.deepEqual(candidate(7, 5),-1);
  assert.deepEqual(candidate(5, 1),-1);
  assert.deepEqual(candidate(5, 5),""0b101"");
}

test();"
HumanEval_104,spa_Latn,js,"Por ejemplo:/ Nota: La matriz devuelta debe ordenarse en orden creciente. / elementos que no tiene ningún dígito par. / Dado un conjunto de enteros positivos x. devuelve un conjunto ordenado de todos los // >>> unique_digits([15, 33, 1422, 1])
// [1, 15, 33]
// >>> unique_digits([152, 323, 1422, 10])
// []
function unique_digits(x){
","function unique_digits(x) {
    return x.filter(num => {
        return !num.toString().split('').some(digit => digit % 2 === 0);
    }).sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = unique_digits;
  assert.deepEqual(candidate([15, 33, 1422, 1]),[1, 15, 33]);
  assert.deepEqual(candidate([152, 323, 1422, 10]),[]);
  assert.deepEqual(candidate([12345, 2033, 111, 151]),[111, 151]);
  assert.deepEqual(candidate([135, 103, 31]),[31, 135]);
}

test();"
HumanEval_105,spa_Latn,js,"Por ejemplo:/ ""Uno"", ""Dos"", ""Tres"", ""Cuatro"", ""Cinco"", ""Seis"", ""Siete"", ""Ocho"", ""Nueve"".  El hombre de la noche/ invertir la matriz resultante, y luego reemplazar cada dígito por su nombre correspondiente de / Dado un conjunto de enteros, ordenar los enteros que están entre 1 y 9 inclusive, // >>> by_length([2, 1, 1, 4, 5, 8, 2, 3])
// [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
// If the array is empty, return an empty array:
// >>> by_length([])
// []
// If the array has any strange number ignore it:
// >>> by_length([1, -1, 55])
// [""One""]
function by_length(arr){
","function by_length(arr) {
  const numberNames = [
    ""One"", ""Two"", ""Three"", ""Four"", ""Five"",
    ""Six"", ""Seven"", ""Eight"", ""Nine""
  ];

  return arr.filter(num => num >= 1 && num <= 9)
            .sort((a, b) => a - b)
            .reverse()
            .map(num => numberNames[num - 1]);
}","const assert = require('node:assert');


function test() {
  let candidate = by_length;
  assert.deepEqual(candidate([2, 1, 1, 4, 5, 8, 2, 3]),[""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -1, 55]),[""One""]);
  assert.deepEqual(candidate([1, -1, 3, 2]),[""Three"", ""Two"", ""One""]);
  assert.deepEqual(candidate([9, 4, 8]),[""Nine"", ""Eight"", ""Four""]);
}

test();"
HumanEval_106,spa_Latn,js,"/ Ejemplo: / el factorial de i es la multiplicación de los números de 1 a i (1 * 2 * ... * i). /i comienza desde el 1. / o la suma de los números de 1 a i de lo contrario. / y devuelve una matriz de tamaño n, de tal manera que el valor del elemento en el índice i es el factorial de i si i es par / Implementar la función f que toma n como un parámetro, // >>> f(5)
// [1, 2, 6, 24, 15]
function f(n){
","function f(n) {
    function factorial(num) {
        let result = 1;
        for (let i = 2; i <= num; i++) {
            result *= i;
        }
        return result;
    }

    function sumUpTo(num) {
        return (num * (num + 1)) / 2; // Sum of first num natural numbers
    }

    let result = [];
    for (let i = 1; i <= n; i++) {
        if (i % 2 === 0) {
            result.push(factorial(i));
        } else {
            result.push(sumUpTo(i));
        }
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = f;
  assert.deepEqual(candidate(5),[1, 2, 6, 24, 15]);
  assert.deepEqual(candidate(7),[1, 2, 6, 24, 15, 720, 28]);
  assert.deepEqual(candidate(1),[1]);
  assert.deepEqual(candidate(3),[1, 2, 6]);
}

test();"
HumanEval_107,spa_Latn,js,"Ejemplo 1:/ palíndromos enteros que caen dentro del rango ((1, n), inclusive. / Dado un entero positivo n, devuelve un array que tiene el número de pares y impares // >>> even_odd_palindrome(3)
// [1, 2]
// Explanation:
// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
// Example 2:
// >>> even_odd_palindrome(12)
// [4, 6]
// Explanation:
// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
// Note:
// 1. 1 <= n <= 10^3
// 2. returned array has the number of even and odd integer palindromes respectively.
function even_odd_palindrome(n){
","function even_odd_palindrome(n) {
    function isPalindrome(num) {
        let str = num.toString();
        return str === str.split('').reverse().join('');
    }

    let evenCount = 0;
    let oddCount = 0;

    for (let i = 1; i <= n; i++) {
        if (isPalindrome(i)) {
            if (i % 2 === 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return [evenCount, oddCount];
}","const assert = require('node:assert');


function test() {
  let candidate = even_odd_palindrome;
  assert.deepEqual(candidate(123),[8, 13]);
  assert.deepEqual(candidate(12),[4, 6]);
  assert.deepEqual(candidate(3),[1, 2]);
  assert.deepEqual(candidate(63),[6, 8]);
  assert.deepEqual(candidate(25),[5, 6]);
  assert.deepEqual(candidate(19),[4, 6]);
  assert.deepEqual(candidate(9),[4, 5]);
  assert.deepEqual(candidate(1),[0, 1]);
}

test();"
HumanEval_108,spa_Latn,js,"/ por ejemplo -123 tiene los dígitos firmados -1, 2 y 3. / Si un número es negativo, entonces su primer dígito firmado será negativo: / el número de elementos cuya suma de dígitos sea > 0. /Escribe una función count_nums que toma una matriz de enteros y devuelve // >>> count_nums([])
// 0
// >>> count_nums([-1, 11, -11])
// 1
// >>> count_nums([1, 1, 2])
// 3
function count_nums(arr){
","function count_nums(arr) {
    return arr.reduce((count, num) => {
        let str = num.toString();
        let sum = 0;
        for (let i = 0; i < str.length; i++) {
            if (i === 0 && str[i] === '-') {
                continue;
            }
            sum += parseInt(str[i]);
        }
        if (num < 0) {
            sum += 2 * parseInt(str[1]); // Adjust for the negative signed digit
        }
        return sum > 0 ? count + 1 : count;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = count_nums;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([-1, -2, 0]),0);
  assert.deepEqual(candidate([1, 1, 2, -2, 3, 4, 5]),6);
  assert.deepEqual(candidate([1, 6, 9, -6, 0, 1, 5]),5);
  assert.deepEqual(candidate([1, 100, 98, -7, 1, -1]),4);
  assert.deepEqual(candidate([12, 23, 34, -45, -56, 0]),5);
  assert.deepEqual(candidate([0, 1]),1);
  assert.deepEqual(candidate([1]),1);
}

test();"
HumanEval_109,spa_Latn,js,"Por ejemplo:/ Nota: La matriz dada tiene garantizado que tiene elementos únicos. / Si la matriz dada está vacía entonces devuelve true. / entonces devuelve verdadero o devuelve falso. / Si es posible obtener la matriz ordenada mediante la realización de la operación anterior / la posición inicial en la matriz, es decir, el índice 0. El último elemento de la matriz se moverá a / Una operación de desplazamiento a la derecha significa desplazar todos los elementos de la matriz por uno / Se le permite realizar la operación de cambio a la derecha cualquier número de veces. / la siguiente operación en el conjunto dado: / es posible obtener una matriz ordenada en orden no decreciente realizando / números en la matriz se ordenarán al azar. Su tarea es determinar si /Tenemos una matriz 'arr' de N enteros arr[1], arr[2], ..., arr[N].El // >>> move_one_ball([3, 4, 5, 1, 2])
// true
// Explanation: By performin 2 right shift operations, non-decreasing order can
// be achieved for the given array.
// >>> move_one_ball([3, 5, 4, 1, 2])
// false
// Explanation:It is not possible to get non-decreasing order for the given
// array by performing any number of right shift operations.
function move_one_ball(arr){
","function move_one_ball(arr) {
    // If the array is empty, it's trivially sorted
    if (arr.length === 0) return true;

    // Count the number of positions where the next element is smaller than the current one
    let dropCount = 0;
    let n = arr.length;

    for (let i = 0; i < n; i++) {
        if (arr[i] > arr[(i + 1) % n]) {
            dropCount++;
        }
    }

    // If the drop count is more than 1, it means more than one drop is there
    // and thus we cannot sort it with right shifts
    return dropCount <= 1;
}","const assert = require('node:assert');


function test() {
  let candidate = move_one_ball;
  assert.deepEqual(candidate([3, 4, 5, 1, 2]),true);
  assert.deepEqual(candidate([3, 5, 10, 1, 2]),true);
  assert.deepEqual(candidate([4, 3, 1, 2]),false);
  assert.deepEqual(candidate([3, 5, 4, 1, 2]),false);
  assert.deepEqual(candidate([]),true);
}

test();"
HumanEval_110,spa_Latn,js,"Por ejemplo:/ De lo contrario, devuelve ""NO"". / todos los elementos de lst1 para ser incluso, devuelve ""SI"". / Si es posible intercambiar elementos entre el lst1 y lst2 para hacer / No hay límite en el número de elementos intercambiados entre lst1 y lst2. / entre ellos para hacer lst1 una matriz de sólo números pares. / y determina si es posible realizar un intercambio de elementos /En este problema, se va a implementar una función que toma dos matrices de números, // >>> exchange([1, 2, 3, 4], [1, 2, 3, 4])
// ""YES""
// >>> exchange([1, 2, 3, 4], [1, 5, 3, 4])
// ""NO""
// It is assumed that the input arrays will be non-empty.
function exchange(lst1, lst2){
","function exchange(lst1, lst2) {
    // Check if lst1 already consists of only even numbers
    let allEvenLst1 = lst1.every(num => num % 2 === 0);
    if (allEvenLst1) return ""YES"";
    
    // Check if there's at least one even number in lst2
    let hasEvenInLst2 = lst2.some(num => num % 2 === 0);
    
    // If there is at least one even number in lst2, it's possible to perform an exchange
    // to make all elements in lst1 even
    if (hasEvenInLst2) return ""YES"";
    
    // If no conditions above are met, it's not possible to make lst1 all even
    return ""NO"";
}","const assert = require('node:assert');


function test() {
  let candidate = exchange;
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 2, 3, 4]),""YES"");
  assert.deepEqual(candidate([1, 2, 3, 4], [1, 5, 3, 4]),""NO"");
  assert.deepEqual(candidate([1, 2, 3, 4], [2, 1, 4, 3]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 4]),""YES"");
  assert.deepEqual(candidate([5, 7, 3], [2, 6, 3]),""NO"");
  assert.deepEqual(candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]),""NO"");
  assert.deepEqual(candidate([100, 200], [200, 200]),""YES"");
}

test();"
HumanEval_111,spa_Latn,js,"/ Ejemplo: Si varias letras tienen la misma ocurrencia, devuelve todas./ de la letra con más repeticiones y que contiene el número correspondiente. /Dada una cadena que representa un espacio separado letras minúsculas, devolver un objeto // >>> histogram(""a b c"")
// {""a"": 1, ""b"": 1, ""c"": 1}
// >>> histogram(""a b b a"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""a b c a b"")
// {""a"": 2, ""b"": 2}
// >>> histogram(""b b b b a"")
// {""b"": 4}
// >>> histogram("""")
// {}
function histogram(test){
","function histogram(test) {
  if (!test) return {};
  
  const letters = test.split(' ');
  const letterCount = {};
  
  for (let letter of letters) {
    if (letterCount[letter]) {
      letterCount[letter]++;
    } else {
      letterCount[letter] = 1;
    }
  }
  
  let maxCount = 0;
  for (let count of Object.values(letterCount)) {
    if (count > maxCount) {
      maxCount = count;
    }
  }
  
  const result = {};
  for (let [letter, count] of Object.entries(letterCount)) {
    if (count === maxCount) {
      result[letter] = count;
    }
  }
  
  return result;
}","const assert = require('node:assert');


function test() {
  let candidate = histogram;
  assert.deepEqual(candidate(""a b b a""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c a b""),{""a"": 2, ""b"": 2});
  assert.deepEqual(candidate(""a b c d g""),{""a"": 1, ""b"": 1, ""c"": 1, ""d"": 1, ""g"": 1});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""b b b b a""),{""b"": 4});
  assert.deepEqual(candidate(""r t g""),{""r"": 1, ""t"": 1, ""g"": 1});
  assert.deepEqual(candidate(""""),{});
  assert.deepEqual(candidate(""a""),{""a"": 1});
}

test();"
HumanEval_112,spa_Latn,js,"- Ejemplo ./ Debe devolver una matriz que contenga la cadena de resultados y true/false para la comprobación. / Una cadena se llama palíndromo si se lee al mismo tiempo hacia atrás como hacia delante. / entonces compruebe si la cadena de resultados es palíndromo. / Nos dan dos cadenas s y c, tienes que eliminar todos los caracteres en s que son iguales a cualquier carácter en c - ¿Qué es lo que quieres?// >>> reverse_delete(""abcde"", ""ae"")
// [""bcd"", false]
// >>> reverse_delete(""abcdef"", ""b"")
// [""acdef"", false]
// >>> reverse_delete(""abcdedcba"", ""ab"")
// [""cdedc"", true]
function reverse_delete(s, c){
","function reverse_delete(s, c) {
    let result = '';
    // Create a set of characters to be deleted
    const deleteChars = new Set(c);
    
    // Construct the result string excluding the characters in c
    for (let char of s) {
        if (!deleteChars.has(char)) {
            result += char;
        }
    }
    
    // Check if the result string is a palindrome
    const isPalindrome = result === result.split('').reverse().join('');
    
    return [result, isPalindrome];
}","const assert = require('node:assert');


function test() {
  let candidate = reverse_delete;
  assert.deepEqual(candidate(""abcde"", ""ae""),[""bcd"", false]);
  assert.deepEqual(candidate(""abcdef"", ""b""),[""acdef"", false]);
  assert.deepEqual(candidate(""abcdedcba"", ""ab""),[""cdedc"", true]);
  assert.deepEqual(candidate(""dwik"", ""w""),[""dik"", false]);
  assert.deepEqual(candidate(""a"", ""a""),["""", true]);
  assert.deepEqual(candidate(""abcdedcba"", """"),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""abcdedcba"", ""v""),[""abcdedcba"", true]);
  assert.deepEqual(candidate(""vabba"", ""v""),[""abba"", true]);
  assert.deepEqual(candidate(""mamma"", ""mia""),["""", true]);
}

test();"
HumanEval_113,spa_Latn,js,"/ de dígitos impares en la cadena i'th de la entrada. / cadena i de la entrada. "" donde todas las i deben ser reemplazadas por el número / Cada elemento i de la salida debe ser ""el número de elementos impares en el / Dado un conjunto de cadenas, donde cada cadena consiste sólo de dígitos, devuelve un conjunto. // >>> odd_count([""1234567""])
// [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
// >>> odd_count([""3"", ""11111111""])
// [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
function odd_count(lst){
","function odd_count(lst) {
    return lst.map(str => {
        const oddCount = Array.from(str).filter(ch => parseInt(ch) % 2 !== 0).length;
        let sentence = ""the number of odd elements in the string i of the input."";
        return sentence.replace(/i/g, oddCount.toString());
    });
}","const assert = require('node:assert');


function test() {
  let candidate = odd_count;
  assert.deepEqual(candidate([""1234567""]),[""the number of odd elements 4n the str4ng 4 of the 4nput.""]);
  assert.deepEqual(candidate([""3"", ""11111111""]),[""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""]);
  assert.deepEqual(candidate([""271"", ""137"", ""314""]),[""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""]);
}

test();"
HumanEval_114,spa_Latn,js,"- Ejemplo ./ de los números. / Dado un conjunto de enteros n, encuentre la suma mínima de cualquier sub-orden no vacío // >>> minSubArraySum([2, 3, 4, 1, 2, 4])
// 1
// >>> minSubArraySum([-1, -2, -3])
// -6
function minSubArraySum(nums){
","function minSubArraySum(nums) {
    let minSum = nums[0];
    let currentSum = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        if (currentSum > 0) {
            currentSum = nums[i];
        } else {
            currentSum += nums[i];
        }
        minSum = Math.min(minSum, currentSum);
    }
    
    return minSum;
}","const assert = require('node:assert');


function test() {
  let candidate = minSubArraySum;
  assert.deepEqual(candidate([2, 3, 4, 1, 2, 4]),1);
  assert.deepEqual(candidate([-1, -2, -3]),-6);
  assert.deepEqual(candidate([-1, -2, -3, 2, -10]),-14);
  assert.deepEqual(candidate([-9999999999999999]),-9999999999999999);
  assert.deepEqual(candidate([0, 10, 20, 1000000]),0);
  assert.deepEqual(candidate([-1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([100, -1, -2, -3, 10, -5]),-6);
  assert.deepEqual(candidate([10, 11, 13, 8, 3, 4]),3);
  assert.deepEqual(candidate([100, -33, 32, -1, 0, -2]),-33);
  assert.deepEqual(candidate([-10]),-10);
  assert.deepEqual(candidate([7]),7);
  assert.deepEqual(candidate([1, -1]),-1);
}

test();"
HumanEval_115,spa_Latn,js,"Ejemplo 1:/ Saque el número de veces que necesita para bajar los cubos. / Su tarea es usar los cubos para vaciar los pozos. / y todos los cubos tienen la misma capacidad. / Cada pozo tiene un cubo correspondiente que se puede utilizar para extraer agua de él, / y cada 1 en una fila representa una sola unidad de agua. Se le da una cuadrícula rectangular de pozos, cada fila representa un solo pozo.// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)
// 6
// Example 2:
// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)
// 5
// Example 3:
// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)
// 0
// Constraints:
// * all wells have the same length
// * 1 <= grid.length <= 10^2
// * 1 <= grid[:,1].length <= 10^2
// * grid[i][j] -> 0 | 1
// * 1 <= capacity <= 10
function max_fill(grid, capacity){
","function max_fill(grid, capacity) {
    let totalWater = 0;
    
    for (let row of grid) {
        for (let cell of row) {
            totalWater += cell;
        }
    }
    
    return Math.ceil(totalWater / capacity);
}","const assert = require('node:assert');


function test() {
  let candidate = max_fill;
  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);
  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);
  assert.deepEqual(candidate([[0, 0, 0], [0, 0, 0]], 5),0);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);
  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);
}

test();"
HumanEval_116,spa_Latn,js,"/ Debe ser implementado así: / Para un número similar de unos, ordenar basado en el valor decimal. / número de unos en su representación binaria en orden ascendente. /En este Kata, tienes que ordenar una matriz de enteros no negativos de acuerdo a // >>> sort_array([1, 5, 2, 3, 4])
// [1, 2, 3, 4, 5]
// >>> sort_array([-2, -3, -4, -5, -6])
// [-6, -5, -4, -3, -2]
// >>> sort_array([1, 0, 2, 3, 4])
// [0, 1, 2, 3, 4]
function sort_array(arr){
","function sort_array(arr) {
    return arr.slice().sort((a, b) => {
        const countOnes = num => num.toString(2).split('0').join('').length;
        const onesA = countOnes(a);
        const onesB = countOnes(b);
        if (onesA === onesB) {
            return a - b;
        }
        return onesA - onesB;
    });
}","const assert = require('node:assert');


function test() {
  let candidate = sort_array;
  assert.deepEqual(candidate([1, 5, 2, 3, 4]),[1, 2, 4, 3, 5]);
  assert.deepEqual(candidate([-2, -3, -4, -5, -6]),[-4, -2, -6, -5, -3]);
  assert.deepEqual(candidate([1, 0, 2, 3, 4]),[0, 1, 2, 4, 3]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]),[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);
  assert.deepEqual(candidate([3, 6, 44, 12, 32, 5]),[32, 3, 5, 6, 12, 44]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
  assert.deepEqual(candidate([2, 4, 8, 16, 32]),[2, 4, 8, 16, 32]);
}

test();"
HumanEval_117,spa_Latn,js,"/ Ejemplos: / Nota: puede asumir que la cadena de entrada contiene sólo letras y espacios. / Si la cadena s está vacía entonces la función debe devolver una matriz vacía. / n consonantes, en orden de que estas palabras aparezcan en la cadena s. / una función que devuelve una matriz de todas las palabras de la cadena s que contienen exactamente /Dada una cadena s y un número natural n, se le ha encargado implementar // >>> select_words(""Mary had a little lamb"", 4)
// [""little""]
// >>> select_words(""Mary had a little lamb"", 3)
// [""Mary"", ""lamb""]
// >>> select_words(""simple white space"", 2)
// []
// >>> select_words(""Hello world"", 4)
// [""world""]
// >>> select_words(""Uncle sam"", 3)
// [""Uncle""]
function select_words(s, n){
","function select_words(s, n) {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
    const words = s.split(' ');
    const result = [];

    for (let word of words) {
        let consonantCount = 0;
        
        for (let char of word) {
            if (!vowels.has(char)) {
                consonantCount += 1;
            }
        }

        if (consonantCount === n) {
            result.push(word);
        }
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = select_words;
  assert.deepEqual(candidate(""Mary had a little lamb"", 4),[""little""]);
  assert.deepEqual(candidate(""Mary had a little lamb"", 3),[""Mary"", ""lamb""]);
  assert.deepEqual(candidate(""simple white space"", 2),[]);
  assert.deepEqual(candidate(""Hello world"", 4),[""world""]);
  assert.deepEqual(candidate(""Uncle sam"", 3),[""Uncle""]);
  assert.deepEqual(candidate("""", 4),[]);
  assert.deepEqual(candidate(""a b c d e f"", 1),[""b"", ""c"", ""d"", ""f""]);
}

test();"
HumanEval_118,spa_Latn,js,"/ Ejemplo: / Usted puede asumir que la cadena dada contiene letra sólo en inglés. / encontrar cualquier vocal cumplió con la condición anterior. / Vocales en el principio y el final no cuentan. Vuelva cadena vacía si no lo hizo / dos consonantes desde el lado derecho de la palabra (sensible a la casilla). Se le da una palabra, su tarea es encontrar la vocal más cercana que se interponga entre ellas.// >>> get_closest_vowel(""yogurt"")
// ""u""
// >>> get_closest_vowel(""FULL"")
// ""U""
// >>> get_closest_vowel(""quick"")
// """"
// >>> get_closest_vowel(""ab"")
// """"
function get_closest_vowel(word){
","function get_closest_vowel(word) {
    const vowels = ""aeiouAEIOU"";

    for (let i = word.length - 2; i > 0; i--) {
        if (vowels.includes(word[i]) && 
            !vowels.includes(word[i - 1]) && 
            !vowels.includes(word[i + 1])) {
            return word[i];
        }
    }

    return """";
}","const assert = require('node:assert');


function test() {
  let candidate = get_closest_vowel;
  assert.deepEqual(candidate(""yogurt""),""u"");
  assert.deepEqual(candidate(""full""),""u"");
  assert.deepEqual(candidate(""easy""),"""");
  assert.deepEqual(candidate(""eAsy""),"""");
  assert.deepEqual(candidate(""ali""),"""");
  assert.deepEqual(candidate(""bad""),""a"");
  assert.deepEqual(candidate(""most""),""o"");
  assert.deepEqual(candidate(""ab""),"""");
  assert.deepEqual(candidate(""ba""),"""");
  assert.deepEqual(candidate(""quick""),"""");
  assert.deepEqual(candidate(""anime""),""i"");
  assert.deepEqual(candidate(""Asia""),"""");
  assert.deepEqual(candidate(""Above""),""o"");
}

test();"
HumanEval_119,spa_Latn,js,"/ Ejemplos: / Devuelve 'Sí' si hay una manera de hacer una buena cadena, y devuelve 'No' de lo contrario. / ""()) "" no es así.Por ejemplo: la cadena '(()))))) ' es buena, mientras que la cadena / Una cadena S se considera buena si y sólo si todos los paréntesis en S / algún orden, que la cadena resultante será buena. / Tu trabajo es comprobar si es posible concatenar las dos cuerdas en / sólo entre paréntesis "" (("") o entre paréntesis cerradas "") "". /Se le da una matriz de dos cadenas, ambas cadenas consisten en abierto // >>> match_parens([""()("", "")""])
// ""Yes""
// >>> match_parens(["")"", "")""])
// ""No""
function match_parens(lst){
","function match_parens(lst) {
    function isBalanced(str) {
        let balance = 0;
        for (let char of str) {
            if (char === '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) return false;
        }
        return balance === 0;
    }

    const [s1, s2] = lst;
    if (isBalanced(s1 + s2) || isBalanced(s2 + s1)) {
        return 'Yes';
    }
    return 'No';
}","const assert = require('node:assert');


function test() {
  let candidate = match_parens;
  assert.deepEqual(candidate([""()("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", "")""]),""No"");
  assert.deepEqual(candidate([""(()(())"", ""())())""]),""No"");
  assert.deepEqual(candidate(["")())"", ""(()()(""]),""Yes"");
  assert.deepEqual(candidate([""(())))"", ""(()())((""]),""Yes"");
  assert.deepEqual(candidate([""()"", ""())""]),""No"");
  assert.deepEqual(candidate([""(()("", ""()))()""]),""Yes"");
  assert.deepEqual(candidate([""(((("", ""((())""]),""No"");
  assert.deepEqual(candidate(["")(()"", ""(()(""]),""No"");
  assert.deepEqual(candidate(["")("", "")(""]),""No"");
  assert.deepEqual(candidate([""("", "")""]),""Yes"");
  assert.deepEqual(candidate(["")"", ""(""]),""Yes"");
}

test();"
HumanEval_120,spa_Latn,js,"Ejemplo 1:/ de longitud k con el máximo de k números en arr. / Dado un array arr de enteros y un entero positivo k, devuelve un array ordenado // >>> maximum([-3, -4, 5], 3)
// [-4, -3, 5]
// Example 2:
// >>> maximum([4, -4, 4], 2)
// [4, 4]
// Example 3:
// >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)
// [2]
// Note:
// 1. The length of the array will be in the range of [1, 1000].
// 2. The elements in the array will be in the range of [-1000, 1000].
// 3. 0 <= k <= len(arr)
function maximum(arr, k){
","function maximum(arr, k) {
    return arr.sort((a, b) => b - a).slice(0, k).sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = maximum;
  assert.deepEqual(candidate([-3, -4, 5], 3),[-4, -3, 5]);
  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);
  assert.deepEqual(candidate([-3, 2, 1, 2, -1, -2, 1], 1),[2]);
  assert.deepEqual(candidate([123, -123, 20, 0, 1, 2, -3], 3),[2, 20, 123]);
  assert.deepEqual(candidate([-123, 20, 0, 1, 2, -3], 4),[0, 1, 2, 20]);
  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0], 7),[-13, -8, 0, 0, 3, 5, 15]);
  assert.deepEqual(candidate([-1, 0, 2, 5, 3, -10], 2),[3, 5]);
  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);
  assert.deepEqual(candidate([4, -4], 2),[-4, 4]);
  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);
  assert.deepEqual(candidate([1, 2, 3, -23, 243, -400, 0], 0),[]);
}

test();"
HumanEval_121,spa_Latn,js,"/ Ejemplos / Dado un conjunto de enteros no vacíos, devuelve la suma de todos los elementos impares que están en posiciones pares. // >>> solution([5, 8, 7, 1])
// 12
// >>> solution([3, 3, 3, 3, 3])
// 9
// >>> solution([30, 13, 24, 321])
// 0
function solution(lst){
","function solution(lst) {
    let sum = 0;
    for (let i = 0; i < lst.length; i += 2) {
        if (lst[i] % 2 !== 0) {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = solution;
  assert.deepEqual(candidate([5, 8, 7, 1]),12);
  assert.deepEqual(candidate([3, 3, 3, 3, 3]),9);
  assert.deepEqual(candidate([30, 13, 24, 321]),0);
  assert.deepEqual(candidate([5, 9]),5);
  assert.deepEqual(candidate([2, 4, 8]),0);
  assert.deepEqual(candidate([30, 13, 23, 32]),23);
  assert.deepEqual(candidate([3, 13, 2, 9]),3);
}

test();"
HumanEval_122,spa_Latn,js,"/ Ejemplo: / la suma de los elementos con como máximo dos dígitos de los primeros k elementos de arr. / Dado un conjunto no vacío de enteros arr y un entero k, devuelve // >>> add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)
// 24
// Constraints:
// 1. 1 <= len(arr) <= 100
// 2. 1 <= k <= len(arr)
function add_elements(arr, k){
","function add_elements(arr, k) {
    let sum = 0;
    for (let i = 0; i < k; i++) {
        if (Math.abs(arr[i]) < 100) {
            sum += arr[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = add_elements;
  assert.deepEqual(candidate([1, -2, -3, 41, 57, 76, 87, 88, 99], 3),-4);
  assert.deepEqual(candidate([111, 121, 3, 4000, 5, 6], 2),0);
  assert.deepEqual(candidate([11, 21, 3, 90, 5, 6, 7, 8, 9], 4),125);
  assert.deepEqual(candidate([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4),24);
  assert.deepEqual(candidate([1], 1),1);
}

test();"
HumanEval_123,spa_Latn,js,"/ get_odd_collatz(5) devuelve [1, 5] # La secuencia de collatz para 5 es [5, 16, 8, 4, 2, 1], por lo que los números impares son sólo 1, y 5. Por ejemplo:/ 2. ordenado por orden creciente./ 1. Collatz(1) es [1]. / Nota: / término más 1. La conjetura es que no importa qué valor de n, la secuencia siempre alcanzará 1. Si el término anterior es impar, el siguiente término es 3 veces el anterior./ término anterior de la siguiente manera: si el término anterior es par, el término siguiente es la mitad de / de la siguiente manera: comienza con cualquier entero positivo n. Luego cada término se obtiene de la La conjetura de Collatz es una conjetura en matemáticas que concierne a una secuencia definida ./ Dado un entero positivo n, devuelve una matriz ordenada que tiene los números impares en la secuencia de collatz. // >>> get_odd_collatz(5)
// [1, 5]
function get_odd_collatz(n){
","function get_odd_collatz(n) {
    let collatzSequence = [];
    while (n !== 1) {
        if (n % 2 !== 0) {
            collatzSequence.push(n);
        }
        n = n % 2 === 0 ? n / 2 : 3 * n + 1;
    }
    collatzSequence.push(1); // Include 1 as it's part of the sequence and is odd
    return collatzSequence.sort((a, b) => a - b);
}","const assert = require('node:assert');


function test() {
  let candidate = get_odd_collatz;
  assert.deepEqual(candidate(14),[1, 5, 7, 11, 13, 17]);
  assert.deepEqual(candidate(5),[1, 5]);
  assert.deepEqual(candidate(12),[1, 3, 5]);
  assert.deepEqual(candidate(1),[1]);
}

test();"
HumanEval_124,spa_Latn,js,"/ 4. La fecha debe tener el formato: mm-dd-aaaa / 3. Los meses no deben ser menores de 1 o mayores de 12./ 2. El número de días no es menor de 1 o mayor de 31 días para los meses 1,3,5,7,8,10,12. Y el número de días no es menor de 1 o mayor de 30 días para los meses 4,6,9,11. Y, el número de días no es menor de 1 o mayor de 29 para el mes 2. / 1. La cadena de fecha no está vacía. / La fecha es válida si se cumplen todas las siguientes reglas: / devuelve verdadero si la fecha es válida de lo contrario falsa. /Tienes que escribir una función que valida una cadena de fecha dada y // >>> valid_date(""03-11-2000"")
// true
// >>> valid_date(""15-01-2012"")
// false
// >>> valid_date(""04-0-2040"")
// false
// >>> valid_date(""06-04-2020"")
// true
// >>> valid_date(""06/04/2020"")
// false
function valid_date(date){
","function valid_date(date) {
    if (!date) return false;
    
    // Regular expression to match the date pattern mm-dd-yyyy
    const datePattern = /^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\d{4}$/;
    if (!datePattern.test(date)) return false;

    // Split the date into parts
    const [month, day, year] = date.split('-').map(Number);

    // Check the valid number of days per month
    if (month === 2) {
        // Check for February, normally 28 max days, 29 if leap year
        const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        if (day > 29 || (day === 29 && !isLeapYear)) return false;
    } else if ([4, 6, 9, 11].includes(month)) {
        // April, June, September, November have 30 max days
        if (day > 30) return false;
    } else {
        // Other months have 31 max days
        if (day > 31) return false;
    }

    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = valid_date;
  assert.deepEqual(candidate(""03-11-2000""),true);
  assert.deepEqual(candidate(""15-01-2012""),false);
  assert.deepEqual(candidate(""04-0-2040""),false);
  assert.deepEqual(candidate(""06-04-2020""),true);
  assert.deepEqual(candidate(""01-01-2007""),true);
  assert.deepEqual(candidate(""03-32-2011""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""04-31-3000""),false);
  assert.deepEqual(candidate(""06-06-2005""),true);
  assert.deepEqual(candidate(""21-31-2000""),false);
  assert.deepEqual(candidate(""04-12-2003""),true);
  assert.deepEqual(candidate(""04122003""),false);
  assert.deepEqual(candidate(""20030412""),false);
  assert.deepEqual(candidate(""2003-04""),false);
  assert.deepEqual(candidate(""2003-04-12""),false);
  assert.deepEqual(candidate(""04-2003""),false);
}

test();"
HumanEval_125,spa_Latn,js,"/ Ejemplos / alfabeto, orden a) = 0, orden b) = 1, ... orden z) = 25 / debe dividirse en comas ',' si no existe ninguna coma debe devolver el número de letras minúsculas con orden impar en el /Dada una cadena de palabras, devuelve una matriz de palabras divididas en espacios en blanco, si no existen espacios en blanco en el texto que desea // >>> split_words(""Hello world!"")
// [""Hello"", ""world!""]
// >>> split_words(""Hello,world!"")
// [""Hello"", ""world!""]
// >>> split_words(""abcdef"")
// 3
function split_words(txt){
","function split_words(txt) {
    if (/\s/.test(txt)) {
        // Split on whitespace if it exists
        return txt.split(/\s+/);
    } else if (/,/.test(txt)) {
        // Split on commas if no whitespace exists
        return txt.split(',');
    } else {
        // Return count of lowercase letters with odd order in the alphabet
        let oddOrderCount = 0;
        for (let i = 0; i < txt.length; i++) {
            let char = txt[i];
            if (char >= 'a' && char <= 'z') {
                let order = char.charCodeAt(0) - 'a'.charCodeAt(0);
                if (order % 2 !== 0) {
                    oddOrderCount++;
                }
            }
        }
        return oddOrderCount;
    }
}","const assert = require('node:assert');


function test() {
  let candidate = split_words;
  assert.deepEqual(candidate(""Hello world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello,world!""),[""Hello"", ""world!""]);
  assert.deepEqual(candidate(""Hello world,!""),[""Hello"", ""world,!""]);
  assert.deepEqual(candidate(""Hello,Hello,world !""),[""Hello,Hello,world"", ""!""]);
  assert.deepEqual(candidate(""abcdef""),3);
  assert.deepEqual(candidate(""aaabb""),2);
  assert.deepEqual(candidate(""aaaBb""),1);
  assert.deepEqual(candidate(""""),0);
}

test();"
HumanEval_126,spa_Latn,js,"/ Ejemplos / número, devuelve false. Asume que no hay números negativos y sólo enteros. Si la matriz tiene más de 1 duplicado de la misma /Dado un conjunto de números, devuelve si están ordenados o no.// >>> is_sorted([5])
// true
// >>> is_sorted([1, 2, 3, 4, 5])
// true
// >>> is_sorted([1, 3, 2, 4, 5])
// false
// >>> is_sorted([1, 2, 3, 4, 5, 6])
// true
// >>> is_sorted([1, 2, 3, 4, 5, 6, 7])
// true
// >>> is_sorted([1, 3, 2, 4, 5, 6, 7])
// false
// >>> is_sorted([1, 2, 2, 3, 3, 4])
// true
// >>> is_sorted([1, 2, 2, 2, 3, 4])
// false
function is_sorted(lst){
","function is_sorted(lst) {
    if (lst.length <= 1) return true;

    for (let i = 0; i < lst.length - 1; i++) {
        if (lst[i] > lst[i + 1]) {
            return false;
        }
        if (lst[i] === lst[i + 1]) {
            // Check if more than 1 duplicate by looking two steps ahead
            if (i + 2 < lst.length && lst[i] === lst[i + 2]) {
                return false;
            }
        }
    }
    return true;
}","const assert = require('node:assert');


function test() {
  let candidate = is_sorted;
  assert.deepEqual(candidate([5]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5]),false);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, 7]),false);
  assert.deepEqual(candidate([]),true);
  assert.deepEqual(candidate([1]),true);
  assert.deepEqual(candidate([3, 2, 1]),false);
  assert.deepEqual(candidate([1, 2, 2, 2, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);
  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);
  assert.deepEqual(candidate([1, 2, 3, 4]),true);
}

test();"
HumanEval_127,spa_Latn,js,"/ [muestras de entrada/salida]: / Si los dos intervalos no se cruzan, devuelve ""NO"". / de lo contrario, devuelve ""NO"". / Si la longitud de la intersección es un número primo, devuelve ""SÍ"", / cuya longitud es 1, que no es un número primo. / Ejemplo, la intersección de los intervalos (1, 3), (2, 4) es (2, 3) / intervalos es un número primo. / Su tarea es determinar si la longitud de la intersección de estos dos / Para cada intervalo dado, se supone que su comienzo es menor o igual a su final. / incluye tanto el principio como el final. / Los intervalos dados están cerrados lo que significa que el intervalo (inicio, fin) / donde cada intervalo es un par de enteros. Por ejemplo, intervalo = (inicio, final) = (1, 2). Se le dan dos intervalos.// >>> intersection([1, 2], [2, 3])
// ""NO""
// >>> intersection([-1, 1], [0, 4])
// ""NO""
// >>> intersection([-3, -1], [-5, 5])
// ""YES""
function intersection(interval1, interval2){
","function intersection(interval1, interval2) {
    const [start1, end1] = interval1;
    const [start2, end2] = interval2;

    // Determine the start and end of the intersection
    const startIntersection = Math.max(start1, start2);
    const endIntersection = Math.min(end1, end2);

    // Calculate the length of the intersection
    const intersectionLength = endIntersection - startIntersection;

    // Helper function to check if a number is prime
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    // Check if the length of the intersection is a prime number
    return intersectionLength > 0 && isPrime(intersectionLength) ? ""YES"" : ""NO"";
}","const assert = require('node:assert');


function test() {
  let candidate = intersection;
  assert.deepEqual(candidate([1, 2], [2, 3]),""NO"");
  assert.deepEqual(candidate([-1, 1], [0, 4]),""NO"");
  assert.deepEqual(candidate([-3, -1], [-5, 5]),""YES"");
  assert.deepEqual(candidate([-2, 2], [-4, 0]),""YES"");
  assert.deepEqual(candidate([-11, 2], [-1, -1]),""NO"");
  assert.deepEqual(candidate([1, 2], [3, 5]),""NO"");
  assert.deepEqual(candidate([1, 2], [1, 2]),""NO"");
  assert.deepEqual(candidate([-2, -2], [-3, -2]),""NO"");
}

test();"
HumanEval_128,spa_Latn,js,"/ Ejemplo: / Nota: devuelve indefinido para arr vacío. / de cada número en la matriz, representado por 1, -1 o 0. / suma de magnitudes de enteros multiplicada por el producto de todos los signos /Se le da una matriz arr de enteros y usted necesita para volver // >>> prod_signs([1, 2, 2, -4])
// 9
// >>> prod_signs([0, 1])
// 0
// >>> prod_signs([])
// undefined
function prod_signs(arr){
","function prod_signs(arr) {
    if (arr.length === 0) return undefined;

    let sumOfMagnitudes = 0;
    let productOfSigns = 1;

    for (let num of arr) {
        sumOfMagnitudes += Math.abs(num);
        productOfSigns *= (num === 0 ? 0 : Math.sign(num));
    }

    return sumOfMagnitudes * productOfSigns;
}","const assert = require('node:assert');


function test() {
  let candidate = prod_signs;
  assert.deepEqual(candidate([1, 2, 2, -4]),-9);
  assert.deepEqual(candidate([0, 1]),0);
  assert.deepEqual(candidate([1, 1, 1, 2, 3, -1, 1]),-10);
  assert.deepEqual(candidate([]),undefined);
  assert.deepEqual(candidate([2, 4, 1, 2, -1, -1, 9]),20);
  assert.deepEqual(candidate([-1, 1, -1, 1]),4);
  assert.deepEqual(candidate([-1, 1, 1, 1]),-4);
  assert.deepEqual(candidate([-1, 1, 1, 0]),0);
}

test();"
HumanEval_129,spa_Latn,js,"/ Ejemplos: / Devuelve una matriz ordenada de los valores de las celdas por las que pasa la ruta mínima. Se garantiza que la respuesta es única./ Lst_A[j] = Lst_B[j]  El número de los miembros de la Comisión es el número de los miembros de la Comisión./ tal que lst_A[i] < lst_B[i] y para cualquier j (1 <= j < i) tenemos / que lst_B, en otras palabras, existe un índice entero i (1 <= i <= k) / a través de (llamémoslos lst_A y lst_B), lst_A es lexicográficamente menos / después de hacer las matrices ordenadas de los valores en las celdas que A y B van / Se considera que un camino A (de longitud k) es menor que un camino B (de longitud k) si - No puedes salir de la red./ necesariamente distintas)./ Tenga en cuenta que un recorrido de longitud k significa visitar exactamente k celdas (no - ¿Qué es eso?En otras palabras, puedes ir a las celdas que comparten un borde con tu corriente./ de cualquier celda, y en cada paso se puede mover a cualquiera de las células vecinas, Tienes que encontrar el camino mínimo de longitud k en la cuadrícula./ inclusive aparece exactamente una vez en las celdas de la cuadrícula. / cada celda de la cuadrícula contiene un valor./ Dado una cuadrícula con N filas y N columnas (N >= 2) y un número entero positivo k, // >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)
// [1, 2, 1]
// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)
// [1]
function minPath(grid, k){
","function minPath(grid, k) {
    const N = grid.length;
    const directions = [
        [0, 1], // right
        [1, 0], // down
        [0, -1], // left
        [-1, 0]  // up
    ];
    
    let minPathResult = Array(k).fill(Infinity);

    function dfs(x, y, path) {
        if (path.length === k) {
            // Check if the current path is lexicographically smaller
            if (comparePaths(path, minPathResult)) {
                minPathResult = [...path];
            }
            return;
        }

        for (const [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {
                path.push(grid[nx][ny]);
                dfs(nx, ny, path);
                path.pop();
            }
        }
    }
    
    function comparePaths(pathA, pathB) {
        for (let i = 0; i < pathA.length; i++) {
            if (pathA[i] < pathB[i]) return true;
            if (pathA[i] > pathB[i]) return false;
        }
        return false;
    }

    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            dfs(i, j, [grid[i][j]]);
        }
    }

    return minPathResult;
}","const assert = require('node:assert');


function test() {
  let candidate = minPath;
  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);
  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);
  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);
  assert.deepEqual(candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);
  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);
  assert.deepEqual(candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);
  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);
  assert.deepEqual(candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);
  assert.deepEqual(candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);
  assert.deepEqual(candidate([[1, 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);
  assert.deepEqual(candidate([[1, 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);
}

test();"
HumanEval_130,spa_Latn,js,"/ Ejemplos: / los primeros n + 1 números de la secuencia de Tribonacci. / Se le da un número entero no negativo n, tiene que devolver una matriz de la / = 2 + 3 + 3 = 8 / tri(3) = tri(2) + tri(1) + tri(4) / tri(4) = 3 / tri(2) = 1 + (2 / 2) = 2 Por ejemplo:/ tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), si n es impar. / tri (n) = 1 + n / 2, si n es par. / tri(1) = 3 / La secuencia de Tribonacci se define por la recurrencia: Sin embargo, lo que la gente no sabe es la secuencia de Tribonacci.Todos conocen la secuencia de Fibonacci, fue estudiada profundamente por los matemáticos en el siglo XX.// >>> tri(3)
// [1, 3, 2, 8]
function tri(n){
","function tri(n) {
    if (n < 0) return [];
    
    let tribonacci = new Array(n + 1);

    for (let i = 0; i <= n; i++) {
        if (i === 1) {
            tribonacci[i] = 3;
        } else if (i % 2 === 0) {
            tribonacci[i] = 1 + i / 2;
        } else {
            tribonacci[i] = 
                (tribonacci[i - 1] !== undefined ? tribonacci[i - 1] : 0) + 
                (tribonacci[i - 2] !== undefined ? tribonacci[i - 2] : 0) + 
                (tribonacci[i + 1] !== undefined ? tribonacci[i + 1] : 0);
        }
    }

    return tribonacci;
}","const assert = require('node:assert');


function test() {
  let candidate = tri;
  assert.deepEqual(candidate(3),[1, 3, 2, 8]);
  assert.deepEqual(candidate(4),[1, 3, 2, 8, 3]);
  assert.deepEqual(candidate(5),[1, 3, 2, 8, 3, 15]);
  assert.deepEqual(candidate(6),[1, 3, 2, 8, 3, 15, 4]);
  assert.deepEqual(candidate(7),[1, 3, 2, 8, 3, 15, 4, 24]);
  assert.deepEqual(candidate(8),[1, 3, 2, 8, 3, 15, 4, 24, 5]);
  assert.deepEqual(candidate(9),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
  assert.deepEqual(candidate(20),[1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);
  assert.deepEqual(candidate(0),[1]);
  assert.deepEqual(candidate(1),[1, 3]);
}

test();"
HumanEval_131,spa_Latn,js,"Por ejemplo:/ Devuelve 0 si todos los dígitos son pares. /Dado un entero positivo n, devuelve el producto de los dígitos impares. // >>> digits(1)
// 1
// >>> digits(4)
// 0
// >>> digits(235)
// 15
function digits(n){
","function digits(n) {
    let product = 1;
    let hasOdd = false;

    while (n > 0) {
        let digit = n % 10;
        if (digit % 2 !== 0) {
            product *= digit;
            hasOdd = true;
        }
        n = Math.floor(n / 10);
    }

    return hasOdd ? product : 0;
}","const assert = require('node:assert');


function test() {
  let candidate = digits;
  assert.deepEqual(candidate(5),5);
  assert.deepEqual(candidate(54),5);
  assert.deepEqual(candidate(120),1);
  assert.deepEqual(candidate(5014),5);
  assert.deepEqual(candidate(98765),315);
  assert.deepEqual(candidate(5576543),2625);
  assert.deepEqual(candidate(2468),0);
}

test();"
HumanEval_132,spa_Latn,js,"/ donde al menos un soporte en la subsecuencia está anidado. / La función debe devolver verdad si y sólo si hay una subsecuencia válida de paréntesis /Crear una función que toma una cadena como entrada que contiene sólo corchetes cuadrados. // >>> is_nested(""[[]]"")
// true
// >>> is_nested(""[]]]]]]][[[[[]"")
// false
// >>> is_nested(""[][]"")
// false
// >>> is_nested(""[]"")
// false
// >>> is_nested(""[[][]]"")
// true
// >>> is_nested(""[[]][["")
// true
function is_nested(string){
","function is_nested(string) {
    let openCount = 0;
    let nested = false;

    for (let char of string) {
        if (char === '[') {
            if (openCount > 0) {
                nested = true;
            }
            openCount++;
        } else if (char === ']') {
            if (openCount > 0) {
                openCount--;
            }
        }
    }
    
    return nested && openCount === 0;
}","const assert = require('node:assert');


function test() {
  let candidate = is_nested;
  assert.deepEqual(candidate(""[[]]""),true);
  assert.deepEqual(candidate(""[]]]]]]][[[[[]""),false);
  assert.deepEqual(candidate(""[][]""),false);
  assert.deepEqual(candidate(""[]""),false);
  assert.deepEqual(candidate(""[[[[]]]]""),true);
  assert.deepEqual(candidate(""[]]]]]]]]]]""),false);
  assert.deepEqual(candidate(""[][][[]]""),true);
  assert.deepEqual(candidate(""[[]""),false);
  assert.deepEqual(candidate(""[]]""),false);
  assert.deepEqual(candidate(""[[]][[""),true);
  assert.deepEqual(candidate(""[[][]]""),true);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""[[[[[[[[""),false);
  assert.deepEqual(candidate(""]]]]]]]]""),false);
}

test();"
HumanEval_133,spa_Latn,js,"/ Ejemplos: / redondear cada elemento en la matriz a la int superior ((Techo) primero. / Necesitas devolver la suma de números al cuadrado en la matriz dada, Se le da una serie de números.// >>> lst([1.0, 2.0, 3.0])
// 14
// >>> lst([1.0, 4.0, 9.0])
// 98
// >>> lst([1.0, 3.0, 5.0, 7.0])
// 84
// >>> lst([1.4, 4.2, 0.0])
// 29
// >>> lst([-2.4, 1.0, 1.0])
// 6
function sum_squares(lst){
","function sum_squares(lst) {
    return lst.map(Math.ceil).reduce((sum, num) => sum + num * num, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);
  assert.deepEqual(candidate([1.0, 3.0, 5.0, 7.0]),84);
  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);
  assert.deepEqual(candidate([-2.4, 1.0, 1.0]),6);
  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);
  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);
  assert.deepEqual(candidate([-1.4, 4.6, 6.3]),75);
  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);
  assert.deepEqual(candidate([0.0]),0);
  assert.deepEqual(candidate([-1.0]),1);
  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);
}

test();"
HumanEval_134,spa_Latn,js,"/ Ejemplos: / Nota: ""palabra"" es un grupo de caracteres separados por un espacio. / una parte de una palabra, y falsa de lo contrario. / de una cadena dada es un carácter alfabético y no es /Crear una función que devuelva verdadero si el último carácter // >>> check_if_last_char_is_a_letter(""apple pie"")
// false
// >>> check_if_last_char_is_a_letter(""apple pi e"")
// true
// >>> check_if_last_char_is_a_letter(""apple pi e "")
// false
// >>> check_if_last_char_is_a_letter("""")
// false
function check_if_last_char_is_a_letter(txt){
","function check_if_last_char_is_a_letter(txt) {
    if (txt.length === 0) return false;
    
    txt = txt.trim();
    if (txt.length === 0) return false;
    
    let parts = txt.split(' ');
    let lastWord = parts[parts.length - 1];
    
    if (lastWord.length === 0) return false;
    
    let lastChar = lastWord[lastWord.length - 1];
    return /^[a-zA-Z]$/.test(lastChar);
}","const assert = require('node:assert');


function test() {
  let candidate = check_if_last_char_is_a_letter;
  assert.deepEqual(candidate(""apple""),false);
  assert.deepEqual(candidate(""apple pi e""),true);
  assert.deepEqual(candidate(""eeeee""),false);
  assert.deepEqual(candidate(""A""),true);
  assert.deepEqual(candidate(""Pumpkin pie ""),false);
  assert.deepEqual(candidate(""Pumpkin pie 1""),false);
  assert.deepEqual(candidate(""""),false);
  assert.deepEqual(candidate(""eeeee e ""),false);
  assert.deepEqual(candidate(""apple pie""),false);
  assert.deepEqual(candidate(""apple pi e ""),false);
}

test();"
HumanEval_135,spa_Latn,js,"/ Ejemplos: / los valores se duplican./ no existe tal elemento entonces devuelve -1. La matriz dada no contendrá / no es mayor o igual al elemento inmediatamente anterior./Crear una función que devuelva el índice más grande de un elemento que // >>> can_arrange([1, 2, 4, 3, 5])
// 3
// >>> can_arrange([1, 2, 3])
// -1
function can_arrange(arr){
","function can_arrange(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            return i;
        }
    }
    return -1;
}","const assert = require('node:assert');


function test() {
  let candidate = can_arrange;
  assert.deepEqual(candidate([1, 2, 4, 3, 5]),3);
  assert.deepEqual(candidate([1, 2, 4, 5]),-1);
  assert.deepEqual(candidate([1, 4, 2, 5, 6, 7, 8, 9, 10]),2);
  assert.deepEqual(candidate([4, 8, 5, 7, 3]),4);
  assert.deepEqual(candidate([]),-1);
}

test();"
HumanEval_136,spa_Latn,js,"/ Ejemplos: / Si no hay números enteros negativos o positivos, devuelve como indefinido. / de enteros positivos en una matriz. / el mayor de los enteros negativos, y 'b' es el más pequeño /Crear una función que devuelva una matriz (a, b), donde 'a' es // >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])
// [undefined, 1]
// >>> largest_smallest_integers([])
// [undefined, undefined]
// >>> largest_smallest_integers([0])
// [undefined, undefined]
function largest_smallest_integers(lst){
","function largest_smallest_integers(lst) {
    let largestNegative = undefined;
    let smallestPositive = undefined;
    
    lst.forEach(num => {
        if (num < 0 && (largestNegative === undefined || num > largestNegative)) {
            largestNegative = num;
        }
        if (num > 0 && (smallestPositive === undefined || num < smallestPositive)) {
            smallestPositive = num;
        }
    });
    
    return [largestNegative, smallestPositive];
}","const assert = require('node:assert');


function test() {
  let candidate = largest_smallest_integers;
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined, 1]);
  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);
  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);
  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);
  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);
  assert.deepEqual(candidate([]),[undefined, undefined]);
  assert.deepEqual(candidate([0]),[undefined, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6]),[-1, undefined]);
  assert.deepEqual(candidate([-1, -3, -5, -6, 0]),[-1, undefined]);
  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3, 1]);
  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);
}

test();"
HumanEval_137,spa_Latn,js,"/ Nota: Si un número real se representa como una cadena, el punto flotante podría ser . o , / Devuelve undefined si los valores son iguales. / números reales, y devuelve la variable más grande en su tipo de variable dado. /Crear una función que toma enteros, flotadores, o cadenas que representan // >>> compare_one(1, 2.5)
// 2.5
// >>> compare_one(1, ""2,3"")
// ""2,3""
// >>> compare_one(""5,1"", ""6"")
// ""6""
// >>> compare_one(""1"", 1)
// undefined
function compare_one(a, b){
","function compare_one(a, b) {
    // Function to parse the input into a real number.
    const parseNum = (val) => {
        if (typeof val === 'number') return val;
        if (typeof val === 'string') {
            // Replace comma with dot for parsing
            let parsed = parseFloat(val.replace(',', '.'));
            // If parsing fails, return NaN
            if (isNaN(parsed)) return NaN;
            return parsed;
        }
        return NaN;
    };

    // Get parsed numerical values
    const numA = parseNum(a);
    const numB = parseNum(b);

    // Compare the inputs to determine which is greater
    if (numA > numB) return a;
    if (numB > numA) return b;

    // If values are equal return undefined
    return undefined;
}","const assert = require('node:assert');


function test() {
  let candidate = compare_one;
  assert.deepEqual(candidate(1, 2),2);
  assert.deepEqual(candidate(1, 2.5),2.5);
  assert.deepEqual(candidate(2, 3),3);
  assert.deepEqual(candidate(5, 6),6);
  assert.deepEqual(candidate(1, ""2,3""),""2,3"");
  assert.deepEqual(candidate(""5,1"", ""6""),""6"");
  assert.deepEqual(candidate(""1"", ""2""),""2"");
  assert.deepEqual(candidate(""1"", 1),undefined);
}

test();"
HumanEval_138,spa_Latn,js,"- Ejemplo ./Evalúe si el número dado n puede ser escrito como la suma de exactamente 4 números pares positivos // >>> is_equal_to_sum_even(4)
// false
// >>> is_equal_to_sum_even(6)
// false
// >>> is_equal_to_sum_even(8)
// true
function is_equal_to_sum_even(n){
","function is_equal_to_sum_even(n) {
    // A number can be expressed as the sum of 4 positive even numbers
    // if it is greater than or equal to 8 and is even.

    if (n >= 8 && n % 2 === 0) {
        return true;
    }
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = is_equal_to_sum_even;
  assert.deepEqual(candidate(4),false);
  assert.deepEqual(candidate(6),false);
  assert.deepEqual(candidate(8),true);
  assert.deepEqual(candidate(10),true);
  assert.deepEqual(candidate(11),false);
  assert.deepEqual(candidate(12),true);
  assert.deepEqual(candidate(13),false);
  assert.deepEqual(candidate(16),true);
}

test();"
HumanEval_139,spa_Latn,js,"Por ejemplo:/ donde n > 0 / brasilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! /El factorial brasileño se define como: // >>> special_factorial(4)
// 288
// The function will receive an integer as input and should return the special
// factorial of this integer.
function special_factorial(n){
","function factorial(num) {
    if (num <= 1) return 1;
    return num * factorial(num - 1);
}

function special_factorial(n) {
    let result = 1;
    for (let i = n; i > 0; i--) {
        result *= factorial(i);
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = special_factorial;
  assert.deepEqual(candidate(4),288);
  assert.deepEqual(candidate(5),34560);
  assert.deepEqual(candidate(7),125411328000);
  assert.deepEqual(candidate(1),1);
}

test();"
HumanEval_140,spa_Latn,js,"/ entonces sustituye todos los espacios consecutivos por - / y si una cadena tiene más de 2 espacios consecutivos, /Dada una cadena de texto, sustituir todos los espacios en él con subrayados, // >>> fix_spaces("" Example"")
// ""Example""
// >>> fix_spaces("" Example 1"")
// ""Example_1""
// >>> fix_spaces("" Example 2"")
// ""_Example_2""
// >>> fix_spaces("" Example 3"")
// ""_Example-3""
function fix_spaces(text){
","function fix_spaces(text) {
    return text.trim().replace(/\s{2,}/g, '-').replace(/\s/g, '_');
}","const assert = require('node:assert');


function test() {
  let candidate = fix_spaces;
  assert.deepEqual(candidate(""Example""),""Example"");
  assert.deepEqual(candidate(""Mudasir Hanif ""),""Mudasir_Hanif_"");
  assert.deepEqual(candidate(""Yellow Yellow  Dirty  Fellow""),""Yellow_Yellow__Dirty__Fellow"");
  assert.deepEqual(candidate(""Exa   mple""),""Exa-mple"");
  assert.deepEqual(candidate(""   Exa 1 2 2 mple""),""-Exa_1_2_2_mple"");
}

test();"
HumanEval_141,spa_Latn,js,"/ Ejemplos: / - La subcadena después del punto debe ser uno de estos: ['txt', 'exe', 'dll'] / el alfabeto latino ('a'-'z' y 'A'-'Z'). / - La subcadena antes del punto no debe estar vacío, y comienza con una letra de / - El nombre del archivo contiene exactamente un punto '.' / - El nombre del archivo no debe contener más de tres dígitos ('0'-'9'). / se cumplen: / Se considera válido el nombre de un archivo si y sólo si se cumplen todas las condiciones siguientes / 'Sí' si el nombre del archivo es válido, y devuelve 'No' en caso contrario. /Crear una función que toma una cadena que representa el nombre de un archivo, y devuelve // >>> file_name_check(""example.txt"")
// ""Yes""
// >>> file_name_check(""1example.dll"")
// ""No""
function file_name_check(file_name){
","function file_name_check(file_name) {
    const validExtensions = ['txt', 'exe', 'dll'];
    const parts = file_name.split('.');

    if (parts.length !== 2) {
        return 'No';
    }

    const [namePart, extensionPart] = parts;

    // Check that the name part is not empty, starts with a letter, and has at most 3 digits
    if (namePart.length === 0 || !/^[a-zA-Z]/.test(namePart)) {
        return 'No';
    }

    const digitCount = (namePart.match(/\d/g) || []).length;
    if (digitCount > 3) {
        return 'No';
    }

    // Check if the extension is one of the valid ones
    if (!validExtensions.includes(extensionPart)) {
        return 'No';
    }

    return 'Yes';
}","const assert = require('node:assert');


function test() {
  let candidate = file_name_check;
  assert.deepEqual(candidate(""example.txt""),""Yes"");
  assert.deepEqual(candidate(""1example.dll""),""No"");
  assert.deepEqual(candidate(""s1sdf3.asd""),""No"");
  assert.deepEqual(candidate(""K.dll""),""Yes"");
  assert.deepEqual(candidate(""MY16FILE3.exe""),""Yes"");
  assert.deepEqual(candidate(""His12FILE94.exe""),""No"");
  assert.deepEqual(candidate(""_Y.txt""),""No"");
  assert.deepEqual(candidate(""?aREYA.exe""),""No"");
  assert.deepEqual(candidate(""/this_is_valid.dll""),""No"");
  assert.deepEqual(candidate(""this_is_valid.wow""),""No"");
  assert.deepEqual(candidate(""this_is_valid.txt""),""Yes"");
  assert.deepEqual(candidate(""this_is_valid.txtexe""),""No"");
  assert.deepEqual(candidate(""#this2_i4s_5valid.ten""),""No"");
  assert.deepEqual(candidate(""@this1_is6_valid.exe""),""No"");
  assert.deepEqual(candidate(""this_is_12valid.6exe4.txt""),""No"");
  assert.deepEqual(candidate(""all.exe.txt""),""No"");
  assert.deepEqual(candidate(""I563_No.exe""),""Yes"");
  assert.deepEqual(candidate(""Is3youfault.txt""),""Yes"");
  assert.deepEqual(candidate(""no_one#knows.dll""),""Yes"");
  assert.deepEqual(candidate(""1I563_Yes3.exe""),""No"");
  assert.deepEqual(candidate(""I563_Yes3.txtt""),""No"");
  assert.deepEqual(candidate(""final..txt""),""No"");
  assert.deepEqual(candidate(""final132""),""No"");
  assert.deepEqual(candidate(""_f4indsartal132.""),""No"");
  assert.deepEqual(candidate("".txt""),""No"");
  assert.deepEqual(candidate(""s.""),""No"");
}

test();"
HumanEval_142,spa_Latn,js,"/ Ejemplos: / cambiar las entradas en la matriz cuyos índices no son un múltiplo de 3 o 4. La función devuelve la suma de todas las entradas. / múltiple de 3 y cubrirá la entrada entera si su índice es un múltiplo de 4 y no un múltiplo de 3. La función no lo hará./ Esta función tomará una matriz de enteros. Para todas las entradas en la matriz, la función elevará al cuadrado la entrada entera si su índice es a - ¿Qué es eso?// >>> lst
// [1, 2, 3]
// >>> lst
// []
// >>> lst
// [-1, -5, 2, -1, -5]
function sum_squares(lst){
","function sum_squares(lst) {
    let sum = 0;
    for (let i = 0; i < lst.length; i++) {
        if (i % 3 === 0) {
            sum += Math.pow(lst[i], 2);
        } else if (i % 4 === 0) {
            sum += Math.pow(lst[i], 3);
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","const assert = require('node:assert');


function test() {
  let candidate = sum_squares;
  assert.deepEqual(candidate([1, 2, 3]),6);
  assert.deepEqual(candidate([1, 4, 9]),14);
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([1, 1, 1, 1, 1, 1, 1, 1, 1]),9);
  assert.deepEqual(candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1]),-3);
  assert.deepEqual(candidate([0]),0);
  assert.deepEqual(candidate([-1, -5, 2, -1, -5]),-126);
  assert.deepEqual(candidate([-56, -99, 1, 0, -2]),3030);
  assert.deepEqual(candidate([-1, 0, 0, 0, 0, 0, 0, 0, -1]),0);
  assert.deepEqual(candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]),-14196);
  assert.deepEqual(candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]),-1448);
}

test();"
HumanEval_143,spa_Latn,js,"Ejemplo 1:/ el orden de las palabras en la nueva cadena debe ser el mismo que el original. / cuya longitud es un número primo, / y tienes que devolver una cadena que contiene las palabras de la oración original, / la oración contiene algunas palabras separadas por un espacio, Se le da una cadena que representa una oración.// >>> words_in_sentence(""This is a test"")
// ""is""
// Example 2:
// >>> words_in_sentence(""lets go for swimming"")
// ""go for""
// Constraints:
// * 1 <= len(sentence) <= 100
// * sentence contains only letters
function words_in_sentence(sentence){
","function words_in_sentence(sentence) {
    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    return sentence.split(' ')
                   .filter(word => isPrime(word.length))
                   .join(' ');
}","const assert = require('node:assert');


function test() {
  let candidate = words_in_sentence;
  assert.deepEqual(candidate(""This is a test""),""is"");
  assert.deepEqual(candidate(""lets go for swimming""),""go for"");
  assert.deepEqual(candidate(""there is no place available here""),""there is no place"");
  assert.deepEqual(candidate(""Hi I am Hussein""),""Hi am Hussein"");
  assert.deepEqual(candidate(""go for it""),""go for it"");
  assert.deepEqual(candidate(""here""),"""");
  assert.deepEqual(candidate(""here is""),""is"");
}

test();"
HumanEval_144,spa_Latn,js,"/ Se puede asumir que x, y n son fracciones válidas, y no tienen cero como denominador. / <numerador>/<denominador> donde tanto el numerador como el denominador son números enteros positivos. / de otra manera. Tanto x como n, son representaciones de cadenas de una fracción, y tienen el siguiente formato, / x * n. La función devuelve verdad si x * n se evalúa como un número entero y falso /Su tarea es implementar una función que simplifique la expresión // >>> simplify(""1/5"", ""5/1"")
// true
// >>> simplify(""1/6"", ""2/1"")
// false
// >>> simplify(""7/10"", ""10/2"")
// false
function simplify(x, n){
","function simplify(x, n) {
    const parseFraction = (fraction) => {
        const [numerator, denominator] = fraction.split('/').map(Number);
        return { numerator, denominator };
    };

    const xFraction = parseFraction(x);
    const nFraction = parseFraction(n);

    const resultNumerator = xFraction.numerator * nFraction.numerator;
    const resultDenominator = xFraction.denominator * nFraction.denominator;

    return resultNumerator % resultDenominator === 0;
}

// Example usage
console.log(simplify(""1/5"", ""5/1"")); // true
console.log(simplify(""1/6"", ""2/1"")); // false
console.log(simplify(""7/10"", ""10/2"")); // false","const assert = require('node:assert');


function test() {
  let candidate = simplify;
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/6"", ""2/1""),false);
  assert.deepEqual(candidate(""5/1"", ""3/1""),true);
  assert.deepEqual(candidate(""7/10"", ""10/2""),false);
  assert.deepEqual(candidate(""2/10"", ""50/10""),true);
  assert.deepEqual(candidate(""7/2"", ""4/2""),true);
  assert.deepEqual(candidate(""11/6"", ""6/1""),true);
  assert.deepEqual(candidate(""2/3"", ""5/2""),false);
  assert.deepEqual(candidate(""5/2"", ""3/5""),false);
  assert.deepEqual(candidate(""2/4"", ""8/4""),true);
  assert.deepEqual(candidate(""2/4"", ""4/2""),true);
  assert.deepEqual(candidate(""1/5"", ""5/1""),true);
  assert.deepEqual(candidate(""1/5"", ""1/5""),false);
}

test();"
HumanEval_145,spa_Latn,js,"Por ejemplo:/ ordenarlos en base a su índice en la matriz original. / Nota: si hay varios elementos con una suma similar de sus dígitos, / en orden ascendente de acuerdo con la suma de sus dígitos. /Escribe una función que ordena el conjunto de enteros dado // >>> order_by_points([1, 11, -1, -11, -12])
// [-1, -11, 1, -12, 11]
// >>> order_by_points([])
// []
function order_by_points(nums){
","function order_by_points(nums) {
    function sumOfDigits(n) {
        // Absolute value to ensure digits are summed correctly for negative numbers
        return Math.abs(n).toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }

    nums.sort((a, b) => {
        const sumA = sumOfDigits(a);
        const sumB = sumOfDigits(b);
        if (sumA === sumB) {
            return 0; // Maintain original order
        }
        return sumA - sumB;
    });

    return nums;
}","const assert = require('node:assert');


function test() {
  let candidate = order_by_points;
  assert.deepEqual(candidate([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]);
  assert.deepEqual(candidate([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);
  assert.deepEqual(candidate([]),[]);
  assert.deepEqual(candidate([1, -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54]);
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);
  assert.deepEqual(candidate([0, 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6]);
}

test();"
HumanEval_146,spa_Latn,js,"Por ejemplo:/ los primeros y últimos dígitos de un número son impares (1, 3, 5, 7, 9). / el número de elementos en el array que son mayores que 10 y ambos /Escribe una función que toma una matriz de números como entrada y devuelve // >>> specialFilter([15, -73, 14, -15])
// 1
// >>> specialFilter([33, -2, -3, 45, 21, 109])
// 2
function specialFilter(nums){
","function specialFilter(nums) {
    return nums.reduce((count, num) => {
        if (Math.abs(num) > 10) {
            const numStr = Math.abs(num).toString();
            const firstDigit = parseInt(numStr[0]);
            const lastDigit = parseInt(numStr[numStr.length - 1]);
            if ([1, 3, 5, 7, 9].includes(firstDigit) && [1, 3, 5, 7, 9].includes(lastDigit)) {
                return count + 1;
            }
        }
        return count;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = specialFilter;
  assert.deepEqual(candidate([5, -2, 1, -5]),0);
  assert.deepEqual(candidate([15, -73, 14, -15]),1);
  assert.deepEqual(candidate([33, -2, -3, 45, 21, 109]),2);
  assert.deepEqual(candidate([43, -12, 93, 125, 121, 109]),4);
  assert.deepEqual(candidate([71, -2, -33, 75, 21, 19]),3);
  assert.deepEqual(candidate([1]),0);
  assert.deepEqual(candidate([]),0);
}

test();"
HumanEval_147,spa_Latn,js,"/ Ejemplo:/ y a[i] + a[j] + a[k] es un múltiplo de 3. / Devuelve el número de triples (a[i], a[j], a[k]) de a donde i < j < k, / Para cada i (1 ≤ i ≤ n), el valor de a[i] = i * i - i + 1. / Se le da un número entero positivo n. Tiene que crear una matriz de números enteros a de longitud n. // >>> get_max_triples(5)
// 1
// Explanation: 
// a = [1, 3, 7, 13, 21]
// The only valid triple is (1, 7, 13).
function get_max_triples(n){
","function get_max_triples(n) {
    // Step 1: Create the integer array 'a'
    let a = new Array(n);
    for (let i = 1; i <= n; i++) {
        a[i - 1] = i * i - i + 1;
    }

    // Step 2: Count the triples
    let count = 0;
    for (let i = 0; i < n - 2; i++) {
        for (let j = i + 1; j < n - 1; j++) {
            for (let k = j + 1; k < n; k++) {
                if ((a[i] + a[j] + a[k]) % 3 === 0) {
                    count++;
                }
            }
        }
    }

    return count;
}","const assert = require('node:assert');


function test() {
  let candidate = get_max_triples;
  assert.deepEqual(candidate(5),1);
  assert.deepEqual(candidate(6),4);
  assert.deepEqual(candidate(10),36);
  assert.deepEqual(candidate(100),53361);
}

test();"
HumanEval_148,spa_Latn,js,"/ Ejemplos / no son nombres de planetas correctos. / La función debe devolver una matriz vacía si planet1 o planet2 / la proximidad al sol. / situado entre la órbita del planeta1 y la órbita del planeta2, ordenado por / La función debe devolver una matriz que contenga todos los planetas cuyas órbitas son / Escriba una función que tome dos nombres de planetas como cadenas planet1 y planet2. - Urano y Neptuno./ es Mercurio, el siguiente es Venus, luego la Tierra, Marte, Júpiter, Saturno, Hay ocho planetas en nuestro sistema solar: el más cercano al Sol.// >>> bf(""Jupiter"", ""Neptune"")
// [""Saturn"", ""Uranus""]
// >>> bf(""Earth"", ""Mercury"")
// ""Venus""
// >>> bf(""Mercury"", ""Uranus"")
// [""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]
function bf(planet1, planet2){
","function bf(planet1, planet2) {
    const planets = [
        ""Mercury"",
        ""Venus"",
        ""Earth"",
        ""Mars"",
        ""Jupiter"",
        ""Saturn"",
        ""Uranus"",
        ""Neptune""
    ];

    const index1 = planets.indexOf(planet1);
    const index2 = planets.indexOf(planet2);

    if (index1 === -1 || index2 === -1) {
        return [];
    }

    const start = Math.min(index1, index2) + 1;
    const end = Math.max(index1, index2);

    return planets.slice(start, end);
}","const assert = require('node:assert');


function test() {
  let candidate = bf;
  assert.deepEqual(candidate(""Jupiter"", ""Neptune""),[""Saturn"", ""Uranus""]);
  assert.deepEqual(candidate(""Earth"", ""Mercury""),[""Venus""]);
  assert.deepEqual(candidate(""Mercury"", ""Uranus""),[""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""]);
  assert.deepEqual(candidate(""Neptune"", ""Venus""),[""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""]);
  assert.deepEqual(candidate(""Earth"", ""Earth""),[]);
  assert.deepEqual(candidate(""Mars"", ""Earth""),[]);
  assert.deepEqual(candidate(""Jupiter"", ""Makemake""),[]);
}

test();"
HumanEval_149,spa_Latn,js,"Por ejemplo:/ Puedes suponer que todas las palabras tendrán la misma longitud. / La función debe devolver una matriz de cadenas en orden ordenado. / Si dos palabras tienen la misma longitud, ordenar la matriz por orden alfabético. / debe devolver el arreglo ordenado por esa regla. El orden de la matriz debe ser ascendente por la longitud de cada palabra, y usted/ y puede contener duplicados. / El array es siempre un array de cadenas y nunca un array de números, / y devuelve la matriz resultante con un orden ordenado, / elimina las cadenas que tienen longitudes impares de ella, /Escribe una función que acepta una matriz de cadenas como parámetro, // >>> list_sort([""aa"", ""a"", ""aaa""])
// [""aa""]
// >>> list_sort([""ab"", ""a"", ""aaa"", ""cd""])
// [""ab"", ""cd""]
function sorted_list_sum(lst){
","function sorted_list_sum(lst) {
    return lst
        .filter(word => word.length % 2 === 0)
        .sort((a, b) => {
            if (a.length === b.length) {
                return a.localeCompare(b);
            }
            return a.length - b.length;
        });
}","const assert = require('node:assert');


function test() {
  let candidate = sorted_list_sum;
  assert.deepEqual(candidate([""aa"", ""a"", ""aaa""]),[""aa""]);
  assert.deepEqual(candidate([""school"", ""AI"", ""asdf"", ""b""]),[""AI"", ""asdf"", ""school""]);
  assert.deepEqual(candidate([""d"", ""b"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""d"", ""dcba"", ""abcd"", ""a""]),[""abcd"", ""dcba""]);
  assert.deepEqual(candidate([""AI"", ""ai"", ""au""]),[""AI"", ""ai"", ""au""]);
  assert.deepEqual(candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]),[]);
  assert.deepEqual(candidate([""aaaa"", ""bbbb"", ""dd"", ""cc""]),[""cc"", ""dd"", ""aaaa"", ""bbbb""]);
}

test();"
HumanEval_150,spa_Latn,js,"/ Ejemplos: / un número primo y debe devolver el valor de y de lo contrario. /Un programa simple que debe devolver el valor de x si n es // >>> x_or_y(7, 34, 12)
// 34
// >>> x_or_y(15, 8, 5)
// 5
function x_or_y(n, x, y){
","function isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;

    if (num % 2 === 0 || num % 3 === 0) return false;

    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }

    return true;
}

function x_or_y(n, x, y) {
    return isPrime(n) ? x : y;
}","const assert = require('node:assert');


function test() {
  let candidate = x_or_y;
  assert.deepEqual(candidate(7, 34, 12),34);
  assert.deepEqual(candidate(15, 8, 5),5);
  assert.deepEqual(candidate(3, 33, 5212),33);
  assert.deepEqual(candidate(1259, 3, 52),3);
  assert.deepEqual(candidate(7919, -1, 12),-1);
  assert.deepEqual(candidate(3609, 1245, 583),583);
  assert.deepEqual(candidate(91, 56, 129),129);
  assert.deepEqual(candidate(6, 34, 1234),1234);
  assert.deepEqual(candidate(1, 2, 0),0);
  assert.deepEqual(candidate(2, 2, 0),2);
}

test();"
HumanEval_151,spa_Latn,js,"Ignorar los números que son negativos o no enteros./Dado un conjunto de números, devuelve la suma de los cuadrados de los números // >>> double_the_difference([1, 3, 2, 0])
// 10
// >>> double_the_difference([-1, -2, 0])
// 0
// >>> double_the_difference([9, -2])
// 81
// >>> double_the_difference([0])
// 0
// If the input array is empty, return 0.
function double_the_difference(lst){
","function double_the_difference(lst) {
    return lst.reduce((sum, num) => {
        if (Number.isInteger(num) && num > 0 && num % 2 !== 0) {
            return sum + num * num;
        }
        return sum;
    }, 0);
}","const assert = require('node:assert');


function test() {
  let candidate = double_the_difference;
  assert.deepEqual(candidate([]),0);
  assert.deepEqual(candidate([5.0, 4.0]),25);
  assert.deepEqual(candidate([0.1, 0.2, 0.3]),0);
  assert.deepEqual(candidate([-10.0, -20.0, -30.0]),0);
  assert.deepEqual(candidate([-1.0, -2.0, 8.0]),0);
  assert.deepEqual(candidate([0.2, 3.0, 5.0]),34);
  assert.deepEqual(candidate([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]),165);
}

test();"
HumanEval_152,spa_Latn,js,"/ ejemplo: / el valor es 0, y si no es así, el valor es la diferencia absoluta entre la suposición y la puntuación. / Devuelve una matriz de la misma longitud que denota qué tan lejos estaba cada suposición./ Se le dan dos matrices de puntuaciones y conjeturas de igual longitud, donde cada índice muestra una coincidencia. / Su tarea es determinar si una persona adivinó correctamente los resultados de un número de partidos. / Definitivamente vale la pena anotar y comparar. Los sentimientos y pensamientos que tienes en ese momento son los que te hacen sentir feliz.Creo que todos recordamos ese sentimiento cuando el resultado de algo tan esperado// >>> compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])
// [0, 0, 0, 0, 3, 3]
// >>> compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])
// [4, 4, 1, 0, 0, 6]
function compare(game, guess){
","function compare(game, guess) {
    return game.map((score, index) => Math.abs(score - guess[index]));
}","const assert = require('node:assert');


function test() {
  let candidate = compare;
  assert.deepEqual(candidate([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]),[0, 0, 0, 0, 3, 3]);
  assert.deepEqual(candidate([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]),[0, 0, 0, 0, 0, 0]);
  assert.deepEqual(candidate([1, 2, 3], [-1, -2, -3]),[2, 4, 6]);
  assert.deepEqual(candidate([1, 2, 3, 5], [-1, 2, 3, 4]),[2, 0, 0, 1]);
}

test();"
HumanEval_153,spa_Latn,js,"/ Ejemplo: / (su fuerza es -1). / devuelve ""Slices.SErviNGSliCes"" ya que ""SErviNGSliCes"" es la extensión más fuerte / extensiones: ['SErviNGSliCes', 'Cheese', 'StuFfed'] entonces usted debería / Por ejemplo, si se le da ""Slices"" como la clase y una matriz de la / elegir el que viene primero en la matriz. Si hay dos o más extensiones con la misma fuerza, debe/ formato: Nombre de clase. Nombre de extensión más fuerte. / Debes encontrar la extensión más fuerte y devolver una cadena en esta / en el nombre de la extensión, la fuerza se da por la fracción CAP - SM. / letras en el nombre de la extensión, y que SM sea el número de letras minúsculas / la fuerza de la extensión es la siguiente: Sepa CAP el número de la mayúscula / Las extensiones se utilizan para cargar clases adicionales a la clase./Se le dará el nombre de una clase (una cadena) y una matriz de extensiones. // >>> Strongest_Extension(""my_class"", [""AA"", ""Be"", ""CC""])
// ""my_class.AA""
function Strongest_Extension(class_name, extensions){
","function Strongest_Extension(class_name, extensions) {
    let strongestExtension = '';
    let maxStrength = -Infinity;

    extensions.forEach(extension => {
        let capCount = 0;
        let smCount = 0;

        for (let char of extension) {
            if (char >= 'A' && char <= 'Z') {
                capCount++;
            } else if (char >= 'a' && char <= 'z') {
                smCount++;
            }
        }

        let strength = capCount - smCount;

        if (strength > maxStrength) {
            maxStrength = strength;
            strongestExtension = extension;
        }
    });

    return `${class_name}.${strongestExtension}`;
}","const assert = require('node:assert');


function test() {
  let candidate = Strongest_Extension;
  assert.deepEqual(candidate(""Watashi"", [""tEN"", ""niNE"", ""eIGHt8OKe""]),""Watashi.eIGHt8OKe"");
  assert.deepEqual(candidate(""Boku123"", [""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""]),""Boku123.YEs.WeCaNe"");
  assert.deepEqual(candidate(""__YESIMHERE"", [""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""]),""__YESIMHERE.NuLl__"");
  assert.deepEqual(candidate(""K"", [""Ta"", ""TAR"", ""t234An"", ""cosSo""]),""K.TAR"");
  assert.deepEqual(candidate(""__HAHA"", [""Tab"", ""123"", ""781345"", ""-_-""]),""__HAHA.123"");
  assert.deepEqual(candidate(""YameRore"", [""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""]),""YameRore.okIWILL123"");
  assert.deepEqual(candidate(""finNNalLLly"", [""Die"", ""NowW"", ""Wow"", ""WoW""]),""finNNalLLly.WoW"");
  assert.deepEqual(candidate(""_"", [""Bb"", ""91245""]),""_.Bb"");
  assert.deepEqual(candidate(""Sp"", [""671235"", ""Bb""]),""Sp.671235"");
}

test();"
HumanEval_154,spa_Latn,js,"/Se le dan 2 palabras. Usted necesita para volver verdad si la segunda palabra o cualquiera de sus rotaciones es una subcadena en la primera palabra // >>> cycpattern_check(""abcd"", ""abd"")
// false
// >>> cycpattern_check(""hello"", ""ell"")
// true
// >>> cycpattern_check(""whassup"", ""psus"")
// false
// >>> cycpattern_check(""abab"", ""baa"")
// true
// >>> cycpattern_check(""efef"", ""eeff"")
// false
// >>> cycpattern_check(""himenss"", ""simen"")
// true
function cycpattern_check(a, b){
","function cycpattern_check(a, b) {
    if (b.length > a.length) return false;
    
    let currentRotation = b;
    for (let i = 0; i < b.length; i++) {
        if (a.includes(currentRotation)) {
            return true;
        }
        currentRotation = currentRotation.slice(1) + currentRotation[0];
    }
    
    return false;
}","const assert = require('node:assert');


function test() {
  let candidate = cycpattern_check;
  assert.deepEqual(candidate(""xyzw"", ""xyw""),false);
  assert.deepEqual(candidate(""yello"", ""ell""),true);
  assert.deepEqual(candidate(""whattup"", ""ptut""),false);
  assert.deepEqual(candidate(""efef"", ""fee""),true);
  assert.deepEqual(candidate(""abab"", ""aabb""),false);
  assert.deepEqual(candidate(""winemtt"", ""tinem""),true);
}

test();"
HumanEval_155,spa_Latn,js,"/ Ejemplo: /Dado un entero. devuelve una matriz que tiene el número de dígitos pares e impares respectivamente. // >>> even_odd_count(-12)
// [1, 1]
// >>> even_odd_count(123)
// [1, 2]
function even_odd_count(num){
","function even_odd_count(num) {
    // Convert the number to a string and take the absolute value for negative numbers
    const numStr = Math.abs(num).toString();
    let evenCount = 0;
    let oddCount = 0;

    // Loop through each digit in the string
    for (let char of numStr) {
        // Convert the character back to a number
        let digit = parseInt(char, 10);
        // Check if the digit is even or odd
        if (digit % 2 === 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }
    return [evenCount, oddCount];
}","const assert = require('node:assert');


function test() {
  let candidate = even_odd_count;
  assert.deepEqual(candidate(7),[0, 1]);
  assert.deepEqual(candidate(-78),[1, 1]);
  assert.deepEqual(candidate(3452),[2, 2]);
  assert.deepEqual(candidate(346211),[3, 3]);
  assert.deepEqual(candidate(-345821),[3, 3]);
  assert.deepEqual(candidate(-2),[1, 0]);
  assert.deepEqual(candidate(-45347),[2, 3]);
  assert.deepEqual(candidate(0),[1, 0]);
}

test();"
HumanEval_156,spa_Latn,js,"/ Ejemplos: / Restricciones: 1 <= num <= 1000 / y devolverlo en minúsculas. /Dado un número entero positivo, obtenga su equivalente numérico romano como una cadena, // >>> int_to_mini_roman(19)
// ""xix""
// >>> int_to_mini_roman(152)
// ""clii""
// >>> int_to_mini_roman(426)
// ""cdxxvi""
function int_to_mini_roman(number){
","function int_to_mini_roman(number) {
    const romanNumerals = [
        { value: 1000, numeral: 'm' },
        { value: 900, numeral: 'cm' },
        { value: 500, numeral: 'd' },
        { value: 400, numeral: 'cd' },
        { value: 100, numeral: 'c' },
        { value: 90, numeral: 'xc' },
        { value: 50, numeral: 'l' },
        { value: 40, numeral: 'xl' },
        { value: 10, numeral: 'x' },
        { value: 9, numeral: 'ix' },
        { value: 5, numeral: 'v' },
        { value: 4, numeral: 'iv' },
        { value: 1, numeral: 'i' }
    ];
    
    let result = '';
    for (const { value, numeral } of romanNumerals) {
        while (number >= value) {
            result += numeral;
            number -= value;
        }
    }
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = int_to_mini_roman;
  assert.deepEqual(candidate(19),""xix"");
  assert.deepEqual(candidate(152),""clii"");
  assert.deepEqual(candidate(251),""ccli"");
  assert.deepEqual(candidate(426),""cdxxvi"");
  assert.deepEqual(candidate(500),""d"");
  assert.deepEqual(candidate(1),""i"");
  assert.deepEqual(candidate(4),""iv"");
  assert.deepEqual(candidate(43),""xliii"");
  assert.deepEqual(candidate(90),""xc"");
  assert.deepEqual(candidate(94),""xciv"");
  assert.deepEqual(candidate(532),""dxxxii"");
  assert.deepEqual(candidate(900),""cm"");
  assert.deepEqual(candidate(994),""cmxciv"");
  assert.deepEqual(candidate(1000),""m"");
}

test();"
HumanEval_157,spa_Latn,js,"/ Ejemplo: - 90 grados.Un triángulo rectángulo es un triángulo en el que un ángulo es recto o / los lados forman un triángulo rectángulo, falso de lo contrario. Dadas las longitudes de los tres lados de un triángulo, devuelve verdad si los tres lados son de la misma longitud.// >>> right_angle_triangle(3, 4, 5)
// true
// >>> right_angle_triangle(1, 2, 3)
// false
function right_angle_triangle(a, b, c){
","function right_angle_triangle(a, b, c) {
    // Sort the sides to ensure the largest side is at the end (potential hypotenuse)
    let sides = [a, b, c].sort((x, y) => x - y);
    
    // Check the Pythagorean theorem to determine if it's a right-angled triangle
    return sides[0]**2 + sides[1]**2 === sides[2]**2;
}","const assert = require('node:assert');


function test() {
  let candidate = right_angle_triangle;
  assert.deepEqual(candidate(3, 4, 5),true);
  assert.deepEqual(candidate(1, 2, 3),false);
  assert.deepEqual(candidate(10, 6, 8),true);
  assert.deepEqual(candidate(2, 2, 2),false);
  assert.deepEqual(candidate(7, 24, 25),true);
  assert.deepEqual(candidate(10, 5, 7),false);
  assert.deepEqual(candidate(5, 12, 13),true);
  assert.deepEqual(candidate(15, 8, 17),true);
  assert.deepEqual(candidate(48, 55, 73),true);
  assert.deepEqual(candidate(1, 1, 1),false);
  assert.deepEqual(candidate(2, 2, 10),false);
}

test();"
HumanEval_158,spa_Latn,js,"/ caracteres, devuelve el que aparece primero en orden lexicográfico. Si varias cadenas tienen un número máximo de caracteres únicos / El array contiene diferentes palabras. Devuelve la palabra con el número máximo /Escribe una función que acepta una matriz de cadenas. // >>> find_max([""name"", ""of"", ""string""])
// ""string""
// >>> find_max([""name"", ""enam"", ""game""])
// ""enam""
// >>> find_max([""aaaaaaa"", ""bb"", ""cc""])
// ""aaaaaaa""
function find_max(words){
","function find_max(words) {
    function uniqueCharacterCount(word) {
        const uniqueChars = new Set(word);
        return uniqueChars.size;
    }

    let maxUniqueCount = -1;
    let result = """";

    words.forEach(word => {
        const currentUniqueCount = uniqueCharacterCount(word);
        if (currentUniqueCount > maxUniqueCount || 
            (currentUniqueCount === maxUniqueCount && word < result)) {
            maxUniqueCount = currentUniqueCount;
            result = word;
        }
    });

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = find_max;
  assert.deepEqual(candidate([""name"", ""of"", ""string""]),""string"");
  assert.deepEqual(candidate([""name"", ""enam"", ""game""]),""enam"");
  assert.deepEqual(candidate([""aaaaaaa"", ""bb"", ""cc""]),""aaaaaaa"");
  assert.deepEqual(candidate([""abc"", ""cba""]),""abc"");
  assert.deepEqual(candidate([""play"", ""this"", ""game"", ""of"", ""footbott""]),""footbott"");
  assert.deepEqual(candidate([""we"", ""are"", ""gonna"", ""rock""]),""gonna"");
  assert.deepEqual(candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]),""nation"");
  assert.deepEqual(candidate([""this"", ""is"", ""a"", ""prrk""]),""this"");
  assert.deepEqual(candidate([""b""]),""b"");
  assert.deepEqual(candidate([""play"", ""play"", ""play""]),""play"");
}

test();"
HumanEval_159,spa_Latn,js,"/ Ejemplo: Si no hay suficientes zanahorias, comerás todas las zanahorias, pero aún así tendrás hambre./ el número de zanahorias que quedan después de las comidas ] / debe devolver una serie de [número total de zanahorias consumidas después de las comidas, Pero ahora necesitas comer más zanahorias para completar las comidas del día.Eres un conejo hambriento, y ya has comido una cierta cantidad de zanahorias,// >>> eat(5, 6, 10)
// [11, 4]
// >>> eat(4, 8, 9)
// [12, 1]
// >>> eat(1, 10, 10)
// [11, 0]
// >>> eat(2, 11, 5)
// [7, 0]
// Variables:
// @number : integer
// the number of carrots that you have eaten.
// @need : integer
// the number of carrots that you need to eat.
// @remaining : integer
// the number of remaining carrots thet exist in stock
// Constrain:
// * 0 <= number <= 1000
// * 0 <= need <= 1000
// * 0 <= remaining <= 1000
// Have fun :)
function eat(number, need, remaining){
","function eat(number, need, remaining) {
    const carrotsToEat = Math.min(need, remaining);
    const totalEaten = number + carrotsToEat;
    const carrotsLeft = remaining - carrotsToEat;
    return [totalEaten, carrotsLeft];
}","const assert = require('node:assert');


function test() {
  let candidate = eat;
  assert.deepEqual(candidate(5, 6, 10),[11, 4]);
  assert.deepEqual(candidate(4, 8, 9),[12, 1]);
  assert.deepEqual(candidate(1, 10, 10),[11, 0]);
  assert.deepEqual(candidate(2, 11, 5),[7, 0]);
  assert.deepEqual(candidate(4, 5, 7),[9, 2]);
  assert.deepEqual(candidate(4, 5, 1),[5, 0]);
}

test();"
HumanEval_160,spa_Latn,js,"/ La matriz de operadores tiene al menos un operador, y la matriz de operandos tiene al menos dos operandos. / Operando es una matriz de enteros no negativos. / La longitud de la matriz de operadores es igual a la longitud de la matriz de operandos menos uno. / Nota: / => resultado = 9 / resultado = 2 + 3 * 4 - 5 / matriz = [2, 3, 4, 5] / operador ['+', '*', '-'] / Ejemplo: / Exposición exponencial (**) / División de piso ( //) / Multiplicación (*) / Sustracción ( - ) / Adición ( +) Las operaciones básicas de álgebra:/ expresión y devuelve la evaluación de esta expresión. / la segunda matriz es una matriz de enteros. Use las dos matrices dadas para construir el álgebra /Dado dos operador de matrices y operando. La primera matriz tiene operaciones básicas de álgebra, y function do_algebra(operator, operand){
","function do_algebra(operator, operand) {
    let expression = operand[0].toString();
    
    for (let i = 0; i < operator.length; i++) {
        let op = operator[i];
        let currentOperand = operand[i + 1];
        
        // Replace floor division symbol '//' with actual JavaScript behavior
        if (op === '//') {
            expression += `Math.floor(${currentOperand})`;
        } else {
            expression += ` ${op} ${currentOperand}`;
        }
    }
    
    // Evaluate the resulting expression
    let result = eval(expression);
    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = do_algebra;
  assert.deepEqual(candidate([""**"", ""*"", ""+""], [2, 3, 4, 5]),37);
  assert.deepEqual(candidate([""+"", ""*"", ""-""], [2, 3, 4, 5]),9);
  assert.deepEqual(candidate([""//"", ""*""], [7, 3, 4]),8);
}

test();"
HumanEval_161,spa_Latn,js,"/ Ejemplos / La función debe devolver la cadena resultante. / Si la cadena no contiene letras, invierta la cadena. / de lo contrario mantenerlo como está. / si s[i] es una letra, invierta su caso de inferior a superior o viceversa, Se le da una cadena de s.// >>> solve(""1234"")
// ""4321""
// >>> solve(""ab"")
// ""AB""
// >>> solve(""#a@C"")
// ""#A@c""
function solve(s){
","function solve(s) {
    let hasLetter = false;
    let result = '';

    for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (/[a-zA-Z]/.test(char)) {
            hasLetter = true;
            if (char === char.toLowerCase()) {
                result += char.toUpperCase();
            } else {
                result += char.toLowerCase();
            }
        } else {
            result += char;
        }
    }

    if (!hasLetter) {
        return result.split('').reverse().join('');
    }

    return result;
}","const assert = require('node:assert');


function test() {
  let candidate = solve;
  assert.deepEqual(candidate(""AsDf""),""aSdF"");
  assert.deepEqual(candidate(""1234""),""4321"");
  assert.deepEqual(candidate(""ab""),""AB"");
  assert.deepEqual(candidate(""#a@C""),""#A@c"");
  assert.deepEqual(candidate(""#AsdfW^45""),""#aSDFw^45"");
  assert.deepEqual(candidate(""#6@2""),""2@6#"");
  assert.deepEqual(candidate(""#$a^D""),""#$A^d"");
  assert.deepEqual(candidate(""#ccc""),""#CCC"");
}

test();"
HumanEval_162,spa_Latn,js,"/ Si 'text' es una cadena vacía, devuelve undefined. /Dada una cadena 'text', devuelve su cadena equivalente de hash md5. // >>> string_to_md5(""Hello world"")
// ""3e25960a79dbc69b674cd4ec67a72c62""
function string_to_md5(text){
","const crypto = require('crypto');

function string_to_md5(text) {
    if (text === """") {
        return undefined;
    }
    return crypto.createHash('md5').update(text).digest('hex');
}","const assert = require('node:assert');


function test() {
  let candidate = string_to_md5;
  assert.deepEqual(candidate(""Hello world""),""3e25960a79dbc69b674cd4ec67a72c62"");
  assert.deepEqual(candidate(""""),undefined);
  assert.deepEqual(candidate(""A B C""),""0ef78513b0cb8cef12743f5aeb35f888"");
  assert.deepEqual(candidate(""password""),""5f4dcc3b5aa765d61d8327deb882cf99"");
}

test();"
HumanEval_163,spa_Latn,js,"Por ejemplo:/ y b, en orden ascendente. /Dados dos enteros positivos a y b, devuelve los dígitos pares entre a y b.// >>> generate_integers(2, 8)
// [2, 4, 6, 8]
// >>> generate_integers(8, 2)
// [2, 4, 6, 8]
// >>> generate_integers(10, 14)
// []
function generate_integers(a, b){
","function generate_integers(a, b) {
    let start = Math.min(a, b);
    let end = Math.max(a, b);
    let evenDigits = [];

    for (let i = start; i <= end; i++) {
        if (i % 2 === 0) {
            evenDigits.push(i);
        }
    }

    return evenDigits;
}","const assert = require('node:assert');


function test() {
  let candidate = generate_integers;
  assert.deepEqual(candidate(2, 10),[2, 4, 6, 8]);
  assert.deepEqual(candidate(10, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(132, 2),[2, 4, 6, 8]);
  assert.deepEqual(candidate(17, 89),[]);
}

test();"
