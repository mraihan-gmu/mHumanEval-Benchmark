[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Lelee ma na ndep\u1ee5ta nke n\u1ecdmba, \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd \u1ecd b\u1ee5la d\u1ecb nso kar\u1ecba ibe ha kar\u1ecba \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 enyere.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ntinye na \u1ecdr\u1ee5 a b\u1ee5 eriri nwere \u1ecdt\u1ee5t\u1ee5 \u00ecgw\u00e8 nke nkedo nkedo. Ihe mgbaru \u1ecds\u1ecd g\u1ecb b\u1ee5 ikewap\u1ee5 nd\u1ecb otu ah\u1ee5 n'ime eriri d\u1ecb iche iche ma weghachite ndep\u1ee5ta nke nd\u1ecb ah\u1ee5. Otu d\u1ecb iche iche d\u1ecb mma (a na-emechi nkedo \u1ecd b\u1ee5la nke \u1ecdma) ma ghara itinye ya n'ime ibe ya. Eleghara ohere \u1ecd b\u1ee5la na eriri ntinye anya. Ihe Nlereanya:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" N'enye \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 na-agbanwe agbanwe, enwere ike \u1ecbba ya na ak\u1ee5k\u1ee5 integer (nke kachas\u1ecb ukwuu d\u1ecb ntak\u1ecbr\u1ecb kar\u1ecba n\u1ecdmba enyere) na decimals (ak\u1ee5k\u1ee5 f\u1ecdd\u1ee5r\u1ee5 na-ad\u1ecbkar\u1ecb obere kar\u1ecba 1). Laghachi ak\u1ee5k\u1ee5 nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" A na-enye g\u1ecb ndep\u1ee5ta nke nkw\u1ee5nye ego na \u1ecbd\u1ecdr\u1ecd \u1ecdr\u1ee5 na aka\u1ee5nt\u1ee5 ak\u1ee5 nke na-amalite na nguzozi efu. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdp\u1ee5ta ma \u1ecd b\u1ee5r\u1ee5 na n'oge \u1ecd b\u1ee5la ego nke aka\u1ee5nt\u1ee5 ah\u1ee5 dara n'okpuru efu, na n'oge ah\u1ee5 \u1ecdr\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi Eziokwu. Ma \u1ecd b\u1ee5gh\u1ecb ya, \u1ecd ga-alaghachi \u1ee4gha. Ihe Nlereanya:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Maka ndep\u1ee5ta enyere nke \u1ecdn\u1ee5\u1ecdg\u1ee5 ntinye, gbak\u1ecd\u1ecd Mean Absolute Deviation gburugburu nkezi nke dataset a. Mean Absolute Deviation b\u1ee5 nkezi nkewa d\u1ecb n'etiti ihe \u1ecd b\u1ee5la na etiti etiti (nkezi na nke a): MAD = nkezi  x - x_mean  Ihe Nlereanya:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Tinye n\u1ecdmba \"delimeter\" n'etiti ab\u1ee5\u1ecd \u1ecd b\u1ee5la na-esochi ihe nke input ndep\u1ee5ta \u2200numbers\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Ntinye aka na \u1ecdr\u1ee5 a b\u1ee5 eriri na-an\u1ecdchite anya \u1ecdt\u1ee5t\u1ee5 \u00ecgw\u00e8 maka nkedo nkedo nkewap\u1ee5r\u1ee5 site na oghere. Maka otu \u1ecd b\u1ee5la, mmep\u1ee5ta nke kachas\u1ecb omimi nke nkedo nke nkedo. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5 (() (()) nwere oke \u1ecdkwa ab\u1ee5\u1ecd nke nkedo mgbe ((())) nwere at\u1ecd.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Nch\u1ecbk\u1ecdta ndep\u1ee5ta ntinye nke eriri naan\u1ecb maka nd\u1ecb nwere substring nyere\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Maka ndep\u1ee5ta nke integers, laghachi a tuple es\u1ecbnede a nchikota na a ngwaah\u1ecba nke niile integers na a ndep\u1ee5ta. Efu nchikota kwes\u1ecbr\u1ecb h\u00e0 0 na efu ngwaah\u1ecba kwes\u1ecbr\u1ecb h\u00e0 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Site na ndep\u1ee5ta nke integers, mep\u1ee5ta ndep\u1ee5ta nke ihe kachas\u1ecb elu nke ach\u1ecdtara ruo oge enyere na usoro.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Nwale ma \u1ecd b\u1ee5r\u1ee5 na eriri enyere b\u1ee5 palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Ntinye b\u1ee5 eriri ab\u1ee5\u1ecd a na b nke nwere naan\u1ecb 1s na 0s. Mee XOR \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd na ntinye nd\u1ecb a ma weghachite nsonaaz\u1ee5 d\u1ecbka eriri.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Site na ndep\u1ee5ta nke eriri, laghachi nke kachas\u1ecb ogologo. Laghachi nke mb\u1ee5 ma \u1ecd b\u1ee5r\u1ee5 na enwere \u1ecdt\u1ee5t\u1ee5 eriri nke ogologo ah\u1ee5. Laghachi \u1ecc d\u1ecbgh\u1ecb ihe \u1ecd b\u1ee5la ma \u1ecd b\u1ee5r\u1ee5 na ndep\u1ee5ta ntinye b\u1ee5 ihe efu.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Laghachi a kas\u1ecb ukwuu nk\u1ecbt\u1ecb divisor nke ab\u1ee5\u1ecd integers a na b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Nch\u1ecbk\u1ecdta ndep\u1ee5ta nke prefixes niile site na nke kachas\u1ecb d\u1ecb mkpirikpi ruo ogologo nke eriri ntinye\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Na-eweghachi eriri nwere n\u1ecdmba nke nwere ohere site na 0 ruo n g\u1ee5nyere.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" N'enye eriri, ch\u1ecdp\u1ee5ta ole mkp\u1ee5r\u1ee5edemede d\u1ecb iche iche (n'agbanyegh\u1ecb \u1ee5d\u1ecb) \u1ecd nwere\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Ntinye na \u1ecdr\u1ee5 a b\u1ee5 eriri na-an\u1ecdchite anya \u1ee5da egw\u00fa na usoro ASCII p\u1ee5r\u1ee5 iche. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbk\u1ecdwa eriri a ma weghachite ndep\u1ee5ta nke integers kwek\u1ecdr\u1ecd na ole \u1ee5da \u1ecd b\u1ee5la anagh\u1ecb ad\u1ecbgide. Nke a b\u1ee5 ak\u1ee5k\u1ecd: 'o' - dum ama, na-ad\u1ecbgide an\u1ecd beats 'o\" - \u1ecdkara ama, na-ad\u1ecbgide ab\u1ee5\u1ecd beats '. \" \" - quater ama, na-ad\u1ecbgide otu beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Ch\u1ecdp\u1ee5ta ugboro ole a na-ah\u1ee5 mkp\u1ee5r\u1ee5okwu n'ime mkp\u1ee5r\u1ee5okwu mb\u1ee5. G\u1ee5\u1ecdn\u1ee5 oge nd\u1ecb na-agbak\u1ecd.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Ntinye b\u1ee5 eriri nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 site na 'efu' ruo 'iri na itoolu'. Nh\u1ecdr\u1ecd nd\u1ecb d\u1ecb mma b\u1ee5 'efu', 'otu', 'ab\u1ee5\u1ecd', 'at\u1ecd', 'an\u1ecd', 'ise', 'isii', 'asaa', 'asat\u1ecd' na 'iri na itoolu'. Laghachi eriri na n\u1ecdmba nd\u1ecb a haziri site na nke kacha nta ruo na nke kachas\u1ecb ukwuu\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Site na ndep\u1ee5ta \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 enyere (nke ogologo d\u1ecbkar\u1ecba ala ab\u1ee5\u1ecd) h\u1ecdr\u1ecd ma weghachite ab\u1ee5\u1ecd nke kacha nso ibe ha ma weghachite ha n'usoro (obere n\u1ecdmba, \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 buru ibu).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" N'enye ndep\u1ee5ta nke n\u1ecdmba (nke \u1ecd d\u1ecbkar\u1ecba ala ab\u1ee5\u1ecd), tinye mgbanwe na-agbanwe agbanwe na ndep\u1ee5ta ah\u1ee5, nke mere na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 kacha nta ga-agh\u1ecd 0 na nke kachas\u1ecb ukwuu ga-agh\u1ecd 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Nch\u1ecbk\u1ecdta e nyere ndep\u1ee5ta nke \u1ee5kp\u1ee5r\u1ee5 Python \u1ecd b\u1ee5la maka naan\u1ecb integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Nloghachi ogologo nke nyere eriri\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Maka \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nyere n, ch\u1ecdta \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 kachas\u1ecb ukwuu nke na-eke n n'otu n'otu, nke pere mpe kar\u1ecba n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Nch\u1ecbk\u1ecdta nke nd\u1ecb isi nke \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 zuru ezu nyere na usoro site na nke kachas\u1ecb nta ruo nke kachas\u1ecb ukwuu. A ga-edep\u1ee5ta n\u1ecdmba nke oge \u1ecd b\u1ee5la kwek\u1ecdr\u1ecd na ugboro ole \u1ecd na-ap\u1ee5ta na factorization. \u1eccn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ntinye kwes\u1ecbr\u1ecb \u1ecbd\u1ecb ka ngwaah\u1ecba nke ihe niile\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Site na ndep\u1ee5ta nke integers, wep\u1ee5 ihe niile na-eme ihe kar\u1ecbr\u1ecb otu ugboro. Debe usoro nke ihe nd\u1ecb f\u1ecdd\u1ee5r\u1ee5 d\u1ecb ka ntinye.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Maka eriri enyere, t\u1ee5ghar\u1ecba obere mkp\u1ee5r\u1ee5edemede ka \u1ecd b\u1ee5r\u1ee5 nnukwu mkp\u1ee5r\u1ee5edemede na nnukwu mkp\u1ee5r\u1ee5edemede ka \u1ecd b\u1ee5r\u1ee5 obere mkp\u1ee5r\u1ee5edemede.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Gbak\u1ecdta ndep\u1ee5ta nke eriri n'ime otu eriri\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Nch\u1ecbk\u1ecdta ndep\u1ee5ta ntinye nke eriri naan\u1ecb maka nd\u1ecb na-amalite site na prefix nyere.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Laghachi naan\u1ecb n\u1ecdmba d\u1ecb mma na ndep\u1ee5ta ah\u1ee5.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Laghachi eziokwu ma \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 enyere b\u1ee5 isi, na \u1ee5gha ma \u1ecd b\u1ee5gh\u1ecb.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Na-enyocha polynomial na \u1ecdn\u1ee5\u1ecdg\u1ee5 xs na isi x. laghachi xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"\u1eccr\u1ee5 a na-ewe ndep\u1ee5ta l ma weghachite ndep\u1ee5ta l 'd\u1ecb ka nke ah\u1ee5 l' b\u1ee5 otu ihe ah\u1ee5 na l na indexes nd\u1ecb na-ad\u1ecbgh\u1ecb nkewa site na at\u1ecd, ebe \u1ee5kp\u1ee5r\u1ee5 ya na indexes nd\u1ecb na-ekewa site na at\u1ecd h\u00e0 nhata \u1ee5kp\u1ee5r\u1ee5 nke ihe kwek\u1ecdr\u1ecd na indexes nke l, ma edozi.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Weghachite ihe nd\u1ecb a na-ah\u1ecdp\u1ee5tagh\u1ecb ahazi na ndep\u1ee5ta\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Na-alaghachi ihe kachas\u1ecb na ndep\u1ee5ta ah\u1ee5.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Laghachi \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 7 na-ap\u1ee5ta na integers na-erugh\u1ecb n nke a na-ekewa site na 11 ma \u1ecd b\u1ee5 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"\u1eccr\u1ee5 a na-ewe ndep\u1ee5ta l ma weghachite ndep\u1ee5ta l 'd\u1ecb ka nke ah\u1ee5 l' b\u1ee5 otu ihe ah\u1ee5 na l na nd\u1ecb na-ad\u1ecbgh\u1ecb ah\u1ee5kebe, ebe uru ya na \u1ecdb\u1ee5na indexes h\u00e0 nhata na \u1ee5kp\u1ee5r\u1ee5 nke \u1ecdb\u1ee5na indexes nke l, ma ahazi.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    na-alaghachi eriri koodu site na \u00ecgw\u00e8 nd\u1ecb na-agbaghar\u1ecb agbaghar\u1ecb nke mkp\u1ee5r\u1ee5edemede at\u1ecd.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib na-alaghachi n-th \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke b\u1ee5 n\u1ecdmba Fibonacci ma \u1ecd b\u1ee5kwa isi.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero na-ewe ndep\u1ee5ta nke integers d\u1ecb ka ntinye. \u1ecd na-alaghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na e nwere ihe at\u1ecd d\u1ecb iche iche na ndep\u1ee5ta ah\u1ee5 na nch\u1ecbk\u1ecdta na efu, na \u1ee4gha ma \u1ecd b\u1ee5gh\u1ecb.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Were anya nke uche h\u1ee5 okporo \u1ee5z\u1ecd nke d\u1ecb ogologo ogologo. n \u1ee5gb\u1ecdala na-aga n'aka ekpe gaa n'aka nri; n n'otu oge, otu \u00ecgw\u00e8 d\u1ecb iche iche nke n \u1ee5gb\u1ecdala na-aga n'aka nri gaa n'aka ekpe. \u1ee4gb\u1ecdala ab\u1ee5\u1ecd ah\u1ee5 na-amalite site na nke d\u1ecb anya site na ibe ha. \u1ee4gb\u1ecdala niile na-aga n'otu \u1ecds\u1ecd. A na-ekwu na \u1ee5gb\u1ecdala ab\u1ee5\u1ecd na-agbag\u1ecd mgbe \u1ee5gb\u1ecdala na-aga n'aka ekpe gaa n'aka nri na-ak\u1ee5 \u1ee5gb\u1ecdala na-aga n'aka nri gaa n'aka ekpe. Ot\u00fa \u1ecd d\u1ecb, \u1ee5gb\u1ecdala nd\u1ecb ah\u1ee5 siri ike ma sie ike; n'ihi ya, ha na-aga n'ihu na-agaghar\u1ecb na trajectory ha d\u1ecb ka a ga-as\u1ecb na ha agbagh\u1ecb. \u1eccr\u1ee5 a na-ewep\u1ee5ta \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke nkwek\u1ecdr\u1ecbta d\u1ecb ot\u00fa ah\u1ee5.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Ndep\u1ee5ta nloghachi na ihe nd\u1ecb e ji 1 m\u1ee5baa.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero na-ewe ndep\u1ee5ta nke integers d\u1ecb ka ntinye. \u1ecd na-alaghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na e nwere ihe ab\u1ee5\u1ecd d\u1ecb iche na ndep\u1ee5ta ah\u1ee5 na nch\u1ecbk\u1ecdta na efu, na \u1ee4gha ma \u1ecd b\u1ee5gh\u1ecb.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Gbanwee isi ihe d\u1ecb na n\u1ecdmba ntinye x na isi. laghachi akara ngosi eriri mgbe nt\u1ee5ghar\u1ecb ah\u1ee5 gas\u1ecbr\u1ecb. n\u1ecdmba isi d\u1ecb obere kar\u1ecba 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"E nyere ogologo nke ak\u1ee5k\u1ee5 na elu nloghachi ebe maka a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Usoro \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 Fib4 b\u1ee5 usoro yiri nke Fibbonacci nke ak\u1ecdwap\u1ee5tara d\u1ecb ka nd\u1ecb a: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Biko dee \u1ecdr\u1ee5 iji r\u1ee5\u1ecd \u1ecdr\u1ee5 nke \u1ecdma na-agbak\u1ecd n-th mmewere nke usoro \u1ecdn\u1ee5\u1ecdg\u1ee5 fib4. Ejila recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Nl\u1ecdghachi nke etiti nke ihe nd\u1ecb d\u1ecb na ndep\u1ee5ta m.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Na-enyocha ma eriri enyere b\u1ee5 palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Laghachi 2^n modulo p (mara maka \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    na-alaghachi eriri koodu site na \u1ecbkwaga ihe odide \u1ecd b\u1ee5la site na 5 na mkp\u1ee5r\u1ee5edemede.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels b\u1ee5 \u1ecdr\u1ee5 na-ewe eriri ma weghachite eriri na-enwegh\u1ecb \u1ee5da olu.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na n\u1ecdmba niile d\u1ecb na ndep\u1ee5ta m d\u1ecb n'okpuru \u1ecdn\u1ee5ego t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Tinye n\u1ecdmba ab\u1ee5\u1ecd x na y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Lelee ma okwu ab\u1ee5\u1ecd nwere otu mkp\u1ee5r\u1ee5edemede.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Laghachi n\u1ecdmba Fibonacci nke n.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets b\u1ee5 eriri nke \"<\" na \">\". laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na bracket \u1ecd b\u1ee5la nwere bracket mmechi kwek\u1ecdr\u1ecd.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Laghachi Eziokwu b\u1ee5 ndep\u1ee5ta ihe na-abawanye ma \u1ecd b\u1ee5 na-ebelata.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Laghachi edozi ihe nd\u1ecb a na-ah\u1ee5kar\u1ecb maka ndep\u1ee5ta ab\u1ee5\u1ecd.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Laghachi ihe kachas\u1ecb mkpa nke n. Were n > 1 ma \u1ecd b\u1ee5gh\u1ecb onye isi.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n b\u1ee5 \u1ecdr\u1ee5 na-agbak\u1ecdta n\u1ecdmba site na 1 ruo n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets b\u1ee5 eriri nke \"(\" na \"\". laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na bracket \u1ecd b\u1ee5la nwere bracket mmechi.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs na-an\u1ecdchi anya \u1ecdn\u1ee5\u1ecdg\u1ee5 nke polynomial. xs[0] + xs[1] * x + xs[2] * x^2 +.... Laghachi ihe nketa nke polynomial a n'otu \u1ee5d\u1ecb.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"Usoro \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 FibFib b\u1ee5 usoro yiri nke Fibbonacci nke ak\u1ecdwap\u1ee5tara d\u1ecb ka nd\u1ecb a: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Biko dee \u1ecdr\u1ee5 iji r\u1ee5\u1ecd \u1ecdr\u1ee5 nke \u1ecdma na-agbak\u1ecd n-th element nke usoro n\u1ecdmba fibfib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nTinye ihe nd\u1ecb \u1ecdz\u1ecd a ga-eji nwalee ya.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Gbanwee mkp\u1ee5r\u1ee5okwu nke integer x, gbanwee mkp\u1ee5r\u1ee5okwu ah\u1ee5 n'aka nri site na mbughar\u1ecb ma weghachite nsonaaz\u1ee5 d\u1ecbka eriri. \u1ecc b\u1ee5r\u1ee5 na mbughar\u1ecb > \u1ecdn\u1ee5\u1ecdg\u1ee5 nke mkp\u1ee5r\u1ee5okwu, laghachi mkp\u1ee5r\u1ee5okwu gbanwere.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"\u1eccr\u1ee5 Dee \u1ecdr\u1ee5 nke na-ewe eriri d\u1ecb ka ntinye ma weghachite nchikota nke mkp\u1ee5r\u1ee5edemede elu naan\u1ecb' koodu ASCII. Ihe at\u1ee5: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Na \u1ecdr\u1ee5 a, a ga-enye g\u1ecb eriri nke na-an\u1ecdchite anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ap\u1ee5l na oranges nke a na-ekesa na nkata mkp\u1ee5r\u1ee5 osisi nkata a nwere ap\u1ee5l, oranges, na mango mkp\u1ee5r\u1ee5 osisi. Nyere eriri nke na-an\u1ecdchite anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke oranges na ap\u1ee5l na integer nke na-an\u1ecdchite anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke mkp\u1ee5r\u1ee5 osisi na nkata weghachite \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke mkp\u1ee5r\u1ee5 osisi mango na nkata. maka examble: fruit_distribution\"5(apples and 6 oranges\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 ap\u1ee5l na 1 oranges\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 ap\u1ee5l na 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 ap\u1ee5l na 1 oranges\",1 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"E nyere usoro nke na-an\u1ecdchite anya alaka nke osisi nke nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 na-ab\u1ee5gh\u1ecb nke na-ad\u1ecbgh\u1ecb mma \u1ecdr\u1ee5 g\u1ecb b\u1ee5 \u1ecbd\u1ecdr\u1ecd otu n'ime \u1ecdn\u1ee5 na laghachi ya. Nch\u1ecbk\u1ecdta a na-ad\u1ecdr\u1ecd kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \u1ecdn\u1ee5 na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta. \u1ecc b\u1ee5r\u1ee5 na a ch\u1ecdtara \u1ecdt\u1ee5t\u1ee5 \u1ecdn\u1ee5 na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta. A ga-eweghachi \u1ecdn\u1ee5 nke nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta. A ga-eweghachi \u1ecdn\u1ee5 na-ad\u1ecdr\u1ecd na ndep\u1ee5ta, [small_value, ya index ], \u1ecc b\u1ee5r\u1ee5 na enwegh\u1ecb \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ma \u1ecd b\u1ee5 na usoro a na-enye b\u1ee5 ihe efu, laghachi []. Ihe Nlereanya 1: Ntinye: [4,2,3] Mmep\u1ee5ta: [2, 1] Nk\u1ecdwa: 2 nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta, na 2 nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta. Ihe Nlereanya 2: Ntinye: [1,2,3] Mmep\u1ee5ta: [2,\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    N'inye usoro nke integers, ch\u1ecdta \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nke ihe nd\u1ecb d\u1ecb mkpa ka a gbanwee iji mee ka usoro ah\u1ee5 d\u1ecb palindromic. Usoro palindromic b\u1ee5 usoro a na-ag\u1ee5 otu az\u1ee5 na n'ihu. Na otu mgbanwe, \u1ecb nwere ike \u1ecbgbanwe otu ihe na ihe \u1ecd b\u1ee5la \u1ecdz\u1ecd. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Dee ihe omume nke na-alaghachi ezi ma \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 enyere b\u1ee5 \u1ecbba \u1ee5ba nke n\u1ecdmba at\u1ecd na-ad\u1ecbgh\u1ecb mma ma \u1ecd b\u1ee5gh\u1ecb \u1ee5gha. \u1ecamara na (a) d\u1ecb obere kar\u1ecba 100. Ihe Nlereanya: is_multiply_prime(30) == Ezi 30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"\u1eccr\u1ee5 g\u1ecb b\u1ee5 ide \u1ecdr\u1ee5 nke na-alaghachi eziokwu ma \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ee5\u1ecdg\u1ee5 x b\u1ee5 ike d\u1ecb mfe nke n na \u1ee5gha na ikpe nd\u1ecb \u1ecdz\u1ecd. x b\u1ee5 ike d\u1ecb mfe nke n ma \u1ecd b\u1ee5r\u1ee5 na n**int=x D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: is_simple_power(1, 4) => eziokwu b\u1ee5_simple_power(2, 2) => eziokwu b\u1ee5_simple_power(8, 2) => eziokwu b\u1ee5_simple_power(3, 2) => \u1ee5gha b\u1ee5_simple_power_(3, 1) \u1ee5gha => b\u1ee5_simple_power_(5, 3) => \u1ee5gha\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"A gwara g\u1ecb ka \u1ecb dee \u1ecdr\u1ee5 nke na-enweta n\u1ecdmba hexadecimal d\u1ecb ka eriri ma g\u1ee5\u1ecd \u1ecdn\u1ee5\u1ecdg\u1ee5 nke mkp\u1ee5r\u1ee5edemede hexadecimal b\u1ee5 nd\u1ecb b\u1ee5 isi (n\u1ecdmba isi, ma \u1ecd b\u1ee5 isi, b\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5 an\u1ee5 ah\u1ee5 kar\u1ecbr\u1ecb 1 nke na-ab\u1ee5gh\u1ecb ngwaah\u1ecba nke \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd d\u1ecb obere). \u1eccn\u1ee5 \u1ecdg\u1ee5g\u1ee5 hexadecimal b\u1ee5 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \u1eccn\u1ee5 \u1ecdg\u1ee5g\u1ee5 isi b\u1ee5 2, 3, 5, 7, 11, 13, 17,... Ya mere, \u1ecb ga-ach\u1ecdp\u1ee5ta \u1ecdn\u1ee5\u1ecdg\u1ee5 nke mkp\u1ee5r\u1ee5edemede nd\u1ecb a: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13). Cheta: \u1ecb nwere ike iche na ntinye b\u1ee5 mgbe niile ziri ezi ma \u1ecd b\u1ee5 oghere, na akara A,B,C,D,E,F, b\u1ee5 nnukwu okwu. Ihe at\u1ee5: Maka num = \"AB\" ihe mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 1. Maka\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"A ga-enye g\u1ecb n\u1ecdmba na decimal \u1ee5d\u1ecb na \u1ecdr\u1ee5 g\u1ecb b\u1ee5 iji t\u1ecdghata ya na \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd usoro. The \u1ecdr\u1ee5 kwes\u1ecbr\u1ecb laghachi a eriri, na onye \u1ecd b\u1ee5la agwa na-an\u1ecdchi anya a \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd usoro. Onye \u1ecd b\u1ee5la agwa na eriri ga-ab\u1ee5 '0' ma \u1ecd b\u1ee5 '1'. A ga-enwe ihe mmezi di na nwunye nke odide 'db' na mmalite na na njedebe nke eriri. The mmezi odide na-e-enyere na usoro. Ihe Nlereanya: decimal_to_binary(15) # alaghachi \"db1111db\" decimal_to_binary32) # alaghachi \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"A na-enye g\u1ecb eriri s. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecblele ma eriri ah\u1ee5 \u1ecd d\u1ecb mma ma \u1ecd b\u1ee5 na \u1ecd b\u1ee5gh\u1ecb. A na-enwe obi \u1ee5t\u1ecd ma \u1ecd b\u1ee5r\u1ee5 na ogologo ya d\u1ecbkar\u1ecba ala 3 na mkp\u1ee5r\u1ee5edemede 3 \u1ecd b\u1ee5la d\u1ecb iche iche D\u1ecb ka ihe at\u1ee5: is_happy(a) => False is_happy(aa) => False is_happy(abcd) => True is_happy(aabb) => False is_happy(adb) => True is_happy(xyy) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u1ecc b\u1ee5 izu ikpeaz\u1ee5 nke \u1ecdkara af\u1ecd ag\u1ee5makw\u1ee5kw\u1ecd na onye nk\u1ee5zi nwere inye akara ule na \u1ee5m\u1ee5 akw\u1ee5kw\u1ecd. Onye nk\u1ee5zi ah\u1ee5 na-eme ya onwe ya alg\u1ecdridim maka grading. Nan\u1ecb nsogbu b\u1ee5, \u1ecd na-efu koodu \u1ecd na-eji maka grading. \u1ecc nyere g\u1ecb a ndep\u1ee5ta nke GPAs maka \u1ee5f\u1ecdd\u1ee5 \u1ee5m\u1ee5 akw\u1ee5kw\u1ecd na \u1ecb ga-ede a \u1ecdr\u1ee5 na ike mmep\u1ee5ta a ndep\u1ee5ta nke akw\u1ee5kw\u1ecd ozi akara ule na-eji na-eson\u1ee5 table: GPA. Letter akara 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E: grade_equation ([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-ewe eriri ma laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na ogologo eriri b\u1ee5 n\u1ecdmba isi ma \u1ecd b\u1ee5 \u1ee4gha ma \u1ecd b\u1ee5gh\u1ecb Ihe at\u1ee5 prime_length (('Ekele') == Eziokwu prime_length (('abcdcba') == Eziokwu prime_length (('kittens') == Eziokwu prime_length (('orange') == \u1ee4gha\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Nyere a mma integer n, laghachi na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke n\u1ecdmba nke n-\u1ecdbula mma integers na-amalite ma \u1ecd b\u1ee5 na-agw\u1ee5 na 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"N'enye \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 d\u1ecb mma N, weghachite ng\u1ee5k\u1ecdta nke mkp\u1ee5r\u1ee5edemede ya na \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd. Ihe Nlereanya Maka N = 1000, ng\u1ee5k\u1ecdta nke mkp\u1ee5r\u1ee5edemede ga-ab\u1ee5 1 mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"1\". Maka N = 150, ng\u1ee5k\u1ecdta nke mkp\u1ee5r\u1ee5edemede ga-ab\u1ee5 6 mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"110\". Maka N = 147, ng\u1ee5k\u1ecdta nke mkp\u1ee5r\u1ee5edemede ga-ab\u1ee5 12 mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"1100\". Mgbanwe: @N integer Constraints: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. Mmep\u1ee5ta: eriri \u1ecdn\u1ee5\u1ecdg\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"N'enye ndep\u1ee5ta nke integer nd\u1ecb na-ab\u1ee5gh\u1ecb oghere lst. gbakwunye ihe nd\u1ecb ah\u1ee5 na-ad\u1ecbgh\u1ecb ah\u1ee5kebe na nd\u1ecb na-ad\u1ecbgh\u1ecb ah\u1ee5kebe.. Ihe at\u1ee5: gbakwunye (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Dee \u1ecdr\u1ee5 nke na-ewe eriri ma weghachite \u1ee5d\u1ecb nke ya. \u1ee4d\u1ecb nke eriri, b\u1ee5 eriri ebe a na-edochi okwu niile (nkewap\u1ee5r\u1ee5 site na oghere) site na okwu \u1ecdh\u1ee5r\u1ee5 ebe a na-edozi ihe odide niile na-ar\u1ecbgo n'usoro dabere na uru ascii. R\u1ecbba ama: \u1eca ga-edebe usoro nke okwu na oghere efu na ah\u1ecbr\u1ecbokwu ah\u1ee5. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: anti_shuffle ((('Hi') laghachi 'Hi' anti_shuffle ((('hello') laghachi 'ehllo' anti_shuffle (('Hello World!!!') laghachi 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    A na-enye g\u1ecb data 2 dimensional, d\u1ecb ka ndep\u1ee5ta nd\u1ecb na-agbak\u1ecdta, nke yiri matriks, Ot\u00fa \u1ecd d\u1ecb, n'ad\u1ecbgh\u1ecb ka matriks, ah\u1ecbr\u1ecb \u1ecd b\u1ee5la nwere ike \u1ecbnwe \u1ecdn\u1ee5\u1ecdg\u1ee5 d\u1ecb iche iche nke ogidi. Nyere lst, na integer x, ch\u1ecdta integers x na ndep\u1ee5ta ah\u1ee5, wee laghachi ndep\u1ee5ta nke tuples, [(x1, y1), (x2, y2)...] d\u1ecb ka nke na tuple \u1ecd b\u1ee5la b\u1ee5 nhazi - (ah\u1ecbr\u1ecb, ogidi), malite na 0.\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    N'enye usoro nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 na-ab\u1ee5gh\u1ecb nke na-ad\u1ecbgh\u1ecb mma, weghachite otu nke usoro ah\u1ee5 e nyere mgbe \u1ecb na-edozi, \u1ecb ga-edozi usoro ah\u1ee5 e nyere na-ar\u1ecbgo ma \u1ecd b\u1ee5r\u1ee5 na nchikota ((mkp\u1ee5r\u1ee5 ego mb\u1ee5, uru ikpeaz\u1ee5) b\u1ee5 ihe d\u1ecb iche, ma \u1ecd b\u1ee5 dozie ya na-agbadata ma \u1ecd b\u1ee5r\u1ee5 na nchikota ((mkp\u1ee5r\u1ee5 ego mb\u1ee5, uru ikpeaz\u1ee5) b\u1ee5 \u1ecdb\u1ee5na. R\u1ecbba ama: * agbanwela usoro ah\u1ee5 e nyere. Ihe at\u1ee5: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Mep\u1ee5ta \u1ecdr\u1ee5 encrypt nke na-ewe eriri d\u1ecb ka ar\u1ee5m\u1ee5ka ma weghachite eriri ezoro ezo na mkp\u1ee5r\u1ee5edemede na-agbaghar\u1ecb. Ekwes\u1ecbr\u1ecb \u1ecbt\u1ee5ghar\u1ecb mkp\u1ee5r\u1ee5edemede n'\u1ee5z\u1ecd d\u1ecb ot\u00fa ah\u1ee5 ka mkp\u1ee5r\u1ee5edemede na-agbada site na ab\u1ee5\u1ecd na-am\u1ee5ba na ebe ab\u1ee5\u1ecd. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: encrypt('hi') na-alaghachi 'lm' encrypt('asdfghjkl') na-alaghachi 'ewhjklnop' encrypt('gf') na-alaghachi 'kj' encrypt('et') na-alaghachi 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    A na-enye g\u1ecb ndep\u1ee5ta nke integers. Dee \u1ecdr\u1ee5 next_smallest (() nke na-alaghachi ihe nke ab\u1ee5\u1ecd kachas\u1ecb nta na ndep\u1ee5ta ah\u1ee5. Laghachi None ma \u1ecd b\u1ee5r\u1ee5 na enwegh\u1ecb ihe d\u1ecb ot\u00fa ah\u1ee5. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    A ga-enye g\u1ecb okwu, \u1ecdr\u1ee5 g\u1ecb ga-ab\u1ee5 \u1ecbg\u1ee5ta \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke okwu nd\u1ecb na-agw\u1ee5 ike. Ihe na-agw\u1ee5 ike b\u1ee5 ah\u1ecbr\u1ecbokwu nke na-amalite site na okwu \"I\". A na-ejik\u1ecdta ah\u1ecbr\u1ecbokwu site na '.', '?' ma \u1ecd b\u1ee5 '!'. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Dee \u1ecdr\u1ee5 nke na-ewe ozi, ma tinye ya n'\u1ee5z\u1ecd ga-eme ka \u1ecd gbanwee mkp\u1ee5r\u1ee5edemede niile, dochie vowels niile na ozi ah\u1ee5 na mkp\u1ee5r\u1ee5edemede nke p\u1ee5tara 2 ebe n'ihu vowel ah\u1ee5 na mkp\u1ee5r\u1ee5edemede Bekee. Were naan\u1ecb mkp\u1ee5r\u1ee5edemede. Ihe at\u1ee5:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"A na-enye g\u1ecb ndep\u1ee5ta nke integers. \u1ecakwes\u1ecbr\u1ecb \u1ecbch\u1ecdta \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb elu ma weghachite nch\u1ecbk\u1ecdta nke mkp\u1ee5r\u1ee5edemede ya. Ihe at\u1ee5: Maka lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 10 Maka lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 25 Maka lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 13 Maka lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 11 Maka lst = [0,81,12,31,21] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 3 Maka lst = [0,1,8,1,2,7]\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    N'inye okwu, laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na igodo niile b\u1ee5 eriri na obere ma \u1ecd b\u1ee5 igodo niile b\u1ee5 eriri na nnukwu, ma \u1ecd b\u1ee5gh\u1ecb laghachi \u1ee4gha. \u1eccr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi \u1ee4gha b\u1ee5 okwu ah\u1ee5 enyere b\u1ee5 oghere. Ihe at\u1ee5: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) kwes\u1ecbr\u1ecb \u1ecblaghachi Eziokwu. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) kwes\u1ecbr\u1ecb \u1ecblaghachi \u1ee4gha. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) kwes\u1ecbr\u1ecb \u1ecblaghachi \u1ee4gha. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) kwes\u1ecbr\u1ecb \u1ecblaghachi \u1ee4gha. check\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Mejuputa oru nke na-ewe \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 na-ab\u1ee5gh\u1ecb nke na-ad\u1ecbgh\u1ecb mma ma weghachite usoro nke mb\u1ee5 n integers nd\u1ecb b\u1ee5 n\u1ecdmba mb\u1ee5 na obere kar\u1ecba n. d\u1ecbka \u1ecdm\u1ee5maat\u1ee5: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Mezue \u1ecdr\u1ee5 nke na-ewe \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd ma weghachite ngwaah\u1ecba nke \u1ecdn\u1ee5\u1ecdg\u1ee5 ha. Were ya na ntinye ah\u1ee5 d\u1ecb mma mgbe niile. Ihe at\u1ee5: \u1ecbba \u1ee5ba ((148, 412) kwes\u1ecbr\u1ecb \u1ecblaghachi 16. \u1ecbba \u1ee5ba ((19, 28) kwes\u1ecbr\u1ecb \u1ecblaghachi 72. \u1ecbba \u1ee5ba ((2020, 1851) kwes\u1ecbr\u1ecb \u1ecblaghachi 0. \u1ecbba \u1ee5ba ((14,-15) kwes\u1ecbr\u1ecb \u1ecblaghachi 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    N'inye eriri s, g\u1ee5\u1ecd \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke \u1ee5da olu d\u1ecb elu na \u1ecdb\u1ee5na indexes. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: count_upper (('aBCdEf') na-alaghachi 1 count_upper (('abcdefg') na-alaghachi 0 count_upper (('dBBE') na-alaghachi 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    N'enye \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nke n, \u1ecb ga-eme ka nkume d\u1ecb n n. N'elu nke mb\u1ee5 nwere nkume n. \u1eccn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke nkume na \u1ecdkwa \u1ecdz\u1ecd b\u1ee5: - n\u1ecdmba \u1ecdz\u1ecd na-esote ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 ihe d\u1ecb iche. - n\u1ecdmba \u1ecdz\u1ecd na-esote ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 \u1ecdb\u1ee5na. Laghachi \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke nkume na \u1ecdkwa \u1ecd b\u1ee5la na ndep\u1ee5ta, ebe ihe d\u1ecb na index i na-an\u1ecdchite anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke nkume na \u1ecdkwa (i + 1).\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    A ga-enye g\u1ecb eriri okwu nkewap\u1ee5r\u1ee5 site na commas ma \u1ecd b\u1ee5 oghere. \u1eccr\u1ee5 g\u1ecb b\u1ee5 ikewa eriri ah\u1ee5 n'ime okwu ma weghachite usoro nke okwu. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: words_string ((\"Hi, aha m b\u1ee5 John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"\u1eccr\u1ee5 a na-ewe n\u1ecdmba ab\u1ee5\u1ecd d\u1ecb mma x na y ma weghachite \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb elu nke d\u1ecb na nso [x, y] g\u1ee5nyere. \u1ecc b\u1ee5r\u1ee5 na \u1ecdnwegh\u1ecb n\u1ecdmba d\u1ecb ot\u00fa ah\u1ee5, mgbe ah\u1ee5 \u1ecdr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi -1. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: h\u1ecdr\u1ecd_n\u1ecdmba 12, 15) = 14 h\u1ecdr\u1ecd_n\u1ecdmba 13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"A na-enye g\u1ecb \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd d\u1ecb mma n na m, \u1ecdr\u1ee5 g\u1ecb b\u1ee5 \u1ecbgbak\u1ecd nkezi nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 site n ruo m (g\u1ee5nyere n na m). Gbanwee az\u1ecbza ya na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nso ma gbanwee ya na \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd. \u1ecc b\u1ee5r\u1ee5 na n kar\u1ecbr\u1ecb m, laghachi -1. Ihe Nlereanya: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"N'inye ndep\u1ee5ta nke n\u1ecdmba zuru ezu x. weghachite ndep\u1ee5ta nke ihe niile na-enwegh\u1ecb ihe \u1ecd b\u1ee5la. R\u1ecbba ama: A ga-edozi ndep\u1ee5ta a na-agbak\u1ecdta na-ar\u1ecbwanye elu. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    N'inye usoro nke integers, dozie usoro nke integers nke d\u1ecb n'etiti 1 na 9 g\u1ee5nyere, gbanwee usoro ah\u1ee5, wee dochie anya mkp\u1ee5r\u1ee5edemede \u1ecd b\u1ee5la site na aha ya kwek\u1ecdr\u1ecd na \"Otu\", \"Ab\u1ee5\u1ecd\", \"At\u1ecd\", \"An\u1ecd\", \"Asaa\", \"Asaa\", \"Asaa\", \"Asaa\", \"Iri\". D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> \u1ee5d\u1ecb arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> \u1ee5d\u1ecb arr -> [8, 5, 4, 3, 2, 2, 1, 1] laghachi [\"Asaa\", \"Asaa\", \"At\u1ecd\", \"At\u1ecd\", \"At\u1ecd\", \"Ab\u1ee5\u1ecd\", \"Otu\", \"Otu\"] \u1ecc b\u1ee5r\u1ee5 na usoro ah\u1ee5 b\u1ee5 ihe efu, weghachite usoro: arr = [] laghachi [] \u1ecc b\u1ee5r\u1ee5 na usoro ah\u1ee5 nwere n\u1ecdmba \u1ecd b\u1ee5la d\u1ecb iche iche, leghara ya anya: arr\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Mejuputa oru f nke na-ewere n dika ihe omuma, ma weghachite ndep\u1ee5ta nke nha n, nke mere na uru nke ihe di na index i bu ihe omuma nke i ma oburu na i bu kwa ma obu nchikota onu ogugu site na 1 rue i ma obu. i na-amalite site na 1. ihe omuma nke i bu otutu onu ogugu site na 1 rue i (1 * 2 *... * i). Ihe Nlereanya: f ((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    N'enye \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 d\u1ecb mma n, laghachi otu tuple nke nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke palindromes na-ad\u1ecbgh\u1ecb ah\u1ee5kebe na nke na-adaba n'ime oke ((1, n), g\u1ee5nyere. Ihe Nlereanya1: Ntinye: 3 Ntinye: (1, 2) Nk\u1ecdwa: Ntinye palindromes b\u1ee5 1, 2, 3. otu n'ime ha b\u1ee5 \u1ecdb\u1ee5na, na ab\u1ee5\u1ecd n'ime ha b\u1ee5 nd\u1ecb na-ad\u1ecbgh\u1ecb ah\u1ee5kebe. Ihe Nlereanya2: Ntinye: 12 Ntinye: (4, 6) Nk\u1ecdwa: Ntinye palindromes b\u1ee5 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. an\u1ecd n'ime ha b\u1ee5 \u1ecdb\u1ee5na, na 6 n'ime ha b\u1ee5 nd\u1ecb na-ad\u1ecbgh\u1ecb ah\u1ee5kebe. R\u1ecbba ama: 1. 1 <= n <= 10 ^ 3 2. tuple laghachiri \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke palindromes na-ad\u1ecbgh\u1ecb ah\u1ee5kebe na nd\u1ecb na-\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Dee \u1ecdr\u1ee5 count_nums nke na-ewe usoro nke integers ma weghachite \u1ecdn\u1ee5\u1ecdg\u1ee5 nke ihe nd\u1ecb nwere nch\u1ecbk\u1ecdta nke mkp\u1ee5r\u1ee5edemede > 0. \u1ecc b\u1ee5r\u1ee5 na \u1ecdn\u1ee5\u1ecdg\u1ee5 d\u1ecb nj\u1ecd, mgbe ah\u1ee5 akara mb\u1ee5 ya ga-ab\u1ee5 ihe na-ad\u1ecbgh\u1ecb mma: d\u1ecbka -123 nwere akara akara -1, 2, na 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Any\u1ecb nwere 'arr' nke N integers arr[1], arr[2],..., arr[N].A ga-edozi \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nd\u1ecb d\u1ecb na array ah\u1ee5. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdp\u1ee5ta ma \u1ecd ga-ekwe omume \u1ecbhazi usoro na-ad\u1ecbgh\u1ecb adaba site na \u1ecbr\u1ee5 \u1ecdr\u1ee5 nd\u1ecb a na array: A na-ahap\u1ee5 g\u1ecb ka \u1ecb r\u1ee5\u1ecd \u1ecdr\u1ee5 nke \u1ecdma ugboro ole \u1ecd b\u1ee5la. Otu \u1ecdr\u1ee5 nke \u1ecdma p\u1ee5tara \u1ecbmeghar\u1ecb ihe niile nke array site na otu \u1ecdn\u1ecdd\u1ee5 na nt\u1ee5ziaka ziri ezi. Ihe ikpeaz\u1ee5 nke array ga-akwaga na mmalite \u1ecdn\u1ecdd\u1ee5 na array i.e. 0th index. \u1ecc b\u1ee5r\u1ee5 na \u1ecd ga-ekwe omume inweta usoro a haziri ahazi site na \u1ecbr\u1ee5 \u1ecdr\u1ee5 n'elu mgbe ah\u1ee5 laghachi Ezi ma \u1ecd b\u1ee5gh\u1ecb laghachi \u1ee4gha. \u1ecc b\u1ee5r\u1ee5 na e nyere array b\u1ee5 ihe efu mgbe ah\u1ee5 laghachi Ezi. R\u1ecbba ama: E nyere ndep\u1ee5ta a na-ekwe nkwa inwe ihe nd\u1ecb p\u1ee5r\u1ee5 iche. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: move_one\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"N'ime nsogbu a, \u1ecb ga-emejuputa \u1ecdr\u1ee5 nke na-ewe ndep\u1ee5ta ab\u1ee5\u1ecd nke n\u1ecdmba, ma ch\u1ecdp\u1ee5ta ma \u1ecd ga-ekwe omume iji gbanwee ihe d\u1ecb n'etiti ha iji mee ka lst1 b\u1ee5r\u1ee5 ndep\u1ee5ta nke naan\u1ecb n\u1ecdmba ab\u1ee5\u1ecd. Enwegh\u1ecb oke na \u1ecdn\u1ee5\u1ecdg\u1ee5 nke ihe gbanwere n'etiti lst1 na lst2. \u1ecc b\u1ee5r\u1ee5 na \u1ecd ga-ekwe omume \u1ecbgbanwe ihe d\u1ecb n'etiti lst1 na lst2 iji mee ka ihe niile d\u1ecb na lst1 b\u1ee5r\u1ee5 \u1ecdb\u1ee5na, laghachi \"EE\". Ma \u1ecd b\u1ee5gh\u1ecb, laghachi \"EE\". D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: mgbanwe [1, 2, 3, 4], [1, 2, 3, 4]) => \"EE\" mgbanwe [1, 2, 3, 4], [1, 5, 3, 4]) => \"EE\" A na-eche na ndep\u1ee5ta ntinye agagh\u1ecb ab\u1ee5 efu.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"N'enye eriri na-an\u1ecdchite anya mkp\u1ee5r\u1ee5edemede pere mpe nkewap\u1ee5r\u1ee5, laghachi akw\u1ee5kw\u1ecd \u1ecdk\u1ecdwa okwu nke mkp\u1ee5r\u1ee5edemede nwere \u1ecdt\u1ee5t\u1ee5 ugboro ugboro ma nwee \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kwek\u1ecdr\u1ecd. \u1ecc b\u1ee5r\u1ee5 na mkp\u1ee5r\u1ee5edemede nwere otu ihe ah\u1ee5, laghachi ha niile. Ihe Nlereanya: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4}: histogram'(((') == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"\u1eccr\u1ee5 E nyere any\u1ecb eriri ab\u1ee5\u1ecd s na c, \u1ecb ga-ehichap\u1ee5 mkp\u1ee5r\u1ee5edemede niile na s nke h\u00e0 nhata na mkp\u1ee5r\u1ee5edemede \u1ecd b\u1ee5la na c wee lelee ma eriri nsonaaz\u1ee5 ah\u1ee5 b\u1ee5 palindrome. A na-akp\u1ecd eriri palindrome ma \u1ecd b\u1ee5r\u1ee5 na \u1ecd na-ag\u1ee5 otu az\u1ee5 az\u1ee5 d\u1ecb ka n'ihu. \u1eca ga-eweghachi otu tuple nwere eriri nsonaaz\u1ee5 na Eziokwu \/ \u1ee4gha maka nlele. Ihe Nlereanya Maka s = \"abcde\", c = \"ae\", nsonaaz\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 ('bcd', \u1ee4gha) Maka s = \"abcdef\", c = \"b\" nsonaaz\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 ('acdef', \u1ee4gha) Maka s = \"abcdedcba\", c = \"ab\", nsonaaz\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 ('cdedc', Eziokwu)\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"N'enye ndep\u1ee5ta nke eriri, ebe eriri \u1ecd b\u1ee5la nwere naan\u1ecb mkp\u1ee5r\u1ee5edemede, laghachi ndep\u1ee5ta. Ihe \u1ecd b\u1ee5la i nke mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"\u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke ihe nd\u1ecb d\u1ecb iche na eriri i nke ntinye. \" ebe a ga-eji n\u1ecdmba nke \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd na n\u1ecdmba nke ntinye.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    N'inye usoro nke integers n, ch\u1ecdta obere nchikota nke \u1ecd b\u1ee5la na-ab\u1ee5gh\u1ecb oghere sub-usoro nke n. Ihe Nlereanya minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    A na-enye g\u1ecb grid nke olulu mmiri. Ah\u1ecbr\u1ecb \u1ecd b\u1ee5la na-an\u1ecdchite anya otu olulu mmiri, na nke \u1ecd b\u1ee5la n'ime ah\u1ecbr\u1ecb na-an\u1ecdchite anya otu mmiri. Olulu mmiri \u1ecd b\u1ee5la nwere b\u1ecdket kwek\u1ecdr\u1ecd na ya nke enwere ike iji wep\u1ee5 mmiri na ya, na b\u1ecdket niile nwere otu ikike. \u1eccr\u1ee5 g\u1ecb b\u1ee5 iji b\u1ecdket ah\u1ee5 kpochap\u1ee5 olulu mmiri. Nweta \u1ecdn\u1ee5\u1ecdg\u1ee5 oge \u1ecb ch\u1ecdr\u1ecd iji belata b\u1ecdket.\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    N'ime Kata a, \u1ecb ga-edozi usoro nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 na-ab\u1ee5gh\u1ecb nke na-ad\u1ecbgh\u1ecb mma d\u1ecbka \u1ecdn\u1ee5\u1ecdg\u1ee5 nke nd\u1ecb d\u1ecb na \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd ha na-ar\u1ecb elu. Maka \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 yiri nke nd\u1ecb ah\u1ee5, na-edozi dabere na uru decimal. A ghagh\u1ecb ime ya d\u1ecb ka nke a:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"N'inye eriri s na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 n, a gwara g\u1ecb ka \u1ecb r\u1ee5\u1ecd \u1ecdr\u1ee5 nke na-al\u1ecdghachi ndep\u1ee5ta nke okwu niile site na eriri s nke nwere kp\u1ecdmkwem n consonants, ka okwu nd\u1ecb a wee p\u1ee5ta na eriri s. \u1ecc b\u1ee5r\u1ee5 na eriri s b\u1ee5 ihe efu mgbe ah\u1ee5 \u1ecdr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi ndep\u1ee5ta efu. R\u1ecbba ama: \u1ecb nwere ike iche na eriri ntinye nwere naan\u1ecb mkp\u1ee5r\u1ee5edemede na oghere. Ihe at\u1ee5: h\u1ecdr\u1ecd_okwu (s) \"\"Mary nwere obere nwa at\u1ee5r\u1ee5\", 4) ==> [\" obere\"] h\u1ecdr\u1ecd_okwu (s) \"\"Mary nwere obere nwa at\u1ee5r\u1ee5\", 3) ==> [\"Mary\", \"nwa at\u1ee5r\u1ee5\"] h\u1ecdr\u1ecd_okwu (s) \"\"ebe \u1ecdcha d\u1ecb mfe\", 2) ==> [] h\u1ecdr\u1ecd_okwu (s) \"\"Ndewo \u1ee5wa\", 4) ==> [\" \u1ee5wa\"] h\u1ecdr\u1ecd_okwu (s) \"\" Uncle sam \", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"A na-enye g\u1ecb okwu. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdta \u1ee5daume kacha nso nke d\u1ecb n'etiti \u1ee5daume ab\u1ee5\u1ecd site n'ak\u1ee5k\u1ee5 aka nri nke okwu ah\u1ee5 (okwu na-emet\u1ee5ta okwu). Olu na mmalite na njedebe anagh\u1ecb ag\u1ee5ta. Laghachi eriri efu ma \u1ecd b\u1ee5r\u1ee5 na \u1ecbch\u1ecdtagh\u1ecb \u1ee5daume \u1ecd b\u1ee5la zutere \u1ecdn\u1ecdd\u1ee5 d\u1ecb n'elu. \u1eca nwere ike iche na eriri ah\u1ee5 nyere nwere mkp\u1ee5r\u1ee5edemede Bekee naan\u1ecb. Ihe Nlereanya: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    N'enye usoro nke integers na k, weghachite ndep\u1ee5ta nke ogologo k na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb k na arr. Ihe Nlereanya1: Ntinye: arr = [-3, -4, 5], k = 3 Ntinye: [-4, -3, 5] Ihe Nlereanya2: Ntinye: arr = [4, -4, 4], k = 2 Ntinye: [4, 4] Ihe Nlereanya3: Ntinye: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Ntinye: [2] R\u1ecbba ama: 1. Ogologo nke usoro ah\u1ee5 ga-ad\u1ecb na [1, 1000]. 2. Ihe nd\u1ecb d\u1ecb na usoro ah\u1ee5 ga-ad\u1ecb na [-1000, 1000]. 3. 0 <= k <= len ((arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"N'enye ndep\u1ee5ta nke integer nd\u1ecb na-ab\u1ee5gh\u1ecb efu, weghachite nch\u1ecbk\u1ecdta nke ihe niile d\u1ecb iche iche d\u1ecb na \u1ecdn\u1ecdd\u1ee5 \u1ecdb\u1ee5na. Ihe Nlereanya ngw\u1ecdta (([5, 8, 7, 1]) ==> 12 ngw\u1ecdta (([3, 3, 3, 3, 3]) ==> 9 ngw\u1ecdta (([30, 13, 24, 321]) ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Nyere a na-ab\u1ee5gh\u1ecb oghere n'usoro nke integers arr na a integer k, laghachi nchikota nke ihe na kas\u1ecb ab\u1ee5\u1ecd digits si mb\u1ee5 k \u1ecdcha nke arr. Ihe Nlereanya: Ntinye: arr = [111,21,3,4000,5,6,7,8,9], k = 4 mmep\u1ee5ta: 24 # nchikota nke 21 + 3 constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    N'enye \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 d\u1ecb mma n, weghachite ndep\u1ee5ta nke nwere \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 na-enwegh\u1ecb at\u1ee5 na usoro collatz. Nk\u1ecdwa Collatz b\u1ee5 \u1ecbk\u1ecd nk\u1ecd na mgbak\u1ecd na mwep\u1ee5 nke met\u1ee5tara usoro ak\u1ecdwap\u1ee5tara d\u1ecb ka nd\u1ecb a: bido na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 \u1ecd b\u1ee5la d\u1ecb mma n. Mgbe ah\u1ee5, a na-enweta okwu \u1ecd b\u1ee5la site na usoro gara aga d\u1ecb ka nd\u1ecb a: \u1ecd b\u1ee5r\u1ee5 na okwu gara aga b\u1ee5 \u1ecdb\u1ee5na, okwu na-esote b\u1ee5 \u1ecdkara nke okwu gara aga. \u1ecc b\u1ee5r\u1ee5 na okwu gara aga b\u1ee5 ihe na-ad\u1ecbgh\u1ecb mma, okwu na-esote b\u1ee5 3 ugboro nke okwu gara aga gbakwunyere 1. Nk\u1ecdwa b\u1ee5 na n'agbanyegh\u1ecb uru n, usoro ah\u1ee5 ga-eru 1. R\u1ecbba ama: 1. Collatz(1) b\u1ee5 [1]. 2. ndep\u1ee5ta a na-edozi na-ar\u1ecbwanye elu. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: get_odd_collatz(5) na-\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"\u1eca ga-ede \u1ecdr\u1ee5 nke na-enyocha \u1ee5b\u1ecdch\u1ecb e nyere ma weghachite Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na \u1ee5b\u1ecdch\u1ecb ah\u1ee5 d\u1ecb ir\u00e8 ma \u1ecd b\u1ee5gh\u1ecb \u1ee4gha. \u1ee4b\u1ecdch\u1ecb ah\u1ee5 d\u1ecb ir\u00e8 ma \u1ecd b\u1ee5r\u1ee5 na iwu niile nd\u1ecb a na-eju af\u1ecd: 1. \u1ee4b\u1ecdch\u1ecb \u1ee5b\u1ecdch\u1ecb ad\u1ecbgh\u1ecb efu. 2. \u1eccn\u1ee5 \u1ecdg\u1ee5g\u1ee5 \u1ee5b\u1ecdch\u1ecb ad\u1ecbgh\u1ecb ihe na-erugh\u1ecb 1 ma \u1ecd b\u1ee5 kar\u1ecba \u1ee5b\u1ecdch\u1ecb 31 maka \u1ecdnwa 1,3,5,7,8,10,12. Na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 \u1ee5b\u1ecdch\u1ecb ad\u1ecbgh\u1ecb ihe na-erugh\u1ecb 1 ma \u1ecd b\u1ee5 kar\u1ecba \u1ee5b\u1ecdch\u1ecb 30 maka \u1ecdnwa 4,6,9,11. Na, \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 \u1ee5b\u1ecdch\u1ecb ad\u1ecbgh\u1ecb ihe na-erugh\u1ecb 1 ma \u1ecd b\u1ee5 kar\u1ecba 29 maka \u1ecdnwa 2. 3. \u1eccnwa ekwes\u1ecbgh\u1ecb \u1ecbd\u1ecb obere kar\u1ecba 1 ma \u1ecd b\u1ee5 kar\u1ecba 12. 4. \u1ee4b\u1ecdch\u1ecb kwes\u1ecbr\u1ecb \u1ecbd\u1ecb na usoro: mm-dd-yyyy d\u1ecbka \u1ecdm\u1ee5maat\u1ee5: valid_date (('03-11-2000') => Eziokwu_\u1ee5b\u1ecdch\u1ecb (_ valid_date) => \u1ee4gha_\u1ee5b\u1ecdch\u1ecb (_ valid_date) => \u1ee4gha_\u1ee5b\u1ecdch\u1ecb (_ valid\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"A na-enye g\u1ecb oge ab\u1ee5\u1ecd, ebe oge \u1ecd b\u1ee5la b\u1ee5 \u1ee5z\u1ecd nke integers. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5, oge = (mmalite, njedebe) = (1, 2). Oge nd\u1ecb ah\u1ee5 enyere emechi nke p\u1ee5tara na oge (mmalite, njedebe) g\u1ee5nyere ma mmalite na njedebe. Maka oge \u1ecd b\u1ee5la, a na-eche na mmalite ya d\u1ecb obere ma \u1ecd b\u1ee5 h\u00e0 njedebe ya. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdp\u1ee5ta ma ogologo nke nkw\u1ee5s\u1ecb nke oge ab\u1ee5\u1ecd a b\u1ee5 n\u1ecdmba isi. Ihe at\u1ee5, nkw\u1ee5s\u1ecb nke oge (1, 3), (2, 4) b\u1ee5 (2, 3) nke ogologo ya b\u1ee5 1, nke na-ab\u1ee5gh\u1ecb n\u1ecdmba isi. \u1ecc b\u1ee5r\u1ee5 na ogologo nke nkw\u1ee5s\u1ecb b\u1ee5 n\u1ecdmba isi, laghachi \"EE\", ma \u1ecd b\u1ee5gh\u1ecb, laghachi \"EE\". \u1ecc b\u1ee5r\u1ee5 na oge ab\u1ee5\u1ecd ah\u1ee5 ad\u1ecbgh\u1ecb agba, laghachi \"EE\". [nbanye \/ mmep\u1ee5ta] ihe at\u1ee5: intersection (((1, 2), (2, 3) ==> \"intersection\", \"NO\", \"intersection-1,\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    A na-enye g\u1ecb usoro nke integers na \u1ecb ga-alaghachi nch\u1ecbk\u1ecdta nke \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke integers m\u1ee5bara site na ngwaah\u1ecba nke ihe \u1ecbr\u1ecbba ama niile nke n\u1ecdmba \u1ecd b\u1ee5la na usoro ah\u1ee5, nke 1, -1 ma \u1ecd b\u1ee5 0 na-an\u1ecdchite anya ya. R\u1ecbba ama: laghachi \u1ecc d\u1ecbgh\u1ecb ihe \u1ecd b\u1ee5la maka oghere efu.\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    \u1eca nwere ike \u1ecbmalite site na sel \u1ecd b\u1ee5la, na na \u1ecd b\u1ee5la nz\u1ecd\u1ee5kw\u1ee5 \u1ecb nwere ike \u1ecbkwaga na nke \u1ecd b\u1ee5la nke nd\u1ecb agbata obi mkp\u1ee5r\u1ee5 nd\u1ee5, na nd\u1ecb \u1ecdz\u1ecd okwu, \u1ecb nwere ike \u1ecbga na mkp\u1ee5r\u1ee5 nd\u1ee5 na-ekere \u00f2k\u00e8 a onu na g\u1ecb ugbu a cell. Biko mara na a \u1ee5z\u1ecd nke ogologo k p\u1ee5tara \u1ecbga kp\u1ecdmkwem k mkp\u1ee5r\u1ee5 nd\u1ee5 (b\u1ee5gh\u1ecb n'\u1ee5z\u1ecd doro anya d\u1ecb iche iche). \u1eca P\u1ee4GH\u1eca aga na grid. A \u1ee5z\u1ecd A (nke ogologo k) na-at\u1ee5le obere kar\u1ecba a \u1ee5z\u1ecd B (nke ogologo k) ma \u1ecd b\u1ee5r\u1ee5 na mgbe na-eme ka nd\u1ecb na-usoro anatara nke \u1ee5kp\u1ee5r\u1ee5 na mkp\u1ee5r\u1ee5 nd\u1ee5 na-aga site A na B (ka any\u1ecb na-akp\u1ecd ha l_st na l_stA), l_stA lexically b\u1ee5 obere kar\u1ecba l_stB, na nd\u1ecb \u1ecdz\u1ecd okwu, a integer index i. [A = 1, j_stA, j_stA, j_st\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Onye \u1ecd b\u1ee5la maara usoro Fibonacci, nd\u1ecb \u1ecdk\u00e0 mm\u1ee5ta mgbak\u1ecd na mwep\u1ee5 na-am\u1ee5 ya nke \u1ecdma na nar\u1ecb af\u1ecd ab\u1ee5\u1ecd gara aga. Ot\u00fa \u1ecd d\u1ecb, ihe nd\u1ecb mmad\u1ee5 na-amagh\u1ecb b\u1ee5 usoro Tribonacci. A na-ak\u1ecdwa usoro Tribonacci site na nl\u1ecdghachi: tri(1) = 3 tri(n) = 1 + n \/ 2, ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 \u1ecdb\u1ee5na. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 ihe d\u1ecb iche. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 A na-enye g\u1ecb n\u1ecdmba integer na-ab\u1ee5gh\u1ecb nke na-ad\u1ecbgh\u1ecb mma, \u1ecb ga-alaghachi ndep\u1ee5ta nke n\u1ecdmba mb\u1ee5 n + 1 nke usoro Tribonacci. Ihe at\u1ee5: tri(\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"N'enye \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 d\u1ecb mma n, weghachite ngwaah\u1ecba nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nd\u1ecb \u1ecdz\u1ecd. Laghachi 0 ma \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 niile b\u1ee5 \u1ecdb\u1ee5na. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: digits(1) == 1 digits(4) == 0 digits(235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"A na-enye g\u1ecb ndep\u1ee5ta nke n\u1ecdmba. \u1ecakwes\u1ecbr\u1ecb \u1ecblaghachi nch\u1ecbk\u1ecdta nke n\u1ecdmba squared na ndep\u1ee5ta enyere, gbasaa ihe \u1ecd b\u1ee5la na ndep\u1ee5ta ah\u1ee5 na elu int ((mkpuchi) mb\u1ee5. Ihe Nlereanya: Maka lst = [1,2,3] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 14 Maka lst = [1,4,9] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 98 Maka lst = [1,3,5,7] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 84 Maka lst = [1.4,4.2,0] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 29 Maka lst = [-2.4,1,1] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Mep\u1ee5ta \u1ecdr\u1ee5 nke na-alaghachi na ntinye kachas\u1ecb nke ihe na-ab\u1ee5gh\u1ecb nke d\u1ecb ukwuu ma \u1ecd b\u1ee5 h\u00e0 nhata na ihe d\u1ecb na ya. \u1ecc b\u1ee5r\u1ee5 na enwegh\u1ecb ihe d\u1ecb ot\u00fa ah\u1ee5, laghachi -1. Nhazi a nyere agagh\u1ecb enwe \u1ee5kp\u1ee5r\u1ee5 ab\u1ee5\u1ecd. Ihe at\u1ee5: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Mep\u1ee5ta \u1ecdr\u1ee5 nke na-ewe integers, floats, ma \u1ecd b\u1ee5 eriri na-an\u1ecdchite anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 d\u1ecb ad\u1ecb, ma weghachite mgbanwe d\u1ecb ukwuu na \u1ee5d\u1ecb mgbanwe ya. Laghachi None ma \u1ecd b\u1ee5r\u1ee5 na \u1ee5kp\u1ee5r\u1ee5 nd\u1ecb ah\u1ee5 h\u00e0 nhata. R\u1ecbba ama: \u1ecc b\u1ee5r\u1ee5 na a na-an\u1ecdchite anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 d\u1ecb ad\u1ecb d\u1ecb ka eriri, isi ihe na-ese n'elu mmiri nwere ike \u1ecbb\u1ee5. ma \u1ecd b\u1ee5, compare_one{1, 2.5) \u00e2 -> 2.5 compare_one{1, \"2,3\") \u00e2 -> \"2,3\" compare_one{5,1\", \"6\") \u00e2 -> \"6\" compare_one{1\", 1) \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Nyochaa ma \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 enyere n nwere ike ide d\u1ecb ka nchikota nke n\u1ecdmba 4 ziri ezi d\u1ecb mma Ihe Nlereanya is_equal_to_sum_even ((4) == \u1ee4gha is_equal_to_sum_even ((6) == \u1ee4gha is_equal_to_sum_even ((8) == Eziokwu\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"A na-ak\u1ecdwap\u1ee5ta ihe nd\u1ecb Brazil d\u1ecb ka: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! ebe n > 0 D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    N'inye ederede ederede, dochie oghere niile d\u1ecb na ya na akara ala, ma \u1ecd b\u1ee5r\u1ee5 na eriri nwere ihe kar\u1ecbr\u1ecb 2 oghere nd\u1ecb na-esote, wee dochie oghere niile na-esote - fix_spaces (((\"Ihe Nlereanya\") == \"Ihe Nlereanya\" fix_spaces (((\"Ihe Nlereanya1\") == \"Ihe Nlereanya1\" fix_spaces (((\"Ihe Nlereanya2\") == \"_Ihe Nlereanya_2\" fix_spaces (((\"Ihe Nlereanya 3\") == \"_Ihe Nlereanya-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Mep\u1ee5ta \u1ecdr\u1ee5 nke na-ewe eriri na-an\u1ecdchite anya aha fa\u1ecbl\u1ee5, ma laghachi 'Ee' ma \u1ecd b\u1ee5r\u1ee5 na aha fa\u1ecbl\u1ee5 ah\u1ee5 d\u1ecb ir\u00e8, ma laghachi 'Mba' ma \u1ecd b\u1ee5gh\u1ecb. A na-ewere aha fa\u1ecbl\u1ee5 d\u1ecb ka ihe ziri ezi ma \u1ecd b\u1ee5r\u1ee5 na \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ecdd\u1ee5 niile nd\u1ecb a na-ezute: - E kwes\u1ecbgh\u1ecb inwe ihe kar\u1ecbr\u1ecb mkp\u1ee5r\u1ee5edemede at\u1ecd ('0'-'9') na aha fa\u1ecbl\u1ee5 ah\u1ee5. - Aha fa\u1ecbl\u1ee5 ah\u1ee5 nwere kp\u1ecdmkwem otu nt\u1ee5p\u1ecd '.' - Ihe ntinye tupu nt\u1ee5p\u1ecd ah\u1ee5 ekwes\u1ecbgh\u1ecb \u1ecbb\u1ee5 ihe efu, \u1ecd ga-amalite na akw\u1ee5kw\u1ecd ozi sitere na mkp\u1ee5r\u1ee5edemede Latin ('a'-'z' na 'A'Z'). - Ihe ntinye mgbe nt\u1ee5p\u1ecd ah\u1ee5 ga-ab\u1ee5 otu n'ime nd\u1ecb a: ['txt', 'exe', 'll'd'] Ihe Nlereanya: file_name_check\"{example.txt\") # => 'Ee'_name_file_check\"\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" \u1eccr\u1ee5 a ga-ewep\u1ee5ta ndep\u1ee5ta nke integers. Maka ihe niile d\u1ecb na ndep\u1ee5ta ah\u1ee5, \u1ecdr\u1ee5 ah\u1ee5 ga-agbanye square na ntinye integer ma \u1ecd b\u1ee5r\u1ee5 na ndeksi ya b\u1ee5 \u1ecdt\u1ee5t\u1ee5 nke 3 ma ga-etinye ihe ntinye integer ma \u1ecd b\u1ee5r\u1ee5 na ndeksi ya b\u1ee5 \u1ecdt\u1ee5t\u1ee5 nke 4 ma \u1ecd b\u1ee5gh\u1ecb \u1ecdt\u1ee5t\u1ee5 nke 3. \u1eccr\u1ee5 ah\u1ee5 agagh\u1ecb agbanwe ihe nd\u1ecb d\u1ecb na ndep\u1ee5ta ah\u1ee5 nke ndeksi ha ab\u1ee5gh\u1ecb \u1ecdt\u1ee5t\u1ee5 nke 3 ma \u1ecd b\u1ee5 4. \u1eccr\u1ee5 ah\u1ee5 ga-eweghachi ng\u1ee5k\u1ecdta nke ihe niile. Ihe Nlereanya: Maka lst = [1,2,3] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 6 Maka lst = [] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 0 Maka lst = [-1,-5,2,-1,-5] mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    A na-enye g\u1ecb eriri na-an\u1ecdchite anya ah\u1ecbr\u1ecbokwu, ah\u1ecbr\u1ecbokwu ah\u1ee5 nwere \u1ee5f\u1ecdd\u1ee5 okwu nkewap\u1ee5r\u1ee5 site na oghere, ma \u1ecb ga-eweghachi eriri nke nwere okwu sitere na ah\u1ecbr\u1ecbokwu mb\u1ee5, nke ogologo ya b\u1ee5 n\u1ecdmba mb\u1ee5, usoro nke okwu na eriri \u1ecdh\u1ee5r\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 otu ihe ah\u1ee5 d\u1ecb na mb\u1ee5. Ihe Nlereanya1: Ntinye: ah\u1ecbr\u1ecbokwu = \"Nke a b\u1ee5 ule\" Ntinye: \"b\u1ee5\" Ihe Nlereanya2: Ntinye: ah\u1ecbr\u1ecbokwu = \"ka any\u1ecb gaa maka igwu mmiri\" Ntinye: \"gaa maka\" Ihe mgbochi: * 1 <= len(sentence) <= 100 * ah\u1ecbr\u1ecbokwu nwere naan\u1ecb mkp\u1ee5r\u1ee5edemede\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"\u1eccr\u1ee5 g\u1ecb b\u1ee5 imejuputa \u1ecdr\u1ee5 nke ga-eme ka okwu x * n d\u1ecb mfe. \u1eccr\u1ee5 ah\u1ee5 na-alaghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na x * n na-at\u1ee5le \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 zuru ezu na \u1ee4gha ma \u1ecd b\u1ee5gh\u1ecb. Ma x na n, b\u1ee5 akara akara nke nkebi, ma nwee usoro nd\u1ecb a, <numerator> \/ <denominator> ebe \u1ecdn\u1ee5\u1ecdg\u1ee5 na denominator b\u1ee5 n\u1ecdmba zuru ezu d\u1ecb mma. \u1eca nwere ike iche na x, na n b\u1ee5 nkebi ziri ezi, ma enwegh\u1ecb efu d\u1ecb ka denominator. simplify \" 1\/5 \", \"5\/1\") = Eziokwu simplify \" 1\/6 \", \"2\/1\") = \u1ee4gha simplify \" 7\/10 \", \"10\/2\") = \u1ee4gha\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Dee \u1ecdr\u1ee5 nke na-edozi ndep\u1ee5ta nke n\u1ecdmba zuru ezu na-ar\u1ecbgo n'usoro d\u1ecbka nch\u1ecbk\u1ecdta nke mkp\u1ee5r\u1ee5edemede ha. R\u1ecbba ama: \u1ecd b\u1ee5r\u1ee5 na e nwere \u1ecdt\u1ee5t\u1ee5 ihe nwere nch\u1ecbk\u1ecdta nke mkp\u1ee5r\u1ee5edemede ha, hazie ha dabere na ndeksi ha na ndep\u1ee5ta mb\u1ee5. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-ewe usoro nke n\u1ecdmba d\u1ecb ka ntinye ma weghachite \u1ecdn\u1ee5\u1ecdg\u1ee5 nke ihe nd\u1ecb d\u1ecb na usoro ah\u1ee5 nke kar\u1ecbr\u1ecb 10 na n\u1ecdmba ab\u1ee5\u1ecd mb\u1ee5 na nke ikpeaz\u1ee5 nke n\u1ecdmba b\u1ee5 ihe efu (1, 3, 5, 7, 9). D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    A na-enye g\u1ecb n\u1ecdmba d\u1ecb mma n. \u1eca ga-emep\u1ee5ta usoro nke ogologo n. Maka onye \u1ecd b\u1ee5la i (1 \u2030\u00a4 i \u2030\u00a4 n), uru nke a[i] = i * i - i + 1. Laghachi \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke at\u1ecd (a[i], a[j], a[k]) nke a ebe i < j < k, na a[i] + a[j] + a[k] b\u1ee5 \u1ecdt\u1ee5t\u1ee5 nke 3. Ihe Nlereanya: Ntinye: n = 5 Ntinye: 1 Nk\u1ecdwa: a = [1, 3, 7, 13, 21] Nan\u1ecb at\u1ecd d\u1ecb ir\u00e8 b\u1ee5 (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-anabata ndep\u1ee5ta nke eriri d\u1ecb ka ihe nkedo, na-ehichap\u1ee5 eriri nd\u1ecb nwere ogologo d\u1ecb iche iche site na ya, ma weghachite ndep\u1ee5ta ah\u1ee5 na usoro a haziri ahazi, Ndep\u1ee5ta ah\u1ee5 b\u1ee5 mgbe niile ndep\u1ee5ta nke eriri na \u1ecd b\u1ee5gh\u1ecb usoro nke n\u1ecdmba, \u1ecd nwere ike \u1ecbnwe duplicates. Usoro nke ndep\u1ee5ta ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbd\u1ecb na-ar\u1ecb elu site na ogologo nke okwu \u1ecd b\u1ee5la, \u1ecb ga-eweghachite ndep\u1ee5ta ah\u1ee5 nke a haziri site na iwu ah\u1ee5. \u1ecc b\u1ee5r\u1ee5 na okwu ab\u1ee5\u1ecd nwere otu ogologo, dozie ndep\u1ee5ta ah\u1ee5 n'usoro mkp\u1ee5r\u1ee5edemede. \u1eccr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi ndep\u1ee5ta nke eriri na usoro nhazi. \u1eca nwere ike iche na okwu niile ga-enwe otu ogologo. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => [\"ab\",\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Ihe omume d\u1ecb mfe nke kwes\u1ecbr\u1ecb \u1ecblaghachi uru nke x ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 n\u1ecdmba mb\u1ee5 ma kwes\u1ecbr\u1ecb \u1ecblaghachi uru nke y ma \u1ecd b\u1ee5gh\u1ecb. Ihe at\u1ee5: maka x_or_y(7, 34, 12) == 34 maka x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Echere m na any\u1ecb niile na-echeta mmet\u1ee5ta ah\u1ee5 mgbe nsonaaz\u1ee5 nke ihe omume a na-echere ogologo oge mechara mara. Mmet\u1ee5ta na echiche \u1ecb nwere n'oge ah\u1ee5 bara uru \u1ecbdebanye na \u1ecbt\u1ee5nyere. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdp\u1ee5ta ma mmad\u1ee5 \u1ecd kwadoro nsonaaz\u1ee5 nke \u1ecdt\u1ee5t\u1ee5 egwuregwu. A na-enye g\u1ecb usoro ab\u1ee5\u1ecd nke akara na \u1ecbk\u1ecd nk\u1ecd nke nha anya, ebe akara \u1ecd b\u1ee5la na-egosi egwuregwu. Laghachi usoro nke nha anya na-egosi ebe \u1ecd b\u1ee5la \u1ecbk\u1ecd nk\u1ecd d\u1ecb. \u1ecc b\u1ee5r\u1ee5 na ha kwadoro, uru ah\u1ee5 b\u1ee5 0, ma \u1ecd b\u1ee5r\u1ee5 na \u1ecd b\u1ee5gh\u1ecb, uru ah\u1ee5 b\u1ee5 \u1ecdd\u1ecbiche zuru oke n'etiti \u1ecbk\u1ecd nk\u1ecd na akara. ihe at\u1ee5: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4],[0,4,1,0,-2]) -> [4,4,0,1,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"A ga-enye g\u1ecb aha klas (ihe nd\u1ecdt\u1ecb) na ndep\u1ee5ta nke nd\u1ecdt\u1ecb. A ga-eji nd\u1ecdt\u1ecb nd\u1ecb ah\u1ee5 bulite klas nd\u1ecb \u1ecdz\u1ecd na klas ah\u1ee5. Ike nke nd\u1ecdt\u1ecb b\u1ee5 d\u1ecb ka nd\u1ecb a: Ka CAP b\u1ee5r\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke mkp\u1ee5r\u1ee5edemede ukwu na aha nd\u1ecdt\u1ecb ah\u1ee5, ma ka SM b\u1ee5r\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke mkp\u1ee5r\u1ee5edemede obere na aha nd\u1ecdt\u1ecb ah\u1ee5, ike ah\u1ee5 nyere site na nkewa CAP - SM. \u1eca ga-ah\u1ee5 nd\u1ecdt\u1ecb kachas\u1ecb ike ma weghachite eriri na usoro a: ClassName.StrongestExtensionName. \u1ecc b\u1ee5r\u1ee5 na enwere nd\u1ecdt\u1ecb ab\u1ee5\u1ecd ma \u1ecd b\u1ee5 kar\u1ecba nwere otu ike, \u1ecb ga-ah\u1ecdr\u1ecd nke mb\u1ee5 na ndep\u1ee5ta ah\u1ee5. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5, \u1ecd b\u1ee5r\u1ee5 na e nyere g\u1ecb \"Slices\" d\u1ecbka klas na ndep\u1ee5ta nke nd\u1ecdt\u1ecb: ['SEviviviSNGliCes', 'Cheese', 'StuFfed']\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"A na-enye g\u1ecb okwu ab\u1ee5\u1ecd. \u1ecakwes\u1ecbr\u1ecb \u1ecblaghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na okwu nke ab\u1ee5\u1ecd ma \u1ecd b\u1ee5 nke \u1ecd b\u1ee5la n'ime nt\u1ee5ghar\u1ecb ya b\u1ee5 substring na okwu mb\u1ee5 cycpattern_check(\"abcd\",\"abd\") => False cycpattern_check(\"hello\",\"ell\") => Eziokwu cycpattern_check(\"whassup\",\"psus\") => False cycpattern_check\"abab\",\"baa\") => Eziokwu cycpattern_check(\"efef\",\"eeff\") => False cycpattern_check\"(hims\",\"simen\") => Eziokwu\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Nyere n\u1ecdmba zuru ezu. weghachite otu tuple nke nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke \u1ecdb\u1ee5na na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5. Ihe Nlereanya: \u1ecdb\u1ee5na_odd_count(-12) ==> (1, 1) \u1ecdb\u1ee5na_odd_count(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    N'enye n\u1ecdmba d\u1ecb mma, nweta \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 ya nke Roman d\u1ecb ka eriri, ma weghachite ya na obere. Ihe mgbochi: 1 <= num <= 1000 Ihe at\u1ee5:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-anabata ndep\u1ee5ta nke eriri. Ndep\u1ee5ta ah\u1ee5 nwere okwu d\u1ecb iche iche. Laghachi okwu ah\u1ee5 na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nke mkp\u1ee5r\u1ee5edemede p\u1ee5r\u1ee5 iche. \u1ecc b\u1ee5r\u1ee5 na \u1ecdt\u1ee5t\u1ee5 eriri nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nke mkp\u1ee5r\u1ee5edemede p\u1ee5r\u1ee5 iche, laghachi nke na-ab\u1ecba na mb\u1ee5 na usoro lexicographical. ch\u1ecdta_max (([\"aha\", \"nke\", \"eriri\"]) == \"eriri\" ch\u1ecdta_max (([\"aha\", \"enam\", \"egwuregwu\"]) == \"enam\" ch\u1ecdta_max (([\"aaaaaaa\", \"bb\", \"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    \u1eca b\u1ee5 oke bekee ag\u1ee5\u1ee5 na-ag\u1ee5, ma \u1ecb riwor\u1ecb \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 \u1ee5f\u1ecdd\u1ee5 nke carrots, ma ugbu a, \u1ecb ch\u1ecdr\u1ecd iri \u1ecdt\u1ee5t\u1ee5 carrots iji mezue nri \u1ee5b\u1ecdch\u1ecb. \u1ecb kwes\u1ecbr\u1ecb \u1ecblaghachi usoro nke [\u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke carrots riri mgbe nri g\u1ecb gas\u1ecbr\u1ecb, \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke carrots f\u1ecdd\u1ee5r\u1ee5 mgbe nri g\u1ecb gas\u1ecbr\u1ecb ] ma \u1ecd b\u1ee5r\u1ee5 na enweghi carrots f\u1ecdd\u1ee5r\u1ee5, \u1ecb ga-eri carrots f\u1ecdd\u1ee5r\u1ee5, ma \u1ecb ka ga-enwe ag\u1ee5\u1ee5. Ihe Nlereanya: * rie ((5, 6, 10) -> [11, 4] * rie ((4, 8, 9) -> [12, 1] * rie ((1, 10, 10) -> [11, 0] * rie ((2, 11, 5) -> [7, 0] Mgbanwe: @ n\u1ecdmba: \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 zuru ezu nke carrots \u1ecb riri. @ mkpa: \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 zuru ezu nke carrots \u1ecb ch\u1ecdr\u1ecd iri. @ f\u1ecdd\u1ee5r\u1ee5n\u1ee5: \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 zuru ezu nke carrots f\u1ecdd\u1ee5r\u1ee5 na ngwaah\u1ecba Constrain\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    N'enye ndep\u1ee5ta ab\u1ee5\u1ecd, onye \u1ecdr\u1ee5, na onye \u1ecdr\u1ee5. Ndep\u1ee5ta nke mb\u1ee5 nwere \u1ecdr\u1ee5 algebra, na ndep\u1ee5ta nke ab\u1ee5\u1ecd b\u1ee5 ndep\u1ee5ta nke integers. Jiri ndep\u1ee5ta ab\u1ee5\u1ecd enyere iji wuo okwu algebra ma weghachite nyocha nke okwu a. \u1eccr\u1ee5 algebra isi: Mgbakwunye ( +) Mwepu ( - ) Nk\u1ecdwap\u1ee5ta ( *) Nkewa ala ( \/\/) Nk\u1ecdwap\u1ee5ta ( ** Ihe at\u1ee5): onye \u1ecdr\u1ee5['+', '*', '-'] array = [2, 3, 4, 5] nsonaaz\u1ee5 = 2 + 3 * 4 - 5 => nsonaaz\u1ee5 = 9 R\u1ecbba ama: Ogologo ndep\u1ee5ta nke onye \u1ecdr\u1ee5 b\u1ee5 otu ogologo nke ndep\u1ee5ta nke onye \u1ecdr\u1ee5 na-ewepu otu. Onye \u1ecdr\u1ee5 b\u1ee5 ndep\u1ee5ta nke nd\u1ecb na-ab\u1ee5gh\u1ecb nd\u1ecb na-ad\u1ecbgh\u1ecb mma. Onye \u1ecdr\u1ee5 nwere \u1ecd d\u1ecbkar\u1ecba ala otu onye \u1ecdr\u1ee5, na ndep\u1ee5ta nke onye \u1ecdr\u1ee5 nwere \u1ecd d\u1ecbkar\u1ecba ala ab\u1ee5\u1ecd.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"A na-enye g\u1ecb eriri s. \u1ecd b\u1ee5r\u1ee5 na s[i] b\u1ee5 mkp\u1ee5r\u1ee5edemede, gbanwee ya site na ala ruo n'elu ma \u1ecd b\u1ee5 vice versa, ma \u1ecd b\u1ee5gh\u1ecb ya, debe ya d\u1ecb ka \u1ecd d\u1ecb. \u1ecc b\u1ee5r\u1ee5 na eriri ah\u1ee5 enwegh\u1ecb mkp\u1ee5r\u1ee5edemede, gbanwee eriri ah\u1ee5. \u1eccr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi eriri nsonaaz\u1ee5. Ihe Nlereanya dozie\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    N'inye eriri 'ederede', laghachi ya md5 hash yiri eriri. \u1ecc b\u1ee5r\u1ee5 na 'ederede' b\u1ee5 eriri efu, laghachi None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    N'inye \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd d\u1ecb mma a na b, laghachi \u1ecdb\u1ee5na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 n'etiti a na b, na-ar\u1ecb elu. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5: mep\u1ee5ta_integers ((2, 8) => [2, 4, 6, 8] mep\u1ee5ta_integers ((8, 2) => [2, 4, 6, 8] mep\u1ee5ta_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]