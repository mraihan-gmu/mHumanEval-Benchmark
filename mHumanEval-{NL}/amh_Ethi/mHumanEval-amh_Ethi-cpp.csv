task_id,nl,pl,prompt,canonical_solutions,test
HumanEval/0,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በተሰጠው የቁጥሮች ቬክተር ውስጥ ከተሰጠው ገደብ ይልቅ እርስ በእርስ የሚቀራረቡ ሁለት ቁጥሮች መኖራቸውን ያረጋግጡ. >>> has_close_elements (ተጠጋጋ) ፣ (ተጠጋጋ) ፣ (ተጠጋጋ) ፣ (ተጠጋጋ) ፣ (ተጠጋጋ) ፣ (ተጠጋጋ) ፣ (ተጠጋጋ) ፣ (ተጠጋጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ) ፣ (ተጠጋ)) ፣ (ትክለ) ፣ (ትክለ) ፣ (ትክለ) ፣ (ትክለ))
bool has_close_elements(std::vector<float> numbers, float threshold) {
","bool has_close_elements(std::vector<float> numbers, float threshold) {
    std::sort(numbers.begin(), numbers.end());  // Sort the numbers in ascending order
    for (size_t i = 1; i < numbers.size(); i++) {
        if (std::abs(numbers[i] - numbers[i - 1]) < threshold) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = has_close_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
}
"
HumanEval/1,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የዚህ ተግባር ግብዓት የተጣበቁ ቅንፎች በርካታ ቡድኖች የያዘ አንድ ሕብረቁምፊ ነው. የእርስዎ ግብ እነዚህ ቡድን በተናጠል ሕብረቁምፊዎች ወደ ለመለየት እና እነዚያ ቬክተር መመለስ ነው. የተለዩ ቡድኖች ሚዛናዊ ናቸው (እያንዳንዱ ክፍት ቅንፍ በአግባቡ ዝግ ነው) እና እርስ በርስ ውስጥ የተጣበቁ አይደለም የግብዓት ሕብረቁምፊ ውስጥ ማንኛውም ክፍተቶች ችላ. >>> separate_paren_groups (((""( ) (() (()))))))) (std::vector<std::string>({(std::string) "")"", ((((())"", (std::string) ""((())))))
std::vector<std::string> separate_paren_groups(std::string paren_string) {
","std::vector<std::string> separate_paren_groups(std::string paren_string) {
    std::vector<std::string> groups;
    std::string current_group;
    int balance = 0;

    for (char ch : paren_string) {
        if (ch == ' ') continue;  // Ignore spaces

        current_group += ch;
        if (ch == '(') {
            balance++;
        } else if (ch == ')') {
            balance--;
            if (balance == 0) {  // Found a balanced group
                groups.push_back(current_group);
                current_group.clear();
            }
        }
    }

    return groups;
}","}
int main() {
    auto candidate = separate_paren_groups;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<std::string>({(std::string)""(()())"", (std::string)""((()))"", (std::string)""()"", (std::string)""((())()())""})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""((()))"", (std::string)""(((())))""})));
    assert(candidate((""(()(())((())))"")) == (std::vector<std::string>({(std::string)""(()(())((())))""})));
    assert(candidate((""( ) (( )) (( )( ))"")) == (std::vector<std::string>({(std::string)""()"", (std::string)""(())"", (std::string)""(()())""})));
}
"
HumanEval/2,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አዎንታዊ የሆነ ተለዋዋጭ ነጥብ ቁጥር ከተሰጠ በኋላ ወደ ሙሉ ቁጥር ክፍል (ከቀረበው ቁጥር ያነሰ ትልቁ ሙሉ ቁጥር) እና አሥርዮሽ (ከቀሪው ክፍል ሁልጊዜ ከ 1 ያነሰ) ሊበታተን ይችላል ። የቁጥር አሥርዮሽ ክፍል ይመልሱ >>> truncate_number((3.5f)) (0.5f)
float truncate_number(float number) {
","float truncate_number(float number) {
    return number - std::floor(number);
}","}
int main() {
    auto candidate = truncate_number;
    assert(candidate((3.5f)) == (0.5f));
    assert(candidate((1.25f)) == (0.25f));
    assert(candidate((123.0f)) == (0.0f));
}
"
HumanEval/3,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በባንክ ሂሳብ ላይ ተቀማጭ እና የመውጣት ስራዎች በዜሮ ሚዛን የሚጀምሩበት ቬክተር ተሰጥቶዎታል ። የእርስዎ ተግባር በማንኛውም ጊዜ የሂሳብ ሚዛን ከዜሮ በታች ቢወድቅ ማወቅ ነው ፣ እና በዚያ ጊዜ ተግባር እውነት መሆን አለበት ። አለበለዚያ ሐሰት መመለስ አለበት ። >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) 3}))) (false) >>> below_zero((std::vector<long>({long) 1, (long) 2, (long) -4, (long) 5}))) (እውነት)
bool below_zero(std::vector<long> operations) {
","bool below_zero(std::vector<long> operations) {
    long balance = 0;
    for (long op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = below_zero;
    assert(candidate((std::vector<long>())) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-3, (long)1, (long)2, (long)-3}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)-4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)2, (long)-2, (long)5, (long)-5, (long)4, (long)-4}))) == (true));
}
"
HumanEval/4,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ለተሰጠ የግብዓት ቁጥሮች ቬክተር ፣ በዚህ የውሂብ ስብስብ አማካይ ዙሪያ አማካይ ፍጹም መዛባት ያስሉ ። አማካይ ፍጹም መዛባት በእያንዳንዱ ንጥረ ነገር እና በማዕከላዊ ነጥብ መካከል ያለው አማካይ ፍጹም ልዩነት ነው (በዚህ ሁኔታ አማካይ): MAD = አማካይ ፳ - x_mean ፳ >>> mean_absolute_deviation (((std::vector<float>({(float) 1.0f, (float) 2.0f, (float) 3.0f, (float) 4.0f}))) (1.0f)
float mean_absolute_deviation(std::vector<float> numbers) {
","float mean_absolute_deviation(std::vector<float> numbers) {
    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();
    float mad = std::accumulate(numbers.begin(), numbers.end(), 0.0f, 
                                [mean](float sum, float x) { return sum + std::abs(x - mean); }) 
                / numbers.size();
    return mad;
}","}
int main() {
    auto candidate = mean_absolute_deviation;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f}))) == (0.5f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
}
"
HumanEval/5,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በእያንዳንዱ ሁለት ተከታታይ የግብዓት ቬክተር አካላት መካከል 'የመጠለያ' ቁጥር ያስገቡ `numbers' >>> intersperse((std::vector<long>() ፣ (4)) (std::vector<long>()) >>> intersperse((std::vector<long>({long) 1, (long) 2, (long) 3}) ፣ (4)) (std::vector<long>({long) 1, (long) 4, (long) 2, (long) 4, (long) 3}))
std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
","std::vector<long> intersperse(std::vector<long> numbers, long delimeter) {
    if (numbers.empty()) return numbers;

    std::vector<long> result;
    for (size_t i = 0; i < numbers.size(); i++) {
        result.push_back(numbers[i]);
        if (i < numbers.size() - 1) {
            result.push_back(delimeter);
        }
    }
    return result;
}","}
int main() {
    auto candidate = intersperse;
    assert(candidate((std::vector<long>()), (7)) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)2})), (8)) == (std::vector<long>({(long)5, (long)8, (long)6, (long)8, (long)3, (long)8, (long)2})));
    assert(candidate((std::vector<long>({(long)2, (long)2, (long)2})), (2)) == (std::vector<long>({(long)2, (long)2, (long)2, (long)2, (long)2})));
}
"
HumanEval/6,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የዚህ ተግባር ግብዓት በቦታዎች የተለዩ የተጣበቁ ቅንፎች በርካታ ቡድኖችን የሚወክል ገመድ ነው ። ለእያንዳንዱ ቡድን የቅንፍ ጥልቀት ጥልቀት ያለው ውጤት ያስወጣል ። ለምሳሌ (())) ከፍተኛው ሁለት ደረጃዎች አሉት ((())) ደግሞ ሶስት አለው ። >>> parse_nested_parens (((((()))) ((())) () (((()))))) (std::vector<long>({(long) 2, (long) 3, (long) 1, (long) 3}))
std::vector<long> parse_nested_parens(std::string paren_string) {
","std::vector<long> parse_nested_parens(std::string paren_string) {
    std::vector<long> depths;
    long current_depth = 0, max_depth = 0;

    for (char ch : paren_string) {
        if (ch == ' ') {
            if (max_depth > 0) {
                depths.push_back(max_depth);
                max_depth = 0;
            }
            current_depth = 0;
        } else if (ch == '(') {
            current_depth++;
            max_depth = std::max(max_depth, current_depth);
        } else if (ch == ')') {
            current_depth--;
        }
    }

    if (max_depth > 0) {
        depths.push_back(max_depth);
    }

    return depths;
}","}
int main() {
    auto candidate = parse_nested_parens;
    assert(candidate((""(()()) ((())) () ((())()())"")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));
    assert(candidate((""() (()) ((())) (((())))"")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((""(()(())((())))"")) == (std::vector<long>({(long)4})));
}
"
HumanEval/7,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠን ንዑስ-ሰንሰለት የያዙትን ብቻ የሰንሰለት ግብዓት ቬክተር ማጣራት >>> filter_by_substring((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_substring(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bacd"", (std::string) ""cde"", (std::string) ""array""})), (""a"") (std::vector<std::string>({(std::string) abc"", (std::string) ""bac""d"", (std::string) ""array""}))
std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
","std::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.find(substring) != std::string::npos) {
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_substring;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""aaaxxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""aaaxxy"", (std::string)""xxxAAA"", (std::string)""xxx""})));
    assert(candidate((std::vector<std::string>({(std::string)""grunt"", (std::string)""trumpet"", (std::string)""prune"", (std::string)""gruesome""})), (""run"")) == (std::vector<std::string>({(std::string)""grunt"", (std::string)""prune""})));
}
"
HumanEval/8,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ለተሰጠ የሙሉ ቁጥሮች ቬክተር በቬክተር ውስጥ ያሉትን ሁሉንም ሙሉ ቁጥሮች ድምር እና ምርት ያካተተ አንድ tuple ይመልሱ ። ባዶ ድምር 0 እኩል መሆን አለበት እና ባዶ ምርት 1 እኩል መሆን አለበት >>> sum_product (((std::vector<long>())) (std::make_tuple ((0, 1)) >>> sum_product (((std::vector<long>({long) 1, (long) 2, (long) 3, (long) 4}))) (std::make_tuple ((10, 24))
std::tuple<long, long> sum_product(std::vector<long> numbers) {
","std::tuple<long, long> sum_product(std::vector<long> numbers) {
    long sum = std::accumulate(numbers.begin(), numbers.end(), 0L);
    long product = std::accumulate(numbers.begin(), numbers.end(), 1L, std::multiplies<long>());
    return std::make_tuple(sum, product);
}","}
int main() {
    auto candidate = sum_product;
    assert(candidate((std::vector<long>())) == (std::make_tuple(0, 1)));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1}))) == (std::make_tuple(3, 1)));
    assert(candidate((std::vector<long>({(long)100, (long)0}))) == (std::make_tuple(100, 0)));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)7}))) == (std::make_tuple(15, 105)));
    assert(candidate((std::vector<long>({(long)10}))) == (std::make_tuple(10, 10)));
}
"
HumanEval/9,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከተሰጠ የቁጥር ቬክተር ጀምሮ በተከታታይ ውስጥ እስከ የተሰጠበት ጊዜ ድረስ የተገኘውን ከፍተኛውን የሮሊንግ ንጥረ ነገር ቬክተር ያመነጫል. >>> rolling_max(((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 3, (long) 4, (long) 2}))) (std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4}))
std::vector<long> rolling_max(std::vector<long> numbers) {
","std::vector<long> rolling_max(std::vector<long> numbers) {
    std::vector<long> result;
    long max_so_far = LONG_MIN;

    for (long num : numbers) {
        max_so_far = std::max(max_so_far, num);
        result.push_back(max_so_far);
    }

    return result;
}","}
int main() {
    auto candidate = rolling_max;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3, (long)100, (long)3}))) == (std::vector<long>({(long)3, (long)3, (long)3, (long)100, (long)100})));
}
"
HumanEval/10,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከተሰጠው ሕብረቁምፊ የሚጀምር አጭር palindrome ያግኙ. የአልጎሪዝም ሀሳብ ቀላል ነው: - ከተሰጠው ሕብረቁምፊ ውስጥ ረጅሙን የፖስትፊክስ ፓሊንድሮም ያግኙ. - ከፓሊንድሮም ቅጥያ በፊት የሚመጣውን የቁምፊ ቅጥያ የቁምፊ ቅጥያ ወደ ኋላው በሰንሰለት መጨረሻ ላይ ያክሉ. >>> make_palindrome ((("""")) ("""") >>> make_palindrome (((""cat"")) (""catac"") >>> make_palindrome (((""cata"")) (""catac"")
std::string make_palindrome(std::string string) {
","std::string make_palindrome(std::string string) {
    auto is_palindrome = [](const std::string &s) {
        return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());
    };

    for (size_t i = 0; i < string.size(); ++i) {
        if (is_palindrome(string.substr(i))) {
            std::string prefix = string.substr(0, i);
            std::reverse(prefix.begin(), prefix.end());
            return string + prefix;
        }
    }

    return string;
}","}
int main() {
    auto candidate = make_palindrome;
    assert(candidate(("""")) == (""""));
    assert(candidate((""x"")) == (""x""));
    assert(candidate((""xyz"")) == (""xyzyx""));
    assert(candidate((""xyx"")) == (""xyx""));
    assert(candidate((""jerry"")) == (""jerryrrej""));
}
"
HumanEval/11,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ግቤት ሁለት ሕብረቁምፊዎች ሀ እና ለ ናቸው 1s እና 0s ብቻ ያካተቱ ናቸው. በእነዚህ ግብዓቶች ላይ ባይናሪ XOR ያካሂዱ እና ውጤቱን እንደ ሕብረቁምፊ ይመልሱ. >>> string_xor((""010""), (""110"")) (""100"")
std::string string_xor(std::string a, std::string b) {
","std::string string_xor(std::string a, std::string b) {
    std::string result;
    for (size_t i = 0; i < a.size(); ++i) {
        result += (a[i] == b[i]) ? '0' : '1';
    }
    return result;
}","}
int main() {
    auto candidate = string_xor;
    assert(candidate((""111000""), (""101010"")) == (""010010""));
    assert(candidate((""1""), (""1"")) == (""0""));
    assert(candidate((""0101""), (""0000"")) == (""0101""));
}
"
HumanEval/12,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከሰንሰለት ቬክተር ውስጥ በጣም ረጅሙን ይመልሱ. ተመሳሳይ ርዝመት ያላቸው በርካታ ሰንሰለቶች ካሉ የመጀመሪያውን ይመልሱ. የመግቢያ ቬክተር ባዶ ከሆነ ምንም አይመልሱ. >>> longest((std::vector<std::string>())) std::nullopt >>> longest((std::vector<std::string>{(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) ""a"" >>> longest(((std::vector<std::string>({(std::string) ""a"", (std::string) ""bb"", (stdstring) ""ccc""}))) ""ccc""
std::optional<std::string> longest(std::vector<std::string> strings) {
","std::optional<std::string> longest(std::vector<std::string> strings) {
    if (strings.empty()) return std::nullopt;

    return *std::max_element(strings.begin(), strings.end(), 
                             [](const std::string& a, const std::string& b) {
                                 return a.size() < b.size();
                             });
}","}
int main() {
    auto candidate = longest;
    assert(candidate((std::vector<std::string>())) == std::nullopt);
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == ""x"");
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""yyy"", (std::string)""zzzz"", (std::string)""www"", (std::string)""kkkk"", (std::string)""abc""}))) == ""zzzz"");
}
"
HumanEval/13,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት integers ሀ እና ለ >>> ትልቁ_የጋራ_መከፋፈል (((3) ፣ (5)) (1) >>> ትልቁ_የጋራ_መከፋፈል (((25) ፣ (15)) (5) አንድ ታላቅ የጋራ መከፋፈል ይመልሳል
long greatest_common_divisor(long a, long b) {
","long greatest_common_divisor(long a, long b) {
    return std::gcd(a, b);
}","}
int main() {
    auto candidate = greatest_common_divisor;
    assert(candidate((3), (7)) == (1));
    assert(candidate((10), (15)) == (5));
    assert(candidate((49), (14)) == (7));
    assert(candidate((144), (60)) == (12));
}
"
HumanEval/14,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከሁሉም ቅድመ-ቅጥያዎች ከሁሉም በጣም አጭር እስከ ረጅሙ የግብዓት ሕብረቁምፊ >>> all_prefixes (((""abc"")) (std::vector<std::string>({(std::string) ""a"", (std::string) ""ab"", (std::string) ""abc""}))
std::vector<std::string> all_prefixes(std::string string) {
","std::vector<std::string> all_prefixes(std::string string) {
    std::vector<std::string> prefixes;
    for (size_t i = 1; i <= string.size(); ++i) {
        prefixes.push_back(string.substr(0, i));
    }
    return prefixes;
}","}
int main() {
    auto candidate = all_prefixes;
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""asdfgh"")) == (std::vector<std::string>({(std::string)""a"", (std::string)""as"", (std::string)""asd"", (std::string)""asdf"", (std::string)""asdfg"", (std::string)""asdfgh""})));
    assert(candidate((""WWW"")) == (std::vector<std::string>({(std::string)""W"", (std::string)""WW"", (std::string)""WWW""})));
}
"
HumanEval/15,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከ0 ጀምሮ እስከ n ድረስ ያሉ ቦታ-የተገደቡ ቁጥሮች የያዘውን ሰንሰለት ይመልሳል.
std::string string_sequence(long n) {
","std::string string_sequence(long n) {
    std::ostringstream oss;
    for (long i = 0; i <= n; ++i) {
        if (i > 0) oss << "" "";
        oss << i;
    }
    return oss.str();
}","}
int main() {
    auto candidate = string_sequence;
    assert(candidate((0)) == (""0""));
    assert(candidate((3)) == (""0 1 2 3""));
    assert(candidate((10)) == (""0 1 2 3 4 5 6 7 8 9 10""));
}
"
HumanEval/16,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ሕብረቁምፊ የተሰጠው, ስንት የተለያዩ ቁምፊዎች (የጉዳይ ምንም ይሁን ምን) ይህ ያካትታል ለማወቅ >>> count_distinct_characters (((""xyzXYZ"")) (3) >>> count_distinct_characters (((""Jerry"")) (4)
long count_distinct_characters(std::string string) {
","long count_distinct_characters(std::string string) {
    std::unordered_set<char> distinct_chars;
    for (char ch : string) {
        distinct_chars.insert(std::tolower(ch));
    }
    return distinct_chars.size();
}","}
int main() {
    auto candidate = count_distinct_characters;
    assert(candidate(("""")) == (0));
    assert(candidate((""abcde"")) == (5));
    assert(candidate((""abcdecadeCADE"")) == (5));
    assert(candidate((""aaaaAAAAaaaa"")) == (1));
    assert(candidate((""Jerry jERRY JeRRRY"")) == (5));
}
"
HumanEval/17,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ይህ ተግባር ወደ ግብዓት አንድ የሙዚቃ ማስታወሻዎች የሚወክሉ ሕብረቁምፊ ነው ASCII ቅርጸት. የእርስዎ ሕብረቁምፊ ቬክተር ለመተንተን ነው በርካታ ምት ጋር የሚዛመድ integers የሚያደርግ እዚህ ላይ አንድ አፈ ታሪክ ነው: 'o' ማስታወሻ - ማስታወሻ, ባለፈው አራት ምት 'o' ያስቀምጣል - ግማሽ ማስታወሻ, ባለፈው ሁለት ምት '- quater ማስታወሻ, ባለፈው አንድ ምት >>> parse_music.
std::vector<long> parse_music(std::string music_string) {
","std::vector<long> parse_music(std::string music_string) {
    std::vector<long> beats;
    std::istringstream iss(music_string);
    std::string note;
    
    while (iss >> note) {
        if (note == ""o"") beats.push_back(4);
        else if (note == ""o|"") beats.push_back(2);
        else if (note == "".|"") beats.push_back(1);
    }

    return beats;
}","}
int main() {
    auto candidate = parse_music;
    assert(candidate(("""")) == (std::vector<long>()));
    assert(candidate((""o o o o"")) == (std::vector<long>({(long)4, (long)4, (long)4, (long)4})));
    assert(candidate(("".| .| .| .|"")) == (std::vector<long>({(long)1, (long)1, (long)1, (long)1})));
    assert(candidate((""o| o| .| .| o o o o"")) == (std::vector<long>({(long)2, (long)2, (long)1, (long)1, (long)4, (long)4, (long)4, (long)4})));
    assert(candidate((""o| .| o| .| o o| o o|"")) == (std::vector<long>({(long)2, (long)1, (long)2, (long)1, (long)4, (long)2, (long)4, (long)2})));
}
"
HumanEval/18,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠን ንዑስ ሰንሰለት በዋናው ሰንሰለት ውስጥ ስንት ጊዜ ማግኘት እንደሚቻል ያግኙ። የሚደጋገፉ ጉዳዮችን ይቁጠሩ. >>> how_many_times((""""), (""a"")) (0) >>> how_many_times(""aaa""), (""a"")) (3) >>> how_many_times(""aaaa""), (""aa"") (3)
long how_many_times(std::string string, std::string substring) {
","long how_many_times(std::string string, std::string substring) {
    if (substring.empty()) return 0;
    
    long count = 0;
    size_t pos = 0;
    
    while ((pos = string.find(substring, pos)) != std::string::npos) {
        count++;
        pos++;  // Move one position forward to count overlapping occurrences
    }
    
    return count;
}","}
int main() {
    auto candidate = how_many_times;
    assert(candidate((""""), (""x"")) == (0));
    assert(candidate((""xyxyxyx""), (""x"")) == (4));
    assert(candidate((""cacacacac""), (""cac"")) == (4));
    assert(candidate((""john doe""), (""john"")) == (1));
}
"
HumanEval/19,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ማስገቢያ ከ ‹ዜሮ› እስከ ‹ዘጠኝ› ድረስ የቁጥር ቁጥሮች በቦታ የተወሰነ ሰንሰለት ነው ። ትክክለኛ ምርጫዎች ‹ዜሮ› ፣ ‹አንድ› ፣ ‹ሁለት› ፣ ‹ሶስት› ፣ ‹አራት› ፣ ‹አምስት› ፣ ‹ስድስት› ፣ ‹ሰባት› ፣ ‹ስምንት› እና ‹ዘጠኝ› ናቸው ። ቁጥሮች ከትንሹ እስከ ትልቁ በተደረደሩ ቁጥሮች ጋር ሰንሰለት ይመልሱ >>> sort_numbers (((""three one five"")) (""አንድ ሶስት አምስት"")
std::string sort_numbers(std::string numbers) {
","std::string sort_numbers(std::string numbers) {
    std::unordered_map<std::string, int> num_map = {
        {""zero"", 0}, {""one"", 1}, {""two"", 2}, {""three"", 3}, {""four"", 4},
        {""five"", 5}, {""six"", 6}, {""seven"", 7}, {""eight"", 8}, {""nine"", 9}
    };

    std::unordered_map<int, std::string> rev_map = {
        {0, ""zero""}, {1, ""one""}, {2, ""two""}, {3, ""three""}, {4, ""four""},
        {5, ""five""}, {6, ""six""}, {7, ""seven""}, {8, ""eight""}, {9, ""nine""}
    };

    std::istringstream iss(numbers);
    std::vector<int> num_list;
    std::string word;

    while (iss >> word) {
        num_list.push_back(num_map[word]);
    }

    std::sort(num_list.begin(), num_list.end());

    std::ostringstream oss;
    for (size_t i = 0; i < num_list.size(); ++i) {
        if (i > 0) oss << "" "";
        oss << rev_map[num_list[i]];
    }

    return oss.str();
}","}
int main() {
    auto candidate = sort_numbers;
    assert(candidate(("""")) == (""""));
    assert(candidate((""three"")) == (""three""));
    assert(candidate((""three five nine"")) == (""three five nine""));
    assert(candidate((""five zero four seven nine eight"")) == (""zero four five seven eight nine""));
    assert(candidate((""six five four three two one zero"")) == (""zero one two three four five six""));
}
"
HumanEval/20,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከተሰጡት ቁጥሮች ቬክተር (በአንድ ርዝመት ቢያንስ ሁለት) አንዱ ከሌላው ጋር በጣም ቅርብ የሆኑትን ሁለት ይምረጡ እና ይመልሱ እና በቅደም ተከተል ይመልሷቸው (ትንሽ ቁጥር ፣ ትልቅ ቁጥር) ። >>> find_closest_elements (በአንድ ቅደም ተከተል)
std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
","std::tuple<float, float> find_closest_elements(std::vector<float> numbers) {
    std::sort(numbers.begin(), numbers.end());
    float min_diff = std::numeric_limits<float>::max();
    float num1 = 0, num2 = 0;

    for (size_t i = 1; i < numbers.size(); ++i) {
        float diff = numbers[i] - numbers[i - 1];
        if (diff < min_diff) {
            min_diff = diff;
            num1 = numbers[i - 1];
            num2 = numbers[i];
        }
    }

    return std::make_tuple(num1, num2);
}","}
int main() {
    auto candidate = find_closest_elements;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(3.9f, 4.0f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))) == (std::make_tuple(5.0f, 5.9f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))) == (std::make_tuple(2.0f, 2.2f)));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))) == (std::make_tuple(2.0f, 2.0f)));
    assert(candidate((std::vector<float>({(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))) == (std::make_tuple(2.2f, 3.1f)));
}
"
HumanEval/21,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠ የቁጥሮች ቬክተር (ቢያንስ ሁለት ንጥረ ነገሮች) ፣ ለዚያ ቬክተር መስመራዊ ለውጥ ያድርጉ ፣ ትንሹ ቁጥር 0 ይሆናል ፣ ትልቁ ደግሞ 1 ይሆናል >>> rescale_to_unit (እ.ተ.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት.ት
std::vector<float> rescale_to_unit(std::vector<float> numbers) {
","std::vector<float> rescale_to_unit(std::vector<float> numbers) {
    float min_val = *std::min_element(numbers.begin(), numbers.end());
    float max_val = *std::max_element(numbers.begin(), numbers.end());

    if (min_val == max_val) {
        std::fill(numbers.begin(), numbers.end(), 0.0f);
        return numbers;
    }

    for (float &num : numbers) {
        num = (num - min_val) / (max_val - min_val);
    }

    return numbers;
}","}
int main() {
    auto candidate = rescale_to_unit;
    assert(candidate((std::vector<float>({(float)2.0f, (float)49.9f}))) == (std::vector<float>({(float)0.0f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)100.0f, (float)49.9f}))) == (std::vector<float>({(float)1.0f, (float)0.0f})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f})));
    assert(candidate((std::vector<float>({(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
    assert(candidate((std::vector<float>({(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))) == (std::vector<float>({(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f})));
}
"
HumanEval/22,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ማጣሪያ የተሰጠው የ cppthon እሴቶች ቬክተር ለጠቅላላ ቁጥሮች ብቻ >>> filter_integers((std::vector<std::any>({(std::string) ""a"", (std::string) 3.14f, (std::string) 5}))) (std::vector<long>({(long) 5})) >>> filter_integers((std::vector<std::any>({1, 2, 3, ""abc"", std::<long,map>), std::vector<long>(()))) (std::vector<long>({(long) 1, (long) 2, (long) 3}))
std::vector<long> filter_integers(std::vector<std::any> values) {
","std::vector<long> filter_integers(std::vector<std::any> values) {
    std::vector<long> result;
    for (const auto& val : values) {
        if (val.type() == typeid(long)) {
            result.push_back(std::any_cast<long>(val));
        } else if (val.type() == typeid(int)) {
            result.push_back(std::any_cast<int>(val));
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_integers;
    assert(candidate((std::vector<std::any>())) == (std::vector<long>()));
    assert(candidate((std::vector<std::any>({4, std::map<long,long>(), std::vector<long>(), 23.2f, 9, ""adasd""}))) == (std::vector<long>({(long)4, (long)9})));
    assert(candidate((std::vector<std::any>({3, ""c"", 3, 3, ""a"", ""b""}))) == (std::vector<long>({(long)3, (long)3, (long)3})));
}
"
HumanEval/23,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠው ሕብረቁምፊ ርዝመት ተመለስ >>> string_length(("""")) (0) >>> string_length((""abc"")) (3)
long string_length(std::string string) {
","long string_length(std::string string) {
    return string.length();
}","}
int main() {
    auto candidate = string_length;
    assert(candidate(("""")) == (0));
    assert(candidate((""x"")) == (1));
    assert(candidate((""asdasnakj"")) == (9));
}
"
HumanEval/24,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ለተሰጠ ቁጥር n፣ nን በእኩል የሚያከፋፍል ትልቁን ቁጥር ይፈልጉ፣ ከ n ያነሰ >>> ትልቁ_መከፋፈያ ((((15)) (5)
long largest_divisor(long n) {
","long largest_divisor(long n) {
    for (long i = n / 2; i > 0; --i) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}","}
int main() {
    auto candidate = largest_divisor;
    assert(candidate((3)) == (1));
    assert(candidate((7)) == (1));
    assert(candidate((10)) == (5));
    assert(candidate((100)) == (50));
    assert(candidate((49)) == (7));
}
"
HumanEval/25,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠውን ጠቅላላ ቁጥር ዋና ዋና ምክንያቶች ከትንሹ እስከ ትልቁ ባለው ቅደም ተከተል ይመልሱ. እያንዳንዱ ምክንያቶች በፋክተሪዜሽን ውስጥ ስንት ጊዜ እንደሚታይ የሚዛመድ የጊዜ ብዛት መሆን አለበት. የመግቢያ ቁጥር ከሁሉም ምክንያቶች እኩል መሆን አለበት >>> factorization (((8)) (std::vector<long> ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> factorize(long n) {
","std::vector<long> factorize(long n) {
    std::vector<long> factors;
    for (long i = 2; i * i <= n; ++i) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 1) {
        factors.push_back(n);
    }
    return factors;
}","}
int main() {
    auto candidate = factorize;
    assert(candidate((2)) == (std::vector<long>({(long)2})));
    assert(candidate((4)) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2, (long)2})));
    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));
    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19, (long)19})));
    assert(candidate((185193)) == (std::vector<long>({(long)3, (long)3, (long)3, (long)19, (long)19, (long)19})));
    assert(candidate((20577)) == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)3})));
}
"
HumanEval/26,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከጠቅላላ ቁጥሮች ቬክተር ውስጥ ከአንድ ጊዜ በላይ የሚከሰቱትን ሁሉንም ንጥረ ነገሮች ያስወግዱ. የንጥረ ነገሮች ቅደም ተከተል እንደ ግብዓት ተመሳሳይ ሆኖ ይቀራል። >>> remove_duplicates((std::vector<long>({(long) 1, (long) 2, (long) 3, (long) 2, (long) 4}))) (std::vector<long>({(long) 1, (long) 3, (long) 4}))
std::vector<long> remove_duplicates(std::vector<long> numbers) {
","std::vector<long> remove_duplicates(std::vector<long> numbers) {
    std::unordered_map<long, int> freq;
    for (long num : numbers) {
        freq[num]++;
    }

    std::vector<long> result;
    for (long num : numbers) {
        if (freq[num] == 1) {
            result.push_back(num);
        }
    }

    return result;
}","}
int main() {
    auto candidate = remove_duplicates;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4, (long)3, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)5})));
}
"
HumanEval/27,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ለተሰጠ ሰንሰለት፣ ትናንሽ ፊደላትን ወደ ትልቅ ፊደል እና ትልቅ ፊደላትን ወደ ትንሽ ፊደል ይለውጡ. >>> flip_case (((""Hello"")) (""HELLO"")
std::string flip_case(std::string string) {
","std::string flip_case(std::string string) {
    for (char &ch : string) {
        if (std::islower(ch)) {
            ch = std::toupper(ch);
        } else if (std::isupper(ch)) {
            ch = std::tolower(ch);
        }
    }
    return string;
}","}
int main() {
    auto candidate = flip_case;
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hello!"")) == (""hELLO!""));
    assert(candidate((""These violent delights have violent ends"")) == (""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS""));
}
"
HumanEval/28,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የሰንሰለት ቬክተር ወደ አንድ ነጠላ ሰንሰለት >>> concatenate((std::vector<std::string>())) ("""") >>> concatenate((std::vector<std::string>({(std::string) ""a"", (std::string) ""b"", (std::string) ""c""}))) (""abc"")
std::string concatenate(std::vector<std::string> strings) {
","std::string concatenate(std::vector<std::string> strings) {
    std::string result;
    for (const auto& str : strings) {
        result += str;
    }
    return result;
}","}
int main() {
    auto candidate = concatenate;
    assert(candidate((std::vector<std::string>())) == (""""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z""}))) == (""xyz""));
    assert(candidate((std::vector<std::string>({(std::string)""x"", (std::string)""y"", (std::string)""z"", (std::string)""w"", (std::string)""k""}))) == (""xyzwk""));
}
"
HumanEval/29,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በተሰጠ ቅድመ-ቅጥያ ለሚጀምሩ ብቻ የሰንሰለት ግብዓት ቬክተር ማጣራት >>> filter_by_prefix((std::vector<std::string>()), (""a"")) (std::vector<std::string>()) >>> filter_by_prefix(((std::vector<std::string>({(std::string) ""abc"", (std::string) ""bcd"", (std::string) ""cde"", (stdstring) ""array""})), (""a"") (std::vector<std::string>(({(std::string) ""abc"", (std::string) ""array""}))
std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
","std::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {
    std::vector<std::string> result;
    for (const auto& str : strings) {
        if (str.rfind(prefix, 0) == 0) {  // Check if 'str' starts with 'prefix'
            result.push_back(str);
        }
    }
    return result;
}","}
int main() {
    auto candidate = filter_by_prefix;
    assert(candidate((std::vector<std::string>()), (""john"")) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""xxx"", (std::string)""asd"", (std::string)""xxy"", (std::string)""john doe"", (std::string)""xxxAAA"", (std::string)""xxx""})), (""xxx"")) == (std::vector<std::string>({(std::string)""xxx"", (std::string)""xxxAAA"", (std::string)""xxx""})));
}
"
HumanEval/30,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በቬክተር ውስጥ አዎንታዊ ቁጥሮች ብቻ ይመልሱ. >>> get_positive((std::vector<long>({long) -1, (long) -2, (long) -4, (long) -5, (long) -6}))) (std::vector<long>({long) -2, (long) -5, (long) -6})) >>> get_positive((std::vector<long>({long) -5, (long) -3, (long) -5, (long) -5, (long) -3, (long) -3, (long) -9, (long) -0, (long) -123, (long) -1, (long) -10}))) (std::vector<long>{(long) -5, (long) -3, (long) -2, (long) -3, (long) -9, (long) -123, (long) -1}))
std::vector<long> get_positive(std::vector<long> l) {
","std::vector<long> get_positive(std::vector<long> l) {
    std::vector<long> result;
    for (long num : l) {
        if (num > 0) {
            result.push_back(num);
        }
    }
    return result;
}","}
int main() {
    auto candidate = get_positive;
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)4, (long)5, (long)6}))) == (std::vector<long>({(long)4, (long)5, (long)6})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)3, (long)9, (long)123, (long)1})));
    assert(candidate((std::vector<long>({(long)-1, (long)-2}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/31,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠው ቁጥር ዋና ከሆነ እውነት እና በሌላ መንገድ ሐሰት ይመልሳል. >>> is_prime((6)) (ሐሰት) >>> is_prime((101)) (እውነት) >>> is_prime((11)) (እውነት) >>> is_prime((13441)) (እውነት) >>> is_prime(61)) (እውነት) >>> is_prime(4)) (ሐሰት) >>> is_prime(1)) (ሐሰት)
bool is_prime(long n) {
","bool is_prime(long n) {
    if (n < 2) return false;
    if (n < 4) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_prime;
    assert(candidate((6)) == (false));
    assert(candidate((101)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((13441)) == (true));
    assert(candidate((61)) == (true));
    assert(candidate((4)) == (false));
    assert(candidate((1)) == (false));
    assert(candidate((5)) == (true));
    assert(candidate((11)) == (true));
    assert(candidate((17)) == (true));
    assert(candidate((85)) == (false));
    assert(candidate((77)) == (false));
    assert(candidate((255379)) == (false));
}
"
HumanEval/33,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ይህ ተግባር አንድ ቬክተር ይወስዳል እና ቬክተር ይመልሳል l' እንደዚህ ነው l' በሦስት የማይከፋፈሉ ኢንዴክሶች ውስጥ ከ l ጋር ተመሳሳይ ነው ፣ በሦስት የሚከፋፈሉ ኢንዴክሶች ላይ ያሉት እሴቶቹ ግን ከ l ተመጣጣኝ ኢንዴክሶች እሴቶች ጋር እኩል ናቸው ፣ ግን ተደራጅተዋል ። >>> sort_third(((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (std::vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_third((std::vector<long>{(long>{(long) 5, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 2}))) (std::vector<(long>{(long>{(long>2, (long) 6, (long) 3, (long) 4, (long) 8, (long) 9, (long) 5}))
std::vector<long> sort_third(std::vector<long> l) {
","std::vector<long> sort_third(std::vector<long> l) {
    std::vector<long> third_indices;
    for (size_t i = 0; i < l.size(); i += 3) {
        third_indices.push_back(l[i]);
    }
    std::sort(third_indices.begin(), third_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 3) {
        l[i] = third_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_third;
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)3, (long)4, (long)6, (long)9, (long)2}))) == (std::vector<long>({(long)2, (long)8, (long)3, (long)4, (long)6, (long)9, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)9, (long)4, (long)8, (long)3, (long)2}))) == (std::vector<long>({(long)2, (long)6, (long)9, (long)4, (long)8, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5, (long)1})));
}
"
HumanEval/34,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በቬክተር ውስጥ የተደረደሩ ልዩ ንጥረ ነገሮችን ይመልሱ >>> unique((std::vector<long>({(long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>{(long) 0, (long) 2, (long) 3, (long) 5, (long) 9, (long) 123}))
std::vector<long> unique(std::vector<long> l) {
","std::vector<long> unique(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    return l;
}","}
int main() {
    auto candidate = unique;
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123})));
}
"
HumanEval/35,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በቬክተር ውስጥ ከፍተኛውን ንጥረ ነገር ይመልሱ. >>> max_element((std::vector<long>({long) 1, (long) 2, (long) 3}))) (3) >>> max_element((std::vector<long>({long) 5, (long) 3, (long) -5, (long) 2, (long) -3, (long) 3, (long) 9, (long) 0, (long) 123, (long) 1, (long) -10}))) (123)
long max_element(std::vector<long> l) {
","long max_element(std::vector<long> l) {
    return *std::max_element(l.begin(), l.end());
}","}
int main() {
    auto candidate = max_element;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (3));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1, (long)-10}))) == (124));
}
"
HumanEval/36,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁጥር 7 ቁጥር በ 11 ወይም በ 13 በሚከፋፈሉ ከ n በታች ባሉ ሙሉ ቁጥሮች ውስጥ የሚከሰትበትን ቁጥር ይመልሱ >>> fizz_buzz((50)) (0) >>> fizz_buzz((78)) (2) >>> fizz_buzz((79) (3)
long fizz_buzz(long n) {
","long fizz_buzz(long n) {
    long count = 0;
    for (long i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            long temp = i;
            while (temp > 0) {
                if (temp % 10 == 7) count++;
                temp /= 10;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = fizz_buzz;
    assert(candidate((50)) == (0));
    assert(candidate((78)) == (2));
    assert(candidate((79)) == (3));
    assert(candidate((100)) == (3));
    assert(candidate((200)) == (6));
    assert(candidate((4000)) == (192));
    assert(candidate((10000)) == (639));
    assert(candidate((100000)) == (8026));
}
"
HumanEval/37,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ይህ ተግባር አንድ ቬክተር ይወስዳል እና ቬክተር ይመልሳል l' እንደዚህ ነው l' ጋር ተመሳሳይ ነው l በዝቅተኛ ኢንዴክሶች ውስጥ ፣ በእኩል ኢንዴክሶች ውስጥ ያሉት እሴቶቹ ግን ከ l እኩል ኢንዴክሶች እሴቶች ጋር እኩል ናቸው ፣ ግን የተደረደሩ ናቸው ። >>> sort_even: vector<long>{(long) 1, (long) 2, (long) 3}))) (std:: vector<long>{(long) 1, (long) 2, (long) 3})) >>> sort_even: vector<long>{(long) 5, (long) 6, (long) 3, (long) 4}))) (std:: vector<(long>{((long) 3, (long) 6, (long) 5, (long) 4}))
std::vector<long> sort_even(std::vector<long> l) {
","std::vector<long> sort_even(std::vector<long> l) {
    std::vector<long> even_indices;
    for (size_t i = 0; i < l.size(); i += 2) {
        even_indices.push_back(l[i]);
    }
    std::sort(even_indices.begin(), even_indices.end());
    
    size_t idx = 0;
    for (size_t i = 0; i < l.size(); i += 2) {
        l[i] = even_indices[idx++];
    }
    
    return l;
}","}
int main() {
    auto candidate = sort_even;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)1, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10}))) == (std::vector<long>({(long)-10, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)5, (long)0, (long)9, (long)1, (long)123})));
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)-12, (long)4, (long)23, (long)2, (long)3, (long)11, (long)12, (long)-10}))) == (std::vector<long>({(long)-12, (long)8, (long)3, (long)4, (long)5, (long)2, (long)12, (long)11, (long)23, (long)-10})));
}
"
HumanEval/39,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// prime_fib የፊቦናቺ ቁጥር የሆነ n-ኛ ቁጥርን ይመልሳል እንዲሁም እሱ ደግሞ ፕራይም ነው። >>> prime_fib((1)) (2) >>> prime_fib((2)) (3) >>> prime_fib(3)) (5) >>> prime_fib((4)) (13) >>> prime_fib(5)) (89)
long prime_fib(long n) {
","bool is_prime(long num) {
    if (num < 2) return false;
    if (num < 4) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (long i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}

long prime_fib(long n) {
    std::vector<long> prime_fibs;
    long a = 1, b = 1;
    while (prime_fibs.size() < n) {
        long next = a + b;
        a = b;
        b = next;
        if (is_prime(next)) {
            prime_fibs.push_back(next);
        }
    }
    return prime_fibs[n - 1];
}","}
int main() {
    auto candidate = prime_fib;
    assert(candidate((1)) == (2));
    assert(candidate((2)) == (3));
    assert(candidate((3)) == (5));
    assert(candidate((4)) == (13));
    assert(candidate((5)) == (89));
    assert(candidate((6)) == (233));
    assert(candidate((7)) == (1597));
    assert(candidate((8)) == (28657));
    assert(candidate((9)) == (514229));
    assert(candidate((10)) == (433494437));
}
"
HumanEval/40,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// triples_sum_to_zero የሙሉ ቁጥሮች ቬክተር እንደ ግብዓት ይወስዳል:: በቬክተሩ ውስጥ ሶስት የተለያዩ ንጥረ ነገሮች ቢኖሩ እውነት ይሆናል ፣ እና በሌላ መንገድ ሐሰት ይሆናል. >>> triples_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> triples_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long)-2, (long) 1} >>> (true) triples_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) >>> triples_to_zero_(std::vector<long>{long>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool triples_sum_to_zero(std::vector<long> l) {
","bool triples_sum_to_zero(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    for (size_t i = 0; i < n - 2; i++) {
        size_t left = i + 1, right = n - 1;
        while (left < right) {
            long sum = l[i] + l[left] + l[right];
            if (sum == 0) return true;
            else if (sum < 0) left++;
            else right--;
        }
    }
    
    return false;
}","}
int main() {
    auto candidate = triples_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)5, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)-100}))) == (false));
    assert(candidate((std::vector<long>({(long)100, (long)3, (long)5, (long)-100}))) == (false));
}
"
HumanEval/41,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ መንገድ ፍጹም ቀጥ ያለ ነው እንበል በቀጥታ ረጅም መስመር. n መኪናዎች ግራ ወደ ቀኝ እየነዱ ናቸው; በተመሳሳይ ጊዜ, n መኪናዎች የተለያዩ ስብስብ ቀኝ ወደ ግራ እየነዱ ናቸው. መኪናዎች ሁለት ስብስቦች እርስ በርሳቸው በጣም ሩቅ መሆን ይጀምራሉ. ሁሉም መኪናዎች ተመሳሳይ ፍጥነት ውስጥ ይንቀሳቀሳሉ. ሁለት መኪናዎች ግራ ወደ ቀኝ የሚንቀሳቀሱ መኪና ቀኝ ወደ ግራ የሚንቀሳቀሱ መኪና ይገጥመዋል ጊዜ ይጋጫሉ ይባላል. ይሁን እንጂ, መኪናዎች በማያልቅ ጠንካራ እና ጠንካራ ናቸው; በዚህም ምክንያት, እነርሱ ግጭት አይደለም እንደ ያላቸውን ትራክተሪ ውስጥ መንቀሳቀስ ይቀጥላሉ. ይህ ተግባር እንዲህ ግጭቶች ቁጥር ያስወጣል.
long car_race_collision(long n) {
","long car_race_collision(long n) {
    return n * n;
}","}
int main() {
    auto candidate = car_race_collision;
    assert(candidate((2)) == (4));
    assert(candidate((3)) == (9));
    assert(candidate((4)) == (16));
    assert(candidate((8)) == (64));
    assert(candidate((10)) == (100));
}
"
HumanEval/42,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በ 1 የተጨመሩ ንጥረ ነገሮች ያሉት ቬክተር ይመለሱ >>> incr_list((std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<long>({long) 2, (long) 3, (long) 4})) >>> incr_list((std::vector<long>({long) 5, (long) 3, (long) 5, (long) 2, (long) 3, (long) 3, (long) 9, (long) 0, (long) 123}))) (std::vector<long>({long) 6, (long) 4, (long) 6, (long) 3, (long) 4, (long) 4, (long) 10, (long) 1, (long) 124}))
std::vector<long> incr_list(std::vector<long> l) {
","std::vector<long> incr_list(std::vector<long> l) {
    for (long &num : l) {
        num++;
    }
    return l;
}","}
int main() {
    auto candidate = incr_list;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)4, (long)3, (long)2})));
    assert(candidate((std::vector<long>({(long)5, (long)2, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123}))) == (std::vector<long>({(long)6, (long)3, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124})));
}
"
HumanEval/43,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// pairs_sum_to_zero የሙሉ ቁጥሮች ቬክተር እንደ ግብዓት ይወስዳል:: በቬክተሩ ውስጥ ሁለት የተለያዩ ንጥረ ነገሮች ቢኖሩ እውነት ይሆናል ፣ እና በሌላ መንገድ ሐሰት ይሆናል. >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 5, (long) 0}))) (false) >>> pairs_sum_to_zero(std::vector<long>({long) 1, (long) 3, (long) 2, (long) 1} >>> (false) pairs_sum_to_zero(std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 7}))) (se) pairs >>>_sum_to_zero(std::vector<long>{long>(((((2, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long)) (false) >>> pairs_sum_to_zero(std::vector<long> (long)) (long) >>> (long) (long) (long) (long) >>> (long)
bool pairs_sum_to_zero(std::vector<long> l) {
","bool pairs_sum_to_zero(std::vector<long> l) {
    std::unordered_set<long> seen;
    for (long num : l) {
        if (seen.count(-num)) {
            return true;
        }
        seen.insert(num);
    }
    return false;
}","}
int main() {
    auto candidate = pairs_sum_to_zero;
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)5, (long)0}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)-2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)7}))) == (false));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)30}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)3, (long)2, (long)31}))) == (true));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)30}))) == (false));
    assert(candidate((std::vector<long>({(long)-3, (long)9, (long)-1, (long)4, (long)2, (long)31}))) == (false));
}
"
HumanEval/44,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የግብዓት ቁጥር x የቁጥር መሠረት ወደ መሠረት ይለውጡ. ከለውጡ በኋላ የሰንሰለት ውክልና ይመልሱ. የመሠረት ቁጥሮች ከ 10 ያነሱ ናቸው. >>> change_base((8), (3)) (""22"") >>> change_base((8), (2)) (""1000"") >>> change_base((7), (2)) (""111"")
std::string change_base(long x, long base) {
","std::string change_base(long x, long base) {
    if (x == 0) return ""0"";
    
    std::string result;
    while (x > 0) {
        result += std::to_string(x % base);
        x /= base;
    }
    
    std::reverse(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = change_base;
    assert(candidate((8), (3)) == (""22""));
    assert(candidate((9), (3)) == (""100""));
    assert(candidate((234), (2)) == (""11101010""));
    assert(candidate((16), (2)) == (""10000""));
    assert(candidate((8), (2)) == (""1000""));
    assert(candidate((7), (2)) == (""111""));
    assert(candidate((2), (3)) == (""2""));
    assert(candidate((3), (4)) == (""3""));
    assert(candidate((4), (5)) == (""4""));
    assert(candidate((5), (6)) == (""5""));
    assert(candidate((6), (7)) == (""6""));
    assert(candidate((7), (8)) == (""7""));
}
"
HumanEval/45,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ለሶስት ማዕዘን የጎን ርዝመት እና ከፍተኛ የመመለሻ አካባቢ የተሰጠው >>> triangle_area (((5), (3)) (7.5f)
float triangle_area(long a, long h) {
","float triangle_area(long a, long h) {
    return 0.5f * a * h;
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((5), (3)) == (7.5f));
    assert(candidate((2), (2)) == (2.0f));
    assert(candidate((10), (8)) == (40.0f));
}
"
HumanEval/46,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የ Fib4 ቁጥር ቅደም ተከተል ከ Fibbonacci ቅደም ተከተል ጋር ተመሳሳይ የሆነ ቅደም ተከተል ነው ይህም እንደሚከተለው ተገልጻል: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). እባክዎን የ fib4 ቁጥር ቅደም ተከተል n-ኛ ንጥረ ነገር በብቃት ለማስላት አንድ ተግባር ይጻፉ. ተደጋጋሚነት አይጠቀሙ. >>> fib4((5)) (4) >>> fib4((6)) (8) >>> fib4((7)) (14)
long fib4(long n) {
","long fib4(long n) {
    if (n == 0 || n == 1 || n == 3) return 0;
    if (n == 2) return 2;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 2;

    for (long i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fib4;
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (28));
    assert(candidate((10)) == (104));
    assert(candidate((12)) == (386));
}
"
HumanEval/47,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በቬክተር ውስጥ ያሉትን ንጥረ ነገሮች መለስ መለስ መለስ l. >>> median((std::vector<long>({(long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (float(3) >>> median((std::vector<long>({(long) -10, (long) 4, (long) 6, (long) 1000, (long) 10, (long) 20}))) (15.0f)
float median(std::vector<long> l) {
","float median(std::vector<long> l) {
    std::sort(l.begin(), l.end());
    size_t n = l.size();
    
    if (n % 2 == 1) {
        return static_cast<float>(l[n / 2]);
    } else {
        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;
    }
}","}
int main() {
    auto candidate = median;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (float(3)));
    assert(candidate((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0f));
    assert(candidate((std::vector<long>({(long)5}))) == (float(5)));
    assert(candidate((std::vector<long>({(long)6, (long)5}))) == (5.5f));
    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3, (long)9, (long)9, (long)2, (long)7}))) == (float(7)));
}
"
HumanEval/48,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠው ሕብረቁምፊ ፓሊንድሮም ከሆነ ያረጋግጣል >>> is_palindrome ((("""")) (እውነት) >>> is_palindrome (((""aba"")) (እውነት) >>> is_palindrome (((""aaaaa"")) (እውነት) >>> is_palindrome (((""zbcd"")) (የሐሰት)
bool is_palindrome(std::string text) {
","bool is_palindrome(std::string text) {
    return std::equal(text.begin(), text.begin() + text.size() / 2, text.rbegin());
}","}
int main() {
    auto candidate = is_palindrome;
    assert(candidate(("""")) == (true));
    assert(candidate((""aba"")) == (true));
    assert(candidate((""aaaaa"")) == (true));
    assert(candidate((""zbcd"")) == (false));
    assert(candidate((""xywyx"")) == (true));
    assert(candidate((""xywyz"")) == (false));
    assert(candidate((""xywzx"")) == (false));
}
"
HumanEval/49,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// 2 ^ n ሞዱል p (ቁጥርን ማወቅ) ይመልሱ: >>> ሞድp((3), (5)) (3) >>> ሞድp((1101), (101)) (2) >>> ሞድp((0), (101)) (1) >>> ሞድp((3), (11)) (8) >>> ሞድp((100), (101)) (1)
long modp(long n, long p) {
","long modp(long n, long p) {
    return std::pow(2, n) % p;
}","}
int main() {
    auto candidate = modp;
    assert(candidate((3), (5)) == (3));
    assert(candidate((1101), (101)) == (2));
    assert(candidate((0), (101)) == (1));
    assert(candidate((3), (11)) == (8));
    assert(candidate((100), (101)) == (1));
    assert(candidate((30), (5)) == (4));
    assert(candidate((31), (5)) == (3));
}
"
HumanEval/51,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// remove_vowels የቁምፊ ገመድ የሚወስድ እና ያለ ድምጽ ፊደሎች ያለ ገመድ የሚመልስ ተግባር ነው። >>> remove_vowels("""")) ("""") >>> remove_vowels((""abcdef"")) (""bcdf"") >>> remove_vowels((""aaaaa"")) ("""") >>> remove_vowels(""aaBAA"")) (""B"") >>> remove_vowels((""zbcd"")) (""zbcd"")
std::string remove_vowels(std::string text) {
","std::string remove_vowels(std::string text) {
    std::string result;
    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    
    for (char ch : text) {
        if (vowels.find(ch) == vowels.end()) {
            result += ch;
        }
    }
    
    return result;
}","}
int main() {
    auto candidate = remove_vowels;
    assert(candidate(("""")) == (""""));
    assert(candidate((""abcdef\nghijklm"")) == (""bcdf\nghjklm""));
    assert(candidate((""fedcba"")) == (""fdcb""));
    assert(candidate((""eeeee"")) == (""""));
    assert(candidate((""acBAA"")) == (""cB""));
    assert(candidate((""EcBOO"")) == (""cB""));
    assert(candidate((""ybcd"")) == (""ybcd""));
}
"
HumanEval/52,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በቬክተር l ውስጥ ያሉ ሁሉም ቁጥሮች ከግቤት በታች ከሆኑ እውነት ይመልሱ >>> below_threshold((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 10})), (100)) (true) >>> below_threshold((std::vector<long>({(long) 1, (long) 20, (long) 4, (long) 10})), (5)) (false)
bool below_threshold(std::vector<long> l, long t) {
","bool below_threshold(std::vector<long> l, long t) {
    return std::all_of(l.begin(), l.end(), [t](long num) { return num < t; });
}","}
int main() {
    auto candidate = below_threshold;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (21)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (22)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (11)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)8, (long)4, (long)10})), (10)) == (false));
}
"
HumanEval/53,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት ቁጥሮች x እና y ይጨምሩ >>> ይጨምሩ (((2), (3)) (5) >>> ይጨምሩ (((5), (7)) (12)
long add(long x, long y) {
","long add(long x, long y) {
    return x + y;
}","}
int main() {
    auto candidate = add;
    assert(candidate((0), (1)) == (1));
    assert(candidate((1), (0)) == (1));
    assert(candidate((2), (3)) == (5));
    assert(candidate((5), (7)) == (12));
    assert(candidate((7), (5)) == (12));
}
"
HumanEval/54,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት ቃላት ተመሳሳይ ቁምፊዎች እንዳላቸው ያረጋግጡ. >>> same_chars(""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) (true) >>> same_chars((""abcd""), (""dddddddabc"")) (true) >>> same_chars(""dddddddabc""), (""abcd"") (true) >>> same_chars((""eabcd""), (""dddddddabc"")) (false) same_chars >>>""((abcd""), (""dddddddabce"") (false) >>> same_chars((""eabcd""), (""ddddzzzzzdzddddabc"") (false)
bool same_chars(std::string s0, std::string s1) {
","bool same_chars(std::string s0, std::string s1) {
    std::unordered_set<char> set0(s0.begin(), s0.end());
    std::unordered_set<char> set1(s1.begin(), s1.end());
    return set0 == set1;
}","}
int main() {
    auto candidate = same_chars;
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(candidate((""abcd""), (""dddddddabc"")) == (true));
    assert(candidate((""dddddddabc""), (""abcd"")) == (true));
    assert(candidate((""eabcd""), (""dddddddabc"")) == (false));
    assert(candidate((""abcd""), (""dddddddabcf"")) == (false));
    assert(candidate((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(candidate((""aabb""), (""aaccc"")) == (false));
}
"
HumanEval/55,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// n-ኛውን የፊቦናቺ ቁጥር ይመልሱ. >>> fib(((10)) (55) >>> fib(((1)) (1) >>> fib((8)) (21)
long fib(long n) {
","long fib(long n) {
    if (n <= 1) return n;
    
    long a = 0, b = 1, c;
    for (long i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    
    return b;
}","}
int main() {
    auto candidate = fib;
    assert(candidate((10)) == (55));
    assert(candidate((1)) == (1));
    assert(candidate((8)) == (21));
    assert(candidate((11)) == (89));
    assert(candidate((12)) == (144));
}
"
HumanEval/56,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// <> እያንዳንዱ የመክፈቻ ቅንፍ የሚዛመድ የመዝጊያ ቅንፍ ካለው እውነት ይመልሳል. >>> correct_bracketing((""<"")) (false) >>> correct_bracketing(""<>"")) (true) >>> correct_bracketing(""<><>"")) (true) >>> correct_bracketing("">(<>"") (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '<') balance++;
        else if (ch == '>') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""<>"")) == (true));
    assert(candidate((""<<><>>"")) == (true));
    assert(candidate((""<><><<><>><>"")) == (true));
    assert(candidate((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(candidate((""<<<><>>>>"")) == (false));
    assert(candidate((""><<>"")) == (false));
    assert(candidate((""<"")) == (false));
    assert(candidate((""<<<<"")) == (false));
    assert(candidate(("">"")) == (false));
    assert(candidate((""<<>"")) == (false));
    assert(candidate((""<><><<><>><>><<>"")) == (false));
    assert(candidate((""<><><<><>><>>><>"")) == (false));
}
"
HumanEval/57,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// እውነት ነው ይመለሱ የቬክተር አካላት በሞኖቶኒክ እየጨመሩ ወይም እየቀነሱ ናቸው. >>> ሞኖቶኒክ ((((std::vector<long>({(long) 1, (long) 2, (long) 4, (long) 20}))) (እውነት) >>> ሞኖቶኒክ (((std::vector<long>{(long) 1, (long) 20, (long) 4, (long) 10}))) (የሐሰት) >>> ሞኖቶኒክ ((((std::vector<long>{(long) 4, (long) 1, (long) 0, (long) -10}))) (እውነት)
bool monotonic(std::vector<long> l) {
","bool monotonic(std::vector<long> l) {
    bool increasing = true, decreasing = true;
    
    for (size_t i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) decreasing = false;
        if (l[i] < l[i - 1]) increasing = false;
    }
    
    return increasing || decreasing;
}","}
int main() {
    auto candidate = monotonic;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)10}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)20}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)20, (long)4, (long)10}))) == (false));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)0, (long)-10}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)1, (long)0}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));
    assert(candidate((std::vector<long>({(long)9, (long)9, (long)9, (long)9}))) == (true));
}
"
HumanEval/58,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ለሁለት ቬክተሮች የተደረደሩ ልዩ የጋራ ንጥረ ነገሮችን ይመልሱ. >>> common((std::vector<long>({long) 1, (long) 4, (long) 3, (long) 34, (long) 653, (long) 2, (long) 5), (std::vector<long>({long) 5, (long) 7, (long) 1, (long) 5, (long) 9, (long) 653, (long) 121}))) (std::vector<long>({long) 1, (long) 5, (long) 653})) >>> common(std::vector<long>({long) 5, (long) 3, (long) 2, (long) 8})), (std::vector<long>{(long) 3, (long) 2))) (std::vector<long>{(long) 2, (long) 3))
std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
","std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {
    std::unordered_set<long> set1(l1.begin(), l1.end());
    std::unordered_set<long> result_set;
    
    for (long num : l2) {
        if (set1.count(num)) {
            result_set.insert(num);
        }
    }
    
    std::vector<long> result(result_set.begin(), result_set.end());
    std::sort(result.begin(), result.end());
    return result;
}","}
int main() {
    auto candidate = common;
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121}))) == (std::vector<long>({(long)1, (long)5, (long)653})));
    assert(candidate((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2}))) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2, (long)4}))) == (std::vector<long>({(long)2, (long)3, (long)4})));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)2, (long)8})), (std::vector<long>())) == (std::vector<long>()));
}
"
HumanEval/59,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ትልቁን የ n ዋና ዋና አምሳያ ይመልሱ n > 1 እና ዋና አይደለም ብለን እንገምታለን >>> ትልቁ_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋና_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ_ዋ______________________________________________________________
long largest_prime_factor(long n) {
","long largest_prime_factor(long n) {
    long largest = -1;
    
    while (n % 2 == 0) {
        largest = 2;
        n /= 2;
    }
    
    for (long i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            largest = i;
            n /= i;
        }
    }
    
    if (n > 1) largest = n;
    
    return largest;
}","}
int main() {
    auto candidate = largest_prime_factor;
    assert(candidate((15)) == (5));
    assert(candidate((27)) == (3));
    assert(candidate((63)) == (7));
    assert(candidate((330)) == (11));
    assert(candidate((13195)) == (29));
}
"
HumanEval/60,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// sum_to_n ከ1 እስከ n ያሉ ቁጥሮች የሚደመር ተግባር ነው። >>> sum_to_n((30)) (465) >>> sum_to_n(100)) (5050) >>> sum_to_n((5)) (15) >>> sum_to_n(10)) (55) >>> sum_to_n(1) (1)
long sum_to_n(long n) {
","long sum_to_n(long n) {
    return n * (n + 1) / 2;
}","}
int main() {
    auto candidate = sum_to_n;
    assert(candidate((1)) == (1));
    assert(candidate((6)) == (21));
    assert(candidate((11)) == (66));
    assert(candidate((30)) == (465));
    assert(candidate((100)) == (5050));
}
"
HumanEval/61,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// brackets የ ""("" እና """") ሰንሰለት ነው. እያንዳንዱ የመክፈቻ ቅንፍ የሚዛመድ የመዝጊያ ቅንፍ ካለው እውነት ይመልሳል. >>> correct_bracketing((""("")) (false) >>> correct_bracketing(""() "")) (true) >>> correct_bracketing(""(()))))) (true) >>> correct_bracketing((""))) (false)
bool correct_bracketing(std::string brackets) {
","bool correct_bracketing(std::string brackets) {
    int balance = 0;
    for (char ch : brackets) {
        if (ch == '(') balance++;
        else if (ch == ')') balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}","}
int main() {
    auto candidate = correct_bracketing;
    assert(candidate((""()"")) == (true));
    assert(candidate((""(()())"")) == (true));
    assert(candidate((""()()(()())()"")) == (true));
    assert(candidate((""()()((()()())())(()()(()))"")) == (true));
    assert(candidate((""((()())))"")) == (false));
    assert(candidate(("")(()"")) == (false));
    assert(candidate((""("")) == (false));
    assert(candidate((""(((("")) == (false));
    assert(candidate(("")"")) == (false));
    assert(candidate((""(()"")) == (false));
    assert(candidate((""()()(()())())(()"")) == (false));
    assert(candidate((""()()(()())()))()"")) == (false));
}
"
HumanEval/62,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// xs የ polynomial ተባባሪዎችን ይወክላሉ xs[0] + xs[1] * x + xs[2] * x^2 + .... የዚህን polynomial derivative በተመሳሳይ መልክ ይመልሱ. >>> derivative((std::vector<long>({long) 3, (long) 1, (long) 2, (long) 4, (long) 5}))) (std::vector<long>{(long) 1, (long) 4, (long) 12, (long) 20})) >>> derivative::std::vector<long>({long) 1, (long) 2, (long) 3}))) (std::vector<(long>{(long) 2, (long) 6}))
std::vector<long> derivative(std::vector<long> xs) {
","std::vector<long> derivative(std::vector<long> xs) {
    std::vector<long> result;
    for (size_t i = 1; i < xs.size(); i++) {
        result.push_back(xs[i] * i);
    }
    return result;
}","}
int main() {
    auto candidate = derivative;
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)4, (long)12, (long)20})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)6})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (std::vector<long>({(long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1, (long)0, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)0, (long)16})));
    assert(candidate((std::vector<long>({(long)1}))) == (std::vector<long>()));
}
"
HumanEval/63,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የ FibFib ቁጥር ቅደም ተከተል ከ Fibbonacci ቅደም ተከተል ጋር ተመሳሳይ የሆነ ቅደም ተከተል ነው ይህም እንደሚከተለው ተገልጻል: fibfib ((0) == 0 fibfib ((1) == 0 fibfib ((2) == 1 fibfib ((n) == fib ((n-1) + fibfib ((n-2) + fibfib ((n-3). እባክዎን የ fibfib ቁጥር ቅደም ተከተል n-ኛ ንጥረ ነገር በብቃት ለማስላት አንድ ተግባር ይጻፉ. >>> fibfib (((1)) (0) >>> fib (((5)) (4) >>> fib ((8)) (24)
long fibfib(long n) {
","long fibfib(long n) {
    if (n == 0 || n == 1) return 0;
    if (n == 2) return 1;

    std::vector<long> dp(n + 1, 0);
    dp[2] = 1;

    for (long i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}","}
int main() {
    auto candidate = fibfib;
    assert(candidate((2)) == (1));
    assert(candidate((1)) == (0));
    assert(candidate((5)) == (4));
    assert(candidate((8)) == (24));
    assert(candidate((10)) == (81));
    assert(candidate((12)) == (274));
    assert(candidate((14)) == (927));
}
"
HumanEval/64,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድን ቃል የሚወክል ገመድ እንደ ግብዓት የሚወስድ እና በገመድ ውስጥ ያሉትን የድምጽ ፊደላት ቁጥር የሚመልስ የድምጽ ፊደላት ይጻፉ። በዚህ ሁኔታ ውስጥ ድምጽ ፊደላት ‹a› ፣ ‹e› ፣ ‹i› ፣ ‹o› ፣ ‹u› ናቸው ። እዚህ ፣ ‹y› እንዲሁ ድምጽ ፊደል ነው ፣ ግን በተሰጠው ቃል መጨረሻ ላይ ብቻ ነው ። ምሳሌ: >>> vowels_count (((""abcde"")) (2) >>> vowels_count (((""ACEDY"")) (3)
long vowels_count(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long vowels_count(std::string s) {
  long count = 0;
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  for (char c : s) {
    if (vowels.count(c)) {
      count++;
    }
  }
  if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {
    count++;
  }
  return count;
}","}
int main() {
    auto candidate = vowels_count;
    assert(candidate((""abcde"")) == (2));
    assert(candidate((""Alone"")) == (3));
    assert(candidate((""key"")) == (2));
    assert(candidate((""bye"")) == (1));
    assert(candidate((""keY"")) == (2));
    assert(candidate((""bYe"")) == (1));
    assert(candidate((""ACEDY"")) == (3));
}
"
HumanEval/65,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የጠቅላላ ቁጥር x አሃዞችን በክብ ይዛወሩ፣ አሃዞቹን ወደ ቀኝ በማዛወር እና ውጤቱን እንደ ሰንሰለት ይመልሱ. shift > አሃዞች ቁጥር ከሆነ አሃዞችን በተቃራኒው ይመልሱ. >>> circular_shift (((12), (1)) (""21"") >>> circular_shift (((12), (2)) (""12"")
std::string circular_shift(long x, long shift) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string circular_shift(long x, long shift) {
  std::string s = std::to_string(x);
  long n = s.length();
  if (n == 0) {
    return """";
  }
  shift %= n;
  if (shift < 0) {
    shift += n;
  }
  if (shift == 0) {
    return s;
  }
  if (shift > n) {
    std::reverse(s.begin(), s.end());
    return s;
  }
  std::string shifted_s = s.substr(n - shift) + s.substr(0, n - shift);
  return shifted_s;
}","}
int main() {
    auto candidate = circular_shift;
    assert(candidate((100), (2)) == (""001""));
    assert(candidate((12), (2)) == (""12""));
    assert(candidate((97), (8)) == (""79""));
    assert(candidate((12), (1)) == (""21""));
    assert(candidate((11), (101)) == (""11""));
}
"
HumanEval/66,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ተግባር አንድን ሕብረቁምፊ እንደ ግብዓት የሚወስድ እና የላይኛዎቹን ቁምፊዎች ድምር ብቻ የሚመልስ ተግባር ይጻፉ' ASCII ኮዶች ምሳሌዎች: >>> digitSum ((("""")) (0) >>> digitSum (((""abAB"")) (131) >>> digitSum (((""abcCd"")) (67) >>> digitSum (((""helloE"")) (69) >>> digitSum (((""woArBld"")) (131) >>> digitSum (((""aAXaaaa"")) (153)
long digitSum(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long digitSum(std::string s) {
  long sum = 0;
  for (char c : s) {
    if (isupper(c)) {
      sum += static_cast<long>(c);
    }
  }
  return sum;
}","}
int main() {
    auto candidate = digitSum;
    assert(candidate(("""")) == (0));
    assert(candidate((""abAB"")) == (131));
    assert(candidate((""abcCd"")) == (67));
    assert(candidate((""helloE"")) == (69));
    assert(candidate((""woArBld"")) == (131));
    assert(candidate((""aAaaaXa"")) == (153));
    assert(candidate(("" How are yOu?"")) == (151));
    assert(candidate((""You arE Very Smart"")) == (327));
}
"
HumanEval/67,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በዚህ ተግባር ውስጥ, እናንተ አንድ ፍሬ ቅርጫት ውስጥ የሚሰራጭ መሆኑን ፖም እና ብርቱካናማዎች ቁጥር የሚወክል አንድ ሕብረቁምፊ ይሰጣል ይህ ቅርጫት ፖም, ብርቱካናማዎች, እና ማንጎ ፍሬዎች ይዟል. የ ፖም እና ፖም ጠቅላላ ቁጥር የሚወክል ሕብረቁምፊ እና ቅርጫት ውስጥ ፍሬዎች ጠቅላላ ቁጥር የሚወክል አንድ ኢንቲጀር የተሰጠው ቅርጫት ውስጥ ማንጎ ፍሬዎች ቁጥር መመለስ. ለምሳሌ ያህል: >>> fruit_distribution ((((("" 5 ፖም እና 6 ብርቱካናማዎች""), (19)) (8) >>> fruit_distribution (((((""0 ፖም እና 1 ብርቱካናማዎች""), (3)) (2) >>> fruit_distribution (((((""2 ፖም እና 3 ብርቱካናማዎች""), (100)) (95) >>> fruit_distribution (((""100 ፖም እና 1 ብርቱካናማዎች""), (120)) (19)
long fruit_distribution(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long fruit_distribution(std::string s, long n) {
  long apples = 0;
  long oranges = 0;
  size_t apples_pos = s.find(""apples"");
  if (apples_pos != std::string::npos) {
    size_t start = 0;
    while (!isdigit(s[start])) {
      start++;
    }
    apples = std::stoll(s.substr(start, apples_pos - start));
  }
  size_t oranges_pos = s.find(""oranges"");
  if (oranges_pos != std::string::npos) {
    size_t and_pos = s.find(""and"");
    size_t start = and_pos + 3;
    while (!isdigit(s[start])) {
      start++;
    }
    oranges = std::stoll(s.substr(start, oranges_pos - start));
  }
  return n - apples - oranges;
}","}
int main() {
    auto candidate = fruit_distribution;
    assert(candidate((""5 apples and 6 oranges""), (19)) == (8));
    assert(candidate((""5 apples and 6 oranges""), (21)) == (10));
    assert(candidate((""0 apples and 1 oranges""), (3)) == (2));
    assert(candidate((""1 apples and 0 oranges""), (3)) == (2));
    assert(candidate((""2 apples and 3 oranges""), (100)) == (95));
    assert(candidate((""2 apples and 3 oranges""), (5)) == (0));
    assert(candidate((""1 apples and 100 oranges""), (120)) == (19));
}
"
HumanEval/68,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ""አንድ ቬክተር የተሰጠው አንድ ቅርንጫፍ የሚወክል ዛፍ ያልሆኑ አሉታዊ ኢንቲጀር ኖዶች ያለው የእርስዎ ተግባር ነው አንድ ኖዶች ለመቅረፍ እና መመለስ ነው. የተወሰደውን ኖድ መሆን አለበት ጋር ያለው ኖድ ትንሹ እንኳ ዋጋ. በርካታ ኖዶች ጋር ተመሳሳይ ትንሹ እንኳ ዋጋ ከተገኙ መመለስ ጋር ያለው ኖድ ትንሹም ማውጫ. የተወሰደውን ኖድ አንድ ቬክተር ውስጥ መመለስ አለበት, [smallest_value, በውስጡ ማውጫ ], ምንም እንኳ ዋጋዎች አሉ ወይም የተሰጠው ቬክተር ባዶ ነው, መመለስ []. ምሳሌ 1: >>> pluck((stdvector<<(long>{(long) 4, (long) 2, (long) 3}))) (stdvector::<(long>{(long} 2, (long) 1})) ማብራሪያ: 2 ትንሹ ዋጋ አለው, እንዲያውም 2 ትንሹ እንኳ አለው. ምሳሌ 2: >>> pluck (dvector::<(stdvector::<(long>1, (long) 2::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
std::vector<long> pluck(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> pluck(std::vector<long> arr) {
  if (arr.empty()) {
    return {};
  }
  long min_even = -1;
  long min_index = -1;
  for (long i = 0; i < arr.size(); ++i) {
    if (arr[i] % 2 == 0) {
      if (min_even == -1 || arr[i] < min_even) {
        min_even = arr[i];
        min_index = i;
      }
    }
  }
  if (min_even == -1) {
    return {};
  }
  return {min_even, min_index};
}","}
int main() {
    auto candidate = pluck;
    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0, (long)1})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4, (long)8}))) == (std::vector<long>({(long)4, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1}))) == (std::vector<long>()));
}
"
HumanEval/69,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አዎንታዊ የሆኑ ሙሉ ቁጥሮች ያሉት ባዶ ያልሆነ ቬክተር ተሰጥቶሃል:: ከዜሮ የሚበልጠውን ትልቁን ሙሉ ቁጥር ይመልሱ፣ እና ከጠቅላላው ቁጥር እሴት ጋር እኩል ወይም የሚበልጥ ድግግሞሽ አለው:: የሙሉ ቁጥር ድግግሞሽ በቬክተሩ ውስጥ የሚታይበት ጊዜ ብዛት ነው:: እንደዚህ አይነት እሴት ከሌለ -1. ምሳሌዎች: >>> ፍለጋ: (((std::vector<long>{(long) 4, (long) 1, (long) 2, (long) 3, (long) 1}))) (2) >>> ፍለጋ: (((std::vector<(long>1, (long) 2, (long) 2, (long) 3, (long) 3, (long) 3, (long) 4, (long) 4, (long) 4} (3)))) >>> ፍለጋ: (((std::vector<(long>{(long) 5, (long) 5, (long) 4, (long) 4, (long) 4}-1))
long search(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long search(std::vector<long> lst) {
  std::map<long, long> counts;
  for (long x : lst) {
    counts[x]++;
  }
  long result = -1;
  for (auto const& [value, count] : counts) {
    if (value > 0 && count >= value) {
      result = std::max(result, value);
    }
  }
  return result;
}","}
int main() {
    auto candidate = search;
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)3, (long)3}))) == (-1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)3, (long)2, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)2, (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6, (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4, (long)10, (long)8, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)8, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)6, (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3, (long)10}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8, (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10, (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)9, (long)10, (long)1, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)6, (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5, (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5, (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10, (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8, (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1, (long)1, (long)5}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9, (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10, (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3}))) == (1));
    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4, (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7, (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1, (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4}))) == (4));
    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4, (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6, (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2, (long)10, (long)7}))) == (4));
    assert(candidate((std::vector<long>({(long)9, (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8, (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3, (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10, (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8}))) == (-1));
    assert(candidate((std::vector<long>({(long)10}))) == (-1));
    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2, (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2}))) == (2));
    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10, (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8}))) == (1));
    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9, (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1, (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7, (long)6}))) == (1));
    assert(candidate((std::vector<long>({(long)3, (long)10, (long)10, (long)9, (long)2}))) == (-1));
}
"
HumanEval/70,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠን የቁጥር ቬክተር፣ ቬክተሩን በድንቅ ቅደም ተከተል ይመልሰዋል። ያልተለመደ ማደራጀት፣ የሚጀምረው ከዝቅተኛው ዋጋ፣ ከዚያም ከቀሪዎቹ የቁጥር ቬክተሮች ከፍተኛው፣ ከዚያም ዝቅተኛው እና የመሳሰሉት ናቸው። ምሳሌዎች: >>> strange_sort_list{(((std::vector<long>(({long) 1, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 4, (long) 2, (long) 3})) >>> strange_sort_list<((std::vector<long>{(long) 5, (long) 5, (long) 5}))) (std::vector<(long>{(long) 5, (long) 5, (long) 5, (long) 5}))) >>> strange_sort_list<((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> strange_sort_list(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> strange_sort_list(std::vector<long> lst) {
  if (lst.empty()) {
    return {};
  }
  std::sort(lst.begin(), lst.end());
  std::vector<long> result;
  long left = 0;
  long right = lst.size() - 1;
  bool take_min = true;
  while (left <= right) {
    if (take_min) {
      result.push_back(lst[left++]);
    } else {
      result.push_back(lst[right--]);
    }
    take_min = !take_min;
  }
  return result;
}","}
int main() {
    auto candidate = strange_sort_list;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)4, (long)2, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9}))) == (std::vector<long>({(long)5, (long)9, (long)6, (long)8, (long)7})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (std::vector<long>({(long)1, (long)5, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>({(long)5, (long)6, (long)7, (long)8, (long)9, (long)1}))) == (std::vector<long>({(long)1, (long)9, (long)5, (long)8, (long)6, (long)7})));
    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5}))) == (std::vector<long>({(long)5, (long)5, (long)5, (long)5})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8}))) == (std::vector<long>({(long)1, (long)8, (long)2, (long)7, (long)3, (long)6, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)0, (long)2, (long)2, (long)2, (long)5, (long)5, (long)-5, (long)-5}))) == (std::vector<long>({(long)-5, (long)5, (long)-5, (long)5, (long)0, (long)2, (long)2, (long)2})));
    assert(candidate((std::vector<long>({(long)111111}))) == (std::vector<long>({(long)111111})));
}
"
HumanEval/71,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የሶስቱ ጎኖች ርዝመት ሲሰጥ የሶስቱ ጎኖች ርዝመት ይሰጣል የሶስቱ ጎኖች ርዝመት ከሆነ የሶስቱ ጎኖች ርዝመት ወደ 2 አሃዝ ይደርሳል ካልሆነ ግን -1 ይደርሳል የሶስቱ ጎኖች ርዝመት ከሶስተኛው ጎን ይበልጣል ምሳሌ: >>> triangle_area((3), (4), (5)) (6.0f) >>> triangle_area((1), (2), (10)) (float-1())
float triangle_area(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>
float triangle_area(long a, long b, long c) {
  if (a + b <= c || a + c <= b || b + c <= a) {
    return -1.0f;
  }
  double s = static_cast<double>(a + b + c) / 2.0;
  double area = std::sqrt(s * (s - a) * (s - b) * (s - c));
  std::stringstream ss;
  ss << std::fixed << std::setprecision(2) << area;
  return std::stof(ss.str());
}","}
int main() {
    auto candidate = triangle_area;
    assert(candidate((3), (4), (5)) == (6.0f));
    assert(candidate((1), (2), (10)) == (float(-1)));
    assert(candidate((4), (8), (5)) == (8.18f));
    assert(candidate((2), (2), (2)) == (1.73f));
    assert(candidate((1), (2), (3)) == (float(-1)));
    assert(candidate((10), (5), (7)) == (16.25f));
    assert(candidate((2), (6), (3)) == (float(-1)));
    assert(candidate((1), (1), (1)) == (0.43f));
    assert(candidate((2), (2), (10)) == (float(-1)));
}
"
HumanEval/72,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁጥር q የሚበር ከሆነ እውነት የሆነ ነገር ይመልሳል፣ ካልሆነ ግን ሐሰት የሆነ ነገር ይጻፍ። የቁጥር q ሚዛናዊ ከሆነ (ፓሊንድሮም ቬክተር ነው) እና የቁጥሮች ድምር ከከፍተኛው ክብደት በታች ወይም እኩል ከሆነ ይበርራል ምሳሌ: >>> will_it_fly((std::vector<long>({long) 1, (long) 2}) ፣ (5)) (false) # 1+2 ከከፍተኛው ክብደት በታች ነው፣ ግን ሚዛናዊ አይደለም። >>> will_it_fly(((std::vector<long>((long) 3, (long) 2, (long) 3}) ፣ (1)) (false) # ሚዛናዊ ነው፣ ግን 3+2+3 ከከፍተኛው ክብደት በላይ ነው። >>> will_it_fly(std::vector<long>{(long>(3, (long) 2, (long) 3}) ፣ (9) (true) # 3+2::vector<long>3፣ እና (5) (true) ከከፍተኛው ክብደት በታች ነው፣ ግን ከከፍተኛው ክብደት በታች ነው።
bool will_it_fly(std::vector<long> q, long w) {
","#include<assert.h>
#include<bits/stdc++.h>
bool will_it_fly(std::vector<long> q, long w) {
  std::vector<long> reversed_q = q;
  std::reverse(reversed_q.begin(), reversed_q.end());
  if (q != reversed_q) {
    return false;
  }
  long sum = 0;
  for (long val : q) {
    sum += val;
  }
  return sum <= w;
}","}
int main() {
    auto candidate = will_it_fly;
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));
    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (6)) == (false));
    assert(candidate((std::vector<long>({(long)5})), (5)) == (true));
}
"
HumanEval/73,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በቁጥር የተሰየመ የቬክተር ቁጥር፣ የቬክተሩን ፓሊንድሮም ለማድረግ የሚያስፈልጉትን አነስተኛ ቁጥር መለዋወጫዎች ያግኙ። ፓሊንድሮም ቬክተር አንድ ቬክተር ነው፣ እሱም ወደ ኋላ እና ወደ ፊት ተመሳሳይ ነው የሚነበበው። በአንድ ለውጥ ውስጥ አንድን ንጥረ ነገር ወደ ሌላ ማንኛውም ንጥረ ነገር መለወጥ ይችላሉ። ለምሳሌ: >>> smallest_change(std::vector<long>({long) 1, (long) 2, (long) 3, (long) 5, (long) 4, (long) 7, (long) 9, (long) 6}))) (4) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1} (1) >>> smallest_change(std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 2, (long) 1} (1) >>> smallest_change
long smallest_change(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long smallest_change(std::vector<long> arr) {
  long n = arr.size();
  long changes = 0;
  for (long i = 0; i < n / 2; ++i) {
    if (arr[i] != arr[n - 1 - i]) {
      changes++;
    }
  }
  return changes;
}","}
int main() {
    auto candidate = smallest_change;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6}))) == (4));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)4, (long)2}))) == (1));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)3, (long)1, (long)1, (long)3}))) == (0));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
}
"
HumanEval/74,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት የቁምፊዎች ቬክተሮችን የሚቀበል እና ከሌላው ቬክተር በታች በጠቅላላው የቁምፊዎች ብዛት ያለው ቬክተርን የሚመልስ ተግባር ይጻፉ። ሁለቱ ቬክተሮች ተመሳሳይ ቁጥር ካላቸው የመጀመሪያውን ቬክተር ይመልሱ ። ምሳሌዎች >>> total_match (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክክለኛውን ቁጥር) ፣ (ትክክለኛውን ቁጥር) ፣ (ትክክለኛውን ቁጥር) ፣ (ትክክለኛውን ቁጥር) ፣ (ትክክለኛውን ቁጥር) ፣ (ትክክለኛውን ቁጥር) ፣ (ትክክለኛውን ቁጥር) ፣ (ትክክክለኛውን ቁጥር) ፣ (ትክክክለኛውን ቁጥር) ፣ (ትክክክለኛውን ቁጥር) ፣ (ትክለኛውን ቁጥር) ፣ (ትክቡር ቁጥር) ፣ (ትክቡር ቁጥር) ፣ (ትክቡር ቁጥር (ትክቡር ቁጥር) ፣ (ትክቡር ቁጥር (ትክቡር ቁጥር) ፣ (ትክቡር ቁጥር (ትክቡር ቁጥር) ፣ (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ) (ጥ (ጥ) (ጥ (ጥ) (ጥ) (ጥ) (ጥ) (ጥ (ጥ) (ጥ (ጥ (ጥ) (ጥ) (ጥ) (ጥ) (ጥ (ጥ (ጥ) (ጥ (ጥ) (ጥ) (ጥ (ጥ (ጥ) (ጥ) (ጥ (ጥ)
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {
  long count1 = 0;
  for (const std::string& s : lst1) {
    count1 += s.length();
  }
  long count2 = 0;
  for (const std::string& s : lst2) {
    count2 += s.length();
  }
  if (count1 <= count2) {
    return lst1;
  } else {
    return lst2;
  }
}","}
int main() {
    auto candidate = total_match;
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hi"", (std::string)""hi"", (std::string)""admin"", (std::string)""project""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>({(std::string)""4""})), (std::vector<std::string>({(std::string)""1"", (std::string)""2"", (std::string)""3"", (std::string)""4"", (std::string)""5""}))) == (std::vector<std::string>({(std::string)""4""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""Hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""}))) == (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hi""})));
    assert(candidate((std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})), (std::vector<std::string>({(std::string)""hI"", (std::string)""hi"", (std::string)""hii""}))) == (std::vector<std::string>({(std::string)""hi"", (std::string)""admin""})));
    assert(candidate((std::vector<std::string>()), (std::vector<std::string>({(std::string)""this""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""this""})), (std::vector<std::string>())) == (std::vector<std::string>()));
}
"
HumanEval/75,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠው ቁጥር የ 3 ዋና ቁጥሮች ማባዛት ከሆነ እውነት የሆነ እና በሌላ መንገድ ሐሰት የሆነ ተግባር ይጻፉ። (ሀ) ከ 100 ያነሰ መሆኑን ማወቅ ምሳሌ: >>> is_multiply_prime((30)) (እውነት) 30 = 2 * 3 * 5
bool is_multiply_prime(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_multiply_prime(long a) {
  if (a <= 0) {
    return false;
  }
  std::vector<int> primes;
  std::vector<bool> is_prime(100, true);
  is_prime[0] = is_prime[1] = false;
  for (int p = 2; p * p < 100; p++) {
    if (is_prime[p]) {
      for (int i = p * p; i < 100; i += p)
        is_prime[i] = false;
    }
  }
  for (int p = 2; p < 100; p++) {
    if (is_prime[p]) {
      primes.push_back(p);
    }
  }
  int count = 0;
  for (int p1 : primes) {
    if (a % p1 == 0) {
      count++;
      int rem = a / p1;
      for (int p2 : primes) {
        if (rem % p2 == 0) {
          count++;
          int rem2 = rem / p2;
          for (int p3 : primes) {
            if (rem2 == p3) {
              count++;
              if (count == 3) {
                return true;
              }
              count--;
            }
          }
          count--;
        }
      }
      count--;
    }
  }
  return false;
}","}
int main() {
    auto candidate = is_multiply_prime;
    assert(candidate((5)) == (false));
    assert(candidate((30)) == (true));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (false));
    assert(candidate((125)) == (true));
    assert(candidate((105)) == (true));
    assert(candidate((126)) == (false));
    assert(candidate((729)) == (false));
    assert(candidate((891)) == (false));
    assert(candidate((1001)) == (true));
}
"
HumanEval/76,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የእርስዎ ተግባር ቁጥር x የ n ቀላል ኃይል ከሆነ እውነት እና በሌሎች ሁኔታዎች ውስጥ ሐሰት የሚመለስ ተግባር መጻፍ ነው. x n ቀላል ኃይል ነው n **int = x ለምሳሌ: >>> is_simple_power (((1) ፣ (4)) (እውነት) >>> is_simple_power (((2), (2)) (እውነት) >>> is_simple_power (((8), (2)) (እውነት) >>> is_simple_power (((3), (2)) (ሐሰት) >>> is_simple_power (((3), (1)) (ሐሰት) >>> is_simple_power (((5), (3)) (ሐሰት)
bool is_simple_power(long x, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_simple_power(long x, long n) {
  if (x == n) return true;
  if (n == 1) return x == 1;
  if (n == 0) return x == 0;
  if (x == 0) return false;
  if (x == 1) return true;
  long power = n;
  while (power < x) {
    if (x % n != 0) return false;
    if (power > x / n) return false;
    power *= n;
  }
  return power == x;
}","}
int main() {
    auto candidate = is_simple_power;
    assert(candidate((16), (2)) == (true));
    assert(candidate((143214), (16)) == (false));
    assert(candidate((4), (2)) == (true));
    assert(candidate((9), (3)) == (true));
    assert(candidate((16), (4)) == (true));
    assert(candidate((24), (2)) == (false));
    assert(candidate((128), (4)) == (false));
    assert(candidate((12), (6)) == (false));
    assert(candidate((1), (1)) == (true));
    assert(candidate((1), (12)) == (true));
}
"
HumanEval/77,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ሙሉ ቁጥር ሀን የሚወስድ እና ይህ ingeger የአንድ ሙሉ ቁጥር ኩብ ከሆነ እውነት የሚመልስ ተግባር ይጻፉ። ማስታወሻ: ግብዓት ሁልጊዜ ትክክለኛ ነው ብለው ሊገምቱ ይችላሉ:: ምሳሌዎች: >>> iscube (((1)) (እውነት) >>> iscube (((2)) (ሐሰት) >>> iscube ((-1)) (እውነት) >>> iscube (((64)) (እውነት) >>> iscube (((0)) (እውነት) >>> iscube (((180)) (ሐሰት)
bool iscube(long a) {
","#include<assert.h>
#include<bits/stdc++.h>
bool iscube(long a) {
  if (a == 0) return true;
  long abs_a = std::abs(a);
  long root = round(std::cbrt(abs_a));
  return root * root * root == abs_a;
}","}
int main() {
    auto candidate = iscube;
    assert(candidate((1)) == (true));
    assert(candidate((2)) == (false));
    assert(candidate((-1)) == (true));
    assert(candidate((64)) == (true));
    assert(candidate((180)) == (false));
    assert(candidate((1000)) == (true));
    assert(candidate((0)) == (true));
    assert(candidate((1729)) == (false));
}
"
HumanEval/78,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የሃሳ አስር ቁጥር ቁጥርን እንደ አንድ ሕብረቁምፊ የሚቀበል እና የሃሳ አስር ቁጥር ቁጥሮች ቁጥርን የሚቆጥር ተግባር እንዲጽፉ ተልእኮ ተሰጥቷቸዋል (የዋና ቁጥር ወይም ዋናው ቁጥር ከሁለት ትናንሽ የዋና ቁጥሮች ውጤት ያልሆነ ከ 1 የሚበልጥ የተፈጥሮ ቁጥር ነው) ። የሃሳ አስር ቁጥሮች 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ናቸው ። የዋና ቁጥሮች 2, 3, 5, 7, 11, 13, 17 ናቸው... ስለዚህ የሚከተሉትን አሃዞች ቁጥር መወሰን አለብዎት: 2, 3, 5, 7, B (= አሃዝ 11), D (= አሃዝ 13) ማስታወሻ: ግብዓት ሁል ጊዜ ትክክለኛ ወይም ባዶ ነው ብለው ሊገምቱ ይችላሉ ሕብረቁምፊ ፣ እና ምልክቶች A ፣ B ፣ C ፣ D ፣ E ፣ F ሁል ጊዜ ትልቅ ናቸው ። ምሳሌዎች: >>> hex_((AB ""ቁልፍ"") 1) >>> hex_(((10 "") E77 "") (2) >>> hex_(AB ""ቁልፍ 1) >>> hex_(ABC1"") (4) >>>x_33 "") >>> hex_(ABC1"") >>> (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
long hex_key(std::string num) {
","#include<assert.h>
#include<bits/stdc++.h>
long hex_key(std::string num) {
  long count = 0;
  std::unordered_set<char> prime_hex = {'2', '3', '5', '7', 'B', 'D'};
  for (char c : num) {
    if (prime_hex.count(c)) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = hex_key;
    assert(candidate((""AB"")) == (1));
    assert(candidate((""1077E"")) == (2));
    assert(candidate((""ABED1A33"")) == (4));
    assert(candidate((""2020"")) == (2));
    assert(candidate((""123456789ABCDEF0"")) == (6));
    assert(candidate((""112233445566778899AABBCCDDEEFF00"")) == (12));
}
"
HumanEval/79,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በ አሃዝ መልክ የተሰጠ ቁጥር እና ተግባርዎ ወደ ባይናሪ ቅርጸት መለወጥ ነው. ተግባር እያንዳንዱ ቁምፊ ባይናሪ ቁጥርን የሚወክልበት ሰንሰለት መመለስ አለበት. እያንዳንዱ ቁምፊ በሰንሰለት ውስጥ '0' ወይም '1' ይሆናል. በሰንሰለት መጀመሪያ እና መጨረሻ ላይ ተጨማሪ ሁለት ቁምፊዎች 'db' ይኖራሉ. ተጨማሪ ቁምፊዎች በ ቅርጸት ለመርዳት አሉ. ምሳሌዎች: >>> decimal_to_binary (((15)) (""db1111db"") >>> decimal_to_binary (((32)) (""db100000db"")
std::string decimal_to_binary(long decimal) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string decimal_to_binary(long decimal) {
  if (decimal == 0) {
    return ""db0db"";
  }
  std::string binaryString = """";
  long temp = std::abs(decimal);
  while (temp > 0) {
    binaryString = (temp % 2 == 0 ? ""0"" : ""1"") + binaryString;
    temp /= 2;
  }
  return ""db"" + binaryString + ""db"";
}","}
int main() {
    auto candidate = decimal_to_binary;
    assert(candidate((0)) == (""db0db""));
    assert(candidate((32)) == (""db100000db""));
    assert(candidate((103)) == (""db1100111db""));
    assert(candidate((15)) == (""db1111db""));
}
"
HumanEval/80,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ string hapcpp ነው ወይም አይደለም. አንድ string hapcpp ነው ከሆነ ርዝመት ቢያንስ 3 ነው እና እያንዳንዱ 3 ተከታታይ ፊደላት ለየት ያሉ ናቸው ለምሳሌ: >>> is_happy((""a"")) (ሐሰት) >>> is_happy((""aa"")) (ሐሰት) >>> is_happy((""abcd"")) (እውነት) >>> is_happy((""aabb"")) (ሐሰት) >>> is_happy(""adb"")) (እውነት) >>> is_happy((""xyy"") (ሐሰት)
bool is_happy(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_happy(std::string s) {
  if (s.length() < 3) {
    return false;
  }
  for (size_t i = 0; i <= s.length() - 3; ++i) {
    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_happy;
    assert(candidate((""a"")) == (false));
    assert(candidate((""aa"")) == (false));
    assert(candidate((""abcd"")) == (true));
    assert(candidate((""aabb"")) == (false));
    assert(candidate((""adb"")) == (true));
    assert(candidate((""xyy"")) == (false));
    assert(candidate((""iopaxpoi"")) == (true));
    assert(candidate((""iopaxioi"")) == (false));
}
"
HumanEval/81,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ይህ የሴሚስተር የመጨረሻ ሳምንት ነው እና መምህሩ ተማሪዎች ወደ ደረጃ መስጠት አለበት. መምህሩ ደረጃ ለመስጠት የራሷን ስልተ-ቀመር እያደረገ ነው. ብቸኛው ችግር እሷ እሷ ደረጃ ለመስጠት ተጠቅሟል ኮድ አጥቷል ነው. እሷ አንዳንድ ተማሪዎች ለ GPAs አንድ ቬክተር ሰጥቷል እና የሚከተለውን ሰንጠረዥ በመጠቀም ደብዳቤ ደረጃዎች አንድ ቬክተር ውፅዓት የሚችል ተግባር መጻፍ አለብዎት: GPA  ደብዳቤ ደረጃ 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E ምሳሌ: >>>_grade_equation((std::vector<float>({(float) 4.0f, (float) 3, (float) 1.7, (float) 2, (float) 3.5)))) (std:""vector::std::std::string::std::string::std::std::string::std::std::string::std::std::std::string::std::std::std::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d::d
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> numerical_letter_grade(std::vector<float> grades) {
  std::vector<std::string> letter_grades;
  for (float gpa : grades) {
    if (gpa == 4.0f) {
      letter_grades.push_back(""A+"");
    } else if (gpa > 3.7f) {
      letter_grades.push_back(""A"");
    } else if (gpa > 3.3f) {
      letter_grades.push_back(""A-"");
    } else if (gpa > 3.0f) {
      letter_grades.push_back(""B+"");
    } else if (gpa > 2.7f) {
      letter_grades.push_back(""B"");
    } else if (gpa > 2.3f) {
      letter_grades.push_back(""B-"");
    } else if (gpa > 2.0f) {
      letter_grades.push_back(""C+"");
    } else if (gpa > 1.7f) {
      letter_grades.push_back(""C"");
    } else if (gpa > 1.3f) {
      letter_grades.push_back(""C-"");
    } else if (gpa > 1.0f) {
      letter_grades.push_back(""D+"");
    } else if (gpa > 0.7f) {
      letter_grades.push_back(""D"");
    } else if (gpa > 0.0f) {
      letter_grades.push_back(""D-"");
    } else {
      letter_grades.push_back(""E"");
    }
  }
  return letter_grades;
}","}
int main() {
    auto candidate = numerical_letter_grade;
    assert(candidate((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f}))) == (std::vector<std::string>({(std::string)""A+"", (std::string)""B"", (std::string)""C-"", (std::string)""C"", (std::string)""A-""})));
    assert(candidate((std::vector<float>({(float)1.2f}))) == (std::vector<std::string>({(std::string)""D+""})));
    assert(candidate((std::vector<float>({(float)0.5f}))) == (std::vector<std::string>({(std::string)""D-""})));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (std::vector<std::string>({(std::string)""E""})));
    assert(candidate((std::vector<float>({(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))) == (std::vector<std::string>({(std::string)""D"", (std::string)""D-"", (std::string)""C-"", (std::string)""B"", (std::string)""B+""})));
    assert(candidate((std::vector<float>({(float)0.0f, (float)0.7f}))) == (std::vector<std::string>({(std::string)""E"", (std::string)""D-""})));
}
"
HumanEval/82,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ሕብረቁምፊ የሚወስድ እና ሕብረቁምፊ ርዝመት ዋና ቁጥር ከሆነ እውነት ወይም ሐሰት ካልሆነ በስተቀር ምሳሌዎችን >>> prime_length (((""Hello"")) (እውነት) >>> prime_length (((""abcdcba"")) (እውነት) >>> prime_length (((""kittens"")) (እውነት) >>> prime_length (((""orange"")) (ሐሰት)
bool prime_length(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(int n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

bool prime_length(std::string string) {
  return is_prime(string.length());
}","}
int main() {
    auto candidate = prime_length;
    assert(candidate((""Hello"")) == (true));
    assert(candidate((""abcdcba"")) == (true));
    assert(candidate((""kittens"")) == (true));
    assert(candidate((""orange"")) == (false));
    assert(candidate((""wow"")) == (true));
    assert(candidate((""world"")) == (true));
    assert(candidate((""MadaM"")) == (true));
    assert(candidate((""Wow"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""HI"")) == (true));
    assert(candidate((""go"")) == (true));
    assert(candidate((""gogo"")) == (false));
    assert(candidate((""aaaaaaaaaaaaaaa"")) == (false));
    assert(candidate((""Madam"")) == (true));
    assert(candidate((""M"")) == (false));
    assert(candidate((""0"")) == (false));
}
"
HumanEval/83,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ አዎንታዊ ሙሉ ቁጥር n ሲሰጥ, በ 1 የሚጀምሩ ወይም የሚያበቃ የ n-አሃዝ አዎንታዊ ሙሉ ቁጥሮች ቁጥር ይመልሱ.
long starts_one_ends(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long starts_one_ends(long n) {
  if (n <= 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  long starts_with_one = std::pow(10, n - 1);
  long ends_with_one = std::pow(10, n - 1);
  long starts_and_ends_with_one = std::pow(10, n - 2);
  return starts_with_one + ends_with_one - starts_and_ends_with_one;
}","}
int main() {
    auto candidate = starts_one_ends;
    assert(candidate((1)) == (1));
    assert(candidate((2)) == (18));
    assert(candidate((3)) == (180));
    assert(candidate((4)) == (1800));
    assert(candidate((5)) == (18000));
}
"
HumanEval/84,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠ አዎንታዊ ሙሉ ቁጥር N፣ የቁጥሮች ድምርን በሁለትዮሽ ይመለስ። ምሳሌ >>> solve((1000)) (""1"") >>> solve((150)) (""110"") >>> solve((147)) (""1100"") ተለዋዋጮች: @N ሙሉ ቁጥር ገደቦች: 0 ≤ N ≤ 10000. ውፅዓት: የሁለትዮሽ ቁጥር ሰንሰለት
std::string solve(long N) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string solve(long N) {
  if (N < 0 || N > 10000) {
    return """"; // Or handle invalid input as needed
  }
  long sum = 0;
  std::string s = std::to_string(N);
  for (char c : s) {
    sum += c - '0';
  }
  if (sum == 0) {
    return ""0"";
  }
  std::string binary_sum = """";
  while (sum > 0) {
    binary_sum = (sum % 2 == 0 ? ""0"" : ""1"") + binary_sum;
    sum /= 2;
  }
  return binary_sum;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((1000)) == (""1""));
    assert(candidate((150)) == (""110""));
    assert(candidate((147)) == (""1100""));
    assert(candidate((333)) == (""1001""));
    assert(candidate((963)) == (""10010""));
}
"
HumanEval/85,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሙሉ ቁጥሮች የሌላቸው ቬክተር ከተሰጠ lst. በባዶ መረጃ ጠቋሚዎች ላይ ያሉትን እኩል አካላት ይጨምሩ. ምሳሌዎች: >>> add((std::vector<long>({(long) 4, (long) 2, (long) 6, (long) 7}))) (2)
long add(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long add(std::vector<long> lst) {
  long sum = 0;
  for (long i = 1; i < lst.size(); i += 2) {
    if (lst[i] % 2 == 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add;
    assert(candidate((std::vector<long>({(long)4, (long)88}))) == (88));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)6, (long)7, (long)2, (long)122}))) == (122));
    assert(candidate((std::vector<long>({(long)4, (long)0, (long)6, (long)7}))) == (0));
    assert(candidate((std::vector<long>({(long)4, (long)4, (long)6, (long)8}))) == (12));
}
"
HumanEval/86,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ሕብረቁምፊ የሚወስድ እና የተደረደሩ ስሪት ይመልሳል አንድ ተግባር ይጻፉ. ሕብረቁምፊ የተደረደሩ ስሪት, ሁሉም ቃላት (በቦታ ተለያይቷል) አዲስ ቃል በ ተተክተዋል የት ሁሉ ቁምፊዎች ascii ዋጋ ላይ የተመሠረተ እየጨመረ ቅደም ተከተል ውስጥ የተደረደሩ ናቸው. ማስታወሻ: አንተ ሐረግ ውስጥ ቃላት እና ባዶ ቦታዎች ቅደም ተከተል መጠበቅ አለበት. ለምሳሌ: >>> anti_shuffle (((""Hi"")) (""Hi"") >>> anti_shuffle (((""hello"")) (""ehllo"") >>> anti_shuffle (((""Hello World!!!"")) (""Hello !!!Wdlor"")
std::string anti_shuffle(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string anti_shuffle(std::string s) {
  std::string result = """";
  std::string current_word = """";
  for (char c : s) {
    if (c == ' ') {
      std::sort(current_word.begin(), current_word.end());
      result += current_word;
      result += c;
      current_word = """";
    } else {
      current_word += c;
    }
  }
  std::sort(current_word.begin(), current_word.end());
  result += current_word;
  return result;
}","}
int main() {
    auto candidate = anti_shuffle;
    assert(candidate((""Hi"")) == (""Hi""));
    assert(candidate((""hello"")) == (""ehllo""));
    assert(candidate((""number"")) == (""bemnru""));
    assert(candidate((""abcd"")) == (""abcd""));
    assert(candidate((""Hello World!!!"")) == (""Hello !!!Wdlor""));
    assert(candidate(("""")) == (""""));
    assert(candidate((""Hi. My name is Mister Robot. How are you?"")) == ("".Hi My aemn is Meirst .Rboot How aer ?ouy""));
}
"
HumanEval/87,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// እንደ ማትሪክስ ተመሳሳይ የሆነ የ 2 ልኬት ውሂብ ተሰጥቶዎታል ፣ ግን እንደ ማትሪክስ ሳይሆን ፣ እያንዳንዱ ረድፍ የተለያዩ አምዶችን ሊይዝ ይችላል ። lst እና ኢንቲጀር x ከተሰጠ ፣ በቬክተሩ ውስጥ ኢንቲጀሮችን ያግኙ ፣ እና የ tuples ቬክተር ይመለሱ ፣ [(x1, y1), (x2, y2) ...] እንደዚህ እያንዳንዱ tuple አንድ አስተባባሪ ነው - (row, columns) ፣ ከ 0 ጀምሮ በመነሻነት በረድፎች ውስጥ ያስተባብራል። እንዲሁም ፣ የ ረድፍ አስተባባሪዎች በወረደ ቅደም ተከተል ይደርጁ ምሳሌዎች: >>> get_row(std::vector<std::vector<>>>> (long) {tupleplector}<long) {tuplector}<long) {tuplector}<long) {tuplector}<long) {long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}{long}long}{long}{long}{long}{long}{long}{long}long}{long}{long}{long}{long}{long}{long}{long}{long}long}{long}{long}{long}{long}long}long}long}long}{long}{long}{long}long}long}{long}long}long}{long}{long}long}long}long}long}long}long}long}long}long}long}long {long}long}long}long}long}long}long {long}long}long}long}long}long {long}long}long}long}long}long {long}long}long}long}long}long}long {long}long}long}long}long
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {
  std::vector<std::tuple<long, long>> coordinates;
  for (long i = 0; i < lst.size(); ++i) {
    std::vector<std::pair<long, long>> row_coords;
    for (long j = 0; j < lst[i].size(); ++j) {
      if (lst[i][j] == x) {
        row_coords.push_back({j, i});
      }
    }
    std::sort(row_coords.rbegin(), row_coords.rend());
    for (const auto& coord_pair : row_coords) {
      coordinates.emplace_back(coord_pair.second, coord_pair.first);
    }
  }
  return coordinates;
}","}
int main() {
    auto candidate = get_row;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1, 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3, 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5, 1)})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2, 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3, 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4, 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5, 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6, 0)})));
    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})), (2)) == (std::vector<std::tuple<long, long>>()));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)})));
}
"
HumanEval/88,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከቀድሞው የቁጥር እሴት ጋር በተያያዘ የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት በቁጥር እሴት ላይ ተስተካክሏል, የቁጥር እሴት ተካቷል, የቁጥር እሴት ተካቷል, የቁጥር እሴት ተካቷል, የቁጥር ተካቷል, የቁጥር ተካቷል, የቁጥር ተካቷል, የቁጥር ተካቷል, የቁጥር ተካቷል, የቁጥር ተካቷል, የቁጥር ተካቷል, ተካቷል, ተካቷል, ተካቷል ተካቷል ተካቷል, ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተካቷል ተ
std::vector<long> sort_array(std::vector<long> array) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> sort_array(std::vector<long> array) {
  std::vector<long> sorted_array = array;
  if (sorted_array.empty()) {
    return sorted_array;
  }
  long first = 0;
  long last = sorted_array.size() - 1;
  if ((first + last) % 2 != 0) {
    std::sort(sorted_array.begin(), sorted_array.end());
  } else {
    std::sort(sorted_array.rbegin(), sorted_array.rend());
  }
  return sorted_array;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)5}))) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6}))) == (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0})));
    assert(candidate((std::vector<long>({(long)2, (long)1}))) == (std::vector<long>({(long)1, (long)2})));
    assert(candidate((std::vector<long>({(long)15, (long)42, (long)87, (long)32, (long)11, (long)0}))) == (std::vector<long>({(long)0, (long)11, (long)15, (long)32, (long)42, (long)87})));
    assert(candidate((std::vector<long>({(long)21, (long)14, (long)23, (long)11}))) == (std::vector<long>({(long)23, (long)21, (long)14, (long)11})));
}
"
HumanEval/89,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድን ሕብረቁምፊ እንደ አንድ ክርክር የሚወስድ እና ፊደል እየተሽከረከረ የተመሰጠረ ሕብረቁምፊ የሚመልስ አንድ ተግባር ኢንክሪፕት ይፍጠሩ. ፊደሉ ፊደሎቹ በሁለት ተደጋግመው ወደ ሁለት ቦታዎች በሚዘዋወሩበት መንገድ መዞር አለባቸው. ለምሳሌ: >>> ኢንክሪፕት (((""ሂ"")) (""lm"") >>> ኢንክሪፕት (((""asdfghjkl"")) (""ewhjklnop"") >>> ኢንክሪፕት (((""gf"")) (""kj"") >>> ኢንክሪፕት (((""et"")) (""ix"")
std::string encrypt(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encrypt(std::string s) {
  std::string encrypted_s = """";
  int shift = 2 * 2;
  for (char c : s) {
    if (isalpha(c)) {
      char base = islower(c) ? 'a' : 'A';
      encrypted_s += static_cast<char>((c - base + shift) % 26 + base);
    } else {
      encrypted_s += c;
    }
  }
  return encrypted_s;
}","}
int main() {
    auto candidate = encrypt;
    assert(candidate((""hi"")) == (""lm""));
    assert(candidate((""asdfghjkl"")) == (""ewhjklnop""));
    assert(candidate((""gf"")) == (""kj""));
    assert(candidate((""et"")) == (""ix""));
    assert(candidate((""faewfawefaewg"")) == (""jeiajeaijeiak""));
    assert(candidate((""hellomyfriend"")) == (""lippsqcjvmirh""));
    assert(candidate((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")) == (""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl""));
    assert(candidate((""a"")) == (""e""));
}
"
HumanEval/90,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁጥር ቬክተር ተሰጥቶሃል:: የ ቬክተር 2 ኛውን አነስተኛ ክፍል የሚመልስ next_smallest () ተግባር ጻፍ:: እንደዚህ አይነት አካል ከሌለ None ይመልሱ:: >>> next_smallest () std::vector<long>{long) 1, (long) 2, (long) 3, (long) 4, (long) 5}))) 2 >>> next_smallest () std::vector<long>{long) 5, (long) 1, (long) 4, (long) 3, (long) 2))) >>> 2 next_smallest () std::vector<long>(long))) std::nullopt >>> next_smallest () std::vector<long>{long) 1, (long) 1))) std::nullopt
std::optional<long> next_smallest(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> next_smallest(std::vector<long> lst) {
  if (lst.size() < 2) {
    return std::nullopt;
  }
  std::sort(lst.begin(), lst.end());
  if (lst[0] == lst[1]) {
    return std::nullopt;
  }
  return lst[1];
}","}
int main() {
    auto candidate = next_smallest;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == 2);
    assert(candidate((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2}))) == 2);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)0}))) == 1);
    assert(candidate((std::vector<long>({(long)1, (long)1}))) == std::nullopt);
    assert(candidate((std::vector<long>({(long)-35, (long)34, (long)12, (long)-45}))) == -35);
}
"
HumanEval/91,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቃላት ሰንሰለት ይሰጥዎታል፣ እና ስራዎ የ አሰልቺዎችን ቁጥር መቁጠር ነው። አሰልቺነት በ ""I"" ቃል የሚጀምር ዓረፍተ ነገር ነው። ዓረፍተ ነገሮች በ ‹› ፣ ‹› ወይም ‹!› የተገደቡ ናቸው። ለምሳሌ: >>> is_bored((""Hello world"")) (0) >>> is_bored((""ሰማዩ ሰማያዊ ነው። ፀሐይ ታበራለች ። ይህንን የአየር ሁኔታ እወዳለሁ"")) (1)
long is_bored(std::string S) {
","#include<assert.h>
#include<bits/stdc++.h>
long is_bored(std::string S) {
  long boredom_count = 0;
  std::string current_sentence = """";
  for (char c : S) {
    current_sentence += c;
    if (c == '.' || c == '?' || c == '!') {
      std::stringstream ss(current_sentence);
      std::string first_word;
      ss >> first_word;
      if (first_word == ""I"") {
        boredom_count++;
      }
      current_sentence = """";
    }
  }
  return boredom_count;
}","}
int main() {
    auto candidate = is_bored;
    assert(candidate((""Hello world"")) == (0));
    assert(candidate((""Is the sky blue?"")) == (0));
    assert(candidate((""I love It !"")) == (1));
    assert(candidate((""bIt"")) == (0));
    assert(candidate((""I feel good today. I will be productive. will kill It"")) == (2));
    assert(candidate((""You and I are going for a walk"")) == (0));
}
"
HumanEval/92,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// 3 ቁጥሮች የሚይዝ ተግባር ይፍጠሩ:: ከቁጥሮች አንዱ ከሌሎቹ ሁለት ድምር ጋር እኩል ከሆነ እውነት ይመልሳል፣ እና ሁሉም ቁጥሮች ኢንቲጀሮች ናቸው:: በሌሎች ሁኔታዎች ሁሉ ሐሰት ይመልሳል:: ምሳሌዎች >>> any_int (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float)) (false) >>> any_int (float) (float) (float) (float) (float) (float) (float) (float)) (false) >>> any_int (float) (float)) (float) (float) (float) (float) (float) (float) (float)) (float) (float) (float) (float)) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float) (float (float) (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float) (float (float) (float (float) (float) (float) (float (float) (float) (float (flo) (float) (flo) (flo) (flo) (float (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo) (flo)
bool any_int(float x, float y, float z) {
","#include<assert.h>
#include<bits/stdc++.h>
bool any_int(float x, float y, float z) {
  if (std::floor(x) != x || std::floor(y) != y || std::floor(z) != z) {
    return false;
  }
  long ix = static_cast<long>(x);
  long iy = static_cast<long>(y);
  long iz = static_cast<long>(z);
  return (ix == iy + iz) || (iy == ix + iz) || (iz == ix + iy);
}","}
int main() {
    auto candidate = any_int;
    assert(candidate((float(2)), (float(3)), (float(1))) == (true));
    assert(candidate((2.5f), (float(2)), (float(3))) == (false));
    assert(candidate((1.5f), (float(5)), (3.5f)) == (false));
    assert(candidate((float(2)), (float(6)), (float(2))) == (false));
    assert(candidate((float(4)), (float(2)), (float(2))) == (true));
    assert(candidate((2.2f), (2.2f), (2.2f)) == (false));
    assert(candidate((float(-4)), (float(6)), (float(2))) == (true));
    assert(candidate((float(2)), (float(1)), (float(1))) == (true));
    assert(candidate((float(3)), (float(4)), (float(7))) == (true));
    assert(candidate((3.0f), (float(4)), (float(7))) == (false));
}
"
HumanEval/93,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// መልዕክት የሚወስድ እና ሁሉንም ፊደላት ካሴስ በሚለውጥ መንገድ የሚሸፍን ተግባር ይጻፉ ፣ በመልዕክቱ ውስጥ ያሉትን ሁሉንም አናባቢዎች በእንግሊዝኛ ፊደል ውስጥ ከዚያ አናባቢ 2 ቦታዎችን በሚታይ ፊደል ይተካሉ ። ፊደላትን ብቻ ይያዙ ። ምሳሌዎች: >>> encode((""test"")) (""TGST"") >>> encode((""ይህ መልእክት ነው"")) (""tHKS KS C MGSSCGG"")
std::string encode(std::string message) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string encode(std::string message) {
  std::string encoded_message = """";
  std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
  std::map<char, char> vowel_map = {
      {'a', 'c'}, {'e', 'g'}, {'i', 'k'}, {'o', 'q'}, {'u', 'w'},
      {'A', 'C'}, {'E', 'G'}, {'I', 'K'}, {'O', 'Q'}, {'U', 'W'}};
  for (char c : message) {
    if (isalpha(c)) {
      char swapped_case = islower(c) ? toupper(c) : tolower(c);
      if (vowels.count(c)) {
        encoded_message += vowel_map[c];
      } else {
        encoded_message += swapped_case;
      }
    } else {
      encoded_message += c;
    }
  }
  return encoded_message;
}","}
int main() {
    auto candidate = encode;
    assert(candidate((""TEST"")) == (""tgst""));
    assert(candidate((""Mudasir"")) == (""mWDCSKR""));
    assert(candidate((""YES"")) == (""ygs""));
    assert(candidate((""This is a message"")) == (""tHKS KS C MGSSCGG""));
    assert(candidate((""I DoNt KnOw WhAt tO WrItE"")) == (""k dQnT kNqW wHcT Tq wRkTg""));
}
"
HumanEval/94,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንተ ሙሉ ቁጥሮች አንድ ቬክተር ተሰጥቶሃል. አንተ ትልቁን ዋና ዋጋ ማግኘት እና አሃዞች ድምር መመለስ አለብዎት. ምሳሌዎች: >>> skjkasdkd((std::vector<long>((long) 0, (long) 3, (long) 2, (long) 1, (long) 3, (long) 5, (long) 7, (long) 4, (long) 5, (long) 2, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) 3, (long) (long) 3, (long) (long) (long) 3, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
long skjkasdkd(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

long sum_digits(long n) {
  long sum = 0;
  std::string s = std::to_string(n);
  for (char c : s) {
    sum += c - '0';
  }
  return sum;
}

long skjkasdkd(std::vector<long> lst) {
  long largest_prime = -1;
  for (long num : lst) {
    if (num > largest_prime && is_prime(num)) {
      largest_prime = num;
    }
  }
  if (largest_prime == -1) {
    return 0;
  }
  return sum_digits(largest_prime);
}","}
int main() {
    auto candidate = skjkasdkd;
    assert(candidate((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3}))) == (10));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1}))) == (25));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3}))) == (13));
    assert(candidate((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6}))) == (11));
    assert(candidate((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21}))) == (3));
    assert(candidate((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)8191}))) == (19));
    assert(candidate((std::vector<long>({(long)8191, (long)123456, (long)127, (long)7}))) == (19));
    assert(candidate((std::vector<long>({(long)127, (long)97, (long)8192}))) == (10));
}
"
HumanEval/95,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ካርታ ከተሰጠ ፣ ሁሉም ቁልፎች በትንሽ ፊደል ወይም ሁሉም ቁልፎች በከፍተኛ ፊደል ውስጥ ያሉ ሕብረቁምፊዎች ከሆኑ እውነት ይመልሱ ፣ ካልሆነ ግን ሐሰት ይመልሱ ። ተግባሩ ሐሰት መመለስ አለበት የተሰጠው ካርታ ባዶ ነው ። ምሳሌዎች: >>> check_dict_case ((((std::map<std::string,std::string>((({{""a"", ""apple""}, {""b"", ""banana""}}))) (እውነት) >>> check_dict_case (((((((std::map,std::string>{{""a"", ""apple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) (ሐሰት) >>> check_dict_case (map) >{{""a"", ""banana""}, {""B"", ""map""}}))) (ሐሰት) >>> check_dict_case (map) >{{""a"", ""apple""}, {""banana""}, {""a"", ""std8"", {""std""apple""}) <<<std::std::std::std::string> (ሐሰት) </std::string>) ""አንድ"" (አንድ""አንድ"", ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ"") ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""፣ ""አንድ""
bool check_dict_case(std::map<std::string,std::string> dict) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_dict_case(std::map<std::string,std::string> dict) {
  if (dict.empty()) {
    return false;
  }
  bool first_key_lower = false;
  bool first_key_upper = false;
  auto it = dict.begin();
  if (!it->first.empty() && islower(it->first[0])) {
    first_key_lower = true;
  } else if (!it->first.empty() && isupper(it->first[0])) {
    first_key_upper = true;
  } else {
    return false;
  }
  for (const auto& pair : dict) {
    if (pair.first.empty()) {
      return false;
    }
    bool current_lower = true;
    bool current_upper = true;
    for (char c : pair.first) {
      if (!islower(c)) {
        current_lower = false;
      }
      if (!isupper(c)) {
        current_upper = false;
      }
    }
    if (first_key_lower && !current_lower) {
      return false;
    }
    if (first_key_upper && !current_upper) {
      return false;
    }
    if (!first_key_lower && !first_key_upper) {
        if (current_lower) first_key_lower = true;
        else if (current_upper) first_key_upper = true;
        else return false;
    }
  }
  return first_key_lower || first_key_upper;
}","}
int main() {
    auto candidate = check_dict_case;
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""b"", ""banana""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))) == (false));
    assert(candidate((std::map<std::string,std::string>({{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>({{""fruit"", ""Orange""}, {""taste"", ""Sweet""}}))) == (true));
    assert(candidate((std::map<std::string,std::string>())) == (false));
}
"
HumanEval/96,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አሉታዊ ያልሆነን ሙሉ ቁጥር የሚወስድ እና ከ n በታች የሆኑ የመጀመሪያዎቹን n ሙሉ ቁጥሮች ቬክተር የሚመልስ ተግባር ተግባራዊ ያድርጉ ለምሳሌ: >>> count_up_to((5)) (std::vector<long>({long) 2, (long) 3})) >>> count_up_to(11)) (std::vector<long>({long) 2, (long) 3, (long) 5, (long) 7})) >>> count_up_to(0)) (std::vector<long>)) >>> count_up_to(20)) (std::vector<long>{(long) 2, (long) 3, (long) 5, (long) 7, (long) 11, (long) 1, (long) 3, (long) 17, (long) 19)) >>> count_up_1) (std::vector<long> >>> count_up_to(18) (std:vector<long>(((3, (long) 11, (long) 5, (long)) (std:vector<long>17) (long)) (long) 1, (long)) (long)) (long) 2, (long)) (long)) (long)
std::vector<long> count_up_to(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long num) {
  if (num <= 1) return false;
  for (long i = 2; i * i <= num; ++i) {
    if (num % i == 0) return false;
  }
  return true;
}

std::vector<long> count_up_to(long n) {
  std::vector<long> primes;
  if (n <= 2) {
    return primes;
  }
  for (long i = 2; i < n; ++i) {
    if (is_prime(i)) {
      primes.push_back(i);
    }
  }
  return primes;
}","}
int main() {
    auto candidate = count_up_to;
    assert(candidate((5)) == (std::vector<long>({(long)2, (long)3})));
    assert(candidate((6)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((7)) == (std::vector<long>({(long)2, (long)3, (long)5})));
    assert(candidate((10)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7})));
    assert(candidate((0)) == (std::vector<long>()));
    assert(candidate((22)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19})));
    assert(candidate((1)) == (std::vector<long>()));
    assert(candidate((18)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((47)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43})));
    assert(candidate((101)) == (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19, (long)23, (long)29, (long)31, (long)37, (long)41, (long)43, (long)47, (long)53, (long)59, (long)61, (long)67, (long)71, (long)73, (long)79, (long)83, (long)89, (long)97})));
}
"
HumanEval/97,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት ሙሉ ቁጥሮች የሚወስዱትን እና የአሃድ አሃዛቸውን ውጤት የሚመልስ ተግባር ይሙሉ። ግብዓት ሁልጊዜ ትክክለኛ ነው ብለን እንወስዳለን:: ምሳሌዎች: >>> ማባዛት (((148), (412)) (16) >>> ማባዛት (((19), (28)) (72) >>> ማባዛት (((2020), (1851)) (0) >>> ማባዛት (((14), (-15)) (20)
long multiply(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>
long multiply(long a, long b) {
  long unit_a = std::abs(a) % 10;
  long unit_b = std::abs(b) % 10;
  return unit_a * unit_b;
}","}
int main() {
    auto candidate = multiply;
    assert(candidate((148), (412)) == (16));
    assert(candidate((19), (28)) == (72));
    assert(candidate((2020), (1851)) == (0));
    assert(candidate((14), (-15)) == (20));
    assert(candidate((76), (67)) == (42));
    assert(candidate((17), (27)) == (49));
    assert(candidate((0), (1)) == (0));
    assert(candidate((0), (0)) == (0));
}
"
HumanEval/98,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ string s ከተሰጠ ፣ በቁጥር ኢንዴክሶች ውስጥ ያሉትን የከፍተኛ ፊደላት ቁጥር ይቁጠሩ ። ለምሳሌ: >>> count_upper (((""aBCdEf"")) (1) >>> count_upper (((""abcdefg"")) (0) >>> count_upper (((""dBBE"")) (0)
long count_upper(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
long count_upper(std::string s) {
  long count = 0;
  std::unordered_set<char> upper_vowels = {'A', 'E', 'I', 'O', 'U'};
  for (long i = 0; i < s.length(); ++i) {
    if (i % 2 == 0 && upper_vowels.count(s[i])) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_upper;
    assert(candidate((""aBCdEf"")) == (1));
    assert(candidate((""abcdefg"")) == (0));
    assert(candidate((""dBBE"")) == (0));
    assert(candidate((""B"")) == (0));
    assert(candidate((""U"")) == (1));
    assert(candidate(("""")) == (0));
    assert(candidate((""EEEE"")) == (2));
}
"
HumanEval/99,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድን ቁጥር የሚወክል ዋጋ (ስትሪንግ) የሚወስድ እና ወደ እሱ በጣም የቀረበውን ኢንቲጀር የሚመልስ ተግባር ይፍጠሩ ። ቁጥሩ ከሁለት ኢንቲጀሮች እኩል ርቀት ላይ ከሆነ ከዜሮ ያጠነጥኑት ። ምሳሌዎች >>> closest_integer (((""10"")) (10) >>> closest_integer (((""15.3"")) ማስታወሻ (15): ከዜሮ ርቆ ማጠነጠቁ ማለት የተሰጠው ቁጥር ከሁለት ኢንቲጀሮች እኩል ርቀት ላይ ከሆነ ፣ እርስዎ መመለስ ያለብዎት ከዜሮ በጣም የራቀ ነው ማለት ነው ። ለምሳሌ closest_integer (((""14.5"") 15 መመለስ አለበት እና closest_integer ((-14.5"") -15. መመለስ አለበት
long closest_integer(std::string value) {
","#include<assert.h>
#include<bits/stdc++.h>
long closest_integer(std::string value) {
  double num = std::stod(value);
  if (num >= 0) {
    if (num - std::floor(num) <= 0.5) {
      return static_cast<long>(std::floor(num));
    } else {
      return static_cast<long>(std::ceil(num));
    }
  } else {
    if (std::ceil(num) - num <= 0.5) {
      return static_cast<long>(std::ceil(num));
    } else {
      return static_cast<long>(std::floor(num));
    }
  }
}","}
int main() {
    auto candidate = closest_integer;
    assert(candidate((""10"")) == (10));
    assert(candidate((""14.5"")) == (15));
    assert(candidate((""-15.5"")) == (-16));
    assert(candidate((""15.3"")) == (15));
    assert(candidate((""0"")) == (0));
}
"
HumanEval/100,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ አዎንታዊ ቁጥር n ከተሰጠ, አንተ ድንጋዮች n ደረጃዎች አንድ ክምር ማድረግ አለብን. የመጀመሪያው ደረጃ n ድንጋዮች አሉት. በሚቀጥለው ደረጃ ውስጥ ድንጋዮች ቁጥር ነው: - n ያልተለመደ ከሆነ ቀጣዩ ባዶ ቁጥር ነው. - n እኩል ከሆነ ቀጣዩ እኩል ቁጥር ነው. አንድ ቬክተር ውስጥ በእያንዳንዱ ደረጃ ውስጥ ድንጋዮች ቁጥር, የት ኢንዴክስ i ላይ ንጥረ ነገር ደረጃ ውስጥ ድንጋዮች ቁጥር ይወክላል (i+1) ምሳሌዎች: >>> make_a_pile(3)) (std::vector<long>{long) 3, (long) 5, (long) 7}))
std::vector<long> make_a_pile(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> make_a_pile(long n) {
  std::vector<long> pile;
  long current_stones = n;
  for (int i = 0; i < n; ++i) {
    pile.push_back(current_stones);
    if (current_stones % 2 != 0) {
      current_stones += 2;
    } else {
      current_stones += 2;
    }
  }
  return pile;
}","}
int main() {
    auto candidate = make_a_pile;
    assert(candidate((3)) == (std::vector<long>({(long)3, (long)5, (long)7})));
    assert(candidate((4)) == (std::vector<long>({(long)4, (long)6, (long)8, (long)10})));
    assert(candidate((5)) == (std::vector<long>({(long)5, (long)7, (long)9, (long)11, (long)13})));
    assert(candidate((6)) == (std::vector<long>({(long)6, (long)8, (long)10, (long)12, (long)14, (long)16})));
    assert(candidate((8)) == (std::vector<long>({(long)8, (long)10, (long)12, (long)14, (long)16, (long)18, (long)20, (long)22})));
}
"
HumanEval/101,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በኮማ ወይም በቦታ የተለዩ የቃላት ሰንሰለት ይሰጥዎታል ። ተልእኮዎ ሰንሰለቱን በቃላት መከፋፈል እና የቃላት ቬክተር መመለስ ነው። ለምሳሌ: >>> words_string (((""Hi, my name is John"")) (std::vector<std::string>({(std::string) ""Hi"", (std::string) ""my"", (std::string) ""name"", (std::string) ""is"", (std::string) ""John""}) >>> words_string (((""One, two, three, four, five, six"")) (std::vector<std::string>({(stdstring) ""One"", (std::string) ""two"", (std::string) ""three"", (std::string) ""four"", (std::string) ""five"", (std::string) ""six""))
std::vector<std::string> words_string(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> words_string(std::string s) {
  std::vector<std::string> words;
  std::string current_word;
  for (char c : s) {
    if (c == ',' || c == ' ') {
      if (!current_word.empty()) {
        words.push_back(current_word);
        current_word = """";
      }
    } else {
      current_word += c;
    }
  }
  if (!current_word.empty()) {
    words.push_back(current_word);
  }
  return words;
}","}
int main() {
    auto candidate = words_string;
    assert(candidate((""Hi, my name is John"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name"", (std::string)""is"", (std::string)""John""})));
    assert(candidate((""One, two, three, four, five, six"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate((""Hi, my name"")) == (std::vector<std::string>({(std::string)""Hi"", (std::string)""my"", (std::string)""name""})));
    assert(candidate((""One,, two, three, four, five, six,"")) == (std::vector<std::string>({(std::string)""One"", (std::string)""two"", (std::string)""three"", (std::string)""four"", (std::string)""five"", (std::string)""six""})));
    assert(candidate(("""")) == (std::vector<std::string>()));
    assert(candidate((""ahmed     , gamal"")) == (std::vector<std::string>({(std::string)""ahmed"", (std::string)""gamal""})));
}
"
HumanEval/102,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ይህ ተግባር ሁለት አዎንታዊ ቁጥሮች x እና y ይወስዳል እና በ [x, y] ክልል ውስጥ ያለውን ትልቁን አጠቃላይ ቁጥር ይመልሳል. እንደዚህ አይነት ቁጥር ከሌለ, ተግባሩ -1. ለምሳሌ: >>> choose_num((12), (15)) (14) >>> choose_num((13), (12)) (-1)
long choose_num(long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>
long choose_num(long x, long y) {
  if (x > y) {
    return -1;
  }
  long end = y;
  if (end % 2 != 0) {
    end--;
  }
  if (end < x) {
    return -1;
  }
  return end;
}","}
int main() {
    auto candidate = choose_num;
    assert(candidate((12), (15)) == (14));
    assert(candidate((13), (12)) == (-1));
    assert(candidate((33), (12354)) == (12354));
    assert(candidate((5234), (5233)) == (-1));
    assert(candidate((6), (29)) == (28));
    assert(candidate((27), (10)) == (-1));
    assert(candidate((7), (7)) == (-1));
    assert(candidate((546), (546)) == (546));
}
"
HumanEval/103,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ሁለት አዎንታዊ ቁጥሮች n እና m ተሰጥተውሃል፣ እና ስራህ ከ n እስከ m ያሉትን አጠቃላይ ቁጥሮች አማካይ ማስላት ነው (n እና m ን ጨምሮ) መልሱን ወደ ቀረበው አጠቃላይ ቁጥር አክብረው እና ወደ ሁለትዮሽ ይለውጡት፣ n ከ m ይበልጣል ከሆነ -1 መልሰው ለምሳሌ: >>> rounded_avg((1), (5)) ""0b11"" >>> rounded_avg(7), (5)) -1 >>> rounded_avg(10), (20)) ""0b1111"" >>> rounded_avg(20), (33) ""0b11010""
Union_std_string_long rounded_avg(long n, long m) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_string_long{
    std::string f0;
    long f1;
    Union_std_string_long(std::string _f0) : f0(_f0) {}
    Union_std_string_long(long _f1) : f1(_f1) {}
    ~Union_std_string_long() {}
    bool operator==(std::string f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_string_long rounded_avg(long n, long m) {
  if (n > m) {
    return Union_std_string_long(-1);
  }
  double sum = 0;
  for (long i = n; i <= m; ++i) {
    sum += i;
  }
  double avg = sum / (m - n + 1);
  long rounded_avg_long = std::round(avg);
  if (rounded_avg_long == 0) {
    return Union_std_string_long(""0b0"");
  }
  std::string binary_string = """";
  long temp = std::abs(rounded_avg_long);
  while (temp > 0) {
    binary_string = (temp % 2 == 0 ? ""0"" : ""1"") + binary_string;
    temp /= 2;
  }
  return Union_std_string_long(""0b"" + binary_string);
}","}
int main() {
    auto candidate = rounded_avg;
    assert(candidate((1), (5)) == ""0b11"");
    assert(candidate((7), (13)) == ""0b1010"");
    assert(candidate((964), (977)) == ""0b1111001010"");
    assert(candidate((996), (997)) == ""0b1111100100"");
    assert(candidate((560), (851)) == ""0b1011000010"");
    assert(candidate((185), (546)) == ""0b101101110"");
    assert(candidate((362), (496)) == ""0b110101101"");
    assert(candidate((350), (902)) == ""0b1001110010"");
    assert(candidate((197), (233)) == ""0b11010111"");
    assert(candidate((7), (5)) == -1);
    assert(candidate((5), (1)) == -1);
    assert(candidate((5), (5)) == ""0b101"");
}
"
HumanEval/104,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠው የ አዎንታዊ ሙሉ ቁጥሮች ቬክተር x. ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም እንኳን ምንም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያውም ቢያም ቢያም ቢያም ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ ቢ
std::vector<long> unique_digits(std::vector<long> x) {
","#include<assert.h>
#include<bits/stdc++.h>
bool has_even_digit(long n) {
  std::string s = std::to_string(n);
  for (char c : s) {
    if ((c - '0') % 2 == 0) {
      return true;
    }
  }
  return false;
}

std::vector<long> unique_digits(std::vector<long> x) {
  std::vector<long> result;
  for (long val : x) {
    if (!has_even_digit(val)) {
      result.push_back(val);
    }
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = unique_digits;
    assert(candidate((std::vector<long>({(long)15, (long)33, (long)1422, (long)1}))) == (std::vector<long>({(long)1, (long)15, (long)33})));
    assert(candidate((std::vector<long>({(long)152, (long)323, (long)1422, (long)10}))) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)12345, (long)2033, (long)111, (long)151}))) == (std::vector<long>({(long)111, (long)151})));
    assert(candidate((std::vector<long>({(long)135, (long)103, (long)31}))) == (std::vector<long>({(long)31, (long)135})));
}
"
HumanEval/105,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠን የጠቅላላ ቁጥሮች ቬክተር ፣ በ 1 እና 9 መካከል ያሉትን የጠቅላላ ቁጥሮች ይደርጁ ፣ የተገኘውን ቬክተር ይለውጡ ፣ እና ከዚያ እያንዳንዱን አሃዝ በተዛማጅ ስሙ ይተኩ ""አንድ"" ፣ ""ሁለት"" ፣ ""ሦስት"" ፣ ""አራት"" ፣ ""አምስት"" ፣ ""ስድስት"" ፣ ""ሰባት"" ፣ ""ስምንት"" ፣ ""ዘጠኝ"" ለምሳሌ: >>> by_length(std::vector<long>{long) 2, (long) 1, (long) 1, (long) 4, (long) 5, (long) 8, (long) 2, (long) 3}))) (std::vector<std::string>{(std::string) ""Eight"", (std::string) ""Five"", (std::string) ""Four"", (std::string) ""three"" , (std::string) ""Two"" , ""Two"" , ""Two"" , ""Two"" (std::string) ""One""::std::string::std::std::st::string::st::st::st::st::string::st::d::d::d: ""One"" (long) ""One"" (long) ""One""long""long)) ፣ (long) ""long""long""long"" (long""long"") ፣ (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (
std::vector<std::string> by_length(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> by_length(std::vector<long> arr) {
  std::vector<long> valid_numbers;
  std::vector<std::string> result;
  std::map<long, std::string> number_names = {
      {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""}, {5, ""Five""},
      {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}};
  for (long num : arr) {
    if (num >= 1 && num <= 9) {
      valid_numbers.push_back(num);
    }
  }
  std::sort(valid_numbers.begin(), valid_numbers.end());
  std::reverse(valid_numbers.begin(), valid_numbers.end());
  for (long num : valid_numbers) {
    result.push_back(number_names[num]);
  }
  return result;
}","}
int main() {
    auto candidate = by_length;
    assert(candidate((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3}))) == (std::vector<std::string>({(std::string)""Eight"", (std::string)""Five"", (std::string)""Four"", (std::string)""Three"", (std::string)""Two"", (std::string)""Two"", (std::string)""One"", (std::string)""One""})));
    assert(candidate((std::vector<long>())) == (std::vector<std::string>()));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)55}))) == (std::vector<std::string>({(std::string)""One""})));
    assert(candidate((std::vector<long>({(long)1, (long)-1, (long)3, (long)2}))) == (std::vector<std::string>({(std::string)""Three"", (std::string)""Two"", (std::string)""One""})));
    assert(candidate((std::vector<long>({(long)9, (long)4, (long)8}))) == (std::vector<std::string>({(std::string)""Nine"", (std::string)""Eight"", (std::string)""Four""})));
}
"
HumanEval/106,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// f ን እንደ ፓራሜትር የሚወስድ እና የ n መጠን ያለው ቬክተር ይመልሳል ፣ ይህም በ ‹ኢንዴክስ› ላይ ያለው ንጥረ ነገር ዋጋ ከሆነ i የ ‹i› ፋክቶሪያል ነው i እኩል ከሆነ ወይም ከሌላው የቁጥሮች ድምር ከ 1 እስከ i ካልሆነ i ከ 1 ይጀምራል የ ‹i› ፋክቶሪያል ከ 1 እስከ i ያሉ ቁጥሮች ማባዛት ነው (1 * 2 * ... * i) ምሳሌ: >>> f (((5)) (std::vector<long>{(long) 1, (long) 2, (long) 6, (long) 24, (long) 15}))
std::vector<long> f(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> f(long n) {
  std::vector<long> result;
  for (long i = 1; i <= n; ++i) {
    if (i % 2 == 0) {
      long factorial = 1;
      for (long j = 1; j <= i; ++j) {
        factorial *= j;
      }
      result.push_back(factorial);
    } else {
      long sum = 0;
      for (long j = 1; j <= i; ++j) {
        sum += j;
      }
      result.push_back(sum);
    }
  }
  return result;
}","}
int main() {
    auto candidate = f;
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15, (long)720, (long)28})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)2, (long)6})));
}
"
HumanEval/107,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ አዎንታዊ ቁጥር n ከተሰጠ ፣ በቁጥር ክልል ውስጥ የሚወድቁትን እኩል እና ያልተለመዱ የሙሉ ቁጥር ፓሊንድሮሞች ቁጥር ያለው አንድ ቱፕል ይመልሱ ምሳሌ 1: >>> እኩል_odd_palindrome (((3)) (std::make_tuple ((1, 2)) ማብራሪያ: ኢንቲጀር ፓሊንድሮም 1, 2, 3. አንዱ እኩል ነው ፣ ሁለቱ ደግሞ ያልተለመዱ ናቸው ምሳሌ 2: >>> እኩል_odd_palindrome (((12)) (std::make_tuple ((4, 6)) ማብራሪያ: ኢንቲጀር ፓሊንድሮም 1, 2, 3, 4, 5, 6, 7, 8, 9, 11 አራት እኩል ናቸው ፣ እና 6 ቱ ደግሞ ያልተለመዱ ናቸው ማስታወሻ: 1 <= n = 10 ^ 3 2. የተመለሰ ቱፕል በቅደም ተከተል የጅምና ያልተለመዱ የሙሉ ቁጥር ፓሊንድሮሞች ብዛት አለው
std::tuple<long, long> even_odd_palindrome(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_palindrome(long num) {
  std::string s = std::to_string(num);
  std::string reversed_s = s;
  std::reverse(reversed_s.begin(), reversed_s.end());
  return s == reversed_s;
}

std::tuple<long, long> even_odd_palindrome(long n) {
  long even_count = 0;
  long odd_count = 0;
  for (long i = 1; i <= n; ++i) {
    if (is_palindrome(i)) {
      if (i % 2 == 0) {
        even_count++;
      } else {
        odd_count++;
      }
    }
  }
  return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_palindrome;
    assert(candidate((123)) == (std::make_tuple(8, 13)));
    assert(candidate((12)) == (std::make_tuple(4, 6)));
    assert(candidate((3)) == (std::make_tuple(1, 2)));
    assert(candidate((63)) == (std::make_tuple(6, 8)));
    assert(candidate((25)) == (std::make_tuple(5, 6)));
    assert(candidate((19)) == (std::make_tuple(4, 6)));
    assert(candidate((9)) == (std::make_tuple(4, 5)));
    assert(candidate((1)) == (std::make_tuple(0, 1)));
}
"
HumanEval/108,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁጥር ድምር > 0 የሆነን የቁጥር ብዛት የሚወስድ እና የቁጥር ድምር > 0 የሆነን የቁጥር ብዛት የሚመልስ የቁጥር ብዛት ይፃፉ: ለምሳሌ -123 የቁጥር ቁጥሮች -1, 2, እና 3 አሉታዊ ይሆናል: >>> count_nums (((std::vector<long>())) (0) >>> count_nums (((std::vector<long>{(long) -1, (long) -11, (long) -11}))) (1) >>> count_nums (((std::vector<long>{(long) 1, (long) 1, (long) 2} (3))))
long count_nums(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_digits_signed(long n) {
  std::string s = std::to_string(n);
  long sum = 0;
  for (long i = 0; i < s.length(); ++i) {
    if (i == 0 && s[i] == '-') {
      if (s.length() > 1) {
        sum -= (s[i + 1] - '0');
        i++;
      }
    } else {
      sum += (s[i] - '0');
    }
  }
  return sum;
}

long count_nums(std::vector<long> arr) {
  long count = 0;
  for (long num : arr) {
    if (sum_digits_signed(num) > 0) {
      count++;
    }
  }
  return count;
}","}
int main() {
    auto candidate = count_nums;
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)2, (long)-2, (long)3, (long)4, (long)5}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)6, (long)9, (long)-6, (long)0, (long)1, (long)5}))) == (5));
    assert(candidate((std::vector<long>({(long)1, (long)100, (long)98, (long)-7, (long)1, (long)-1}))) == (4));
    assert(candidate((std::vector<long>({(long)12, (long)23, (long)34, (long)-45, (long)-56, (long)0}))) == (5));
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == (1));
    assert(candidate((std::vector<long>({(long)1}))) == (1));
}
"
HumanEval/109,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// እኛ N ሙሉ ቁጥሮች arr[1], arr[2], ..., arr[N] የቬክተር 'አር' አለን. በቬክተሩ ውስጥ ያሉት ቁጥሮች በዘፈቀደ ይደረደራሉ. የእርስዎ ተግባር በተሰጠው ቬክተር ላይ የሚከተሉትን ክዋኔዎች በማከናወን ቬክተሩን በማይቀንስ ቅደም ተከተል መደርደር ይቻል እንደሆነ መወሰን ነው: በቀኝ አቅጣጫ ማንኛውንም ቁጥር ማዛወር ይችላሉ. አንድ የቀኝ አቅጣጫ መቀየር ክዋኔ ማለት የቬክተሩ ሁሉንም አካላት በአንድ ቦታ ወደ ቀኝ አቅጣጫ ማዛወር ማለት ነው. የቬክተሩ የመጨረሻው አካል ወደ ቬክተሩ ውስጥ ወደ መጀመሪያው ቦታ ማለትም ወደ 0 ኛ ኢንዴክስ ይዛወራል። ከላይ ያለውን ክዋኔ በማከናወን የተደረደሩ ቬክተሮችን ማግኘት ከተቻለ እውነተኛውን ይመለሱ ሐሰተኛ ይመለሱ. የተሰጠው ቬክተር ባዶ ከሆነ እውነተኛውን ይመለሱ. ማስታወሻ: የተሰጠው ቬክተር ልዩ አካላት እንዲኖሩት ዋስትና ተሰጥቷል. ለምሳሌ: >>> move_one_ball_((st_vector_{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
bool move_one_ball(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
bool move_one_ball(std::vector<long> arr) {
  if (arr.empty()) {
    return true;
  }
  int n = arr.size();
  std::vector<long> sorted_arr = arr;
  std::sort(sorted_arr.begin(), sorted_arr.end());
  for (int shift = 0; shift < n; ++shift) {
    std::vector<long> shifted_arr(n);
    for (int i = 0; i < n; ++i) {
      shifted_arr[i] = arr[(i - shift + n) % n];
    }
    if (shifted_arr == sorted_arr) {
      return true;
    }
  }
  return false;
}","}
int main() {
    auto candidate = move_one_ball;
    assert(candidate((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)10, (long)1, (long)2}))) == (true));
    assert(candidate((std::vector<long>({(long)4, (long)3, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
}
"
HumanEval/110,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በዚህ ችግር ውስጥ ሁለት የቁጥር ቬክተሮችን የሚወስድ ተግባር ተግባራዊ ያደርጋል ፣ እና lst1 ን የቁጥር ቁጥሮች ብቻ ቬክተር ለማድረግ በመካከላቸው የንጥረ ነገሮችን መለዋወጥ መቻል አለመቻሉን ይወስናል ። በ lst1 እና lst2 መካከል በተለዋዋጭ ንጥረ ነገሮች ብዛት ላይ ገደብ የለም ። በ lst1 እና lst2 መካከል ያሉትን ንጥረ ነገሮች መለዋወጥ የሚቻል ከሆነ የ lst1 ንጥረ ነገሮችን ሁሉ እኩል ለማድረግ ""አዎ"" ይመልሱ ። አለበለዚያ ""አይሆንም"" ይመልሱ ። ለምሳሌ: >>> መለዋወጥ (((std::vector<>((long) 1, (long) 2, (long) 3, (long) 4}) ፣ (std::vector<>((long) 1, (long) 2, (long) 3, (long) 4}) ፣ (std::vector<>(long))))) (""አዎ"") >>> (std::vector<>{(long>{1, (long) 2, (long) 3, (long)) (std::vector<>(long)) ፣ (long) 4)) ፣ (long) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long))
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
","#include<assert.h>
#include<bits/stdc++.h>
std::string exchange(std::vector<long> lst1, std::vector<long> lst2) {
  long odd_count_lst1 = 0;
  for (long num : lst1) {
    if (num % 2 != 0) {
      odd_count_lst1++;
    }
  }
  long even_count_lst2 = 0;
  for (long num : lst2) {
    if (num % 2 == 0) {
      even_count_lst2++;
    }
  }
  if (even_count_lst2 >= odd_count_lst1) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = exchange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)2, (long)1, (long)4, (long)3}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)4}))) == (""YES""));
    assert(candidate((std::vector<long>({(long)5, (long)7, (long)3})), (std::vector<long>({(long)2, (long)6, (long)3}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)6, (long)1, (long)8, (long)9})), (std::vector<long>({(long)3, (long)5, (long)5, (long)1, (long)1, (long)1}))) == (""NO""));
    assert(candidate((std::vector<long>({(long)100, (long)200})), (std::vector<long>({(long)200, (long)200}))) == (""YES""));
}
"
HumanEval/111,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ሕብረቁምፊ የተለዩ ትናንሽ ፊደላት የሚያመለክቱትን ሕብረቁምፊ ከተሰጠ በኋላ፣ በጣም የተደጋገሙትን ፊደላት ካርታ መልሶ ያቅርቡ፣ እና ተመጣጣኝ ቆጠራውን ይያዙ። በርካታ ፊደላት ተመሳሳይ ክስተት ካላቸው፣ ሁሉንም መልሰው ያቅርቡ፣ ምሳሌ: >>> ሂስቶግራም (histogram) (https://www.youtube.com/watch?v=p_Z6g8f8f8f) (https://www.youtube.com/watch?v=Z6g8f8f8f8f8f8f8f) (https://www.youtube.com/watch?v=Z6g8f8f8f8f8f8f) (https://www.youtube.com/watch?v=Z6g8f8f8f8f8f8f) (https://www.youtube.com/watch?v=Z6g8f8f8f8f8f) (https://www.youtube.com/watch?v=Z6g8f8f8f8f8f8f8f) (https://www.youtube.com/watch?v=z6f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f8f)
std::map<std::string,long> histogram(std::string test) {
","#include<assert.h>
#include<bits/stdc++.h>
std::map<std::string,long> histogram(std::string test) {
  std::map<std::string, long> counts;
  std::string current_word;
  std::stringstream ss(test);
  while (ss >> current_word) {
    counts[current_word]++;
  }
  if (counts.empty()) {
    return {};
  }
  long max_count = 0;
  for (const auto& pair : counts) {
    if (pair.second > max_count) {
      max_count = pair.second;
    }
  }
  std::map<std::string, long> result;
  for (const auto& pair : counts) {
    if (pair.second == max_count) {
      result[pair.first] = pair.second;
    }
  }
  return result;
}","}
int main() {
    auto candidate = histogram;
    assert(candidate((""a b b a"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c a b"")) == (std::map<std::string,long>({{""a"", 2}, {""b"", 2}})));
    assert(candidate((""a b c d g"")) == (std::map<std::string,long>({{""a"", 1}, {""b"", 1}, {""c"", 1}, {""d"", 1}, {""g"", 1}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate((""b b b b a"")) == (std::map<std::string,long>({{""b"", 4}})));
    assert(candidate((""r t g"")) == (std::map<std::string,long>({{""r"", 1}, {""t"", 1}, {""g"", 1}})));
    assert(candidate(("""")) == (std::map<std::string,long>()));
    assert(candidate((""a"")) == (std::map<std::string,long>({{""a"", 1}})));
}
"
HumanEval/112,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ተግባር ሁለት ሕብረቁምፊዎች ተሰጥቶናል s እና c፣ በ s ውስጥ ያሉትን ማንኛውንም ገጸ-ባህሪያት ከማንኛውም ገጸ-ባህሪያት ጋር እኩል የሆኑትን ሁሉ መሰረዝ አለብዎት ከዚያም ውጤቱ ሕብረቁምፊ ፓሊንድሮም መሆኑን ያረጋግጡ። አንድ ሕብረቁምፊ ወደ ፊት ተመሳሳይ ከሆነ ወደ ኋላ የሚነበብ ከሆነ ፓሊንድሮም ይባላል ። የውጤቱን ሕብረቁምፊ እና እውነተኛ / ሐሰተኛ ለምርመራው የያዘውን የቱፕል መመለስ አለብዎት ። ምሳሌ >>> reverse_delete (((""abcde""), (""ae"")) (std::make_tuple (((bcd"", false)) >>> reverse_delete (((""abcdef""), (""b"") (std::make_tuple (((acdef"",)) >>> reverse_delete (((abcded"", false)) >>> reverse_delete (((abcded""), (""abcba"") (std::make_tuple (((cdedc"", true))
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
","#include<assert.h>
#include<bits/stdc++.h>
std::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {
  std::string result = """";
  std::unordered_set<char> chars_to_delete(c.begin(), c.end());
  for (char ch : s) {
    if (chars_to_delete.find(ch) == chars_to_delete.end()) {
      result += ch;
    }
  }
  std::string reversed_result = result;
  std::reverse(reversed_result.begin(), reversed_result.end());
  return std::make_tuple(result, result == reversed_result);
}","}
int main() {
    auto candidate = reverse_delete;
    assert(candidate((""abcde""), (""ae"")) == (std::make_tuple(""bcd"", false)));
    assert(candidate((""abcdef""), (""b"")) == (std::make_tuple(""acdef"", false)));
    assert(candidate((""abcdedcba""), (""ab"")) == (std::make_tuple(""cdedc"", true)));
    assert(candidate((""dwik""), (""w"")) == (std::make_tuple(""dik"", false)));
    assert(candidate((""a""), (""a"")) == (std::make_tuple("""", true)));
    assert(candidate((""abcdedcba""), ("""")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""abcdedcba""), (""v"")) == (std::make_tuple(""abcdedcba"", true)));
    assert(candidate((""vabba""), (""v"")) == (std::make_tuple(""abba"", true)));
    assert(candidate((""mamma""), (""mia"")) == (std::make_tuple("""", true)));
}
"
HumanEval/113,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// እያንዳንዱ ሕብረቁምፊዎች ብቻ አሃዞች ያካተተ ነው, አንድ ቬክተር ይመለሱ. እያንዳንዱ ንጥረ ነገር i ""የግብዓት ሕብረቁምፊ i ውስጥ ያልተለመዱ ንጥረ ነገሮች ቁጥር መሆን አለበት. "" ሁሉም i's ግብዓት i'th ሕብረቁምፊ ውስጥ ያልተለመዱ አሃዞች ቁጥር ጋር መተካት አለባቸው የት. >>> odd_count((std::vector<std::string>(({std::string) ""1234567""}))) (std::vector<std::string>({stdstring)::""የ ያልተለመዱ ንጥረ ነገሮች ቁጥር 4n የ str4ng 4 የ 4n. "")) >>> odd_count((stdvector<stdstring>::{(stdstring)::{(stdstring) """", ""3 (stdstring)::""""1111""11"")) (stdvector<stdstring::{stdstring>:n) 1::"" 1stn: 1 (((string) የ ያልተለመዱ ንጥረ ነገሮች ቁጥር 8n. "")) 8n.
std::vector<std::string> odd_count(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<std::string> odd_count(std::vector<std::string> lst) {
  std::vector<std::string> result;
  for (const std::string& s : lst) {
    int count = 0;
    for (char c : s) {
      if ((c - '0') % 2 != 0) {
        count++;
      }
    }
    std::string count_str = std::to_string(count);
    std::string modified_s = s;
    for (char& c : modified_s) {
      if (isdigit(c) && (c - '0') % 2 != 0) {
        c = count_str[0];
      }
    }
    result.push_back(""the number of odd elements "" + count_str + ""n the str"" + modified_s + ""ng "" + modified_s + "" of the "" + modified_s + ""nput."");
  }
  return result;
}","}
int main() {
    auto candidate = odd_count;
    assert(candidate((std::vector<std::string>({(std::string)""1234567""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 4n the str4ng 4 of the 4nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""3"", (std::string)""11111111""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (std::string)""the number of odd elements 8n the str8ng 8 of the 8nput.""})));
    assert(candidate((std::vector<std::string>({(std::string)""271"", (std::string)""137"", (std::string)""314""}))) == (std::vector<std::string>({(std::string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (std::string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (std::string)""the number of odd elements 2n the str2ng 2 of the 2nput.""})));
}
"
HumanEval/114,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁጥር n ንዑስ-ቬክተር ከተሰጠ ፣ ከማንኛውም ባዶ ያልሆነ የቁጥር ንዑስ-ቬክተር አነስተኛውን ድምር ያግኙ ምሳሌ >>> minSubArraySum(((std::vector<long>({long) 2, (long) 3, (long) 4, (long) 1, (long) 2, (long) 4}))) (1) >>> minSubArraySum(std::vector<long>{(long) -1, (long) -2, (long) -3)))) (-6)
long minSubArraySum(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>
long minSubArraySum(std::vector<long> nums) {
  if (nums.empty()) {
    throw std::invalid_argument(""Input vector cannot be empty."");
  }
  long min_so_far = nums[0];
  long current_min = nums[0];
  for (size_t i = 1; i < nums.size(); ++i) {
    current_min = std::min(nums[i], current_min + nums[i]);
    min_so_far = std::min(min_so_far, current_min);
  }
  return min_so_far;
}","}
int main() {
    auto candidate = minSubArraySum;
    assert(candidate((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (-6));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));
    assert(candidate((std::vector<long>({(long)-9999999999999999}))) == (-9999999999999999));
    assert(candidate((std::vector<long>({(long)0, (long)10, (long)20, (long)1000000}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)100, (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));
    assert(candidate((std::vector<long>({(long)10, (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));
    assert(candidate((std::vector<long>({(long)100, (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));
    assert(candidate((std::vector<long>({(long)-10}))) == (-10));
    assert(candidate((std::vector<long>({(long)7}))) == (7));
    assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));
}
"
HumanEval/115,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// እያንዳንዱ ረድፍ አንድ ነጠላ ጉድጓድ ይወክላል, እና እያንዳንዱ ረድፍ ውስጥ 1 ውኃ ነጠላ አሃድ ይወክላል. እያንዳንዱ ጉድጓድ ውኃ ለማውጣት ጥቅም ላይ ሊውል የሚችል አንድ ተዛማጅ ባልዲ አለው, እና ሁሉም ባልዲዎች ተመሳሳይ አቅም አላቸው. የእርስዎ ተግባር ጉድጓዶች ባዶ ወደ ባልዲዎች መጠቀም ነው. ወደ ባልዲዎች ዝቅ ለማድረግ የሚያስፈልገውን ጊዜ ቁጥር ውፅዓት. ምሳሌ 1: >>> max_fill((std::vector<std::vector<std::vector<long>, (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
","#include<assert.h>
#include<bits/stdc++.h>
long max_fill(std::vector<std::vector<long>> grid, long capacity) {
  long bucket_lowering_count = 0;
  for (const auto& row : grid) {
    long water_in_well = 0;
    for (long unit : row) {
      water_in_well += unit;
    }
    bucket_lowering_count += (water_in_well + capacity - 1) / capacity;
  }
  return bucket_lowering_count;
}","}
int main() {
    auto candidate = max_fill;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));
}
"
HumanEval/116,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በዚህ ካታ ውስጥ ፣ አሉታዊ ያልሆኑ አጠቃላይ ቁጥሮች በሁለትዮሽ ውክልናቸው ውስጥ ባሉ ቁጥሮች ቁጥር መሠረት በዝቅተኛ ቅደም ተከተል መደርደር አለብዎት ። ለተመሳሳይ ቁጥሮች ፣ በአስርዮሽ እሴት ላይ በመመርኮዝ መደርደር አለበት ። እንደሚከተለው መተግበር አለበት: >>> sort_array((std::vector<long>{(long) 1, (long) 5, (long) 2, (long) 3, (long) 4}))) (std::vector<long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5})) >>> sort_array((std::vector<long>{(long>{(long) 2, (long) 3, (long) 4, (long) 5, (long) 6}))) (std::vector<(long>{(long>{-6, (long) 5, (long) 4, (long) 3, (long) 2} >>> sort_array_std::vector<(long>{(long>1, (long) 3, (long)) (long) 0, (long)) (long) 2, (long) 3, (long)) (long) 4)) (long) (long) (long) (long) (long)) (long) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long)) (long))
std::vector<long> sort_array(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
int count_set_bits(long n) {
  int count = 0;
  if (n < 0) {
    n = std::abs(n);
  }
  while (n > 0) {
    n &= (n - 1);
    count++;
  }
  return count;
}

bool compare(long a, long b) {
  int bits_a = count_set_bits(a);
  int bits_b = count_set_bits(b);
  if (bits_a != bits_b) {
    return bits_a < bits_b;
  }
  return a < b;
}

std::vector<long> sort_array(std::vector<long> arr) {
  std::sort(arr.begin(), arr.end(), compare);
  return arr;
}","}
int main() {
    auto candidate = sort_array;
    assert(candidate((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6}))) == (std::vector<long>({(long)-4, (long)-2, (long)-6, (long)-5, (long)-3})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)0, (long)1, (long)2, (long)4, (long)3})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)2, (long)5, (long)77, (long)4, (long)5, (long)3, (long)5, (long)7, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)2, (long)4, (long)4, (long)3, (long)3, (long)5, (long)5, (long)5, (long)7, (long)77})));
    assert(candidate((std::vector<long>({(long)3, (long)6, (long)44, (long)12, (long)32, (long)5}))) == (std::vector<long>({(long)32, (long)3, (long)5, (long)6, (long)12, (long)44})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32}))) == (std::vector<long>({(long)2, (long)4, (long)8, (long)16, (long)32})));
}
"
HumanEval/117,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ string s እና አንድ ተፈጥሯዊ ቁጥር n ከተሰጠ, እነዚህ ቃላት string s ውስጥ እንዲታዩ በትክክል n ወዘተ የያዘውን string s ከ ሁሉ ቃላት ቬክተር የሚመልስ ተግባር ተግባራዊ ለማድረግ ተልእኮ ተሰጥቶታል. string s ባዶ ከሆነ ከዚያም ተግባር ባዶ ቬክተር መመለስ አለበት. ማስታወሻ: አንተ ብቻ ፊደላት እና ክፍተቶች የያዘ የግብዓት ሕብረቁምፊ ሊወስዱ ይችላሉ. ምሳሌዎች: >>> select_words (((""ማርያም ትንሽ በግ ነበረው""), (4)) (std::vector<std::string>({(std::string) ""ትንሽ""}) >>> select_words ((((""ማርያም ትንሽ በግ ነበረው""), (3)) (std::vector<std::string>((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> select_words(std::string s, long n) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_consonant(char c) {
  c = tolower(c);
  return (c >= 'a' && c <= 'z' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u');
}

std::vector<std::string> select_words(std::string s, long n) {
  std::vector<std::string> result;
  std::string current_word;
  for (char c : s) {
    if (c == ' ') {
      long consonant_count = 0;
      for (char word_char : current_word) {
        if (is_consonant(word_char)) {
          consonant_count++;
        }
      }
      if (consonant_count == n) {
        result.push_back(current_word);
      }
      current_word = """";
    } else {
      current_word += c;
    }
  }
  long consonant_count = 0;
  for (char word_char : current_word) {
    if (is_consonant(word_char)) {
      consonant_count++;
    }
  }
  if (consonant_count == n) {
    result.push_back(current_word);
  }
  return result;
}","}
int main() {
    auto candidate = select_words;
    assert(candidate((""Mary had a little lamb""), (4)) == (std::vector<std::string>({(std::string)""little""})));
    assert(candidate((""Mary had a little lamb""), (3)) == (std::vector<std::string>({(std::string)""Mary"", (std::string)""lamb""})));
    assert(candidate((""simple white space""), (2)) == (std::vector<std::string>()));
    assert(candidate((""Hello world""), (4)) == (std::vector<std::string>({(std::string)""world""})));
    assert(candidate((""Uncle sam""), (3)) == (std::vector<std::string>({(std::string)""Uncle""})));
    assert(candidate((""""), (4)) == (std::vector<std::string>()));
    assert(candidate((""a b c d e f""), (1)) == (std::vector<std::string>({(std::string)""b"", (std::string)""c"", (std::string)""d"", (std::string)""f""})));
}
"
HumanEval/118,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ቃል ተሰጥቶሃል:: ስራህ ከቃሉ በስተቀኝ በኩል በሁለት የቃላት ፊደላት መካከል የሚገኘውን በጣም ቅርብ የሆነን የቃላት ፊደል (የቃላት ቁጥርን የሚመለከት) መፈለግ ነው:: በመጀመርያው እና መጨረሻው ያሉ የቃላት ፊደሎች አይቆጠሩም:: ከላይ የተጠቀሰውን ሁኔታ የሚያሟላ የቃላት ፊደል ካላገኘህ ባዶውን ሰንሰለት መልሰህ ላክ:: የተሰጠው ሰንሰለት የእንግሊዝኛ ፊደል ብቻ ይዟል ብለህ ልትገምተው ትችላለህ:: ምሳሌ: >>> get_closest_vowel (((""yogurt""))) (""u"") >>> get_closest_vowel (((""FULL"")) (""U"") >>> get_closest_vowel (((""quick"")) ("""") >>> get_closest_vowel ((((ab"") ("""")
std::string get_closest_vowel(std::string word) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_vowel(char c) {
  c = tolower(c);
  return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');
}

bool is_consonant(char c) {
  return isalpha(c) && !is_vowel(c);
}

std::string get_closest_vowel(std::string word) {
  if (word.length() < 3) {
    return """";
  }
  for (int i = word.length() - 2; i >= 1; --i) {
    if (is_vowel(word[i]) && is_consonant(word[i - 1]) && is_consonant(word[i + 1])) {
      return std::string(1, word[i]);
    }
  }
  return """";
}","}
int main() {
    auto candidate = get_closest_vowel;
    assert(candidate((""yogurt"")) == (""u""));
    assert(candidate((""full"")) == (""u""));
    assert(candidate((""easy"")) == (""""));
    assert(candidate((""eAsy"")) == (""""));
    assert(candidate((""ali"")) == (""""));
    assert(candidate((""bad"")) == (""a""));
    assert(candidate((""most"")) == (""o""));
    assert(candidate((""ab"")) == (""""));
    assert(candidate((""ba"")) == (""""));
    assert(candidate((""quick"")) == (""""));
    assert(candidate((""anime"")) == (""i""));
    assert(candidate((""Asia"")) == (""""));
    assert(candidate((""Above"")) == (""o""));
}
"
HumanEval/119,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት ሕብረቁምፊዎች የተሰጡ ናቸው፣ ሁለቱም ሕብረቁምፊዎች ክፍት ቅንፍ '(' ወይም የቅርብ ቅንፍ ') ' ብቻ ነው ያላቸው። ስራዎ ሁለቱንም ሕብረቁምፊዎች በተወሰነ ቅደም ተከተል ማገናኘት ይቻል እንደሆነ መፈተሽ ነው፣ ይህም የሚመነጨው ሕብረቁምፊ ጥሩ ይሆናል ማለት ነው። አንድ ሕብረቁምፊ S ጥሩ ነው ተብሎ የሚወሰነው ሁሉም በ S ውስጥ ያሉ ቅንፎች ሚዛናዊ ከሆኑ ብቻ ነው። ለምሳሌ: ሕብረቁምፊው '(())))' ጥሩ ነው፣ ሕብረቁምፊው '())' ግን ጥሩ አይደለም:: ጥሩ ሕብረቁምፊን ለመሥራት የሚያስችል መንገድ ካለ 'አዎ' ይመልሱ፣ አለበለዚያ ደግሞ 'አይ' ይመልሱ:: ምሳሌዎች: >>> match_parens(std::vector<std::string>{((stdstring) "") ፣ "" (((std::string) "")) ፣ "" ()) "" (""አዎ"") >>> match_parens<std::vector<stdstring>{((stdstring>"" (""አይ"")
std::string match_parens(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_good(const std::string& s) {
  int balance = 0;
  for (char c : s) {
    if (c == '(') {
      balance++;
    } else if (c == ')') {
      balance--;
    }
    if (balance < 0) {
      return false;
    }
  }
  return balance == 0;
}

std::string match_parens(std::vector<std::string> lst) {
  std::string s1 = lst[0];
  std::string s2 = lst[1];
  if (is_good(s1 + s2) || is_good(s2 + s1)) {
    return ""Yes"";
  } else {
    return ""No"";
  }
}","}
int main() {
    auto candidate = match_parens;
    assert(candidate((std::vector<std::string>({(std::string)""()("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)"")""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()(())"", (std::string)""())())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")())"", (std::string)""(()()(""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(())))"", (std::string)""(()())((""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""()"", (std::string)""())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""(()("", (std::string)""()))()""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)""(((("", (std::string)""((())""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")(()"", (std::string)""(()(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)"")("", (std::string)"")(""}))) == (""No""));
    assert(candidate((std::vector<std::string>({(std::string)""("", (std::string)"")""}))) == (""Yes""));
    assert(candidate((std::vector<std::string>({(std::string)"")"", (std::string)""(""}))) == (""Yes""));
}
"
HumanEval/120,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ቬክተር arr የተሰኘ ሙሉ ቁጥሮች እና አንድ አዎንታዊ ሙሉ ቁጥር k የተሰጠ, አንድ የተደረደሩ ቬክተር ርዝመት k ጋር ከፍተኛ k ቁጥሮች ውስጥ arr. ምሳሌ 1: >>> ከፍተኛው((std::vector<long>({long) -3, (long) -4, (long) -5,)), (3)) (std::vector<long>({long) -4, (long) -3, (long) 5}) ምሳሌ 2: >>> ከፍተኛው((std::vector<long>({long) -4, (long) -4, (long) 4})), (2)) (std::vector<long>({long) -4, (long) 4}) ምሳሌ 3: >>> ከፍተኛው(std::vector<long>{(long) -3, (long) -2, (long) -1, (long) -2, (long) -1, (long) -2, (long) -1, (long) (1)) (1) (std::vector<long>(arr) -2: 1) የ ቬክተር ርዝመት በ 1000 ውስጥ ይሆናል የ ቬክተር ርዝመት በ k ውስጥ ይሆናል [አስተዋል 1 ፣ 2 ፣ 1000] ማስታወሻ: የ ቬክተር ርዝመት በ 1000 ውስጥ ይሆናል [አንድ = 1 ፣ 2]
std::vector<long> maximum(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> maximum(std::vector<long> arr, long k) {
  std::sort(arr.rbegin(), arr.rend());
  std::vector<long> result;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    result.push_back(arr[i]);
  }
  std::sort(result.begin(), result.end());
  return result;
}","}
int main() {
    auto candidate = maximum;
    assert(candidate((std::vector<long>({(long)-3, (long)-4, (long)5})), (3)) == (std::vector<long>({(long)-4, (long)-3, (long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4, (long)4})), (2)) == (std::vector<long>({(long)4, (long)4})));
    assert(candidate((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1)) == (std::vector<long>({(long)2})));
    assert(candidate((std::vector<long>({(long)123, (long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (3)) == (std::vector<long>({(long)2, (long)20, (long)123})));
    assert(candidate((std::vector<long>({(long)-123, (long)20, (long)0, (long)1, (long)2, (long)-3})), (4)) == (std::vector<long>({(long)0, (long)1, (long)2, (long)20})));
    assert(candidate((std::vector<long>({(long)5, (long)15, (long)0, (long)3, (long)-13, (long)-8, (long)0})), (7)) == (std::vector<long>({(long)-13, (long)-8, (long)0, (long)0, (long)3, (long)5, (long)15})));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)2, (long)5, (long)3, (long)-10})), (2)) == (std::vector<long>({(long)3, (long)5})));
    assert(candidate((std::vector<long>({(long)1, (long)0, (long)5, (long)-7})), (1)) == (std::vector<long>({(long)5})));
    assert(candidate((std::vector<long>({(long)4, (long)-4})), (2)) == (std::vector<long>({(long)-4, (long)4})));
    assert(candidate((std::vector<long>({(long)-10, (long)10})), (2)) == (std::vector<long>({(long)-10, (long)10})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)-23, (long)243, (long)-400, (long)0})), (0)) == (std::vector<long>()));
}
"
HumanEval/121,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ባዶ ያልሆነ የሙሉ ቁጥሮች ቬክተር ሲሰጥ ፣ በደረጃዎች ውስጥ ያሉትን ሁሉንም ያልተለመዱ ንጥረ ነገሮች ድምር ይመልሱ ። ምሳሌዎች >>> መፍትሄው (((std::vector<long>({(long) 5, (long) 8, (long) 7, (long) 1}))) (12) >>> መፍትሄው ((((std::vector<long>({(long) 3, (long) 3, (long) 3, (long) 3}))) (9) >>> መፍትሄው (((std::vector<>(({long) 30, (long) 13, (long) 24, (long) 321}))) (0)
long solution(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long solution(std::vector<long> lst) {
  long sum = 0;
  for (long i = 0; i < lst.size(); i += 2) {
    if (lst[i] % 2 != 0) {
      sum += lst[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = solution;
    assert(candidate((std::vector<long>({(long)5, (long)8, (long)7, (long)1}))) == (12));
    assert(candidate((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3}))) == (9));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)24, (long)321}))) == (0));
    assert(candidate((std::vector<long>({(long)5, (long)9}))) == (5));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)8}))) == (0));
    assert(candidate((std::vector<long>({(long)30, (long)13, (long)23, (long)32}))) == (23));
    assert(candidate((std::vector<long>({(long)3, (long)13, (long)2, (long)9}))) == (3));
}
"
HumanEval/122,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከሙሉ ቁጥሮች arr እና k የተሰጠ ሙሉ ቁጥር ፣ ከመጀመሪያዎቹ k የ arr ንጥረ ነገሮች ውስጥ ቢበዛ ሁለት አሃዞች ያሉት ንጥረ ነገሮች ድምር ይመልሱ ምሳሌ: >>> add_elements((std::vector<long>(({long) 111, (long) 21, (long) 3, (long) 4000, (long) 5, (long) 6, (long) 7, (long) 8, (long) 9})), (4)) (24) ገደቦች: 1. 1 <= len(arr) <= 100 2. 1 <= k <= lenarr)
long add_elements(std::vector<long> arr, long k) {
","#include<assert.h>
#include<bits/stdc++.h>
long add_elements(std::vector<long> arr, long k) {
  long sum = 0;
  for (long i = 0; i < std::min((long)arr.size(), k); ++i) {
    if (arr[i] >= -99 && arr[i] <= 99) {
      sum += arr[i];
    }
  }
  return sum;
}","}
int main() {
    auto candidate = add_elements;
    assert(candidate((std::vector<long>({(long)1, (long)-2, (long)-3, (long)41, (long)57, (long)76, (long)87, (long)88, (long)99})), (3)) == (-4));
    assert(candidate((std::vector<long>({(long)111, (long)121, (long)3, (long)4000, (long)5, (long)6})), (2)) == (0));
    assert(candidate((std::vector<long>({(long)11, (long)21, (long)3, (long)90, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (125));
    assert(candidate((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4)) == (24));
    assert(candidate((std::vector<long>({(long)1})), (1)) == (1));
}
"
HumanEval/123,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ አዎንታዊ ቁጥር n ከተሰጠ ፣ በኮላዝ ቅደም ተከተል ውስጥ ያልተለመዱ ቁጥሮች ያሉት የተደረደሩ ቬክተርን ይመልሱ ። የኮላዝ ግምታዊነት በሂሳብ ውስጥ እንደሚከተለው በተገለጸው ቅደም ተከተል ላይ የሚመለከት ግምታዊነት ነው-በማንኛውም አዎንታዊ ቁጥር n ይጀምሩ ከዚያም እያንዳንዱ ቃል ከቀዳሚው ቃል እንደሚከተለው ይወሰዳል-የቀዳሚው ቃል እኩል ከሆነ ፣ ቀጣዩ ቃል ከቀዳሚው ቃል ግማሽ ነው ። የቀደመው ቃል ያልተለመደ ከሆነ ፣ ቀጣዩ ቃል ከቀዳሚው ቃል 3 እጥፍ ነው እና 1.
std::vector<long> get_odd_collatz(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
std::vector<long> get_odd_collatz(long n) {
  std::vector<long> odd_numbers;
  std::unordered_set<long> seen;
  long current = n;
  while (seen.find(current) == seen.end()) {
    seen.insert(current);
    if (current % 2 != 0) {
      odd_numbers.push_back(current);
    }
    if (current == 1) {
      break;
    }
    if (current % 2 == 0) {
      current /= 2;
    } else {
      current = 3 * current + 1;
    }
  }
  std::sort(odd_numbers.begin(), odd_numbers.end());
  return odd_numbers;
}","}
int main() {
    auto candidate = get_odd_collatz;
    assert(candidate((14)) == (std::vector<long>({(long)1, (long)5, (long)7, (long)11, (long)13, (long)17})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)5})));
    assert(candidate((12)) == (std::vector<long>({(long)1, (long)3, (long)5})));
    assert(candidate((1)) == (std::vector<long>({(long)1})));
}
"
HumanEval/124,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠውን ቀን ሰንሰለት የሚያረጋግጥ እና ቀን ከሆነ እውነት የሚመልስ ተግባር መጻፍ አለብዎት ካልሆነ ግን ሐሰት ነው. ቀን የሚከተሉት ደንቦች ሁሉ ከተሟሉ ቀን ልክ ነው: 1. ቀን ሰንሰለት ባዶ አይደለም 2. ቀናት ቁጥር ከ 1 በታች ወይም ከ 31 ቀናት በላይ አይደለም ወራት 1,3,5,7,8,10,12. እና ቀናት ቁጥር ከ 1 በታች ወይም ከ 30 ቀናት በላይ አይደለም ወራት 4,6,9,11. እና, ቀናት ቁጥር ከ 1 በታች ወይም ከ 29 በላይ አይደለም ወር 2. 3. ወራት ከ 1 በታች ወይም ከ 12 በላይ መሆን የለበትም 4. ቀን ቅርጸት ውስጥ መሆን አለበት: ሚሜ-dd-yyyy >>> valid_(date((103-11-2000"")) (እውነት) >>> valid_date((15-01-2012"")) (ሐሰት) >>> valid_date(04-040-20"") (ሐሰት) >>> valid_(date_(06-2020"") (እውነት) >>> valid_date""06/04/2020) (ሐሰት)
bool valid_date(std::string date) {
","#include<assert.h>
#include<bits/stdc++.h>
bool valid_date(std::string date) {
  if (date.empty()) {
    return false;
  }
  if (date.length() != 10 || date[2] != '-' || date[5] != '-') {
    return false;
  }
  int month, day, year;
  try {
    month = std::stoi(date.substr(0, 2));
    day = std::stoi(date.substr(3, 2));
    year = std::stoi(date.substr(6, 4));
  } catch (const std::invalid_argument& e) {
    return false;
  } catch (const std::out_of_range& e) {
    return false;
  }
  if (month < 1 || month > 12) {
    return false;
  }
  if (day < 1) {
    return false;
  }
  if (month == 2) {
    if (day > 29) {
      return false;
    }
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    if (day > 30) {
      return false;
    }
  } else {
    if (day > 31) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = valid_date;
    assert(candidate((""03-11-2000"")) == (true));
    assert(candidate((""15-01-2012"")) == (false));
    assert(candidate((""04-0-2040"")) == (false));
    assert(candidate((""06-04-2020"")) == (true));
    assert(candidate((""01-01-2007"")) == (true));
    assert(candidate((""03-32-2011"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""04-31-3000"")) == (false));
    assert(candidate((""06-06-2005"")) == (true));
    assert(candidate((""21-31-2000"")) == (false));
    assert(candidate((""04-12-2003"")) == (true));
    assert(candidate((""04122003"")) == (false));
    assert(candidate((""20030412"")) == (false));
    assert(candidate((""2003-04"")) == (false));
    assert(candidate((""2003-04-12"")) == (false));
    assert(candidate((""04-2003"")) == (false));
}
"
HumanEval/125,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }    bool operator==(long f) {
        return f1 == f ;
    }
};
// ቃላት ተከታታይ የተሰጠው, ነጭ ቦታ ላይ የተከፋፈሉ ቃላት ቬክተር መመለስ, ምንም ነጭ ቦታዎች በጽሑፉ ውስጥ የለም ከሆነ እናንተ ኮማዎች ላይ መከፋፈል አለበት ',' ምንም ኮማዎች የለም ከሆነ አንተ ፊደል ውስጥ ያልተለመደ ቅደም ተከተል ጋር አነስተኛ ፊደላት ቁጥር መመለስ አለበት, ord('a') = 0, ord('b') = 1, ... ord('z') = 25 ምሳሌዎች >>> split_words (አለም ሰላም!
Union_std_vector_std_string__long split_words(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
union Union_std_vector_std_string__long{
    std::vector<std::string> f0;
    long f1;
    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}
    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}
    ~Union_std_vector_std_string__long() {}
    bool operator==(std::vector<std::string> f) {
        return f0 == f ;
    }
    bool operator==(long f) {
        return f1 == f ;
    }
};
Union_std_vector_std_string__long split_words(std::string txt) {
  if (txt.find(' ') != std::string::npos) {
    std::vector<std::string> words;
    std::stringstream ss(txt);
    std::string word;
    while (ss >> word) {
      words.push_back(word);
    }
    return Union_std_vector_std_string__long(words);
  } else if (txt.find(',') != std::string::npos) {
    std::vector<std::string> words;
    std::string current_word;
    for (char c : txt) {
      if (c == ',') {
        words.push_back(current_word);
        current_word = """";
      } else {
        current_word += c;
      }
    }
    words.push_back(current_word);
    return Union_std_vector_std_string__long(words);
  } else {
    long odd_order_count = 0;
    for (char c : txt) {
      if (islower(c)) {
        if ((c - 'a') % 2 != 0) {
          odd_order_count++;
        }
      }
    }
    return Union_std_vector_std_string__long(odd_order_count);
  }
}","}
int main() {
    auto candidate = split_words;
    assert(candidate((""Hello world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello,world!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world!""}));
    assert(candidate((""Hello world,!"")) == std::vector<std::string>({(std::string)""Hello"", (std::string)""world,!""}));
    assert(candidate((""Hello,Hello,world !"")) == std::vector<std::string>({(std::string)""Hello,Hello,world"", (std::string)""!""}));
    assert(candidate((""abcdef"")) == 3);
    assert(candidate((""aaabb"")) == 2);
    assert(candidate((""aaaBb"")) == 1);
    assert(candidate(("""")) == 0);
}
"
HumanEval/126,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ቁጥሮች የተሰጡ ከሆነ፣ ቁጥሮች በዝቅተኛ ቅደም ተከተል ተደራጅተው ይሁን አይሁን ይመልሱ። ቬክተር ከአንድ በላይ ተመሳሳይ ቁጥር ካለው፣ ሐሰት ይመልሱ። ምንም አሉታዊ ቁጥሮች እና ሙሉ ቁጥሮች ብቻ ይገመቱ። ምሳሌዎች >>> is_sorted (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
bool is_sorted(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_sorted(std::vector<long> lst) {
  if (lst.size() <= 1) {
    return true;
  }
  std::map<long, int> counts;
  for (long x : lst) {
    counts[x]++;
  }
  for (auto const& [key, val] : counts) {
    if (val > 2) {
      return false;
    }
  }
  for (size_t i = 0; i < lst.size() - 1; ++i) {
    if (lst[i] > lst[i + 1]) {
      return false;
    }
  }
  return true;
}","}
int main() {
    auto candidate = is_sorted;
    assert(candidate((std::vector<long>({(long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7}))) == (false));
    assert(candidate((std::vector<long>())) == (true));
    assert(candidate((std::vector<long>({(long)1}))) == (true));
    assert(candidate((std::vector<long>({(long)3, (long)2, (long)1}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4}))) == (false));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4}))) == (true));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4}))) == (true));
}
"
HumanEval/127,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት ክፍተቶች ተሰጥተውሃል፣ እያንዳንዱ ክፍተት ጥንድ የሙሉ ቁጥሮች ነው። ለምሳሌ፣ ክፍተት = (መጀመሪያ፣ መጨረሻ) = (1, 2) የተሰጡት ክፍተቶች የተዘጉ ናቸው ይህም ማለት ክፍተቱ (መጀመሪያ፣ መጨረሻ) መጀመሪያ እና መጨረሻን ያካትታል ማለት ነው። ለእያንዳንዱ የተሰጠ ክፍተት፣ ጅማሬው ከ መጨረሻው ያነሰ ወይም እኩል ነው ተብሎ ይታሰባል:: ስራዎ የእነዚህ ሁለት ክፍተቶች መቋረጫ ርዝመት ፕራይም ቁጥር መሆኑን መወሰን ነው። ለምሳሌ፣ የ ክፍተቶች መቋረጫ (1, 3), (2, 4) (2, 3) ሲሆን ርዝመቱ 1 ሲሆን ይህም ፕራይም ቁጥር አይደለም። የመቋረጫው ርዝመት ፕራይም ቁጥር ከሆነ ""አዎ"" ይመልሱ፣ አለበለዚያ ""አይደለም"" ይመልሱ:: ሁለቱ ክፍተቶች የማይገናኙ ከሆነ ""አይደለም"" ይመልሱ:: [input/output] ናሙናዎች: >>> መቋረጫ:: (((dmake_tuple1, 2) ፣ (dmake_tuple2, 3) ፣ (dmake_tuple1) ፣ (dmake_tuple5) ፣ (dmake_tuple_1, 4) ፣ (dmake_make_tuple_1, 4) ፣ (dmake_make_make_make_make_make)
std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_prime(long n) {
  if (n <= 1) return false;
  for (long i = 2; i * i <= n; ++i) {
    if (n % i == 0) return false;
  }
  return true;
}

std::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {
  long start1 = std::get(interval1);
  long end1 = std::get(interval1);
  long start2 = std::get(interval2);
  long end2 = std::get(interval2);
  long intersection_start = std::max(start1, start2);
  long intersection_end = std::min(end1, end2);
  long intersection_length = intersection_end - intersection_start + 1;
  if (intersection_length <= 0) {
    return ""NO"";
  }
  if (is_prime(intersection_length)) {
    return ""YES"";
  } else {
    return ""NO"";
  }
}","}
int main() {
    auto candidate = intersection;
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(2, 3))) == (""NO""));
    assert(candidate((std::make_tuple(-1, 1)), (std::make_tuple(0, 4))) == (""NO""));
    assert(candidate((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5))) == (""YES""));
    assert(candidate((std::make_tuple(-2, 2)), (std::make_tuple(-4, 0))) == (""YES""));
    assert(candidate((std::make_tuple(-11, 2)), (std::make_tuple(-1, -1))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(3, 5))) == (""NO""));
    assert(candidate((std::make_tuple(1, 2)), (std::make_tuple(1, 2))) == (""NO""));
    assert(candidate((std::make_tuple(-2, -2)), (std::make_tuple(-3, -2))) == (""NO""));
}
"
HumanEval/128,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንተ ሙሉ ቁጥሮች አንድ ቬክተር ተሰጥቶሃል እና በ 1, -1 ወይም 0 የተወከለው ቬክተር ውስጥ እያንዳንዱ ቁጥር ሁሉ ምልክቶች ምርት በ ሙሉ ቁጥሮች መጠን ድምር መመለስ ይኖርብናል. ማስታወሻ: ባዶ arr ምንም ተመላሽ. ምሳሌ: >>> prod_signs(((std::vector<long>{(long) 1, (long) 2, (long) 2, (long) -4}))) 9 >>> prod_signs(std::vector<long>({(long) 0, (long) 1}))) 0 >>> prod_signs((std::vector<long>(())) std::nopt
std::optional<long> prod_signs(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>

std::optional<long> prod_signs(std::vector<long> arr) {
  if (arr.empty()) {
    return std::nullopt;
  }
  long sum_magnitudes = 0;
  long product_of_signs = 1;
  for (long num : arr) {
    sum_magnitudes += std::abs(num);
    if (num > 0) {
      product_of_signs *= 1;
    } else if (num < 0) {
      product_of_signs *= -1;
    } else {
      product_of_signs *= 0;
    }
  }
  return sum_magnitudes * product_of_signs;
}","}
int main() {
    auto candidate = prod_signs;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4}))) == -9);
    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);
    assert(candidate((std::vector<long>())) == std::nullopt);
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)-1, (long)1}))) == 4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)1}))) == -4);
    assert(candidate((std::vector<long>({(long)-1, (long)1, (long)1, (long)0}))) == 0);
}
"
HumanEval/129,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// N ረድፎች እና N አምዶች (N >= 2) እና አዎንታዊ የሆነ k ሙሉ ቁጥር ያለው ፍርግርግ ሲሰጥ እያንዳንዱ ፍርግርግ እሴት ይይዛል. [1, N * N] ጨምሮ እያንዳንዱ ሙሉ ቁጥር በፍርግርግ ውስጥ ባሉ ህዋሳት ላይ አንድ ጊዜ በትክክል ይታያል. በ ፍርግርግ ውስጥ ያለውን k ርዝመት ያለው አነስተኛውን መንገድ መፈለግ አለብዎት. ከማንኛውም ህዋስ መጀመር ይችላሉ, እና በእያንዳንዱ ደረጃ ወደ ማንኛውም ጎረቤት ህዋስ መሄድ ይችላሉ, በሌላ አነጋገር, ከአሁኑ ህዋስ ጋር ጠርዝ ወደሚያጋሩ ህዋሳት መሄድ ይችላሉ. እባክዎ ልብ ይበሉ k ርዝመት ያለው መንገድ ማለት k ህዋሶችን በትክክል መጎብኘት ማለት ነው (በተለይም የተለየ አይደለም). ከግሪድ መውጣት አይችሉም. A (የ k ርዝመት) መንገድ A እና B (የ k ርዝመት) ከሚሄዱት ህዋሶች ላይ የተደረደሩ ቬክተሮች ከተደረደሩ በኋላ ከ B (የ k) መንገድ ያነሰ ነው (እነሱን እንጥራቸው l_stA እና l_stB) ፣ l_stA በ lexographically ከ l_stB ያነሰ ነው ፣ በሌላ አነጋገር ፣ i_j = l_j_j_j_j_j_j_j_j (i <1A <= i_j_j_j_j_j_j) እና i_j <= l_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j_j
std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {
  int n = grid.size();
  std::vector<long> min_path;

  std::function<void(int, int, std::vector<long>)> dfs = 
    [&](int row, int col, std::vector<long> current_path) {
    if (current_path.size() == k) {
      if (min_path.empty() || current_path < min_path) {
        min_path = current_path;
      }
      return;
    }

    current_path.push_back(grid[row][col]);

    int dr= {-1, 1, 0, 0};
    int dc= {0, 0, -1, 1};

    for (int i = 0; i < 4; ++i) {
      int next_row = row + dr[i];
      int next_col = col + dc[i];
      if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {
        dfs(next_row, next_col, current_path);
      }
    }
  };

  for (int start_row = 0; start_row < n; ++start_row) {
    for (int start_col = 0; start_col < n; ++start_col) {
      dfs(start_row, start_col, {});
    }
  }

  return min_path;
}","}
int main() {
    auto candidate = minPath;
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) == (std::vector<long>({(long)1, (long)2, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) == (std::vector<long>({(long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6, (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11, (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15, (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16, (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1, (long)10, (long)1, (long)10, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8, (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4, (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7, (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10, (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1, (long)7, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16, (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8, (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6, (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}), (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) == (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1, (long)5})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1, (long)2})));
    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10)) == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1, (long)3})));
}
"
HumanEval/130,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁሉም ሰው የፊቦናቺን ቅደም ተከተል ያውቃል ፣ ባለፉት ሁለት መቶ ዓመታት ውስጥ በሂሳብ ሊቃውንት በጥልቀት የተጠና ነበር ። ሆኖም ሰዎች የማያውቁት የቲሪቦናቺ ቅደም ተከተል ነው ። የቲሪቦናቺ ቅደም ተከተል የሚገለጸው በመደጋገም ነው: tri(1) = 3 tri(n) = 1 + n / 2 ፣ n እኩል ከሆነ ፣ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ፣ n ያልተለመደ ከሆነ ለምሳሌ: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 አሉታዊ ያልሆነ አጠቃላይ ቁጥር n ተሰጥቶዎታል ፣ የቲሪቦናቺን ቅደም ተከተል የመጀመሪያዎቹን n + 1 ቬክተር መመለስ አለብዎት ። ምሳሌዎች: >>> (((((3)) (dst ረዥም ቬክተር> (<((((1 ፣ (<((3) (<((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<long> tri(long n) {
","#include <assert.h>
#include <bits/stdc++.h>

std::vector<long> tri(long n) {
  std::vector<long> result;
  if (n >= 0) {
    result.push_back(1);
  }
  if (n >= 1) {
    result.push_back(3);
  }
  for (long i = 2; i <= n; ++i) {
    if (i % 2 == 0) {
      result.push_back(1 + i / 2);
    } else {
      if (i - 1 >= 0 && i - 2 >= 0 && i + 1 <= n)
      {
          result.push_back(result[i-1] + result[i-2] + result[i]);
      }
      else if (i - 1 >= 0 && i - 2 >= 0)
      {
          result.push_back(result[i-1] + result[i-2]);
      }
      else if (i - 1 >= 0)
      {
          result.push_back(result[i-1]);
      }
      else
      {
          result.push_back(0);
      }
    }
  }
  return result;
}","}
int main() {
    auto candidate = tri;
    assert(candidate((3)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8})));
    assert(candidate((4)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3})));
    assert(candidate((5)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15})));
    assert(candidate((6)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4})));
    assert(candidate((7)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24})));
    assert(candidate((8)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5})));
    assert(candidate((9)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35})));
    assert(candidate((20)) == (std::vector<long>({(long)1, (long)3, (long)2, (long)8, (long)3, (long)15, (long)4, (long)24, (long)5, (long)35, (long)6, (long)48, (long)7, (long)63, (long)8, (long)80, (long)9, (long)99, (long)10, (long)120, (long)11})));
    assert(candidate((0)) == (std::vector<long>({(long)1})));
    assert(candidate((1)) == (std::vector<long>({(long)1, (long)3})));
}
"
HumanEval/131,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ አዎንታዊ ቁጥር n ከተሰጠ ፣ የዝቅተኛ አሃዞችን ውጤት ይመልሱ ። ሁሉም አሃዞች እኩል ከሆኑ 0 ይመልሱ ። ለምሳሌ: >>> አሃዞች (((1)) (1) >>> አሃዞች (((4)) (0) >>> አሃዞች (((235)) (15)
long digits(long n) {
","#include<assert.h>
#include<bits/stdc++.h>
long digits(long n) {
  long product = 1;
  std::string s = std::to_string(n);
  bool has_odd = false;
  for (char c : s) {
    long digit = c - '0';
    if (digit % 2 != 0) {
      product *= digit;
      has_odd = true;
    }
  }
  if (!has_odd) {
    return 0;
  }
  return product;
}","}
int main() {
    auto candidate = digits;
    assert(candidate((5)) == (5));
    assert(candidate((54)) == (5));
    assert(candidate((120)) == (1));
    assert(candidate((5014)) == (5));
    assert(candidate((98765)) == (315));
    assert(candidate((5576543)) == (2625));
    assert(candidate((2468)) == (0));
}
"
HumanEval/132,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ብቻ ካሬ ቅንፍ የያዘ አንድ ሕብረቁምፊ እንደ ግብዓት የሚወስድ ተግባር ይፍጠሩ. ተግባር እውነተኛ መመለስ አለበት እና ብቻ ከሆነ በቅንፍ ውስጥ ቢያንስ አንድ ቅንፍ የተጠለፉ የት ቅንፍ አንድ ትክክለኛ subsequence አለ ከሆነ. >>> is_nested((""[[]]"")) (እውነት) >>> is_nested((""[]]]]]]]][[[[[]"")) (ሐሰት) >>> is_nested((""[][]"")) (ሐሰት) >>> is_nested((""[]"")) (ሐሰት) >>> is_nested(""[[]]"") (እውነት) >>> is_nested(""[[]]"") (እውነት)
bool is_nested(std::string string) {
","#include<assert.h>
#include<bits/stdc++.h>
bool is_nested(std::string string) {
  int balance = 0;
  bool nested = false;
  for (char c : string) {
    if (c == '[') {
      balance++;
    } else if (c == ']') {
      if (balance > 1) {
        nested = true;
      }
      balance--;
      if (balance < 0) {
        return false;
      }
    }
  }
  return balance == 0 && nested;
}","}
int main() {
    auto candidate = is_nested;
    assert(candidate((""[[]]"")) == (true));
    assert(candidate((""[]]]]]]][[[[[]"")) == (false));
    assert(candidate((""[][]"")) == (false));
    assert(candidate((""[]"")) == (false));
    assert(candidate((""[[[[]]]]"")) == (true));
    assert(candidate((""[]]]]]]]]]]"")) == (false));
    assert(candidate((""[][][[]]"")) == (true));
    assert(candidate((""[[]"")) == (false));
    assert(candidate((""[]]"")) == (false));
    assert(candidate((""[[]][["")) == (true));
    assert(candidate((""[[][]]"")) == (true));
    assert(candidate(("""")) == (false));
    assert(candidate((""[[[[[[[["")) == (false));
    assert(candidate((""]]]]]]]]"")) == (false));
}
"
HumanEval/133,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁጥሮች ቬክተር ተሰጥቶሃል:: የቁጥሮች ካሬ ድምርን በቬክተሩ ውስጥ መመለስ አለብህ:: በመጀመሪያ በቬክተሩ ውስጥ ያሉትን እያንዳንዱን ንጥረ ነገሮች ወደላይኛው int (ላይኛው) አክብድ:: ምሳሌዎች: >>> lst (ላይኛው):: vector (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው) <float> (ላይኛው <float>float>float>float> (float>float>float>float>float>float>float>float>float>float>float>float>float>float>float>float>float>float>float>float>
long sum_squares(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
long sum_squares(std::vector<float> lst) {
  long sum = 0;
  for (float num : lst) {
    long rounded_up = std::ceil(num);
    sum += rounded_up * rounded_up;
  }
  return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f}))) == (14));
    assert(candidate((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84));
    assert(candidate((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f}))) == (29));
    assert(candidate((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6));
    assert(candidate((std::vector<float>({(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230));
    assert(candidate((std::vector<float>({(float)10000.0f, (float)10000.0f}))) == (200000000));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75));
    assert(candidate((std::vector<float>({(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086));
    assert(candidate((std::vector<float>({(float)0.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f}))) == (1));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2));
}
"
HumanEval/134,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠውን ሰንሰለት የመጨረሻው ቁምፊ የአልፋቤት ቁምፊ ከሆነ እና የቃላት አካል ካልሆነ እና በሌላ መንገድ ሐሰት ከሆነ እውነት የሚመልስ ተግባር ይፍጠሩ. ማስታወሻ: ""ቃል"" በቦታ የተለዩ የቁምፊዎች ቡድን ነው. ምሳሌዎች: >>> check_if_last_char_is_a_letter ((((""apple pie"")) (ሐሰት) >>> check_if_last_char_is_a_letter (((""apple pi e"")) (እውነት) >>> check_if_last_char_is_a_letter (((""apple pi e)) (ሐሰት) >>> check_if_last_char_is_a_letter ((("")) (ሐሰት)
bool check_if_last_char_is_a_letter(std::string txt) {
","#include<assert.h>
#include<bits/stdc++.h>
bool check_if_last_char_is_a_letter(std::string txt) {
  if (txt.empty()) {
    return false;
  }
  if (!isalpha(txt.back())) {
    return false;
  }
  if (txt.length() > 1 && txt[txt.length() - 2] != ' ') {
    return false;
  }
  return true;
}","}
int main() {
    auto candidate = check_if_last_char_is_a_letter;
    assert(candidate((""apple"")) == (false));
    assert(candidate((""apple pi e"")) == (true));
    assert(candidate((""eeeee"")) == (false));
    assert(candidate((""A"")) == (true));
    assert(candidate((""Pumpkin pie "")) == (false));
    assert(candidate((""Pumpkin pie 1"")) == (false));
    assert(candidate(("""")) == (false));
    assert(candidate((""eeeee e "")) == (false));
    assert(candidate((""apple pie"")) == (false));
    assert(candidate((""apple pi e "")) == (false));
}
"
HumanEval/135,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ከቀዳሚው አካል ጋር የማይበልጥ ወይም የማይመጣጠን ትልቁን መረጃ ጠቋሚ የሚመልስ ተግባር ይፍጠሩ. እንደዚህ ያለ አካል ከሌለ ከዚያ ይመለሱ -1. የተሰጠው ቬክተር የተባዙ እሴቶችን አይይዝም. ምሳሌዎች: >>> can_arrange((std::vector<long>({long) 1, (long) 2, (long) 4, (long) 3, (long) 5}))) (3) >>> can_arrange((std::vector<long>{(long) 1, (long) 2, (long) 3}))) (-1)
long can_arrange(std::vector<long> arr) {
","#include<assert.h>
#include<bits/stdc++.h>
long can_arrange(std::vector<long> arr) {
  for (long i = 1; i < arr.size(); ++i) {
    if (arr[i] < arr[i - 1]) {
      return i;
    }
  }
  return -1;
}","}
int main() {
    auto candidate = can_arrange;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5}))) == (3));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)4, (long)5}))) == (-1));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)2, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10}))) == (2));
    assert(candidate((std::vector<long>({(long)4, (long)8, (long)5, (long)7, (long)3}))) == (4));
    assert(candidate((std::vector<long>())) == (-1));
}
"
HumanEval/136,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሀ፣ ለ የሚመልስ ተግባር ይፍጠሩ፣ ሀ በቬክተር ውስጥ ካሉ አሉታዊ ሙሉ ቁጥሮች ትልቁ ሲሆን፣ ለ ደግሞ ከ አዎንታዊ ሙሉ ቁጥሮች ትንሹ ነው። አሉታዊ ወይም አዎንታዊ ሙሉ ቁጥሮች ከሌሉ እንደ None ይመልሱ። ምሳሌዎች: >>> largest_smallest_integers((std::vector<long>{long>) 2, (long) 4, (long) 1, (long) 3, (long) 5, (long) 7}))) std::make_tuplestd::optional<long>(std::nopt), std::optional<long>) >>> largest_smallest_integers(((std::vector<long>))) std::optional<long> (<long>)
std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<tuple>
#include<vector>

std::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {
    std::optional<long> largest_negative = std::nullopt;
    std::optional<long> smallest_positive = std::nullopt;
    for (long num : lst) {
        if (num < 0) {
            if (!largest_negative.has_value() || num > largest_negative.value()) {
                largest_negative = num;
            }
        } else if (num > 0) {
            if (!smallest_positive.has_value() || num < smallest_positive.value()) {
                smallest_positive = num;
            }
        }
    }
    return std::make_tuple(largest_negative, smallest_positive);
}","}
int main() {
    auto candidate = largest_smallest_integers;
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7, (long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1)));
    assert(candidate((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)-2}))) == std::make_tuple(-2, 1));
    assert(candidate((std::vector<long>({(long)4, (long)5, (long)3, (long)6, (long)2, (long)7, (long)-7}))) == std::make_tuple(-7, 2));
    assert(candidate((std::vector<long>({(long)7, (long)3, (long)8, (long)4, (long)9, (long)2, (long)5, (long)-9}))) == std::make_tuple(-9, 2));
    assert(candidate((std::vector<long>())) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)0}))) == std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)-5, (long)-6, (long)0}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>(std::nullopt)));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)1}))) == std::make_tuple(-3, 1));
    assert(candidate((std::vector<long>({(long)-6, (long)-4, (long)-4, (long)-3, (long)-100, (long)1}))) == std::make_tuple(-3, 1));
}
"
HumanEval/137,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }    bool operator==(float f) {
        return f1 == f ;
    }    bool operator==(std::string f) {
        return f2 == f ;
    }    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};
// እውነተኛ ቁጥሮች የሚወክሉ ኢንቲጀሮችን፣ ፍሎተዎችን ወይም ሰንሰለቶችን የሚወስድ እና የተሰጠውን ተለዋዋጭ አይነት ውስጥ ትልቁን ተለዋዋጭ የሚመልስ ተግባር ይፍጠሩ። እሴቶቹ እኩል ከሆኑ ምንም አይመልሱም ማስታወሻ: እውነተኛ ቁጥር እንደ ሰንሰለት ከተወከለው ተለዋዋጭ ነጥብ ሊሆን ይችላል . ወይም , >>> compare_one(1, 2.5f) 2.5f >>> compare_one(1, ""2,3"") ""2,3"" >>> compare_one(""5,1"", ""6"") ""6"" >>> compare_one(""1"", 1) std::nullopt
Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<optional>
#include<string>

union Union_long_float_std_string{
    long f0;
    float f1;
    std::string f2;
    Union_long_float_std_string(long _f0) : f0(_f0) {}
    Union_long_float_std_string(float _f1) : f1(_f1) {}
    Union_long_float_std_string(std::string _f2) : f2(_f2) {}
    ~Union_long_float_std_string() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
};
union Union_long_float_std_string_std_nullopt{
    long f0;
    float f1;
    std::string f2;
    std::nullopt f3;
    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}
    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}
    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}
    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}
    ~Union_long_float_std_string_std_nullopt() {}
    bool operator==(long f) {
        return f0 == f ;
    }
    bool operator==(float f) {
        return f1 == f ;
    }
    bool operator==(std::string f) {
        return f2 == f ;
    }
    bool operator==(std::nullopt f) {
        return f3 == f ;
    }
};

double parse_real(const std::string& s) {
    std::string temp = s;
    std::replace(temp.begin(), temp.end(), ',', '.');
    try {
        return std::stod(temp);
    } catch (const std::invalid_argument& e) {
        return std::numeric_limits<double>::quiet_NaN();
    } catch (const std::out_of_range& e) {
        return std::numeric_limits<double>::quiet_NaN();
    }
}

Union_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {
    if (a.f2.empty() && b.f2.empty()) {
        if (typeid(a.f0) == typeid(long) && typeid(b.f0) == typeid(long)) {
            if (a.f0 > b.f0) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f0 > a.f0) return Union_long_float_std_string_std_nullopt(b.f0);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f1) == typeid(float)) {
            if (a.f1 > b.f1) return Union_long_float_std_string_std_nullopt(a.f1);
            if (b.f1 > a.f1) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f0) == typeid(long) && typeid(b.f1) == typeid(float)) {
            if (static_cast<float>(a.f0) > b.f1) return Union_long_float_std_string_std_nullopt(a.f0);
            if (b.f1 > static_cast<float>(a.f0)) return Union_long_float_std_string_std_nullopt(b.f1);
        } else if (typeid(a.f1) == typeid(float) && typeid(b.f0) == typeid(long)) {
            if (a.f1 > static_cast<float>(b.f0)) return Union_long_float_std_string_std_nullopt(a.f1);
            if (static_cast<float>(b.f0) > a.f1) return Union_long_float_std_string_std_nullopt(b.f0);
        }
    } else {
        double val_a, val_b;
        if (!a.f2.empty()) val_a = parse_real(a.f2);
        else if (typeid(a.f0) == typeid(long)) val_a = static_cast<double>(a.f0);
        else val_a = static_cast<double>(a.f1);

        if (!b.f2.empty()) val_b = parse_real(b.f2);
        else if (typeid(b.f0) == typeid(long)) val_b = static_cast<double>(b.f0);
        else val_b = static_cast<double>(b.f1);

        if (!std::isnan(val_a) && !std::isnan(val_b)) {
            if (val_a > val_b) return Union_long_float_std_string_std_nullopt(a);
            if (val_b > val_a) return Union_long_float_std_string_std_nullopt(b);
        }
    }
    return Union_long_float_std_string_std_nullopt(std::nullopt{});
}","}
int main() {
    auto candidate = compare_one;
    assert(candidate(1, 2) == 2);
    assert(candidate(1, 2.5f) == 2.5f);
    assert(candidate(2, 3) == 3);
    assert(candidate(5, 6) == 6);
    assert(candidate(1, ""2,3"") == ""2,3"");
    assert(candidate(""5,1"", ""6"") == ""6"");
    assert(candidate(""1"", ""2"") == ""2"");
    assert(candidate(""1"", 1) == std::nullopt);
}
"
HumanEval/138,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠው ቁጥር n በትክክል የ 4 አዎንታዊ የቁጥር ቁጥሮች ድምር ሆኖ ሊፃፍ ይችል እንደሆነ ይገምግሙ ምሳሌ >>> is_equal_to_sum_even ((4)) (ሐሰት) >>> is_equal_to_sum_even ((6)) (ሐሰት) >>> is_equal_to_sum_even ((8)) (እውነት)
bool is_equal_to_sum_even(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_equal_to_sum_even(long n) {
    if (n <= 6 || n % 2 != 0) {
        return false;
    }
    return true;
}","}
int main() {
    auto candidate = is_equal_to_sum_even;
    assert(candidate((4)) == (false));
    assert(candidate((6)) == (false));
    assert(candidate((8)) == (true));
    assert(candidate((10)) == (true));
    assert(candidate((11)) == (false));
    assert(candidate((12)) == (true));
    assert(candidate((13)) == (false));
    assert(candidate((16)) == (true));
}
"
HumanEval/139,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የብራዚል ፋክቶሪያል እንዲህ ተብሎ ተገልጿል: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! n > 0 ለምሳሌ: >>> special_factorial((4)) (288) ተግባር እንደ ግብዓት አንድ ሙሉ ቁጥር ይቀበላል እና የዚህን ሙሉ ቁጥር ልዩ ፋክቶሪያል መመለስ አለበት.
long special_factorial(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long factorial(long k) {
    long res = 1;
    for (long i = 2; i <= k; ++i) {
        res *= i;
    }
    return res;
}

long special_factorial(long n) {
    if (n <= 0) {
        return 1;
    }
    long result = 1;
    for (long i = 1; i <= n; ++i) {
        result *= factorial(i);
    }
    return result;
}","}
int main() {
    auto candidate = special_factorial;
    assert(candidate((4)) == (288));
    assert(candidate((5)) == (34560));
    assert(candidate((7)) == (125411328000));
    assert(candidate((1)) == (1));
}
"
HumanEval/140,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ የጽሑፍ ሰንሰለት ከተሰጠ ፣ በውስጡ ያሉትን ሁሉንም ክፍተቶች በግርጌ ምልክት ይተኩ ፣ እና አንድ ሰንሰለት ከ 2 በላይ ተከታታይ ክፍተቶች ካሉት ፣ ከዚያ ሁሉንም ተከታታይ ክፍተቶች በ - >>> fix_spaces ((("" ምሳሌ "")) (""ምሳሌ"") >>> fix_spaces ((("" ምሳሌ 1 "")) (""ምሳሌ_1"") >>> fix_spaces ((("" ምሳሌ 2"")) (""_ምሳሌ_2"") >>> fix_spaces ((("" ምሳሌ 3"")) (""_ምሳሌ-3"")
std::string fix_spaces(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string fix_spaces(std::string text) {
    std::string result = """";
    int space_count = 0;
    for (char c : text) {
        if (c == ' ') {
            space_count++;
        } else {
            if (space_count == 1) {
                result += '_';
            } else if (space_count > 1) {
                result += '-';
            }
            result += c;
            space_count = 0;
        }
    }
    if (space_count == 1 && !result.empty() && result.back() != '_') {
        result += '_';
    } else if (space_count > 1 && !result.empty() && result.back() != '-') {
        result += '-';
    } else if (space_count > 0 && result.empty()) {
        if (space_count > 2) result += '-';
        else if (space_count == 1) result += '_';
    } else if (space_count == 1 && result.empty()) {
        result += '_';
    }

    std::string trimmed_result = """";
    bool non_space_found = false;
    for (char c : result) {
        if (c != ' ') {
            non_space_found = true;
            trimmed_result += c;
        } else if (non_space_found) {
            trimmed_result += c;
        }
    }

    while (!trimmed_result.empty() && trimmed_result.front() == '_') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '_') {
        trimmed_result.pop_back();
    }
     while (!trimmed_result.empty() && trimmed_result.front() == '-') {
        trimmed_result.erase(trimmed_result.begin());
    }
    while (!trimmed_result.empty() && trimmed_result.back() == '-') {
        trimmed_result.pop_back();
    }

    std::string final_result = """";
    space_count = 0;
    for (char c : trimmed_result) {
        if (c == '_') {
            space_count++;
        } else {
            if (space_count == 1) {
                final_result += '_';
            } else if (space_count > 1) {
                final_result += '-';
            }
            final_result += c;
            space_count = 0;
        }
    }
    if (space_count == 1) {
        final_result += '_';
    } else if (space_count > 1) {
        final_result += '-';
    }

    return final_result;
}","}
int main() {
    auto candidate = fix_spaces;
    assert(candidate((""Example"")) == (""Example""));
    assert(candidate((""Mudasir Hanif "")) == (""Mudasir_Hanif_""));
    assert(candidate((""Yellow Yellow  Dirty  Fellow"")) == (""Yellow_Yellow__Dirty__Fellow""));
    assert(candidate((""Exa   mple"")) == (""Exa-mple""));
    assert(candidate((""   Exa 1 2 2 mple"")) == (""-Exa_1_2_2_mple""));
}
"
HumanEval/141,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የፋይል ስም የሚወክል ሕብረቁምፊ የሚወስድ ተግባር ይፍጠሩ፣ እና የፋይሉ ስም ትክክለኛ ከሆነ 'አዎ' ይመልሳል፣ እና አለበለዚያ 'አይደለም' ይመልሳል። የፋይል ስም ትክክለኛ እንደሆነ የሚወሰነው የሚከተሉት ሁኔታዎች በሙሉ ከተሟሉ ብቻ ነው:- በፋይሉ ስም ውስጥ ከሶስት በላይ አሃዞች ('0'-'9') ሊኖሩ አይገባም። - የፋይሉ ስም በትክክል አንድ ነጥብ '.' ይዟል። - ከዶቱ በፊት ያለው ንዑስ ሕብረቁምፊ ባዶ መሆን የለበትም፣ እና ከላቲን ፊደል ፊደል ('a'-'z' እና 'A'-Z') ይጀምራል - ከዶቱ በኋላ ያለው ንዑስ ሕብረቁምፊ ከእነዚህ ውስጥ አንዱ መሆን አለበት: ['txt', 'exe', 'll'] ምሳሌዎች: >>> file_name_check""{""{""{""}""{""}""{""}""{""}""{""}""{""}""{""}""{""}""}""{""}""{""}""}""{""}""}""{""}""}""{""}""}""}""{""}""}""}""}""
std::string file_name_check(std::string file_name) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string file_name_check(std::string file_name) {
    int digit_count = 0;
    int dot_count = 0;
    size_t dot_pos = std::string::npos;

    for (size_t i = 0; i < file_name.length(); ++i) {
        if (isdigit(file_name[i])) {
            digit_count++;
        } else if (file_name[i] == '.') {
            dot_count++;
            dot_pos = i;
        }
    }

    if (digit_count > 3 || dot_count != 1) {
        return ""No"";
    }

    if (dot_pos == 0 || dot_pos == file_name.length() - 1) {
        return ""No"";
    }

    std::string name_part = file_name.substr(0, dot_pos);
    std::string ext_part = file_name.substr(dot_pos + 1);

    if (name_part.empty() || !isalpha(name_part[0])) {
        return ""No"";
    }

    if (ext_part == ""txt"" || ext_part == ""exe"" || ext_part == ""dll"") {
        return ""Yes"";
    } else {
        return ""No"";
    }
}","}
int main() {
    auto candidate = file_name_check;
    assert(candidate((""example.txt"")) == (""Yes""));
    assert(candidate((""1example.dll"")) == (""No""));
    assert(candidate((""s1sdf3.asd"")) == (""No""));
    assert(candidate((""K.dll"")) == (""Yes""));
    assert(candidate((""MY16FILE3.exe"")) == (""Yes""));
    assert(candidate((""His12FILE94.exe"")) == (""No""));
    assert(candidate((""_Y.txt"")) == (""No""));
    assert(candidate((""?aREYA.exe"")) == (""No""));
    assert(candidate((""/this_is_valid.dll"")) == (""No""));
    assert(candidate((""this_is_valid.wow"")) == (""No""));
    assert(candidate((""this_is_valid.txt"")) == (""Yes""));
    assert(candidate((""this_is_valid.txtexe"")) == (""No""));
    assert(candidate((""#this2_i4s_5valid.ten"")) == (""No""));
    assert(candidate((""@this1_is6_valid.exe"")) == (""No""));
    assert(candidate((""this_is_12valid.6exe4.txt"")) == (""No""));
    assert(candidate((""all.exe.txt"")) == (""No""));
    assert(candidate((""I563_No.exe"")) == (""Yes""));
    assert(candidate((""Is3youfault.txt"")) == (""Yes""));
    assert(candidate((""no_one#knows.dll"")) == (""Yes""));
    assert(candidate((""1I563_Yes3.exe"")) == (""No""));
    assert(candidate((""I563_Yes3.txtt"")) == (""No""));
    assert(candidate((""final..txt"")) == (""No""));
    assert(candidate((""final132"")) == (""No""));
    assert(candidate((""_f4indsartal132."")) == (""No""));
    assert(candidate(("".txt"")) == (""No""));
    assert(candidate((""s."")) == (""No""));
}
"
HumanEval/142,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// "" ይህ ተግባር የሙሉ ቁጥሮች ቬክተር ይወስዳል። በቬክተሩ ውስጥ ላሉት ሁሉም ግቤቶች፣ ተግባሩ የሙሉ ቁጥር ግቤቱን ካሬ ያደርገዋል ኢንዴክሱ የ3 ብዙ ከሆነ እና የሙሉ ቁጥር ግቤቱን ካቢ ያደርገዋል ኢንዴክሱ የ4 ብዙ ከሆነ እና የ3 ብዙ ካልሆነ። ተግባሩ በቬክተሩ ውስጥ ያሉትን ግቤቶች አይለውጥም ኢንዴክሶቻቸው የ3 ወይም የ4 ብዙ ካልሆኑ ተግባሩ ከዚያ የሁሉም ግቤቶች ድምር ይመልሳል። ምሳሌዎች: >>> lst (long({(long) 1, (long) 2, (long) 3})) >>> lst ((long)) >>> lst ({(long) -1, (long) -5, (long) 2, (long) -1, (long) -5}))
long sum_squares(std::vector<long> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_squares(std::vector<long> lst) {
    long sum = 0;
    for (size_t i = 0; i < lst.size(); ++i) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}","}
int main() {
    auto candidate = sum_squares;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3}))) == (6));
    assert(candidate((std::vector<long>({(long)1, (long)4, (long)9}))) == (14));
    assert(candidate((std::vector<long>())) == (0));
    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1, (long)1}))) == (9));
    assert(candidate((std::vector<long>({(long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1, (long)-1}))) == (-3));
    assert(candidate((std::vector<long>({(long)0}))) == (0));
    assert(candidate((std::vector<long>({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))) == (-126));
    assert(candidate((std::vector<long>({(long)-56, (long)-99, (long)1, (long)0, (long)-2}))) == (3030));
    assert(candidate((std::vector<long>({(long)-1, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)0, (long)-1}))) == (0));
    assert(candidate((std::vector<long>({(long)-16, (long)-9, (long)-2, (long)36, (long)36, (long)26, (long)-20, (long)25, (long)-40, (long)20, (long)-4, (long)12, (long)-26, (long)35, (long)37}))) == (-14196));
    assert(candidate((std::vector<long>({(long)-1, (long)-3, (long)17, (long)-1, (long)-15, (long)13, (long)-1, (long)14, (long)-14, (long)-12, (long)-5, (long)14, (long)-14, (long)6, (long)13, (long)11, (long)16, (long)16, (long)4, (long)10}))) == (-1448));
}
"
HumanEval/143,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ ዓረፍተ ነገር የሚወክል አንድ ሕብረቁምፊ ተሰጥቶሃል፣ ዓረፍተ ነገር በቦታ የተለዩ አንዳንድ ቃላትን ይዟል፣ እና ርዝመቶቹ የመጀመሪያ ቁጥሮች የሆኑትን ቃላት የያዘ ሕብረቁምፊ መመለስ አለብህ፣ በአዲሱ ሕብረቁምፊ ውስጥ ያሉት ቃላት ቅደም ተከተል ከመጀመሪያው ጋር ተመሳሳይ መሆን አለበት ምሳሌ 1: >>> words_in_sentence (((""This is a test"")) (""is"") ምሳሌ 2: >>> words_in_sentence (((""let go for swimming"")) (""go for"") ገደቦች: * 1 <= len ((sentence) <= 100 * ዓረፍተ ነገር ፊደላትን ብቻ ይዟል
std::string words_in_sentence(std::string sentence) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

std::string words_in_sentence(std::string sentence) {
    std::string result = """";
    std::stringstream ss(sentence);
    std::string word;
    while (ss >> word) {
        if (is_prime(word.length())) {
            if (!result.empty()) {
                result += "" "";
            }
            result += word;
        }
    }
    return result;
}","}
int main() {
    auto candidate = words_in_sentence;
    assert(candidate((""This is a test"")) == (""is""));
    assert(candidate((""lets go for swimming"")) == (""go for""));
    assert(candidate((""there is no place available here"")) == (""there is no place""));
    assert(candidate((""Hi I am Hussein"")) == (""Hi am Hussein""));
    assert(candidate((""go for it"")) == (""go for it""));
    assert(candidate((""here"")) == (""""));
    assert(candidate((""here is"")) == (""is""));
}
"
HumanEval/144,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የእርስዎ ተግባር x * n አገላለጽ ለማቅለል አንድ ተግባር ተግባራዊ ማድረግ ነው. ተግባር x * n አንድ ሙሉ ቁጥር እና ሐሰት ካልሆነ ይገመታል እውነት ይመለሳል. ሁለቱም x እና n, አንድ ክፍልፋይ ያለውን ሕብረቁምፊ ውክልና ናቸው, እና የሚከተለውን ቅርጸት, <numerator> / <denominator> ሁለቱም ቆጣሪ እና ጠቋሚ አዎንታዊ ሙሉ ቁጥሮች ናቸው የት አላቸው. አንተ x, እና n ትክክለኛ ክፍልፋዮች ናቸው ብሎ ማሰብ ይችላሉ, እና ጠቋሚ እንደ ዜሮ የላቸውም. >>> ቀላል ማድረግ ((""1/5""), (""5/1"")) (እውነት) >>> ቀላል ማድረግ ((""1/6""), (""2/1"") (ሐሰት) >>> ቀላል ማድረግ ((""7/10""), (""10/2"") (ሐሰት)
bool simplify(std::string x, std::string n) {
","#include<assert.h>
#include<bits/stdc++.h>

long gcd(long a, long b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

bool simplify(std::string x, std::string n) {
    long x_num, x_den, n_num, n_den;
    size_t slash_pos = x.find('/');
    x_num = std::stol(x.substr(0, slash_pos));
    x_den = std::stol(x.substr(slash_pos + 1));

    slash_pos = n.find('/');
    n_num = std::stol(n.substr(0, slash_pos));
    n_den = std::stol(n.substr(slash_pos + 1));

    long num = x_num * n_num;
    long den = x_den * n_den;

    long common_divisor = gcd(num, den);
    den /= common_divisor;

    return den == 1;
}","}
int main() {
    auto candidate = simplify;
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/6""), (""2/1"")) == (false));
    assert(candidate((""5/1""), (""3/1"")) == (true));
    assert(candidate((""7/10""), (""10/2"")) == (false));
    assert(candidate((""2/10""), (""50/10"")) == (true));
    assert(candidate((""7/2""), (""4/2"")) == (true));
    assert(candidate((""11/6""), (""6/1"")) == (true));
    assert(candidate((""2/3""), (""5/2"")) == (false));
    assert(candidate((""5/2""), (""3/5"")) == (false));
    assert(candidate((""2/4""), (""8/4"")) == (true));
    assert(candidate((""2/4""), (""4/2"")) == (true));
    assert(candidate((""1/5""), (""5/1"")) == (true));
    assert(candidate((""1/5""), (""1/5"")) == (false));
}
"
HumanEval/145,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠውን የቁጥር ቬክተር በቁጥር ድምር መሠረት በዝቅተኛ ቅደም ተከተል የሚደርደር ተግባር ይጻፉ ማስታወሻ: ተመሳሳይ የሆነ የቁጥር ድምር ያላቸው በርካታ ዕቃዎች ካሉ በዋናው ቬክተር ውስጥ ባለው መረጃ ጠቋሚ መሠረት ያደራጁ ለምሳሌ: >>> order_by_points((std::vector<long>({long) 1, (long) 11, (long) -1, (long) -1, (long) -12}))) (std::vector<long>({long) -1, (long) -11, (long) 1, (long) -12, (long) 11})) >>> order_by_points((std::vector<long>())) (std::vector<long>(long))
std::vector<long> order_by_points(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

long sum_digits(long n) {
    long sum = 0;
    std::string s = std::to_string(std::abs(n));
    for (char c : s) {
        sum += c - '0';
    }
    return sum;
}

std::vector<long> order_by_points(std::vector<long> nums) {
    std::vector<std::pair<long, size_t>> indexed_nums;
    for (size_t i = 0; i < nums.size(); ++i) {
        indexed_nums.push_back({nums[i], i});
    }

    std::sort(indexed_nums.begin(), indexed_nums.end(), [](const std::pair<long, size_t>& a, const std::pair<long, size_t>& b) {
        long sum_a = sum_digits(a.first);
        long sum_b = sum_digits(b.first);
        if (sum_a != sum_b) {
            return sum_a < sum_b;
        }
        return a.second < b.second;
    });

    std::vector<long> result;
    for (const auto& pair : indexed_nums) {
        result.push_back(pair.first);
    }
    return result;
}","}
int main() {
    auto candidate = order_by_points;
    assert(candidate((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12}))) == (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11})));
    assert(candidate((std::vector<long>({(long)1234, (long)423, (long)463, (long)145, (long)2, (long)423, (long)423, (long)53, (long)6, (long)37, (long)3457, (long)3, (long)56, (long)0, (long)46}))) == (std::vector<long>({(long)0, (long)2, (long)3, (long)6, (long)53, (long)423, (long)423, (long)423, (long)1234, (long)145, (long)37, (long)46, (long)56, (long)463, (long)3457})));
    assert(candidate((std::vector<long>())) == (std::vector<long>()));
    assert(candidate((std::vector<long>({(long)1, (long)-11, (long)-32, (long)43, (long)54, (long)-98, (long)2, (long)-3}))) == (std::vector<long>({(long)-3, (long)-32, (long)-98, (long)-11, (long)1, (long)2, (long)43, (long)54})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9, (long)10, (long)11}))) == (std::vector<long>({(long)1, (long)10, (long)2, (long)11, (long)3, (long)4, (long)5, (long)6, (long)7, (long)8, (long)9})));
    assert(candidate((std::vector<long>({(long)0, (long)6, (long)6, (long)-76, (long)-21, (long)23, (long)4}))) == (std::vector<long>({(long)-76, (long)-21, (long)0, (long)4, (long)23, (long)6, (long)6})));
}
"
HumanEval/146,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁጥሮች ቬክተር እንደ ግብዓት የሚወስድ እና በቬክተሩ ውስጥ ከ 10 የሚበልጡትን እና የአንድ ቁጥር የመጀመሪያ እና የመጨረሻ አሃዞች እኩል የሆኑትን የቁጥሮች ብዛት የሚመልስ ተግባር ይጻፉ (1, 3, 5, 7, 9) ለምሳሌ: >>> specialFilter((std::vector<long>({(long) 15, (long) -73, (long) -14, (long) -15}))) (1) >>> specialFilter((std::vector<long>({(long) 33, (long) -2, (long) -3, (long) -45, (long) 21, (long) 109} (2))))
long specialFilter(std::vector<long> nums) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_odd_digit(char c) {
    return (c == '1' || c == '3' || c == '5' || c == '7' || c == '9');
}

long specialFilter(std::vector<long> nums) {
    long count = 0;
    for (long num : nums) {
        if (std::abs(num) > 10) {
            std::string s = std::to_string(std::abs(num));
            if (!s.empty() && is_odd_digit(s.front()) && is_odd_digit(s.back())) {
                count++;
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = specialFilter;
    assert(candidate((std::vector<long>({(long)5, (long)-2, (long)1, (long)-5}))) == (0));
    assert(candidate((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15}))) == (1));
    assert(candidate((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109}))) == (2));
    assert(candidate((std::vector<long>({(long)43, (long)-12, (long)93, (long)125, (long)121, (long)109}))) == (4));
    assert(candidate((std::vector<long>({(long)71, (long)-2, (long)-33, (long)75, (long)21, (long)19}))) == (3));
    assert(candidate((std::vector<long>({(long)1}))) == (0));
    assert(candidate((std::vector<long>())) == (0));
}
"
HumanEval/147,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ አዎንታዊ ቁጥር n ተሰጥቶሃል. አንተ ርዝመት n አንድ ሙሉ ቁጥር ቬክተር መፍጠር አለብዎት. ለእያንዳንዱ i (1 ≤ i ≤ n), a [i] = i * i - i + 1. i < j < k, እና a [i] + a [j] + a [k] አንድ ሦስት እጥፍ ነው የት አንድ ሦስት እጥፍ ቁጥር (a [i], a [j], a [k]) ይመልሱ. ምሳሌ: >>> get_max_triples((5)) (1) ማብራሪያ: ሀ = [1, 3, 7, 13, 21] ብቸኛው ትክክለኛ ሶስቴ (1, 7, 13) ነው.
long get_max_triples(long n) {
","#include<assert.h>
#include<bits/stdc++.h>

long get_max_triples(long n) {
    if (n < 3) {
        return 0;
    }
    std::vector<long> a(n);
    for (long i = 0; i < n; ++i) {
        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;
    }

    long count = 0;
    for (long i = 0; i < n; ++i) {
        for (long j = i + 1; j < n; ++j) {
            for (long k = j + 1; k < n; ++k) {
                if ((a[i] + a[j] + a[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}","}
int main() {
    auto candidate = get_max_triples;
    assert(candidate((5)) == (1));
    assert(candidate((6)) == (4));
    assert(candidate((10)) == (36));
    assert(candidate((100)) == (53361));
}
"
HumanEval/148,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// በፀሐይ ስርዓታችን ውስጥ ስምንት ፕላኔቶች አሉ: ከፀሐይ በጣም ቅርብ የሆነው ሜርኩሪ ነው, ቀጣዩ ደግሞ ቬኑስ ነው, ከዚያም ምድር, ማርስ, ጁፒተር, ሳተርን, ኡራነስ, ኔፕቱን. ሁለት የፕላኔቶች ስሞች እንደ ፕላኔት 1 እና ፕላኔት 2 ያሉትን ሁለት የፕላኔቶች ስሞች የሚወስድ ተግባር ይጻፉ. ተግባሩ በፕላኔቶች መካከል ያለውን የፕላኔቶች ምህዋር እና የፕላኔቶች ምህዋር የያዘውን ሁሉንም ፕላኔቶች የያዘውን የፕላኔቶች ምህዋር መመለስ አለበት, ከፀሐይ ጋር ቅርበት. ፕላኔቶች ወይም ፕላኔቶች 2 ትክክለኛ የፕላኔቶች ስሞች ካልሆኑ ተግባሩ ባዶ የሆነ የፕላኔቶች ስብስብ መመለስ አለበት. ምሳሌዎች >>> bf (((""ጁፒተር"") ፣ (""ኔፕቱን"")) (std::vector<std::string>{(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
std::vector<std::string> bf(std::string planet1, std::string planet2) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> bf(std::string planet1, std::string planet2) {
    std::vector<std::string> planets = {""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    auto it1 = std::find(planets.begin(), planets.end(), planet1);
    auto it2 = std::find(planets.begin(), planets.end(), planet2);

    if (it1 == planets.end() || it2 == planets.end()) {
        return {};
    }

    int index1 = std::distance(planets.begin(), it1);
    int index2 = std::distance(planets.begin(), it2);

    if (index1 == index2) {
        return {};
    }

    int start = std::min(index1, index2) + 1;
    int end = std::max(index1, index2);

    std::vector<std::string> result;
    for (int i = start; i < end; ++i) {
        result.push_back(planets[i]);
    }
    return result;
}","}
int main() {
    auto candidate = bf;
    assert(candidate((""Jupiter""), (""Neptune"")) == (std::vector<std::string>({(std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Mercury"")) == (std::vector<std::string>({(std::string)""Venus""})));
    assert(candidate((""Mercury""), (""Uranus"")) == (std::vector<std::string>({(std::string)""Venus"", (std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn""})));
    assert(candidate((""Neptune""), (""Venus"")) == (std::vector<std::string>({(std::string)""Earth"", (std::string)""Mars"", (std::string)""Jupiter"", (std::string)""Saturn"", (std::string)""Uranus""})));
    assert(candidate((""Earth""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Mars""), (""Earth"")) == (std::vector<std::string>()));
    assert(candidate((""Jupiter""), (""Makemake"")) == (std::vector<std::string>()));
}
"
HumanEval/149,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁምፊዎች ቬክተር እንደ ፓራሜትር የሚቀበል ተግባር ይጻፉ ፣ ያልተለመዱ ርዝመቶች ያላቸውን ሕብረቁምፊዎች ይሰርዙ እና የተገኘውን ቬክተር በተደረደሩ ቅደም ተከተል ይመልሳሉ ፣ ቬክተሩ ሁል ጊዜ የቁምፊዎች ቬክተር ነው እና በጭራሽ የቁጥሮች ቬክተር አይደለም ፣ እና የተባዙ ነገሮችን ሊይዝ ይችላል። የቬክተሩ ቅደም ተከተል በእያንዳንዱ ቃል ርዝመት መነሳት አለበት ፣ እና ያንን ደንብ በመጠቀም የተደረደሩ ቬክተሩን መመለስ አለብዎት ። ሁለት ቃላት ተመሳሳይ ርዝመት ካላቸው ቬክተሩን በፊደል ቅደም ተከተል ይደርጁ ። ተግባሩ የተደረደሩ ሕብረቁምፊዎች ቬክተር መመለስ አለበት ። ሁሉም ቃላት ተመሳሳይ ርዝመት ይኖራቸዋል ብለው ሊገምቱ ይችላሉ ። ለምሳሌ: >>> list_sort{""}::stdvector{""}:stdvector{""}:stdvector{""}:stdvector{""}:stdvector{""}:stdvector{""}:stdvector{""}:stdvector{""dvector{""}:stdvector{""dvector}:stdvector{""dvector}:stdvector{""dvector""dvector""dve""dve""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d""d)
std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {
    std::vector<std::string> even_length_strings;
    for (const std::string& s : lst) {
        if (s.length() % 2 == 0) {
            even_length_strings.push_back(s);
        }
    }

    std::sort(even_length_strings.begin(), even_length_strings.end(), [](const std::string& a, const std::string& b) {
        if (a.length() != b.length()) {
            return a.length() < b.length();
        }
        return a < b;
    });

    return even_length_strings;
}","}
int main() {
    auto candidate = sorted_list_sum;
    assert(candidate((std::vector<std::string>({(std::string)""aa"", (std::string)""a"", (std::string)""aaa""}))) == (std::vector<std::string>({(std::string)""aa""})));
    assert(candidate((std::vector<std::string>({(std::string)""school"", (std::string)""AI"", (std::string)""asdf"", (std::string)""b""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""asdf"", (std::string)""school""})));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""b"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""d"", (std::string)""dcba"", (std::string)""abcd"", (std::string)""a""}))) == (std::vector<std::string>({(std::string)""abcd"", (std::string)""dcba""})));
    assert(candidate((std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""}))) == (std::vector<std::string>({(std::string)""AI"", (std::string)""ai"", (std::string)""au""})));
    assert(candidate((std::vector<std::string>({(std::string)""a"", (std::string)""b"", (std::string)""b"", (std::string)""c"", (std::string)""c"", (std::string)""a""}))) == (std::vector<std::string>()));
    assert(candidate((std::vector<std::string>({(std::string)""aaaa"", (std::string)""bbbb"", (std::string)""dd"", (std::string)""cc""}))) == (std::vector<std::string>({(std::string)""cc"", (std::string)""dd"", (std::string)""aaaa"", (std::string)""bbbb""})));
}
"
HumanEval/150,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// n ዋነኛ ቁጥር ከሆነ የ x ዋጋን መመለስ ያለበት እና አለበለዚያ የ y ዋጋን መመለስ ያለበት ቀላል ፕሮግራም ምሳሌዎች: >>> x_or_y((7), (34), (12)) (34) >>> x_or_y(15), (8), (5) (5)
long x_or_y(long n, long x, long y) {
","#include<assert.h>
#include<bits/stdc++.h>

bool is_prime(long n) {
    if (n <= 1) return false;
    for (long i = 2; i * i <= n; ++i) {
        if (n % i == 0) return false;
    }
    return true;
}

long x_or_y(long n, long x, long y) {
    if (is_prime(n)) {
        return x;
    } else {
        return y;
    }
}","}
int main() {
    auto candidate = x_or_y;
    assert(candidate((7), (34), (12)) == (34));
    assert(candidate((15), (8), (5)) == (5));
    assert(candidate((3), (33), (5212)) == (33));
    assert(candidate((1259), (3), (52)) == (3));
    assert(candidate((7919), (-1), (12)) == (-1));
    assert(candidate((3609), (1245), (583)) == (583));
    assert(candidate((91), (56), (129)) == (129));
    assert(candidate((6), (34), (1234)) == (1234));
    assert(candidate((1), (2), (0)) == (0));
    assert(candidate((2), (2), (0)) == (2));
}
"
HumanEval/151,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ቁጥሮች የተሰጡበት ቬክተር፣ በቬክተሩ ውስጥ ያሉትን ቁጥሮች ካሬዎች ድምር ይመልሱ፣ አሉታዊ የሆኑትን ቁጥሮች ችላ ይበሉ ወይም ሙሉ ቁጥሮች አይደሉም፣ >>> double_the_difference (እጥፍ_ልዩነት) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ (ረጅም) ፣ ረጅም))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
long double_the_difference(std::vector<float> lst) {
","#include<assert.h>
#include<bits/stdc++.h>

long double_the_difference(std::vector<float> lst) {
    long sum_of_squares = 0;
    for (float num : lst) {
        if (num > 0 && static_cast<long>(num) == num && static_cast<long>(num) % 2 != 0) {
            sum_of_squares += static_cast<long>(num) * static_cast<long>(num);
        }
    }
    return sum_of_squares;
}","}
int main() {
    auto candidate = double_the_difference;
    assert(candidate((std::vector<float>())) == (0));
    assert(candidate((std::vector<float>({(float)5.0f, (float)4.0f}))) == (25));
    assert(candidate((std::vector<float>({(float)0.1f, (float)0.2f, (float)0.3f}))) == (0));
    assert(candidate((std::vector<float>({(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0));
    assert(candidate((std::vector<float>({(float)0.2f, (float)3.0f, (float)5.0f}))) == (34));
    assert(candidate((std::vector<float>({(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165));
}
"
HumanEval/152,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የብዙ ጊዜ የተጠበቀው ክስተት ውጤት በመጨረሻ ሲታወቅ ሁላችንም ያንን ስሜት እናስታውሳለን ብዬ አስባለሁ ። በዚያ ቅጽበት ያጋጠሙዎት ስሜቶች እና ሀሳቦች በእርግጠኝነት ልብ ሊባል እና ሊወዳደሩ የሚገባቸው ናቸው ። የእርስዎ ተግባር አንድ ሰው የበርካታ ግጥሚያዎችን ውጤት በትክክል እንደገመተው መወሰን ነው ። እኩል ርዝመት ያላቸው ሁለት ውጤት እና ግምቶች የተሰጡዎት ናቸው ፣ እያንዳንዱ መረጃ ጠቋሚ ግጥሚያ የሚያሳይበት እያንዳንዱ መረጃ ጠቋሚ እኩል ርዝመት ያለው ቬክተር ይመለሳል እያንዳንዱ ግምት ምን ያህል ርቀት እንደነበረ የሚያመለክት ከሆነ እሴቱ 0 ነው ፣ ካልሆነ ግን እሴቱ በግምቱ እና በደረጃው መካከል ያለው ፍጹም ልዩነት ነው ። ለምሳሌ: >>>((longd::vector<(long>{(long) 1, (long) 2, (long) 3, (long) 4, (long) 5, (long) 1 ፣ (long) 2 ፣ (long) 2 ፣ (long) 0 ፣ (long) 3 ፣ (long) 0 ፣ (long) 4 ፣ (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long) (long
std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> compare(std::vector<long> game, std::vector<long> guess) {
    std::vector<long> diff;
    for (size_t i = 0; i < game.size(); ++i) {
        diff.push_back(std::abs(game[i] - guess[i]));
    }
    return diff;
}","}
int main() {
    auto candidate = compare;
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3})));
    assert(candidate((std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})), (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0}))) == (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)0, (long)0})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})), (std::vector<long>({(long)-1, (long)-2, (long)-3}))) == (std::vector<long>({(long)2, (long)4, (long)6})));
    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)5})), (std::vector<long>({(long)-1, (long)2, (long)3, (long)4}))) == (std::vector<long>({(long)2, (long)0, (long)0, (long)1})));
}
"
HumanEval/153,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የክፍል ስም (የአውታር) እና የተራዘመ የቬክተር ይሰጥዎታል. የተራዘመ ቅጥያዎች ተጨማሪ ክፍሎችን ወደ ክፍሉ ለመጫን ጥቅም ላይ ይውላሉ. የቅጥያው ጥንካሬ እንደሚከተለው ነው: CAP በቅጥያው ስም ውስጥ ያሉትን የከፍተኛ ፊደላት ቁጥር ይሁን, እና SM በቅጥያው ስም ውስጥ ያሉትን የትንሽ ፊደላት ቁጥር ይሁን, ጥንካሬው በ CAP - SM ክፍል ይሰጣል. በጣም ጠንካራውን ቅጥያ መፈለግ እና በዚህ ቅርጸት ውስጥ አንድ ሰንሰለት መመለስ አለብዎት: ClassName.StrongestExtensionName. ተመሳሳይ ጥንካሬ ያላቸው ሁለት ወይም ከዚያ በላይ ቅጥያዎች ካሉ, በቬክተሩ ውስጥ መጀመሪያ የሚመጣውን መምረጥ አለብዎት. ለምሳሌ, ""Slices"" እንደ ክፍል እና ቅጥያዎች ቬክተር ከተሰጡ: ['SErviSliNGCes'', 'Cheese', 'StuFed'] ከዚያ 'Slices.SErviSliNGCes' መመለስ አለብዎት:: 'myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:: myst:::: myst:::::::::::::::::::: myst::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
","#include<assert.h>
#include<bits/stdc++.h>

int calculate_strength(const std::string& extension) {
    int cap_count = 0;
    int sm_count = 0;
    for (char c : extension) {
        if (isupper(c)) {
            cap_count++;
        } else if (islower(c)) {
            sm_count++;
        }
    }
    return cap_count - sm_count;
}

std::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {
    if (extensions.empty()) {
        return class_name;
    }

    std::string strongest_extension = extensions[0];
    int max_strength = calculate_strength(extensions[0]);

    for (size_t i = 1; i < extensions.size(); ++i) {
        int current_strength = calculate_strength(extensions[i]);
        if (current_strength > max_strength) {
            max_strength = current_strength;
            strongest_extension = extensions[i];
        }
    }

    return class_name + ""."" + strongest_extension;
}","}
int main() {
    auto candidate = Strongest_Extension;
    assert(candidate((""Watashi""), (std::vector<std::string>({(std::string)""tEN"", (std::string)""niNE"", (std::string)""eIGHt8OKe""}))) == (""Watashi.eIGHt8OKe""));
    assert(candidate((""Boku123""), (std::vector<std::string>({(std::string)""nani"", (std::string)""NazeDa"", (std::string)""YEs.WeCaNe"", (std::string)""32145tggg""}))) == (""Boku123.YEs.WeCaNe""));
    assert(candidate((""__YESIMHERE""), (std::vector<std::string>({(std::string)""t"", (std::string)""eMptY"", (std::string)""nothing"", (std::string)""zeR00"", (std::string)""NuLl__"", (std::string)""123NoooneB321""}))) == (""__YESIMHERE.NuLl__""));
    assert(candidate((""K""), (std::vector<std::string>({(std::string)""Ta"", (std::string)""TAR"", (std::string)""t234An"", (std::string)""cosSo""}))) == (""K.TAR""));
    assert(candidate((""__HAHA""), (std::vector<std::string>({(std::string)""Tab"", (std::string)""123"", (std::string)""781345"", (std::string)""-_-""}))) == (""__HAHA.123""));
    assert(candidate((""YameRore""), (std::vector<std::string>({(std::string)""HhAas"", (std::string)""okIWILL123"", (std::string)""WorkOut"", (std::string)""Fails"", (std::string)""-_-""}))) == (""YameRore.okIWILL123""));
    assert(candidate((""finNNalLLly""), (std::vector<std::string>({(std::string)""Die"", (std::string)""NowW"", (std::string)""Wow"", (std::string)""WoW""}))) == (""finNNalLLly.WoW""));
    assert(candidate((""_""), (std::vector<std::string>({(std::string)""Bb"", (std::string)""91245""}))) == (""_.Bb""));
    assert(candidate((""Sp""), (std::vector<std::string>({(std::string)""671235"", (std::string)""Bb""}))) == (""Sp.671235""));
}
"
HumanEval/154,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// 2 ቃላት ተሰጥተውሃል:: ሁለተኛውን ቃል ወይም ከማንኛውም ዙር መዞሪያዎቹ የመጀመሪያውን ቃል ውስጥ ንዑስ ገመድ ከሆነ እውነት መመለስ አለብህ >>> cycpattern_check((""abcd""), (""abd"")) (false) >>> cycpattern_check((""hello""), (""ell"")) (true) >>> cycpattern_check((""whassup""), (""psus"")) (false) >>> cycpattern_check((""abab""), (""baa"")) (true) >>> cycpattern_(check""efef""), (""eeff"") cy (false) >>> cycpattern_check((""himens""), (""simen"") (true)
bool cycpattern_check(std::string a, std::string b) {
","#include<assert.h>
#include<bits/stdc++.h>

bool cycpattern_check(std::string a, std::string b) {
    if (b.empty()) {
        return true;
    }
    if (a.length() < b.length()) {
        return false;
    }
    for (int i = 0; i < b.length(); ++i) {
        std::rotate(b.begin(), b.begin() + 1, b.end());
        if (a.find(b) != std::string::npos) {
            return true;
        }
    }
    return false;
}","}
int main() {
    auto candidate = cycpattern_check;
    assert(candidate((""xyzw""), (""xyw"")) == (false));
    assert(candidate((""yello""), (""ell"")) == (true));
    assert(candidate((""whattup""), (""ptut"")) == (false));
    assert(candidate((""efef""), (""fee"")) == (true));
    assert(candidate((""abab""), (""aabb"")) == (false));
    assert(candidate((""winemtt""), (""tinem"")) == (true));
}
"
HumanEval/155,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሙሉ ቁጥር ከተሰጠ፣ በቅደም ተከተል የቁጥር ብዛት ያላቸው እና ያልተለመዱ ቁጥሮች ያሉት አንድ የቁጥር ብዛት ይመልሳል። ምሳሌ: >>> even_odd_count((-12)) (std::make_tuple(1, 1)) >>> even_odd_count((123)) (std::make_tuple(1, 2)
std::tuple<long, long> even_odd_count(long num) {
","#include<assert.h>
#include<bits/stdc++.h>
#include<tuple>

std::tuple<long, long> even_odd_count(long num) {
    long even_count = 0;
    long odd_count = 0;
    std::string s = std::to_string(std::abs(num));
    for (char c : s) {
        int digit = c - '0';
        if (digit % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    return std::make_tuple(even_count, odd_count);
}","}
int main() {
    auto candidate = even_odd_count;
    assert(candidate((7)) == (std::make_tuple(0, 1)));
    assert(candidate((-78)) == (std::make_tuple(1, 1)));
    assert(candidate((3452)) == (std::make_tuple(2, 2)));
    assert(candidate((346211)) == (std::make_tuple(3, 3)));
    assert(candidate((-345821)) == (std::make_tuple(3, 3)));
    assert(candidate((-2)) == (std::make_tuple(1, 0)));
    assert(candidate((-45347)) == (std::make_tuple(2, 3)));
    assert(candidate((0)) == (std::make_tuple(1, 0)));
}
"
HumanEval/156,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አዎንታዊ የሆነ ሙሉ ቁጥር ከተሰጠ፣ የሮማን አሃዝ ተመጣጣኝ የሆነውን እንደ ሰንሰለት ያግኙ፣ እና በትንሽ ፊደል ይመልሱት። ገደቦች: 1 <= num <= 1000 ምሳሌዎች: >>> int_to_mini_roman((19)) (""xix"") >>> int_to_mini_roman((152)) (""clii"") >>> int_to_mini_roman(426)) (""cdxxvi"")
std::string int_to_mini_roman(long number) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string int_to_mini_roman(long number) {
    std::string roman = """";
    std::vector<std::pair<int, std::string>> roman_map = {
        {1000, ""m""}, {900, ""cm""}, {500, ""d""}, {400, ""cd""}, {100, ""c""},
        {90, ""xc""}, {50, ""l""}, {40, ""xl""}, {10, ""x""}, {9, ""ix""}, {5, ""v""},
        {4, ""iv""}, {1, ""i""}
    };

    for (const auto& pair : roman_map) {
        while (number >= pair.first) {
            roman += pair.second;
            number -= pair.first;
        }
    }
    return roman;
}","}
int main() {
    auto candidate = int_to_mini_roman;
    assert(candidate((19)) == (""xix""));
    assert(candidate((152)) == (""clii""));
    assert(candidate((251)) == (""ccli""));
    assert(candidate((426)) == (""cdxxvi""));
    assert(candidate((500)) == (""d""));
    assert(candidate((1)) == (""i""));
    assert(candidate((4)) == (""iv""));
    assert(candidate((43)) == (""xliii""));
    assert(candidate((90)) == (""xc""));
    assert(candidate((94)) == (""xciv""));
    assert(candidate((532)) == (""dxxxii""));
    assert(candidate((900)) == (""cm""));
    assert(candidate((994)) == (""cmxciv""));
    assert(candidate((1000)) == (""m""));
}
"
HumanEval/157,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የሶስቱ ጎኖች ርዝመት ከተሰጠ የሶስት ጎኖች ርዝመት ከተሰጠ እውነት ይመልሳል ሶስት ጎኖች ቀኝ ማዕዘን ያለው ሶስት ማዕዘን ቢሆኑም ፣ ካልሆነ ግን ሐሰት ነው ። ቀኝ ማዕዘን ያለው ሶስት ማዕዘን አንድ ማእዘን ቀኝ ማዕዘን ወይም 90 ዲግሪ ያለው ሶስት ማዕዘን ነው ። ምሳሌ: >>> right_angle_triangle (((3), (4), (5)) (እውነት) >>> right_angle_triangle (((1), (2), (3)) (ሐሰት)
bool right_angle_triangle(long a, long b, long c) {
","#include<assert.h>
#include<bits/stdc++.h>

bool right_angle_triangle(long a, long b, long c) {
    std::vector<long> sides = {a, b, c};
    std::sort(sides.begin(), sides.end());
    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
}","}
int main() {
    auto candidate = right_angle_triangle;
    assert(candidate((3), (4), (5)) == (true));
    assert(candidate((1), (2), (3)) == (false));
    assert(candidate((10), (6), (8)) == (true));
    assert(candidate((2), (2), (2)) == (false));
    assert(candidate((7), (24), (25)) == (true));
    assert(candidate((10), (5), (7)) == (false));
    assert(candidate((5), (12), (13)) == (true));
    assert(candidate((15), (8), (17)) == (true));
    assert(candidate((48), (55), (73)) == (true));
    assert(candidate((1), (1), (1)) == (false));
    assert(candidate((2), (2), (10)) == (false));
}
"
HumanEval/158,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የቁምፊዎችን ቬክተር የሚቀበል ተግባር ይጻፉ ቬክተሩ የተለያዩ ቃላትን ይ containsል ። ከፍተኛውን ልዩ ቁምፊዎች ያሉት ቃል ይመልሱ ። በርካታ ሕብረቁምፊዎች ከፍተኛውን ልዩ ቁምፊዎች ካሉ በቅደም ተከተል የሚመጣውን ይመልሱ ። >>> find_max(std::vector<std::string>({(std::string) ""name"", (std::string) ""of"", (std::string) ""string""}))) (""string"") >>> find_max{(std::vector<std::string>({(std::string) ""name"", (std::string) ""enam"") >>> find_max{(std::string) ""game""} (""enam"") >>> find_max{(std::vector<std::string>{((stdaaaaaaa""}, (std::string) ""bbbb"" (""std::string""}) (""string""))
std::string find_max(std::vector<std::string> words) {
","#include<assert.h>
#include<bits/stdc++.h>

int count_unique_chars(const std::string& s) {
    std::set<char> unique_chars;
    for (char c : s) {
        unique_chars.insert(c);
    }
    return unique_chars.size();
}

std::string find_max(std::vector<std::string> words) {
    if (words.empty()) {
        return """";
    }

    std::string max_unique_word = words[0];
    int max_unique_count = count_unique_chars(words[0]);

    for (size_t i = 1; i < words.size(); ++i) {
        int current_unique_count = count_unique_chars(words[i]);
        if (current_unique_count > max_unique_count) {
            max_unique_count = current_unique_count;
            max_unique_word = words[i];
        } else if (current_unique_count == max_unique_count && words[i] < max_unique_word) {
            max_unique_word = words[i];
        }
    }
    return max_unique_word;
}","}
int main() {
    auto candidate = find_max;
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""of"", (std::string)""string""}))) == (""string""));
    assert(candidate((std::vector<std::string>({(std::string)""name"", (std::string)""enam"", (std::string)""game""}))) == (""enam""));
    assert(candidate((std::vector<std::string>({(std::string)""aaaaaaa"", (std::string)""bb"", (std::string)""cc""}))) == (""aaaaaaa""));
    assert(candidate((std::vector<std::string>({(std::string)""abc"", (std::string)""cba""}))) == (""abc""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""this"", (std::string)""game"", (std::string)""of"", (std::string)""footbott""}))) == (""footbott""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""gonna"", (std::string)""rock""}))) == (""gonna""));
    assert(candidate((std::vector<std::string>({(std::string)""we"", (std::string)""are"", (std::string)""a"", (std::string)""mad"", (std::string)""nation""}))) == (""nation""));
    assert(candidate((std::vector<std::string>({(std::string)""this"", (std::string)""is"", (std::string)""a"", (std::string)""prrk""}))) == (""this""));
    assert(candidate((std::vector<std::string>({(std::string)""b""}))) == (""b""));
    assert(candidate((std::vector<std::string>({(std::string)""play"", (std::string)""play"", (std::string)""play""}))) == (""play""));
}
"
HumanEval/159,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተራበ ጥንቸል ነዎት ፣ እናም የተወሰነ ቁጥር ያላቸው ካሮት በልተዋል ፣ ግን አሁን የቀኑን ምግብ ለማጠናቀቅ ተጨማሪ ካሮት መብላት ያስፈልግዎታል ። [ከመመገብዎ በኋላ የተበሉ ካሮት ብዛት ፣ ከምግብዎ በኋላ የቀሩ ካሮት ብዛት] አንድ ቬክተር መመለስ አለብዎት በቂ የቀሩ ካሮት ከሌሉ የቀሩትን ካሮት ሁሉ ትበላለህ ፣ ግን አሁንም ትራባለህ ። ምሳሌ: >>> eat((5), (6), (10)) (std::vector<long>{(()11, (long) 4})) >>> eat(4), (8), (9) (std::vector<long>{(() 12, ( (1})) eat >>>(1), (10), (10) (std::vector<long>{() 11, (long) 0)) eat >>>(2), (5) (std::vector<<long>{() 7, (long) 0)) @ የቁጥር ቁጥሮች: 0 @ የቁጥር ቁጥሮች: 1000 * የቁጥር ቁጥሮች: 0 @ የቁጥር ቁጥሮች: 1000 * የቁጥር ቁጥሮች: 0 @ የቁጥር ቁጥሮች: 1000 * የቁጥር ቁጥሮች: 0 @ የቁጥር ቁጥሮች: 1000 * የቁጥር ቁጥሮች: 0
std::vector<long> eat(long number, long need, long remaining) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> eat(long number, long need, long remaining) {
    long eaten = 0;
    long left = remaining;
    long to_eat = need;

    if (left >= to_eat) {
        eaten = to_eat;
        left -= to_eat;
    } else {
        eaten = left;
        left = 0;
    }

    return {(long)number + eaten, left};
}","}
int main() {
    auto candidate = eat;
    assert(candidate((5), (6), (10)) == (std::vector<long>({(long)11, (long)4})));
    assert(candidate((4), (8), (9)) == (std::vector<long>({(long)12, (long)1})));
    assert(candidate((1), (10), (10)) == (std::vector<long>({(long)11, (long)0})));
    assert(candidate((2), (11), (5)) == (std::vector<long>({(long)7, (long)0})));
    assert(candidate((4), (5), (7)) == (std::vector<long>({(long)9, (long)2})));
    assert(candidate((4), (5), (1)) == (std::vector<long>({(long)5, (long)0})));
}
"
HumanEval/160,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት ቬክተሮች ኦፕሬተር እና ኦፐራንድ ሲሰጡ የመጀመሪያው ቬክተር መሰረታዊ የአልጀብራ ስራዎች አሉት ሁለተኛው ቬክተር ደግሞ የሙሉ ቁጥሮች ቬክተር ነው የተሰጡትን ሁለት ቬክተሮች ተጠቅመው የአልጀብራ አገላለፅ ይገንቡ እና የዚህ አገላለፅ ግምገማ ይመልሱ መሰረታዊ የአልጀብራ ስራዎች ድምር (+) መቀነስ ()) - ማባዛት (*) ወለል ክፍፍል (//) ማስረጃ (**) ምሳሌ: ኦፕሬተር['+', '*', '-'] ቬክተር = [2, 3, 4, 5] ውጤት = 2 + 3 * 4 - 5 => ውጤት = 9 ማስታወሻ: የኦፕሬተር ቬክተር ርዝመት ከኦፕሬንት ቬክተር ርዝመት ጋር እኩል ነው ከ 1 ን ይጎድላል ኦፕሬተር ቬክተር ከ አሉታዊ ያልሆኑ ሙሉ ቁጥሮች ቬክተር ነው ኦፕሬተር ቬክተር ቢያንስ አንድ ኦፕሬተር አለው እና ኦፕሬተር ቬክተር ቢያንስ ሁለት ኦፕሬንዶች አሉት
long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
","#include<assert.h>
#include<bits/stdc++.h>

long do_algebra(std::vector<std::string> op, std::vector<long> operand) {
    std::vector<long> current_operand = operand;
    std::vector<std::string> current_operator = op;

    auto apply_op = [&](long a, long b, const std::string& o) {
        if (o == ""+"") return a + b;
        if (o == ""-"") return a - b;
        if (o == ""*"") return a * b;
        if (o == ""//"") return a / b;
        if (o == ""**"") return static_cast<long>(pow(a, b));
        return 0L; // Should not happen
    };

    std::vector<std::string> precedence1 = {""**""};
    std::vector<std::string> precedence2 = {""*"", ""//""};
    std::vector<std::string> precedence3 = {""+"", ""-""};

    auto evaluate = [&](const std::vector<std::string>& prec) {
        size_t i = 0;
        while (i < current_operator.size()) {
            bool found = false;
            for (const auto& o : prec) {
                if (current_operator[i] == o) {
                    current_operand[i] = apply_op(current_operand[i], current_operand[i + 1], current_operator[i]);
                    current_operand.erase(current_operand.begin() + i + 1);
                    current_operator.erase(current_operator.begin() + i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                i++;
            }
        }
    };

    evaluate(precedence1);
    evaluate(precedence2);
    evaluate(precedence3);

    return current_operand[0];
}","}
int main() {
    auto candidate = do_algebra;
    assert(candidate((std::vector<std::string>({(std::string)""**"", (std::string)""*"", (std::string)""+""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (37));
    assert(candidate((std::vector<std::string>({(std::string)""+"", (std::string)""*"", (std::string)""-""})), (std::vector<long>({(long)2, (long)3, (long)4, (long)5}))) == (9));
    assert(candidate((std::vector<std::string>({(std::string)""//"", (std::string)""*""})), (std::vector<long>({(long)7, (long)3, (long)4}))) == (8));
}
"
HumanEval/161,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// አንድ string s ተሰጥቶሃል s[i] ፊደል ከሆነ ካሴቱን ከታች ወደ ላይ ወይም በተቃራኒው ይለውጡት አለበለዚያ እንደነበረው ይተውት ።
std::string solve(std::string s) {
","#include<assert.h>
#include<bits/stdc++.h>

std::string solve(std::string s) {
    bool has_letter = false;
    for (char c : s) {
        if (isalpha(c)) {
            has_letter = true;
            break;
        }
    }

    if (has_letter) {
        for (char& c : s) {
            if (islower(c)) {
                c = toupper(c);
            } else if (isupper(c)) {
                c = tolower(c);
            }
        }
    } else {
        std::reverse(s.begin(), s.end());
    }
    return s;
}","}
int main() {
    auto candidate = solve;
    assert(candidate((""AsDf"")) == (""aSdF""));
    assert(candidate((""1234"")) == (""4321""));
    assert(candidate((""ab"")) == (""AB""));
    assert(candidate((""#a@C"")) == (""#A@c""));
    assert(candidate((""#AsdfW^45"")) == (""#aSDFw^45""));
    assert(candidate((""#6@2"")) == (""2@6#""));
    assert(candidate((""#$a^D"")) == (""#$A^d""));
    assert(candidate((""#ccc"")) == (""#CCC""));
}
"
HumanEval/162,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// የተሰጠው ሕብረቁምፊ 'ጽሑፍ'፣ የ md5 ሃሽ ተመጣጣኝ ሕብረቁምፊውን ይመልሱ። 'ጽሑፍ' ባዶ ሕብረቁምፊ ከሆነ፣ None ይመልሱ። >>> string_to_md5((""Hello world"")) ""3e25960a79dbc69b674cd4ec67a72c62""
std::optional<std::string> string_to_md5(std::string text) {
","#include<assert.h>
#include<bits/stdc++.h>
#include <optional>

#include <openssl/md5.h>
#include <iomanip>
#include <sstream>

std::optional<std::string> string_to_md5(std::string text) {
    if (text.empty()) {
        return std::nullopt;
    }

    unsigned char digest[MD5_DIGEST_LENGTH];
    MD5((unsigned char*)text.c_str(), text.length(), digest);

    std::stringstream ss;
    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];
    }
    return ss.str();
}","}
int main() {
    auto candidate = string_to_md5;
    assert(candidate((""Hello world"")) == ""3e25960a79dbc69b674cd4ec67a72c62"");
    assert(candidate(("""")) == std::nullopt);
    assert(candidate((""A B C"")) == ""0ef78513b0cb8cef12743f5aeb35f888"");
    assert(candidate((""password"")) == ""5f4dcc3b5aa765d61d8327deb882cf99"");
}
"
HumanEval/163,amh_Ethi,cpp,"#include<assert.h>
#include<bits/stdc++.h>
// ሁለት አዎንታዊ ሙሉ ቁጥሮች ሀ እና ለ የተሰጡ ከሆነ በ a እና በ b መካከል ያሉትን እኩል ቁጥሮች በማደግ ላይ ቅደም ተከተል ይመልሱ ። ለምሳሌ: >>> generate_integers (((2), (8)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8})) >>> generate_integers (((8), (2)) (std::vector<long> (((long) 2, (long) 4, (long) 6, (long) 8)) >>> generate_integers (((10), (14)) (std::vector<long> (())
std::vector<long> generate_integers(long a, long b) {
","#include<assert.h>
#include<bits/stdc++.h>

std::vector<long> generate_integers(long a, long b) {
    std::vector<long> result;
    long start = std::min(a, b);
    long end = std::max(a, b);
    for (long i = start; i <= end; ++i) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}","}
int main() {
    auto candidate = generate_integers;
    assert(candidate((2), (10)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((10), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((132), (2)) == (std::vector<long>({(long)2, (long)4, (long)6, (long)8})));
    assert(candidate((17), (89)) == (std::vector<long>()));
}
"
