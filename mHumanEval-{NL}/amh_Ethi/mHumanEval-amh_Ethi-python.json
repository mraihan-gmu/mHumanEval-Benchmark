[
    {
        "task_id": "HumanEval/0",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"በተሰጠው የቁጥሮች ዝርዝር ውስጥ ከተሰጠው ገደብ ይልቅ እርስ በእርስ የሚቀራረቡ ሁለት ቁጥሮች ካሉ ያረጋግጡ ምሳሌ: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) ሐሰት >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) እውነት \"\"\"\n",
        "canonical_solution": "for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/1",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"የዚህ ተግባር ግብዓት የተጣበቁ ቅንፎች በርካታ ቡድኖች የያዘ አንድ ሕብረቁምፊ ነው. የእርስዎ ግብ እነዚህ ቡድን በተናጠል ሕብረቁምፊዎች ወደ ለመለየት እና እነዚያ ዝርዝር መመለስ ነው. የተለያየ ቡድኖች ሚዛናዊ ናቸው (እያንዳንዱ ክፍት ቅንፍ በአግባቡ ዝግ ነው) እና እርስ በርስ ውስጥ የተጣበቁ አይደለም ማስገቢያ ሕብረቁምፊ ውስጥ ማንኛውም ክፍተቶች ችላ. ምሳሌ: >>> separate_paren_groups' ((()) (() (()))))))) ['() ', '(()) ', '((() ']\"\"\"\n",
        "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/2",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"አዎንታዊ የሆነ ተለዋዋጭ ነጥብ ቁጥር ከተሰጠ በኋላ ወደ ሙሉ ቁጥር ክፍል (ከቀረበው ቁጥር ያነሰ ትልቁ ሙሉ ቁጥር) እና አሥርዮሽ (ከቀሪው ክፍል ሁልጊዜ ከ 1 ያነሰ) ሊበታተን ይችላል ። የቁጥር አሥርዮሽ ክፍል ይመልሱ ምሳሌ: >>> truncate_number ((3.5) 0.5 \"\"\"\n",
        "canonical_solution": "    return number % 1.0\n",
        "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/3",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"በባንክ ሂሳብ ላይ ከዜሮ ሚዛን ጋር የሚጀምሩ ተቀማጭ እና የማስወገጃ ስራዎች ዝርዝር ተሰጥቶዎታል ። የእርስዎ ተግባር በማንኛውም ነጥብ ላይ የሂሳብ ሚዛን ከዜሮ በታች ቢወድቅ ማወቅ ነው ፣ እና በዚያ ነጥብ ላይ ተግባር እውነት መመለስ አለበት ። አለበለዚያ ሐሰት መመለስ አለበት ። ምሳሌ: >>> below_zero([1, 2, 3]) ሐሰት >>> below_zero([1, 2, -4, 5]) እውነት \"\"\"\n",
        "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/4",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"ለተሰጠ የግብዓት ቁጥሮች ዝርዝር ፣ በዚህ የውሂብ ስብስብ አማካይ ዙሪያ አማካይ ፍጹም መዛባት ያስሱ ። አማካይ ፍጹም መዛባት በእያንዳንዱ ንጥረ ነገር እና በማዕከላዊ ነጥብ መካከል ያለው አማካይ ፍጹም ልዩነት ነው (በዚህ ሁኔታ አማካይ): MAD = አማካይ ̋ x - x_mean ̋ ምሳሌ: >>> mean_absolute_deviation ([1.0, 2.0, 3.0, 4.0]) 1.0 \"\"\"\n",
        "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/5",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"በእያንዳንዱ ሁለት ተከታታይ የግብዓት ዝርዝር አካላት መካከል 'የመጠለያ' ቁጥር ያስገቡ `numbers' >>> intersperse (([], 4) [] >>> intersperse (([1, 2, 3], 4) [1, 4, 2, 4, 3] \"\"\"\n",
        "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/6",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"የዚህ ተግባር ግብዓት በቦታዎች የተለዩ የተጣበቁ ቅንፎች በርካታ ቡድኖችን የሚወክል ገመድ ነው ። ለእያንዳንዱ ቡድን ፣ የጥቅል ጥልቅ ጥልቅ ደረጃን ያስወጣል ። ለምሳሌ (() (()) ከፍተኛው ሁለት የጥቅል ደረጃዎች አሉት ፣ ((())) ደግሞ ሶስት አሉት ። >>> parse_nested_parens (('((()) ((())) (((()) (((()))) [2, 3, 1, 3] \"\"\"\n",
        "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/7",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"የተሰጠን ንዑስ ሰንሰለት የያዙትን ብቻ የሰንሰለት ዝርዝር ማጣራት >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if substring in x]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/8",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"ለተሰጠ የሙሉ ቁጥሮች ዝርዝር, ድምር እና በዝርዝር ውስጥ ያሉትን ሁሉንም ሙሉ ቁጥሮች ውጤት ያካተተ አንድ tuple ይመልሱ. ባዶ ድምር 0 እኩል መሆን አለበት እና ባዶ ምርት እኩል መሆን አለበት 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) \"\"\"\n",
        "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/9",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"ከተሰጠ የሙሉ ቁጥሮች ዝርዝር ውስጥ እስከ ተከታታይ ጊዜ ድረስ የተገኘውን ከፍተኛውን የማሽከርከር ንጥረ ነገር ዝርዝር ያመነጫል. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] \"\"\"\n",
        "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/10",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"ከተሰጠው ሕብረቁምፊ የሚጀምር አጭር palindrome ያግኙ. የአልጎሪዝም ሀሳብ ቀላል ነው: - ከተሰጠው ሕብረቁምፊ ውስጥ ረጅሙን የፖስትፊክስ ፓሊንድሮም ያግኙ. - ከፓሊንድሮም ቅጥያ በፊት የሚመጣውን የቁምፊ ቅጥያ የቁምፊ ቅጥያ ወደ ኋላው በሰንሰለት መጨረሻ ላይ ያክሉ. >>> make_palindrome ((('') ' ' >>> make_palindrome ((('cat') 'catac' >>> make_palindrome ((('catac') 'catac' \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"የተሰጠው ሕብረቁምፊ ፓሊንድሮም ከሆነ ይፈትሹ \"\"\"\n",
        "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/11",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"ግቤት ሁለት ሕብረቁምፊዎች ሀ እና ቢ ብቻ 1s እና 0s ያካተተ ነው. በእነዚህ ግብዓቶች ላይ ባይናሪ XOR ያከናውኑ እና ውጤቱን እንደ ሕብረቁምፊ ይመልሱ. >>> string_xor('010', '110') '100' \"\"\"\n",
        "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test": "def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/12",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"ከዝርዝሩ ውስጥ ረጅሙን ይመልሱ. ተመሳሳይ ርዝመት ያላቸው በርካታ ሕብረቁምፊዎች ካሉ የመጀመሪያውን ይመልሱ. የመግቢያ ዝርዝር ባዶ ከሆነ ምንም አይመልሱ. >>> ረጅሙ (([]) >>> ረጅሙ ((['a', 'b', 'c']) 'a' >>> ረጅሙ ((['a', 'bb', 'ccc']) 'ccc' \"\"\"\n",
        "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test": "def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/13",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"ሁለት ሙሉ ቁጥሮች ሀ እና ለ >>> ትልቁ_የጋራ_አከፋፋይ ((3, 5) 1 >>> ትልቁ_የጋራ_አከፋፋይ ((25, 15) 5 \"\"\"\n",
        "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n",
        "test": "def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/14",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"ወደ ግብዓት ሕብረቁምፊ ውስጥ አጭር ጀምሮ እስከ ረዥሙ ድረስ ሁሉም ቅድመ-ቅጥያዎች ዝርዝር ይመለሳል >>> all_prefixes (('abc') ['a', 'ab', 'abc'] \"\"\"\n",
        "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/15",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"ከ0 ጀምሮ እስከ n ድረስ ያሉ ቦታ-የተገደቡ ቁጥሮች የያዘውን ሰንሰለት ይመልሳል። >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' \"\"\"\n",
        "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test": "def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/16",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"አንድ ሕብረቁምፊ ከተሰጠ በኋላ ስንት የተለያዩ ቁምፊዎች (ከጉዳዩ ጋር ምንም ግንኙነት ሳይኖረው) እንደሚይዝ ለማወቅ >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 \"\"\"\n",
        "canonical_solution": "    return len(set(string.lower()))\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/17",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"ይህ ተግባር ግብዓት ልዩ ASCII ቅርጸት ውስጥ የሙዚቃ ማስታወሻዎች የሚወክሉ አንድ ሕብረቁምፊ ነው. የእርስዎ ተግባር በርካታ ምት ጋር የሚዛመድ integers ሕብረቁምፊ ዝርዝር ለመተንተን ነው: 'o' ማስታወሻ, ባለፈው አራት ምት 'o' ያስቀምጣል - ግማሽ ማስታወሻ, ባለፈው ሁለት ምት 'o' ያስቀምጣል - quater ማስታወሻ, ባለፈው አንድ ምት >>> parse_music '. 'o' ያስቀምጣል .\"\"\"\n",
        "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test": "def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/18",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"የተሰጠን ንዑስ ሰንሰለት በዋናው ሰንሰለት ውስጥ ስንት ጊዜ ማግኘት እንደሚቻል ያግኙ። የሚደጋገፉ ጉዳዮችን ይቁጠሩ. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 \"\"\"\n",
        "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test": "def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/19",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"ማስገቢያ ከ ‹ዜሮ› እስከ ‹ዘጠኝ› ድረስ የቁጥር ቁጥሮች በቦታ የተወሰነ ሰንሰለት ነው ። ትክክለኛ ምርጫዎች ‹ዜሮ› ፣ ‹አንድ› ፣ ‹ሁለት› ፣ ‹ሶስት› ፣ ‹አራት› ፣ ‹አምስት› ፣ ‹ስድስት› ፣ ‹ሰባት› ፣ ‹ስምንት› እና ‹ዘጠኝ› ናቸው ። ቁጥሮች ከትንሹ እስከ ትልቁ በተደረደሩ ቁጥሮች ጋር ሰንሰለት ይመልሱ >>> sort_numbers (('three one five') 'one three five' \"\"\"\n",
        "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/20",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"ከተሰጡት ቁጥሮች ዝርዝር (በአንድ ርዝመት ቢያንስ ሁለት) አንዱ ከሌላው ጋር በጣም ቅርብ የሆኑትን ሁለት ይምረጡ እና ይመልሱ እና በቅደም ተከተል ይመልሷቸው (ትንሽ ቁጥር ፣ ትልቅ ቁጥር) ። >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) \"\"\"\n",
        "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/21",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"ቁጥሮች ዝርዝር (ቢያንስ ሁለት ንጥረ ነገሮች), ይህ ዝርዝር ወደ አንድ መስመራዊ መለወጥ ተግባራዊ, እንዲህ ትንሹ ቁጥር ይሆናል 0 እና ትልቁ ይሆናል 1 >>> rescale_to_unit (([1.\"\"\"\n",
        "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n",
        "test": "def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/22",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"የተሰጠውን የፒቶን እሴቶች ዝርዝር ለጠቅላላ ቁጥሮች ብቻ ማጣራት >>> filter_integers ((['a', 3.14, 5]) [5] >>> filter_integers (([1, 2, 3, 'abc', {}, []]) [1, 2, 3] \"\"\"\n",
        "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/23",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"የተሰጠው ሕብረቁምፊ ርዝመት ተመለስ >>> strlen('') 0 >>> strlen('abc') 3 \"\"\"\n",
        "canonical_solution": "    return len(string)\n",
        "test": "def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/24",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"ለተሰጠ ቁጥር n፣ nን በእኩል የሚያከፋፍል ትልቁን ቁጥር ይፈልጉ፣ ከ n ያነሰ >>> ትልቁ_መከፋፈል ((15) 5 \"\"\"\n",
        "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test": "def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/25",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"የተሰጠውን ጠቅላላ ቁጥር ከትንሹ እስከ ትልቁ ባለው ቅደም ተከተል የዋናዎቹን ዝርዝር ይመልሱ. እያንዳንዱ የፋክተሮች ቁጥር በፋክተራይዜሽን ውስጥ ስንት ጊዜ እንደሚታይ ተመጣጣኝ ቁጥር ሊዘረዝር ይገባል. የመግቢያ ቁጥር ከሁሉም የፋክተሮች ውጤት ጋር እኩል መሆን አለበት >>> factorization ((8) [2, 2, 2] >>> factorization ((25) [5, 5] >>> factorization ((70) [2, 5, 7] \"\"\"\n",
        "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test": "def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/26",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"ከጠቅላላ ቁጥሮች ዝርዝር ውስጥ ከአንድ ጊዜ በላይ የሚከሰቱትን ሁሉንም ንጥረ ነገሮች ያስወግዱ. የንጥረ ነገሮች ቅደም ተከተል እንደ ግብዓት ተመሳሳይ ሆኖ ይቀራል። >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] \"\"\"\n",
        "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/27",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"ለተሰጠ ሰንሰለት፣ ትናንሽ ፊደላትን ወደ ትልቅ ፊደል እና ትልቅ ፊደላትን ወደ ትንሽ ፊደል ይለውጡ. >>> flip_case ((('Hello') 'HELLO' \"\"\"\n",
        "canonical_solution": "    return string.swapcase()\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/28",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"በአንድ ሰንሰለት ውስጥ የተጣመሩ የሰንሰለት ዝርዝር >>> concatenate([]) '' >>> concatenate(['a', 'b', 'c']) 'abc' \"\"\"\n",
        "canonical_solution": "    return ''.join(strings)\n",
        "test": "def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/29",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"የተሰጠውን ቅድመ-ቅጥያ የሚጀምሩትን ብቻ የቁምፊዎች ዝርዝር ማጣራት >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] \"\"\"\n",
        "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n",
        "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/30",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"በዝርዝሩ ውስጥ ያሉትን አዎንታዊ ቁጥሮች ብቻ ይመልሱ. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] \"\"\"\n",
        "canonical_solution": "    return [e for e in l if e > 0]\n",
        "test": "def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/31",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef is_prime(n):\n    \"\"\"የተሰጠው ቁጥር ዋና ከሆነ እውነት ይመልሳል ፣ አለበለዚያም ሐሰት ነው ። >>> is_prime(6) ሐሰት >>> is_prime(101) እውነት >>> is_prime(11) እውነት >>> is_prime(13441) እውነት >>> is_prime(61) እውነት >>> is_prime(4) ሐሰት >>> is_prime(1) ሐሰት \"\"\"\n",
        "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/32",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"xs የ polynomial ተባዮች ናቸው:: find_zero find x እንዲህ poly (((x) = 0. find_zero ብዙ ቢኖሩም እንኳ ዜሮ ነጥብ ብቻ ነው የሚመልሰው:: ከዚህም በላይ find_zero መፍትሄን ስለሚያስገኝ የቁጥር ብዛት ያላቸው እና ትልቁ ዜሮ ያልሆነ የቁጥር ብዛት ያላቸው የዝርዝር xs ብቻ ይወስዳል:: >>> round ((find_zero[(1, 2]), 2) # f (((x) = 1 + 2x -0.5 >>> round ((find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x ^ 2 + x ^ 3  1.0\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"በ x ነጥብ ላይ xs ንብረቶች ያለው ፖሊኖሚል ይገመግማል xs[0] + xs [1] * x + xs [1] * x ^ 2 + .... xs [n] * x ^ n \"\"\"\n",
        "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/33",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"ይህ ተግባር ዝርዝር ይወስዳል እና ዝርዝር ይመልሳል l' እንደዚህ ነው l' በሦስት የማይከፋፈሉ ኢንዴክሶች ውስጥ ከ l ጋር ተመሳሳይ ነው ፣ በሦስት የሚከፋፈሉ ኢንዴክሶች ላይ ያሉት እሴቶቹ ግን ከ l ተመጣጣኝ ኢንዴክሶች እሴቶች ጋር እኩል ናቸው ፣ ግን የተደረደሩ ናቸው ። >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] \"\"\"\n",
        "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/34",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef unique(l: list):\n    \"\"\"በዝርዝር ውስጥ የተደረደሩ ልዩ ልዩ ንጥረ ነገሮችን ይመልሳል >>> ልዩ (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] \"\"\"\n",
        "canonical_solution": "    return sorted(list(set(l)))\n",
        "test": "def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/35",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef max_element(l: list):\n    \"\"\"በዝርዝሩ ውስጥ ከፍተኛውን ንጥረ ነገር ይመልሱ. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10)) 123 \"\"\"\n",
        "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/36",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"የቁጥር 7 ቁጥር በ 11 ወይም በ 13 በሚከፋፈሉ ከ n በታች ባሉ ሙሉ ቁጥሮች ውስጥ የሚከሰትበትን ቁጥር ይመልሱ >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 \"\"\"\n",
        "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test": "def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/37",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"ይህ ተግባር ዝርዝር ይወስዳል እና ዝርዝር ይመልሳል l' እንደዚህ ነው l' ጋር ተመሳሳይ ነው l በዝቅተኛ ኢንዴክሶች ውስጥ ፣ በእኩል ኢንዴክሶች ላይ ያሉት እሴቶቹ ከ l እኩል ኢንዴክሶች እሴቶች ጋር እኩል ናቸው ፣ ግን የተደረደሩ ናቸው ። >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] \"\"\"\n",
        "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/38",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"በ encode_cyclic ተግባር የተመሰጠረውን የግብዓት ሕብረቁምፊ ይወስዳል. የተመሰጠረውን ሕብረቁምፊ ይመልሳል. \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\" የሶስት ቁምፊዎች ዑደት ቡድኖች በ ኮድ ሰንሰለት ይመልሳል.\"\"\"\n",
        "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/39",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib የፊቦናቺ ቁጥር የሆነ n-ኛ ቁጥርን ይመልሳል እንዲሁም እሱ ደግሞ ፕራይም ነው። >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 \"\"\"\n",
        "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test": "def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/40",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero የሙሉ ቁጥሮች ዝርዝር እንደ ግብዓት ይወስዳል:: በዝርዝሩ ውስጥ ሶስት የተለያዩ ንጥረ ነገሮች ቢኖሩ እውነት ይመልሳል ፣ እና ካልሆነ ግን ሐሰት ነው >>> triples_sum_to_zero([1, 3, 5, 0]) ሐሰት >>> triples_sum_to_zero[(1, 3, -2, 1]) እውነት >>> triples_sum_to_zero([1, 2, 3, 7]) ሐሰት >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) እውነት >>> triples_sum_to_zero[1]) ሐሰት \"\"\"\n",
        "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/41",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"አንድ መንገድ ፍጹም ቀጥ ያለ ያለ ረዥም መስመር ነው እንበል. n መኪናዎች ግራ ወደ ቀኝ እየነዱ ናቸው; በተመሳሳይ ጊዜ, n መኪናዎች የተለያዩ ስብስብ ቀኝ ወደ ግራ እየነዱ ናቸው. መኪናዎች ሁለት ስብስቦች እርስ በርሳቸው በጣም ሩቅ መሆን ይጀምራሉ. ሁሉም መኪናዎች ተመሳሳይ ፍጥነት ውስጥ ይንቀሳቀሳሉ. ሁለት መኪናዎች ግራ ወደ ቀኝ የሚንቀሳቀሱ መኪና ቀኝ ወደ ግራ የሚንቀሳቀሱ መኪና ይገጥመዋል ጊዜ ይጋጫሉ ይባላል. ይሁን እንጂ, መኪናዎች እጅግ ጠንካራ እና ጠንካራ ናቸው; በዚህም ምክንያት, እነርሱ ግጭት አይደለም እንደ ያላቸውን ትራክተሪ ውስጥ መንቀሳቀስ ይቀጥላሉ. ይህ ተግባር እንዲህ ግጭቶች ቁጥር ያስወጣል. \"\"\"\n",
        "canonical_solution": "    return n**2\n",
        "test": "def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/42",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"በ1 የተጨመሩ ንጥረ ነገሮች ያሉት ዝርዝር ይመለሳል >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] \"\"\"\n",
        "canonical_solution": "    return [(e + 1) for e in l]\n",
        "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/43",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero እንደ ግብዓት የሙሉ ቁጥሮች ዝርዝር ይወስዳል:: በዝርዝሩ ውስጥ ሁለት የተለያዩ ንጥረ ነገሮች ቢኖሩ እውነት ይመልሳል ፣ አለበለዚያ ግን ሐሰት ነው >>> pairs_sum_to_zero([1, 3, 5, 0]) ሐሰት >>> pairs_sum_to_zero[(1, 3, -2, 1]) ሐሰት >>> pairs_sum_to_zero([1, 2, 3, 7]) ሐሰት >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) እውነት >>> pairs_sum_to_zero[1]) ሐሰት \"\"\"\n",
        "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/44",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"የግብዓት ቁጥር x የቁጥር መሠረት ወደ መሠረት ይለውጡ. ከለውጡ በኋላ የሰንሰለት ውክልና ይመልሱ. የመሠረት ቁጥሮች ከ 10 ያነሱ ናቸው. >>> ለውጥ_መሠረት ((8, 3) '22' >>> ለውጥ_መሠረት ((8, 2) '1000' >>> ለውጥ_መሠረት ((7, 2) '111' \"\"\"\n",
        "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/45",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"ለሶስት ማዕዘን የጎን ርዝመት እና ከፍተኛ የመመለሻ አካባቢ የተሰጠው >>> triangle_area ((5, 3) 7.5 \"\"\"\n",
        "canonical_solution": "    return a * h / 2.0\n",
        "test": "def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/46",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef fib4(n: int):\n    \"\"\"የ Fib4 ቁጥር ቅደም ተከተል ከ Fibbonacci ቅደም ተከተል ጋር ተመሳሳይ የሆነ ቅደም ተከተል ነው ይህም እንደሚከተለው ተገልጻል: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). እባክዎን የ fib4 ቁጥር ቅደም ተከተል n-ኛ ንጥረ ነገር በብቃት ለማስላት አንድ ተግባር ይጻፉ. ተደጋጋሚነት አይጠቀሙ. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 \"\"\"\n",
        "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test": "def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/47",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef median(l: list):\n    \"\"\"በዝርዝሩ ውስጥ ያሉትን ንጥረ ነገሮች የመመለሻ ሚዲያ l. >>> ሚዲያ (([3, 1, 2, 4, 5]) 3 >>> ሚዲያ (([-10, 4, 6, 1000, 10, 20]) 15.0 \"\"\"\n",
        "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/48",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"የተሰጠው ሕብረቁምፊ ፓሊንድሮም ከሆነ ይፈትሻል >>> is_palindrome (('') እውነት ነው >>> is_palindrome (('aba') እውነት ነው >>> is_palindrome (('aaaaa') እውነት ነው >>> is_palindrome (('zbcd') ሐሰት \"\"\"\n",
        "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/49",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"2^n ሞዱሎ ፒ (ቁጥርን ማወቅ) ይመልሱ. >>> ሞዱል ፒ (3, 5) 3 >>> ሞዱል ፒ (0, 101) 1 >>> ሞዱል ፒ (3, 11) 8 >>> ሞዱል ፒ (100, 101) 1\"\"\"\n",
        "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test": "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/50",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"በ encode_shift ተግባር የተመሰጠረውን እንደ ግብዓት ሕብረቁምፊ ይወስዳል. የተመሰጠረውን ሕብረቁምፊ ይመልሳል. \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"እያንዳንዱን ፊደል በ5 በመቀየር የተቆጠረውን ሰንሰለት ይመልሳል።\"\"\"\n",
        "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test": "def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/51",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels የተባለው ተግባር የቃላት ሰንሰለት የሚወስድ እና ያለ ድምጽ ፊደላት ያለ ሰንሰለት የሚመልስ ተግባር ነው። >>> remove_vowels('') '' >>> remove_vowels(\"abcdef\\nghijklm\") 'bcdf\\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') ' ' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' \"\"\"\n",
        "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/52",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"ሁሉም ቁጥሮች ከቁጥር በታች ከሆኑ እውነት ይመልሱ t. >>> below_threshold (([1, 2, 4, 10], 100) እውነት >>> below_threshold (([1, 20, 4, 10], 5) ሐሰት \"\"\"\n",
        "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/53",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"ሁለት ቁጥሮች x እና y ይጨምሩ >>> ይጨምሩ ((2, 3) 5 >>> ይጨምሩ ((5, 7) 12 \"\"\"\n",
        "canonical_solution": "    return x + y\n",
        "test": "def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/54",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"ሁለት ቃላት ተመሳሳይ ቁምፊዎች እንዳሏቸው ያረጋግጡ. >>> same_chars (('eabcdzzzz', 'dddzzzzzzdeddabc') እውነት >>> same_chars (('abcd', 'dddddddabc') እውነት >>> same_chars (('dddddddabc', 'abcd') እውነት >>> same_chars (('eabcd', 'dddddddddabc') ሐሰት >>> same_chars ((('abcd', 'dddddddabddce') ሐሰት >>> same_chars (((abcdzzzz', 'dddzzzzzzdddabc') ሐሰት \"\"\"\n",
        "canonical_solution": "    return set(s0) == set(s1)\n",
        "test": "def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/55",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef fib(n: int):\n    \"\"\"n-ኛውን የፊቦናቺ ቁጥር ይመልሱ. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test": "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/56",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"<> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>\"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/57",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"እውነት ነው የሚለው የዝርዝር ንጥረ ነገሮች በሞኖቶኒክ እየጨመሩ ወይም እየቀነሱ ናቸው. >>> ሞኖቶኒክ (([1, 2, 4, 20]) እውነት >>> ሞኖቶኒክ (([1, 20, 4, 10]) ሐሰት >>> ሞኖቶኒክ (([4, 1, 0, -10]) እውነት \"\"\"\n",
        "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test": "def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/58",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"ለሁለት ዝርዝሮች የተደረደሩ ልዩ የጋራ ንጥረ ነገሮችን ይመልሳል. >>> የጋራ (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> የጋራ (([5, 3, 2, 8], [3, 2]) [2, 3] \"\"\"\n",
        "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test": "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/59",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"ትልቁን የ n ዋና ዋና አምሳያ ይመልሱ n > 1 እና ዋና አይደለም ብሎ ያስቡ. >>> ትልቁ_ዋና_ዋና_ዋና አምሳያ ((13195) 29 >>> ትልቁ_ዋና_ዋና አምሳያ ((2048) 2 \"\"\"\n",
        "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test": "def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/60",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n ከ1 እስከ n ያሉትን ቁጥሮች የሚደመር ተግባር ነው። >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 \"\"\"\n",
        "canonical_solution": "    return sum(range(n + 1))\n",
        "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/61",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets የ \"(\" እና \"\") ሰንሰለት ነው. እያንዳንዱ የመክፈቻ ቅንፍ የሚዛመድ የመዝጊያ ቅንፍ ካለው እውነት ይመለሳል. >>> correct_bracketing(\"(\") ሐሰት >>> correct_bracketing(\"() እውነት >>> correct_bracketing(\"() \") እውነት >>> correct_bracketing(\") ሐሰት \"\"\"\n",
        "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test": "def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/62",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs የ polynomial ተባባሪዎችን ይወክላል xs[0] + xs[1] * x + xs[2] * x^2 + .... የዚህን ፖሊኖሚየም ተዋጽኦ በተመሳሳይ መልክ ይመልሱ. >>> derivative (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> derivative[(1, 2, 3]) [2, 6] \"\"\"\n",
        "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/63",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"የ FibFib ቁጥር ቅደም ተከተል ከ Fibbonacci ቅደም ተከተል ጋር ተመሳሳይ የሆነ ቅደም ተከተል ነው ይህም እንደሚከተለው ተገልጻል: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). እባክዎን የ fibfib ቁጥር ቅደም ተከተል n-ኛ ንጥረ ነገር በብቃት ለማስላት አንድ ተግባር ይጻፉ. >>> fibfib(1) 0 >>> fib(5) 4 >>> fibfib(8) 24 \"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/64",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\nFIX = \"\"\"አንድን ቃል የሚወክል ገመድ እንደ ግብዓት የሚወስድ እና በገመድ ውስጥ ያሉትን የድምጽ ፊደላት ቁጥር የሚመልስ የድምጽ ፊደላት ይጻፉ። በዚህ ሁኔታ ውስጥ ድምጽ ፊደላት ‹a› ፣ ‹e› ፣ ‹i› ፣ ‹o› ፣ ‹u› ናቸው ። እዚህ ፣ ‹y› እንዲሁ ድምጽ ፊደል ነው ፣ ግን በተሰጠው ቃል መጨረሻ ላይ ብቻ ነው ። ምሳሌ: >>> vowels_count ((\"abcde\") 2 >>> vowels_count ((\"ACEDY\") 3 \"\"\"\n\ndef vowels_count(s):\n    \"\"\"ተጨማሪ የሙከራ ጉዳዮችን ያክሉ \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/65",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"የጠቅላላ ቁጥር x አሃዞችን በክብ ይዛወሩ፣ አሃዞቹን ወደ ቀኝ በማዛወር እና ውጤቱን እንደ ሰንሰለት ይመልሱ. shift > አሃዞች ቁጥር ከሆነ አሃዞችን በተቃራኒው ይመልሱ. >>> circular_shift(12, 1) \"21\" >>> circular_shift(12, 2) \"12\" \"\"\"\n",
        "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/66",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef digitSum(s):\n    \"\"\"ተግባር አንድን ሕብረቁምፊ እንደ ግብዓት የሚወስድ እና የላይኛዎቹን ቁምፊዎች ድምር ብቻ የሚመልስ ተግባር ይጻፉ' ASCII ኮዶች ምሳሌዎች: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153 \"\"\"\n",
        "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/67",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"በዚህ ተግባር ውስጥ, እናንተ አንድ ፍሬ ቅርጫት ውስጥ የሚሰራጭ መሆኑን ፖም እና ብርቱካናማዎች ቁጥር የሚወክል አንድ ሕብረቁምፊ ይሰጣቸዋል ይህ ቅርጫት ፖም, ብርቱካናማ, እና ማንጎ ፍሬዎች ይዟል. የ ፖም እና ፖም ጠቅላላ ቁጥር የሚወክል ሕብረቁምፊ እና ቅርጫት ውስጥ ፍሬዎች ጠቅላላ ቁጥር የሚወክል አንድ ኢንቲጀር የተሰጠው ቅርጫት ውስጥ ማንጎ ፍሬዎች ቁጥር ይመልሱ. ለምሳሌ ያህል: fruit_distribution\"5(ፖም እና 6 ብርቱካናማዎች\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 ፖም እና 1 ብርቱካናማዎች\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 ፖም እና 3 ብርቱካናማዎች\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 ፖም እና 1 ብርቱካናማዎች\",1 -> 120 - 100 - 1 = 19 \"\"\"\n",
        "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/68",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef pluck(arr):\n    \"\"\"\"አንድ ድርድር ያልተሳካ የሙሉ ቁጥር ኖዶች ያሉት አንድ ዛፍ ቅርንጫፍ የሚወክል ከሆነ ስራዎ አንዱን ኖዶች መምረጥ እና መመለስ ነው. የተመረጠው ኖድ አነስተኛውን እኩል ዋጋ ያለው ኖድ መሆን አለበት. ተመሳሳይ አነስተኛ እኩል ዋጋ ያላቸው በርካታ ኖዶች ከተገኙ አነስተኛውን መረጃ ጠቋሚ ያለው ኖድ መመለስ አለባቸው. የተመረጠው ኖድ በዝርዝር ውስጥ መመለስ አለበት, [small_value, its index]፣ ምንም እኩል እሴቶች ከሌሉ ወይም የተሰጠው ድርድር ባዶ ከሆነ, መልሰው []. ምሳሌ 1: ግብዓት: [4,2,3] ውፅዓት: [2, 1] ማብራሪያ: 2 አነስተኛውን እኩል ዋጋ አለው, እና 2 አነስተኛውን መረጃ ጠቋሚ አለው. ምሳሌ 2: ግብዓት: [1,2,3] ውፅዓት: [2, 1] ማብራሪያ: 2 አነስተኛውን እሴት አለው, እና 2 አነስተኛውን እኩል መረጃ ጠቋሚ አለው. ምሳሌ 3: ግብዓት: [] ውፅዓት: [4: 5] ግብዓት: [0, 3, 4] ውፅዓት: 1 [0, 0] ትንሹ ኖድ: 1 ትንሹ መረጃ ጠቋሚ አለው, ግን ሁለት እሴቶች አሉ. ስለዚህ የመጀመሪያውን እንመርጣለን: 1 ትንሹ እሴት አለው, ግን <= ዜሮስ ነው.\"\"\"\n",
        "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/69",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef search(lst):\n    '''አንተ አዎንታዊ integers አንድ ያልሆነ ባዶ ዝርዝር ተሰጥቶሃል. ከዜሮ በላይ ነው ትልቁን integer ይመልሱ, እና ይልቅ ወይም ራሱ integer ዋጋ እኩል የሆነ ድግግሞሽ አለው. አንድ integer ድግግሞሽ ይህ ዝርዝር ውስጥ ይታያል ጊዜ ቁጥር ነው. እንዲህ ያለ ዋጋ የለም ከሆነ, -1. ምሳሌዎች: ፍለጋ: (([4, 1, 2, 2, 3, 1]) == 2 (([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3 (([5, 5, 4, 4, 4]) == -1 '''\n",
        "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/70",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef strange_sort_list(lst):\n    '''የተሰጠ የሙሉ ቁጥሮች ዝርዝር፣ ዝርዝር በ እንግዳ ቅደም ተከተል ይመለሳል። እንግዳ ማቀናበር፣ በትንሹ ዋጋ ሲጀመር፣ ከዚያም በቀሪዎቹ ሙሉ ቁጥሮች ከፍተኛው፣ ከዚያም ዝቅተኛው እና የመሳሰሉት ናቸው። ምሳሌዎች: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [5, 5, 5, 5] strange_sort_list (([]) == [] '''\n",
        "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/71",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef triangle_area(a, b, c):\n    '''የሶስቱ ጎኖች ርዝመት ሲሰጥ የሶስቱ ጎኖች ርዝመት ይሰጣል የሶስቱ ጎኖች ትክክለኛ ባለሶስት ማዕዘን ከሆነ የሶስቱ ጎኖች አካባቢ ወደ 2 አሃዝ ነጥብ ተመላሽ ይደረጋል ካልሆነ -1 ይመለስ ሶስት ጎኖች ከማንኛውም ሁለት ጎኖች ድምር ከሶስተኛው ጎን የበለጠ ከሆነ ትክክለኛ ባለሶስት ማዕዘን ይሰራሉ ምሳሌ: triangle_area (3, 4, 5) == 6.00 triangle_area (1, 2, 10) == -1 '''\n",
        "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/72",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef will_it_fly(q,w):\n    '''የቁጥር q የሚበር ከሆነ እውነት የሚመልስ ተግባር ይጻፉ፣ ካልሆነ ግን ሐሰት የሚመልስ ተግባር ይጻፉ። የቁጥር q ሚዛናዊ ከሆነ (ፓሊንድሮም ዝርዝር ነው) እና የቁጥሮች ድምር ከከፍተኛው ሊኖር ከሚችለው ክብደት በታች ወይም እኩል ከሆነ ይበር ምሳሌ: will_it_fly (([1, 2], 5) â -> ሐሰት # 1+2 ከከፍተኛው ሊኖር ከሚችለው ክብደት ያነሰ ነው፣ ግን ሚዛናዊ አይደለም። will_it_fly (([3, 2, 3], 1) â -> ሐሰት # ሚዛናዊ ነው፣ ግን 3+2+3 ከከፍተኛው ሊኖር ከሚችለው ክብደት ይበልጣል። will_it_fly (([3, 2, 3], 9) â -> እውነት # 3+23 ከከፍተኛው ሊኖር ከሚችለው ክብደት ያነሰ ነው፣ እና ሚዛናዊ ነው። will_it_fly ((([3], â 5) -> እውነት # 3 ከከፍተኛው ሊኖር ከሚችለው ክብደት ያነሰ ነው፣ እና ሚዛናዊ ነው። '''\n",
        "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/73",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef smallest_change(arr):\n    \"\"\"አንድ ድርድር የተሰጠ ከሆነ፣ ድርድርን ፓሊንድሮም ለማድረግ የሚያስፈልጉትን አነስተኛ ቁጥር መለዋወጫዎች ይፈልጉ። ፓሊንድሮም ድርድር አንድ ድርድር ነው ወደ ኋላ እና ወደ ፊት ተመሳሳይ የሚነበብ። በአንድ ለውጥ ውስጥ አንድ ንጥረ ነገር ወደ ሌላ ማንኛውም ንጥረ ነገር መለወጥ ይችላሉ ለምሳሌ: ትንሹ_ለውጥ (([1,2,3,5,4,7,9,6]) == 4 ትንሹ_ለውጥ (([1, 2, 3, 4, 3, 2, 2]) == 1 ትንሹ_ለውጥ (([1, 2, 3, 2, 1]) == 0 \"\"\"\n",
        "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/74",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef total_match(lst1, lst2):\n    '''ሁለት የቁምፊዎች ዝርዝሮችን የሚቀበል እና ከሌላው ዝርዝር በታች በዝርዝሩ ውስጥ ባሉ ሁሉም ቁጥሮች ውስጥ አጠቃላይ የቁምፊዎች ብዛት ያለው ዝርዝር የሚመልስ ተግባር ይጻፉ። ሁለቱ ዝርዝሮች ተመሳሳይ ቁጥር ያላቸው ከሆነ የመጀመሪያውን ዝርዝር ይመልሱ ። ምሳሌዎች total_match (([], []) â -> [] total_match ((['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi'] total_match ((['hi', 'admin'], ['hi', 'admin', 'project']) â -> ['hi', 'admin'] total_match ((['hi', 'admin'], ['I', 'hi', 'hi']) â -> ['hI', 'hi'], 'hi'_match ((['4'], ['1'', '2'', '3'', '4' , '5' -> ['4'])'''\n",
        "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/75",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"የተሰጠው ቁጥር የ 3 ዋና ቁጥሮች ማባዛት ከሆነ እውነት የሆነ እና በሌላ መንገድ ሐሰት የሆነ ተግባር ይጻፉ። (ሀ) ከ 100 ያነሰ መሆኑን ማወቅ ምሳሌ: is_multiply_prime(30) == እውነት 30 = 2 * 3 * 5 \"\"\"\n",
        "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/76",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"የእርስዎ ተግባር ቁጥር x ቀላል ኃይል ከሆነ እውነት እና በሌሎች ሁኔታዎች ውስጥ ሐሰት የሚመለስ ተግባር መጻፍ ነው. x n ቀላል ኃይል ከሆነ x ነው ለምሳሌ: is_simple_power (n) ፣ 4) => እውነት ነው is_simple_power (n) ፣ 2) => እውነት ነው is_simple_power (n) ፣ 8) 2) => እውነት ነው is_simple_power (n) ፣ 2) => ሐሰት ነው is_simple_power (n) ፣ 3) => ሐሰት ነው\"\"\"\n",
        "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/77",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef iscube(a):\n    '''አንድ ሙሉ ቁጥር ሀን የሚወስድ እና እውነት የሚመልስ ተግባር ይጻፉ ይህ ኢንጌር የአንዳንድ ሙሉ ቁጥር ኩብ ከሆነ ማስታወሻ: ግብዓት ሁል ጊዜ ትክክለኛ ነው ብለው ሊገምቱ ይችላሉ ምሳሌዎች: iscube ((1) ==> እውነተኛ iscube ((2) ==> ሐሰተኛ iscube ((-1) ==> እውነተኛ iscube ((64) ==> እውነተኛ iscube ((0) ==> እውነተኛ iscube ((180) ==> ሐሰተኛ '''\n",
        "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/78",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef hex_key(num):\n    \"\"\"አንድ ተግባር እንዲጽፉ ተልዕኮ ተሰጥቷቸዋል ይህም የሃሳ አስር ቁጥርን እንደ አንድ ሕብረቁምፊ ይቀበላል እና የሃሳ አስር አሃዝ አሃዞችን ቁጥር ይቆጥራል (አንድ አሃዝ ወይም አሃዝ ከሁለት ትናንሽ የቁጥር ቁጥሮች ውጤት ያልሆነ ከ 1 የሚበልጥ የተፈጥሮ ቁጥር ነው) ። የሃሳ አስር አሃዞች ቁጥሮች 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ናቸው ። የጠቅላላ ቁጥሮች 2, 3, 5, 7, 11, 13, 17 ናቸው... ስለዚህ የሚከተሉትን አሃዞች ቁጥር መወሰን አለብዎት: 2, 3, 5, 7, B (= አሃዛዊ 11), D (= አሃዛዊ 13) ማስታወሻ: ግብዓት ሁልጊዜ ትክክል ወይም ባዶ ነው ብለው ሊገምቱ ይችላሉ ሕብረቁምፊ ፣ እና ምልክቶች A, B, C, D, E, F ሁልጊዜ ትልቅ ናቸው ። ምሳሌዎች: ለ num = AB ውጤቱ num = 1 መሆን አለበት ለ \"1077E\" ውጤቱ 2 መሆን አለበት ለ num = \"AB\" 1 መሆን አለበት ለ num = \"AB33\" መሆን አለበት ለ num = \"ABC\" መሆን አለበት ለ num = 4.67123456 መሆን አለበት ለ \"A\" መሆን አለበት ለ \"2020\" መሆን አለበት ለ \"2020\"\"\"\"\n",
        "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/79",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"አንተ አሃዝ አሃዝ ቅርጸት ይሰጣል እና ተግባር ሁለትዮሽ ቅርጸት ለመለወጥ ነው. ተግባር አንድ ሕብረቁምፊ መመለስ አለበት, እያንዳንዱ ቁምፊ አንድ ሁለትዮሽ ቁጥር የሚወክል ጋር. ሕብረቁምፊ ውስጥ እያንዳንዱ ቁምፊ '0' ወይም '1' ይሆናል. ሕብረቁምፊ መጀመሪያ ላይ እና መጨረሻ ላይ ተጨማሪ ቁምፊዎች 'db' አንድ ባልና ሚስት በዚያ ይሆናል. ተጨማሪ ቁምፊዎች ቅርጸት ጋር ለመርዳት አሉ. ምሳሌዎች: አሃዝ_ወደ_ሁለትዮሽ(15) # ይመለሳል \"db1111db\" አሃዝ_ወደ_ሁለትዮሽ32) # ይመለሳል \"db100000db\"\"\"\"\n",
        "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/80",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef is_happy(s):\n    \"\"\"አንድ string ደስተኛ ነው ወይም አይደለም. አንድ string ደስተኛ ነው ከሆነ ርዝመት ቢያንስ 3 ነው እና እያንዳንዱ 3 ተከታታይ ፊደላት የተለዩ ናቸው ለምሳሌ: is_happy (a) => ሐሰት is_happy (aa) => ሐሰት is_happy (abcd) => እውነት is_happy (aabb) => ሐሰት is_happy (adb) => እውነት is_happy (xyy) => ሐሰት \"\"\"\n",
        "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/81",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"ይህ የሴሚስተር የመጨረሻ ሳምንት ነው እና መምህሩ ተማሪዎች ወደ ደረጃ መስጠት አለበት. መምህሩ ደረጃ አሰጣጥ የራሷን ስልተ-ቀመር በማድረግ ቆይቷል. ብቸኛው ችግር እሷ እሷ ደረጃ አሰጣጥ ተጠቅሟል ኮድ አጥቷል ነው. እሷ አንዳንድ ተማሪዎች ለ GPAs ዝርዝር ሰጥቷል እና የሚከተለውን ሰንጠረዥ በመጠቀም ደብዳቤ ደረጃዎች ዝርዝር ውፅዓት የሚችል ተግባር መጻፍ አለብዎት: GPA  ደብዳቤ ደረጃ 4.0 A + > 3.7 A > 3.3 A- > 3.0 B + > 2.7 B- > 2.3 B- > 2.0 C + > 1.7 C > 1.3 C- > 1.0 D + > 0.7 D > 0.0 D- 0.0 E ምሳሌ: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n",
        "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/82",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef prime_length(string):\n    \"\"\"አንድ ሕብረቁምፊ የሚወስድ እና ሕብረቁምፊ ርዝመት ዋና ቁጥር ከሆነ እውነት ወይም ካልሆነ ሐሰት የሚመልስ ተግባር ይጻፉ ምሳሌዎች prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == ሐሰት \"\"\"\n",
        "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/83",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef starts_one_ends(n):\n    \"\"\"አንድ አዎንታዊ ሙሉ ቁጥር n ከተሰጠ, በ 1 የሚጀምሩ ወይም የሚያበቃ የ n-አሃዝ አዎንታዊ ሙሉ ቁጥሮች ብዛት ይመልሱ.\"\"\"\n",
        "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/84",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef solve(N):\n    \"\"\"አንድ አዎንታዊ ሙሉ ቁጥር N ከተሰጠ, የቁጥሮች ድምርን በሁለትዮሽ ይመለስ. ምሳሌ ለ N = 1000, የቁጥሮች ድምር 1 ይሆናል ውፅዓት \"1\" መሆን አለበት. ለ N = 150, የቁጥሮች ድምር 6 ይሆናል ውፅዓት \"110\" መሆን አለበት. ለ N = 147, የቁጥሮች ድምር 12 ይሆናል ውፅዓት \"1100\" መሆን አለበት. ተለዋዋጮች: @N ሙሉ ቁጥር ገደቦች: 0 â‰¤ N â‰¤ 10000. ውፅዓት: የሁለትዮሽ ቁጥር ሰንሰለት \"\"\"\n",
        "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/85",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef add(lst):\n    \"\"\"ባዶ ያልሆነ የሙሉ ቁጥሮች ዝርዝር ከተሰጠ lst በባዶ መረጃ ጠቋሚዎች ላይ ያሉትን እኩል ንጥረ ነገሮች ይጨምሩ . ምሳሌዎች: add (([4, 2, 6, 7]) ==> 2 \"\"\"\n",
        "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/86",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef anti_shuffle(s):\n    \"\"\"አንድ ሕብረቁምፊ የሚወስድ እና አንድ የታዘዘ ስሪት ይመልሳል አንድ ተግባር ይጻፉ. ሕብረቁምፊ የታዘዘ ስሪት, ሁሉም ቃላት (በቦታ ተለያይተው) አዲስ ቃል በ ተተክተዋል የት ሁሉ ቁምፊዎች ascii ዋጋ ላይ የተመሠረተ እየጨመረ ቅደም ተከተል ውስጥ የተደራጁ ናቸው. ማስታወሻ: አንተ ቃል እና ባዶ ቦታዎች ቅደም ተከተል መጠበቅ አለበት. ለምሳሌ: anti_shuffle ((('Hi') ይመልሳል 'Hi' anti_shuffle ((('hello') ይመልሳል 'ehllo' anti_shuffle (('Hello World!!!') ይመልሳል 'Hello !!!Wdlor' \"\"\"\n",
        "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/87",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef get_row(lst, x):\n    \"\"\"የ 2 ልኬት ውሂብ ተሰጥቶዎታል ፣ እንደ የተጣበቁ ዝርዝሮች ፣ ይህም እንደ ማትሪክስ ነው ፣ ሆኖም ግን ፣ እንደ ማትሪክስ ሳይሆን ፣ እያንዳንዱ ረድፍ የተለያዩ አምዶችን ሊይዝ ይችላል ። lst እና ኢንቲጀር x ከተሰጠ ፣ በዝርዝሩ ውስጥ ኢንቲጀሮችን ያግኙ ፣ እና የጉድጓዶች ዝርዝር ይመለሱ ፣ [(x1, y1), (x2, y2) ...] እያንዳንዱ ቱፕል አንድ መጋጠሚያ ነው - (የረድፍ ፣ አምዶች) ፣ ከ 0. ጋር በመጀመር መጋጠሚያዎችን በመጀመሪያ በረድፎች በዝቅተኛ ቅደም ተከተል ይደርጁ ። እንዲሁም ፣ የረድፍ መጋጠሚያዎችን በረድፎች በዝቅተኛ ቅደም ተከተል ይደርጁ ። ምሳሌዎች: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1] ], 1) == [0,0, 0, 0, 1, 4], 0 (1, 0), (2, 5), (2, 0) get_((1), 1) [] == [_[ ረድፍ 1, 2, 3, 2], 3 == [2, 2] ]]\"\"\"\n",
        "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/88",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef sort_array(array):\n    \"\"\"ከቁጥር ጋር በተያያዘ የተሰጠውን ቅጂ መልሰው ይልኩ፣ ከተደረደሩ በኋላ የተሰጠውን ቅደም ተከተል ይለዩ፣ ድምርው ((የመጀመሪያው መረጃ ጠቋሚ ዋጋ ፣ የመጨረሻው መረጃ ጠቋሚ ዋጋ) ባዶ ከሆነ ፣ ወይም ድምርው ((የመጀመሪያው መረጃ ጠቋሚ ዋጋ ፣ የመጨረሻው መረጃ ጠቋሚ ዋጋ) እኩል ከሆነ ፣ በመውረድ ቅደም ተከተል ይለዩት ማስታወሻ: * የተሰጠውን ቅደም ተከተል አይለውጡ ምሳሌዎች: * sort_array[(]) => [] * sort_array([5]) => [5] * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 6] \"\"\"\n",
        "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/89",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef encrypt(s):\n    \"\"\"አንድን ሕብረቁምፊ እንደ አንድ ክርክር የሚወስድ እና ፊደል እየተሽከረከረ ጋር የተመሰጠረ ሕብረቁምፊ የሚመልስ አንድ ተግባር encrypt ይፍጠሩ. ፊደል ፊደላት ሁለት ሁለት ቦታዎች ላይ ሁለት ጊዜ ወደ ታች እንዲዘዋወሩ በሚያስችል መንገድ መዞር አለበት. ለምሳሌ: encrypt('hi') ይመልሳል 'lm' encrypt('asdfghjkl') ይመልሳል 'ewhjklnop' encrypt('gf') ይመልሳል 'kj' encrypt('et') ይመልሳል 'ix' \"\"\"\n",
        "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/90",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef next_smallest(lst):\n    \"\"\"የሙሉ ቁጥሮች ዝርዝር ተሰጥቶዎታል. የዝርዝሩን 2 ኛ ትንሹን ንጥረ ነገር የሚመልስ next_smallest () ተግባር ይጻፉ. እንደዚህ ያለ ንጥረ ነገር ከሌለ ምንም አይመልስ. next_smallest () [1, 2, 3, 4, 5]) == 2 next_smallest () [5, 1, 4, 3, 2]) == 2 next_smallest () == None next_smallest () [1, 1]) == None \"\"\"\n",
        "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/91",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef is_bored(S):\n    \"\"\"የቃላት ሰንሰለት ይሰጥዎታል ፣ እና የእርስዎ ተግባር የቅጥያዎችን ብዛት መቁጠር ነው። ቅጥያ በ \"I\" ቃል የሚጀምር ዓረፍተ ነገር ነው። ዓረፍተ ነገሮች በ ‹› ፣ ‹› ወይም ‹› የተገደቡ ናቸው ። ለምሳሌ: >>> is_bored ((\"Hello world\") 0 >>> is_bored ((\"ሰማዩ ሰማያዊ ነው ። ፀሐይ ታበራለች ። ይህንን የአየር ሁኔታ እወዳለሁ\") 1 \"\"\"\n",
        "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/92",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef any_int(x, y, z):\n    '''3 ቁጥሮች የሚወስድ ተግባር ይፍጠሩ. ከቁጥሮች አንዱ ከሌሎቹ ሁለት ድምር ጋር እኩል ከሆነ እውነት ይመልሳል, እና ሁሉም ቁጥሮች ኢንቲጀሮች ናቸው. በሌሎች ሁኔታዎች ሁሉ ሐሰት ይመለሳል. ምሳሌዎች any_int{5, 2, 7} -> True any_int{3, 2, 2}) -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''\n",
        "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/93",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef encode(message):\n    \"\"\"መልዕክት የሚወስድ ተግባር ይጻፉ፣ እና ሁሉንም ፊደላት ካሴስ በሚለውጥ መልኩ ኮድ ያድርጉ፣ መልዕክቱ ውስጥ ያሉትን ሁሉንም አናባቢዎች በእንግሊዝኛ ፊደል ውስጥ ከ 2 ቦታዎች በፊት ከሚታየው ፊደል ጋር ይተካሉ። ፊደሎችን ብቻ ይያዙ። ምሳሌዎች: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' \"\"\"\n",
        "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/94",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"የቁጥር ዝርዝር ተሰጥቶሃል:: ትልቁን የቁጥር እሴት ማግኘት እና የቁጥሮች ድምር መመለስ አለብህ:: ምሳሌ: ለ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ውጤቱ 10 መሆን አለበት ለ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ውጤቱ 25 መሆን አለበት ለ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ውጤቱ 13 መሆን አለበት ለ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ውጤቱ 11 መሆን አለበት ለ lst = [0,81,12,3,21,1] ውጤቱ 3 መሆን አለበት ለ lst = [0,1,8,1,2,7] ውጤቱ 7 መሆን አለበት\"\"\"\n",
        "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/95",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef check_dict_case(dict):\n    \"\"\"አንድ መዝገበ ቃላት ከተሰጠ ፣ ሁሉም ቁልፎች በትንሽ ፊደል ወይም ሁሉም ቁልፎች በከፍተኛ ፊደል ውስጥ ያሉ ሕብረቁምፊዎች ከሆኑ እውነት ይመልሱ ፣ አለበለዚያ ሐሰት ይመልሱ ። ተግባሩ ሐሰት መመለስ አለበት የተሰጠው መዝገበ ቃላት ባዶ ነው ። ምሳሌዎች: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) እውነት መመለስ አለበት ። check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) ሐሰት መመለስ አለበት ። check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) ሐሰት መመለስ አለበት ። check_dict_case{\"ስም\":\"John\", \"ዕድሜ\":\"36\", \"ከተማ\":\"Houston\"}) ሐሰት መመለስ አለበት ። check_dict_case{\"NC\":\"STATE\", \"Z\":\"IP\"45\") እውነት መመለስ አለበት ።\"\"\"\n",
        "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/96",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef count_up_to(n):\n    \"\"\"አሉታዊ ያልሆነን ሙሉ ቁጥር የሚወስድ እና ከ n በታች የሆኑ የመጀመሪያዎቹን n ሙሉ ቁጥሮች ድርድር የሚመልስ ተግባር ተግባራዊ ያድርጉ ለምሳሌ: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] \"\"\"\n",
        "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/97",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef multiply(a, b):\n    \"\"\"ሁለት ሙሉ ቁጥሮች የሚወስዱትን እና የአሃድ አሃዛቸውን ውጤት የሚመልስ ተግባር ይሙሉ። ግብዓት ሁልጊዜ ትክክለኛ ነው ብለን እናስባለን። ምሳሌዎች: ማባዛት ((148, 412) መመለስ አለበት 16. ማባዛት ((19, 28) መመለስ አለበት 72. ማባዛት ((2020, 1851) መመለስ አለበት 0. ማባዛት ((14,-15) መመለስ አለበት 20. \"\"\"\n",
        "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/98",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef count_upper(s):\n    \"\"\"አንድ string s ከተሰጠ፣ በቁጥር ውስጥ ያሉትን የዋና ፊደላት ቁጥር በቁጥር ይቁጠሩ ለምሳሌ: count_upper (('aBCdEf') 1 count_upper (('abcdefg') 0 count_upper (('dBBE') 0 ይመልሳል\"\"\"\n",
        "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/99",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef closest_integer(value):\n    '''አንድን ቁጥር የሚወክል ዋጋ (ስትሪንግ) የሚወስድ እና ወደ እሱ በጣም የቀረበውን ኢንቲጀር የሚመልስ ተግባር ይፍጠሩ ። ቁጥሩ ከሁለት ኢንቲጀሮች እኩል ርቀት ላይ ከሆነ ከዜሮ ያጠነጥኑት ። ምሳሌዎች >>> closest_integer ((\"10\") 10 >>> closest_integer ((\"15.3\") 15 ማስታወሻ: ከዜሮ ርቆ ማጠነጠቁ ማለት የተሰጠው ቁጥር ከሁለት ኢንቲጀሮች እኩል ርቀት ላይ ከሆነ ፣ እርስዎ መመለስ ያለብዎት ከዜሮ በጣም የራቀ ነው ማለት ነው ። ለ ምሳሌ closest_integer \" ((14.5\") 15 መመለስ አለበት እና closest_integer \" ((-14.5\") -15. መመለስ አለበት'''\n",
        "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/100",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef make_a_pile(n):\n    \"\"\"አንድ አዎንታዊ ቁጥር n ከተሰጠ, አንተ ድንጋዮች n ደረጃዎች አንድ ክምር ማድረግ አለብን. የመጀመሪያው ደረጃ n ድንጋዮች አሉት. በሚቀጥለው ደረጃ ውስጥ ድንጋዮች ቁጥር ነው: - n ያልተለመደ ከሆነ ቀጣዩ ባዶ ቁጥር ነው. - n እኩል ከሆነ ቀጣዩ እኩል ቁጥር ነው. አንድ ዝርዝር ውስጥ በእያንዳንዱ ደረጃ ውስጥ ድንጋዮች ቁጥር, የት ኢንዴክስ ላይ ንጥረ ነገር i ደረጃ ውስጥ ድንጋዮች ቁጥር ይወክላል (i+1). ምሳሌዎች: >>> make_a_pile(3) [3, 5, 7] \"\"\"\n",
        "canonical_solution": "    return [n + 2*i for i in range(n)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/101",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef words_string(s):\n    \"\"\"እርስዎ ኮማ ወይም ክፍተት የተለዩ ቃላት አንድ ሕብረቁምፊ ይሰጣል. የእርስዎ ተግባር ቃላት ወደ ሕብረቁምፊ ለመከፋፈል እና ቃላት አንድ ድርድር መመለስ ነው. ለምሳሌ: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"] \"\"\"\n",
        "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/102",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef choose_num(x, y):\n    \"\"\"ይህ ተግባር ሁለት አዎንታዊ ቁጥሮች x እና y ይወስዳል እና በ [x, y] ክልል ውስጥ ያለውን ትልቁን አቻ ቁጥር ይመልሳል ። እንደዚህ ያለ ቁጥር ከሌለ ታዲያ ተግባሩ - 1 መመለስ አለበት ። ለምሳሌ: choose_num(12, 15) = 14 choose_num(13, 12) = -1 \"\"\"\n",
        "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/103",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"ሁለት አዎንታዊ ቁጥሮች n እና m ተሰጥተውሃል፣ እና ስራህ ከ n እስከ m ያሉትን አጠቃላይ ቁጥሮች አማካይ ማስላት ነው (n እና m ን ጨምሮ) መልሱን ወደ ቀረበው አጠቃላይ ቁጥር አክብረው እና ወደ ሁለትዮሽ ይለውጡት. n ከ m ይበልጣል ከሆነ -1 መልሰው. ምሳሌ: rounded_avg(1, 5) => \"0b11\" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => \"0b1111\" rounded_avg(20, 33) => \"0b11010\" \"\"\"\n",
        "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/104",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef unique_digits(x):\n    \"\"\"የተሰጠ አዎንታዊ ሙሉ ቁጥሮች ዝርዝር x. ምንም እንኳን ምንም እንኳን የቁጥር ቁጥር የሌላቸው የሁሉም ንጥረ ነገሮች የተደረደሩ ዝርዝር ይመለሱ. ማስታወሻ: የተመለሰው ዝርዝር በዝቅተኛ ቅደም ተከተል መደርደር አለበት. ለምሳሌ: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] \"\"\"\n",
        "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/105",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef by_length(arr):\n    \"\"\"የተሰጠን የሙሉ ቁጥሮች ድርድር፣ በ1 እና 9 መካከል ያሉትን ሙሉ ቁጥሮች ይደርጁ፣ የተገኘውን ድርድር ይለውጡ፣ እና እያንዳንዱን አሃዝ በተዛማጅ ስሙ ይተኩ ከ \"አንድ\"፣ \"ሁለት\"፣ \"ሦስት\"፣ \"አራት\"፣ \"አምስት\"፣ \"ስድስት\"፣ \"ሰባት\"፣ \"ስምንት\"፣ \"ዘጠኝ\" ለምሳሌ: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [\"Eight\", \"Five\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"] ድርድሩ ባዶ ከሆነ፣ አንድ ድርድርድርድር ይመልሱ: arr = [] return [] ድርድሩ ማንኛውም እንግዳ ቁጥር ካለው ችላ ይበሉ: arr = [1, -1 , 55] -> arr -> [1, 1], 55 -> reverse arr = [51] return - 'One' 1, ]\"\"\"\n",
        "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/106",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef f(n):\n    \"\"\"f ን እንደ ፓራሜትር የሚወስድ እና የ n መጠን ዝርዝር ይመልሳል ፣ ስለሆነም በ ኢንዴክስ ውስጥ ያለው የ i እሴት እኩል ከሆነ የ i ፋክቶሪያል ነው ወይም ካልሆነ ከ 1 እስከ i ያሉ ቁጥሮች ድምር ነው ። i ከ 1 ይጀምራል የ i ፋክቶሪያል ከ 1 እስከ i ያሉ ቁጥሮች ማባዛት ነው (1 * 2 * ... * i) ምሳሌ: f ((5) == [1, 2, 6, 24, 15] \"\"\"\n",
        "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/107",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"አንድ አዎንታዊ ሙሉ ቁጥር n ከተሰጠ ፣ በ ‹(1 ፣ n› ውስጥ የሚወድቁትን የቁጥር እና ያልተለመዱ የቁጥር ፓሊንድሮሞች ብዛት ያለው አንድ ቱፕል ይመልሱ ። ምሳሌ1: ግብዓት: 3 ውፅዓት: (1, 2) ማብራሪያ: የቁጥር ፓሊንድሮም ናቸው 1, 2, 3. ከመካከላቸው አንዱ እኩል ነው ፣ እና ሁለቱ ደግሞ ያልተለመዱ ናቸው ምሳሌ2: ግብዓት: 12 ውፅዓት: (4, 6) ማብራሪያ: የቁጥር ፓሊንድሮም ናቸው 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. አራት እኩል ናቸው ፣ እና 6 ቱ ደግሞ ያልተለመዱ ናቸው ማስታወሻ: 1. 1 <= n <= 10 ^ 3 2. ቱፕል በቅደም ተከተል የቁጥር እና ያልተለመዱ የቁጥር ፓሊንድሮሞች ብዛት ተመልሷል ። \"\"\"\n",
        "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/108",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef count_nums(arr):\n    \"\"\"የቁጥር ድምር > 0 የሆነን የቁጥር ብዛት የሚወስድ እና የቁጥር ድምር > 0 የሆነን የቁጥር ብዛት የሚመልስ የቁጥር ብዛት የሚወስድ የቁጥር ብዛት የሚሰጥ ተግባር ይጻፉ: ለምሳሌ -123 የቁጥር ቁጥሮች -1, 2, እና 3 ነው: >>> count_nums (([]) == 0 >>> count_nums ([-1, 11, -11]) == 1 >>> count_nums ([(1, 1, 2]) == 3 \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/109",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef move_one_ball(arr):\n    \"\"\"እኛ አንድ ድርድር 'አር' N ሙሉ ቁጥሮች arr[1], arr[2], ..., arr[N] ያለው. በድርድር ውስጥ ያሉት ቁጥሮች በዘፈቀደ ይደረደራሉ. የእርስዎ ተግባር የተሰጠው ድርድር ላይ የሚከተለውን ክወና በማድረግ አንድ ድርድር ያልቀነሰ ቅደም ተከተል ውስጥ የተደረደሩ ማግኘት ይቻላል እንደሆነ ለመወሰን ነው: አንተም የ ቀኝ ሽግግር ክወና በማንኛውም ቁጥር ጊዜ ማከናወን ይፈቀዳል. አንድ ቀኝ ሽግግር ክወና ማለት ነው ድርድር ሁሉ ንጥረ ነገሮች በአንድ ቦታ ላይ ወደ ቀኝ አቅጣጫ ማንቀሳቀስ. የ ድርድር የመጨረሻው ንጥረ ነገር ድርድር ውስጥ መነሻ ቦታ ማለትም 0th ይንቀሳቀሳሉ. ከላይ ያለውን ክወና በማከናወን የተደረደሩ ድርድር ማግኘት ይቻላል ከሆነ ከዚያም እውነተኛ መመለስ አለበለዚያ ሐሰት መመለስ. የተሰጠው ድርድር ከዚያም ባዶ መመለስ. ማስታወሻ: የተሰጠው ዝርዝር ልዩ ንጥረ ነገሮች እንዲኖራቸው ዋስትና ነው. ለምሳሌ: move_one_(ball[3, 4, 5, 2>====================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================\"\"\"\n",
        "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/110",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"በዚህ ችግር ውስጥ ሁለት የቁጥሮች ዝርዝሮችን የሚወስድ ተግባር ተግባራዊ ያደርጋል ፣ እና lst1 ን የቁጥሮች ዝርዝር ብቻ ለማድረግ በመካከላቸው የቁጥሮች ልውውጥን ማከናወን ይቻል እንደሆነ ይወስናል ። በ lst1 እና lst2 መካከል በተለዋጭ ቁሳቁሶች ብዛት ላይ ገደብ የለም ። በ lst1 እና lst2 መካከል ያሉትን ንጥረ ነገሮች መለዋወጥ የሚቻል ከሆነ የ lst1 ን ንጥረ ነገሮች ሁሉ እኩል እንዲሆኑ ለማድረግ \"አዎ\" ይመልሱ ። አለበለዚያ \"አይሆንም\" ይመልሱ ። ለምሳሌ: ልውውጥ [(1, 2, 3, 4], [1, 2, 3, 4]) => \"አዎ\" ልውውጥ [(1, 2, 3, 4], [1, 5, 3, 4]) => \"አይሆንም\" ግብዓት ዝርዝሮች ባዶ አይደሉም ተብሎ ይታሰባል ። \"\"\"\n",
        "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/111",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef histogram(test):\n    \"\"\"አንድ ሕብረቁምፊ የተሰጠው ቦታ የተለዩ አነስተኛ ፊደላት የሚወክሉ ከሆነ, በጣም ድግግሞሽ ያለው ደብዳቤ እና ተጓዳኝ ቆጠራ የያዘ መዝገበ ቃላት ይመልሱ. በርካታ ፊደላት ተመሳሳይ ክስተት ያላቸው ከሆነ, ሁሉንም መልሰው. ምሳሌ: ሂስቶግራም (('a b c') == {'a': 1, 'b': 1, 'c': 1} ሂስቶግራም (('a b b a') == {'a': 2, 'b': 2} ሂስቶግራም (('a b c a b') == {'a': 2, 'b': 2} ሂስቶግራም (('b b a') == {'b 4}: ሂስቶግራም (('a') == {'b 4} \"\"\"\n",
        "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/112",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"ተግባር ሁለት ሕብረቁምፊዎች ተሰጥቶናል s እና c፣ በ s ውስጥ ያሉትን ማንኛውንም ገጸ-ባህሪያት ከማንኛውም ገጸ-ባህሪያት ጋር እኩል የሆኑትን ሁሉ መሰረዝ አለብዎት ከዚያም ውጤቱ ሕብረቁምፊ ፓሊንድሮም መሆኑን ያረጋግጡ። አንድ ሕብረቁምፊ ወደ ፊት ተመሳሳይ ከሆነ ወደ ኋላ የሚነበብ ከሆነ ፓሊንድሮም ይባላል ። ውጤቱን ሕብረቁምፊ እና እውነት / ሐሰት ለምርመራው የያዘ አንድ ቱፕል መመለስ አለብዎት ። ለምሳሌ ለ s = \"abcde\" ፣ c = \"ae\" ውጤቱ መሆን አለበት ('bcd'፣ ሐሰት) ለ s = \"abcdef\" ፣ c = \"b\" ውጤቱ መሆን አለበት ('acdef'፣ ሐሰት) ለ s = \"abcdedcba\" ፣ c = \"ab\" ውጤቱ መሆን አለበት ('cdedc'፣ እውነት)\"\"\"\n",
        "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/113",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef odd_count(lst):\n    \"\"\"እያንዳንዱ ሕብረቁምፊዎች ብቻ አሃዞች ያካተተ ነው የት ሕብረቁምፊዎች ዝርዝር የተሰጠው, አንድ ዝርዝር መመለስ. እያንዳንዱ ንጥረ ነገር i \"የ ግብዓት ሕብረቁምፊ i ውስጥ ያልተለመዱ ንጥረ ነገሮች ቁጥር መሆን አለበት. \" ሁሉም i's ግብዓት i'th ሕብረቁምፊ ውስጥ ያልተለመዱ አሃዞች ቁጥር ጋር መተካት አለባቸው የት. >>> ያልተለመደ_ቁጥር ['1234567']) [\"የ ያልተለመዱ ንጥረ ነገሮች ቁጥር 4n የ str4ng 4 የ 4nput.\"] >>> ያልተለመደ_ቁጥር ['3',\"111111\"]) [\"የ ያልተለመዱ ንጥረ ነገሮች ቁጥር 1n የ str1ng 1 የ 1nput. \", \"የ ያልተለመዱ ንጥረ ነገሮች ቁጥር 8n የ str8ng 8 የ 8nput. \"]\"\"\"\n",
        "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/114",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"የቁጥር ቁጥሮች ስብስብ ከተሰጠ፣ የቁጥር ቁጥሮች ስብስብ አነስተኛውን ድምር ያግኙ። ምሳሌ minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 \"\"\"\n",
        "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/115",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"የጓድጓድ መረብ የተሰጠዎት አራት ማዕዘን ቅርፅ ያለው ነው:: እያንዳንዱ ረድፍ አንድን ጉድጓድ ይወክላል፣ እና እያንዳንዱ 1 በአንድ ረድፍ ውስጥ አንድን የውሃ አሃድ ይወክላል:: እያንዳንዱ ጉድጓድ ውሃውን ለማውጣት የሚያገለግል ተዛማጅ ባልዲ አለው፣ እና ሁሉም ባልዲዎች ተመሳሳይ አቅም አላቸው:: የእርስዎ ተግባር ባልዲዎቹን በመጠቀም ጉድጓዶቹን ለማውጣት ነው:: ባልዲዎቹን ለማውረድ የሚያስፈልጉዎትን ጊዜዎች ያስገቡ:: ምሳሌ 1: ግብዓት: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 ውፅዓት: 6 ምሳሌ 2: ግብዓት: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 ውፅዓት: 5 ምሳሌ 3: ግብዓት: [[:0,0,0], [0,0]] bucket_capacity: 5 ውፅዓት: 0 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 2 * 2 * 3 * 2 * 3 * 4 * 5 * 6 * 6 * 6 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * * 10 * 10 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\"\"\"\n",
        "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n",
        "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/116",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef sort_array(arr):\n    \"\"\"በዚህ ካታ ውስጥ አሉታዊ ያልሆኑ ሙሉ ቁጥሮች በሁለትዮሽ ውክልናቸው ውስጥ ባሉ ቁጥሮች ብዛት መሠረት በዝቅተኛ ቅደም ተከተል መደርደር አለብዎት ። ተመሳሳይ ቁጥር ላላቸው ሰዎች በአስርዮሽ እሴት ላይ በመመርኮዝ መደርደር አለበት ። እንደዚህ ሊተገበር ይገባል: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] \"\"\"\n",
        "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/117",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef select_words(s, n):\n    \"\"\"አንድ string s እና አንድ የተፈጥሮ ቁጥር n ከተሰጠ, እነዚህ ቃላት string s ውስጥ ይታያሉ ዘንድ, በትክክል n አናባቢዎች የያዙ ከ string s ሁሉ ቃላት ዝርዝር የሚመለስ አንድ ተግባር ተግባራዊ ለማድረግ ተልእኮ ተደርጓል. string s ባዶ ከሆነ ከዚያም ተግባር ባዶ ዝርዝር መመለስ አለበት. ማስታወሻ: አንተ ማስገቢያ ሕብረቁምፊዎች ብቻ ፊደላት እና ክፍተቶች ይዟል ሊያስቡ ይችላሉ. ምሳሌዎች: select_words \"ማርያም ትንሽ በግ ነበረው\", 4) ==> [\"ትንሽ\"] select_words \"ማርያም ትንሽ በግ ነበረው\", 3) ==> [\"ማርያም\", \"በግልጽ ቦታ\", 2) ==> [] select_words \"Hello world\", 4) ==> [\"world\"] select_words \"አጎቴ ሳም\", 3) ==> [\"አጎቴ\"] \"\"\"\n",
        "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/118",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"አንድ ቃል ተሰጥቶሃል. የእርስዎ ተግባር ከቃሉ በስተቀኝ በኩል ከሁለት ጠናቃኞች መካከል የሚቆም በጣም ቅርብ የሆነን ድምጽ ማግኘት ነው (የቁጥር ልዩነት) ። በመጀመርያ እና መጨረሻ ላይ ያሉ ድምፆች አይቆጠሩም. ከላይ የተጠቀሰውን ሁኔታ የሚያሟላ ምንም ድምጽ ካላገኙ ባዶ ገመድ ይመልሱ. የተሰጠው ገመድ የእንግሊዝኛ ፊደል ብቻ ይ containsል ብለው ሊገምቱ ይችላሉ. ምሳሌ: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" ((ab\") ==> \"\" \"\"\"\n",
        "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/119",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef match_parens(lst):\n    '''ሁለት ሕብረቁምፊዎች ዝርዝር ተሰጥቶሃል፣ ሁለቱም ሕብረቁምፊዎች ክፍት ቅንፍ '(' ወይም የቅርብ ቅንፍ ') ' ብቻ ነው ያላቸው። ስራህ ሁለቱንም ሕብረቁምፊዎች በተወሰነ ቅደም ተከተል ማገናኘት ይቻል እንደሆነ መፈተሽ ነው፣ ይህም የሚመነጨው ሕብረቁምፊ ጥሩ ይሆናል ማለት ነው። አንድ ሕብረቁምፊ S ጥሩ ነው ተብሎ የሚወሰደው በ S ውስጥ ያሉት ሁሉም ቅንፎች ሚዛናዊ ከሆኑ ብቻ ነው። ለምሳሌ: ሕብረቁምፊው '((()) 'ጥሩ ነው፣ ሕብረቁምፊው '()) ' ግን ጥሩ አይደለም:: ጥሩ ሕብረቁምፊ ለማድረግ መንገድ ካለ 'አዎ' ይመልሱ፣ አለበለዚያ ደግሞ 'አይ' ይመልሱ:: ምሳሌዎች: match_parens[('() ', ') ']) == 'አዎ' match_parens[(') ', ') ']) == 'አይ' '''\n",
        "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/120",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef maximum(arr, k):\n    \"\"\"አንድ ድርድር arr ሙሉ ቁጥሮች እና አዎንታዊ ሙሉ ቁጥር k የተሰጠው, arr ውስጥ ከፍተኛው k ቁጥሮች ጋር ርዝመት k አንድ የተደረደሩ ዝርዝር ይመለሱ. ምሳሌ1: ግቤት: arr = [-3, -4, 5], k = 3 ውፅዓት: [-4, -3, 5] ምሳሌ2: ግቤት: arr = [4, -4, 4], k = 2 ውፅዓት: [4, 4] ምሳሌ3: ግቤት: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 ውፅዓት: [2] ማስታወሻ: 1. የ ድርድር ርዝመት ክልል ውስጥ ይሆናል [1, 1000]. 2. ድርድር ውስጥ ያሉት ንጥረ ነገሮች ክልል ውስጥ ይሆናል [-1000, 1000]. 3. 0 <= k <= len ((arr) \"\"\"\n",
        "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/121",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef solution(lst):\n    \"\"\"ባዶ ያልሆነ የሙሉ ቁጥሮች ዝርዝር ከተሰጠ ፣ በባዶ ቦታዎች ላይ ያሉትን ሁሉንም ያልተለመዱ ንጥረ ነገሮች ድምር ይመልሱ ። ምሳሌዎች መፍትሄ (([5, 8, 7, 1]) ==> 12 መፍትሄ (([3, 3, 3, 3]) ==> 9 መፍትሄ (([30, 13, 24, 321]) ==>0 \"\"\"\n",
        "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/122",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef add_elements(arr, k):\n    \"\"\"አንድ ባዶ ያልሆነ የሙሉ ቁጥሮች arr እና k ሙሉ ቁጥር የተሰጠው ፣ ከመጀመሪያዎቹ k የ arr ንጥረ ነገሮች ውስጥ ከሁለት አሃዞች በላይ የያዙትን የቁጥር ድምር ይመልሱ ምሳሌ: ግቤት: arr = [111,21,3,4000,5,6,7,8,9], k = 4 ውፅዓት: 24 # ድምር 21 + 3 ገደቦች: 1.\"\"\"\n",
        "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/123",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"አንድ አዎንታዊ ቁጥር n ከተሰጠ፣ ያልተለመዱ ቁጥሮች በኮላዝ ቅደም ተከተል የተደረደሩ ዝርዝር ይመልሱ። የኮላዝ ግምታዊ ሀሳብ በሂሳብ ውስጥ የሚከተለውን በሚከተለው መንገድ የተገለጸ ቅደም ተከተል የሚመለከት ግምታዊ ሀሳብ ነው: ከማንኛውም አዎንታዊ ቁጥር n ይጀምሩ ከዚያም እያንዳንዱ ቃል ከቀዳሚው ቃል እንደሚከተለው ይወሰዳል: የቀደመው ቃል እኩል ከሆነ ፣ ቀጣዩ ቃል ከቀዳሚው ቃል ግማሽ ነው ። የቀደመው ቃል ያልተለመደ ከሆነ ፣ ቀጣዩ ቃል ከቀዳሚው ቃል 3 እጥፍ ነው እና 1.\"\"\"\n",
        "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/124",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef valid_date(date):\n    \"\"\"የተሰጠውን ቀን ሰንሰለት የሚያረጋግጥ እና ቀን ከሆነ እውነት የሚመልስ ተግባር መጻፍ አለብዎት ካልሆነ ግን ሐሰት ነው. ቀኑ የሚሰራው የሚከተሉት ደንቦች በሙሉ ከተሟሉ ነው: 1. የቀን ሰንሰለት ባዶ አይደለም 2. የቀን ብዛት ከ 1 በታች ወይም ከ 31 ቀናት በላይ አይደለም በወራት 1,3,5,7,8,10,12 እና የቀን ብዛት ከ 1 በታች ወይም ከ 30 ቀናት በላይ አይደለም በወራት 4,6,9,11 እና የቀን ብዛት ከ 1 በታች ወይም ከ 29 በታች አይደለም በወሩ 2. 3. ወሮች ከ 1 በታች ወይም ከ 12 በላይ መሆን የለባቸውም 4. ቀኑ በ ቅርጸት መሆን አለበት: mm-dd-yyyy ለምሳሌ: valid_date (('03-11-2000') => true_date (('15-01-2012') => false_date (('04-01-2040') => false_date (('06-04-2020') => true_date (('06-04/2020') => false\"\"\"\n",
        "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/125",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef split_words(txt):\n    '''ቃላት ተከታታይ የተሰጠው, ነጭ ቦታ ላይ የተከፋፈሉ ቃላት ዝርዝር መመለስ, ምንም ነጭ ቦታዎች በጽሑፉ ውስጥ የለም ከሆነ እናንተ ኮማዎች ላይ መከፋፈል አለበት ',' ምንም ኮማዎች የለም ከሆነ ፊደል ውስጥ ያልተለመደ ቅደም ተከተል ጋር ትናንሽ ፊደላት ቁጥር መመለስ አለበት, ord('a') = 0, ord'(b') = 1, ... ord('z') = 25 ምሳሌዎች split_words ((\"Hello world!\") â -> [\"Hello\", \"world!\"] split_words ((\"Hello,world!\") â -> [\"Hello\", \"world!\" split_words\"(abcdef\") == 3 '''\n",
        "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/126",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef is_sorted(lst):\n    '''ቁጥሮች ዝርዝር ከተሰጠ, እነሱ እየጨመረ ቅደም ተከተል ውስጥ የተደረደሩ ናቸው ወይም አይደለም ይመልሳል. ዝርዝር ተመሳሳይ ቁጥር ከ 1 በላይ ቅጂዎች ካሉ, ውሸት ይመልሳል. ምንም አሉታዊ ቁጥሮች እና ብቻ ኢንቲጀሮች እንበል. ምሳሌዎች is_sorted ((([5]) â -> እውነተኛ is_sorted (([1, 2, 3, 4, 5]) â -> እውነተኛ is_sorted (([1, 2, 3, 4, 5, 6]) â -> ሐሰተኛ is_sorted (([1, 2, 3, 4, 5, 6, 7]) â -> እውነተኛ is_sorted (([1, 3, 2, 3, 4, 5, 6, 7]) â -> እውነተኛ is_sorted (([1, 3, 2, 4, 5, 6, 7]) â -> ሐሰተኛ is_sorted (([1, 2, 2, 2, 3, 3, 4]) â -> እውነተኛ is_sorted (([1, 2, 2, 3, 4 -> ሐሰተኛ ])'''\n",
        "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/127",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"ሁለት ክፍተቶች ተሰጥተውሃል፣ እያንዳንዱ ክፍተት ሁለት ሙሉ ቁጥሮች ናቸው። ለምሳሌ፣ ክፍተት = (መጀመሪያ፣ መጨረሻ) = (1, 2) ። የተሰጡት ክፍተቶች የተዘጉ ናቸው ይህም ማለት ክፍተቱ (መጀመሪያ፣ መጨረሻ) መጀመሪያ እና መጨረሻን ያካትታል ማለት ነው። ለእያንዳንዱ የተሰጠ ክፍተት፣ ጅማሬው ከ መጨረሻው ያነሰ ወይም እኩል ነው ተብሎ ይታሰባል ። የእርስዎ ተግባር የእነዚህ ሁለት ክፍተቶች መቋረጫ ርዝመት ዋና ቁጥር መሆኑን መወሰን ነው። ለምሳሌ፣ የ ክፍተቶች መቋረጫ (1, 3), (2, 4) (2, 3) ሲሆን ርዝመቱ 1 ሲሆን ይህም ዋና ቁጥር አይደለም ። የመቋረጫው ርዝመት ዋና ቁጥር ከሆነ \"አዎ\" ይመልሱ፣ አለበለዚያ \"አይደለም\" ይመልሱ። ሁለቱ ክፍተቶች የማይገናኙ ከሆነ \"አይደለም\" ይመልሱ:: [input/output] ናሙናዎች: መቋረጫ (((1, 2), (2, 3) ==> \"መቋረጫ-1, ((1), 4) ==> \"መቋረጫ (0,\", (NO) ==> 5-1, ((5,-) \"አዎ\" ())\"\"\"\n",
        "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/128",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef prod_signs(arr):\n    \"\"\"አንተ ሙሉ ቁጥሮች አንድ ድርድር ተሰጥቶሃል እና እናንተ በ 1 የሚወከለው, -1 ወይም 0 በ ድርድር ውስጥ እያንዳንዱ ቁጥር ሁሉ ምልክቶች ምርት በ ሙሉ ቁጥሮች መጠን ድምር መመለስ ይኖርብናል. ማስታወሻ: ባዶ ድርድር ምንም ይመልሳል. ምሳሌ: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == None \"\"\"\n",
        "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/129",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef minPath(grid, k):\n    \"\"\"N ረድፎች እና N አምዶች (N >= 2) እና አዎንታዊ የሆነ k ሙሉ ቁጥር ያለው ፍርግርግ ሲሰጥ እያንዳንዱ ፍርግርግ እሴት ይይዛል. [1, N * N] ጨምሮ ባለው ክልል ውስጥ ያለው እያንዳንዱ ሙሉ ቁጥር በፍርግርግ ውስጥ ባሉ ህዋሳት ላይ አንድ ጊዜ በትክክል ይታያል. በማንኛውም ህዋስ ውስጥ ያለውን k ርዝመት ያለው አነስተኛውን መንገድ መፈለግ አለብዎት, እና በእያንዳንዱ ደረጃ ወደ ማንኛውም ጎረቤት ህዋስ መሄድ ይችላሉ, በሌላ አነጋገር, ከአሁኑ ህዋስ ጋር ጠርዝ ወደሚያጋሩ ህዋሳት መሄድ ይችላሉ. እባክዎ ልብ ይበሉ k ርዝመት ያለው መንገድ ማለት k ህዋሶችን በትክክል መጎብኘት ማለት ነው (በተለይም የተለየ አይደለም). ከግሪድ ውጭ መሄድ አይችሉም. A (የ k ርዝመት) መንገድ ከ B (የ k ርዝመት) መንገድ ያነሰ ነው ተብሎ ይታሰባል A እና B (እነሱን እና lA_st እና lA_st ብለን እንጠራቸዋለን) በሚያልቁ ህዋሶች ላይ እሴቶችን ከተመዘገቡ በኋላ ፣ lA_st ከ lA_st እና lA_st ቢባል), lA_st በቃል አፃፃፃፍነት ከ lA_st ቢያንስ አንድ ጊዜ አንድ ጊዜ ይታያልቃል ይታይበታል.\"\"\"\n",
        "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/130",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef tri(n):\n    \"\"\"ሁሉም ሰው የፊቦናቺን ቅደም ተከተል ያውቃል ፣ ባለፉት ሁለት መቶ ዓመታት ውስጥ በሂሳብ ሊቃውንት በጥልቀት የተጠና ነበር ። ሆኖም ሰዎች የማያውቁት የቲሪቦናቺ ቅደም ተከተል ነው ። የቲሪቦናቺ ቅደም ተከተል የሚገለጸው በመደጋገም ነው: tri(1) = 3 tri(n) = 1 + n / 2 ፣ n እኩል ከሆነ ፣ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ፣ n ያልተለመደ ከሆነ ለምሳሌ: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 አሉታዊ ያልሆነ አጠቃላይ ቁጥር n ተሰጥቶዎታል ፣ የቲሪቦናቺን ቅደም ተከተል የመጀመሪያዎቹን n + 1 ቁጥሮች ዝርዝር መመለስ አለብዎት ። ምሳሌዎች: tri(3) = [1, 3, 2, 8]\"\"\"\n",
        "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/131",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef digits(n):\n    \"\"\"አንድ አዎንታዊ ቁጥር n ከተሰጠ ፣ የዝቅተኛ አሃዞችን ውጤት ይመልሱ ። ሁሉም አሃዞች እኩል ከሆኑ 0 ይመልሱ ። ለምሳሌ: አሃዞች\"\"\"\n",
        "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/132",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef is_nested(string):\n    '''ብቻ ካሬ ቅንፍ የያዘ አንድ ሕብረቁምፊ እንደ ግብዓት የሚወስድ ተግባር ይፍጠሩ. ተግባር እውነተኛ መመለስ አለበት እና ብቻ ከሆነ ቢያንስ አንድ ቅንፍ ውስጥ የተጠለፉ ነው የት ቅንፍ አንድ ትክክለኛ subsequence አለ. is_nested '[[]]') â -> እውነተኛ is_nested '[[]]]]]]][[[[[[]') â -> ሐሰት is_nested '[][]') â -> ሐሰት is_nested '[]') â -> ሐሰት is_nested '[[]') â -> ሐሰት is_nested'[[][]]') â -> እውነት is_nested'[[]][[]]') â -> እውነት'''\n",
        "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/133",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"ቁጥሮች ዝርዝር ተሰጥቶሃል:: የተሰጠውን ዝርዝር ውስጥ ካሉት ቁጥሮች ካሬ ድምር መመለስ አለብህ:: በመጀመሪያ በዝርዝሩ ውስጥ ያሉትን እያንዳንዱን ንጥረ ነገሮች ወደላይኛው int ((ጣሪያ) አክብ:: ምሳሌዎች: ለ lst = [1,2,3] ውፅዓት 14 መሆን አለበት ለ lst = [1,4,9] ውፅዓት 98 መሆን አለበት ለ lst = [1,3,5,7] ውፅዓት 84 መሆን አለበት ለ lst = [1.4,4.2,0] ውፅዓት 29 መሆን አለበት ለ lst = [-2.4,1,1] ውፅዓት 6 መሆን አለበት \"\"\"\n",
        "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/134",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''የተሰጠውን ሰንሰለት የመጨረሻው ቁምፊ የአልፋቤት ቁምፊ ከሆነ እና የቃላት አካል ካልሆነ እና ሀሰት ካልሆነ እውነት የሚመልስ ተግባር ይፍጠሩ. ማስታወሻ: \"ቃል\" በቦታ የተለዩ የቁምፊዎች ቡድን ነው. ምሳሌዎች: check_if_last_char_is_a_letter\" (የ\"ፖም ፒ\") â -> ሐሰት check_if_last_char_is_a_letter\" (የ\"ፖም ፒ\") â -> እውነት check_if_last_char_is_a_letter\" (የ\"ፖም ፒ\") â -> ሐሰት check_if_last_char_is_a_letter\" (የ\"ፖም ፒ\") â -> ሐሰት check_if_last_char_is_a_letter\" (የ\"ፖም ፒ\") â -> ሐሰት '''\n",
        "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/135",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef can_arrange(arr):\n    \"\"\"ከቀዳሚው አካል ጋር የማይመጣጠን ወይም የማይበልጥ ትልቁን መረጃ ጠቋሚ የሚመልስ ተግባር ይፍጠሩ. እንደዚህ አይነት አካል ከሌለ ከዚያ -1. ተመላሽ ያድርጉ የተሰጠው ድርድር የተባዙ እሴቶችን አይይዝም. ምሳሌዎች: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 \"\"\"\n",
        "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/136",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef largest_smallest_integers(lst):\n    '''አንድ tuple (ሀ, ለ) ይመልሳል አንድ ተግባር ይፍጠሩ, የት 'ሀ' አሉታዊ integers መካከል ትልቁ ነው, እና 'ለ' ዝርዝር ውስጥ አዎንታዊ integers መካከል ትንሹ ነው. አሉታዊ ወይም አዎንታዊ integers የለም ከሆነ, እንደ ምንም ይመልሳል. ምሳሌዎች: ትልቁ_ትንሹ_integers[2, 4, 1, 3, 5, 7]) == (ምንም, 1) ትልቁ_ትንሹ_integers([]) == (ምንም, ምንም) ትልቁ_ትንሹ_integers[0]) == (ምንም, ምንም) '''\n",
        "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/137",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef compare_one(a, b):\n    \"\"\"እውነተኛ ቁጥሮች የሚወክሉ ኢንቲጀሮችን፣ ፍሎተዎችን ወይም ሰንሰለቶችን የሚወስድ እና የተሰጠውን ተለዋዋጭ አይነት ውስጥ ትልቁን ተለዋዋጭ የሚመልስ ተግባር ይፍጠሩ። እሴቶቹ እኩል ከሆኑ ምንም አይመልሱም ማስታወሻ: እውነተኛ ቁጥር እንደ ሰንሰለት ከተወከለው ተለዋዋጭ ነጥብ ሊሆን ይችላል . ወይም , compare_one(1, 2.5) â -> 2.5 compare_one(1, \"2,3\") â -> \"2,3\" compare_one(\"5,1\", \"6\") â -> \"6\" compare_one(\"1\", 1) â -> None \"\"\"\n",
        "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/138",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"የተሰጠው ቁጥር n በትክክል የ 4 አዎንታዊ የቁጥር ድምር ሆኖ ሊጻፍ ይችል እንደሆነ ይገምግሙ ምሳሌ is_equal_to_sum_even (አራት) == ሐሰት is_equal_to_sum_even (ስድስት) == ሐሰት is_equal_to_sum_even (ስምንት) == እውነት \"\"\"\n",
        "canonical_solution": "    return n%2 == 0 and n >= 8\n",
        "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/139",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef special_factorial(n):\n    \"\"\"የብራዚል ፋክቶሪያል እንዲህ ተብሎ ተገልጿል: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1! n > 0 ለምሳሌ: >>> special_factorial ((4) 288 ተግባር እንደ ግብዓት አንድ ሙሉ ቁጥር ይቀበላል እና የዚህን ሙሉ ቁጥር ልዩ ፋክቶሪያል መመለስ አለበት ። \"\"\"\n",
        "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/140",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef fix_spaces(text):\n    \"\"\"_ ምሳሌ-3 ፣ በውስጡ ያሉትን ሁሉንም ክፍተቶች በግርጌ ምልክት ይተኩ ፣ እና አንድ ሰንሰለት ከ 2 በላይ ተከታታይ ክፍተቶች ካሉት ፣ ከዚያ ሁሉንም ተከታታይ ክፍተቶች በ - fix_spaces ((\"ምሳሌ\") == \"ምሳሌ\" fix_spaces ((\"ምሳሌ1\") == \"ምሳሌ_1\" fix_spaces (((\"ምሳሌ2\") == \"_ምሳሌ_2\" fix_spaces ((\"ምሳሌ 3\") == \"_ምሳሌ-3\" \"\n    \"\"\"\n",
        "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/141",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef file_name_check(file_name):\n    \"\"\"የፋይል ስም የሚወክል ሕብረቁምፊ የሚወስድ ተግባር ይፍጠሩ, እና 'አዎ' ይመለሳል የፋይል ስም ትክክለኛ ከሆነ, እና 'አይደለም' ይመለስ አለበለዚያ. የፋይል ስም ትክክለኛ እንደሆነ ተደርጎ ይቆጠራል እና ብቻ ከሆነ ሁሉም የሚከተሉት ሁኔታዎች የተሟሉ ናቸው: - የፋይል ስም ውስጥ ከሦስት አሃዞች በላይ መሆን የለበትም ('0'-'9') - የፋይል ስም በትክክል አንድ ነጥብ 'ይዟል. - የ ንዑስ ሕብረቁምፊ በፊት ነጥብ መሆን የለበትም ባዶ, እና አንድ ደብዳቤ ጋር ይጀምራል ከ የላቲን alphapet ('a'-'z' እና 'A'Z'). - የ ንዑስ ሕብረቁምፊ በኋላ ነጥብ ከእነዚህ ውስጥ አንዱ መሆን አለበት: ['txt', 'exe', 'll'] ምሳሌዎች: file_name_check\"(ለምሳሌ txt. #\") => 'አዎ'የፋይል ስም_check\"(ለምሳሌ1d. #\") => 'አይደለም' (የ ስም በላቲን ፊደል ፊደል መጀመር አለበት)\"\"\"\n",
        "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/142",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\" ይህ ተግባር የሙሉ ቁጥሮች ዝርዝር ይወስዳል። ለዝርዝሩ ውስጥ ላሉት ሁሉም ግቤቶች፣ ተግባሩ የሙሉ ቁጥር ግቤቱን ካሬ ያደርገዋል ኢንዴክሱ የ3 ብዙ ከሆነ እና የሙሉ ቁጥር ግቤቱን ካዩት ኢንዴክሱ የ4 ብዙ ከሆነ እና የ3 ብዙ ካልሆነ። ተግባሩ በዝርዝሩ ውስጥ ያሉትን ግቤቶች አይለውጥም ኢንዴክሶቻቸው የ3 ወይም የ4 ብዙ ካልሆኑ ተግባሩ የሁሉም ግቤቶች ድምር ይመልሳል። ምሳሌዎች: ለ lst = [1,2,3] ውፅዓት 6 መሆን አለበት ለ lst = [] ውፅዓት 0 መሆን አለበት ለ lst = [-1,-5,2,-1,-5] ውፅዓት -126 መሆን አለበት \"\"\"\n",
        "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/143",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"አንድ ዓረፍተ ነገር የሚወክል ሕብረቁምፊ ተሰጥቶሃል፣ ዓረፍተ ነገሩ በቦታ የተለዩ አንዳንድ ቃላትን ይዟል፣ እና ርዝመቶቹ የመጀመሪያ ቁጥሮች የሆኑትን ቃላት የያዘ ሕብረቁምፊ መመለስ አለብህ፣ በአዲሱ ሕብረቁምፊ ውስጥ ያሉት ቃላት ቅደም ተከተል ከመጀመሪያው ጋር ተመሳሳይ መሆን አለበት። ምሳሌ1: ግቤት: ዓረፍተ ነገር = \"ይህ ፈተና ነው\" ውፅዓት: \"እ\" ምሳሌ2: ግቤት: ዓረፍተ ነገር = \"ለዋኝነት እንሂድ\" ውፅዓት: \"ሂድ\" ገደቦች: * 1 <= len(sentence) <= 100 * ዓረፍተ ነገር ፊደላትን ብቻ ይ containsል \"\"\"\n",
        "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/144",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef simplify(x, n):\n    \"\"\"የእርስዎ ተግባር x * n አገላለጽ ለማቅለል አንድ ተግባር ተግባራዊ ለማድረግ ነው. ተግባር x * n አንድ ሙሉ ቁጥር እና የሐሰት ካልሆነ ይገመታል እውነት ይመለሳል. ሁለቱም x እና n, አንድ ክፍልፋይ ያለውን ሕብረቁምፊ ውክልና ናቸው, እና የሚከተለውን ቅርጸት, <numerator> / <denominator> አላቸው ሁለቱም ቆጣሪ እና ጠቋሚ አዎንታዊ ሙሉ ቁጥሮች ናቸው የት. አንተ x, እና n ትክክለኛ ክፍልፋዮች ናቸው ብሎ ማሰብ ይችላሉ, እና ጠቋሚ እንደ ዜሮ የላቸውም. ቀላል ማድረግ:\"\"\"\n",
        "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/145",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef order_by_points(nums):\n    \"\"\"የተሰጠውን የቁጥር ዝርዝር በቁጥራቸው ድምር መሠረት በዝቅተኛ ቅደም ተከተል የሚደርደር ተግባር ይጻፉ። ማስታወሻ: ተመሳሳይ የሆነ የቁጥራቸው ድምር ያላቸው በርካታ ንጥሎች ካሉ በዋናው ዝርዝር ውስጥ ባለው መረጃ ጠቋሚ መሠረት ያደራጁዋቸው ። ለምሳሌ: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points[]) == [] \"\"\"\n",
        "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/146",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef specialFilter(nums):\n    \"\"\"ቁጥሮች እንደ ግብዓት የሚወስድ እና ቁጥሮች ውስጥ ከ 10 በላይ የሆኑትን ንጥረ ነገሮች ቁጥር የሚመልስ ተግባር ይጻፉ እና ሁለቱም ቁጥር የመጀመሪያ እና የመጨረሻ አሃዞች ነጠላ (1, 3, 5, 7, 9) ናቸው ለምሳሌ: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 \"\"\"\n",
        "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/147",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef get_max_triples(n):\n    \"\"\"አንተ n አዎንታዊ ሙሉ ቁጥር የተሰጠው ነው. አንተ ርዝመት n አንድ ሙሉ ቁጥር ድርድር መፍጠር አለብዎት. ለእያንዳንዱ i (1 ‰¤ i ‰¤ n), a [i] = i * i - i + 1 ዋጋ. i < j < k, እና a [i] + a [j] + a [k] አንድ ሦስትዮሽ ቁጥር (a [i], a [j], a [k]) ይመልሱ. ምሳሌ: ግብዓት: n = 5 ውፅዓት: 1 ማብራሪያ: አንድ = [1, 3, 7, 13, 21] ብቸኛው ትክክለኛ ሶስቴ ነው (1, 7, 13). \"\"\"\n",
        "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/148",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef bf(planet1, planet2):\n    '''በፀሐይ ስርዓታችን ውስጥ ስምንት ፕላኔቶች አሉ: ከፀሐይ በጣም ቅርብ የሆነው ሜርኩሪ ነው, ቀጣዩ ቬኑስ ነው, ከዚያም ምድር, ማርስ, ጁፒተር, ሳተርን, ኡራነስ, ኔፕቱን. ሁለት የፕላኔቶች ስሞች እንደ ፕላኔት 1 እና ፕላኔት 2 ያሉትን ሁለት የፕላኔቶች ስሞች የሚወስድ ተግባር ይጻፉ. ተግባሩ በፕላኔቶች መካከል ያለውን የፕላኔቶች ምህዋር እና የፕላኔቶች ምህዋር የያዘውን ሁሉንም ፕላኔቶች የያዘውን የፕላኔቶች ምህዋር መመለስ አለበት, ከፀሐይ ጋር ቅርበት የተደረደሩ. ፕላኔቶች 1 ወይም ፕላኔት 2 ትክክለኛ የፕላኔቶች ስሞች ካልሆኑ ተግባሩ ባዶ የሆነ የፕላኔቶች ምህዋር መመለስ አለበት. ምሳሌዎች bf \"(ጁፒተር\", \"ኔፕቱን\") ==> (\"ሳተርን\", \"ዩራነስ\") bf \"(ምድር\", \"ሜርኩሪ\") ==> (\"ቬኑስ\", \"ምድር\", \"ማርስ\", \"ጁፒተር\", \"ሳተር\") '''\n",
        "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/149",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"የቁምፊዎች ዝርዝር እንደ መለኪያ የሚቀበል፣ ያልተለመዱ ርዝመቶች ያላቸውን የቁምፊዎች ዝርዝር የሚሰርዝ፣ እና የተገኘውን ዝርዝር በተደረደሩ ቅደም ተከተል የሚመልስ ተግባር ይጻፉ፣ ዝርዝሩ ሁልጊዜ የቁምፊዎች ዝርዝር እንጂ የቁጥሮች ድርድር አይደለም፣ እና ተደጋጋሚዎችን ሊይዝ ይችላል። የዝርዝሩ ቅደም ተከተል በእያንዳንዱ ቃል ርዝመት መነሳት አለበት፣ እና እርስዎ በዝርዝሩ ላይ የተደረደሩትን ዝርዝር መመለስ አለብዎት፣ ሁለት ቃላት ተመሳሳይ ርዝመት ካላቸው፣ ዝርዝሩን በፊደል አጻጻፍ ይደርጁ፣ ተግባሩ የተደረደሩትን የቁምፊዎች ዝርዝር መመለስ አለበት። ሁሉም ቃላት ተመሳሳይ ርዝመት ይኖራቸዋል ብለው ሊገምቱ ይችላሉ። ለምሳሌ: assert list_sort[\"aa\"፣ \"a\"፣ \"aaa\"]) => assert list_sort[\"ab\"፣ \"a\"፣ \"aaa\"፣ \"cd\" => \"cd\" ())\"\"\"\n",
        "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/150",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"n ዋናው ቁጥር ከሆነ የ x ዋጋን መመለስ ያለበት እና አለበለዚያ የ y ዋጋን መመለስ ያለበት ቀላል ፕሮግራም ምሳሌዎች: ለ x_or_y ((7, 34, 12) == 34 ለ x_or_y ((15, 8, 5) == 5 \"\"\"\n",
        "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/151",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef double_the_difference(lst):\n    '''ቁጥሮች ዝርዝር ከተሰጠ, በዝርዝሩ ውስጥ ያሉትን ቁጥሮች ካሬዎች ድምር ይመልሱ. አሉታዊ የሆኑትን ቁጥሮች ችላ ይበሉ ወይም ሙሉ ቁጥሮች አይደሉም. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 የመግቢያ ዝርዝር ባዶ ከሆነ, 0 ይመልሱ '''\n",
        "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/152",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef compare(game,guess):\n    \"\"\"የብዙ ጊዜ የተጠበቀው ክስተት ውጤት በመጨረሻ ሲታወቅ ሁላችንም ያንን ስሜት እናስታውሳለን ብዬ አስባለሁ ። በዚያ ቅጽበት ያለዎት ስሜቶች እና ሀሳቦች በእርግጠኝነት ልብ ሊባል እና ሊወዳደሩ የሚገባቸው ናቸው ። የእርስዎ ተግባር አንድ ሰው የበርካታ ግጥሚያዎችን ውጤት በትክክል እንደገመተው መወሰን ነው ። እኩል ርዝመት ያላቸው ሁለት ነጥቦችን እና ግምቶችን ይሰጥዎታል ፣ እያንዳንዱ መረጃ ጠቋሚ ግጥሚያ የሚያሳይበት። እያንዳንዱ ግምት ምን ያህል እንደቀረ የሚያመለክት ተመሳሳይ ርዝመት ያለው ድርድር ይመልሱ ። በትክክል ከተገመተ ዋጋው 0 ነው ፣ ካልሆነ ግን ዋጋው በግምት እና በደረጃው መካከል ያለው ፍጹም ልዩነት ነው ። ለምሳሌ: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,2,4]) -> [4,0,1,0,6]\"\"\"\n",
        "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/153",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"የክፍል ስም (የአውታር ስም) እና የተራዘመ ዝርዝር ይሰጥዎታል። የተራዘመ ቅጥያዎች ተጨማሪ ክፍሎችን ወደ ክፍሉ ለመጫን ጥቅም ላይ ይውላሉ. የተራዘመ ቅጥያ ጥንካሬ እንደሚከተለው ነው: CAP የቅጥያ ስም ውስጥ ያሉትን ትልልቅ ፊደላት ቁጥር ይሁን, እና SM የቅጥያ ስም ውስጥ ያሉትን ትናንሽ ፊደላት ቁጥር ይሁን, ጥንካሬው በ CAP - SM ክፍል ይሰጣል. በጣም ጠንካራውን ቅጥያ መፈለግ እና በዚህ ቅርጸት ውስጥ አንድ ሰንሰለት መመለስ አለብዎት: ClassName.StrongestExtensionName. ተመሳሳይ ጥንካሬ ያላቸው ሁለት ወይም ከዚያ በላይ ቅጥያዎች ካሉ, በዝርዝሩ ውስጥ መጀመሪያ የሚመጣውን መምረጥ አለብዎት. ለምሳሌ, \"Slices\" እንደ ክፍል እና ቅጥያዎች ዝርዝር: ['SEviviRNGCliES', 'Cheese', 'StuFfed'] ከዚያ 'Slices.SEviRNGCliES' 'SviRNGCliES' 'mySviRNGCliES' ነው ምክንያቱም ጥንካሬው በ ‹AA' (ጥንካሬው ጠንካራ ነው, ለምሳሌ 'AA'_Class'_ StrongestExtension'=1 ነው) '፣\"\"\"\n",
        "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/154",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"2 ቃላት ተሰጥተውሃል:: ሁለተኛውን ቃል ወይም ከማንኛውም አዙሪት ውስጥ የመጀመሪያውን ቃል ውስጥ ንዑስ ገመድ ከሆነ እውነተኛ መመለስ አለብህ cycpattern_check(\"abcd\",\"abd\") => ሐሰተኛ cycpattern_check(\"hello\",\"ell\") => እውነተኛ cycpattern_check(\"whassup\",\"psus\") => ሐሰተኛ cycpattern_check\"abab\",\"baa\") => እውነተኛ cycpattern_check(\"efef\",\"eeff\") => ሐሰተኛ cycpattern_check\"(hims\",\"simen\") => እውነት \"\"\"\n",
        "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/155",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef even_odd_count(num):\n    \"\"\"ሙሉ ቁጥር ከተሰጠ፣ በቅደም ተከተል የቁጥር ቁጥር ያላቸው እና ያልተለመዱ ቁጥሮች ያሉት አንድ የቁጥር ቁጥር ይመልሳል። ምሳሌ: እንኳን_odd_count(-12) ==> (1, 1) እንኳን_odd_count(123) ==> (1, 2) \"\"\"\n",
        "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/156",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"አዎንታዊ የሆነ ሙሉ ቁጥር ከተሰጠ፣ የሮማን አሃዝ ተመጣጣኝ የሆነውን እንደ ሰንሰለት ያግኙ፣ እና በትንሽ ፊደል ይመልሱት። ገደቦች: 1 <= num <= 1000 ምሳሌዎች: >>> int_to_mini_roman ((19) == 'xix' >>> int_to_mini_roman ((152) == 'clii' >>> int_to_mini_roman ((426) == 'cdxxvi' \"\"\"\n",
        "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/157",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''የሶስቱ ጎኖች ርዝመት ከተሰጠ የሶስት ጎኖች ርዝመት ከተሰጠ እውነት ይመልሳል ሶስት ጎኖች ቀኝ ማዕዘን ያለው ሶስት ማዕዘን ቢሆኑም ስህተት ነው ። ቀኝ ማዕዘን ያለው ሶስት ማዕዘን አንድ ማእዘን ቀኝ ማዕዘን ወይም 90 ዲግሪ ያለው ሶስት ማዕዘን ነው ። ምሳሌ: right_angle_triangle ((3, 4, 5) == እውነተኛ ቀኝ_ ማዕዘን_ትሪያንግል ((1, 2, 3) == ስህተት '''\n",
        "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/158",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef find_max(words):\n    \"\"\"የቁምፊዎች ዝርዝር የሚቀበል ተግባር ይጻፉ። ዝርዝሩ የተለያዩ ቃላትን ይ containsል። ከፍተኛውን ልዩ ቁምፊዎች ቁጥር ያለው ቃል ይመልሱ ። በርካታ ሕብረቁምፊዎች ከፍተኛውን ልዩ ቁምፊዎች ቁጥር ካላቸው በቃል አጻጻፍ ቅደም ተከተል መጀመሪያ የሚመጣውን ይመልሱ ።\"\"\"\n",
        "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/159",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"አንተ የተራበ ጥንቸል ነህ, እና አስቀድመው ካሮት የተወሰነ ቁጥር በልተዋል, ነገር ግን አሁን ተጨማሪ ካሮት መብላት አለብዎት የዕለቱን ምግብ ለማጠናቀቅ. አንተ አንድ ድርድር መመለስ አለበት [ከመብላት በኋላ በላ ካሮት ጠቅላላ ቁጥር, ካሮት ቁጥር ከበላችሁ በኋላ ይቀራል ] በቂ ቀሪ ካሮት የለም ከሆነ, ሁሉንም ቀሪ ካሮት ይበላሉ, ነገር ግን አሁንም ይራባቸዋል. ምሳሌ: * መብላት ((5, 6, 10) -> [11, 4] * መብላት ((4, 8, 9) -> [12, 1] * መብላት ((1, 10, 10) -> [11, 0] * መብላት ((2, 11, 5) -> [7, 0] ተለዋዋጮች: @number:: አንተ በላ ካሮት ቁጥር አጠቃላይ ቁጥር. @need:: አንተ መብላት ይኖርብናል ካሮት ቁጥር አጠቃላይ ቁጥር. @remaining:: ቀሪ ካሮት ቁጥር አጠቃላይ ቁጥር: * ቁጥሩ <= 0 = <= 1000 * <= 1000 <= <= 1000 ቀሪ ካሮት ውስጥ አሉ: ቁጥሩ <= 1000 <= 1000 ይዝናኑ:\"\"\"\n",
        "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/160",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"ሁለት ዝርዝሮች ኦፕሬተር እና ኦፐራንድ ተሰጥቷል ። የመጀመሪያው ዝርዝር መሰረታዊ የአልጀብራ ክዋኔዎች አሉት ፣ ሁለተኛው ዝርዝር ደግሞ የሙሉ ቁጥሮች ዝርዝር ነው። የተሰጡትን ሁለት ዝርዝሮች በመጠቀም የአልጀብራ አገላለፅ ይገንቡ እና የዚህን አገላለጽ ግምገማ ይመልሱ ። መሰረታዊ የአልጀብራ ክዋኔዎች: ማከል (+) መቀነስ (-)) ማባዛት ( *) ወለል ክፍፍል ( //) ማስረጃ ( ** ምሳሌ) ኦፕሬተር['+'፣ '*', '-'] ድርድር = [2, 3, 4, 5] ውጤት = 2 + 3 * 4 - 5 => ውጤት = 9 ማስታወሻ: የኦፕሬተር ዝርዝር ርዝመት ከኦፕሬንድ ዝርዝር ርዝመት ጋር እኩል ነው ከ 1 በታች ኦፕሬንድ ከ አሉታዊ ያልሆኑ ሙሉ ቁጥሮች ዝርዝር ነው ኦፕሬተር ቢያንስ አንድ ኦፕሬተር አለው ፣ እና ኦፕሬንድ ዝርዝር ቢያንስ ሁለት ኦፕሬንዶች አሉት \"\"\"\n",
        "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/161",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef solve(s):\n    \"\"\"አንድ string s ተሰጥቶሃል s[i] ፊደል ከሆነ ካሴቱን ከታች ወደ ላይ ወይም በተቃራኒው ይለውጡት አለበለዚያ እንደነበረው ይተውት ።\"\"\"\n",
        "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/162",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef string_to_md5(text):\n    \"\"\"የተሰጠው ሕብረቁምፊ 'ጽሑፍ'፣ md5 ሃሽ ተመጣጣኝ ሕብረቁምፊውን ይመልሱ። 'ጽሑፍ' ባዶ ሕብረቁምፊ ከሆነ፣ None ይመልሱ። >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' \"\"\"\n",
        "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    },
    {
        "task_id": "HumanEval/163",
        "nl": "amh_Ethi",
        "pl": "python",
        "prompt": "\ndef generate_integers(a, b):\n    \"\"\"ሁለት አዎንታዊ ሙሉ ቁጥሮች ሀ እና ለ የተሰጡ ከሆነ በ a እና b መካከል ያሉትን እኩል ቁጥሮች በማደግ ላይ ቅደም ተከተል ይመልሱ ። ለምሳሌ: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] \"\"\"\n",
        "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n",
        "Unnamed: 6": "",
        "Unnamed: 7": "",
        "Unnamed: 8": ""
    }
]