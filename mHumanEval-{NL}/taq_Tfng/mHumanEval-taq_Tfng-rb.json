[{"task_id":"HumanEval_0","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⴱⴰⵔⴰⵣ ⵏ ⵓⵙⵙⵉⵔⴰⵔⵣⵣⵓ ⴳ ⵡⴰⵏⵙⴰ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵀⴰⵜ ⵉⵍⵍⴰ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⵉⵏ ⵢⵓⵙⴰⵏ ⵉⵏⴳⵔⵙⵏ ⵓⴳⴳⴰⵔ ⵏ # >>> has_close_elements.call([1.0, 2.0, 3.0], 0.5)\n# false\n# >>> has_close_elements.call([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# true\ndef has_close_elements(numbers, threshold)\n","canonical_solution":"def has_close_elements(numbers, threshold)\n  numbers.combination(2).any? { |a, b| (a - b).abs < threshold }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_has_close_elements\n    candidate = method(:has_close_elements)\n    assert_equal(true, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3))\n    assert_equal(false, candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05))\n    assert_equal(true, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95))\n    assert_equal(false, candidate.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8))\n    assert_equal(true, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1))\n    assert_equal(true, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0))\n    assert_equal(false, candidate.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5))\n  end\nend\n"},{"task_id":"HumanEval_1","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵥⵎ ⴽⵔⴰ ⵏ ⵡⴰⵏⵙⴰ ⴳ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ.ⵜⴰⵔⵓⴱⴱⴰ ⵉⴱⴹⴰⵏ ⵜⵜⵓⵙⵎⵙⴰⵙⴰⵏ (ⵢⴰⵜⵜⵓⵢ ⵏ ⴽⵓ ⵜⴰⴱⵔⴰⵜⴰ ⵉⵕⵥⵎⵏ ⵉⵜⵜⵓⵙⵎⵓⵏ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵉⵅⵚⵚⴰⵏ) ⴷ ⵓⵔ ⵜⵜⵓⵙⵎⵓⵏ ⴳ ⵢⴰⵏ ⵔⴱⴹⵓ ⵏ ⵜⵔⴰⴱⴱⵓⵜ ⴰⴷ ⵖⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵥⵍⵉⵏ ⴷ ⵓⵙⵡⴰⵍⴰ ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵉⵏⵏⴰ.ⴷⴰ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵓⵡⵡⵓⵔ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⵉⴼⵔⴽⵜ ⴳ ⵍⵍⴰⵏⵜ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⴱⵕⴰⵏⴽⵉⵙⵉⵏ ⵉⵜⵜⵓⵙⵎⵓⵏⵏ. ⴰⵡⵜⵜⴰⵙ ⵏⵏⴽ ⵉⴳⴰ ⴰⴷ # >>> separate_paren_groups.call(\"( ) (( )) (( )( ))\")\n# [\"()\", \"(())\", \"(()())\"]\ndef separate_paren_groups(paren_string)\n","canonical_solution":"def separate_paren_groups(paren_string)\n  # Remove spaces from the string\n  paren_string = paren_string.gsub(\" \", \"\")\n  \n  result = []\n  current_group = \"\"\n  balance = 0\n\n  paren_string.each_char do |char|\n    current_group += char\n    balance += 1 if char == '('\n    balance -= 1 if char == ')'\n\n    if balance == 0 && !current_group.empty?\n      result << current_group\n      current_group = \"\"\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_separate_paren_groups\n    candidate = method(:separate_paren_groups)\n    assert_equal([\"(()())\", \"((()))\", \"()\", \"((())()())\"], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([\"()\", \"(())\", \"((()))\", \"(((())))\"], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([\"(()(())((())))\"], candidate.call(\"(()(())((())))\"))\n    assert_equal([\"()\", \"(())\", \"(()())\"], candidate.call(\"( ) (( )) (( )( ))\"))\n  end\nend\n"},{"task_id":"HumanEval_2","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔ ⵏ ⵓⴳⵣⵣⵓⵎ ⴰⵎⵔⴰⵡ ⵏ ⵡⵓⵟⵟⵓⵏ.(ⴰⵛⵔⵓⵜ ⵏ ⵓⵛⵔⴰⵉ ⴰⵀⴰ ⵉⴳⴰ ⴰⵎⵥⵥⵢⴰⵏ ⵙⴳ 1).ⴷ ⵓⴳⵣⵣⵓⵎ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ (ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵉⵎⵥⵥⵉⵢⵏ ⵙⴳ ⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⵔⴰⵡⵏ ⵉⵖ ⵏⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ, ⵏⵣⵎⵔ ⴰⴷ ⵏⵙⴱⴹ # >>> truncate_number.call(3.5)\n# 0.5\ndef truncate_number(number)\n","canonical_solution":"def truncate_number(number)\n  number - number.to_i\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n  end\nend\n"},{"task_id":"HumanEval_3","nl":"taq_Tfng","pl":"rb","prompt":"ⴳ ⵜⵏⵇⵇⵉⴹⵜ ⴰⴷ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵎⵔⵙⵜ ⵜⵉⴷⵜ. ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵉⴷⵜ.ⴰⵛⴰⵍ ⵓⴰⵏ ⵏⴻⴱⵓⵍⴰⵜⴻ ⵜⴰⵏ ⵓⵉⵏ ⴰⴾⴰⵍ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⴻⵜ ⴰⵂⴰⵏⴰⵜ ⴰⵙⵉⴾⵏⴻ ⵏ ⴰⵙⵉⴾⵏⴻ ⵏ ⴰⴾⴰⵍ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜⴷⴰ ⵜⵜⵓⴼⴽⴰ ⴽⵉⴳⴰⵏ ⵏ ⵜⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵓⵙⵙⴰⵔⵓ ⴷ ⵓⵙⵙⴰⵢ ⴳ ⵓⵙⵙⵉⴹⵏ ⵏ ⵍⴱⴰⵏⴽ ⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ # >>> below_zero.call([1, 2, 3])\n# false\n# >>> below_zero.call([1, 2, -4, 5])\n# true\ndef below_zero(operations)\n","canonical_solution":"def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_zero\n    candidate = method(:below_zero)\n    assert_equal(false, candidate.call([]))\n    assert_equal(false, candidate.call([1, 2, -3, 1, 2, -3]))\n    assert_equal(true, candidate.call([1, 2, -4, 5, 6]))\n    assert_equal(false, candidate.call([1, -1, 2, -2, 5, -5, 4, -4]))\n    assert_equal(true, candidate.call([1, -1, 2, -2, 5, -5, 4, -5]))\n    assert_equal(true, candidate.call([1, -2, 2, -2, 5, -5, 4, -4]))\n  end\nend\n"},{"task_id":"HumanEval_4","nl":"taq_Tfng","pl":"rb","prompt":"MAD=ⴰⵎⵎⴰⵜⵜⴰⵢ. x - x_ⵎⵉⵏ.ⴰⵛⵔⵓⵜ ⴷ ⵜⵉⵜⴱⴰⵈⴻⵜ ⵜⴰⵏ ⴰⵎⵎⴰⵙ (ⴰⵎⴰⵣⴰⵔⴰⵏ ⴷⴰⵗ ⴰⵍⵓⴰⵈ ⵓⴻⵏ):ⴰⵎⵣⴰⵔⴰⵢ ⵏ ⵓⵖⵣⵓⵔⴰⵏ ⴰⵎⵏⵉⴳ ⵉⴳⴰ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ ⴳⵔ ⴽⵓ ⴰⵂⴰⵏⴷⴰⴶ ⵏ ⴰⵎⵎⴰⵙ ⵏ ⴷⴰⵜⴰ ⵙⵢⵜ ⵓⵢⵏⵉ ⵓⵎⵙⴳⵔⴰⵡ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵙⴽⵛⵛⵓⵎⵏ, ⵙⵙⵓⴷⵙ ⴰⵎⵏⵣⴰⵢ ⴰⵖⴰⵔⴰⵏ # >>> mean_absolute_deviation.call([1.0, 2.0, 3.0, 4.0])\n# 1.0\ndef mean_absolute_deviation(numbers)\n","canonical_solution":"def mean_absolute_deviation(numbers)\n  mean = numbers.sum.to_f \/ numbers.size\n  deviations = numbers.map { |num| (num - mean).abs }\n  deviations.sum \/ numbers.size\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0, 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2, candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"},{"task_id":"HumanEval_5","nl":"taq_Tfng","pl":"rb","prompt":"\"ⴰⴷ ⵢⴰⵛ ⵓⵟⵟⵓⵏ \" ⴷⵓⵍⵉⵎⵉⵜⵔ \" ⴳⵔ ⴽⵓ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴷⴰⵢⵏ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⵙⴽⵛⵎ \" `numbers\" # >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1, 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n","canonical_solution":"def intersperse(numbers, delimeter)\n  return numbers if numbers.empty?\n  result = []\n  numbers.each_with_index do |num, index|\n    result << num\n    result << delimeter unless index == numbers.size - 1\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2, 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"},{"task_id":"HumanEval_6","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ (() (()) ⵖⵓⵔⵙ ⵙⵉⵏ ⵉⵙⵡⵉⵔⵏ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⴳ ⵜⵉⵣⵉ ⵏⵏⴰ ⴳ ⵖⵓⵔ ((())) ⴽⵕⴰⴹ. ⵉ ⴽⵓ ⵜⴰⵔⴰⴱⴱⵓⵜ, ⵙⵏⵓⵍⴼⵓ ⴰⵙⵡⵉⵔ ⵏ ⵓⴱⵔⴰⵏⵜⵉⵙ ⵉⴳⴳⵓⵜⵏ.ⴷⴰ ⵉⵜⵜⵓⵙⴽⴰⵔ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵡⵓⵔⵉ ⴰⴷ ⵙ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⵉⵙⵎⴷⵢⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵔⵓⴱⴱⴰ ⵉ ⵜⴱⵕⴰⵏⴽⵉⵙⵜⵉⵏ ⵉⵜⵜⵓⵙⴱⴹⴰⵏ ⵙ ⵉⵎⵣⴰⵔⴰⵢⵏ.# >>> parse_nested_parens.call(\"(()()) ((())) () ((())()())\")\n# [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n","canonical_solution":"def parse_nested_parens(paren_string)\n  paren_string.split.map do |group|\n    max_depth = current_depth = 0\n    group.chars.each do |char|\n      if char == '('\n        current_depth += 1\n        max_depth = [max_depth, current_depth].max\n      elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"(()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"() (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"))\n  end\nend\n"},{"task_id":"HumanEval_7","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⵓⵙⴼⵉⵍⵍ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵜⵉⴼⵉⵏⴰⵖ # >>> filter_by_substring.call([], \"a\")\n# []\n# >>> filter_by_substring.call([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"bacd\", \"array\"]\ndef filter_by_substring(strings, substring)\n","canonical_solution":"def filter_by_substring(strings, substring)\n  strings.select { |string| string.include?(substring) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"))\n  end\nend\n"},{"task_id":"HumanEval_8","nl":"taq_Tfng","pl":"rb","prompt":"ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵓⵎⴹⴰⵏ ⵏ ⵓⴽⵙⵓⵎ ⴰⵣⴳⵏ ⴷ ⵓⵎⴹⴰⵏ ⵏ ⵓⴽⵙⵓⵎ ⴰⵣⴳⵏ ⴷ 1.ⵉ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵖⵣⵓⵔ ⴷ ⵓⵙⴼⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⵙⵍ.# >>> sum_product.call([])\n# [0, 1]\n# >>> sum_product.call([1, 2, 3, 4])\n# [10, 24]\ndef sum_product(numbers)\n","canonical_solution":"def sum_product(numbers)\n  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  [sum, product]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0], candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"},{"task_id":"HumanEval_9","nl":"taq_Tfng","pl":"rb","prompt":"ⴳ ⵓⴹⴼⴼⵉⵕ.ⵙⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴼⵖ ⴰⵎⵙⴳⵏⴰⴼ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵇⵇⵓⵔⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⴰⵔ ⵜⵉⵣⵉ ⵏⵏⴰ ⵉⵜⵜⵢⴰⴼⴰⵏ # >>> rolling_max.call([1, 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n","canonical_solution":"def rolling_max(numbers)\n  max_so_far = numbers.first\n  numbers.map do |num|\n    max_so_far = [max_so_far, num].max\n  end\nend\n\n# Example usage:\n# puts rolling_max([1, 2, 3, 2, 3, 4, 2]).inspect","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4, 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100], candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"},{"task_id":"HumanEval_10","nl":"taq_Tfng","pl":"rb","prompt":"- ⴰⴷ ⵢⴰⵣⴰⵔ ⵙ ⵜⴳⵉⵔⴰ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⵏ ⵜⵣⵡⴰⵔⵜ ⵏⵏⴰ ⵉⵜⵜⴰⴷⴼⵏ ⴷⴰⵜ ⵏ ⵓⴷⴼⵍ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ.- ⴰⵔⴰⵎ ⴰⴷ ⵏⴰⴼ ⵜⵉⵣⵉ ⵜⴰⵖⵣⵉⴼⵜ ⵏ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ.ⵜⴰⵡⵏⴳⵉⵎⵜ ⵏ ⴰⵍⴳⵓⵔⵉⵜⵎ ⵜⴳⴰ ⵜⴰⴼⵔⴰⵔⵜ: ⴹⴼⵔ ⴰⵎⵣⵔⵓⵢ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵏⵏⴰ ⵉⵜⵜⴱⴷⴰⴷⵏ ⵙ ⵜⵉⴼⵉⵏⴰⵖ.# >>> make_palindrome.call(\"\")\n# \"\"\n# >>> make_palindrome.call(\"cat\")\n# \"catac\"\n# >>> make_palindrome.call(\"cata\")\n# \"catac\"\ndef make_palindrome(string)\n","canonical_solution":"def make_palindrome(string)\n  return string if string.empty?\n\n  def is_palindrome?(s)\n    s == s.reverse\n  end\n\n  (0...string.length).reverse_each do |i|\n    if is_palindrome?(string[i..-1])\n      return string + string[0...i].reverse\n    end\n  end\n\n  string\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\", candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"},{"task_id":"HumanEval_11","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵏⵙⴽⴰⵔ XOR ⴱⵉⵏⴰⵔⵉ ⵅⴼ ⵉⵙⴽⵛⵛⵓⵎⵏ ⴰⴷ ⴷ ⴷⴰ ⵏⵙⴽⵛⵎ ⵜⴰⵢⴰⴼⵓⵜ ⴰⵡⴷ ⵙ ⵜⴰⵍⵖⴰ.ⴳⴰⵏ ⵉⵏⴽⵛⵛⵓⵎⵏ ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ a ⴷ b ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ 1 ⴷ 0 ⵅⵙ.# >>> string_xor.call(\"010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n","canonical_solution":"def string_xor(a, b)\n  result = \"\"\n  a.length.times do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"},{"task_id":"HumanEval_12","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ nil ⴳ ⵡⴰⴷⴷⴰⴷ ⵏⵏⴰ ⴳ ⵓⵔ ⵉⵍⵍⵉ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⴽⵛⵛⵓⵎ.ⵙⴳ ⵓⵎⵙⴰⵙⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⴽⵔ ⵜⵉⵣⵉ ⵜⴰⵖⴰⵔⴰⵏⵜ. ⵙⴽⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ ⴳ ⵡⴰⴷⴷⴰⴷ ⵏ ⴽⵉⴳⴰⵏ ⵏ # >>> longest.call([])\n# nil\n# >>> longest.call([\"a\", \"b\", \"c\"])\n# \"a\"\n# >>> longest.call([\"a\", \"bb\", \"ccc\"])\n# \"ccc\"\ndef longest(strings)\n","canonical_solution":"def longest(strings)\n  return nil if strings.empty?\n  strings.max_by(&:length)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n    assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n  end\nend\n"},{"task_id":"HumanEval_13","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔⵏ ⴰⵎⵟⵟⵓ ⴰⵎⵛⵛⵓⵔⴰⵔ ⴰⵎⵇⵔⴰⵏ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⴷ b # >>> greatest_common_divisor.call(3, 5)\n# 1\n# >>> greatest_common_divisor.call(25, 15)\n# 5\ndef greatest_common_divisor(a, b)\n","canonical_solution":"def greatest_common_divisor(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3, 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49, 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"},{"task_id":"HumanEval_14","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵏⴼⴰⵔⵏ ⵙⴳ ⵓⵥⵥⵉⴹⵕ ⴰⵔ ⵓⵣⵣⵓⵣⵔ ⵏ ⵜⵣⵍⵉⵜ ⵏ ⵓⵙⴽⵛⵎ # >>> all_prefixes.call(\"abc\")\n# [\"a\", \"ab\", \"abc\"]\ndef all_prefixes(string)\n","canonical_solution":"def all_prefixes(string)\n  (1..string.length).map { |i| string[0, i] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"], candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"WWW\"))\n  end\nend\n"},{"task_id":"HumanEval_15","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ ⴳ ⵓⵎⵣⵡⴰⵔⵓ ⵙⴳ 0 ⴰⵔ n.# >>> string_sequence.call(0)\n# \"0\"\n# >>> string_sequence.call(5)\n# \"0 1 2 3 4 5\"\ndef string_sequence(n)\n","canonical_solution":"def string_sequence(n)\n  (0..n).to_a.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_16","nl":"taq_Tfng","pl":"rb","prompt":"ⴹⴰⵗ ⵜⴰⵔⵔⴰⵉⵜ, ⵙⴰⴾⵏⵢⴷ ⵉⵎⵎⵉⴾ ⵓⴰ ⵙ ⵉⵋⵋⴰ # >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>> count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n","canonical_solution":"def count_distinct_characters(string)\n  string.downcase.chars.uniq.count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5, candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"},{"task_id":"HumanEval_17","nl":"taq_Tfng","pl":"rb","prompt":"\"ⵂⴰⵛⴻ\" - ⴰⴾⴰⵜⴰⴱ ⵏ ⴰⴾⴾⵓⵣ, ⵉⴾⴾⴰ ⵜⴰⴾⴾⴰⵛⵜ\"oⴰⵙⵂⴰⴾⵉ\" - ⴰⵛⵂⵔⵓⵜ ⵏ ⵏⵓⵜⵢ, ⵉⴾⴾⴰⵏ ⵙⴰⵏⴰⵜⴰⵜ ⵉⴾⵉⴰⵏ\"o\" - ⴰⴾⴰⵜⴰⴱ ⴰⴾⴾⴰⵔⴰⵏ, ⵉⴾⴾⴰⵓⴰⵏ ⴰⴾⴾⵓⵣ ⴾⴰⵍⴰ ⵉⵍⴰⵏ ⴰⵍⴰⵗⵉ:ⵓⴰⵔ ⵢⵈⵢⵍ ⵓⴰ ⵢⵔⴰⵓⴰⵏ.ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴼⵙⵉ ⵜⴰⵡⴰⵍⵜ ⴰⴷ ⴷ ⴰⴷ ⵜⵙⴽⵔ ⴰⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴽⵙⵙⵉ ⵏ ⴽⵓ ⵜⴰⵡⴰⵍⵜ.ⴷⴰ ⵉⵜⵜⵓⵙⴽⵛⵎ ⵓⵏⴰⵎⴽ ⴰⴷ ⵙ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵉ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵓⵥⴰⵡⴰⵏ ⵙ ⵜⵍⵖⴰ ⵉⵥⵍⵉⵏ ⵏ ASCII.# >>> parse_music.call(\"o o| .| o| o| .| .| .| .| o o\")\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n","canonical_solution":"def parse_music(music_string)\n  # Split the input string into individual notes.\n  notes = music_string.split\n\n  # Map each note to its corresponding number of beats.\n  notes.map do |note|\n    case note\n    when 'o'\n      4\n    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1, 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4, 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1, 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"},{"task_id":"HumanEval_18","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵎⵙⵏ ⵎⵏⵏⴰⵡⵜ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵖⵢ ⴰⴷ ⵢⵉⵍⵉ ⵓⵙⴽⴽⵉⵍ ⴰⵎⵏⴹⴰⵡ ⴳ ⵜⴽⵔⵔⴰⵢⵜ ⵜⴰⵢⵍⴰⵏⵜ. ⵔⵎⵙⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵙⴳⴷⴰⵍⵏ.# >>> how_many_times.call(\"\", \"a\")\n# 0\n# >>> how_many_times.call(\"aaa\", \"a\")\n# 3\n# >>> how_many_times.call(\"aaaa\", \"aa\")\n# 3\ndef how_many_times(string, substring)\n","canonical_solution":"def how_many_times(string, substring)\n  return 0 if substring.empty?\n  count = 0\n  i = 0\n  while i <= string.length - substring.length\n    if string[i, substring.length] == substring\n      count += 1\n    end\n    i += 1\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\", \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4, candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"john doe\", \"john\"))\n  end\nend\n"},{"task_id":"HumanEval_19","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵜⵉⴼⵔⴽⵜ ⵙ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙⴳ ⵡⵉⵏ ⵉⵎⵥⵥⵉⵏ ⴰⵔ ⵡⵉⵏ ⵉⵎⵇⵇⵔⴰⵏ ⵉⵙⵜⴰⵢⵏ ⵉⵣⵔⴼⴰⵏ ⴳⴰⵏ \"ⵥⵕⵓ\", \"ⵢⴰⵏ\", \" ⵙⵉⵏ\", \" ⴽⵕⴰⴹ\", \" ⴽⴽⵓⵥ\", \" ⵙⵎⵎⵓⵙ\", \"ⵚⴹⵉⵚ\", \" ⵙⴰ\", \" ⵜⴰⵎ\" ⴷ \" ⵜⵥⴰ\".\"ⵉⴽⴽⵉ ⵏ ⵓⴹⴼⵕ ⵉⴳⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ \"ⴰⵎⵢⴰ\" ⴰⵔ \"ⵜⵥⴰ\".# >>> sort_numbers.call(\"three one five\")\n# \"one three five\"\ndef sort_numbers(numbers)\n","canonical_solution":"def sort_numbers(numbers)\n  numeral_map = {\n    'zero' => 0,\n    'one' => 1,\n    'two' => 2,\n    'three' => 3,\n    'four' => 4,\n    'five' => 5,\n    'six' => 6,\n    'seven' => 7,\n    'eight' => 8,\n    'nine' => 9\n  }\n\n  number_words = numbers.split\n  sorted_numbers = number_words.sort_by { |word| numeral_map[word] }\n  sorted_numbers.join(' ')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six five four three two one zero\"))\n  end\nend\n"},{"task_id":"HumanEval_20","nl":"taq_Tfng","pl":"rb","prompt":"ⴹⴰⵔⴰⵜ ⵓⵢⵏ, ⴰⴷⴷⵉⴾⵓⴷ ⵏ ⵉⴾⵉ ⵏ ⴰⵍⴾⴰⴷ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⵓⵢⵏ (ⵉⴾⵉ ⵏ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵎⴰⴷⵔⵓⵉⵏ, ⵉⴾⵉ ⵏ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵎⴰⵈⵈⵓⵔⴰⵏ)ⵙⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ (ⵙ ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵓⵔ ⵉⴷⵔⵓⵙ ⵙⵉⵏ) ⵙⵜⴰⵢ ⴷ ⵙⵔⴷⵙⵏ ⵙⵉⵏ ⵡⵉⵏⵏⴰ ⵢⵓⴳⵔⵏ ⴽⵓ ⵢⴰⵏ # >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n# [2.0, 2.2]\n# >>> find_closest_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# [2.0, 2.0]\ndef find_closest_elements(numbers)\n","canonical_solution":"def find_closest_elements(numbers)\n  sorted_numbers = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  min_difference = (sorted_numbers[1] - sorted_numbers[0]).abs\n\n  (1...(sorted_numbers.length - 1)).each do |i|\n    current_difference = (sorted_numbers[i + 1] - sorted_numbers[i]).abs\n    if current_difference < min_difference\n      min_difference = current_difference\n      closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    end\n  end\n\n  closest_pair\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0, 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2, 3.1, 4.1, 5.1]))\n  end\nend\n"},{"task_id":"HumanEval_21","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵢⴰ ⴰⵖⵢⴰⵏ ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ 0 ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ ⵔⴰⴷ ⵉⴳ 1ⴳ ⵓⵙⵔⵙⵉ ⵏ ⵡⵓⵟⵟⵓⵏ (ⵙ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⴷⵖⴰⵔ), ⵙⵙⵎⵔⵙⵏ ⴰⵙⵏⴼⵍ ⴰⵎⵉⵔⵉⵡ ⴳ ⵓⵙⵔⵙⵉ, # >>> rescale_to_unit.call([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers)\n","canonical_solution":"def rescale_to_unit(numbers)\n  min = numbers.min\n  max = numbers.max\n  range = max - min\n  return numbers.map { |num| (num - min) \/ range.to_f }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0, 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0, 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25, 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\nend\n"},{"task_id":"HumanEval_22","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵎⵙⴳⴷⴰⵍ ⵏ ⴽⵔⴰ ⵏ ⵡⴰⵜⵉⴳⵏ ⵏ rbthon ⵖⴰⵙ ⵉ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ # >>> filter_integers.call([\"a\", 3.14, 5])\n# [5]\n# >>> filter_integers.call([1, 2, 3, \"abc\", {}, []])\n# [1, 2, 3]\ndef filter_integers(values)\n","canonical_solution":"def filter_integers(values)\n  values.select { |value| value.is_a?(Integer) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n    assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\nend\n"},{"task_id":"HumanEval_23","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵓⵜⵓⵔ ⵍⵓⵏⴳ ⵏ ⵜⵔⵉⵏⴳ # >>> strlen.call(\"\")\n# 0\n# >>> strlen.call(\"abc\")\n# 3\ndef strlen(string)\n","canonical_solution":"strlen = lambda do |string|\n  string.length\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"asdasnakj\"))\n  end\nend\n"},{"task_id":"HumanEval_24","nl":"taq_Tfng","pl":"rb","prompt":"ⵉ ⵓⵎⴹⴰⵏ n, ⴷⴼⵔ ⴰⵎⴹⴰⵏ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵉⵜⵜⴱⴹⵓⵏ n ⵙ ⵜⴰⵖⴹⴼⵜ, ⴷ ⵉⵎⵥⵥⵉⵏ ⵙⴳ n # >>> largest_divisor.call(15)\n# 5\ndef largest_divisor(n)\n","canonical_solution":"def largest_divisor(n)\n  (n - 1).downto(1) do |i|\n    return i if n % i == 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n  end\nend\n"},{"task_id":"HumanEval_25","nl":"taq_Tfng","pl":"rb","prompt":"ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⵙⴽⵛⵎ ⴰⵎⵎ ⵓⵢⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴰⴽⴽⵡ ⴽⵓ ⵢⴰⵏ ⴳ ⵉⵎⴳⴳⵉⵜⵏ ⴰⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⵉⵣⴷⵉⵏ ⴷ ⵡⵓⵟⵟⵓⵏ ⵏⵏⴰ ⴳ ⴷⴰ ⵢⴰⴷⴼ ⴳ ⵓⵙⴼⵙⵉ.ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵎⵙⴷⵉ ⵏ ⵉⵎⴳⴳⵉⵜⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⵙⴳ ⵓⵥⵥⵉⵢⵏ ⴰⵔ ⵓⵅⴰⵜⴰⵔ.# >>> factorize.call(8)\n# [2, 2, 2]\n# >>> factorize.call(25)\n# [5, 5]\n# >>> factorize.call(70)\n# [2, 5, 7]\ndef factorize(n)\n","canonical_solution":"def factorize(n)\n  factors = []\n  divisor = 2\n  while n > 1\n    while n % divisor == 0\n      factors << divisor\n      n \/= divisor\n    end\n    divisor += 1\n  end\n  factors\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_factorize\n    candidate = method(:factorize)\n    assert_equal([2], candidate.call(2))\n    assert_equal([2, 2], candidate.call(4))\n    assert_equal([2, 2, 2], candidate.call(8))\n    assert_equal([3, 19], candidate.call(57))\n    assert_equal([3, 3, 19, 19], candidate.call(3249))\n    assert_equal([3, 3, 3, 19, 19, 19], candidate.call(185193))\n    assert_equal([3, 19, 19, 19], candidate.call(20577))\n    assert_equal([2, 3, 3], candidate.call(18))\n  end\nend\n"},{"task_id":"HumanEval_26","nl":"taq_Tfng","pl":"rb","prompt":"ⵃⴹⵓ ⵜⴰⵍⵖⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵙ ⵓⴱⵔⵉⴷ ⵏ ⵓⵙⴽⵛⵎ.ⵙⴳ ⵓⵎⵙⴷⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⵉⵜⵜⵊⵕⵓⵏ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ.# >>> remove_duplicates.call([1, 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n","canonical_solution":"def remove_duplicates(numbers)\n  numbers.select { |num| numbers.count(num) == 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1, 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"},{"task_id":"HumanEval_27","nl":"taq_Tfng","pl":"rb","prompt":" ⵉ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵙⵓⵜⵍ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴷ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵇⵔⴰⵏⵏ ⵙ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ.# >>> flip_case.call(\"Hello\")\n# \"hELLO\"\ndef flip_case(string)\n","canonical_solution":"def flip_case(string)\n  string.swapcase\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights have violent ends\"))\n  end\nend\n"},{"task_id":"HumanEval_28","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵙⵎⵓⵏ ⵏ ⵜⵓⴳⵜ ⵏ ⵉⵙⵉⴹⵏ ⴳ ⵢⴰⵏ ⵓⵙⵉⴹⵏ # >>> concatenate.call([])\n# \"\"\n# >>> concatenate.call([\"a\", \"b\", \"c\"])\n# \"abc\"\ndef concatenate(strings)\n","canonical_solution":"def concatenate(strings)\n  strings.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_concatenate\n    candidate = method(:concatenate)\n    assert_equal(\"\", candidate.call([]))\n    assert_equal(\"xyz\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"xyzwk\", candidate.call([\"x\", \"y\", \"z\", \"w\", \"k\"]))\n  end\nend\n"},{"task_id":"HumanEval_29","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⴽⵛⵛⵓⵎ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵉ ⵡⵉⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵙ ⵢⴰⵜ ⵜⵣⵍⵖⴰ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵏ.# >>> filter_by_prefix.call([], \"a\")\n# []\n# >>> filter_by_prefix.call([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n# [\"abc\", \"array\"]\ndef filter_by_prefix(strings, prefix)\n","canonical_solution":"def filter_by_prefix(strings, prefix)\n  strings.select { |string| string.start_with?(prefix) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_prefix\n    candidate = method(:filter_by_prefix)\n    assert_equal([], candidate.call([], \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n  end\nend\n"},{"task_id":"HumanEval_30","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵖⴰⵙ ⵉⵎⴹⴰⵏ ⵉⴳⴳⵓⴷⵉⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ.# >>> get_positive.call([-1, 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n","canonical_solution":"get_positive = lambda do |l|\n  l.select { |num| num > 0 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1, -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1, -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_31","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵔ ⵉⵜⵜⴰⵍⵙ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵜⵉⵔⵡⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ.# >>> is_prime.call(6)\n# false\n# >>> is_prime.call(101)\n# true\n# >>> is_prime.call(11)\n# true\n# >>> is_prime.call(13441)\n# true\n# >>> is_prime.call(61)\n# true\n# >>> is_prime.call(4)\n# false\n# >>> is_prime.call(1)\n# false\ndef is_prime(n)\n","canonical_solution":"is_prime = lambda do |n|\n  return false if n <= 1\n  return true if n == 2\n  return false if n.even?\n\n  max_divisor = Math.sqrt(n).to_i\n  (3..max_divisor).step(2).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_prime\n    candidate = method(:is_prime)\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(101))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(13441))\n    assert_equal(true, candidate.call(61))\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(1))\n    assert_equal(true, candidate.call(5))\n    assert_equal(true, candidate.call(11))\n    assert_equal(true, candidate.call(17))\n    assert_equal(false, candidate.call(85))\n    assert_equal(false, candidate.call(77))\n    assert_equal(false, candidate.call(255379))\n  end\nend\n"},{"task_id":"HumanEval_33","nl":"taq_Tfng","pl":"rb","prompt":"ⵉⵍⴰⵏ ⴰⵜⵉⴳ ⵏ ⵉⵙⴼⴽⴰ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ \"ⵍ\", ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.l' ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷ l ⴳ ⵉⵙⵏⵎⴰⵍⵏ ⵏⵏⴰ ⵓⵔ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ, ⵎⴰⵛⴰ ⵜⵉⵏⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⵎⴰⵍⵏ ⵏⵏⴰ ⵉⵜⵜⵓⵣⵟⵟⴰⵢⵏ ⵙ ⴽⵕⴰⴹ ⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷⴰ ⵜⴽⴽⴰ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ l ⴰⵔ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ l' ⵣⵓⵏⴷ ⵎⴰⵙ # >>> sort_third.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third.call([5, 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n","canonical_solution":"def sort_third(l)\n  divisible_by_three = l.each_with_index.select { |_, idx| idx % 3 == 0 }.map(&:first).sort\n  l.each_with_index.map { |val, idx| idx % 3 == 0 ? divisible_by_three.shift : val }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5, 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5, 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5, 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5, 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"},{"task_id":"HumanEval_34","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵥⵍⴰⵢⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ # >>> unique.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n","canonical_solution":"def unique(l)\n  l.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_35","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵇⵇⵓⵔⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ.# >>> max_element.call([1, 2, 3])\n# 3\n# >>> max_element.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n","canonical_solution":"def max_element(l)\n  l.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2, 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]))\n  end\nend\n"},{"task_id":"HumanEval_36","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔ ⵏ ⵓⵎⴹⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵓⵟⵟⵓⵏ 7 ⴳ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵥⵥⵉⵏ ⵏⵏⴰ ⵓⵔ ⵢⴰⴽⵙⵓⵍⵏ ⵙ 11 ⵏⵖⴷ 13. # >>> fizz_buzz.call(50)\n# 0\n# >>> fizz_buzz.call(78)\n# 2\n# >>> fizz_buzz.call(79)\n# 3\ndef fizz_buzz(n)\n","canonical_solution":"def fizz_buzz(n)\n  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 || i % 13 == 0\n      count += i.to_s.count('7')\n    end\n  end\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n    assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n    assert_equal(8026, candidate.call(100000))\n  end\nend\n"},{"task_id":"HumanEval_37","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵡⴰⵜⵉⴳⵏ ⵏ ⵉⵙⵖⵏⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏ \"ⵍ\", ⵎⴰⵛⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.I ⴰⵎⵙⴰⵙⴰ ⴷ I ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵎⴰⵛⴰ ⵜⵉⵜⵉⴳⵉⵏ ⵏⵏⵙ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳⴰⵏⵜ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴷⴰ ⵜⴽⴽⴰ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⴳⵔⵓⵎⵎⴰ l ⴰⵔ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ l' ⵣⵓⵏⴷ ⵎⴰⵙ # >>> sort_even.call([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_even.call([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n","canonical_solution":"def sort_even(l)\n  even_indices = l.each_index.select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  \n  even_index = 0\n  l.each_with_index.map do |value, index|\n    if index.even?\n      even_values[even_index].tap { even_index += 1 }\n    else\n      value\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1, 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\nend\n"},{"task_id":"HumanEval_39","nl":"taq_Tfng","pl":"rb","prompt":"prime_fib ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵙ-ⵏⵏⴰ ⵉⴳⴰⵏ ⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⴷ ⵉⴳⴰ ⴰⵡⴷ ⴰⵎⵣⵡⴰⵔⵓ. # >>> prime_fib.call(1)\n# 2\n# >>> prime_fib.call(2)\n# 3\n# >>> prime_fib.call(3)\n# 5\n# >>> prime_fib.call(4)\n# 13\n# >>> prime_fib.call(5)\n# 89\ndef prime_fib(n)\n","canonical_solution":"def prime_fib(n)\n  require 'prime'\n  \n  fibs = Enumerator.new do |y|\n    a, b = 0, 1\n    loop do\n      a, b = b, a + b\n      y << b\n    end\n  end\n  \n  prime_fibs = fibs.lazy.select { |fib| Prime.prime?(fib) }\n  prime_fibs.first(n).last\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n    assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n    assert_equal(433494437, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_40","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵜⵉⴳ ⵏ ⵓⵎⵢⴰ, ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⵏⵙⴰ ⵢⴰⴹⵏ.ⴷⴰ ⵉⵜⵜⴰⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⴰⵙⵉ ⵡⴰⵏⵙⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵣⵓⵏⴷ ⵜⴰⵏⴽⵔⴰ.# >>> triples_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> triples_sum_to_zero.call([1, 3, -2, 1])\n# true\n# >>> triples_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> triples_sum_to_zero.call([2, 4, -5, 3, 9, 7])\n# true\n# >>> triples_sum_to_zero.call([1])\n# false\ndef triples_sum_to_zero(l)\n","canonical_solution":"def triples_sum_to_zero(l)\n  n = l.length\n  (0...n-2).each do |i|\n    ((i+1)...n-1).each do |j|\n      ((j+1)...n).each do |k|\n        return true if l[i] + l[j] + l[k] == 0\n      end\n    end\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false, candidate.call([100, 3, 5, -100]))\n  end\nend\n"},{"task_id":"HumanEval_41","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵜⵙⵙⵓⴼⵖ ⵜⵎⵔⵙⵜ ⴰⴷ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵏⵖⵉ ⴰⴷ.ⴷⴰⵗ ⵜⴰⴱⴰⵔⴰⵜ ⵜⴰⵏ ⵏⴰⵙⴰⵏ ⵛⵓⵏⴷ ⵓⴰⵔ ⵉⵋⵋⴰ ⴰⴾⴰⵔⴰⵛⵂⵎⵇⵇⴰⵔ, ⵍⵍⴰⵏ ⵉⵎⵓⴷⴰⵔ ⵉⴷⵓⵙⵏ ⴱⴰⵀⵔⴰ ⴷ ⵉⴷⵓⵙⵏ; ⵙ ⵜⵢⴰⴼⵓⵜ, ⴷⴰ ⵙⵓⵍⵏ ⵙ ⵓⵎⵓⵙⵙⵓ.ⴰⵍⵓⴰⵈ ⵓⴰ ⵉⴷ ⵜⴰⴾⴰⵍ ⵜⴰⴾⴰⵔⵓⵙⵜ ⵜⴰ ⵜⴰⴾⴰⵍ ⵙ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴰⵛⵂⵔⵓⵜⵆⴰⵙ ⴰⴾⵓⵣⴰⵏⴰⵏ ⵙ ⵜⴰⵣⴰⵉⵜ ⵉⵉⵉⴰⵜ. ⵙⴰⵏⴰⵜⴰⵜ ⵉⴾⴰⵔⴰⵏⴰⵏ ⴰⵜⵓⴰⵗⵔⴰⴷⴰ ⵜⵜⵓⵙⵙⵓⴷⵓ ⵙ ⵓⵣⵔⴼ ⵙ ⵓⵛⵍⵍ. ⵙⵏⴰⵜ ⵜⵔⵓⴱⴱⴰ ⵏ ⵜⵓⵍⵍⵉⵜⵉⵏ ⴷⴰ ⵜⵜⴱⴷⵓⵏⵜ ⵙ ⵓⴱⵔⴰⵔ ⵏ ⵣⵉⴽⴽ ⵣⵉ ⵔⴱⴰⵜ.ⴷⴰ ⵙⵙⵓⴷⵙⵏ n ⵏ ⵉⵎⵓⴷⴰⵔ ⵙⴳ ⵓⵥⵍⵎⴰⴹ ⵖⵔ ⵓⵥⵍⵎⴰⴹ; ⴳ ⵢⴰⵜ ⵜⵉⵣⵉ, ⵜⴰⵔⴰⴱⴱⵓⵜ ⵏ ⵉⵎⵓⴷⴰⵔ ⴰⵜⴰⵍⴰⵗⵉ ⴰⵙ ⴰⴱⴰⵔⴰ ⴻⵈⵈⴰⵍ ⴰⴱⴰⵔⴰ ⵓⴰ ⵓⵗⴰⴷⴰⵏ ⵂⴰⵔⴾⵓⴾ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜdef car_race_collision(n)\n","canonical_solution":"def car_race_collision(n)\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_car_race_collision\n    candidate = method(:car_race_collision)\n    assert_equal(4, candidate.call(2))\n    assert_equal(9, candidate.call(3))\n    assert_equal(16, candidate.call(4))\n    assert_equal(64, candidate.call(8))\n    assert_equal(100, candidate.call(10))\n  end\nend\n"},{"task_id":"HumanEval_42","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵣⵣⵉⴳⵣⵏ ⵙ 1.# >>> incr_list.call([1, 2, 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n","canonical_solution":"def incr_list(l)\n  l.map { |x| x + 1 }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3, 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"},{"task_id":"HumanEval_43","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵜⵉⴳ ⵏ ⵓⵎⵢⴰ, ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⵏⵙⴰ ⵢⴰⴹⵏ.ⴷⴰ ⵉⵜⵜⴰⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⴷⴰ ⵉⵜⵜⴰⵙⵉ pairs_sum_to_zero ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ.# >>> pairs_sum_to_zero.call([1, 3, 5, 0])\n# false\n# >>> pairs_sum_to_zero.call([1, 3, -2, 1])\n# false\n# >>> pairs_sum_to_zero.call([1, 2, 3, 7])\n# false\n# >>> pairs_sum_to_zero.call([2, 4, -5, 3, 5, 7])\n# true\n# >>> pairs_sum_to_zero.call([1])\n# false\ndef pairs_sum_to_zero(l)\n","canonical_solution":"def pairs_sum_to_zero(l)\n  num_set = l.to_set\n  l.each do |num|\n    return true if num != 0 && num_set.include?(-num)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1, 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5, 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3, 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"},{"task_id":"HumanEval_44","nl":"taq_Tfng","pl":"rb","prompt":"ⵉⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⴳⴰⵏ ⵉⵎⵥⵥⵉⵏ ⵙⴳ 10.ⴷⴰ ⵉⵜⵜⴰⵣⴰⵍ ⵓⵙⵎⴷⵢⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵏⴼⵍ.ⵙⵏⴼⵍ ⵜⴰⵙⵉⵍⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵛⵛⵓⵎ x ⵙ ⵜⴰⵙⵉⵍⴰ.# >>> change_base.call(8, 3)\n# \"22\"\n# >>> change_base.call(8, 2)\n# \"1000\"\n# >>> change_base.call(7, 2)\n# \"111\"\ndef change_base(x, base)\n","canonical_solution":"def change_base(x, base)\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits << (x % base).to_s\n    x \/= base\n  end\n  digits.reverse.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8, 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\", candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7, 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3, 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5, 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7, 8))\n  end\nend\n"},{"task_id":"HumanEval_45","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵣⵣⵓⵣⵔ ⵏ ⵓⴳⴰⴼⴰ ⴷ ⵢⵉⴳⵔ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵎⵇⵔⴰⵏ ⵉ ⵜⵔⵉⴳⵓⵏⵉⵜ.# >>> triangle_area.call(5, 3)\n# 7.5\ndef triangle_area(a, h)\n","canonical_solution":"def triangle_area(a, h)\n  (a * h) \/ 2.0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(7.5, candidate.call(5, 3))\n    assert_equal(2.0, candidate.call(2, 2))\n    assert_equal(40.0, candidate.call(10, 8))\n  end\nend\n"},{"task_id":"HumanEval_46","nl":"taq_Tfng","pl":"rb","prompt":"ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ ⵉⴼⵔⴷⵉⵙ ⵏ ⵡⵉⵙⵙ n ⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ fib4. ⵓⵔ ⵜⵙⵙⵎⵔⴰⵙ ⵜⵉⵔⵔⴰ. fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).fib4(3) -> 0 fib4(2) -> 2 fib4(1) -> 0 fib4(0) -> 0 ⵜⴰⵍⵖⴰ ⵏ ⵓⵟⵟⵓⵏ ⵏ Fib4 ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ:# >>> fib4.call(5)\n# 4\n# >>> fib4.call(6)\n# 8\n# >>> fib4.call(7)\n# 14\ndef fib4(n)\n","canonical_solution":"def fib4(n)\n  return 0 if n == 0 || n == 1 || n == 3\n  return 2 if n == 2\n\n  fib4_seq = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_seq[i] = fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n  end\n  fib4_seq[n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28, candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_47","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⴰⴽⵡⵣ ⵡⴰⵎⵎⴰⵙ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ l. # >>> median.call([3, 1, 2, 4, 5])\n# 3\n# >>> median.call([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n","canonical_solution":"def median(l)\n  sorted = l.sort\n  len = sorted.length\n  if len.odd?\n    sorted[len \/ 2]\n  else\n    (sorted[len \/ 2 - 1] + sorted[len \/ 2]) \/ 2.0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4, 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5, candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7, candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"},{"task_id":"HumanEval_48","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⴰⴷ ⵉⴳ ⵍⵉⵙⵜⵔⵉⵏ ⴰⴽⴽⵡ ⵉⴳⴰⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ # >>> is_palindrome.call(\"\")\n# true\n# >>> is_palindrome.call(\"aba\")\n# true\n# >>> is_palindrome.call(\"aaaaa\")\n# true\n# >>> is_palindrome.call(\"zbcd\")\n# false\ndef is_palindrome(text)\n","canonical_solution":"is_palindrome = lambda do |text|\n  text == text.reverse\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true, candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"},{"task_id":"HumanEval_49","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔ 2^n ⵎⵓⴷⵓⵍⵓ p (ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⵙ ⵡⵓⵟⵟⵓⵏ).# >>> modp.call(3, 5)\n# 3\n# >>> modp.call(1101, 101)\n# 2\n# >>> modp.call(0, 101)\n# 1\n# >>> modp.call(3, 11)\n# 8\n# >>> modp.call(100, 101)\n# 1\ndef modp(n, p)\n","canonical_solution":"def modp(n, p)\n  return 1 if p == 1\n  2.pow(n, p)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"},{"task_id":"HumanEval_51","nl":"taq_Tfng","pl":"rb","prompt":"remove_vowels ⵜⴳⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴱⵍⴰ ⵜⵉⴼⵉⵏⴰⵖ. # >>> remove_vowels.call(\"\")\n# \"\"\n# >>> remove_vowels.call(\"abcdef\")\n# \"bcdf\"\n# >>> remove_vowels.call(\"aaaaa\")\n# \"\"\n# >>> remove_vowels.call(\"aaBAA\")\n# \"B\"\n# >>> remove_vowels.call(\"zbcd\")\n# \"zbcd\"\ndef remove_vowels(text)\n","canonical_solution":"def remove_vowels(text)\n  text.delete('aeiouAEIOU')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\", candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\", candidate.call(\"ybcd\"))\n  end\nend\n"},{"task_id":"HumanEval_52","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵔ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⴰⴽⴽⵡ ⴳ ⵓⵎⵙⴳⵏⴰⴼ l ⴷⴷⴰⵡ ⵏ ⵓⴽⵜⵜⴰⵢ t. # >>> below_threshold.call([1, 2, 4, 10], 100)\n# true\n# >>> below_threshold.call([1, 20, 4, 10], 5)\n# false\ndef below_threshold(l, t)\n","canonical_solution":"def below_threshold(l, t)\n  l.all? { |num| num < t }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_below_threshold\n    candidate = method(:below_threshold)\n    assert_equal(true, candidate.call([1, 2, 4, 10], 100))\n    assert_equal(false, candidate.call([1, 20, 4, 10], 5))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 21))\n    assert_equal(true, candidate.call([1, 20, 4, 10], 22))\n    assert_equal(true, candidate.call([1, 8, 4, 10], 11))\n    assert_equal(false, candidate.call([1, 8, 4, 10], 10))\n  end\nend\n"},{"task_id":"HumanEval_53","nl":"taq_Tfng","pl":"rb","prompt":"ⵙⵓⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ x ⴷ y # >>> add.call(2, 3)\n# 5\n# >>> add.call(5, 7)\n# 12\ndef add(x, y)\n","canonical_solution":"add = ->(x, y) { x + y }","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(1, candidate.call(0, 1))\n    assert_equal(1, candidate.call(1, 0))\n    assert_equal(5, candidate.call(2, 3))\n    assert_equal(12, candidate.call(5, 7))\n    assert_equal(12, candidate.call(7, 5))\n  end\nend\n"},{"task_id":"HumanEval_54","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⴻⵛⴻⵛⴻ ⵎⴻⵗ ⵙⴰⵏⴰⵜⴰⵜ ⵉⵙⵎⴰⵓⴰⵏ ⵉⵍⴰⵏ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⵓⵍⴰⵂⵏⴻⵏ.# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\n# true\n# >>> same_chars.call(\"abcd\", \"dddddddabc\")\n# true\n# >>> same_chars.call(\"dddddddabc\", \"abcd\")\n# true\n# >>> same_chars.call(\"eabcd\", \"dddddddabc\")\n# false\n# >>> same_chars.call(\"abcd\", \"dddddddabce\")\n# false\n# >>> same_chars.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# false\ndef same_chars(s0, s1)\n","canonical_solution":"def same_chars(s0, s1)\n  s0.chars.uniq.all? { |char| s1.include?(char) } &&\n  s1.chars.uniq.all? { |char| s0.include?(char) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false, candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"))\n  end\nend\n"},{"task_id":"HumanEval_55","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔ ⵏ ⵜⵓⵏⴹⵜ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ ⵜⵉⵙ n.# >>> fib.call(10)\n# 55\n# >>> fib.call(1)\n# 1\n# >>> fib.call(8)\n# 21\ndef fib(n)\n","canonical_solution":"def fib(n)\n  return n if n <= 1\n  fib(n - 1) + fib(n - 2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89, candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"},{"task_id":"HumanEval_56","nl":"taq_Tfng","pl":"rb","prompt":"return true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ. brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ \"<\" ⴷ \">\". # >>> correct_bracketing.call(\"<\")\n# false\n# >>> correct_bracketing.call(\"<>\")\n# true\n# >>> correct_bracketing.call(\"<<><>>\")\n# true\n# >>> correct_bracketing.call(\"><<>\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.chars.each do |char|\n    if char == '<'\n      balance += 1\n    elsif char == '>'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"<>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true, candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false, candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n    assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\">\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"<><><<><>><>>><>\"))\n  end\nend\n"},{"task_id":"HumanEval_57","nl":"taq_Tfng","pl":"rb","prompt":"Return true ⵉⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵙⵏⵙⵍ ⴷⴰ ⵙⵙⵓⴷⵓⵏ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵓⵙⵙⵖⵓⴷⵓ ⵏⵖⴷ ⵓⵙⵙⴷⵔⵓⵙ.# >>> monotonic.call([1, 2, 4, 20])\n# true\n# >>> monotonic.call([1, 20, 4, 10])\n# false\n# >>> monotonic.call([4, 1, 0, -10])\n# true\ndef monotonic(l)\n","canonical_solution":"def monotonic(l)\n  increasing = true\n  decreasing = true\n\n  (0...l.length - 1).each do |i|\n    if l[i] < l[i + 1]\n      decreasing = false\n    elsif l[i] > l[i + 1]\n      increasing = false\n    end\n  end\n\n  increasing || decreasing\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2, 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false, candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1, 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false, candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\nend\n"},{"task_id":"HumanEval_58","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵢⵉⵡⵏⴻⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵉ ⵙⵉⵏ ⵉⵎⵙⴷⴷⵉⵜⵏ.# >>> common.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common.call([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n","canonical_solution":"def common(l1, l2)\n  (l1 & l2).uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5, 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3, 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"},{"task_id":"HumanEval_59","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔ ⵏ ⵓⵎⵙⴽⵉⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ ⵏ n. ⵏⵙⵙⵉⵏ ⵉⵙ n > 1 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⵡⴰⵔⵓ. # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n# 2\ndef largest_prime_factor(n)\n","canonical_solution":"def largest_prime_factor(n)\n  factor = 2\n  while factor * factor <= n\n    if n % factor == 0\n      n \/= factor\n    else\n      factor += 1\n    end\n  end\n  n\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n  end\nend\n"},{"task_id":"HumanEval_60","nl":"taq_Tfng","pl":"rb","prompt":"sum_to_n ⵜⴳⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵎⵓⵏ ⵉⵎⴹⴰⵏ ⵙⴳ 1 ⴰⵔ n. # >>> sum_to_n.call(30)\n# 465\n# >>> sum_to_n.call(100)\n# 5050\n# >>> sum_to_n.call(5)\n# 15\n# >>> sum_to_n.call(10)\n# 55\n# >>> sum_to_n.call(1)\n# 1\ndef sum_to_n(n)\n","canonical_solution":"def sum_to_n(n)\n  (1..n).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n    assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_61","nl":"taq_Tfng","pl":"rb","prompt":"return true ⵎⴽ ⴷⴰⵔ ⴽⵓ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵕⵥⵥⵓⵎ ⵜⴰⴳⴳⴰⵢⵜ ⵏ ⵓⵇⵇⵏ. brackets ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵏ \"(\" ⴷ \")\".# >>> correct_bracketing.call(\"(\")\n# false\n# >>> correct_bracketing.call(\"()\")\n# true\n# >>> correct_bracketing.call(\"(()())\")\n# true\n# >>> correct_bracketing.call(\")(()\")\n# false\ndef correct_bracketing(brackets)\n","canonical_solution":"def correct_bracketing(brackets)\n  balance = 0\n  brackets.each_char do |char|\n    if char == '('\n      balance += 1\n    elsif char == ')'\n      balance -= 1\n    end\n    return false if balance < 0\n  end\n  balance == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true, candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false, candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n    assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\")\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false, candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"()()(()())()))()\"))\n  end\nend\n"},{"task_id":"HumanEval_62","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔⵏ ⴷⵉⵔⵉⴼⵉⴰⵜⵉⴱ ⵏ ⴱⵓⵍⵉⵏⵓⵎⵉⵢⴰ ⴰⴷ ⴳ ⵢⴰⵜ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ. xs[0] + xs[1] * x + xs[2] * x^2 + .... ⴷⴰ ⵉⵙⵎⴷⵢⴰ xs ⵉⵎⴳⴳⵉⵜⵏ ⵏ ⴽⵉⴳⴰⵏ ⵏ ⵉⵡⵜⵜⴰ.# >>> derivative.call([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative.call([1, 2, 3])\n# [2, 6]\ndef derivative(xs)\n","canonical_solution":"def derivative(xs)\n  return [] if xs.length < 2\n  xs.each_with_index.map { |coef, index| coef * index }[1..-1]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3, 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2, 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3, 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_63","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵔⵢⵣ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵉⴹⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵎⴹⴰⵏ ⵏ fibfib ⵙ ⵢⴰⵜ ⵜⵖⴰⵔⴰⵙⵜ ⵉⴼⵓⵍⴽⵉⵏ.fibfib{n} == fibfib{n-1} + fibfib{n-2} + fibfib{n-3}fib fib ((2) == 1 fibfib{1) == 0 fibfib{0} == 0 ⵜⴰⵍⵖⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⴼⵉⴱⴼⵉⴱ ⵜⴳⴰ ⵜⴰⵍⵖⴰ ⵢⴰⴽⵙⵓⵍⵏ ⴷ ⵜⴰⵍⵖⴰ ⵏ ⴼⵉⴱⴱⵓⵏⴰⵛⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⵙ ⵓⵎⴽ ⴰⴷ:# >>> fibfib.call(1)\n# 0\n# >>> fibfib.call(5)\n# 4\n# >>> fibfib.call(8)\n# 24\ndef fibfib(n)\n","canonical_solution":"def fibfib(n)\n  return 0 if n == 0 || n == 1\n  return 1 if n == 2\n\n  a, b, c = 0, 0, 1\n  (3..n).each do\n    a, b, c = b, c, a + b + c\n  end\n  c\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fibfib\n    candidate = method(:fibfib)\n    assert_equal(1, candidate.call(2))\n    assert_equal(0, candidate.call(1))\n    assert_equal(4, candidate.call(5))\n    assert_equal(24, candidate.call(8))\n    assert_equal(81, candidate.call(10))\n    assert_equal(274, candidate.call(12))\n    assert_equal(927, candidate.call(14))\n  end\nend\n"},{"task_id":"HumanEval_64","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⴰⵛⵛⵉⵍ, ⵎⴰⵛⴰ ⴷⴰⵢ ⵉⴳ ⵉⵍⵍⴰ ⴳ ⵜⴳⵉⵔⴰ ⵏ ⵜⴳⵓⵔⵉ ⵉⵜⵜⵓⴼⴽⴰⵏ.ⵉⵎⵓⵙⵙⵓⵜⵏ ⴳ ⵡⴰⴷⴷⴰⴷ ⴰⴷ ⴳⴰⵏ \"ⴰ\", \"ⵢ\", \"ⵉ\", \"ⵓ\", \"ⵓ\". ⴷⵖⴰ, \"ⵢ\" ⵉⴳⴰ ⴰⵡⴷ \"ⴰ\"ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴳⵓⵔⵉ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵣⵍⵉⵜ.ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ vowels_count ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵜⴰⵡⵓⵔⵉ ⵏ # >>> vowels_count.call(\"abcde\")\n# 2\n# >>> vowels_count.call(\"ACEDY\")\n# 3\ndef vowels_count(s)\n","canonical_solution":"def vowels_count(s)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  \n  s.chars.each_with_index do |char, index|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif char.downcase == 'y' && index == s.length - 1\n      count += 1\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"ACEDY\"))\n  end\nend\n"},{"task_id":"HumanEval_65","nl":"taq_Tfng","pl":"rb","prompt":"ⵎⴽ ⵜⵍⵍⴰ ⵜⵣⵍⵉⵜ > ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵔⴰⴷ ⵙⵔⵙⵏ ⵡⵓⵟⵟⵓⵏ ⵙ ⵓⴱⵔⴷ.ⴷ ⴰⵔ ⵏⴰⴽⴽⴰ ⵜⴰⵢⴰⴼⵓⵜ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ.ⴷⴰ ⵏⵙⵎⵓⵜⵜⵔ ⵉⵎⵉⴹⵏ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ x ⵙ ⵜⵙⵓⵜⵍⵜ, ⵏⵙⵎⵓⵜⵜⵔ ⵉⵎⵉⴹⵏ ⵙ ⵜⵙⴳⴰ ⵏ ⵓⵣⵔⴼ ⵙ ⵓⵎⵙⵓⵜⵍ.# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12, 2)\n# \"12\"\ndef circular_shift(x, shift)\n","canonical_solution":"def circular_shift(x, shift)\n  digits = x.to_s.chars\n  num_digits = digits.length\n\n  if shift > num_digits\n    return digits.reverse.join\n  else\n    shift = shift % num_digits\n    shifted_digits = digits.rotate(-shift)\n    return shifted_digits.join\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100, 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\", candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"11\", candidate.call(11, 101))\n  end\nend\n"},{"task_id":"HumanEval_66","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴾⵓⴷ ⵜⴰⵏ ⵓⵉⵏ ASCIIⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵖⵕⴹⴰ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏⵏ ⵏ ⵓⴼⵍⵍⴰ ⵜⴰⵣⵣⴰⵍⵜ # >>> digitSum.call(\"\")\n# 0\n# >>> digitSum.call(\"abAB\")\n# 131\n# >>> digitSum.call(\"abcCd\")\n# 67\n# >>> digitSum.call(\"helloE\")\n# 69\n# >>> digitSum.call(\"woArBld\")\n# 131\n# >>> digitSum.call(\"aAaaaXa\")\n# 153\ndef digitSum(s)\n","canonical_solution":"def digitSum(s)\n  s.chars.select { |char| char =~ \/[A-Z]\/ }.map(&:ord).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131, candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327, candidate.call(\"You arE Very Smart\"))\n  end\nend\n"},{"task_id":"HumanEval_67","nl":"taq_Tfng","pl":"rb","prompt":"ⵉ ⵓⵛⵛⵉⵍ: ⴳ ⵜⴽⵕⴹⴰ ⵔⵥⵎ ⵓⵟⵟⵓⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ ⵏ ⵍⵎⴰⵏⴳⵓ ⴳ ⵜⴽⵕⴹⴰ. ⵜⵉⴱⵕⴰⵏⵊⵉⵏ ⴷ ⵜⴱⵔⵖⴰ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⴰⵎⴹⴰⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵜⵢⴰⴼⵓⵜⵉⵏ ⴹⴰⵔⴰⵜ ⴰⵙⵉⴾⵏⵓ ⵏ ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ, ⴾⵢⵍ ⴰⴾⴰⵍ,ⴰⵈⵈⴰⵍⴰⵏ ⴰ ⵉⴾⴼⴰⵏ ⴷⴰⵗ ⵜⴰⴱⴰⵔⴰⵜ ⵏ ⵉⴼⵔⴰⵜⴰⵏ ⴰⵂⴰⵏ ⵜⴰⴱⴰⵔⴰⵜ ⵜⵢⵏⴳ ⵜⵎⵙⴰⵔⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ ⵉⵙⵎⴷⵢⴰⵏⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴱⵔⵟⵓⴽⵜ ⴷ ⵜⴱⵔⵟⵓⴽⵜ # >>> fruit_distribution.call(\"5 apples and 6 oranges\", 19)\n# 8\n# >>> fruit_distribution.call(\"0 apples and 1 oranges\", 3)\n# 2\n# >>> fruit_distribution.call(\"2 apples and 3 oranges\", 100)\n# 95\n# >>> fruit_distribution.call(\"100 apples and 1 oranges\", 120)\n# 19\ndef fruit_distribution(s, n)\n","canonical_solution":"def fruit_distribution(s, n)\n  numbers = s.scan(\/\\d+\/).map(&:to_i)\n  apples = numbers[0]\n  oranges = numbers[1]\n  total_fruits = n\n  mangos = total_fruits - (apples + oranges)\n  mangos\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fruit_distribution\n    candidate = method(:fruit_distribution)\n    assert_equal(8, candidate.call(\"5 apples and 6 oranges\", 19))\n    assert_equal(10, candidate.call(\"5 apples and 6 oranges\", 21))\n    assert_equal(2, candidate.call(\"0 apples and 1 oranges\", 3))\n    assert_equal(2, candidate.call(\"1 apples and 0 oranges\", 3))\n    assert_equal(95, candidate.call(\"2 apples and 3 oranges\", 100))\n    assert_equal(0, candidate.call(\"2 apples and 3 oranges\", 5))\n    assert_equal(19, candidate.call(\"1 apples and 100 oranges\", 120))\n  end\nend\n"},{"task_id":"HumanEval_68","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ 1:ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵡⴰⵜⵉⴳⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ ⵏⵖⴷ ⵉⴳ ⵓⵎⵙⴳⴷⴰⵍ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵉⴳⴰ ⵡⴰⴽⵓ, ⵙⵙⴽⵛⵎ [].ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⵏⴼⵍ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⵏⴱⴹⵏ ⴳ ⵢⴰⵏ ⵓⵎⵙⴳⵏⴰⴼ, [smallest_value, ⴰⵙⵖⵍ ⵏⵏⵙ], ⵎⴽ ⵜⵜⵢⴰⴼⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ ⴰⵎⵎ ⵓⵎⴹⴰⵏ, ⵙⵙⴽⵛⵎ ⵜⵓⵏⵏⵓⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⵓⵏⵏⵓⵏⵜ ⵉⵜⵜⵓⵙⴽⵔⵏ ⵜⴰⵡⵜⵎⵉⵢⵜ ⵜⴰⵥⵥⵉⵥⵜ ⴳ ⵡⴰⵜⵉⴳ ⴰⵎⵎ ⵓⵎⵢⴰ.ⵜⴰⵣⴰⵍⵍⵉⵜ ⵏⴰⵙⵙ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⵢⴰⵜ ⵙⴳ ⵜⵓⵏⵏⵓⵏⵜ ⴷ ⴰⴷ ⵜⵔⴰⵔ.\"ⴰⴽⴽⴰ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵉ ⵉⵙⵎⴷⵢⴰⵏ ⵢⴰⵏ ⵓⵥⵟⵟⴰ ⵏ ⵢⴰⵜ ⵜⵙⴽⵍⴰ ⵏⵏⴰ ⵖⵓⵔ ⵍⵍⴰⵏⵜ ⵜⵓⵏⵏⵓⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵏ # >>> pluck.call([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck.call([1, 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\n# Example 3:\n# >>> pluck.call([])\n# []\n# Example 4:\n# >>> pluck.call([5, 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there are two zeros,\n# so we will choose the first zero, which has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n","canonical_solution":"def pluck(arr)\n  smallest_even = nil\n  smallest_index = nil\n  \n  arr.each_with_index do |value, index|\n    if value.even?\n      if smallest_even.nil? || value < smallest_even\n        smallest_even = value\n        smallest_index = index\n      end\n    end\n  end\n\n  smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2, 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4, 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7, 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"},{"task_id":"HumanEval_69","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵜⵉⴳ ⴰⴷ, ⵔⵔⵓⵜⵓⵔ -1.ⵜⴰⴽⴰⵜ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴽⴽⴰⵍ ⵏⵏⴰ ⴳ ⵉⵜⵜⵓⴼⴽⴰⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ.ⴰⵎⵢⴰ, ⴷ ⵖⵓⵔⵙ ⵜⴰⵔⵖⴰ ⵜⴰⵅⴰⵜⴰⵔⵜ ⵏⵖⴷ ⵉⵎⴽⵉⵏⵏⴰ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵉⵎⵉⴹ ⴰⵎⴷⴷⴰⴷ ⵉⵎⴰⵏ ⵏⵏⵙ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵏⵉⴳ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵏⴰⵏ. ⵔⵔⵓⵜⵓⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵅⴰⵜⴰⵔ ⵏⵏⴰ ⵢⵓⴳⵔⵏ # >>> search.call([4, 1, 2, 2, 3, 1])\n# 2\n# >>> search.call([1, 2, 2, 3, 3, 3, 4, 4, 4])\n# 3\n# >>> search.call([5, 5, 4, 4, 4])\n# -1\ndef search(lst)\n","canonical_solution":"def search(lst)\n  freq_hash = lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  valid_numbers = freq_hash.select { |num, freq| freq >= num }.keys\n  valid_numbers.empty? ? -1 : valid_numbers.max\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5, 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1, candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8, 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1, candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1, candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8, 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1, candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1, candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1, candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1, candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"},{"task_id":"HumanEval_70","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ, ⵔⴰⴷ ⵢⵉⵍⵉ ⵡⵓⴳⴳⴰⵔ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴷ ⵔⴰⴷ ⵢⵉⵍⵉ ⵡⵓⴳⴳⴰⵔ, ⴷ ⴰⵢⴰⴷ.ⴰⵙⵎⵉⵍⵍ ⴰⵎⵣⴳⵓⵏ, ⵉⴳ ⴷⴰ ⵜⵜⴱⴷⵓⴷ ⵙ ⵡⴰⵜⵉⴳ ⴰⵎⵥⵥⵢⴰⵏ, ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⴰⵙⵔⴷ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵔⴰⴷ ⵏⵔⴰⵔⵓ ⴰⵙⵔⴷ ⵙ ⵓⵍⵖⵓ.# >>> strange_sort_list.call([1, 2, 3, 4])\n# [1, 4, 2, 3]\n# >>> strange_sort_list.call([5, 5, 5, 5])\n# [5, 5, 5, 5]\n# >>> strange_sort_list.call([])\n# []\ndef strange_sort_list(lst)\n","canonical_solution":"def strange_sort_list(lst)\n  result = []\n  lst.sort!\n  until lst.empty?\n    result << lst.shift\n    result << lst.pop unless lst.empty?\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1, 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1, 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5, 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7, 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2, 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\nend\n"},{"task_id":"HumanEval_71","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⴰⵛⵂⵔⵓⵜ ⵓⴰⵏ ⴾⴰⵔⴰⴷⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⴷⴰ ⵙⴽⴰⵔⵏ ⵢⴰⵜ ⵜⵔⴰⵢⵓⴳⵍⴰⵏⵜ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⵜⵍⵍⴰ ⵜⵔⵎⵉⵜ ⵏ ⵙⵏⴰⵜ ⵜⴼⵓⵍⵉⵏ ⴽⵔⴰ ⵢⴰⴹⵏ ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⴷⴰ ⵉⵜⵜⵔⴰⵔ -1 ⵜⵔⵉⴰⵏⴳⵉⵍ ⵜⵓⵔⴷⴰ ⵙ 2 ⵏ ⵜⵏⵇⵇⵉⴹⵉⵏ ⵜⵉⵎⵔⴰⵡⵉⵏ ⵎⴽ ⵜⴳⴰ ⴽⵕⴰⴹⵜ ⵜⴼⵓⵍⵉⵏ ⵢⴰⵜ ⵜⵔⵉⴰⵏⴳⵉⵍⵜ ⵜⵓⵏⵖⵉⴷⵜ.ⴷⴰ ⵜⵜⵓⴽⴽⴰⵏ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⴽⵕⴰⴹ ⵓⴷⵖⴰⵔ. ⵔⵎⵙⵏ ⵜⴰⵊⵓⵎⵎⴰ ⵏ # >>> triangle_area.call(3, 4, 5)\n# 6.0\n# >>> triangle_area.call(1, 2, 10)\n# -1\ndef triangle_area(a, b, c)\n","canonical_solution":"def triangle_area(a, b, c)\n  # Check for valid triangle\n  if a + b > c && a + c > b && b + c > a\n    # Calculate the semi-perimeter\n    s = (a + b + c) \/ 2.0\n    # Calculate the area using Heron's formula\n    area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    # Round to 2 decimal points\n    return area.round(2)\n  else\n    return -1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triangle_area\n    candidate = method(:triangle_area)\n    assert_equal(6.0, candidate.call(3, 4, 5))\n    assert_equal(-1, candidate.call(1, 2, 10))\n    assert_equal(8.18, candidate.call(4, 8, 5))\n    assert_equal(1.73, candidate.call(2, 2, 2))\n    assert_equal(-1, candidate.call(1, 2, 3))\n    assert_equal(16.25, candidate.call(10, 5, 7))\n    assert_equal(-1, candidate.call(2, 6, 3))\n    assert_equal(0.43, candidate.call(1, 1, 1))\n    assert_equal(-1, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_72","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵔⴰⴷ ⵉⵢⵉ ⵜⵓⴷⵔⵜ ⵏ ⵓⴱⵓⵊⵉⴽⵜ q ⵉⴳ ⴷ ⴰⵎⵙⴰⵙⴰ (ⵉⴳⴰ ⵢⴰⵏ ⵓⵎⵙⴰⵙⴰ ⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉ) ⴷ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⵙ ⵡⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵓⴽⵙⴰⵢ ⴰⵅⴰⵜⴰⵔ w.ⵔⵉⵜⵓⵔⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⴳⴰⵏ ⵜⵉⴷⵜ ⵎⴽ ⴷⴰ ⵉⵜⵜⵓⵖⴰⵍ ⵓⴱⵓⵊⵉⴽⵜ q, ⴷ ⵜⵉⴽⵕⴹⵉ ⵎⴽ ⵓⵔ ⵉⴳⵉ.# >>> will_it_fly.call([1, 2], 5)\n# false\n# # 1+2 is less than the maximum possible weight, but it's unbalanced.\n# >>> will_it_fly.call([3, 2, 3], 1)\n# false\n# # it's balanced, but 3+2+3 is more than the maximum possible weight.\n# >>> will_it_fly.call([3, 2, 3], 9)\n# true\n# # 3+2+3 is less than the maximum possible weight, and it's balanced.\n# >>> will_it_fly.call([3], 5)\n# true\n# # 3 is less than the maximum possible weight, and it's balanced.\ndef will_it_fly(q, w)\n","canonical_solution":"def will_it_fly(q, w)\n  is_palindrome = q == q.reverse\n  total_weight = q.sum\n  is_balanced_and_under_weight = is_palindrome && total_weight <= w\n  is_balanced_and_under_weight\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_will_it_fly\n    candidate = method(:will_it_fly)\n    assert_equal(true, candidate.call([3, 2, 3], 9))\n    assert_equal(false, candidate.call([1, 2], 5))\n    assert_equal(true, candidate.call([3], 5))\n    assert_equal(false, candidate.call([3, 2, 3], 1))\n    assert_equal(false, candidate.call([1, 2, 3], 6))\n    assert_equal(true, candidate.call([5], 5))\n  end\nend\n"},{"task_id":"HumanEval_73","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴷⴰ ⵉⵜⵜⵓⵙⵎⴷ ⵢⴰⵏ ⵓⵎⵏⵉⴷ ⵙ ⵓⵎⵏⵉⴷ ⴷ ⵙ ⵓⵎⵏⵉⴷ. ⴳ ⵢⴰⵏ ⵓⵙⵏⴼⵍ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵏⴼⵍ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵙ ⴽⵔⴰ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵢⴰⴹⵏ.ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⵍ ⴰⴼⴰⴷ ⴰⴷ ⵜⴳ ⵜⴳ ⵜⵎⵙⴷⴰⵍⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵜ. ⵜⴰⵎⵙⴷⴰⵍⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵜ ⵜⴳⴰ ⵜⴰⵎⵙⴷⴰⵍⵜ ⵏⵏⴰ ⴹⴼⵓⵕ ⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⴹⴼⵓⵕ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ # >>> smallest_change.call([1, 2, 3, 5, 4, 7, 9, 6])\n# 4\n# >>> smallest_change.call([1, 2, 3, 4, 3, 2, 2])\n# 1\n# >>> smallest_change.call([1, 2, 3, 2, 1])\n# 0\ndef smallest_change(arr)\n","canonical_solution":"def smallest_change(arr)\n  changes = 0\n  left = 0\n  right = arr.length - 1\n\n  while left < right\n    if arr[left] != arr[right]\n      changes += 1\n    end\n    left += 1\n    right -= 1\n  end\n\n  changes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_smallest_change\n    candidate = method(:smallest_change)\n    assert_equal(4, candidate.call([1, 2, 3, 5, 4, 7, 9, 6]))\n    assert_equal(1, candidate.call([1, 2, 3, 4, 3, 2, 2]))\n    assert_equal(1, candidate.call([1, 4, 2]))\n    assert_equal(1, candidate.call([1, 4, 4, 2]))\n    assert_equal(0, candidate.call([1, 2, 3, 2, 1]))\n    assert_equal(0, candidate.call([3, 1, 1, 3]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(1, candidate.call([0, 1]))\n  end\nend\n"},{"task_id":"HumanEval_74","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵎⴽ ⴷⴰⵔ ⵙⵏⴰⵜ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵉⵎⴹⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵙⵙⴽⵛⵎ ⵜⴰⵔⴰⴱⴱⵓⵜ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ.ⴰⵎⴹⴰⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵜⴽⴰⵔ ⴳ ⴽⵓⵍⵍⵓ ⵜⵉⵙⵉⴹⴼⵉⵏ ⵏ ⵓⵎⵙⴰⵙⴰ ⴷⵔⵓⵙⵏ ⴳ ⵓⵎⵙⴰⵙⴰ ⵢⴰⴹⵏ.ⵔⵉⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵙⵏⴰⵜ ⵜⵔⴱⴰⵜⵉⵏ ⵏ ⵉⵙⵉⴹⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⵔⴱⴰⵜ ⵏⵏⴰ ⵖⵓⵔ ⵉⵍⵍⴰ # >>> total_match.call([], [])\n# []\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n# [\"hI\", \"Hi\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n# [\"hi\", \"admin\"]\n# >>> total_match.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n# [\"hI\", \"hi\", \"hi\"]\n# >>> total_match.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])\n# [\"4\"]\ndef total_match(lst1, lst2)\n","canonical_solution":"def total_match(lst1, lst2)\n  total_chars1 = lst1.map(&:length).sum\n  total_chars2 = lst2.map(&:length).sum\n\n  if total_chars1 < total_chars2\n    lst1\n  elsif total_chars2 < total_chars1\n    lst2\n  else\n    lst1\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\", \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n    assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"},{"task_id":"HumanEval_75","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵃⵎⴰ ⴰⴷ ⵏⵙⵙⵏ ⵉⵙ (ⴰ) ⴷⵔⵓⵙ ⵙⴳ 100.ⴷ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵉⵜⵜⵓⴼⴽⴰⵏ ⵜⴰⵔⵡⴰ ⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ # >>> is_multiply_prime.call(30)\n# true\n# 30 = 2 * 3 * 5\ndef is_multiply_prime(a)\n","canonical_solution":"require 'prime'\n\ndef is_multiply_prime(a)\n  return false if a >= 100\n  prime_factors = a.prime_division\n  return true if prime_factors.size == 3 && prime_factors.all? { |_, exponent| exponent == 1 }\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_multiply_prime\n    candidate = method(:is_multiply_prime)\n    assert_equal(false, candidate.call(5))\n    assert_equal(true, candidate.call(30))\n    assert_equal(true, candidate.call(8))\n    assert_equal(false, candidate.call(10))\n    assert_equal(true, candidate.call(125))\n    assert_equal(true, candidate.call(105))\n    assert_equal(false, candidate.call(126))\n    assert_equal(false, candidate.call(729))\n    assert_equal(false, candidate.call(891))\n    assert_equal(true, candidate.call(1001))\n  end\nend\n"},{"task_id":"HumanEval_76","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: x ⴷ ⵜⴰⵣⵎⵔⵜ ⵜⴰⵎⵢⵉⵡⴰⵏⵜ ⵏ n ⵎⴽ n**int=x ⵜⴰⵣⵎⵔⵜ ⵏ n ⴷ ⵜⵉⵔⵡⵉ ⴳ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ.ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⵔⵔⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ x ⵢⴰⵏ # >>> is_simple_power.call(1, 4)\n# true\n# >>> is_simple_power.call(2, 2)\n# true\n# >>> is_simple_power.call(8, 2)\n# true\n# >>> is_simple_power.call(3, 2)\n# false\n# >>> is_simple_power.call(3, 1)\n# false\n# >>> is_simple_power.call(5, 3)\n# false\ndef is_simple_power(x, n)\n","canonical_solution":"def is_simple_power(x, n)\n  return false if x <= 0 || n <= 1\n  return true if x == 1\n\n  power = n\n  while power <= x\n    return true if power == x\n    power *= n\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_simple_power\n    candidate = method(:is_simple_power)\n    assert_equal(true, candidate.call(16, 2))\n    assert_equal(false, candidate.call(143214, 16))\n    assert_equal(true, candidate.call(4, 2))\n    assert_equal(true, candidate.call(9, 3))\n    assert_equal(true, candidate.call(16, 4))\n    assert_equal(false, candidate.call(24, 2))\n    assert_equal(false, candidate.call(128, 4))\n    assert_equal(false, candidate.call(12, 6))\n    assert_equal(true, candidate.call(1, 1))\n    assert_equal(true, candidate.call(1, 12))\n  end\nend\n"},{"task_id":"HumanEval_77","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵓⵉⵙⵙⴰⵎ: ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⴰⵜⵓⴰⵣⵋⴰⵎ ⴰⵙ ⵉⴾⵉ ⵏ ⴰⴾⴰⵉⴰⴷ ⵓⵍⴰⵗⴰⵏ ⵂⴰⵔⴾⵓⴾⵎⴽ ⵉⴳⴰ ⵡⵉⵏⴳⵉⵊⵔ ⴰⴷ ⴰⵎⴷⵢⴰ ⴰⵎⵖⴰⵔⴰⵏ ⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ a ⴰⵔ ⵉⵜⵜⴰⵊⵊⴰ ⵜⵉⴷⵜ # >>> iscube.call(1)\n# true\n# >>> iscube.call(2)\n# false\n# >>> iscube.call(-1)\n# true\n# >>> iscube.call(64)\n# true\n# >>> iscube.call(0)\n# true\n# >>> iscube.call(180)\n# false\ndef iscube(a)\n","canonical_solution":"def iscube(a)\n  cube_root = a.abs**(1.0\/3)\n  cube_root.round**3 == a\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_iscube\n    candidate = method(:iscube)\n    assert_equal(true, candidate.call(1))\n    assert_equal(false, candidate.call(2))\n    assert_equal(true, candidate.call(-1))\n    assert_equal(true, candidate.call(64))\n    assert_equal(false, candidate.call(180))\n    assert_equal(true, candidate.call(1000))\n    assert_equal(true, candidate.call(0))\n    assert_equal(false, candidate.call(1729))\n  end\nend\n"},{"task_id":"HumanEval_78","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷ ⵉⵙⵎⴰⵡⵏ ⴰ,ⴱ,ⵙ,ⴷ,ⵢ,ⴼ ⴳⴰⵏ ⴰⵀⴰ ⵉⵎⵇⵔⴰⵏⵏ.ⵜⴰⵍⵖⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵉⵙ ⵉⴳⴰ ⵡⴰⴷⴷⴰⴷ ⵏ ⵓⴽⵛⵛⵓⵎ ⴰⵀⴰ ⵉⴳⵏ ⴰⵣⵔⴼⴰⵏ ⵏⵖⴷ ⴰⵎⵙⴷⴷⵉ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⴱ (= ⴷⵢⵛⵉⵎⴰⵍ 11), ⴷ (= ⴷⵢⵛⵉⵎⴰⵍ 13).ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⵙⵙⴽⵜⵉ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ ⵡⵓⵟⵟⵓⵏ ⴰⴷ: 2, 3, 5, 7, ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳⴰⵏ 2, 3, 5, 7, 11, 13, 17...ⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵙⵡⴰⵜ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.ⵓⴳⴳⴰⵔ ⵏ 1 ⵓⵔ ⵉⴳⵉ ⴰⵎⵢⴰⴼⵓ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵔⴳⴰⵢⵏ ⵉⵎⵥⵥⵉⵏ).ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴳ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⵡⵓⵔⴰ (ⵉⴹ ⴰⵎⵣⵡⴰⵔⵓ, ⵏⵖⴷ ⴰⵎⵣⵡⴰⵔⵓ, ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵓⵟⵟⵓⵏ ⴰⵀⵉⵣⴰⴷⵉⵎⴰⵍ ⴰⵎⵎ ⵜⴰⴹⴰ ⴷ ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⵓⵟⵟⵓⵏ ⵏ ⵓⵟⵟⵓⵏ ⴰⵀⵉⵣⴰⴷⵉⵎⴰⵍ ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⴰⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ # >>> hex_key.call(\"AB\")\n# 1\n# >>> hex_key.call(\"1077E\")\n# 2\n# >>> hex_key.call(\"ABED1A33\")\n# 4\n# >>> hex_key.call(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key.call(\"2020\")\n# 2\ndef hex_key(num)\n","canonical_solution":"def hex_key(num)\n  prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n  num.chars.count { |digit| prime_hex_digits.include?(digit) }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_hex_key\n    candidate = method(:hex_key)\n    assert_equal(1, candidate.call(\"AB\"))\n    assert_equal(2, candidate.call(\"1077E\"))\n    assert_equal(4, candidate.call(\"ABED1A33\"))\n    assert_equal(2, candidate.call(\"2020\"))\n    assert_equal(6, candidate.call(\"123456789ABCDEF0\"))\n    assert_equal(12, candidate.call(\"112233445566778899AABBCCDDEEFF00\"))\n  end\nend\n"},{"task_id":"HumanEval_79","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵉⵍⴰⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵓⴳⴳⴰⵔ ⴰⴼⴰⴷ ⴰⴷ ⵜⵜⵓⵙⵎⵔⴰⵙ ⵜⴰⵍⵖⴰ.ⵔⴰⴷ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ \"db\" ⴳ ⵍⴱⴷⵓ ⴷ ⵜⴳⵉⵔⴰ ⵏ ⵜⵣⵍⵉⵜ.ⴽⵓ ⴰⵔⵉⵎ ⴳ ⵜⵣⵍⵉⵜ ⵔⴰⴷ ⵉⴳ \"0\" ⵏⵖ \"1\".ⵜⴰⵍⵖⴰ ⵏ ⵜⴱⵉⵏⴰⵔⵉⵜ. ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵜⵡⵓⵔⵉ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ, ⴷ ⴽⵓ ⵉⵙⴽⴽⵉⵍ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴱⵉⵏⴰⵔⵉⵜ ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵜⴹⵉⵚⵜ ⴳ ⵜⴰⵍⵖⴰ ⵏ ⵜⴷⵉⵣⵎⵉⵜ ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⴼⵍⵜ ⵙ # >>> decimal_to_binary.call(15)\n# \"db1111db\"\n# >>> decimal_to_binary.call(32)\n# \"db100000db\"\ndef decimal_to_binary(decimal)\n","canonical_solution":"def decimal_to_binary(decimal)\n  \"db\" + decimal.to_s(2) + \"db\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_decimal_to_binary\n    candidate = method(:decimal_to_binary)\n    assert_equal(\"db0db\", candidate.call(0))\n    assert_equal(\"db100000db\", candidate.call(32))\n    assert_equal(\"db1100111db\", candidate.call(103))\n    assert_equal(\"db1111db\", candidate.call(15))\n  end\nend\n"},{"task_id":"HumanEval_80","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ \" haprb \" ⵎⴽ ⵉⴳⴰ ⵓⵖⵣⵉ ⵏⵏⵙ ⴽⵕⴰⴹ ⵓⴳⴳⴰⵔ ⴷ ⴽⵕⴰⴹⵜ ⵜⵉⵔⵔⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵥⵕⵉⵖ ⵉⵖ ⵜⴳⴰ ⵜⵣⵍⵉⵜ ⵜⴰⴷⵙⵍⴰⵏⵜ ⵏⵖ ⵓⵔ ⵜⵍⵍⵉ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ s.# >>> is_happy.call(\"a\")\n# false\n# >>> is_happy.call(\"aa\")\n# false\n# >>> is_happy.call(\"abcd\")\n# true\n# >>> is_happy.call(\"aabb\")\n# false\n# >>> is_happy.call(\"adb\")\n# true\n# >>> is_happy.call(\"xyy\")\n# false\ndef is_happy(s)\n","canonical_solution":"def is_happy(s)\n  return false if s.length < 3\n  \n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  \n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true, candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n    assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"iopaxioi\"))\n  end\nend\n"},{"task_id":"HumanEval_81","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: 0.0 E > 0.0 ⴷ- > 0.7 D > 1.0 ⴷ+ > 1.3 C- > 1.7 C > 2.0 C+ > 2.3 ⴱ- > 2.7 B > 3.0 ⴱ+ > 3.3 ⴰ- > 3.7 ⴰ 4.0 ⴰ+ GPA. ⴰⵍⴾⴰⴷ ⵏ ⵜⵉⴾⴰⵔⵙⵉⵓⴻⵏⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵥⴹⴰⵕⵏ ⴰⴷ ⵉⴼⴽ ⵜⴰⵡⵍⴰⴼⵜ ⵏ ⵡⴰⵏⴰⵡⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵙ ⵓⵙⵎⵔⵙ ⵏ ⵜⴼⵍⵡⵉⵜ ⴰⴷ: ⵜⴰⴾⴼⴰ-ⵛⴻ ⵉⴻ ⴰⴾⴰⵍ ⵏⴰⵛⴰⵍⴰ ⵜⴰⵏ ⵉⴻ ⵍⴰⴾⴰⴷⴰⵏ ⵉⵉⵉⴰⴷ ⴰⴷ ⵉⴶⵔⴰⵓ ⴰⴷ ⴰⴾⵜⴰⴱⵎⵓⵛⴰⴾⵉⵍ ⵓⴰ ⵉⵉⵉⴰⵏ ⴰⵎⵓⵙ ⴰⵙ ⵜⴰⴾⴼⴰ ⴰⵛⵓⵓⴷ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷⵆⵢⵍ ⴰⵍⵍⴰⵗⴰⵜ ⵓⴰ ⵉⵋⵋⴰⵏ ⴰⵍⵍⵗⵉⵙⴰⵔ ⴰⵍⴶⵂⵓⵔⵉⵜⵎ ⵏⵢⵜ ⵉ ⴰⴾⴾⴰⵉ ⵏ ⴰⵍⴾⴰⴷⴻⵈⴰⵍ ⴻⵎⴰⵉⵏⴰⴶ ⵓⴰ ⴷⴰⵔⴰⵎⴰⵏ ⴰⵏ ⵙⴻⵎⴻⵙⵜⴻⵔ ⴰⴷ ⵎⴰⴶⵔⴰⴷ ⵉⵍⴰ ⴰⴶⴰⵔⴰⵓ ⴰⵏ ⵜⵉⴾⴰⵔⵙⴻⵏ# >>> grade_equation.call([4.0, 3, 1.7, 2, 3.5])\n# [\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\ndef numerical_letter_grade(grades)\n","canonical_solution":"def numerical_letter_grade(grades)\n  grades.map do |gpa|\n    case \n    when gpa == 4.0\n      \"A+\"\n    when gpa > 3.7\n      \"A\"\n    when gpa > 3.3\n      \"A-\"\n    when gpa > 3.0\n      \"B+\"\n    when gpa > 2.7\n      \"B\"\n    when gpa > 2.3\n      \"B-\"\n    when gpa > 2.0\n      \"C+\"\n    when gpa > 1.7\n      \"C\"\n    when gpa > 1.3\n      \"C-\"\n    when gpa > 1.0\n      \"D+\"\n    when gpa > 0.7\n      \"D\"\n    when gpa > 0.0\n      \"D-\"\n    else\n      \"E\"\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_numerical_letter_grade\n    candidate = method(:numerical_letter_grade)\n    assert_equal([\"A+\", \"B\", \"C-\", \"C\", \"A-\"], candidate.call([4.0, 3, 1.7, 2, 3.5]))\n    assert_equal([\"D+\"], candidate.call([1.2]))\n    assert_equal([\"D-\"], candidate.call([0.5]))\n    assert_equal([\"E\"], candidate.call([0.0]))\n    assert_equal([\"D\", \"D-\", \"C-\", \"B\", \"B+\"], candidate.call([1.0, 0.3, 1.5, 2.8, 3.3]))\n    assert_equal([\"E\", \"D-\"], candidate.call([0.0, 0.7]))\n  end\nend\n"},{"task_id":"HumanEval_82","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵜⵉⵖⵣⵉ ⵜⴳⴰ ⴰⵎⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏⵖⴷ ⵜⵉⵔⵡⵉ ⵔⵉⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ ⴰⵔ ⵉⵜⵜⴰⵊⵊⴰ ⵜⵉⴷⵜ ⵎⴽ ⵜⴳⴰ ⵓⵡⵉⴽⵉ ⴰⵏⵎⵍⴰⵏ # >>> prime_length.call(\"Hello\")\n# true\n# >>> prime_length.call(\"abcdcba\")\n# true\n# >>> prime_length.call(\"kittens\")\n# true\n# >>> prime_length.call(\"orange\")\n# false\ndef prime_length(string)\n","canonical_solution":"def prime_length(string)\n  length = string.length\n  return false if length < 2\n\n  (2..Math.sqrt(length)).each do |i|\n    return false if length % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_length\n    candidate = method(:prime_length)\n    assert_equal(true, candidate.call(\"Hello\"))\n    assert_equal(true, candidate.call(\"abcdcba\"))\n    assert_equal(true, candidate.call(\"kittens\"))\n    assert_equal(false, candidate.call(\"orange\"))\n    assert_equal(true, candidate.call(\"wow\"))\n    assert_equal(true, candidate.call(\"world\"))\n    assert_equal(true, candidate.call(\"MadaM\"))\n    assert_equal(true, candidate.call(\"Wow\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(true, candidate.call(\"HI\"))\n    assert_equal(true, candidate.call(\"go\"))\n    assert_equal(false, candidate.call(\"gogo\"))\n    assert_equal(false, candidate.call(\"aaaaaaaaaaaaaaa\"))\n    assert_equal(true, candidate.call(\"Madam\"))\n    assert_equal(false, candidate.call(\"M\"))\n    assert_equal(false, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_83","nl":"taq_Tfng","pl":"rb","prompt":"ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ ⵏⵏⴰ ⵉⵙⵙⵏⵜⵉⵢⵏ ⵏⵖⴷ ⵉⵎⵉⵔⴰⵢⵏ ⵙ 1.ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵏⵓⵍⴼⵓ ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ n def starts_one_ends(n)\n","canonical_solution":"def starts_one_ends(n)\n  return 0 if n <= 0\n\n  # Count numbers starting with 1\n  start_with_1 = 9 ** (n - 1)\n\n  # Count numbers ending with 1\n  end_with_1 = 9 ** (n - 1)\n\n  # Adjust for double counting the number that both starts and ends with 1\n  both_start_and_end_with_1 = 9 ** (n - 2) if n > 1\n  \n  start_with_1 + end_with_1 - (both_start_and_end_with_1 || 0)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n  end\nend\n"},{"task_id":"HumanEval_84","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ N, ⵙⵙⴽⵛⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⵙ ⵜⴱⵉⵏⴰⵔⵉⵜ. # >>> solve.call(1000)\n# \"1\"\n# >>> solve.call(150)\n# \"110\"\n# >>> solve.call(147)\n# \"1100\"\n# Variables:\n# @N integer\n# Constraints: 0 ≤ N ≤ 10000.\n# Output:\n# a string of binary number\ndef solve(n)\n","canonical_solution":"def solve(n)\n  sum_of_digits = n.to_s.chars.map(&:to_i).sum\n  sum_of_digits.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n  end\nend\n"},{"task_id":"HumanEval_85","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵓⵙⵔⵙⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⴷⴷⴰⵎⵏ, ⵣⵡⴰⵔ ⴰⴷ ⵏⵔⵏⵓ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ.# >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n","canonical_solution":"def add(lst)\n  lst.each_with_index.select { |num, index| index.odd? && num.even? }.map(&:first).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n    assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0, candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n  end\nend\n"},{"task_id":"HumanEval_86","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴰⵜⵓⵉⵙⵙⴰⵏ: ⵉⵋⵋⴰⵛⵂ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏ ⴰⴾⴰⵔⴰⵛⵂ ⵏ ⵉⵙⵎⴰⵓⴰⵏ ⴷ ⵉⵂⴰⵏⴷⴰⴶⴰⵏ ⵓⵉⵏ ⴰⴱⴰⵔⴰ ⵜⴰⵏ ⴷⴰⵗ ⵜⴰⵗⵢⵍⵉⵜⴾⵢⵍ ⴰⴾⴰⵔⴰⵛⵂ ⵏ ⴰⵍⵈⵉⵎ ⵏ ⴰⵙⵛⵉⵉⴷⴰ ⵜⵜⵓⵙⵏⴼⴰⵍ ⵙ ⵜⴳⵓⵔⵉ ⵜⴰⵎⴰⵢⵏⵓⵜ ⴳ  ⴰⵔ ⵜⵜⵓⵙⵏⵎⴰⵍⴰ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳⵜⴰⵍⵖⴰ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵜⴳⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴳ ⵍⵍⴰⵏⵜ ⴽⵓⵍⵍⵓ ⵜⴳⵓⵔⵉⵡⵉⵏ (ⵜⵓⴱⴹⴰ ⵙ ⵓⵙⴰⵢⵔⴰⵔ) ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⴽⵙⵉⵍ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵜ ⵜⵓⵏⵖⵉⵍⵜ ⵉⵜⵜⵓⵙⵏⵎⴰⵍⴰⵢⵏ.# >>> anti_shuffle.call(\"Hi\")\n# \"Hi\"\n# >>> anti_shuffle.call(\"hello\")\n# \"ehllo\"\n# >>> anti_shuffle.call(\"Hello World!!!\")\n# \"Hello !!!Wdlor\"\ndef anti_shuffle(s)\n","canonical_solution":"def anti_shuffle(s)\n  s.split(\/(\\s+)\/).map { |word| word.chars.sort.join }.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot. How are you?\"))\n  end\nend\n"},{"task_id":"HumanEval_87","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵡⴷ, ⵙⵙⵓⴷⵙ ⴰⴽⵓⵓⵔⴷⵉⵏⴰⵜⵏ ⵏ ⵜⴰⴳⴳⴰⵢⵜ ⵙ ⵜⵔⵙⴰⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔ.ⴷⴰ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ ⵙ ⵜⵉⵣⵡⵓⵔⵉ ⵙ ⵜⵉⵙⵉⴹⴼⵉⵏ ⵙ ⵓⵍⵜⵖ.ⴽⵓ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴳⴰ ⴽⵓⵓⵔⴷⵉⵏⴰⵜ - (ⵜⵉⵔⵉⵜ, ⵜⵉⵔⵙⴰⵍ), ⴰⵔⵜⴰⵉ ⵙ 0.ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴰ ⴰⵙⵔⴷⴰⵙ ⵏ ⵉⵙⵔⴷⴰⵙⵏ, [(x1, y1), (x2, y2) ...] ⵣⵓⵏⴷ ⵎⴰⵙ ⴳ ⵜⵉⴽⴽⵉ ⵏ lst, ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ x, ⵃⵜⵉⵜ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ x ⴳ ⵓⵎⵙⴳⵏⴰⴼ,ⴽⵓ ⵜⴰⵔⵙⵍⵜ ⵜⵣⵎⵔ ⴰⴷ ⵜⴰⴽⴽⴰ ⴰⵎⴹⴰⵏ ⵏ ⵜⵔⵙⴰⵍ ⵉⵣⵍⵉⵏ.ⴰⵢⴰ ⵢⴰⴽⵙⵓⵍ ⴷ ⵎⴰⵜⵔⵉⴽⵙ, ⵎⴰⵛⴰ ⵓⵔ ⵢⴰⴽⵙⵓⵍ ⴷ ⵎⴰⵜⵔⵉⴽⵙ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⵏⵖⵎⵉⵙⵏ ⵏ ⵙⵉⵏ ⵡⵓⴳⴳⵓⴳⵏ, ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵉⵎⵙⴷⴷⵉⵢⵏ ⵉⵎⵎⵔⵓⵔⵉⵏ, # >>> get_row.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n# [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n# >>> get_row.call([], 1)\n# []\n# >>> get_row.call([[], [1], [1, 2, 3]], 3)\n# [[2, 2]]\ndef get_row(lst, x)\n","canonical_solution":"def get_row(lst, x)\n  result = []\n\n  lst.each_with_index do |row, i|\n    row.each_with_index do |value, j|\n      result << [i, j] if value == x\n    end\n  end\n\n  result.sort_by { |coord| [coord[0], -coord[1]] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"},{"task_id":"HumanEval_88","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:* ⵓⵔ ⴷⴰ ⵏⵙⵙⵏⴼⵍ ⴰⵙⵔⴷⴰⵙ ⵉⵜⵜⵓⴼⴽⴰⵏ. ⴰⵜⵡⵉⵍ: ⵏⵖ ⴰⴷ ⵏⵙⵎⵓⵏ ⴳ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵣⴷⴰⵔ ⵉⵖ ⵉⴳⴰ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵖⴰⵍ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵖⴰⵍ ⴰⵎⴳⴳⴰⵔⵓ.ⵔⴰⴷ ⵜⵙⵏⵙⵉ ⵉⵎⵙⴷⴷⵉ ⵏ ⵓⵎⵙⴳⴷⴰⵍ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵙⵙⵓ ⵉⴳ ⵜⵍⵍⴰ ⵜⴳⵔⵓⵎⵎⴰ ((ⵜⵉⴳⵉ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵉⴹⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⴷ ⵡⴰⵜⵉⴳ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵓⵙⵙⵉⴹⵏ ⴰⵎⴳⴳⴰⵔⵓ) ⵓⵔ ⵉⴳⵉⵏ, ⴷⴼⴼⵉⵔ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵎⵙⴷⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵕⵥⵥⴰⵏⵏ, # >>> sort_array.call([])\n# []\n# >>> sort_array.call([5])\n# [5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5])\n# [0, 1, 2, 3, 4, 5]\n# >>> sort_array.call([2, 4, 3, 0, 1, 5, 6])\n# [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n","canonical_solution":"def sort_array(array)\n  return array if array.empty? || array.size == 1\n\n  if (array.first + array.last).odd?\n    array.sort\n  else\n    array.sort.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5], candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2, 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0, 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23, 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"},{"task_id":"HumanEval_89","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴰⴷⴷⵓⵙ ⵙ ⵙⵉⵏ ⵉⴽⴼⵓⴷⵏ ⵙ ⵙⵏⴰⵜ ⵜⵉⵖⴰⵔⵉⵡⵉⵏ.ⵉⵇⵏⴻⵏ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⴰⵍ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵜⵖⴰⵔⴰⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵔⴰⵏⵜ ⵜⴱⵔⵔⴰⵜⵉⵏ ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵜⵉⴼⵉⵏⴰⵖ ⵉⵜⵜⵓⵃⴹⴰⵏ ⵙ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵓⵙⴽⴽⵉⵍ ⵏ ⵜⵉⴼⵉⵏⴰⵖ.ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏ ⵓⵙⵏⴼⵍⵍⵓⵍ ⵏⵏⴰ ⵉⵜⵜⴰⵙⵉⵏ ⵜⵉⴼⵉⵏⴰⵖ ⴰⵎⵎ ⵓⵎⴳⵔⴰⴷ ⴷ # >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"et\")\n# \"ix\"\ndef encrypt(s)\n","canonical_solution":"def encrypt(s)\n  s.chars.map do |char|\n    if char =~ \/[a-z]\/\n      ((char.ord - 'a'.ord + 4) % 26 + 'a'.ord).chr\n    elsif char =~ \/[A-Z]\/\n      ((char.ord - 'A'.ord + 4) % 26 + 'A'.ord).chr\n    else\n      char\n    end\n  end.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"e\", candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_90","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⵉⵜⵓⵔⵏ ⵏⵉⵍ ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ.ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ next_smallest (() ⵏⵏⴰ ⵉⵙⴽⵔⵏ ⵜⵉⴽⴽⵍⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⴳ ⵉⵎⵥⵥⵢⴰⵏ ⵏ ⵓⵎⵙⴳⵏⴰⴼ. ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.# >>> next_smallest.call([1, 2, 3, 4, 5])\n# 2\n# >>> next_smallest.call([5, 1, 4, 3, 2])\n# 2\n# >>> next_smallest.call([])\n# nil\n# >>> next_smallest.call([1, 1])\n# nil\ndef next_smallest(lst)\n","canonical_solution":"def next_smallest(lst)\n  unique_sorted = lst.uniq.sort\n  unique_sorted.length >= 2 ? unique_sorted[1] : nil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1, candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"},{"task_id":"HumanEval_91","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵜⵉⴼⵔⴰⵙ ⴰⵜ-ⵓ-ⴰⵗⴱⴰⵍ ⵏⴰⵜ ⵙ \"\", \"?\" ⵎⵢⵗ \"!\"\"ⵜⵉⵎⵙⵓⵜⴰ\" ⵜⴰⵈⵈⴰⵍ ⵜⴰⵗⵉⵍⵉⵜ ⵜⵉⵙⵙⵉⵏⵜⴰ ⵙ ⵉⵙⵉⵎ ⵓⴰⵏ \"I\"ⴰⴷ ⴰⵜⵓⴰⴾⴰⵙⴰⵏ ⵜⴰⴱⴰⵔⴰⵜ ⴰⵏ ⵎⴰⴶⵔⴰⴷ, ⴰⴷ ⴰⵛⴰⵆⵉⵍ ⴰⵏⴻⵙ ⴰⴷ ⴰⵉⴶⵉ ⴰⵏ ⵎⴰⴶⵔⴰⴷ.# >>> is_bored.call(\"Hello world\")\n# 0\n# >>> is_bored.call(\"The sky is blue. The sun is shining. I love this weather\")\n# 1\ndef is_bored(s)\n","canonical_solution":"def is_bored(s)\n  sentences = s.split(\/(?<=[.?!])\/)\n  sentences.count { |sentence| sentence.strip.start_with?('I') }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1, candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"))\n  end\nend\n"},{"task_id":"HumanEval_92","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴼⵉⵔⴰⵙ ⵜⵉⵣⴳⴰⵍⵉⵏ ⴳ ⴽⵔⴰ ⵏ ⵡⴰⴷⴷⴰⴷⵏ ⵢⴰⴹⵏ.ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵢⴰⵏ ⴳ ⵡⵓⵟⵟⵓⵏⵏ ⴰⵎⵎ ⵓⴳⵣⵓⵎ ⵏ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵢⴰⴹⵏ, ⴷ ⵡⵓⵟⵟⵓⵏ ⴰⴽⴽⵡ ⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ 3 ⵏ ⵡⵓⵟⵟⵓⵏ.# >>> any_int.call(5, 2, 7)\n# true\n# >>> any_int.call(3, 2, 2)\n# false\n# >>> any_int.call(3, -2, 1)\n# true\n# >>> any_int.call(3.6, -2.2, 2)\n# false\ndef any_int(x, y, z)\n","canonical_solution":"def any_int(x, y, z)\n  if [x, y, z].all? { |n| n.is_a?(Integer) }\n    x == y + z || y == x + z || z == x + y\n  else\n    false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_any_int\n    candidate = method(:any_int)\n    assert_equal(true, candidate.call(2, 3, 1))\n    assert_equal(false, candidate.call(2.5, 2, 3))\n    assert_equal(false, candidate.call(1.5, 5, 3.5))\n    assert_equal(false, candidate.call(2, 6, 2))\n    assert_equal(true, candidate.call(4, 2, 2))\n    assert_equal(false, candidate.call(2.2, 2.2, 2.2))\n    assert_equal(true, candidate.call(-4, 6, 2))\n    assert_equal(true, candidate.call(2, 1, 1))\n    assert_equal(true, candidate.call(3, 4, 7))\n    assert_equal(false, candidate.call(3.0, 4, 7))\n  end\nend\n"},{"task_id":"HumanEval_93","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⵂⴰ ⴰⴷ ⴰⴾⵜⴰⴱⴰⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏⴰⵛⵛⵉⵍ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵓⴰⵏ ⴰⵏⴶⵍⵉⵣⵜⴰⴱⵔⴰⵜ ⵙ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵜⵜⵉⵍⵉⵏ ⵙⵏⴰⵜ ⵏ ⵡⴰⵏⵙⴰⵢⵏ ⴷⴰⵜ ⵏ ⵜⴱⵔⴰⵜ ⴷⴰ ⵉⵜⵜⵎⵓⵜⵜⴰⵢ ⵡⴰⵏⴰⵡ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⴷⴰ ⵉⵜⵜⵎⵓⵜⵜⴰⵢ ⴽⵓⵍⵍⵓ ⵉⵎⵙⵍⵉ ⴳ ⵔⵔⴰⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⴰⵔ ⵉⵜⵜⵓⵣⵎⵎⴻⵎ ⴳ # >>> encode.call(\"test\")\n# \"TGST\"\n# >>> encode.call(\"This is a message\")\n# \"tHKS KS C MGSSCGG\"\ndef encode(message)\n","canonical_solution":"def encode(message)\n  vowels = 'aeiou'\n  swap_vowels = {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w'}\n  \n  encoded_message = message.chars.map do |char|\n    if vowels.include?(char.downcase)\n      new_char = swap_vowels[char.downcase]\n      char == char.upcase ? new_char.upcase : new_char.downcase\n    else\n      char == char.upcase ? char.downcase : char.upcase\n    end\n  end\n\n  encoded_message.join\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"},{"task_id":"HumanEval_94","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⴼ ⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ ⴰⵅⴰⵜⴰⵔ, ⴷ ⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.# >>> skjkasdkd.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n# 10\n# >>> skjkasdkd.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n# 25\n# >>> skjkasdkd.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n# 13\n# >>> skjkasdkd.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n# 11\n# >>> skjkasdkd.call([0, 81, 12, 3, 1, 21])\n# 3\n# >>> skjkasdkd.call([0, 8, 1, 2, 1, 7])\n# 7\ndef skjkasdkd(lst)\n","canonical_solution":"def skjkasdkd(lst)\n  require 'prime'\n\n  # Find the largest prime number in the array\n  largest_prime = lst.select { |num| Prime.prime?(num) }.max\n  \n  # Return 0 if no prime number is found\n  return 0 if largest_prime.nil?\n\n  # Calculate the sum of digits of the largest prime number\n  largest_prime.to_s.chars.map(&:to_i).sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_skjkasdkd\n    candidate = method(:skjkasdkd)\n    assert_equal(10, candidate.call([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))\n    assert_equal(25, candidate.call([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))\n    assert_equal(13, candidate.call([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))\n    assert_equal(11, candidate.call([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))\n    assert_equal(3, candidate.call([0, 81, 12, 3, 1, 21]))\n    assert_equal(7, candidate.call([0, 8, 1, 2, 1, 7]))\n    assert_equal(19, candidate.call([8191]))\n    assert_equal(19, candidate.call([8191, 123456, 127, 7]))\n    assert_equal(10, candidate.call([127, 97, 8192]))\n  end\nend\n"},{"task_id":"HumanEval_95","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵀⴰⵜ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵏ ⵜⵉⵣⴳⵉⵍⵜ ⵉⴳ ⵉⵍⵍⴰ ⵓⵃⴰⵛ ⵉⵜⵜⵓⴼⴽⴰⵏ.ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴽⵓⵍⵍⵓ ⵉⵙⵍⴽⵉⵏ ⵜⵉⵙⴳⵓⵔⵉⵡⵉⵏ ⴳ ⵜⵉⵙⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵅⴰⵜⴰⵔⵉⵏ, ⵔⴰⴷ ⵢⴰⴽⵡⵣ false.ⵉⴳ ⴷⴰⵔⴽ ⵉⵙⵎ ⵏ ⵓⵛⵛⵉ, ⵙⵓⵍ ⵉⴽⴼⵉⴷ ⵜⵉⴷⵜ ⵎⴽ ⴳⴰⵏ ⴽⵓⵍⵍⵓ ⵉⵙⵍⴽⵉⵏ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⴳ ⵍⵉⵙⵜⵔⴰⵔ # >>> check_dict_case.call({\"a\" => \"apple\", \"b\" => \"banana\"})\n# true\n# >>> check_dict_case.call({\"a\" => \"apple\", \"A\" => \"banana\", \"B\" => \"banana\"})\n# false\n# >>> check_dict_case.call({\"a\" => \"apple\", 8 => \"banana\", \"a\" => \"apple\"})\n# false\n# >>> check_dict_case.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"})\n# false\n# >>> check_dict_case.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"})\n# true\ndef check_dict_case(dict)\n","canonical_solution":"def check_dict_case(dict)\n  return false if dict.empty?\n\n  lowercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.downcase }\n  uppercase_keys = dict.keys.all? { |key| key.is_a?(String) && key == key.upcase }\n\n  lowercase_keys || uppercase_keys\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_dict_case\n    candidate = method(:check_dict_case)\n    assert_equal(true, candidate.call({\"p\" => \"pineapple\", \"b\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"A\" => \"banana\", \"B\" => \"banana\"}))\n    assert_equal(false, candidate.call({\"p\" => \"pineapple\", \"5\" => \"banana\", \"a\" => \"apple\"}))\n    assert_equal(false, candidate.call({\"Name\" => \"John\", \"Age\" => \"36\", \"City\" => \"Houston\"}))\n    assert_equal(true, candidate.call({\"STATE\" => \"NC\", \"ZIP\" => \"12345\"}))\n    assert_equal(true, candidate.call({\"fruit\" => \"Orange\", \"taste\" => \"Sweet\"}))\n    assert_equal(false, candidate.call({}))\n  end\nend\n"},{"task_id":"HumanEval_96","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵣⵡⵓⵔⴰ ⴷ ⵡⵉⵏ ⵡⴰⵔ n. ⵙⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⴳⵉⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵎⵙⴳⴷⴰⵍ ⵏ ⵉⵎⵉⴹⵏ ⵉⵎⵣⵡⵓⵔⴰ n # >>> count_up_to.call(5)\n# [2, 3]\n# >>> count_up_to.call(11)\n# [2, 3, 5, 7]\n# >>> count_up_to.call(0)\n# []\n# >>> count_up_to.call(20)\n# [2, 3, 5, 7, 11, 13, 17, 19]\n# >>> count_up_to.call(1)\n# []\n# >>> count_up_to.call(18)\n# [2, 3, 5, 7, 11, 13, 17]\ndef count_up_to(n)\n","canonical_solution":"def count_up_to(n)\n  return [] if n <= 2\n  primes = []\n  (2...n).each do |num|\n    is_prime = true\n    (2..Math.sqrt(num)).each do |i|\n      if num % i == 0\n        is_prime = false\n        break\n      end\n    end\n    primes << num if is_prime\n  end\n  primes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([], candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"},{"task_id":"HumanEval_97","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵉⵏⴰⵣⴶⴰⵎ ⴰⵙ ⵉⴾⵉ ⵏⴰⴾⴰⵛⴰⴷ ⴰⵈⴰⵍ ⴰⴶⵓⴷⵉⵉⴰⵏ ⴰⵗⴰⵍ.ⴰⵎⵢⴰⴼⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⴰⴳⵣⵣⵓⵎⵜ ⵏⵏⵙⵏ.ⵜⵢⵎⵎⴰ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ # >>> multiply.call(148, 412)\n# 16\n# >>> multiply.call(19, 28)\n# 72\n# >>> multiply.call(2020, 1851)\n# 0\n# >>> multiply.call(14, -15)\n# 20\ndef multiply(a, b)\n","canonical_solution":"def multiply(a, b)\n  a_unit_digit = a.abs % 10\n  b_unit_digit = b.abs % 10\n  a_unit_digit * b_unit_digit\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_multiply\n    candidate = method(:multiply)\n    assert_equal(16, candidate.call(148, 412))\n    assert_equal(72, candidate.call(19, 28))\n    assert_equal(0, candidate.call(2020, 1851))\n    assert_equal(20, candidate.call(14, -15))\n    assert_equal(42, candidate.call(76, 67))\n    assert_equal(49, candidate.call(17, 27))\n    assert_equal(0, candidate.call(0, 1))\n    assert_equal(0, candidate.call(0, 0))\n  end\nend\n"},{"task_id":"HumanEval_98","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵙ ⵜⵉⴼⵉⴼⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ s, ⵔⵎⵙⵏ ⴰⵎⴹⴰⵏ ⵏ ⵉⵎⵙⵍⵉⵢⵏ ⵉⵎⵇⵔⴰⵏⵏ ⴳ ⵉⵙⵏⴼⴰⵔⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. # >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n","canonical_solution":"def count_upper(s)\n  vowels = ['A', 'E', 'I', 'O', 'U']\n  count = 0\n\n  s.chars.each_with_index do |char, index|\n    if index.even? && vowels.include?(char)\n      count += 1\n    end\n  end\n\n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"EEEE\"))\n  end\nend\n"},{"task_id":"HumanEval_99","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵙⴳ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵓⵏ ⵙⴳ ⵓⵎⵢⴰ.ⴰⵔ ⵉⵜⵜⴰⴷⴼ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵉⵔⵉⵡ ⴰⴽⴽⵡ ⵉⵎⵉⵔⵉⵡⵏ. ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵉⵔⵉⵡ ⴰⵎⵣⴰⵔⴰⵢ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵡⴰⵜⵉⴳ (ⵜⴰⵙⵉⵔⵜ) ⵉⵙⵎⴷⵢⴰⵏ ⴰⵎⴹⴰⵏ # >>> closest_integer.call(\"10\")\n# 10\n# >>> closest_integer.call(\"15.3\")\n# 15\n# Note:\n# Rounding away from zero means that if the given number is equidistant\n# from two integers, the one you should return is the one that is the\n# farthest from zero. For example closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\ndef closest_integer(value)\n","canonical_solution":"def closest_integer(value)\n  number = value.to_f\n  if number > 0\n    (number + 0.5).floor\n  else\n    (number - 0.5).ceil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"},{"task_id":"HumanEval_100","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:i ⴰⵎⵓⵙ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⵉⵂⵓⴾⴰⵏ ⴷⴰⵗ ⵢⴷⴰⴶ ⵓⴰⵏ (ⵉ+1)ⴷⴰ ⵉⵜⵜⴰⵊⵊⵓ ⵓⵟⵟⵓⵏ ⵏ ⵉⵃⵔⵉⵜⵏ ⴳ ⴽⵓ ⴰⵙⵡⵉⵔ ⴳ ⵓⵎⵙⴳⵏⴰⴼ, ⴳ ⵉⵍⵍⴰ ⵓⵏⴰⵎⴽ ⴳ ⵓⵙⵏⵎⵍ - ⴰⵎⴹⴰⵏ ⴰⵎⵎⵓⵟⵟⵓⵏ ⴰⵎⵎⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵉⴳ n ⴰⵎⵎⵓⵟⵟⵓⵏ. - ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⴰⵎⴹⴰⵏ ⴰⵎⵣⴰⵔⴰⵢ ⵉⴳ n ⴰⵎⵣⴰⵔⴰⵢ. ⵓⵉ-ⴷ-ⵉⵍⵍⴰⵏ ⴷⴰⵗ ⵜⴰⵂⵔⵉⴾⴻ ⵜⴰⵏ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⴰⵎⵓⵙⴰⵏ:ⴰⵙⵉⵔⵜⴰⵉ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏ ⵉⵍⴰ N ⵉⵂⴰⵏⴷⴰⴶⴰⵏⵎⴽ ⴷ ⵢⴰⴽⴽⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵙⴽⵔ ⵢⴰⵜ ⵜⵔⴱⴰⵜ ⵏ n ⵉⵙⵡⵉⵔⵏ ⵏ ⵉⵅⵅⴰⵏⵏ.# >>> make_a_pile.call(3)\n# [3, 5, 7]\ndef make_a_pile(n)\n","canonical_solution":"def make_a_pile(n)\n  result = []\n  current_stones = n\n  n.times do\n    result << current_stones\n    current_stones += 2\n  end\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9, 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"},{"task_id":"HumanEval_101","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴰⴷ ⵜⴱⴹⵓ ⵜⵉⴼⵉⵏⴰⵖ ⵖⵔ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ.ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵈⵈⵉⵍ ⴾⵢⵍ ⵉⵙⵎⴰⵓⴰⵏ ⴰⵋⵋⵓⵜⵏⵢⵏ ⵉⵋⵋⴰⵏⵢⵏ ⵙ ⵛⵓⵎⴰ ⵜⴰⵏ ⵎⵢⵗ ⵙⴱⵢⵛⵢⵙ ⵜⴰⵏ ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ# >>> words_string.call(\"Hi, my name is John\")\n# [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n# >>> words_string.call(\"One, two, three, four, five, six\")\n# [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n","canonical_solution":"def words_string(s)\n  s.split(\/[\\s,]+\/)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\", \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two, three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([], candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"ahmed     , gamal\"))\n  end\nend\n"},{"task_id":"HumanEval_102","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵓⵔ ⵉⵍⵍⵉ ⵡⵓⵟⵟⵓⵏ ⴰⴷ, ⵇⴰⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ -1.ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵇⵇⵔⴰⵏ ⴳ ⵓⵎⵣⴰⵔⴰⵢ [x, y] ⴳ ⵜⵓⵎⵣⵉⵏ. ⵎⴽ ⴷⴰ ⵜⴽⴽⴰ ⵜⵎⵔⵙⵜ ⴰⴷ ⵙⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵃⵍⴰⵏ x ⴷ y ⴰⵔ ⵜⵔⴰⵔ # >>> choose_num.call(12, 15)\n# 14\n# >>> choose_num.call(13, 12)\n# -1\ndef choose_num(x, y)\n","canonical_solution":"def choose_num(x, y)\n  return -1 if x > y\n  # Start looking from the largest number\n  max_even = y.even? ? y : y - 1\n  # Iterate downwards to find the biggest even number\n  max_even.downto(x) do |n|\n    return n if n.even?\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_choose_num\n    candidate = method(:choose_num)\n    assert_equal(14, candidate.call(12, 15))\n    assert_equal(-1, candidate.call(13, 12))\n    assert_equal(12354, candidate.call(33, 12354))\n    assert_equal(-1, candidate.call(5234, 5233))\n    assert_equal(28, candidate.call(6, 29))\n    assert_equal(-1, candidate.call(27, 10))\n    assert_equal(-1, candidate.call(7, 7))\n    assert_equal(546, candidate.call(546, 546))\n  end\nend\n"},{"task_id":"HumanEval_103","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵎⴽ ⵜⴳⴰ n ⴰⵅⴰⵜⴰⵔ ⵙⴳ m, ⵔⵔⵓⵜⵓⵔ -1.ⵔⵓⵏⴷ ⵜⵔⴰⵔⵓⵜ ⵖⵔ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵉⴹⴰⵏ ⴷ ⵜⵙⵏⴼⵍ ⵖⵔ ⴱⵉⵏⴰⵔⵉ.ⴰⵎⵎⴰⵙⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙⴳ n ⴰⵔ m (ⴰⵎⵓⵏ ⴷ n ⴷ m).ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ n ⴷ m, ⴷ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵉⵟⵏ # >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>> rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n# >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n","canonical_solution":"def rounded_avg(n, m)\n  return -1 if n > m\n\n  sum = (n..m).reduce(:+)\n  count = m - n + 1\n  average = (sum.to_f \/ count).round\n  \"0b\" + average.to_i.to_s(2)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1, 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996, 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362, 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7, 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5, 5))\n  end\nend\n"},{"task_id":"HumanEval_104","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵜⴰⵍⵖⴰ: ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵉⵎⵙⴷⴷⵉⵢⵏ ⵉⵜⵜⵓⵙⵎⵓⵜⵜⵓⵢⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ.ⵉⴼⵔⴷⵉⵙⵏ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ.ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴽⵙⵡⴰⵜⵏ x, ⵔⴰⴷ ⵏⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ # >>> unique_digits.call([15, 33, 1422, 1])\n# [1, 15, 33]\n# >>> unique_digits.call([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n","canonical_solution":"def unique_digits(x)\n  x.select { |num| num.to_s.chars.none? { |digit| digit.to_i.even? } }.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15, 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n    assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31, 135], candidate.call([135, 103, 31]))\n  end\nend\n"},{"task_id":"HumanEval_105","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: \"ⵢⵉⴰⵏ\", \"ⵉⵏⵏⴰ\", \"ⵜⵕⴰⴹ\", \"ⴽⵓⵥ\", \"ⵎⵎⵓⵙ\", \"ⵙⴹⵉⵙ\", \"ⴰⵙⵙⴰ\", \"ⵜⴰⵎⵔⴰⵡ\". ⵔⵔⵣⵓ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵉⵜⵜⵓⵙⵢⴰⴼⴰⵏ, ⴷ ⴷⴼⴼⵉⵔ ⴰⴷ ⵙⵎⵓⵜⵜⵔ ⴽⵓ ⵓⴽⵕⴹ ⵙ ⵢⵉⵙⵎ ⵏⵏⵙ ⵙⴳ ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⵙⵓⴷⵙ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳⵔ 1 ⴷ 9 ⴳ ⵜⴰⵎⵎ ⵏⵙⵏ, # >>> by_length.call([2, 1, 1, 4, 5, 8, 2, 3])\n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# >>> by_length.call([])\n# []\n# If the array has any strange number ignore it:\n# >>> by_length.call([1, -1, 55])\n# [\"One\"]\ndef by_length(arr)\n","canonical_solution":"def by_length(arr)\n  number_names = {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\"\n  }\n\n  filtered_sorted_reversed = arr.select { |x| x.between?(1, 9) }.sort.reverse\n  filtered_sorted_reversed.map { |num| number_names[num] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5, 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"], candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"], candidate.call([9, 4, 8]))\n  end\nend\n"},{"task_id":"HumanEval_106","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵉⴳⴰ ⵓⴼⴰⴽⵜⵓⵔⵢⴰⵍ ⵏ \"ⵉ\" ⴰⵙⴼⵓⴽⵍⵓ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ \"ⵉ\" (1 * 2 * ... * \"ⵉ\").ⵔⴰⴷ ⵙⵏⵜⵉ ⵙⴳ 1.ⵏⵖⴷ ⵜⴳⵎⵉⴹⵉ ⵏ ⵡⵓⵟⵟⵓⵏ ⵙⴳ 1 ⴰⵔ i. ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ n, ⵣⵓⵏⴷ ⵎⴰⵙⴷ ⴰⵜⵉⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵙⵖⵍ \"ⵉ\" ⵉⴳⴰ ⵜⴰⴳⴳⴰⵢⵜ ⵏ \"ⵉ\" ⵎⴽ ⵜⴳⴰ \"ⵉ\" ⵙⵙⵎⵔⵙ ⵜⴰⵡⵓⵔⵉ f ⵏⵏⴰ ⵢⵓⵎⵥⵏ n ⴰⵎⵎ ⵓⵎⵙⴽⴰⵔ, # >>> f.call(5)\n# [1, 2, 6, 24, 15]\ndef f(n)\n","canonical_solution":"def f(n)\n  (1..n).map do |i|\n    if i.even?\n      (1..i).inject(:*) || 1\n    else\n      (1..i).inject(:+)\n    end\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_f\n    candidate = method(:f)\n    assert_equal([1, 2, 6, 24, 15], candidate.call(5))\n    assert_equal([1, 2, 6, 24, 15, 720, 28], candidate.call(7))\n    assert_equal([1], candidate.call(1))\n    assert_equal([1, 2, 6], candidate.call(3))\n  end\nend\n"},{"task_id":"HumanEval_107","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ 1:ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵜⴱⴰⵍⵉⵏⴷⵔⵓⵎⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵎⵎⴰⵙ ((1, n), ⴳ ⵜⴰⵎⵎⵏⵜ.ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⴰⵏ ⵉⵎⵎⵔⵉⵏⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ # >>> even_odd_palindrome.call(3)\n# [1, 2]\n# Explanation:\n# Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# >>> even_odd_palindrome.call(12)\n# [4, 6]\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1 <= n <= 10^3\n# 2. returned array has the number of even and odd integer palindromes respectively.\ndef even_odd_palindrome(n)\n","canonical_solution":"def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n\n  (1..n).each do |num|\n    if num.to_s == num.to_s.reverse\n      if num.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n\n  [even_count, odd_count]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_palindrome\n    candidate = method(:even_odd_palindrome)\n    assert_equal([8, 13], candidate.call(123))\n    assert_equal([4, 6], candidate.call(12))\n    assert_equal([1, 2], candidate.call(3))\n    assert_equal([6, 8], candidate.call(63))\n    assert_equal([5, 6], candidate.call(25))\n    assert_equal([4, 6], candidate.call(19))\n    assert_equal([4, 5], candidate.call(9))\n    assert_equal([0, 1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_108","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ -123 ⵉⵍⴰ ⵉⵎⴹⴰⵏⵏ ⵉⵎⵓⵙⵙⵓⵜⵏ -1, 2, ⴷ 3. ⵎⴽ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⴳⵓⵔ, ⵔⴰⴷ ⵉⴳ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⵙ ⴰⵎⴳⵓⵔ:ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ > 0. ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ count_nums ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴰ # >>> count_nums.call([])\n# 0\n# >>> count_nums.call([-1, 11, -11])\n# 1\n# >>> count_nums.call([1, 1, 2])\n# 3\ndef count_nums(arr)\n","canonical_solution":"def count_nums(arr)\n  arr.count do |num|\n    num.to_s.chars.map(&:to_i).sum > 0\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1, 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5, candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0, 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"},{"task_id":"HumanEval_109","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵜⴰⵍⵖⴰ: ⴷⴰ ⵉⵜⵜⵓⵙⴷⴷⴰ ⵎⴰⵙ ⴷⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵥⵍⴰⵢⵏ.ⵎⴽ ⵜⴳⴰ ⵜⵔⴰⴱⴱⵓⵜ ⵜⴰⵡⴼⵔⴰⵏⵜ ⵜⵍⵍⵓⵍⴷ, ⴹⴰⵕⵜ ⵓⵢⴰ ⵔⴰⴷ ⴷ-ⵜⵓⵖⴰⵍ ⵜⵉⴷⵜ ⵏⵖ ⵔⴰⴷ ⴷ-ⵜⵓⵖⴰⵍ ⵜⵉⴱⵔⵙⴳⴳⵡⴰⴷⵜ.ⵉⵖ ⵜⵣⵎⵔⵎ ⴰⴷ ⵜⴰⵡⵉⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵜⵉⴳⴳⵉⵜ ⵏ ⵜⵎⵙⴽⵔⵜ ⵏⵏⵉⴳ ⵏ ⵓⵢⴰ ⵜⵉⴷⴷⴰⴷⵜ ⵏ ⵓⵙⵙⵏⵜⵉ ⴳ ⵓⵎⵙⴳⵏⴰⴼ, ⵉⴳⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵡⵉⵙⵙ 0.ⵔⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵓⵏⴰⵡ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵜⵉⴳⴳⵉⵜ ⵏ ⵓⵙⵙⴼⵍⴷ ⵙ ⵓⵣⵔⴼ ⵜⵔⵏⴰ ⴰⵙⴼⵍⴷ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵢⴰⵏ.ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⴽⵔⵎ ⵜⵉⴳⴳⵉⵜ ⵏ ⵓⵙⵏⴼⵍ ⵙ ⵓⵣⵔⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⵉⴽⴽⴰⵍ.ⵜⵉⴳⴳⵉⵜ ⴰⴷ ⵅⴼ ⵓⵎⵙⴳⵏⴰⴼ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ: ⵉⵖⵢ ⴰⴷ ⵏⵙⵎⵓⵏ ⵜⴰⵔⵔⴰⵢⵜ ⵙ ⵓⵍⵓⴳ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵔⵔⵓⴽ ⵙ ⵜⴽⴰⵔⴹⴰ ⵏ ⵔⴰⴷ ⵜⵜⵓⵙⵏⵎⴰⵍⴰⵜ ⵉⵎⴹⴰⵏ ⴳ ⵓⵎⵙⴰⵙⴰ ⵙ ⵜⴱⵔⵉⴷⵜ ⵏ ⵓⵙⴽⵙⵍ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⵏⵎ ⵎⴰⵙ ⵖⵓⵔⵖ ⵜⴰⴳⵔⵓⵎⵎⴰ 'ⴰⵔⵔ' ⵏ N ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ arr[1], arr[2], ..., arr[N].# >>> move_one_ball.call([3, 4, 5, 1, 2])\n# true\n# Explanation: By performin 2 right shift operations, non-decreasing order can\n# be achieved for the given array.\n# >>> move_one_ball.call([3, 5, 4, 1, 2])\n# false\n# Explanation:It is not possible to get non-decreasing order for the given\n# array by performing any number of right shift operations.\ndef move_one_ball(arr)\n","canonical_solution":"def move_one_ball(arr)\n  return true if arr.empty?\n\n  n = arr.size\n  count_rotation_point = 0\n  rotation_index = -1\n\n  (0...n).each do |i|\n    next_index = (i + 1) % n\n    if arr[i] > arr[next_index]\n      count_rotation_point += 1\n      rotation_index = next_index\n    end\n  end\n\n  count_rotation_point <= 1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_move_one_ball\n    candidate = method(:move_one_ball)\n    assert_equal(true, candidate.call([3, 4, 5, 1, 2]))\n    assert_equal(true, candidate.call([3, 5, 10, 1, 2]))\n    assert_equal(false, candidate.call([4, 3, 1, 2]))\n    assert_equal(false, candidate.call([3, 5, 4, 1, 2]))\n    assert_equal(true, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_110","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ, ⵙⵓⵍ \"ⵓⵀⵓ\".ⵎⴰⵔ ⴰⴷ ⴳⵉⵏ ⴰⴽⴽⵡ ⵉⴼⵔⴷⵉⵙⵏ ⵏ lst1 ⵉⵎⵣⴰⵔⴰⵢⵏ, ⵙⵙⴽⵔ \"YES\".ⵉⵖ ⵜⵣⵎⵔⵎ ⴰⴷ ⵏⵙⵎⵓⵜⵜⵔ ⵉⴼⵔⴷⵉⵙⵏ ⴳⵔ lst1 ⴷ lst2 ⵃⵎⴰ ⴰⴷ ⵏⵙⴽⵔ ⵓⵔ ⵉⵍⵍⵉ ⵓⵜⵜⵓ ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴳⵔ lst1 ⴷ lst2.ⵔⴰⵔⵏ ⴰⵙⵏⵙⵍ ⵏ LST1 ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⵡⵉⵏ ⴷ ⴷⴰ ⵉⵜⵜⵉⵔⵉ ⵎⴰⵢⴷ ⵉⵥⴹⴰⵕ ⴰⴷ ⵉⵜⵜⵓⵙⵏⴼⵍ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵜⵎⵓⴽⵔⵉⵙⵜ ⴰⴷ, ⵔⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵢⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵙⵏⴼⴰⵔⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, # >>> exchange.call([1, 2, 3, 4], [1, 2, 3, 4])\n# \"YES\"\n# >>> exchange.call([1, 2, 3, 4], [1, 5, 3, 4])\n# \"NO\"\n# It is assumed that the input arrays will be non-empty.\ndef exchange(lst1, lst2)\n","canonical_solution":"def exchange(lst1, lst2)\n  # Check if lst1 already consists solely of even numbers\n  return \"YES\" if lst1.all?(&:even?)\n\n  # Check if there are at least as many even numbers in lst2\n  # as there are odd numbers in lst1\n  odd_count_lst1 = lst1.count(&:odd?)\n  even_count_lst2 = lst2.count(&:even?)\n\n  odd_count_lst1 <= even_count_lst2 ? \"YES\" : \"NO\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_exchange\n    candidate = method(:exchange)\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [1, 2, 3, 4]))\n    assert_equal(\"NO\", candidate.call([1, 2, 3, 4], [1, 5, 3, 4]))\n    assert_equal(\"YES\", candidate.call([1, 2, 3, 4], [2, 1, 4, 3]))\n    assert_equal(\"YES\", candidate.call([5, 7, 3], [2, 6, 4]))\n    assert_equal(\"NO\", candidate.call([5, 7, 3], [2, 6, 3]))\n    assert_equal(\"NO\", candidate.call([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]))\n    assert_equal(\"YES\", candidate.call([100, 200], [200, 200]))\n  end\nend\n"},{"task_id":"HumanEval_111","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵎⴽ ⴳⴰⵏ ⴽⵉⴳⴰⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉ ⵜⵉⴽⴽⵉ ⵢⴰⵜ, ⵔⵎⵙⵏ ⴰⴽⴽⵡ.ⵏ ⵜⴰⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵍⵙⵏ ⴽⵉⴳⴰⵏ ⴷ ⵉⵍⵍⴰ ⴳⵉⵙ ⵓⵟⵟⵓⵏ ⵏ ⵜⴱⵔⴰⵜ ⵏⵏⴰ ⵉⵇⵇⵏⵏ ⴰⴽⴷ ⵜⴱⵔⴰⵜ.ⵎⴽ ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵉⴼⵔⵜ ⵉⵙⵎⴷⵢⴰⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵜⵉⵎⵥⵥⵢⴰⵏⵉⵏ ⵉⵜⵜⵢⴰⴼⴰⵏ ⵙ ⵜⵉⴽⵍⵜ, ⵙⵙⴽⵛⵎ ⵀⴰⵛⵉ.# >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" => 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n# {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n","canonical_solution":"def histogram(test)\n  return {} if test.empty?\n\n  count = Hash.new(0)\n\n  test.split.each do |char|\n    count[char] += 1\n  end\n\n  max_count = count.values.max\n  count.select { |_, value| value == max_count }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1, \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4}, candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"},{"task_id":"HumanEval_112","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍⵉⵇⵇⴰⵏⴷ ⴰⴷ ⴷ-ⵜⵔⴰⵔⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⵓⵙⵏⵙⵍ ⵏ ⵜⵢⴰⴼⵓⵜ ⴷ true\/false ⵉ ⵓⵣⵣⵔⴰⵢ.ⴷⴰ ⵜⵜⵉⵏⵉⵏ ⵉ ⵡⵓⵟⵟⵓⵏ ⴱⴰⵍⵉⵏⴷⵔⵓⵎ ⵉⵖ ⵉⴳⴰ ⵡⴰⵏⵏⴰⵢ ⵏⵏⵙ ⴰⵎ ⵡⴰⵏⵏⴰⵢ ⵏⵏⵙ ⵙ ⴷⴰⵜ.ⴹⴰⵕⵜ ⵓⵢⴰ, ⵥⵕⵖ ⵉⵙ ⵜⴳⴰ ⵜⵉⴼⵔⵜ ⵏ ⵜⵢⴰⴼⵓⵜ ⵜⴰⴱⴰⵍⵉⵏⴷⵔⵓⵎⵜ.ⴷⴰ ⵏⵜⵜⴰⴽⴽⴰ ⵙⵉⵏ ⵉⵙⵉⵔⵎⵏ s ⴷ c, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⴽⵛⵎ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ s ⵏⵏⴰ ⵉⴳⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉ ⴽⵓⵍⵍⵓ ⵉⵙⴽⴽⵉⵍⵏ ⴳ c.ⵜⴰⵣⵣⴰⵍⵜ # >>> reverse_delete.call(\"abcde\", \"ae\")\n# [\"bcd\", false]\n# >>> reverse_delete.call(\"abcdef\", \"b\")\n# [\"acdef\", false]\n# >>> reverse_delete.call(\"abcdedcba\", \"ab\")\n# [\"cdedc\", true]\ndef reverse_delete(s, c)\n","canonical_solution":"def reverse_delete(s, c)\n  # Remove all characters in c from s\n  filtered_string = s.delete(c)\n  \n  # Check if the filtered string is a palindrome\n  is_palindrome = filtered_string == filtered_string.reverse\n  \n  # Return the result array\n  [filtered_string, is_palindrome]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\", \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n    assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\", true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true], candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"mamma\", \"mia\"))\n  end\nend\n"},{"task_id":"HumanEval_113","nl":"taq_Tfng","pl":"rb","prompt":"ⵏ ⵡⵓⵟⵟⵓⵏ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ ⴳ ⵜⵣⵍⵉⵜ ⵜⵉⵙⵙ i ⵏ ⵓⵙⴽⵛⵎ.\" ⴳ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⵙⵏⴼⴰⵍⵏ ⴽⵓⵍⵍⵓ ⵜⵉⵖⵔⵎⵉⵡⵉⵏ \"ⵉ\" ⵙ ⵓⵟⵟⵓⵏ ⴽⵓ ⵉⴼⵔⴷⵉⵙ i ⵏ ⵜⵢⴰⴼⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⴳ \" ⵓⵟⵟⵓⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⵉⴹⵏ, ⴳ ⴽⵓ ⵉⵙⵉⴹⵏ ⵓⵔ ⵉⴳⵉⵏ ⵡⵉⵏ ⵡⵓⵟⵟⵓⵏ, ⵙⵙⴽⵔ ⴰⵙⵏⵙⵍ.# >>> odd_count.call([\"1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n","canonical_solution":"def odd_count(lst)\n  lst.map do |num_str|\n    count = num_str.count('13579')\n    \"the number of odd elements #{count}n the str#{count}ng #{count} of the #{count}nput.\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\", \"314\"]))\n  end\nend\n"},{"task_id":"HumanEval_114","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍⵏ ⵉⵎⴹⴰⵏⵏ.ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵙⴰⴼⵉ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴰⴷⵔⵓⵙⵜ ⵏ ⴽⵓ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵜⴰⵡⵜⵎⴰⵢⵜ ⵓⵔ ⵉⴳⵉⵏ ⵜⵍⵍⴰⵍⵜ # >>> minSubArraySum.call([2, 3, 4, 1, 2, 4])\n# 1\n# >>> minSubArraySum.call([-1, -2, -3])\n# -6\ndef minSubArraySum(nums)\n","canonical_solution":"def minSubArraySum(nums)\n  min_sum = nums[0]\n  current_sum = 0\n  nums.each do |num|\n    if current_sum > 0\n      current_sum = num\n    else\n      current_sum += num\n    end\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2, 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14, candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6, candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100, -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10, candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1, candidate.call([1, -1]))\n  end\nend\n"},{"task_id":"HumanEval_115","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ 1:ⴰⴾⵜⴰⴱ ⵏ ⵉⵎⵎⵉⴾ ⵓⴰ ⵙ ⵉⵋⵋⴰ ⴰⵓⵢⵏ ⴰⴷⴷⵓⴱⴰⵜ ⵏⵢⵜ ⴰⴷ ⵉⴾⴼ-ⴰ ⵉⵂⴰⵔⴰⵏⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⵆⴰⴷⴰⵎ ⵏ ⴱⵓⴾⵢⵜ ⵜⴰⵏ ⵉ ⴰⵙⵉⵓⴰⴷ ⵏ ⵉⵋⵉⵜⴰⵏⴷ ⵉⵛⵛⵉⴾⵉⵍⴰⵏ ⴼⵓⴾ ⵉⵍⴰⵏⴰⵏ ⵜⴰⵣⵓⵏⵜ ⵉⵉⵉⴰⵜⴾⴻⵍ ⵜⴰⵂⴰⵏⵉⵏⵜ ⵉⵍⴰ ⴱⵓⴾⴻⵜ ⵉⵋⵋⴰⵏ ⵉⵋⵋⵉ ⵏ ⴰⵎⴰⵏ ⴷⴰⵗ ⴻⴷⴰⴶ ⵓⴻⵏⴷ ⴽⵓ 1 ⴳ ⵜⴰⴳⵔⵡⵜ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⵢⵎⵓⵏⵜ ⵏ ⵡⴰⵎⴰⵏ.ⴰⵜⵓⴰⵗⵔⴰⴱⴰⵏ ⵙⴰⴾⴰⵍ ⵏⵓⴾⴰⵉⴰⵏ ⵏⵓⴾⴰⵉⴰⵏ. ⵔⵉⴾⵓⴾ ⵢⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⵏ ⵉⵉⵉⴰⵏ# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n","canonical_solution":"def max_fill(grid, capacity)\n  total_water_units = grid.flatten.sum\n  (total_water_units.to_f \/ capacity).ceil\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0, candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1], [1, 1, 1, 1]], 9))\n  end\nend\n"},{"task_id":"HumanEval_116","nl":"taq_Tfng","pl":"rb","prompt":"ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔ ⵣⵓⵏⴷ ⴰⵢⴰ: ⵉ ⵡⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵢⴰⵖⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙⵙⵓⴷⵙ ⵅⴼ ⵡⴰⵜⵉⴳ ⴰⵎⵔⴰⵡ.ⵓⵟⵟⵓⵏ ⵏ ⵉⵎⵉⴹⵏ ⴳ ⵓⵙⵎⴷⵢⴰ ⵏⵏⵙⵏ ⴰⵎⵉⵏⴰⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵓⵇⵕⴰⵏ.ⴳ ⴽⴰⵜⴰ ⴰⴷ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⵙⵓⴷⵙⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵏ ⵖⴼ # >>> sort_array.call([1, 5, 2, 3, 4])\n# [1, 2, 3, 4, 5]\n# >>> sort_array.call([-2, -3, -4, -5, -6])\n# [-6, -5, -4, -3, -2]\n# >>> sort_array.call([1, 0, 2, 3, 4])\n# [0, 1, 2, 3, 4]\ndef sort_array(arr)\n","canonical_solution":"def sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1, 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3, -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32, 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"},{"task_id":"HumanEval_117","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵜⴰⵍⵖⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴽⴷ ⵉⵙ ⴳⴰⵏ ⵉⵣⵔⵉⴳⵏ ⵏ ⵓⵙⴽⵛⵎ ⵖⴰⵙ ⵉⵙⴽⴽⵉⵍⵏ ⴷ ⵉⵎⵣⴰⵔⴰⵢⵏ.ⵎⴽ ⵜⴳⴰ ⵜⵉⵙⵉⴹⴼⵜ s ⵜⵍⵍⵉⵜ, ⵇⴰⴷ ⵜⵕⵓⵡⵉ ⵜⴰⵡⵓⵔⵉ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵍⵍⵉⵜ.n ⵉⵎⵙⴰⵙⴰⵏ, ⵙ ⵓⵍⵖⴰ ⵏⵏⴰ ⴳ ⵜⵜⵉⵍⵉⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴷ ⴳ ⵜⵣⵍⵉⵜ s. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵙⴽⴰⵔⵏ ⴰⵙⵖⵍ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ ⵙⴳ ⵜⵉⴼⵉⵏⴰⵖ s ⵏⵏⴰ ⴳ ⵉⵍⵍⴰ ⴳ ⵜⵉⴽⴽⵉ ⵏ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ s ⴷ ⵢⴰⵏ ⵓⵟⵟⵓⵏ ⴰⴳⴰⵎⴰⵏ n, ⵜⵜⵓⵣⵔⴰⴽ ⴰⴷ ⵜⵙⵙⴽⵔ # >>> select_words.call(\"Mary had a little lamb\", 4)\n# [\"little\"]\n# >>> select_words.call(\"Mary had a little lamb\", 3)\n# [\"Mary\", \"lamb\"]\n# >>> select_words.call(\"simple white space\", 2)\n# []\n# >>> select_words.call(\"Hello world\", 4)\n# [\"world\"]\n# >>> select_words.call(\"Uncle sam\", 3)\n# [\"Uncle\"]\ndef select_words(s, n)\n","canonical_solution":"def select_words(s, n)\n  vowels = \"aeiouAEIOU\"\n  words = s.split\n  words.select do |word|\n    consonant_count = word.chars.count { |char| !vowels.include?(char) }\n    consonant_count == n\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([], candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"a b c d e f\", 1))\n  end\nend\n"},{"task_id":"HumanEval_118","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵎⴰⵙ ⴷ ⵜⴰⴳⵓⵔⵉ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵖⴰⵙ ⵜⵍⴰ ⵜⴰⴱⵔⵉⴷⵜ ⵜⴰⵏⴳⵍⵉⵣⵜ.ⴹⴼⵔ ⵉ ⴽⵓ ⴰⵖⵔⵉⵎ ⵏⵏⴰ ⵉⵔⵡⴰⵏ ⵙ ⵡⴰⴷⴷⴰⴷ ⵏ ⴰⴼⵍⵍⴰ.ⵓⵔ ⴷⴰ ⵜⵜⵓⵙⵉⴹⵏ ⵉⵎⵙⵍⵉ ⴳ ⵜⵉⵣⵡⵉⵔⵉ ⴷ ⵜⴳⵉⵔⴰ. ⵔⴰⵏⵜⵔ ⵜⴰⵣⵍⵉⵜ ⵜⴰⵅⵍⴰⴼⵜ ⵎⴽ ⵓⵔ ⵜⵍⵍⵉ ⵙⵉⵏ ⵉⵎⵙⴰⵙⴰⵏ ⵙⴳ ⵜⵙⴳⴰ ⵏ ⵡⴰⵡⴰⵍ (ⴰⵙⵙⵏ ⵜⴱⵔⵉⴷⵜ).ⴷⴰ ⵜⵜⵓⴳⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉ. ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⴰⴼⴷ ⵓⴱⵓⵅⵉⵍ ⵏⵏⴰ ⵢⵓⴳⵔⵏ ⴳⵔ # >>> get_closest_vowel.call(\"yogurt\")\n# \"u\"\n# >>> get_closest_vowel.call(\"FULL\")\n# \"U\"\n# >>> get_closest_vowel.call(\"quick\")\n# \"\"\n# >>> get_closest_vowel.call(\"ab\")\n# \"\"\ndef get_closest_vowel(word)\n","canonical_solution":"def get_closest_vowel(word)\n  vowels = \"aeiouAEIOU\"\n  (1...word.length - 1).reverse_each do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) && !vowels.include?(word[i + 1])\n      return word[i]\n    end\n  end\n  return \"\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\", candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"Above\"))\n  end\nend\n"},{"task_id":"HumanEval_119","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⵉⵜⵓⵔⵏ \"ⵉⵀ\" ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴱⵔⵉⴷ ⵉ ⵓⵙⴽⴰⵔ ⵏ ⵢⴰⵏ ⵓⵙⵉⴹⵏ ⵉⵖⵓⴷⴰⵏ, ⴷ ⵔⵉⵜⵓⵔⵏ \"ⵓⵅⴰ\" ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⴷⴷⴰⴷ.\" ((()) \" ⵓⵔ ⵉⴳⵉ.ⴳⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ. ⵙ ⵓⵎⴷⵢⴰ: ⵜⵉⴼⵉⵏⴰⵖ \"(((() \" ⵜⴳⴰ ⵉⵖⵓⴷⴰⵏ, ⵎⴰⵛⴰ ⵜⵉⴼⵉⵏⴰⵖ ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵢⴰⵏ ⵓⵙⵏⴼⵍⵓⵍ S ⵙ ⵉⵙ ⵉⴳⴰ ⵉⵖⵓⴷⴰⵏ ⵉⴳ ⴷ ⵖⴰⵙ ⵉⴳ ⵎⴰⵕⵕⴰ ⵉⴽⵕⵕⴰⵥⵏ ⴳ S ⴽⵔⴰ ⵏ ⵓⴽⵓⴷ, ⵎⴰⵙⴷ ⵜⵉⴼⵔⴽⵜ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⵔⴰⴷ ⵜⴳ ⵉⵖⵓⴷⴰⵏ.ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⴷ ⴰⵙ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵉⴾⵉⵉ ⵙⴰⵏⴰⵜⴰⵜⴰⵜ ⵜⵉⵣⵓⵏⴰⵓⴻⵏ ⴷⴰⵗⴷⴰⵢ ⴷⴰ ⵜⵜⵓⵣⵎⵎⴻⵎⵏ ⵉⴹⵕⵉⵚⵏ \" (() \" ⵏⵖⴷ ⵉⴹⵕⵉⵚⵏ ⵏ ⵜⴳⵏⵓⵜ \") \".ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ, ⵙⵏⴰⵜ ⵜⵣⵍⵖⴰ ⴷⴰⵔⵙⵏⵜ ⵜⵉⴼⵔⴽⵉⵏ.# >>> match_parens.call([\"()(\", \")\"])\n# \"Yes\"\n# >>> match_parens.call([\")\", \")\"])\n# \"No\"\ndef match_parens(lst)\n","canonical_solution":"def match_parens(lst)\n  a, b = lst\n\n  # Define a helper method to check if a string is balanced\n  def balanced?(s)\n    count = 0\n    s.each_char do |c|\n      count += 1 if c == '('\n      count -= 1 if c == ')'\n      return false if count < 0\n    end\n    count == 0\n  end\n\n  # Check if either concatenation forms a good string\n  if balanced?(a + b) || balanced?(b + a)\n    \"Yes\"\n  else\n    \"No\"\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_match_parens\n    candidate = method(:match_parens)\n    assert_equal(\"Yes\", candidate.call([\"()(\", \")\"]))\n    assert_equal(\"No\", candidate.call([\")\", \")\"]))\n    assert_equal(\"No\", candidate.call([\"(()(())\", \"())())\"]))\n    assert_equal(\"Yes\", candidate.call([\")())\", \"(()()(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(())))\", \"(()())((\"]))\n    assert_equal(\"No\", candidate.call([\"()\", \"())\"]))\n    assert_equal(\"Yes\", candidate.call([\"(()(\", \"()))()\"]))\n    assert_equal(\"No\", candidate.call([\"((((\", \"((())\"]))\n    assert_equal(\"No\", candidate.call([\")(()\", \"(()(\"]))\n    assert_equal(\"No\", candidate.call([\")(\", \")(\"]))\n    assert_equal(\"Yes\", candidate.call([\"(\", \")\"]))\n    assert_equal(\"Yes\", candidate.call([\")\", \"(\"]))\n  end\nend\n"},{"task_id":"HumanEval_120","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ 1:ⵏ ⵜⵉⵖⵣⵉ k ⴷ ⵡⵓⵟⵟⵓⵏ k ⴳ arr. ⵎⴽ ⴷⴰ ⵏⴽⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ arr ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵢⴰⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ k, ⵏⵙⵙⴽⵍ ⴰⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ # >>> maximum.call([-3, -4, 5], 3)\n# [-4, -3, 5]\n# Example 2:\n# >>> maximum.call([4, -4, 4], 2)\n# [4, 4]\n# Example 3:\n# >>> maximum.call([-3, 2, 1, 2, -1, -2, 1], 1)\n# [2]\n# Note:\n# 1. The length of the array will be in the range of [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n","canonical_solution":"def maximum(arr, k)\n  arr.sort.last(k).sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3, -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2], candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123, -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123, 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5, 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2, 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n    assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10], candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23, 243, -400, 0], 0))\n  end\nend\n"},{"task_id":"HumanEval_121","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵎⴽ ⴷⴰ ⵏⵜⵜⴰⴼ ⵢⴰⵏ ⵓⵙⵔⴷⴰⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵅⴷⴷⴰⵎⵏ, ⵏⵙⵙⴽⵜⵉ ⵙ ⵓⵖⵣⵓⵔⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⴳ ⵡⴰⵏⵙⴰ ⵉⵎⵣⴰⵔⴰⵢⵏ. # >>> solution.call([5, 8, 7, 1])\n# 12\n# >>> solution.call([3, 3, 3, 3, 3])\n# 9\n# >>> solution.call([30, 13, 24, 321])\n# 0\ndef solution(lst)\n","canonical_solution":"def solution(lst)\n  lst.each_with_index.reduce(0) do |sum, (val, idx)|\n    (idx.even? && val.odd?) ? sum + val : sum\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7, 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0, candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30, 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"},{"task_id":"HumanEval_122","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⴰⵎⵎⴰⴳ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵙⵏⴰⵜ ⵜⴽⵕⴹⵉⵡⵉⵏ ⴳ ⵓⴳⴳⴰⵔ ⵙⴳ ⴽ ⴽⵕⴰⴹ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵎⵣⵡⵓⵔⴰ ⵏ arr.ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵓⵙⵔⵙⵉ ⵓⵔ ⵉⴳⵉⵏ ⵓⵎⵏⵉⴳ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ arr ⴷ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ k,  return# >>> add_elements.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n# 24\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\ndef add_elements(arr, k)\n","canonical_solution":"def add_elements(arr, k)\n  arr.first(k).select { |num| num.abs.to_s.length <= 2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1, -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111, 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90, 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"},{"task_id":"HumanEval_123","nl":"taq_Tfng","pl":"rb","prompt":"get_odd_collatz(5) ⴷⴰ ⵉⵜⵜⵔⴰⵔ [1, 5] # ⵜⴰⵍⵖⴰ ⵏ ⴽⵓⵍⵍⴰⵜⵣ ⵉ 5 ⵜⴳⴰ [5, 16, 8, 4, 2, 1], ⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵉⵎⴹⴰⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵅⴰⵙ 1, ⴷ 5. ⵙ ⵓⵎⴷⵢⴰ: 2. ⵜⴰⵔⵔⴰⵢⵜ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵔⵏⵉⵡ.1. ⴽⵓⵍⵍⴰⵜⵣ ((1) ⵉⴳⴰ [1].ⴰⵜⵡⵉⵍ: ⴷⴰ ⵉⵜⵜⵉⵏⵉ ⵓⵙⵏⵓⵎⵎⵓ ⵎⴰⵙ ⴷ ⵡⴰⵜⵉⴳ ⴰⴽⴽⵡ ⵏ n, ⵔⴰⴷ ⵜⵍⴽⵎ ⵜⵉⴼⵔⴽⵜ ⴰⵀⴰ 1.ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ ⵜⴰⴳⴳⴰⵢⵜ, ⵜⴳⵓⵔⵉ ⵜⴰⴹⴼⴰⵕⵜ ⵔⴰⴷ ⵜⴳ 3 ⵏ ⵜⵉⴽⴽⴰⵍ ⵏ ⵜⴳⵓⵔⵉ ⵉⵣⵔⵉⵏ.ⵜⵉⴼⵔⵉⵜ ⵉⵣⵔⵉⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵉⴳ ⵉⴳⴰ ⵜⵉⴼⵔⵉⵜ ⵉⵣⵔⵉⵏ ⵉⵎⵣⴷⴰⵢⵏ, ⵜⵉⴼⵔⵉⵜ ⵜⴰⴹⴼⴰⵕⵜ ⵜⴳⴰ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵙ ⵓⵎⴽ ⴰⴷ: ⵙⵙⵏⵜⵉ ⵙ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ n. ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ, ⴷⴰ ⵜⵜⵓⵢⴰⴽⴽⴰ ⴽⵓ ⵜⴰⵙⴳⵓⵔⵉ ⵙⴳ ⵜⴰⴳⵏⵉⵜ ⵏ ⴽⵓⵍⵍⴰⵣ ⵜⴳⴰ ⵜⴰⴳⵏⵉⵜ ⴳ ⵜⵓⵙⵏⴰⴽⵜ ⵏⵏⴰ ⵉⵥⵍⵉⵏ ⵙ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵉⵜⵜⵓⵙⵏⵎⵍⵏ ⴳ ⵓⵙⴰⵜⵉ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵙⴽⵛⵎ ⴰⵙⵖⵍ ⵏ ⵓⵙⵎⵙⴰⵙⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⴳ ⵓⵙⵓⵔⵙ ⵏ ⴽⵓⵍⴰⵜⵣ. # >>> get_odd_collatz.call(5)\n# [1, 5]\ndef get_odd_collatz(n)\n","canonical_solution":"def get_odd_collatz(n)\n  collatz_sequence = []\n  while n != 1\n    collatz_sequence << n if n.odd?\n    if n.even?\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n  end\n  collatz_sequence << 1 if n == 1\n\n  collatz_sequence.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_odd_collatz\n    candidate = method(:get_odd_collatz)\n    assert_equal([1, 5, 7, 11, 13, 17], candidate.call(14))\n    assert_equal([1, 5], candidate.call(5))\n    assert_equal([1, 3, 5], candidate.call(12))\n    assert_equal([1], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_124","nl":"taq_Tfng","pl":"rb","prompt":"4. ⴷⴰⵜⵢ ⵜ ⵉⵋⵋⴰ ⴷⴰⵗ ⴼⵓⵔⵎⴰⵜⵉ: ⵎⵎ-ⴷⴷ-ⵢⵢⵢⵢⵢⵉ3. ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⴳ ⵡⴰⵢⵢⵓⵔⵏ ⴷⴷⵔⵓⵙⵏ ⵙⴳ 1 ⵏⵖ ⵓⴳⴳⴰⵔ ⵏ 12.2. ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 31 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵢⵢⵎ ⵓⴰⵏ 1,3,5,7,8,10,12 ⴷ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 30 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵎ ⵓⴰⵏ 4,6,9,11 ⴷ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵏ ⴰⵍⵓⴰⵈ ⵓⴰⵔ ⵉⴷⴷⵉⴾⵓⴷ ⵓⴰ ⵢⴷⵢⵙ ⵎⵢⵗ ⵓⵋⵋⴰⵔⴰⵏ 29 ⵏ ⴰⵍⵓⴰⵈ ⵉ ⴰⵛⵂⵢⵎ ⵓⴰⵏ 21. ⵜⴰⵣⵓⵏⵜ ⵏ ⵡⴰⵙⵙ ⵓⵔ ⵜⴳⵉ ⵜⵍⵍⴰⵍⵜ.ⴷⴰⵜⴰ ⵜ ⴰⵈⵈⴰⵍ ⴰ ⵓⴰⵔ ⵏ ⵉⵍⴰ ⴰⵍⵆⵉⴷⵎⴰⵜ ⴰ ⴼⴰⵍ ⵉⵍⴾⴰⵎⴰⵏ ⴼⵓⴾ ⵏⴰⵙⴰⵏ:ⴷⴰ ⵉⵜⵜⴰⴽⴽⴰ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⴰⵙⵙ ⴰⵣⵔⴼⴰⵏ ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵜ. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵉⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙⵏ ⵜⵉⴼⵔⴽⵜ ⵏ ⵡⴰⵙⵙ ⴷ # >>> valid_date.call(\"03-11-2000\")\n# true\n# >>> valid_date.call(\"15-01-2012\")\n# false\n# >>> valid_date.call(\"04-0-2040\")\n# false\n# >>> valid_date.call(\"06-04-2020\")\n# true\n# >>> valid_date.call(\"06\/04\/2020\")\n# false\ndef valid_date(date)\n","canonical_solution":"def valid_date(date)\n  return false if date.nil? || date.empty?\n  \n  # Check if the date format is correct\n  match = date.match(\/^(\\d{2})-(\\d{2})-(\\d{4})$\/)\n  return false unless match\n  \n  month, day, year = match.captures.map(&:to_i)\n  \n  # Check if month is valid\n  return false if month < 1 || month > 12\n  \n  # Check if day is valid according to the month\n  case month\n  when 1, 3, 5, 7, 8, 10, 12\n    return day >= 1 && day <= 31\n  when 4, 6, 9, 11\n    return day >= 1 && day <= 30\n  when 2\n    return day >= 1 && day <= 29\n  else\n    return false\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_valid_date\n    candidate = method(:valid_date)\n    assert_equal(true, candidate.call(\"03-11-2000\"))\n    assert_equal(false, candidate.call(\"15-01-2012\"))\n    assert_equal(false, candidate.call(\"04-0-2040\"))\n    assert_equal(true, candidate.call(\"06-04-2020\"))\n    assert_equal(true, candidate.call(\"01-01-2007\"))\n    assert_equal(false, candidate.call(\"03-32-2011\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"04-31-3000\"))\n    assert_equal(true, candidate.call(\"06-06-2005\"))\n    assert_equal(false, candidate.call(\"21-31-2000\"))\n    assert_equal(true, candidate.call(\"04-12-2003\"))\n    assert_equal(false, candidate.call(\"04122003\"))\n    assert_equal(false, candidate.call(\"20030412\"))\n    assert_equal(false, candidate.call(\"2003-04\"))\n    assert_equal(false, candidate.call(\"2003-04-12\"))\n    assert_equal(false, candidate.call(\"04-2003\"))\n  end\nend\n"},{"task_id":"HumanEval_125","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⴰⵍⵍⴰⵙ, ord{\"a\") = 0, ord{\"b\") = 1, ... ord{\"z\") = 25 ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵜⵓⴱⴹⵓ ⵅⴼ ⵜⵉⴼⵉⵏⴰⵖ ',' ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵜⵉⴼⵉⵏⴰⵖ  ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⴰⵔⵉⴹ ⵓⵟⵟⵓⵏ ⵏ ⵡⴰⵔⵔⴰⵜⵏ ⵉⵎⵥⵥⵢⴰⵏⵏ ⵙ ⵓⵙⵙⵓⴷⵙ ⴰⵎⵢⴰⵏⴰⵡ ⴳ ⵎⴽ ⵜⵍⵍⴰ ⵢⴰⵜ ⵜⵉⴼⵔⵜ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ, ⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵙ ⵜⴱⴹⴰⵢⵜ ⵅⴼ ⵡⴰⵢⴷⴰ, ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⵡⴰⵢⴷⴰ ⴳ ⵓⴹⵕⵉⵚ ⵏⵏⴰ ⵜⵔⴰ # >>> split_words.call(\"Hello world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"Hello,world!\")\n# [\"Hello\", \"world!\"]\n# >>> split_words.call(\"abcdef\")\n# 3\ndef split_words(txt)\n","canonical_solution":"def split_words(txt)\n  if txt.include?(' ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n    odd_count = txt.chars.count { |char| ('a'..'z').include?(char) && (char.ord - 'a'.ord).odd? }\n    return odd_count\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2, candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n    assert_equal(0, candidate.call(\"\"))\n  end\nend\n"},{"task_id":"HumanEval_126","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏnumber, return false. ⵓⵔ ⴷⴰ ⵏⵜⵜⴰⴼⴰ ⵉⵎⴹⴰⵏ ⵉⵔⵉⵏⵉⵏ ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⴳ ⵓⵍⵓⴳ ⵏ ⵓⴽⵛⵛⵓⵎ. ⵉⵖ ⴷⴰⵔ ⵓⵎⵙⴳⵏⴰⴼ ⵓⴳⴳⴰⵔ ⵏ ⵢⴰⵏ ⵓⵎⵙⴽⴰⵔ ⵏ ⵢⴰⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵎⴽ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ, ⴰⵔ ⵜⵔⴰⵔⴷ ⵉⵙ ⵜⵜⵓⵙⵎⵉⵍⵏ ⵏⵖ ⵓⵔ ⵜⵜⵓⵙⵎⵉⵍⵏ.# >>> is_sorted.call([5])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5])\n# false\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6])\n# true\n# >>> is_sorted.call([1, 2, 3, 4, 5, 6, 7])\n# true\n# >>> is_sorted.call([1, 3, 2, 4, 5, 6, 7])\n# false\n# >>> is_sorted.call([1, 2, 2, 3, 3, 4])\n# true\n# >>> is_sorted.call([1, 2, 2, 2, 3, 4])\n# false\ndef is_sorted(lst)\n","canonical_solution":"def is_sorted(lst)\n  lst.each_cons(2).with_index do |(a, b), index|\n    return false if a > b\n    return false if index < lst.length - 2 && a == b && lst[index + 2] == b\n  end\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_sorted\n    candidate = method(:is_sorted)\n    assert_equal(true, candidate.call([5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6]))\n    assert_equal(true, candidate.call([1, 2, 3, 4, 5, 6, 7]))\n    assert_equal(false, candidate.call([1, 3, 2, 4, 5, 6, 7]))\n    assert_equal(true, candidate.call([]))\n    assert_equal(true, candidate.call([1]))\n    assert_equal(false, candidate.call([3, 2, 1]))\n    assert_equal(false, candidate.call([1, 2, 2, 2, 3, 4]))\n    assert_equal(false, candidate.call([1, 2, 3, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 2, 3, 3, 4]))\n    assert_equal(true, candidate.call([1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_127","nl":"taq_Tfng","pl":"rb","prompt":"[ⵉⵏⴱⵓⵜ\/ⵓⵓⵜⴱⵓⵜ] ⵙⵜⵓⵎⴱⵍⵙ: ⵎⴽ ⵓⵔ ⴷⴰ ⵜⵜⵎⴳⴰⵍⵏⵜ ⵙⵏⴰⵜ ⵜⵣⵎⵎⴰⵔ, ⵙⵓⵍⵏ \"ⵓⵀⵓ\".ⵎⴽ ⵓⵔ ⵉⴳⵉ, ⵔⵔⵓⵜⵓⵔ \"ⵓⵀⵓ\".ⵎⴽ ⵉⴳⴰ ⵓⵖⵣⵉ ⵏ ⵓⵙⵎⴽⵍ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵣⵡⴰⵔⵓ, ⵙⵙⴽⵛⵎ \"YES\", ⴷ ⴰⵖⵣⵉ ⵏⵏⵙ ⵉⴳⴰⵜ 1, ⴷ ⵓⵔ ⵉⴳⵉ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ.ⴰⵎⴷⵢⴰ, ⴰⵙⵎⵓⵜⵜⴳ ⵏ ⵉⵎⵣⴰⵣⴰⵍ (1, 3), (2, 4) ⵉⴳⴰ (2, 3) ⵉⵙⵎ ⵏ ⵉⵏⴱⵉⵔⴰⵍⵏ ⵉⴳⴰ ⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ.ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵜⴰⵢⴷ ⵎⴰⵢⴷ ⵉⴳⴰⵏ ⵜⵉⵖⵣⵉ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵙⵏⴰⵜ ⵉ ⴽⵓ ⴰⵣⵎⵣ, ⴷⴰ ⵉⵜⵜⵓⵙⵎⵔⴰⵙ ⵉⵙ ⵉⴳⴰ ⵍⴱⴷⵓ ⵏⵏⵙ ⵉⵎⵥⵥⵉⵢⵏ ⵏⵖⴷ ⵉⵎⴽⵉⵏⵏⴰ ⴷ ⵜⴳⵉⵔⴰ ⵏⵏⵙ.ⵢⵂⴰⵉ ⵜⵉⵣⴰⵔⴰⵜ ⴷ ⴰⵎⵉⵏⴷⵉⴷⴰ ⵜⵜⵓⵙⵎⵓⵏⴰⵏ ⵡⴰⵏⵙⵉⵡⵏ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ, ⵎⴰⵢⴰⴷ ⵉⴳⴰⵏ ⵡⴰⵏⵙⵉⵡⵏ (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ) ⴳ ⵉⴳⴰⵏ ⴽⵓ ⵓⵣⵎⵣ ⵢⴰⵏ ⵓⵣⴳⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙ ⵓⵎⴷⵢⴰ, ⴰⵣⵎⵣ = (ⵜⴱⴷⴰⴷⵜ, ⵜⴳⵉⵔⴰ) = (1, 2).ⴾⵢⵍ ⴰⴾⴰⵍ ⵉⵍⴰⵏ ⵜⵉ ⵉⵙⵙⵉⵏ ⵉⴾⴰⵏⵏⴰⵏ,# >>> intersection.call([1, 2], [2, 3])\n# \"NO\"\n# >>> intersection.call([-1, 1], [0, 4])\n# \"NO\"\n# >>> intersection.call([-3, -1], [-5, 5])\n# \"YES\"\ndef intersection(interval1, interval2)\n","canonical_solution":"def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n\n  if intersection_start > intersection_end\n    return \"NO\"\n  end\n\n  intersection_length = intersection_end - intersection_start + 1\n\n  return \"YES\" if prime?(intersection_length)\n\n  \"NO\"\nend\n\ndef prime?(n)\n  return false if n <= 1\n  return true if n == 2 || n == 3\n\n  (2..Math.sqrt(n).to_i).each do |i|\n    return false if n % i == 0\n  end\n\n  true\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1, 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2, 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\", candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2, -2], [-3, -2]))\n  end\nend\n"},{"task_id":"HumanEval_128","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: Note: return nil for empty arr.  ⴰⴱⵔⵉⴷ ⵏ ⵓⵙⵎⵓⵜⵜⴳ ⵏ ⵡⴰⵏⵙⴰⵏ ⴽⵓ ⵓⵟⵟⵓⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ, ⵉⵜⵜⵓⵙⵎⴷⵢⴰ ⵙ 1, -1 ⵏⵖⴷ 0. ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵉⵙⵎⴽⵜⵉⵜⵉⵏ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵙ ⵜⵢⴰⴼⵓⵜ ⵏ ⵉⵙⵎⴰⵡⵏ ⴰⴽⴽⵡ ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵇⵇⴰⵏ ⴰⴷ ⵜⵔⴰⵔ # >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n# >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n","canonical_solution":"def prod_signs(arr)\n  return nil if arr.empty?\n  \n  product_signs = arr.reduce(1) { |prod, num| prod * num <=> 0 }\n  sum_magnitudes = arr.map(&:abs).sum\n  \n  product_signs * sum_magnitudes\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n"},{"task_id":"HumanEval_129","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵉⵜⵜⵓⵙⵓⴷⵙⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵙ ⵉⵣⵣⵔⵉ ⵓⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ. ⴾⴰⵍⴰ ⵉⵋⵋⴰ ⴰⵓⵢⵏ, ⴰⵍⵓⴰⵣⴰⴱ ⵓⴰⵔ ⵢⵈⵈⵢⵍ ⵓⴰ ⵢⵣⵣⴰⵔⴰⵏlst_A[j] = lst_B[j] ⵣⵓⵏⴷ lst_A[i] < lst_B[i] ⴷ ⴽⵓ j (1 <= j < i) ⵖⵓⵔⵖ ⵙⴳ lst_B, ⵙ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵢⴰⴹⵏ, ⵉⵍⵍⴰ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ i (1 <= i <= k) ⵙⴳ (ⴰⴷ ⵏⵙⵎⵎⴰ ⵜⵏ lst_A ⴷ lst_B), lst_A ⴷ ⵡⵉⵏ ⵍⴰⴽⵙⵉⴽⵓⵊⵔⴰⴼⵉ ⴷⴼⴼⵉⵔ ⵎⴰⴷ ⵜⵜⵓⵙⴽⴰⵔⵏⵜ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵏ ⵡⴰⵜⵉⴳⵏ ⵉⴹⴼⴰⵕⵏ ⵉ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⵔⴰⴷ ⵙⴽⵔⵏ A ⴷ Bⴷⴰ ⵉⵜⵜⵓⵙⵡⵉⵏⴳⵎ ⵓⴱⵔⵉⴷ A (ⵙ ⵜⵉⵖⵣⵉ k) ⴷⵔⵓⵙⵏ ⵓⴱⵔⵉⴷ B (ⵙ ⵜⵉⵖⵣⵉ k) ⵎⴽ ⵓⴰⵔ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⴰⴾⵉⵛⵉⴷ ⴷⴰⵗ ⴶⵔⵉⴷⴰⵍⴰⵗⵉ ⵏ ⴰⵍⴰⵗⵉⴰⵜⵓⴰⵣⴰⵉ ⴰⵙ ⴰⴱⴰⵔⴰ ⵓⴰⵏ ⵜⵉⵛⵉⵋⵔⵉⵜ ⵏ k ⴰⵎⵓⵙ ⴰⵙⵉⴾⵉ ⵏ ⵛⵢⵍⵍ ⵜⴰⵏ ⵓⵉⵏ k (ⵓⴰⵔ ⵏ ⴰⵈⵈⵢⵍ ⵜⴰⴱⵍⵉⵜ. ⵙ ⵜⴳⵓⵔⵉ ⵢⴰⴹⵏ, ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵣⵔⵉⴷ ⵙ ⵜⵖⵔⴰⵙⵉⵏ ⵏⵏⴰ ⴷⴰⵔ ⵜⴰⴳⵓⵜ ⵏ ⵓⵥⴰⵡⴰⵏ ⵙⴳ ⴽⴰ ⵉⴳⴰⵜ ⵜⴰⵖⵔⴰⵙⵜ, ⴷ ⴳ ⴽⵓ ⵜⴰⵙⵓⵔⵉⴼⵜ ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵓⵜⵍⵜ ⵖⵔ ⴽⴰ ⵉⴳⴰⵜ ⵜⴰⵖⵔⴰⵙⵜ ⵜⴰⴷⴷⴰⵔⵜ ⵜⵓⵎⵍⵉⵍⵜ, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵏⴰⴼ ⴰⴱⵔⵉⴷ ⴰⵎⵥⵥⵢⴰⵏ ⵏ ⵜⵉⵖⵣⵉ k ⴳ ⵜⴽⵔⵔⴰⵢⵜ. ⵉⵖⵢ ⴰⴷ ⵏⴱⴷⵓ ⴷⴰ ⵉⵜⵜⵓⵢⴼⴼⵖ \"inclusive\" ⵢⴰⵜ ⵜⵉⴽⴽⵍⵜ ⴳ ⵜⵖⵔⴰⵙⵉⵏ ⵏ ⵜⵔⴰⴱⴱⵓⵜ.ⴽⵓ ⵜⴰⵖⵔⴰⵙⵜ ⵏ ⵜⴽⴰⵔⴹⴰ ⵜⵍⵍⴰ ⴳ ⵡⴰⵜⵉⴳ. ⴽⵓ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵙⵏⴼⵍ [1, N * N] ⴳ ⵜⴽⵔⵔⴰⵢⵜ ⵏ N ⵏ ⵜⵉⵙⵉⴹⴼⵉⵏ ⴷ N ⵏ ⵜⵔⵙⴰⵍ (N >= 2) ⴷ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ k, # >>> minPath.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n# [1, 2, 1]\n# >>> minPath.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n# [1]\ndef minPath(grid, k)\n","canonical_solution":"def minPath(grid, k)\n  n = grid.size\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  min_path = nil\n\n  n.times do |i|\n    n.times do |j|\n      queue = [[[i, j], [grid[i][j]]]]\n      until queue.empty?\n        position, path = queue.shift\n        if path.size == k\n          min_path = path if min_path.nil? || path < min_path\n          next\n        end\n        directions.each do |dx, dy|\n          x, y = position[0] + dx, position[1] + dy\n          if x.between?(0, n-1) && y.between?(0, n-1)\n            queue.push([[x, y], path + [grid[x][y]]])\n          end\n        end\n      end\n    end\n  end\n  min_path\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1, 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"},{"task_id":"HumanEval_130","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵉⵎⴹⴰⵏ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵛⵉ ⵏ n + 1 ⴰⵎⵣⵡⴰⵔⵓ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⴹ ⴰⵎⴷⴷⴰⴷ ⵓⵔ ⵉⴳⵉⵏ ⴰⵎⵏⴳⵓ n, ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵔⴰⵢⵜ ⵏ = 2 + 3 + 3= 8 tri(3) = tri(2) + tri(1) + tri(4) tri(4) = 3 tri(2) = 1 + (2 \/ 2) = 2 ⵙ ⵓⵎⴷⵢⴰ: tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ⵉⴳ n ⵓⵔ ⵉⴳⵉ ⴰⵎⵣⴰⵔⴰⵢ. tri{n} = 1 + n \/ 2, ⵉⴳ ⵉⴳⴰ n ⵉⵎⵣⴰⵔⴰⵢⵏ. tri(1) = 3 ⴷⴰ ⵜⵜⵓⵙⵏⵎⵍ ⵜⴹⴰ ⵏ ⵜⵔⵉⴱⵓⵏⴰⵛⵛⵉ ⵙ ⵓⵙⵏⴼⵍ: ⵎⴰⵛⴰ, ⵓⵔ ⵉⵙⵙⵉⵏ ⵎⵉⴷⴷⵏ ⵙ ⵓⴹⴼⵕ ⵏ ⵟⵔⵉⴱⵓⵏⴰⵛⵛⵉ.ⴷⴰ ⵉⵜⵜⵢⴰⵔⴰ ⴽⵓ ⵢⴰⵏ ⵙ ⵓⵙⵏⵙⵍ ⵏ ⴼⵉⴱⵓⵏⴰⵛⵛⵉ, ⴰⵔ ⵜⵜⵎⵔⴰⵔⴰⵏ ⵉⵎⵓⵙⵏⴰⵡⵏ ⵏ ⵜⵓⵙⵏⴰⴽⵜ ⴳ # >>> tri.call(3)\n# [1, 3, 2, 8]\ndef tri(n)\n","canonical_solution":"def tri(n)\n  sequence = [1, 3]\n  \n  (2..n).each do |i|\n    if i.even?\n      sequence[i] = 1 + i \/ 2\n    else\n      sequence[i] = sequence[i - 1] + sequence[i - 2] + sequence[i + 1] rescue 0\n    end\n  end\n  \n  sequence[0..n]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2, 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n    assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_131","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ 0 ⵎⴽ ⴳⴰⵏ ⴰⴽⴽⵡ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴳⵓⵏⵏ. ⴳ ⵓⵎⵉⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n, ⵙⵏⵓⵍⴼⵓ ⵜⴰⵢⴰⴼⵓⵜ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ. # >>> digits.call(1)\n# 1\n# >>> digits.call(4)\n# 0\n# >>> digits.call(235)\n# 15\ndef digits(n)\n","canonical_solution":"def digits(n)\n  odd_digits = n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }\n  return 0 if odd_digits.empty?\n  odd_digits.reduce(:*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5, candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5, candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625, candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"},{"task_id":"HumanEval_132","nl":"taq_Tfng","pl":"rb","prompt":"ⴳ ⵉⵍⵍⴰ ⵓⵙⵎⵓⵏ ⵏ ⴽⵔⴰ ⵏ ⵜⴽⵕⵕⵓⵎⵜ ⴳ ⵜⴹⴼⴼⵓⵕⵜ.ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵏ ⵜⵉⴷⵜ ⵎⴽ ⴷ ⵖⴰⵙ ⵎⴽ ⵉⵍⵍⴰ ⵢⴰⵏ ⵓⴹⴼⴼⵓⵕ ⵉⵣⵔⴼⴰⵏ ⵏ ⵜⴱⵕⴰⴽⴰⵜⵉⵏ ⵔⵥⵎ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⴰⵎⵎ ⵓⴽⵛⵛⵓⵎ ⵢⴰⵜ ⵜⵉⴼⵉⵏⴰⵖ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴱⵕⴰⴽⴰⵜⵉⵏ ⵜⵉⴽⵓⴷⴰⵕⵉⵏ.# >>> is_nested.call(\"[[]]\")\n# true\n# >>> is_nested.call(\"[]]]]]]][[[[[]\")\n# false\n# >>> is_nested.call(\"[][]\")\n# false\n# >>> is_nested.call(\"[]\")\n# false\n# >>> is_nested.call(\"[[][]]\")\n# true\n# >>> is_nested.call(\"[[]][[\")\n# true\ndef is_nested(string)\n","canonical_solution":"def is_nested(string)\n  stack = []\n  has_nested = false\n\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n    elsif char == ']'\n      if stack.empty?\n        return false\n      end\n      stack.pop\n      has_nested = true if stack.any?\n    end\n  end\n\n  has_nested\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false, candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n    assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"[]]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false, candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n    assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"[[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"))\n  end\nend\n"},{"task_id":"HumanEval_133","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴷⴰ ⵉⵜⵜⵉⵔⵉⵡ ⴽⵓ ⵉⴼⵔⴷⵉⵙ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵙ ⵓⴼⵍⵍⴰ ⵏ ⵡⴰⵜⵜⴰⵢⵏ ⵏ ⵡⴰⵎⵎⴰⵙⵏ ⵣⵡⴰⵔ.ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵓⴽⵓⴱⴰⵕ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵉⵜⵜⵓⴼⴽⴰⵏ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵏⵉⵡ ⵏ ⵡⵓⵟⵟⵓⵏ.# >>> lst.call([1.0, 2.0, 3.0])\n# 14\n# >>> lst.call([1.0, 4.0, 9.0])\n# 98\n# >>> lst.call([1.0, 3.0, 5.0, 7.0])\n# 84\n# >>> lst.call([1.4, 4.2, 0.0])\n# 29\n# >>> lst.call([-2.4, 1.0, 1.0])\n# 6\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map { |num| (num.ceil)**2 }.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84, candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4, 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230, candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0, 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086, candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0, 1.0, 0.0]))\n  end\nend\n"},{"task_id":"HumanEval_134","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵓⵉⵣⴶⴰⵔ: \"ⴰⵍⵎⴰⵗⵏⴰ\" ⵢⵈⴰⵍ ⵜⴰⵈⵈⵉⵎⵜ ⴰⵏ ⵎⴰⴶⵔⴰⴷ ⴰⵜⵉⵓⴰⵣⴰⵉⴰⵏ ⵙ ⵢⴷⴰⴶ.ⴰⵛⵔⵓⵜ ⵏ ⴰⵍⵎⴰⵗⵏⴰ ⴷ ⵓⴰⵔ ⵏ ⵓⵍⴰⵗ ⵋⵉⵔ ⴰⵓⵢⵏⵏ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵉⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴳⴰ ⵢⴰⵏ ⵓⵡⵔⵉⴽ ⵏ ⵜⵉⵔⵔⴰ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵓⵔ ⵉⴳⵉ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵊⵊⴰⵏ ⴰⴷ ⵜⴳ ⵜⵉⴷⵜ ⵎⴽ ⵉⴳⴰ ⵡⵓⵎⵓⵖ ⴰⵎⴳⴳⴰⵔⵓ # >>> check_if_last_char_is_a_letter.call(\"apple pie\")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e\")\n# true\n# >>> check_if_last_char_is_a_letter.call(\"apple pi e \")\n# false\n# >>> check_if_last_char_is_a_letter.call(\"\")\n# false\ndef check_if_last_char_is_a_letter(txt)\n","canonical_solution":"check_if_last_char_is_a_letter = ->(txt) {\n  return false if txt.strip.empty?\n  words = txt.strip.split(' ')\n  last_word = words.last\n  return false if last_word.empty?\n  last_char = last_word[-1]\n\n  last_char =~ \/[a-zA-Z]\/ && (words.size == 1 || txt[txt.rindex(last_char) - 1] == ' ')\n}","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false, candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false, candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false, candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple pi e \"))\n  end\nend\n"},{"task_id":"HumanEval_135","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⴰⵜⵉⴳⵏ ⵉⵎⵎⵓⵟⵟⵓⵏⵏ.ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵓⵏⴰⵡ ⴰⴷ, ⵔⴰⴷ ⵏⵔⴰⵔ -1ⵓⵔ ⵉⴳⵉ ⴰⵅⴰⵜⴰⵔ ⵏⵖⴷ ⵉⵎⴽⵏ ⵉ ⵓⵏⴰⵡ ⵏⵏⴰ ⴷ ⵢⵓⵛⴽⴰⵏ ⴷⴰⵜ ⵏⵏⵙ. ⵎⴽ ⵔⴰⵏⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵏⵎⴰⵜⴰⵔ ⴰⵅⴰⵜⴰⵔ ⵏ ⵢⴰⵏ ⵉⴼⵔⴷⵉⵙ ⵏⵏⴰ # >>> can_arrange.call([1, 2, 4, 3, 5])\n# 3\n# >>> can_arrange.call([1, 2, 3])\n# -1\ndef can_arrange(arr)\n","canonical_solution":"def can_arrange(arr)\n  (1...arr.length).reverse_each do |i|\n    return i if arr[i] < arr[i - 1]\n  end\n  -1\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_can_arrange\n    candidate = method(:can_arrange)\n    assert_equal(3, candidate.call([1, 2, 4, 3, 5]))\n    assert_equal(-1, candidate.call([1, 2, 4, 5]))\n    assert_equal(2, candidate.call([1, 4, 2, 5, 6, 7, 8, 9, 10]))\n    assert_equal(4, candidate.call([4, 8, 5, 7, 3]))\n    assert_equal(-1, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_136","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴽⵔⴰ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵏⵖⴷ ⵉⵎⵏⴳⵉⵏⵏ, ⵙⵙⴽⵛⵎ-ⵜ ⵙ nil. ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴳ ⵓⵎⵙⴳⴷⴰⵍ.ⴰⵎⵉⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳⴳⵓⵜⵏ ⴳ ⵓⵎⵏⵣⴰⵢ, ⴷ \"ⴱ\" ⵉⴳⴰ ⴰⵎⵉⴹⴰⵏ ⴰⵎⵥⵥⵢⴰⵏ ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⴽⴽⴰⵏ ⴰⵙⵔⴷⴰⵙ (ⴰ,ⴱ), ⴳ ⵉⵍⵍⴰ 'ⴰ' # >>> largest_smallest_integers.call([2, 4, 1, 3, 5, 7])\n# [nil, 1]\n# >>> largest_smallest_integers.call([])\n# [nil, nil]\n# >>> largest_smallest_integers.call([0])\n# [nil, nil]\ndef largest_smallest_integers(lst)\n","canonical_solution":"def largest_smallest_integers(lst)\n  largest_negative = nil\n  smallest_positive = nil\n  \n  lst.each do |num|\n    if num < 0\n      largest_negative = num if largest_negative.nil? || num > largest_negative\n    elsif num > 0\n      smallest_positive = num if smallest_positive.nil? || num < smallest_positive\n    end\n  end\n  \n  [largest_negative, smallest_positive]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2, 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5, 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil, nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100, 1]))\n  end\nend\n"},{"task_id":"HumanEval_137","nl":"taq_Tfng","pl":"rb","prompt":"ⵜⴰⵍⵖⴰ: ⵎⴽ ⵉⵜⵜⵓⵙⵎⴷⵢⴰ ⵓⵟⵟⵓⵏ ⵏ ⵜⵉⴷⵜ ⵙ ⵜⴰⵍⵖⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵉⵖⵢ ⴰⴷ ⵉⴳ ⵓⴱⵔⵉⴷ ⵏ ⵓⴱⵔⵉⴷ ⴰⵎⵙⵙⵓⴷⵓ . ⵏⵖⴷ , ⴰⵔ ⵉⵜⵜⵔⴰⵔ nil ⵎⴽ ⵜⴳⴰⴷ ⵜⵉⵏⴷⵉⵜⵉⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ. ⵉⵎⴹⴰⵏ ⵏ ⵜⵉⴷⵜ, ⴰⵔ ⵉⵙⴽⵔ ⴰⵎⵙⵏⴼⵍⵓⵍ ⴰⵅⴰⵜⴰⵔ ⴳ ⵡⴰⵏⴰⵡ ⵏ ⵓⵎⵙⵏⴼⵍⵓⵍ ⵏⵏⴻⵙ.ⵔⵡⵉ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ, ⵏⵖⴷ ⵉⵙⵉⴹⵏ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵏⵖⴷ ⵉⵙⵉⴹⵏ ⵏ ⵡⵓⵟⵟⵓⵏ # >>> compare_one.call(1, 2.5)\n# 2.5\n# >>> compare_one.call(1, \"2,3\")\n# \"2,3\"\n# >>> compare_one.call(\"5,1\", \"6\")\n# \"6\"\n# >>> compare_one.call(\"1\", 1)\n# nil\ndef compare_one(a, b)\n","canonical_solution":"def compare_one(a, b)\n  a = a.to_s.tr(',', '.').to_f if a.is_a?(String) && a.include?(',')\n  b = b.to_s.tr(',', '.').to_f if b.is_a?(String) && b.include?(',')\n\n  if a.is_a?(String) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Float)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(Float)\n    a = a.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(Integer)\n    b = b.to_f\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Float)\n    b = b.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Float) && b.is_a?(String)\n    a = a.to_s # Only supporting variable type comparison, retain original types\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(String) && b.is_a?(Integer)\n    return nil if a == b\n    return a > b ? a : b\n  elsif a.is_a?(Integer) && b.is_a?(String)\n    return nil if a == b\n    return a > b ? a : b\n  else\n    return nil\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare_one\n    candidate = method(:compare_one)\n    assert_equal(2, candidate.call(1, 2))\n    assert_equal(2.5, candidate.call(1, 2.5))\n    assert_equal(3, candidate.call(2, 3))\n    assert_equal(6, candidate.call(5, 6))\n    assert_equal(\"2,3\", candidate.call(1, \"2,3\"))\n    assert_equal(\"6\", candidate.call(\"5,1\", \"6\"))\n    assert_equal(\"2\", candidate.call(\"1\", \"2\"))\n    assert_equal(nil, candidate.call(\"1\", 1))\n  end\nend\n"},{"task_id":"HumanEval_138","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍⵔⵣⵓ ⵏ ⵡⴰⵜⵉⴳ ⵏ ⵡⵓⵟⵟⵓⵏ n ⵉⵖⵢ ⴰⴷ ⵉⵜⵜⵢⴰⵔⴰ ⵙ ⵓⵖⵣⵓⵔ ⵏ ⴽⴽⵓⵥ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵣⴰⵔⴰⵢⵏ ⵉⵃⵍⴰⵏ # >>> is_equal_to_sum_even.call(4)\n# false\n# >>> is_equal_to_sum_even.call(6)\n# false\n# >>> is_equal_to_sum_even.call(8)\n# true\ndef is_equal_to_sum_even(n)\n","canonical_solution":"def is_equal_to_sum_even(n)\n  return false if n < 8\n  n.even?\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_equal_to_sum_even\n    candidate = method(:is_equal_to_sum_even)\n    assert_equal(false, candidate.call(4))\n    assert_equal(false, candidate.call(6))\n    assert_equal(true, candidate.call(8))\n    assert_equal(true, candidate.call(10))\n    assert_equal(false, candidate.call(11))\n    assert_equal(true, candidate.call(12))\n    assert_equal(false, candidate.call(13))\n    assert_equal(true, candidate.call(16))\n  end\nend\n"},{"task_id":"HumanEval_139","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴳ ⵉⵍⵍⴰ n > 0 brazilian_factorial{n} = n! * (n-1)! * (n-2)! * ... * 1! ⴷⴰ ⵉⵜⵜⵓⵙⵏⵎⵍ ⵓⴼⴰⴽⵜⵓⵔⴰⵍ ⴰⴱⵕⴰⵣⵉⵍⵉ ⵙ: # >>> special_factorial.call(4)\n# 288\n# The function will receive an integer as input and should return the special\n# factorial of this integer.\ndef special_factorial(n)\n","canonical_solution":"def special_factorial(n)\n  return 1 if n <= 1\n  (1..n).inject(1) { |product, i| product * factorial(i) }\nend\n\ndef factorial(num)\n  return 1 if num <= 1\n  (2..num).inject(1, :*)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_special_factorial\n    candidate = method(:special_factorial)\n    assert_equal(288, candidate.call(4))\n    assert_equal(34560, candidate.call(5))\n    assert_equal(125411328000, candidate.call(7))\n    assert_equal(1, candidate.call(1))\n  end\nend\n"},{"task_id":"HumanEval_140","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴼⴼⵉⵔ ⴰⴷ ⵙⵏⴼⵍ ⵉⵙⴰⵢⵔⴰⵔⵏ ⴰⴽⴽⵡ ⵉⵎⵣⴷⴰⵢⵏ ⵙ - ⴷ ⵎⴽ ⴳⴰⵏ ⵜⵉⵙⵉⴹⴼⴰⵏⵉⵏ ⵓⴳⴳⴰⵔ ⵏ 2 ⵏ ⵡⴰⵏⵙⴰ ⵉⵎⴹⴼⴰⵕⵏ, ⴹⴰⵗ ⵜⴰⵙⴰⵙⵙⴰⵗⵔⴰⵓⵜ ⵏ ⵉⴾⵉⵜⴱⴰⵏ, ⵙⴰⵎⵎⵓⵜⵜⵉ ⵏ ⵉⵂⴰⵏⴷⴰⴶⴰⵏ ⴼⵓⴾ ⴷⴰⵗ ⵢⴷⵢⵙ ⵏ ⴾⴰⵔⵜⵉ ⵜⴰⵏ# >>> fix_spaces.call(\" Example\")\n# \"Example\"\n# >>> fix_spaces.call(\" Example 1\")\n# \"Example_1\"\n# >>> fix_spaces.call(\" Example 2\")\n# \"_Example_2\"\n# >>> fix_spaces.call(\" Example 3\")\n# \"_Example-3\"\ndef fix_spaces(text)\n","canonical_solution":"def fix_spaces(text)\n  text.strip.gsub(\/\\s{3,}\/, '-').gsub(' ', '_')\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2 2 mple\"))\n  end\nend\n"},{"task_id":"HumanEval_141","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:- ⵉⵇⵏⴻⵏ ⴰⴷ ⵉⴳ ⵓⵙⵏⴼⵍⵓⵍ ⴷⴼⴼⵉⵔ ⵜⴱⵔⵉⴷⵜ ⵢⴰⵏ ⴳ ⵡⴰⵏⵏⴰ ⴷⴷⵖ: ['txt', 'exe', 'dll'] ⴰⵍⴾⴰⴷⴰⵏ ⵓⵉⵏ ⵍⴰⵜⵉⵏ (\"ⴰ-ⵣ\" ⴷ \"ⴰ-ⵣ\")- ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵢⵉⵍⵉ ⵡⴰⵏⵙⴰ ⴷⴰⵜ ⵏ ⵜⴱⵔⵉⴷⵜ, ⴰⵔ ⵜⴱⴷⴰⴷ ⵙ ⵓⴱⵔⵉⴷ - ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⵉⵍⵍⴰ ⴳⵉⵙ ⵢⴰⵏ ⵓⴱⵔⵉⴽⵜ '.' - ⵓⵔ ⵉⵅⵚⵚⴰ ⴰⴷ ⵉⵍⵉⵏ ⵓⴳⴳⴰⵔ ⵏ ⴽⵕⴰⴹ ⵏ ⵡⵓⵟⵟⵓⵏ (\"0\" - \"9\") ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ. ⵜⵜⵓⵙⵎⵓⵏ: ⵉⵙⵎ ⵏ ⵓⴱⵔⵓⴹⵉⵣ ⴰⵔ ⵉⵜⵜⵓⵙⵡⴰⵏ ⵉⵙ ⵉⴳⴰ ⵡⴰⵍⵍⵉ ⵉⵣⵔⵉⵏ ⵎⴽ ⴷ ⵎⴽ ⴷⴰ ⵇⵇⴰⵔⵏ ⴽⵓⵍⵍⵓ ⵜⵎⵙⴰⵔⵉⵏ ⴷⴷⵖ \"ⴷⴰ\" ⵉⵖ ⵉⴳⴰ ⵢⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ ⴰⵣⵔⴼⴰⵏ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ \"ⵓⵀⵓ\" ⵎⴽ ⵓⵔ ⵉⴳⵉ. ⵙⴽⵔ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵡⵜⵜⵓ ⵉⵙⵎⴷⵢⴰ ⵉⵙⵎ ⵏ ⵓⵖⵎⵉⵙ, ⴰⵔ ⵉⵜⵜⵔⴰⵔ # >>> file_name_check.call(\"example.txt\")\n# \"Yes\"\n# >>> file_name_check.call(\"1example.dll\")\n# \"No\"\ndef file_name_check(file_name)\n","canonical_solution":"def file_name_check(file_name)\n  # Check if there's exactly one dot in the filename\n  return 'No' unless file_name.count('.') == 1\n  \n  # Split the filename into the name and extension\n  name, extension = file_name.split('.')\n  \n  # Check if the name part starts with a letter\n  return 'No' if name.empty? || !name[0].match?(\/[a-zA-Z]\/)\n  \n  # Check if the extension is valid\n  return 'No' unless ['txt', 'exe', 'dll'].include?(extension)\n  \n  # Count digits in the file name\n  digit_count = file_name.count(\"0-9\")\n  \n  # Check if digits are more than three\n  return 'No' if digit_count > 3\n  \n  'Yes'\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_file_name_check\n    candidate = method(:file_name_check)\n    assert_equal(\"Yes\", candidate.call(\"example.txt\"))\n    assert_equal(\"No\", candidate.call(\"1example.dll\"))\n    assert_equal(\"No\", candidate.call(\"s1sdf3.asd\"))\n    assert_equal(\"Yes\", candidate.call(\"K.dll\"))\n    assert_equal(\"Yes\", candidate.call(\"MY16FILE3.exe\"))\n    assert_equal(\"No\", candidate.call(\"His12FILE94.exe\"))\n    assert_equal(\"No\", candidate.call(\"_Y.txt\"))\n    assert_equal(\"No\", candidate.call(\"?aREYA.exe\"))\n    assert_equal(\"No\", candidate.call(\"\/this_is_valid.dll\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.wow\"))\n    assert_equal(\"Yes\", candidate.call(\"this_is_valid.txt\"))\n    assert_equal(\"No\", candidate.call(\"this_is_valid.txtexe\"))\n    assert_equal(\"No\", candidate.call(\"#this2_i4s_5valid.ten\"))\n    assert_equal(\"No\", candidate.call(\"@this1_is6_valid.exe\"))\n    assert_equal(\"No\", candidate.call(\"this_is_12valid.6exe4.txt\"))\n    assert_equal(\"No\", candidate.call(\"all.exe.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"I563_No.exe\"))\n    assert_equal(\"Yes\", candidate.call(\"Is3youfault.txt\"))\n    assert_equal(\"Yes\", candidate.call(\"no_one#knows.dll\"))\n    assert_equal(\"No\", candidate.call(\"1I563_Yes3.exe\"))\n    assert_equal(\"No\", candidate.call(\"I563_Yes3.txtt\"))\n    assert_equal(\"No\", candidate.call(\"final..txt\"))\n    assert_equal(\"No\", candidate.call(\"final132\"))\n    assert_equal(\"No\", candidate.call(\"_f4indsartal132.\"))\n    assert_equal(\"No\", candidate.call(\".txt\"))\n    assert_equal(\"No\", candidate.call(\"s.\"))\n  end\nend\n"},{"task_id":"HumanEval_142","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⴰⴷ ⵜⵙⵏⴼⵍ ⵜⵎⵙⴽⵜⵉⵜⵉⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵡⵓⵟⵟⵓⵏ ⵏ 3 ⵏⵖⴷ 4. ⵔⴰⴷ ⵜⵕⵡⵍ ⵜⵡⵓⵔⵉ ⵜⴰⴳⵓⵜ ⵏ ⵜⵎⵙⴽⵜⵉⵜⵉⵏ ⴰⴽⴽⵡ.ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3 ⴷ ⵔⴰⴷ ⵢⴰⴽⵣ ⴰⵎⴳⴳⴰⵔⵓ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⴳ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 4 ⴷ ⵓⵔ ⵉⴳⵉ ⴰⵎⴳⴳⴰⵔⵓ ⵏ 3. ⵓⵔ ⵔⴰⴷ ⵜⴳⴳ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵔⴰⴷ ⵜⵕⵥⵎ ⴰⵎⵙⴷⵉ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵉ ⴽⵓⵍⵍⵓ ⵜⵉⵎⵙⴽⵜⵉⵜⵉⵏ ⴳ ⵓⵎⵙⴷⵉ, ⵔⴰⴷ ⵜⵕⵥⵎ ⵜⴰⵡⵓⵔⵉ ⴰⵎⵙⴷⵉ ⵏ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⵎⴽ ⵉⴳⴰ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙ \" # >>> lst\n# [1, 2, 3]\n# >>> lst\n# []\n# >>> lst\n# [-1, -5, 2, -1, -5]\ndef sum_squares(lst)\n","canonical_solution":"def sum_squares(lst)\n  lst.map.with_index do |num, index|\n    if index % 3 == 0\n      num ** 2\n    elsif index % 4 == 0\n      num ** 3\n    else\n      num\n    end\n  end.sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n    candidate = method(:sum_squares)\n    assert_equal(6, candidate.call([1, 2, 3]))\n    assert_equal(14, candidate.call([1, 4, 9]))\n    assert_equal(0, candidate.call([]))\n    assert_equal(9, candidate.call([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n    assert_equal(-3, candidate.call([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n    assert_equal(0, candidate.call([0]))\n    assert_equal(-126, candidate.call([-1, -5, 2, -1, -5]))\n    assert_equal(3030, candidate.call([-56, -99, 1, 0, -2]))\n    assert_equal(0, candidate.call([-1, 0, 0, 0, 0, 0, 0, 0, -1]))\n    assert_equal(-14196, candidate.call([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]))\n    assert_equal(-1448, candidate.call([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]))\n  end\nend\n"},{"task_id":"HumanEval_143","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ 1:ⵍⴰⵀⴰⵏ ⵏ ⵡⴰⵡⴰⵍ ⴳ ⵜⵣⵍⵉⵜ ⵜⴰⵎⴰⵢⵏⵓⵜ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵉⵎⴽⵉⵏ ⵡⵉⵙⵙ ⵓⵣⵡⴰⵔⵓ.ⵜⵉⵖⵣⵉ ⵏⵏⵙ ⵜⴳⴰ ⵉⵎⴹⴰⵏ ⵉⵎⵣⵡⵓⵔⴰ, ⴷ ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵔⵉⵜⵓⵔ ⵙⵜⵔⵉⴳ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵏ ⵜⴳⵓⵔⵉ ⵜⴰⵢⵎⵎⴰⵜ, ⵜⴰⴳⵓⵔⵉ ⵜⵍⴰ ⴽⵔⴰ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵉⵜⵜⵓⵢⴼⵔⴰⵔⵏ ⵙ ⵓⵙⴰⵢⵔⴰⵔ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎ ⵉⵙⵎⴷⵢⴰⵏ ⵜⴰⴳⵓⵔⵉ, # >>> words_in_sentence.call(\"This is a test\")\n# \"is\"\n# Example 2:\n# >>> words_in_sentence.call(\"lets go for swimming\")\n# \"go for\"\n# Constraints:\n# * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n","canonical_solution":"def words_in_sentence(sentence)\n  def is_prime?(num)\n    return false if num <= 1\n    (2..Math.sqrt(num)).none? { |i| num % i == 0 }\n  end\n  \n  words = sentence.split(\" \")\n  prime_length_words = words.select { |word| is_prime?(word.length) }\n  prime_length_words.join(\" \")\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"))\n  end\nend\n"},{"task_id":"HumanEval_144","nl":"taq_Tfng","pl":"rb","prompt":"ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⵎⴽⵜⵉ ⵎⴰⵙ ⴷ x, ⴷ n ⴳⴰⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵉⵖⵓⴷⴰⵏ, ⴷ ⵓⵔ ⴷⴰⵔⵙⵏ ⵓⵎⵢⴰ ⴰⵎⵎ ⵓⵎⵙⵙⴰⵖ.<numerator>\/<denominator> ⴳⴰⵏ ⵙⵉⵏ ⵉⵎⵉⴹⵏ ⵉⵎⴷⴷⴰⴷⵏ ⴷ ⵉⵎⵙⵙⴰⵖⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵎⴽⵍⵍⵉ, ⴳⴰⵏ x ⴷ n, ⴰⵙⵎⴷⵢⴰ ⵏ ⵓⴽⵙⴰⵢ ⵏ ⵜⴳⵣⵣⵓⵎⵜ, ⴷ ⵖⵓⵔⵙⵏ ⵜⴰⵍⵖⴰ ⴷ ⵢⵓⵛⴽⴰⵏ, x * n. ⴷⴰ ⵜⵔⴰⵔ ⵜⴰⵡⵓⵔⵉ ⵜⵉⴷⵜ ⵎⴽ ⵜⵙⵙⵎⵔⴰⵙ x * n ⵉ ⵓⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ ⴷ ⵜⵉⴷⵜ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴽ ⵜⴳⴰ ⴰⴷ ⵜⵙⵙⴽⵔ ⵢⴰⵜ ⵜⵎⵔⵙⵜ ⵏⵏⴰ ⵔⴰⴷ ⵉⵙⴱⴷⵉⴷ ⴰⵙⵏⵓⵎⵎⵍ # >>> simplify.call(\"1\/5\", \"5\/1\")\n# true\n# >>> simplify.call(\"1\/6\", \"2\/1\")\n# false\n# >>> simplify.call(\"7\/10\", \"10\/2\")\n# false\ndef simplify(x, n)\n","canonical_solution":"def simplify(x, n)\n  # Convert x and n to numerators and denominators\n  num_x, den_x = x.split('\/').map(&:to_i)\n  num_n, den_n = n.split('\/').map(&:to_i)\n\n  # Multiply fractions: (num_x * num_n) \/ (den_x * den_n)\n  numerator = num_x * num_n\n  denominator = den_x * den_n\n\n  # Check if the result is a whole number\n  numerator % denominator == 0\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_simplify\n    candidate = method(:simplify)\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/6\", \"2\/1\"))\n    assert_equal(true, candidate.call(\"5\/1\", \"3\/1\"))\n    assert_equal(false, candidate.call(\"7\/10\", \"10\/2\"))\n    assert_equal(true, candidate.call(\"2\/10\", \"50\/10\"))\n    assert_equal(true, candidate.call(\"7\/2\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"11\/6\", \"6\/1\"))\n    assert_equal(false, candidate.call(\"2\/3\", \"5\/2\"))\n    assert_equal(false, candidate.call(\"5\/2\", \"3\/5\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"8\/4\"))\n    assert_equal(true, candidate.call(\"2\/4\", \"4\/2\"))\n    assert_equal(true, candidate.call(\"1\/5\", \"5\/1\"))\n    assert_equal(false, candidate.call(\"1\/5\", \"1\/5\"))\n  end\nend\n"},{"task_id":"HumanEval_145","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵔⴰⵏⵜ ⵙ ⵓⵙⵓⴷⵙ ⵏⵏⵙⵏ ⵙ ⵓⵙⵉⵔⴰ ⵏⵏⵙⵏ ⴳ ⵓⵙⵏⵙⵍ ⴰⵎⵣⵡⴰⵔⵓ.ⴰⵜⵡⵉⵍ: ⵉⵖ ⵉⵍⵍⴰ ⴽⵉⴳⴰⵏ ⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵙ ⵡⴰⵜⵉⴳ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ ⵉⵎⵎⵔⵡⴰⵙⵏ, ⵙ ⵓⵍⵖⵓ ⴰⵎⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏⵏⵙⵏ.ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⵙⵔⵔⵓⵙ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ # >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1, -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n","canonical_solution":"def order_by_points(nums)\n  nums.sort_by.with_index do |num, index|\n    [num.to_s.chars.map(&:to_i).sum.abs, index]\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11], candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32, 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6], candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"},{"task_id":"HumanEval_146","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵣⵡⴰⵔⵓ ⴷ ⵡⵉⵏ ⴹⴰⵕⵜ ⵓⴳⴳⴰⵔ ⵏ ⵡⵓⵟⵟⵓⵏ (1, 3, 5, 7, 9).ⴰⵎⴹⴰⵏ ⵏ ⵉⴼⵔⴷⵉⵙⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⵢⵓⴳⵔⵏ 10 ⴷ ⵙⵏⴰⵜ ⵙⵔⵙⵏ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ ⴰⵎⵎ ⵉⵏⴽⵛⵓⵎⵏ ⴷ ⵡⵉⵏ ⵜⵏⴰⴼⵓⵜⵉⵏ # >>> specialFilter.call([15, -73, 14, -15])\n# 1\n# >>> specialFilter.call([33, -2, -3, 45, 21, 109])\n# 2\ndef specialFilter(nums)\n","canonical_solution":"def specialFilter(nums)\n  nums.count do |num|\n    num > 10 && num.to_s[0].to_i.odd? && num.to_s[-1].to_i.odd?\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5, -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2, candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43, -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75, 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n  end\nend\n"},{"task_id":"HumanEval_147","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ:ⴷ a[i] + a[j] + a[k] ⴷ ⴰⵎⵔⴰⵔⵓ ⵏ 3. ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵔⴱⵉⵍⵉⵏ (ⴰ[i], ⴰ[ⵊ], ⴰ[ⴽ]) ⵏ ⴰ ⴳ ⵉⵍⵍⴰ i < ⵊ < ⴽ, ⵉ ⴽⵓ i (1 ≤ i ≤ n), ⴰⵜⵉⴳ ⵏ a[i] = i * i - i + 1. ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⴹ ⴰⵎⴷⴷⴰⴷ ⴰⵎⵏⵉⴳ ⴰⵎⵏⵉⴳ n. ⵉⵇⵇⴰⵏ ⴷ ⴰⴷ ⵜⵙⴽⵔ ⵢⴰⵏ ⵓⵙⵔⴷ ⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ a ⵏ ⵜⵉⵖⵣⵉ n. # >>> get_max_triples.call(5)\n# 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is (1, 7, 13).\ndef get_max_triples(n)\n","canonical_solution":"def get_max_triples(n)\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  count = 0\n  \n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      (j+1...n).each do |k|\n        count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  \n  count\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n    assert_equal(53361, candidate.call(100))\n  end\nend\n"},{"task_id":"HumanEval_148","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵓⵔ ⴳⵉⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵉⵜⵔⴰⵏ ⵉⵎⵙⴰⵙⴰⵏ.ⵜⵣⵎⵔ ⵜⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵏ ⵜⴰⴳⵔⵡⴰⵏⵜ ⵜⴰⵅⵅⴰⵔⵜ ⵎⴽ ⵜⴳⴰ planete1 ⵏⵖ planete2 ⵜⴰⵣⵓⵍⵉ ⵏ ⵜⴰⴼⵓⴾⵜⵉⵍⵍⴰⵏ ⵋⵉⵔ ⵜⴰⵗⵉⵙⵙⴰ ⵏ ⴱⵍⴰⵢⵏⵢⵜ1 ⴷ ⵜⴰⵗⵉⵙⵙⴰ ⵏ ⴱⵍⴰⵢⵏⵢⵜ2, ⵉⵋⵋⴰⵏ ⵙ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⵡⴰⵍ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⴰⴽⴽⵡ ⵉⵜⵔⴰⵏ ⵏⵏⴰ ⵉⵍⵍⴰⵏ ⵜⵉⵖⵔⵓⵎⵎⴰ ⵏⵏⵙ ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⵓⵎⵥⵏ ⵙⵉⵏ ⵉⵙⵎⴰⵡⵏ ⵏ ⵉⵜⵔⴰⵏ ⴰⵎⵎ ⵜⵉⵙⵉⴹⴼⵕⵉⵏ planet1 ⴷ planet2.ⵓⵓⵔⴰⵏⵓⵙ, ⵏⴻⴱⵜⵓⵏⴻ.ⵉⴳⴰ ⵎⵉⵔⴽⵓⵔⵉ, ⵡⴰⵏⵏⴰ ⴷ ⵉⴷⴷⴰⵏ ⵉⴳⴰ ⵡⵉⵏⵓⵙ, ⴷⴼⴼⵉⵔ ⵏ ⵓⵢⴰ ⵉⴳⴰ ⵡⴰⴽⴰⵍ, ⵎⴰⵕⵙ, ⵊⵓⴱⵉⵜⵔ, ⵙⴰⵜⵓⵔⵏ, ⵍⵍⴰⵏⵜ 8 ⵏ ⵜⵣⵡⵉⵏⵏⵉⵜⵉⵏ ⴳ ⵓⵏⴳⵔⴰⵡ ⵏ ⵜⴰⴼⵓⴽⵜ ⵏⵏⵖ: ⵜⵉⴷⵙⵜ ⵜⴰⴷⵙⵜⵔⴰⵔⵜ ⵏ ⵜⴰⴼⵓⴽⵜ.# >>> bf.call(\"Jupiter\", \"Neptune\")\n# [\"Saturn\", \"Uranus\"]\n# >>> bf.call(\"Earth\", \"Mercury\")\n# \"Venus\"\n# >>> bf.call(\"Mercury\", \"Uranus\")\n# [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\ndef bf(planet1, planet2)\n","canonical_solution":"def bf(planet1, planet2)\n  planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \n  idx1 = planets.index(planet1)\n  idx2 = planets.index(planet2)\n  \n  return [] if idx1.nil? || idx2.nil?\n\n  start_idx, end_idx = [idx1, idx2].sort\n  \n  planets[(start_idx + 1)...end_idx]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_bf\n    candidate = method(:bf)\n    assert_equal([\"Saturn\", \"Uranus\"], candidate.call(\"Jupiter\", \"Neptune\"))\n    assert_equal([\"Venus\"], candidate.call(\"Earth\", \"Mercury\"))\n    assert_equal([\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], candidate.call(\"Mercury\", \"Uranus\"))\n    assert_equal([\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], candidate.call(\"Neptune\", \"Venus\"))\n    assert_equal([], candidate.call(\"Earth\", \"Earth\"))\n    assert_equal([], candidate.call(\"Mars\", \"Earth\"))\n    assert_equal([], candidate.call(\"Jupiter\", \"Makemake\"))\n  end\nend\n"},{"task_id":"HumanEval_149","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⵜⵣⵎⵔⴷ ⴰⴷ ⵜⵙⵙⵏⴷ ⵉⵙ ⵇⴰⴷ ⵢⵉⵍⵉ ⵓⵖⵣⵉ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ ⴰⴽⴽⵡ.ⵍⴰⵇⵏ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⴰⵔⴰⵔ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵓⵏⵎⴰⵍⴰ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ.ⵎⴽ ⴷⴰⵔ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ ⵜⵉⵖⵣⵉ ⵜⴰⵣⴳⵣⴰⵡⵜ, ⵙⵙⵓⴷⵙ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵙ ⵓⴽⵙⴰⵢ.ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⵉ ⴰⵙⵔⴷⴰⵙ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ ⵙ ⵓⴷⴷⴰⴷ ⴰⴷ.ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⴳ ⵜⴰⵍⵖⴰ ⵏ ⵓⵙⵏⵙⵍ ⵙ ⵓⵙⵙⴼⵍⴷ ⵙ ⵜⵉⵖⵣⵉ ⵏ ⴽⵓ ⵜⴳⵓⵔⵉ, ⴷ ⵇⴰⴷ ⵜⵙⵙⴽⵔⴷ ⴰⴷⴷⵓⴱⴰⵜ ⴰⴷ ⵢⵂⴰ ⵉⴾⵉⵜⴱⴰⵏⵉⴳⴰ ⵓⵎⵙⴳⵏⴰⴼ ⴰⵀⴰ ⴰⵎⵙⴳⵏⴰⴼ ⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵓⵔ ⴷ ⴰⵎⵙⴳⵏⴰⴼ ⵏ ⵉⵎⴹⴰⵏ, ⴷ ⴰⵔ ⵉⵜⵜⴰⴽⴽⴰ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵉⵜⵜⵓⵙⵢⴰⴼⴰⵏ ⵙ ⵢⴰⵏ ⵓⴽⵓⴷ ⵉⵜⵜⵓⵙⵎⵉⵍⵏ, ⴷⴰ ⵉⵜⵜⵓⵙⴽⵙⵉ ⵜⵉⴼⵔⴽⵉⵏ ⵏⵏⴰ ⵖⵓⵔ ⵍⵍⴰⵏ ⵜⵉⵖⵣⵉⵡⵉⵏ ⵓⵔ ⵉⵎⵙⴰⵙⴰⵏ, ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⵉⴹⵏⵏ ⴰⵎⵎ ⵓⴱⴰⵔⴰⵎⴰⵜⵔ,# >>> list_sort.call([\"aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\", \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n","canonical_solution":"def list_sort(arr)\n  arr.select { |s| s.length.even? }\n     .sort_by { |s| [s.length, s] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\", \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"], candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"},{"task_id":"HumanEval_150","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵔⴰⴷ ⵢⴰⴽⴽⴰ ⵡⴰⵜⵉⴳ ⵏ y ⵎⴽ ⵓⵔ ⵉⴳⵉ ⵡⴰⵜⵉⴳ ⴰⵎⵣⵡⴰⵔⵓ.ⴰⵖⴰⵡⴰⵙ ⴰⵎⵢⵉⵡⵏ ⵏⵏⴰ ⵉⵇⵇⴰⵏ ⴰⴷ ⵢⴰⴽⴽⴰ ⴰⵜⵉⴳ ⵏ x ⵎⴽ ⵉⴳⴰ n # >>> x_or_y.call(7, 34, 12)\n# 34\n# >>> x_or_y.call(15, 8, 5)\n# 5\ndef x_or_y(n, x, y)\n","canonical_solution":"def x_or_y(n, x, y)\n  require 'prime'\n  n.prime? ? x : y\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_x_or_y\n    candidate = method(:x_or_y)\n    assert_equal(34, candidate.call(7, 34, 12))\n    assert_equal(5, candidate.call(15, 8, 5))\n    assert_equal(33, candidate.call(3, 33, 5212))\n    assert_equal(3, candidate.call(1259, 3, 52))\n    assert_equal(-1, candidate.call(7919, -1, 12))\n    assert_equal(583, candidate.call(3609, 1245, 583))\n    assert_equal(129, candidate.call(91, 56, 129))\n    assert_equal(1234, candidate.call(6, 34, 1234))\n    assert_equal(0, candidate.call(1, 2, 0))\n    assert_equal(2, candidate.call(2, 2, 0))\n  end\nend\n"},{"task_id":"HumanEval_151","nl":"taq_Tfng","pl":"rb","prompt":"ⴳ ⵓⵎⵙⴳⵏⴰⴼ ⵏⵏⴰ ⵓⵔ ⵉⵎⴽⵍⵉ.  ⵓⵔ ⴷⴰ ⵏⵙⵙⴽⵜⵉ ⵉⵎⴹⴰⵏ ⵏⵏⴰ ⵓⵔ ⵉⴳⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ.ⴷⴰ ⵉⵜⵜⵓⴼⴽⴰ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵡⵓⵟⵟⵓⵏ, ⵔⴰⵏⵜⵓ ⵜⴰⴳⵔⵓⵎⵎⴰ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵡⵓⵟⵟⵓⵏ # >>> double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1, -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n# 0\n# If the input array is empty, return 0.\ndef double_the_difference(lst)\n","canonical_solution":"def double_the_difference(lst)\n  lst.select { |n| n.is_a?(Integer) && n.odd? && n >= 0 }\n     .map { |n| n ** 2 }\n     .sum\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1, 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0, candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2, 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"},{"task_id":"HumanEval_152","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ:ⴰⵍⵈⵉⵎ ⵢⵈⵈⴰⵍ 0, ⵎⵢⵗ ⴰ ⴼⴰⵍ ⵓⴰⵔ ⵢⵈⵈⵢⵍ, ⴰⵍⵈⵉⵎ ⵢⵈⵈⴰⵍ ⴰⵏⵎⵉⵣⵍⴰⵉ ⵓⵍⴰⵗⴰⵏ ⵋⵉⵔ ⵜⴰ-ⵉⵜⵢ ⴷ ⵜⵢⵗⴰⵔⵢⴷⴰ ⵉⵜⵜⵔⴰⵔ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵜⵉⵖⵣⵉ ⵏⵏⴰ ⵉⵎⴽⵉⵏⵏⴰ ⵉⵙⵏⵎⴰⵍⴰ ⵎⴰⵢⴷ ⵉⴳⴰⵏ ⴰⴱⴰⵔⴰⵣ ⵏ ⴽⵓ ⴰⵙⵏⵖⵍ. ⵎⴽ ⵜⵔⵏⴰ ⴰⵙⵏⵖⵍ ⵙ ⵜⴷⵓⵙⵉ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⵔⴰⴱⴱⵓⵜⵉⵏ ⵏ ⵜⵏⴰⴼⵓⵜⵉⵏ ⴷ ⵉⵙⵡⵉⵏⴳⵉⵎⵏ ⵏ ⵜⵉⵖⵣⵉ ⵉⵎⵣⴰⵔⴰⵢⵏ, ⴳ ⴷⴰ ⵉⵙⵙⴼⵔⴰⵢ ⴽⵓ ⵉⵎⵉⴹ ⵢⴰⵜ ⵜⵎⵙⴰⵙⴰ.ⴰⵍⵆⵉⴷⵎⴰⵜ ⵏⵢⵜ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴰⵉⴰⴷ ⴰⵙ ⴰⵓⴰⴷⵉⵎ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷ ⵙ ⵜⵉⴷⵉⵜⵜ ⴼⴰⵍ ⵜⵉⵏⴼⴰ ⵏ ⵉⵛⵂ-ⵉⴾⵉⵍⴰⵏⴰⵍⴰⵗⵉ ⵏⴰⵜ ⴰⵙ ⵉⵋⵋⴰ ⴰⴾⴰⵉⴰⴷ ⴷ ⴰⵙⵉⴾⵉ ⵏⵢⵜⴰⴾⴰⵉⴰⴷ ⵓⴰ ⵉⴾⵏⴰⵏ ⵜⴰ-ⵉⵜⵢ ⵏ-ⴰⴾⴰⵉⴰⴷ ⵓⴰ ⵉⴾⵏⴰⵏ ⴰⵍⵓⴰⵈ ⵓⵢⵏⴰⵂⴰⵏⴰⵉ ⴰⵏ ⵏⴰⴾⴰⵍ ⴰⵜⵉⵓⴰⵏⵏⴰ ⴰⵏ ⵜⴰ-ⵉⵜⵢ ⴰⵏ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ ⵜⴰ-ⵉⵜⵢ# >>> compare.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])\n# [0, 0, 0, 0, 3, 3]\n# >>> compare.call([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2])\n# [4, 4, 1, 0, 0, 6]\ndef compare(game, guess)\n","canonical_solution":"def compare(game, guess)\n  game.zip(guess).map { |score, prediction| (score - prediction).abs }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1, 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3, 5], [-1, 2, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_153","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: (ⵜⵓⵙⴷⵉⴷⵜ ⵏⵏⵙ ⵜⴳⴰ -1).return \"Slices.SErviNGSliCes\" ⴰⵛⴽⵓ \"SErviNGSliCes\" ⵉⴳⴰ ⵓⵙⵙⵖⵣⵏ ⵉⴷⵓⵙⵏ ⵉⵙⵎ ⵏ ⵓⵙⵙⴰⵔⵓ: ['ⵙⵉⵔⴼⵉⵏⴳⵙⵍⵉⵛⵙ', 'ⵛⵉⵣ', 'ⵙⵜⵓⴼⴼⵉⴷ'], ⵇⴰⴷ ⵜⵙⵙⵏⴷⵙ ⵓⵎⴷⵢⴰ, ⵎⴽ ⵜⵜⵓⴼⴽⴰ \"ⵙⵍⴰⵢⵛⵙ\" ⴰⵎⵎ ⵜⵣⵔⴰⵡⵜ ⴷ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⴷⴰ ⵉⵜⵜⵓⵙⵜⴰ ⵡⴰⵏⵏⴰ ⵉⵜⵜⵓⵢⴰⵏⵏⴰⵏ ⴳ ⵓⵎⵙⴳⵏⴰⴼ.ⵎⴽ ⵍⵍⴰⵏ ⵙⵉⵏ ⵏ ⵉⵙⵖⵣⵣⵉⴼⵏ ⵏⵖ ⵓⴳⴳⴰⵔ ⵙ ⵢⴰⵜ ⵜⵉⴷⵜ, ⵇⴰⴷ ⵜⵙⵙⴽⵛⵎ format: ClassName.StrongestExtensionName. ⵇⴰⴷ ⵜⵙⵙⵉⴼⴹ ⵜⴰⴳⵣⵉⵔⵜ ⵜⴰⴷⵓⵙⵜ ⴷ ⵜⵔⴰⵔ ⵜⴰⵡⵉⵍⴰ ⴳ ⵓⵢⴰ ⴳ ⵢⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵣⵎⵔⵜ ⵙ ⵜⴽⵕⴹⵉ CAP - SM. ⵜⵉⴼⵔⵉⵙⵉⵏ ⴳ ⵉⵙⵎ ⵏ ⵓⵙⵖⵣⵣⵉⴼ, ⴷ ⴰⴷ ⵜⴳ SM ⴰⵎⴹⴰⵏ ⵏ ⵜⵉⴼⵔⵉⵙⵉⵏ ⵜⵉⵎⵥⵥⵢⴰⵏⵉⵏ ⵜⴰⵣⵓⵏⵜ ⵏ ⵓⵙⵙⵖⵣⵣⵉⴼ ⵜⴳⴰ ⵣⵓⵏⴷ ⴰⵢⴰ: ⴰⴷ ⵜⴳ CAP ⴰⵎⴹⴰⵏ ⵏ ⵡⵓⵟⵟⵓⵏ ⵏ ⵜⵉⵔⵔⴰ ⴷⴰ ⵜⵜⵓⵙⵎⵔⴰⵙⵏⵜ ⵜⵔⵏⵓⵜⵉⵏ ⵃⵎⴰ ⴰⴷ ⵜⵜⵓⵙⴽⵛⵎⵏ ⵉⵙⵍⵎⴰⴷⵏ ⵢⴰⴹⵏⵉⵏ ⴳ ⵓⵙⵍⵎⴷ.ⵔⴰⴷ ⵜⵜⵓⴼⴽⴰ ⵢⵉⵙⵎ ⵏ ⵜⵔⴳⴰ (ⵜⴰⵏⴳⵉ) ⴷ ⵢⴰⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵉⵙⵖⵣⵏ.# >>> Strongest_Extension.call(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n# \"my_class.AA\"\ndef Strongest_Extension(class_name, extensions)\n","canonical_solution":"def Strongest_Extension(class_name, extensions)\n  strongest_extension = extensions.max_by do |extension|\n    cap_count = extension.count('A-Z')\n    sm_count = extension.count('a-z')\n    cap_count - sm_count\n  end\n  \"#{class_name}.#{strongest_extension}\"\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\", candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\", candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"_\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\", [\"671235\", \"Bb\"]))\n  end\nend\n"},{"task_id":"HumanEval_154","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵏⴰⵜ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵇⴰⴷ ⵜⵔⴰⵔⴷ true ⵎⴽ ⵜⴳⴰ ⵜⴳⵓⵔⵉ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵏⵖ ⴽⵔⴰ ⵏ ⵜⵙⵓⵜⵍⵉⵏ ⵏⵏⵙ ⵜⴰⴳⵓⵔⵉ ⵜⴰⴷⵙⵍⴰⵏⵜ ⴳ ⵜⴳⵓⵔⵉ ⵜⴰⵎⵣⵡⴰⵔⵓⵜ.# >>> cycpattern_check.call(\"abcd\", \"abd\")\n# false\n# >>> cycpattern_check.call(\"hello\", \"ell\")\n# true\n# >>> cycpattern_check.call(\"whassup\", \"psus\")\n# false\n# >>> cycpattern_check.call(\"abab\", \"baa\")\n# true\n# >>> cycpattern_check.call(\"efef\", \"eeff\")\n# false\n# >>> cycpattern_check.call(\"himenss\", \"simen\")\n# true\ndef cycpattern_check(a, b)\n","canonical_solution":"def cycpattern_check(a, b)\n  (0...b.length).each do |i|\n    rotated_b = b[i..-1] + b[0...i]\n    return true if a.include?(rotated_b)\n  end\n  false\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true, candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"))\n  end\nend\n"},{"task_id":"HumanEval_155","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵉⴳ ⵏⵙⴽⵔ ⴰⵎⴹⴰⵏ ⴰⵎⴷⴷⴰⴷ, ⵏⵙⵙⴽⵛⵎ ⴰⵙⵏⵙⵍ ⵏⵏⴰ ⴳ ⵍⵍⴰⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵎⵎⵉⴷⵏ ⴷ ⵉⵎⵎⵉⴷⵏ ⵙ ⵓⵎⵣⴰⵔⴰⵢ.# >>> even_odd_count.call(-12)\n# [1, 1]\n# >>> even_odd_count.call(123)\n# [1, 2]\ndef even_odd_count(num)\n","canonical_solution":"def even_odd_count(num)\n  num.to_s.chars.map(&:to_i).select { |digit| digit != 0 }.partition(&:even?).map(&:count)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"},{"task_id":"HumanEval_156","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏ:ⵜⵉⵎⵥⴰⴳⵉⵏ: 1 <= num <= 1000 ⴷ ⵙ ⵜⵉⴼⵉⵏⴰⵖ ⵙ ⵓⴽⵙⴰⵢ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ, ⵙⵙⵓⵜⵔ ⴰⵎⵙⴽⴰⵔ ⵏ ⵡⵓⵟⵟⵓⵏ ⵉⵕⵓⵎⵉⵢⵏ ⵏⵏⵙ ⴰⵎⵎ ⵜⴰⴳⵔⵓⵎⵎⴰ, # >>> int_to_mini_roman.call(19)\n# \"xix\"\n# >>> int_to_mini_roman.call(152)\n# \"clii\"\n# >>> int_to_mini_roman.call(426)\n# \"cdxxvi\"\ndef int_to_mini_roman(number)\n","canonical_solution":"def int_to_mini_roman(number)\n  values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n\n  result = ''\n  values.each_with_index do |value, index|\n    while number >= value\n      number -= value\n      result += numerals[index]\n    end\n  end\n\n  result\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"},{"task_id":"HumanEval_157","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: 90 ⴷⴻⴶⵔⴻⴻⴻ.ⵜⴰⴾⴾⵓⵣⵜ ⵜⴰ ⵜⴰⵂⴰⵜ ⵜⴰⵂⵔⵉⴾⴻ ⵜⴰ ⵜⴰⵈⵈⴰⵍ ⵜⴰⴾⴾⵓⵣⵜ ⴷⴰⵗ ⵜⴰⵈⵈⴰⵍ ⴰⴾⴾⵓⵣ ⵉⵉⵉⴰⵏ ⴰⴾⴾⵓⵣ ⵎⴻⵗⴷⴰ ⵜⵜⵓⵙⴽⴰⵔⵏ ⵉⴼⵔⴷⵉⵙⵏ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⵉⵖⵎⵔⵉⵏ ⵜⵉⴷⵙⵍⴰⵏⵉⵏ, ⵓⵔ ⵉⴳⵉ ⵜⵉⴷⵙⵜ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵜⵉⵖⵣⵉ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⴼⵓⵍⵉⵏ ⵏ ⴽⵕⴰⴹ ⵏ ⵜⵉⵙⴳⵡⵉⵏ. ⵔⴰⴷ ⵏⵔⴰⵔ ⵜⵉⴷⵜ ⵎⴽ ⵔⴰⴷ ⴽⵕⴰⴹ # >>> right_angle_triangle.call(3, 4, 5)\n# true\n# >>> right_angle_triangle.call(1, 2, 3)\n# false\ndef right_angle_triangle(a, b, c)\n","canonical_solution":"def right_angle_triangle(a, b, c)\n  sides = [a, b, c].sort\n  sides[0]**2 + sides[1]**2 == sides[2]**2\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_right_angle_triangle\n    candidate = method(:right_angle_triangle)\n    assert_equal(true, candidate.call(3, 4, 5))\n    assert_equal(false, candidate.call(1, 2, 3))\n    assert_equal(true, candidate.call(10, 6, 8))\n    assert_equal(false, candidate.call(2, 2, 2))\n    assert_equal(true, candidate.call(7, 24, 25))\n    assert_equal(false, candidate.call(10, 5, 7))\n    assert_equal(true, candidate.call(5, 12, 13))\n    assert_equal(true, candidate.call(15, 8, 17))\n    assert_equal(true, candidate.call(48, 55, 73))\n    assert_equal(false, candidate.call(1, 1, 1))\n    assert_equal(false, candidate.call(2, 2, 10))\n  end\nend\n"},{"task_id":"HumanEval_158","nl":"taq_Tfng","pl":"rb","prompt":"ⵔⴻⵜⵔⵓⵏ ⵆⴰⵔⴻⵛⵜⴻⵔⵙ , ⴰⴷⴷoⴱⴰⵜ ⵓⴰ ⴰⵣⵣⴰⵔⴰⵏ ⴷⴰⵗ ⴰⵍⴾⴰⴷ ⵏ ⴰⵍⵎⴰⵗⵏⴰ ⵏ ⵉⵙⵎⴰⵓⴰⵏⵎⴽ ⴳⴰⵏ ⵉⵙⴽⴽⵉⵍⵏ ⵉⵎⵢⴰⵏⴰⵡⵏ ⴽⵉⴳⴰⵏ, ⴷⴰ ⵉⵜⵜⴰⵎⵥ ⵓⵎⵙⴳⵏⴰⴼ ⴽⵉⴳⴰⵏ ⵏ ⵜⴳⵓⵔⵉⵡⵉⵏ. ⵔⴰⵏⵜⵔ ⵜⴳⵓⵔⵉ ⵙ ⵓⵟⵟⵓⵏ ⴰⵎⵇⵔⴰⵏ ⵔⵔⴰⵢ ⵜⴰⵡⵓⵔⵉ ⵏⵏⴰ ⵉⵜⵜⴰⵎⵥⵏ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵙⵉⴹⵏⵏ.# >>> find_max.call([\"name\", \"of\", \"string\"])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n","canonical_solution":"def find_max(words)\n  # Helper function to count unique characters\n  def unique_char_count(word)\n    word.chars.uniq.size\n  end\n\n  words.max_by { |word| [unique_char_count(word), -word] }\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\", \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\", \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\", \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\", \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n  end\nend\n"},{"task_id":"HumanEval_159","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ: ⵎⴽ ⵓⵔ ⵍⵍⵉⵏ ⵉⵔⵖⵉⵢⵏ ⵉⵇⵇⵉⵎⵏ, ⵔⴰⴷ ⵜⵙⵙⵓⵜⵎ ⴰⴽⴽⵡ ⵉⵔⵖⵉⵢⵏ ⵉⵇⵇⵉⵎⵏ, ⵎⴰⴽⴰ ⵔⴰⴷ ⵜⵇⵇⵉⵎ ⵜⵔⵖⵉ.ⴰⴹⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵏⵏⴰ ⴷ ⵉⵇⵇⵉⵎⵏ ⴷⴼⴼⵉⵔ ⵏ ⵡⵓⵜⵛⵉ ⵏⵏⴽ ] ⵉⵇⵏⴻⵏ ⴰⴷ ⵜⴰⵔⴻⴷ ⴰⵎⵙⴳⵏⴰⴼ ⵏ [ⴰⵎⴹⴰⵏ ⴰⵖⵓⵍⴰⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵏⵏⴰ ⵜⵙⵙⵓⵜⵔⴷ ⴷⴼⴼⵉⵔ ⵏ ⵜⴰⵢⵢⵔⵉ, ⵎⴰⵛⴰ ⴷⵖⴰ ⵉⵇⵇⴰⵏⴷ ⴰⴷ ⵜⵜⵓⵜⵜⵓⵢⴷ ⴽⵉⴳⴰⵏ ⵏ ⵉⴽⴰⵔⵓⵟⵏ ⵃⵎⴰ ⴰⴷ ⵜⵙⵙⵎⵓⵔⵎ ⵜⴰⵢⵢⵉⵔⴰ ⵏ ⵡⴰⵙⵙ.ⴻⵈⴰⵍⴻ ⵜⴰⵛⵉⵛⴻⵜ ⵜⴰ ⵜⴰⴶⴰⵏⴻⵏ ⴰⵛⴻⵛ, ⴰⴷ ⴾⴰⵍⴰ ⵉⴶⵔⴰⵓⴻⵜ ⴰⴶⵓⴷⴰⵏ ⴰⵏ ⵜⴰⵛⵉⵛⴻⵜ ⴰⵏ ⴾⴰⵔⵓⵜⴻⵏ,# >>> eat.call(5, 6, 10)\n# [11, 4]\n# >>> eat.call(4, 8, 9)\n# [12, 1]\n# >>> eat.call(1, 10, 10)\n# [11, 0]\n# >>> eat.call(2, 11, 5)\n# [7, 0]\n# Variables:\n# @number : integer\n# the number of carrots that you have eaten.\n# @need : integer\n# the number of carrots that you need to eat.\n# @remaining : integer\n# the number of remaining carrots thet exist in stock\n# Constrain:\n# * 0 <= number <= 1000\n# * 0 <= need <= 1000\n# * 0 <= remaining <= 1000\n# Have fun :)\ndef eat(number, need, remaining)\n","canonical_solution":"def eat(number, need, remaining)\n  total_eaten = number + [need, remaining].min\n  carrots_left = [remaining - need, 0].max\n  [total_eaten, carrots_left]\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_eat\n    candidate = method(:eat)\n    assert_equal([11, 4], candidate.call(5, 6, 10))\n    assert_equal([12, 1], candidate.call(4, 8, 9))\n    assert_equal([11, 0], candidate.call(1, 10, 10))\n    assert_equal([7, 0], candidate.call(2, 11, 5))\n    assert_equal([9, 2], candidate.call(4, 5, 7))\n    assert_equal([5, 0], candidate.call(4, 5, 1))\n  end\nend\n"},{"task_id":"HumanEval_160","nl":"taq_Tfng","pl":"rb","prompt":"ⴷⴰ ⵉⵜⵜⵉⵍⵉ ⴳ ⵓⵙⵔⵔⵓⵙ ⵏ ⵓⵎⵙⴽⴰⵔ ⵢⴰⵏ ⵓⵎⵙⴽⴰⵔ, ⴷ ⵓⵙⵔⵔⵓⵙ ⵏ ⵓⵎⵙⴽⴰⵔ ⵏ ⵓⵎⵙⴽⴰⵔ ⵙ ⵙⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ.ⵉⴳⴰ ⵓⴱⵢⵔⴰⵏⴷ ⵢⴰⵏ ⵓⵙⵏⵙⵍ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵓⵔ ⵉⴳⵉⵏ ⵉⵔⵉⵏⵉⵢⵏ.ⵜⵉⵖⵣⵉ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⵎⵙⵡⵓⵔⵉ ⵜⴳⴰ ⵜⵜ ⵜⵉⵖⵣⵉ ⵏ ⵓⵎⵙⴳⵏⴰⴼ ⵏ ⵓⵎⵙⵡⵓⵔⵉ ⵎⵉⵏⵓⵙ ⵢⴰⵏ.ⴰⵜⵡⵉⵍ: => ⵜⴰⵢⴰⴼⵓⵜ = 9 ⵜⴰⵢⴰⴼⵓⵜ = 2 + 3 * 4 - 5 ⴰⵙⵔⵔⵓⵙ = [2, 3, 4, 5] ⴰⵎⵙⵙⵎⵔⵙⴰⵍ['+', '*', '-'] ⴰⵍⵎⵉⵜⴰⵍ: ⴰⵙⵎⵓⵜⵜⴳ (**) ⴰⴱⵟⵟⵓ ⵏ ⵜⵣⴰⵍⵖⵉⵡⵉⵏ ( \/\/) ⴰⵙⴼⵓⴷⴷⵓ (*) ⵜⵓⴽⴽⵙⴰ ( - ) ⴰⵙⵎⵓⵏ ( +) ⵜⵉⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ ⵏ ⵓⵙⵉⵙⵙⵏ: ⵉⵙⵎ ⵏ ⵓⵙⵏⵓⵎⵎⵍ ⴷ ⵓⵙⵡⴰⵍⴰ ⵏ ⵓⵙⵎⵉⵍ ⴰⴷ. ⵜⴰⴳⵔⵡⴰⵏⵜ ⵜⵉⵙⵙ ⵙⵏⴰⵜ ⵜⴳⴰ ⵜⴰⴳⵔⵡⴰⵏⵜ ⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ. ⵙⵎⵔⵙⵏⵜ ⵙⵏⴰⵜ ⵏ ⵜⴳⵔⵡⴰⵏⵜ ⵉⵜⵜⵓⴼⴽⴰⵏ  ⵃⵎⴰ ⴰⴷ ⵜⵜⵓⵙⴽⴰⵔⵏⵜ ⵜⴱⵔⵉⴷⵉⵏ ⵏ ⵍⵊⵉⴱⵔ.ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵙⵉⵏ ⵉⵎⵙⴽⴰⵔⵏ ⵏ ⵉⵎⵙⴷⴷⵉⵜⵏ, ⴷ ⵓⵎⵙⴽⴰⵔ. ⴰⵎⵙⴷⴷⵉⵜ ⴰⵎⵣⵡⴰⵔⵓ ⵖⵓⵔⵙ ⵜⵉⵎⴳⴳⵉⵜⵉⵏ ⵏ ⵍⵊⵉⴱⵔ, ⴷ def do_algebra(operator, operand)\n","canonical_solution":"def do_algebra(operator, operand)\n  expression = operand[0].to_s\n  operator.each_with_index do |op, index|\n    if op == '\/\/'\n      expression += ' \/ ' + operand[index + 1].to_s\n    else\n      expression += ' ' + op + ' ' + operand[index + 1].to_s\n    end\n  end\n  eval(expression)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\", \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\", \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"\/\/\", \"*\"], [7, 3, 4]))\n  end\nend\n"},{"task_id":"HumanEval_161","nl":"taq_Tfng","pl":"rb","prompt":"ⴰⵍⵎⵉⵜⴰⵍ ⵜⴰⵏⵍⴰⵇⴱⴰⵍ ⵜⴰⵡⵓⵔⵉ ⴰⴷ ⵜⵕⵓⴹⵓ ⵜⵉⴼⵔⴽⵜ ⵏ ⵜⵢⴰⴼⵓⵜ.ⵎⴽ ⵓⵔ ⵉⵍⵍⵉ ⴳ ⵜⵉⴼⵔⵜ ⴽⵔⴰ ⵏ ⵡⴰⵔⵔⴰⵜⵏ, ⵙⵙⵓⵜⵍ ⵜⵉⴼⵔⵜ.ⵎⴽ ⵓⵔ ⵉⴳⵉ ⴰⵢⴰ ⵃⴹⵓ ⵖⵉⴽⵍⵍⵉ ⵉⴳⴰ.ⵎⴽ ⵜⴳⴰ s[i] ⵢⴰⵜ ⵜⴱⵔⴰⵜ, ⵙⵙⵓⵜⵔ ⵜⴰⵡⴰⵍⵜ ⵏⵏⵙ ⵙⴳ ⴷⴷⴰⵡ ⴰⵔ ⴰⴼⵍⵍⴰ ⵏⵖⴷ ⵙ ⵓⵎⵣⴰⵔⴰⵢ, ⴷⴰ ⵜⵜⵓⴼⴽⴰ ⵉⴽⵛⵛⵓⵎⵏ s.# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n","canonical_solution":"def solve(s)\n  if s =~ \/[a-zA-Z]\/\n    s.chars.map { |char| char =~ \/[a-zA-Z]\/ ? char.swapcase : char }.join\n  else\n    s.reverse\n  end\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\", candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"#$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"},{"task_id":"HumanEval_162","nl":"taq_Tfng","pl":"rb","prompt":"ⵎⴽ ⵉⴳⴰ 'text' ⵢⴰⵏ ⵓⴹⵕⵉⵚ ⵓⵔ ⵉⵍⵉⵏ ⴽⵔⴰ, ⵔⵉⵜⵓⵔⵏ nil.ⵙ ⵜⵉⴽⴽⵉ ⵏ \"ⵜⵉⴽⵙⵜ\" ⵏ ⵜⵉⴼⵉⵏⴰⵖ, ⵙⵓⵍⵏ ⵜⵉⴼⵉⵏⴰⵖ ⵏ \"ⵀⴰⵛⵉ\" ⵏ md5 ⵏⵏⵙ. # >>> string_to_md5.call(\"Hello world\")\n# \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n","canonical_solution":"require 'digest'\n\ndef string_to_md5(text)\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\", candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"))\n  end\nend\n"},{"task_id":"HumanEval_163","nl":"taq_Tfng","pl":"rb","prompt":"ⵙ ⵓⵎⴷⵢⴰ: ⴷ ⴱ, ⵙ ⵓⵍⵍⵙ ⵏ ⵓⵙⵙⴰⵔⵓ.ⴳ ⵜⵉⴽⴽⵉ ⵏ ⵙⵉⵏ ⵉⵎⴹⴰⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⴷⴷⴰⴷⵏ ⵉⵎⵏⵖⴰⵏⵏ a ⴷ b, ⵙⵙⴽⵛⵎ ⵉⵎⴹⴰⵏ ⵉⵎⵎⵔⵡⵉⵏ ⴳⵔ a # >>> generate_integers.call(2, 8)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(8, 2)\n# [2, 4, 6, 8]\n# >>> generate_integers.call(10, 14)\n# []\ndef generate_integers(a, b)\n","canonical_solution":"def generate_integers(a, b)\n  (a..b).to_a.concat((b..a).to_a).select { |num| num.even? }.uniq.sort\nend","tests":"require 'test\/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2, 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2, 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n  end\nend\n"}]