[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kp\u0254e \u0256a be xexl\u1ebddzesi eve a\u0256ewo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" D\u0254w\u0254\u0192e sia \u0192e nu\u014b\u0254\u014bl\u0254 enye nyagbe si me nu\u014b\u0254\u014bl\u0254wo \u0192e \u0192u\u0192o\u0192o ge\u0256e le. W\u00f2 ta\u0256odzinu enye be n\u00e0\u0256e wo \u0256e vovo \u0256e nyagbewo me eye n\u00e0tr\u0254 wo \u0192e \u014bk\u0254wo. \u0191u\u0192o\u0192owo le \u0256o\u0256o nu (wo domet\u0254 \u0256esia\u0256e \u0192e nu\u014b\u0254\u014bl\u0254wo le \u0256o\u0256o nu) eye womele wo n\u0254ewo me o. M\u00e8ga\u014be a\u0256aba \u0192u te\u0192e a\u0256eke dzi le nyagbewo me o. Kp\u0254\u0256e\u014bu:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Ne wots\u0254 xexl\u1ebddzesi si \u0192e xexl\u1ebddzesi le abe floating point ene la, woate \u014bu am\u00e3e \u0256e xexl\u1ebddzesi blibo (xexl\u1ebddzesi si lolo wu si le sue wu xexl\u1ebddzesi si wona) kple xexl\u1ebddzesi siwo nye decimal (\u0192e xexl\u1ebddzesi si tsi anyi la n\u0254a sue wu 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Woana w\u00f2 ga kple ga siwo n\u00e8ts\u0254na le ga me kple esiwo n\u00e8ts\u0254na le ga me le ga me \u0192e \u014bk\u0254wo le ga me si dze eg\u0254me kple ga home si mes\u0254 gb\u0254 o. W\u00f2 d\u0254deasi enye be n\u00e0kp\u0254e ne ga home si le ga me le ga me dzi la dzi \u0256e kp\u0254t\u0254 le ga home si mes\u0254 gb\u0254 o la dzi, eye le \u0263eyi\u0263i ma me la, ele be d\u0254w\u0254w\u0254a na\u0256o true. Ne menye nenema o la, ele be w\u00f2a\u0256o false. Kp\u0254\u0256e\u014bu:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Le numelolowo \u0192e numedzodzro me la, bu ak\u0254nta le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si le nu si si le nu si le nu si si le nu si si si le nu si si si le nu si le nu si si\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" De dzesi 'delimeter' le nu\u014b\u0254\u014bl\u0254 siwo le nu\u014b\u0254\u014bl\u0254awo dome dome\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" E\u028be sia \u0192e nu\u0192le nye \u0192u\u0192o\u0192o ge\u0256e siwo me nu\u0192le\u0192le siwo me nu\u0192le\u0192lewo le la le. Le \u0192u\u0192o\u0192o \u0256esia\u0256e me la, na nu\u0192le\u0192le siwo me nu\u0192le\u0192lewo le la \u0192e nu\u0192le\u0192le \u0192e akpa si lolo wu. Le kp\u0254\u0256e\u014bu me (() (()) \u0192e nu\u0192le\u0192le le akpa eve me eye ((())) le akpa et\u0254\u0303 me.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter input list of strings only for ones that contain given substring (Kpl\u0254 nya siwo le \u014b\u0254\u014bl\u0254dzesi me la \u0256o na esiwo me nya a\u0256e le)\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Le integers \u0192e list a\u0256e me la, tr\u0254na tuple si nye sum kple product si nye integers siwo kat\u00e3 le list la me. Empty sum an\u0254 s\u0254s\u0254m kple 0 eye empty product an\u0254 s\u0254s\u0254m kple 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Tso xexl\u1ebddzesi blibowo \u0192e \u014bk\u0254wo dzi la, w\u0254 xexl\u1ebddzesi siwo dzi woate \u014bu akp\u0254 nu le le \u0256o\u0256ow\u0254\u0256i me vase\u0256e \u0263eyi\u0263i a\u0256e dzi la \u0192e \u014bk\u0254wo.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Dzidze ne nyagbe si wots\u0254 na enye palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" A\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Le nyagbewo \u0192e \u0192u\u0192o\u0192o me la, tr\u0254 nyagbe si didi wu la. Gbugb\u0254 nyagbe gb\u00e3t\u0254 la ne nyagbe ge\u0256e le \u0192u\u0192o\u0192o me eye wo kat\u00e3 \u0192e didime le \u0256eka. Megbugb\u0254 nyagbe a\u0256eke ne nyagbewo \u0192e \u0192u\u0192o\u0192o me mele o.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Gbugb\u0254a ame eve siwo nye xexl\u1ebddzesi blibo a kple b \u0192e mama g\u00e3t\u0254 la v\u025b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" \u0189o\u0256o\u0256edzesi siwo kat\u00e3 le \u014bg\u0254dzesi siwo kat\u00e3 le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi siwo le \u014bg\u0254dzesi\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Etr\u0254na string si me numel\u0254 siwo wo\u0256o \u0256i le te\u0192ea le tso 0 va se \u0256e n.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Ne wots\u0254 nyagbe a\u0256e na w\u00f2 la, kp\u0254 ame vovovo nenie le eme (\u0256ikeke mele eme o be wo domet\u0254 nenie nye g\u00e3 alo sue)\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" E\u028bevi si le d\u0254 sia me enye ha\u0192onuwo \u0192e ha si le ASCII \u0192e n\u0254n\u0254me t\u0254x\u025b a\u0256e me. W\u00f2 d\u0254 enye be n\u00e0\u0256e ha sia me eye n\u00e0na xexl\u1ebddzesi siwo s\u0254 kple zi nenie wo domet\u0254 \u0256e sia \u0256e \u0192e \u0256i\u0256i me. \u014ak\u0254 a\u0256e le afisia: 'o' - \u0256i\u0256i blibo, si n\u0254a anyi zi ene 'o' - \u0256i\u0256i af\u00e3, si n\u0254a anyi zi eve''o' - \u0256i\u0256i ene, si n\u0254a anyi zi \u0256eka\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Kp\u0254 zi nenie woate \u014bu akp\u0254 nyagb\u0254gbl\u0254 a\u0256e le nyagb\u0254gbl\u0254 gb\u00e3t\u0254a me. Xl\u1ebd nyagb\u0254gbl\u0254 siwo to vovo.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Numerowo \u0192e xexl\u1ebddzesi si wo\u0256o \u0256i le te\u0192e si tso 'a\u028baa' va se \u0256e 'asieke' la nye nu\u014b\u0254\u014bl\u0254. E\u028be\u0192onuwo nye 'a\u028baa', '\u0256eka', 'eve', 'et\u0254\u0303', 'ene', 'at\u0254\u0303', 'ade', 'adre', 'enyi' kple 'asieke.' E\u0256ea xexl\u1ebddzesi siwo wo\u0256o \u0256i tso suet\u0254 va se \u0256e g\u00e3t\u0254 la \u0256a\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Ne \u00e8kp\u0254 xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi eve me (si \u0192e didime nye eve ya teti) la, tia eve siwo te \u0256e wo n\u0254ewo \u014bu wu eye n\u00e0ts\u0254 wo a\u0256o \u0256o\u0256o nu (xexl\u1ebddzesi si le sue wu, xexl\u1ebddzesi si le g\u00e3 wu).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Ne \u00e8na xexl\u1ebddzesiwo (siwo me nu eve le) \u0192e \u014bk\u0254wo le la, z\u00e3a linear transform \u0256e \u014bk\u0254a \u014bu, ale be xexl\u1ebddzesi suet\u0254 nava zu 0 eye g\u00e3t\u0254 nava zu 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers (Ts\u0254 Python \u0192e xexl\u1ebddzesiwo kat\u00e3 na numegbewo ko)\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Xexl\u1ebddzesi si wots\u0254 \u0256o kpe kpe edzi be enye nyate\u0192e\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Le xexl\u1ebddzesi n a\u0256e \u014bu la, di xexl\u1ebddzesi si lolo wu si mam\u00e3 n s\u0254s\u0254e, si le sue wu n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Ets\u0254 ame\u0192omevi siwo wots\u0254 w\u0254 numekuku la \u0192e xexl\u1ebddzesi tso suet\u0254 dzi va se \u0256e g\u00e3t\u0254 dzi. Ehi\u00e3 be woa\u014bl\u0254 nu\u0192omevi \u0256esia\u0256e \u0192e xexl\u1ebddzesi si s\u0254 kple zi nenie w\u00f2adze le nu\u0192omevi me. Ehi\u00e3 be xexl\u1ebddzesi si woade la nas\u0254 kple nu\u0192omevi siwo kat\u00e3 wots\u0254 w\u0254 numekuku la \u0192e xexl\u1ebddzesi\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \u00d0e nusiwo kat\u00e3 dz\u0254 wu zi \u0256eka la \u0256a le xexl\u1ebddzesi blibowo \u0192e \u014bk\u0254 me. Na nusiwo kp\u0254t\u0254 la nan\u0254 \u0256o\u0256o \u0256eka me abe alesi wow\u0254e le numedzodzroa me ene.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Ne \u00e8le nyagbe a\u0256e si wots\u0254 nu\u014bl\u0254tiwo \u014bl\u0254m la, tr\u0254 \u014b\u0254\u014bl\u0254dzesi suewo na \u014b\u0254\u014bl\u0254dzesi g\u00e3wo eye n\u00e0tr\u0254 \u014b\u0254\u014bl\u0254dzesi g\u00e3wo na \u014b\u0254\u014bl\u0254dzesi suewo.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" \u0189o stringwo \u0192e list \u0256e string \u0256eka me\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Dzidze string siwo dze eg\u0254me kple \u014bk\u0254 a\u0256e ko le string siwo \u0192e \u014bk\u0254 le wo me la me.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"\u00d0i xexl\u1ebddzesi siwo nye dzidzimegbegbl\u1ebdwo ko le nu\u014bl\u0254\u0256ia me.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Ne xexl\u1ebddzesi a\u0256e nye gb\u00e3t\u0254 la, egatr\u0254na va nye nyate\u0192e, eye ne menye nenema o la, egadzena a\u028batso.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Edzroa polynomial kple coefficients xs le nu x. return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"D\u0254w\u0254\u0192e sia x\u0254a \u014bk\u0254dzesi l eye w\u00f2\u0256oa \u014bk\u0254dzesi l' si nye be l' s\u0254 kple l le \u014bk\u0254dzesi siwo womate \u014bu ama \u0256e et\u0254\u0303 o me, eye e\u0192e asix\u0254x\u0254 le \u014bk\u0254dzesi siwo womate \u014bu ama \u0256e et\u0254\u0303 o me la s\u0254 kple \u014bk\u0254dzesi siwo s\u0254 kple l, gake wo\u0256\u0254 wo \u0256o.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Etr\u0254na nu siwo wota \u0256e \u0256o\u0256o nu le list me\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Etr\u0254na nu vevi si le list la me la \u0192e agb\u0254s\u0254s\u0254me.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Xl\u1ebd zi nenie xexl\u1ebddzesi 7 dze le xexl\u1ebddzesi siwo mede n o siwo woma \u0256e 11 alo 13 me.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"D\u0254w\u0254\u0192e sia x\u0254a \u014bk\u0254dzesi l eye w\u00f2\u0256oa \u014bk\u0254dzesi l' si nye be l' s\u0254 kple l le numedzesi siwo nye odd me, eye e\u0192e asix\u0254x\u0254wo le numedzesi siwo nye even me s\u0254 kple l \u0192e numedzesi siwo nye even me t\u0254, gake wo\u0256\u0254 wo \u0256o.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    Etr\u0254na nyagbe siwo wots\u0254 nu\u014b\u0254\u014bl\u0254dzesi et\u0254\u0303 \u0192e \u0192u\u0192o\u0192owo w\u0254 \u0256o\u0256o na.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib \u0256oa xexl\u1ebddzesi si nye Fibonacci \u0192e xexl\u1ebddzesi si nye prime h\u00e3 la te\u0192e.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero x\u0254a integers \u0192e list abe input ene. E\u0256oa true ne nu et\u0254\u0303 le list la me siwo \u0192e sum nye zero, eye false ne menye nenema o.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Bu m\u0254 a\u0256e si nye m\u0254 z\u0254z\u0254 si to m\u0254 \u0256eka p\u025bp\u025bp\u025b, si didi didi la \u014bu kp\u0254. \u01b2u n le \u028bum tso miame yi \u0256usime; le \u0263eyi\u0263i ma ke me la, \u028bu n bubu siwo to m\u0254 \u0256eka la le \u028bum tso miame yi miame. \u01b2u eveawo dze eg\u0254me le didi\u0192e tso wo n\u0254ewo gb\u0254. \u01b2u \u0256esia\u0256e le du \u0256eka me. Wogbl\u0254na be \u028bu eve \u0192oa wo n\u0254ewo ne \u028bu si le \u028bum tso miame yi \u0256usime la \u0192o \u028bu si le \u028bum tso miame yi miame la. Gake \u028buawo s\u1ebdna eye woses\u1ebdna ale gbegbe; le esia ta, woyia edzi n\u0254a \u028bua me abe \u0256e wome\u0192o wo n\u0254ewo o ene. D\u0254w\u0254\u0256ui sia naa \u028bukuk\u0254 siawo \u0192e \u028buk\u0254k\u0254\u0256i \u0192e xexl\u1ebdme.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Woatr\u0254a nu siwo wots\u0254 1 dzi \u0256e edzi la \u0256e wo \u014bu.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero x\u0254a integers \u0192e list abe input ene. E\u0256oa true ne nu eve le list la me siwo \u0192e sum nye zero, eye false ne menye nenema o.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Tr\u0254 x si nye numeral \u0192e g\u0254me\u0256okpe la na x si nye numeral \u0192e g\u0254me\u0256okpe. tr\u0254 x si nye numeral \u0192e g\u0254me\u0256okpe la na x si nye numeral la.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Ne wots\u0254 axa \u0192e didime kple te\u0192e si wotr\u0254na \u0256o \u0192e lolome na dzogoe et\u0254\u0303 la,\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 xexl\u1ebddzesiwo \u0192e \u0256o\u0256o nye \u0256o\u0256o si \u0256i Fibbonacci \u0192e \u0256o\u0256o si me nyawo le si me nyawo le abe esiawo ene: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Taflatse \u014bl\u0254 d\u0254deasi a\u0256e si ana n\u00e0bu ak\u0254nta le fib4 xexl\u1ebddzesiwo \u0192e \u0256o\u0256o \u0192e nu enelia \u014bu nyuie. M\u00e8gaz\u00e3 gbugb\u0254gagb\u0254gagb\u0254 o.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"\u0189o\u0256owo \u0192e domedome le list l me.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Kp\u0254e \u0256a be nyagbe si wots\u0254 \u0256o la nye palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Gbugb\u0254 2^n modulo p (bu xexl\u1ebddzesi \u014bu nyuie).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    tr\u0254a asi le \u014b\u0254\u014bl\u0254dzesi \u0256esia\u0256e \u014bu 5 le alfabeta me ts\u0254 tr\u0254a asi le \u014b\u0254\u014bl\u0254dzesi si wots\u0254 de dzesie \u014bu.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels nye d\u0254w\u0254na si x\u0254a nyagbewo eye w\u00f2\u0256oa nyagbewo siwo me nyagbewo mele o.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t. \u00d0\u0254 nyate\u0192e ne xexl\u1ebddzesi siwo kat\u00e3 le list l me le te\u0192ete\u0192e t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Ts\u0254 xexl\u1ebddzesi eve x kple y kpe\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Kp\u0254e \u0256a be \u014b\u0254\u014bl\u0254dzesi \u0256eka t\u0254gbi le nya eve a\u0256ewo me h\u00e3.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Gbl\u0254 Fibonacci xexl\u1ebddzesi si nye n-t\u0254.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets nye \"<\" kple \">\" \u0192e string. return True ne bracket \u0256e sia \u0256e si le \u028bu\u028bu me la nye bracket si le nu \u0192om.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Return True nye list elements siwo le dzidzim \u0256e edzi alo le to yim.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Etr\u0254na na nu siwo le abe \u0256eka ene siwo wota \u0256e \u0256o\u0256o nu le nu\u014bl\u0254\u0256i eve me.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Gbugb\u0254 n \u0192e akpa vevi g\u00e3t\u0254 v\u025b. Ts\u0254e be n > 1 eye menye akpa vevi o.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n nye d\u0254 si wots\u0254na \u0192oa xexl\u1ebddzesi siwo tso 1 va se \u0256e n nu \u0192u.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets nye string si nye \"(\" kple \"\". return True ne bracket si le \u028bu\u028bu la nye bracket si le nu \u0192om.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs nye polynomial \u0192e koefi\u0256iz\u025b. xs[0] + xs[1] * x + xs[2] * x^2 +.... \u00d0\u0254 polynomial sia \u0192e derivative le m\u0254 ma ke nu.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"FibFib xexl\u1ebddzesiwo \u0192e \u0256o\u0256o nye \u0256o\u0256o si s\u0254 kple Fibbonacci \u0192e \u0256o\u0256o si me nyawo le: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nTs\u0254 dodokp\u0254 bubuwo kpe \u0256e e\u014bu.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Z\u0254 x \u0192e xexl\u1ebddzesi siwo le x me la le nudzra\u0256o\u0192e, tr\u0254 wo \u0256e \u0256usime to wo t\u0254tr\u0254 me eye n\u00e0tr\u0254 wo\u0192e xexl\u1ebddzesiwo w\u00f2azu string. Ne shift > xexl\u1ebddzesiwo la, tr\u0254 xexl\u1ebddzesi siwo le x me la \u0256e megbe.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"D\u0254deasi \u014al\u0254 d\u0254deasi si x\u0254a nyagbe abe nu\u014b\u0254\u014bl\u0254 ene eye w\u00f2\u0256oa ASCII \u0192e dzesi siwo le etame \u0192e xexl\u1ebddzesi ko \u0192e xexl\u1ebddzesi gb\u0254. Kp\u0254\u0256e\u014buwo: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Le d\u0254 sia me la, woana nyagbe si le tsitre \u0256i na atadi kple a\u014buti siwo woma \u0256e atikutsetsewo \u0192e kusi me la w\u00f2. Atiku sia me atadi, a\u014buti, kple mango atikutsetsewo le. Ne nyagbe si le tsitre \u0256i na a\u014butiwo kple atadiwo \u0192e xexl\u1ebdme kple xexl\u1ebdme blibo si le tsitre \u0256i na atikutsetsewo \u0192e xexl\u1ebdme le kusi me la, gbugb\u0254 \u0192o asi le atikutsetse siwo le kusi la me \u0192e xexl\u1ebdme. le kp\u0254\u0256e\u014bu me: fruit_distribution\"5(atadi kple a\u014buti 6\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 atadi kple a\u014buti 1,3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 atadi kple a\u014buti 3, 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 atadi kple a\u014buti 1,20) \",1 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Ne \u00e8kp\u0254 nu siwo le abe ati a\u0256e \u0192e al\u0254wo ene siwo me xexl\u1ebddzesi siwo nye negative mele o la, w\u00f2 d\u0254e nye be n\u00e0\u0256e nu siwo le wo dome la domet\u0254 \u0256eka le wo me ahana w\u00f2atr\u0254e. Ne \u00e8kp\u0254 nu siwo le wo me siwo \u0192e xexl\u1ebddzesi nye eve la, ekema tr\u0254 nu si \u0192e xexl\u1ebddzesi le sue wu la. Ne xexl\u1ebddzesi siwo le wo me siwo \u0192e xexl\u1ebddzesi nye eve la s\u0254 gb\u0254 la, tr\u0254 nu si \u0192e xexl\u1ebddzesi le sue wu la. Ne xexl\u1ebddzesi siwo le wo me la mele eve o alo nu siwo le wo me la le \u0192u\u0192lu la, tr\u0254 nu si le sue wu la. Kp\u0254\u0256e\u014bu 1: M\u0254\u0256e\u0256e: [4,2,3] M\u0254\u0256e\u0256e: [2, 1] M\u0254\u0256e\u0256e: 2 nye xexl\u1ebddzesi si le sue wu, eye 2 nye xexl\u1ebddzesi si le sue wu. Kp\u0254\u0256e\u014bu 2: M\u0254\u0256e\u0256e: [1,2,3] M\u0254\u0256e\u0256e:\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Ne \u00e8na ame\u0192omevi a\u0256e si nye xexl\u1ebddzesi blibowo \u0192e xexl\u1ebddzesi la, kp\u0254 nu siwo hi\u00e3 be woatr\u0254 asi le wo \u014bu hafi woate \u014bu aw\u0254 nu\u0192omevi si nye palindromic la. Nu\u0192omevi si nye palindromic nye nu\u0192omevi si woxl\u1ebdna le m\u0254 \u0256eka ke nu yi megbe kple \u014bg\u0254. Le t\u0254tr\u0254 \u0256eka me la, \u00e0te \u014bu atr\u0254 asi le nu\u0192omevi \u0256eka \u014bu na nu bubu \u0256esia\u0256e. Le kp\u0254\u0256e\u014bu me: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"\u014al\u0254 d\u0254 si ne xexl\u1ebddzesi si wona la nye xexl\u1ebddzesi gb\u00e3t\u0254 3 \u0192e dzi\u0256eleme la, enye nyate\u0192e eye ne menye nenema o la enye a\u028batso.\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"W\u00f2 d\u0254deasi enye be n\u00e0\u014bl\u0254 d\u0254deasi si ana n\u00e0kp\u0254 be enye nyate\u0192e ne xexl\u1ebddzesi x nye n \u0192e \u014bus\u1ebd si le b\u0254b\u0254e eye enye a\u028batso le go bubuwo me. x nye \u014bus\u1ebd si le b\u0254b\u0254e si le b\u0254b\u0254e si ne n**int=x Le kp\u0254\u0256e\u014bu me: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Wo\u0256o d\u0254 na w\u00f2 be n\u00e0\u014bl\u0254 d\u0254 si x\u0254a xexl\u1ebddzesi ade\u0256ek\u025b me abe nyagbe ene eye w\u00f2xl\u1ebda xexl\u1ebddzesi ade\u0256ek\u025b me xexl\u1ebddzesi siwo nye numeral gb\u00e3t\u0254wo (numeral gb\u00e3t\u0254, alo prime, nye xexl\u1ebddzesi si lolo wu 1 si menye xexl\u1ebddzesi sue eve \u0192e \u0192u\u0192o\u0192o o). Xexadecimal xexl\u1ebddzesiwoe nye 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Xexadecimal xexl\u1ebddzesiwoe nye 2, 3, 5, 7, 11, 13, 17,... Eyata ele be n\u00e0kp\u0254 xexl\u1ebddzesi siwo gb\u0254na \u0192e xexl\u1ebddzesi: 2, 3, 5, 7, B (= decimal 11), D (= decimal 13). De dzesii: \u00e0te \u014bu abu be nya si n\u00e8\u014bl\u0254 la nye nyate\u0192e alo nyagbe \u0192u\u0192lu \u0263esia\u0263i, eye dzesi siwo nye A,B,C,D,E,F, nye nyagbe g\u00e3wo \u0263esia\u0263i. Kp\u0254\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Woana xexl\u1ebddzesi si le xexl\u1ebddzesi ewo me na w\u00f2 eye w\u00f2 d\u0254e nye be n\u00e0tr\u0254e w\u00f2azu xexl\u1ebddzesi eve me. Ele be d\u0254w\u0254w\u0254a nagbugb\u0254 nyagbe a\u0256e, si me nya \u0256e sia \u0256e le tsitre \u0256i na xexl\u1ebddzesi eve me. \u014ak\u0254 \u0256e sia \u0256e le nyagbea me anye '0' alo '1'. \u014ak\u0254 eve bubu an\u0254 'db' le nyagbea \u0192e g\u0254medzedze kple nuwuwu. \u014ak\u0254 bubu siwo le eme la akpe \u0256e \u0256o\u0256ow\u0254\u0192ea \u014bu. Kp\u0254\u0256e\u014buwo: decimal_to_binary ((15) # tr\u0254a \"db1111db\" decimal_to_binary32) # tr\u0254a \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Wona akplo s. W\u00f2 d\u0254 enye be n\u00e0kp\u0254e \u0256a be akploa nye dzidz\u0254a alo menye dzidz\u0254a o. Akplo nye dzidz\u0254a ne e\u0192e didime nye 3 ya teti eye \u014b\u0254\u014bl\u0254dzesi 3 siwo kpl\u0254e \u0256o la domet\u0254 \u0256e sia \u0256e to vovo. Le kp\u0254\u0256e\u014bu me: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd) => True is_happy ((aabb) => False is_happy ((adb) => True is_happy ((xyy)) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Le kwasi\u0256a maml\u025bt\u0254 me le suku \u0192e nuwuwu la, nufiala la na dzesi sukuviawo. Nufiala la w\u0254 e\u0192e \u014but\u0254 \u0192e dzesi\u014b\u0254\u014bl\u0254. Kuxia koe nye be, e\u014bl\u0254 dzesi si w\u00f2z\u00e3 ts\u0254 \u0256o dzesi sukuviawo la be. Ena nufiala la \u0192e dzesiwo \u0192e xexl\u1ebddzesi w\u00f2 eye ele be n\u00e0\u014bl\u0254 d\u0254 si ate \u014bu ana dzesi siwo le l\u025bta me la \u0192e xexl\u1ebddzesi le l\u025bta me la le kpl\u0254\u0303 si gb\u0254na dzi: GPA. L\u025bta \u0192e xexl\u1ebddzesi 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"\u014al\u0254 d\u0254 si x\u0254a string eye w\u00f2tr\u0254na na True ne string \u0192e didime nye prime number alo False ne menye nenema o Kp\u0254\u0256e\u014bu prime_length{'Hello') == True prime_length{'abcdcba') == True prime_length{'kittens') == True prime_length{'orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Ne wots\u0254 xexl\u1ebddzesi nyui n na la, gbugb\u0254 xexl\u1ebddzesi siwo nye xexl\u1ebddzesi nyui siwo \u0192e xexl\u1ebddzesi nye n eye wodze eg\u0254me alo wua enu kple 1 la \u0192e xexl\u1ebddzesi agb\u0254s\u0254s\u0254me.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Ne wode dzesi xexl\u1ebddzesi blibo si nye N la, tr\u0254 e\u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo kat\u00e3 \u0192e xexl\u1ebddzesi le binary me. Kp\u0254\u0256e\u014bu Ne N = 1000 la, xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesi anye 1 ne ele be woa\u0256o \"1\" le gbeadzi. Ne N = 150 la, xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesi anye 6 ne ele be woa\u0256o \"110\". Ne N = 147 la, xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesi anye 12 ne ele be woa\u0256o \"1100\". Nu\u0192onuwo: @N xexl\u1ebddzesi blibowo \u0192e xexl\u1ebddzesiwo: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. Nu\u0192onu: xexl\u1ebddzesi siwo nye binary \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Ne wode xexl\u1ebddzesi siwo menye \u0192u\u0192lu o la, kpe xexl\u1ebddzesi siwo nye eve siwo le xexl\u1ebddzesi eve dzi la kpe. Kp\u0254\u0256e\u014buwo: kpe \u0192 ([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u014al\u0254 d\u0254 si x\u0254a nyagbe eye w\u00f2tr\u0254na e\u0192e \u0256o\u0256o nu. Nyagbe \u0192e \u0256o\u0256o nu nye nyagbe si me nyaawo kat\u00e3 (siwo dome woama kple te\u0192e) wots\u0254 nya yeye si me nyaawo kat\u00e3 le \u0256o\u0256o nu le \u0256o\u0256o nu le \u0256o\u0256o nu le ascii \u0192e asix\u0254x\u0254 nu. De dzesii: Ele be n\u00e0l\u00e9 nyagbewo kple te\u0192e siwo le \u0192u\u0192lu le nyagbea me \u0192e \u0256o\u0256o nu. Le kp\u0254\u0256e\u014bu me: anti_shuffle ((('Hi') tr\u0254na 'Hi' anti_shuffle ((('hello') tr\u0254na 'ehllo' anti_shuffle (('Hello World!!!') tr\u0254na 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Woana w\u00f2 2 dimensional data, abe nested lists, si \u0256i matrix, gake, to vovo na matrixwo la, axa \u0256esia\u0256e ate \u014bu akp\u0254 axa vovovo. Ne lst, kple integers x, la, di integers x le axa, eye na\u0256o tuples list, [(x1, y1), (x2, y2)...] ale be xta sia nye coordinate - (row, columns), si dze eg\u0254me kple 0. Tr\u0254 coordinates gb\u00e3 le axawo nu le \u0256o\u0256o si le dzi yim nu. Az\u0254 h\u00e3, tr\u0254 coordinates le axawo nu le axawo nu le \u0256o\u0256o si le \u0256i\u0256im nu. Kp\u0254\u0256e\u014buwo: get_row[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(], 1) [] ==\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Ne \u00e8na ame siwo menye negatives o \u0192e xexl\u1ebddzesiwo \u0192e \u0192u\u0192o\u0192o la, tr\u0254 asi le xexl\u1ebddzesi si n\u00e8na la \u014bu le \u0256o\u0256o nu ne xexl\u1ebddzesi siwo le \u0192u\u0192o\u0192o me la nye \u0256eka, alo ne xexl\u1ebddzesi siwo le \u0192u\u0192o\u0192o me la nye eve.\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"W\u0254 d\u0254deasi si nye encrypt si x\u0254a nyagbe abe nyagb\u0254gbl\u0254 ene eye w\u00f2tr\u0254na na nyagbe si wots\u0254 nyagbewo \u0256o la kple \u014b\u0254\u014bl\u0254dzesi si wotr\u0254na. Ele be woa\u0256\u0254li \u014b\u0254\u014bl\u0254dzesi la ale be \u014b\u0254\u014bl\u0254dzesiwo natr\u0254 \u0256e anyi eve dzi \u0256e te\u0192e eve. Le kp\u0254\u0256e\u014bu me: encrypt (('hi') tr\u0254na 'lm' encrypt (('asdfghjkl') tr\u0254na 'ewhjklnop' encrypt (('gf') tr\u0254na 'kj' encrypt (('et') tr\u0254na 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Wona xexl\u1ebddzesi blibowo \u0192e \u014bk\u0254wo w\u00f2. \u014al\u0254 d\u0254deasi si nye next_smallest (() si ana xexl\u1ebddzesi si nye evelia le xexl\u1ebddzesi siwo le xexl\u1ebddzesi suewo dome la. Ne xexl\u1ebddzesi ma meli o la, ekema e\u0256o \u0256eke o. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Woana nyagbewo \u0192e xexl\u1ebdme w\u00f2, eye w\u00f2 d\u0254deasi enye be n\u00e0xl\u1ebd nuxaxawo \u0192e xexl\u1ebdme. Nuxaxa nye nyagb\u0254gbl\u0254 si dzea eg\u0254me kple nya \"I\". '.', '?' alo '!'ye dea se\u0192o\u0192owo dome. Le kp\u0254\u0256e\u014bu me:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    \u014al\u0254 d\u0254deasi a\u0256e si x\u0254a gbedasi, eye w\u00f2\u014bl\u0254a nu le m\u0254 a\u0256e nu be w\u00f2ats\u0254 \u014b\u0254\u014bl\u0254dzesiwo kat\u00e3 \u0192e \u014b\u0254\u014bl\u0254dzesi g\u00e3wo kple suewo atr\u0254 asii, eye w\u00f2ats\u0254 \u014b\u0254\u014bl\u0254dzesi si dze te\u0192e eve le \u014b\u0254\u014bl\u0254dzesi ma \u014bg\u0254 le E\u028begbe alfabeta me a\u0256o \u014b\u0254\u014bl\u0254dzesi siwo kat\u00e3 le gbedasia me te\u0192e. Ts\u0254 \u014b\u0254\u014bl\u0254dzesiwo ko. Kp\u0254\u0256e\u014buwo:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Wona xexl\u1ebddzesi blibowo \u0192e \u014bk\u0254w\u00f2. Ele be n\u00e0kp\u0254 xexl\u1ebddzesi gb\u00e3t\u0254 g\u00e3t\u0254 eye n\u00e0ts\u0254 e\u0192e xexl\u1ebddzesi siwo wots\u0254 \u0192o xl\u00e3e \u0192e xexl\u1ebddzesi agb\u0254s\u0254s\u0254e. Kp\u0254\u0256e\u014buwo: Ne lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] la, ele be nu si n\u00e0\u014bl\u0254 la nanye 10 Ne lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] la, ele be nu si n\u00e0\u014bl\u0254 la nanye 25 Ne lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] la, ele be nu si n\u00e0\u014bl\u0254 la nanye 13 Ne lst = [0,724,32,71,99,32,60,91,83,0,5,6] la, ele be\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Ne nyag\u0254me\u0256egbal\u1ebd le esi la, tr\u0254na True ne nya\u0192okawo kat\u00e3 nye nyagbewo le \u014b\u0254\u014bl\u0254dzesi suewo me alo nya\u0192okawo kat\u00e3 nye nyagbewo le \u014b\u0254\u014bl\u0254dzesi g\u00e3wo me, ne menye nenema o tr\u0254na False. Ehi\u00e3 be d\u0254w\u0254w\u0254a natr\u0254na False ne nyag\u0254me\u0256egbal\u1ebda le \u0192u\u0192lu. Kp\u0254\u0256e\u014buwo: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) natr\u0254na True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) natr\u0254na False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) natr\u0254na False. check_dict_case{\"Name\":\"John\",\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"W\u0254 d\u0254deasi a\u0256e si x\u0254a xexl\u1ebddzesi si menye negatif\u0254 o eye w\u00f2nana xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye xexl\u1ebddzesi gb\u00e3t\u0254 siwo nye\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Dzidze d\u0254 si x\u0254a xexl\u1ebddzesi blibo eve eye w\u00f2nana wo \u0192e xexl\u1ebddzesi \u0256eka \u0192e xexl\u1ebddzesiwo \u0192e agb\u0254s\u0254s\u0254na. Ts\u0254e be nu si wots\u0254 de eme la nye nyate\u0192e \u0263esia\u0263i. Kp\u0254\u0256e\u014buwo: dzi\u0192oname ((148, 412) na\u0256o 16. dzi\u0192oname ((19, 28) na\u0256o 72. dzi\u0192oname ((2020, 1851) na\u0256o 0. dzi\u0192oname ((14,-15) na\u0256o 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Ne wots\u0254 nyagbe s na w\u00f2 la, xl\u1ebd nyagbe g\u00e3 siwo le \u014b\u0254\u014bl\u0254dzesi eve me. Le kp\u0254\u0256e\u014bu me: count_upper (('aBCdEf') ana 1 count_upper (('abcdefg') ana 0 count_upper (('dBBE') ana 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Ne \u00e8na xexl\u1ebddzesi blibo si nye n la, ele be n\u00e0na kpewo nan\u0254 anyi le dzidze n me. Kpewo le dzidze gb\u00e3t\u0254a me. Kpewo \u0192e xexl\u1ebddzesi le dzidze si kpl\u0254e \u0256o me enye: - xexl\u1ebddzesi si kpl\u0254e \u0256o si nye eve ne n nye eve. - xexl\u1ebddzesi eve si kpl\u0254e \u0256o ne n nye eve. Gbugb\u0254 kpewo \u0192e xexl\u1ebddzesi le dzidze \u0256e sia \u0256e me le \u014bk\u0254dzesi a\u0256e me, afisi nu si le index i nye kpewo \u0192e xexl\u1ebddzesi le dzidze (i+1) me. Kp\u0254\u0256e\u014buwo:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Woana nyagbewo \u0192e k\u0254me si wom\u00e3 kple k\u0254me alo te\u0192ewo. W\u00f2 d\u0254 enye be n\u00e0ma k\u0254me la \u0256e nyagbewo me eye n\u00e0tr\u0254 nyagbewo \u0192e \u0192u\u0192o\u0192o a\u0256e. Le kp\u0254\u0256e\u014bu me: words_string ((\"Medo gbe na w\u00f2, nye \u014bk\u0254e nye John\") == [\"Medo gbe na w\u00f2\", \"nye\", \"\u014bk\u0254\", \"enye\", \"John\"] words_string ((\"Ame \u0256eka, eve, et\u0254\u0303, ene, at\u0254\u0303, ade\") == [\"Ame \u0256eka\", \"eve\", \"et\u0254\u0303\", \"ene\", \"at\u0254\u0303\", \"ade\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"D\u0254w\u0254\u0192e sia x\u0254a xexl\u1ebddzesi nyui eve x kple y eye w\u00f2\u0256oa xexl\u1ebddzesi si nye xexl\u1ebddzesi si nye [x, y] kple [x, y] dome la \u0192e xexl\u1ebddzesi g\u00e3t\u0254. Ne xexl\u1ebddzesi ma meli o la, ke d\u0254w\u0254\u0192e la na\u0256o -1. Le kp\u0254\u0256e\u014bu me: choose_num ((12, 15) = 14 choose_num ((13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Wona xexl\u1ebddzesi siwo nye n kple m eve, eye w\u00f2 d\u0254e nye be n\u00e0bu xexl\u1ebddzesi siwo nye n va se \u0256e m (kple n kple m) \u0192e titina. \u0191o \u014bu\u0256o\u0256oa nu \u0192u va \u0256o xexl\u1ebddzesi si gogo wu eye n\u00e0tr\u0254 e\u014bu w\u00f2azu xexl\u1ebddzesi eve. Ne n lolo wu m la, tr\u0254 -1. Kp\u0254\u0256e\u014bu: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b11\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Ne wots\u0254 xexl\u1ebddzesi siwo nye x siwo nye ame blibowo \u0192e \u014bk\u0254wo na m\u00ed la, m\u00edana xexl\u1ebddzesi siwo kat\u00e3 nye x siwo nye ame blibowo \u0192e \u014bk\u0254wo la \u0192e \u014bk\u0254wo nan\u0254 \u0256o\u0256o nu.\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Ne \u00e8na xexl\u1ebddzesi blibowo \u0192e \u0192u\u0192o\u0192o a\u0256e la, w\u0254 xexl\u1ebddzesi blibo siwo le 1 kple 9 dome la \u0192e \u0256o\u0256o, tr\u0254 asi le xexl\u1ebddzesi siwo le \u0192u\u0192o\u0192o si me la \u014bu, eye n\u00e0ts\u0254 xexl\u1ebddzesi siwo s\u0254 na wo la a\u0256\u0254li wo domet\u0254 \u0256e sia \u0256e. Le kp\u0254\u0256e\u014bu me: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 1, 1] return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"] Ne \u0192u\u0192o\u0192o la le \u0192u\u0192lu la, tr\u0254 asi le xexl\u1ebddzesi a\u0256e \u014bu: arr = [] return [] Ne xexl\u1ebddzesi a\u0256e le \u0192u\u0192o\u0192o si me la, \u014be a\u0256aba \u0192u edzi: arr = [1, -1, 55] -> arr -> [1, 55]\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" W\u0254 d\u0254deasi si nye f si x\u0254a n abe parameter ene, eye w\u00f2nana n \u0192e lolome \u0192e list, si me nu si le index i \u0192e asix\u0254x\u0254 nye i \u0192e factorial ne i nye eve alo xexl\u1ebddzesi siwo tso 1 va se \u0256e i \u0192e xexl\u1ebddzesi. i dze eg\u0254me tso 1. i \u0192e factorial enye xexl\u1ebddzesi siwo tso 1 va se \u0256e i \u0192e xexl\u1ebddzesi (1 * 2 *... * i). Kp\u0254\u0256e\u014bu: f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Ne wode dzesi xexl\u1ebddzesi blibo si nye n la, tr\u0254na na tuple si me xexl\u1ebddzesi blibo siwo nye eve kple eve siwo le \u0256o\u0256o si nye ((1, n) me la le. Kp\u0254\u0256e\u014bu 1: \u014ag\u0254donya: 3 \u014ag\u0254donya: (1, 2) \u014ag\u0254donya: \u014ag\u0254donyawo nye 1, 2, 3. wo domet\u0254 \u0256eka nye eve, eye eve nye eve. Kp\u0254\u0256e\u014bu 2: \u014ag\u0254donya: 12 \u014ag\u0254donya: (4, 6) \u014ag\u0254donya: \u014ag\u0254donyawo nye 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. wo domet\u0254 ene nye eve, eye wo domet\u0254 6 nye eve. De dzesii: 1. 1 <= n <= 10^3 2. tuple tr\u0254na na xexl\u1ebddzesi blibo siwo nye eve kple eve \u0192e xexl\u1ebddzesi.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    \u014al\u0254 d\u0254deasi count_nums si x\u0254a xexl\u1ebddzesi blibowo \u0192e \u0192u\u0192o\u0192o eye w\u00f2nana numel\u0254\u0303 siwo \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi nye 0. Ne xexl\u1ebddzesi a\u0256e nye v\u0254\u0303 la, ekema e\u0192e dzesi gb\u00e3t\u0254 anye v\u0254\u0303: le kp\u0254\u0256e\u014bu me -123 \u0192e dzesi nye -1, 2, kple 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"E\u028bevi a\u0256e le m\u00eda si si me xexl\u1ebddzesi N le. E\u028bevi la me xexl\u1ebddzesiwo an\u0254 \u0256o\u0256o nu le \u0256o\u0256o nu. W\u00f2 d\u0254deasi enye be n\u00e0nya ne anya w\u0254 be n\u00e0na xexl\u1ebddzesi a\u0256e nan\u0254 \u0256o\u0256o nu le \u0256o\u0256o nu si mele to yim o to d\u0254w\u0254w\u0254 si gb\u0254na dzi w\u0254w\u0254 le xexl\u1ebddzesi si wona la dzi: Wo\u0256e m\u0254 na w\u00f2 be n\u00e0w\u0254 \u0256usime\u028bu\u028bu\u028bu \u0192e d\u0254w\u0254w\u0254 zi ale si n\u00e8di. \u014autinya \u0256eka si le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim le to yim\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Le kuxi sia me la, \u00e0w\u0254 d\u0254 a\u0256e si x\u0254a xexl\u1ebddzesiwo \u0192e \u014bk\u0254wo le xexl\u1ebddzesi eve me, eye w\u00f2akp\u0254e \u0256a be anya w\u0254 be woadzra nu\u014b\u0254\u014bl\u0254awo \u0256o \u0256e wo n\u0254ewo dome be lst1 nanye xexl\u1ebddzesi evewo \u0192e \u014bk\u0254wo ko. Mome \u0256e nu\u014b\u0254\u014bl\u0254 siwo woadzra \u0256o \u0256e lst1 kple lst2 dome la \u0192e xexl\u1ebddzesi dzi o. Ne anya w\u0254 be woadzra nu\u014b\u0254\u014bl\u0254awo \u0256o \u0256e lst1 kple lst2 dome be lst1 \u0192e nu\u014b\u0254\u014bl\u0254awo kat\u00e3 nanye xexl\u1ebddzesi evewo la, gbugb\u0254 \"YES\" \u0256o. Ne menye nenema o la, gbugb\u0254 \"NO\" \u0256o. Le kp\u0254\u0256e\u014bu me: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" Wobui be nu\u014b\u0254\u014bl\u0254awo man\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Ne wots\u0254 nyagbe a\u0256e si nye nyagbe siwo nye nyagbe siwo me nyagbewo le la \u0192e xexl\u1ebdme \u0256o la, gbugb\u0254 \u014bl\u0254 nyagbe si me nyagbeawo \u0192e xexl\u1ebdme s\u0254 gb\u0254 le la. Ne \u014b\u0254\u014bl\u0254dzesi ge\u0256e s\u0254 le wo me la, gbugb\u0254 \u014bl\u0254 wo kat\u00e3. Kp\u0254\u0256e\u014bu: histogram ((a b c) == {'a': 1, 'b': 1, 'c': 1} histogram ((a b b a') == {'a': 2, 'b': 2} histogram ((a b c a b') == {'a': 2, 'b': 2} histogram ((b b a') == {'b 4}: histogram (a b b) == {'b 4}: histogram (a b b') == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"D\u0254w\u0254\u0192e Wona m\u0254\u0303 eve m\u00ed s kple c, ele be n\u00e0\u0256e \u014b\u0254\u014bl\u0254dzesi siwo kat\u00e3 le s me siwo s\u0254 kple \u014b\u0254\u014bl\u0254dzesi \u0256esia\u0256e le c me \u0256a eye n\u00e0dzro be nu si do tso eme la nye palindrome. Woy\u0254a m\u0254\u0303 a\u0256e be palindrome ne exl\u1ebdna kple megbe kple \u014bg\u0254. Ele be n\u00e0tr\u0254 nu si do tso eme la \u0192e \u0192u\u0192o\u0192o si me nu si do tso eme kple Nyate\u0192e\/A\u028batsoe le adzodzoe me. Kp\u0254\u0256e\u014bu: Ne s = \"abcde\", c = \"ae\", nu si do tso eme anye ('bcd',A\u028batsoe) Ne s = \"abcdef\", c = \"b\" nu si do tso eme anye ('acdef',A\u028batsoe) Ne s = \"abcdedcba\", c = \"ab\", nu si do tso eme anye ('cdedc',A\u028batsoe)\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Ne wots\u0254 nyagbewo \u0192e xexl\u1ebddzesi si me nyagbe \u0256esia\u0256e nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo nye xexl\u1ebddzesi siwo\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Ne wode xexl\u1ebddzesi blibowo numewo nu la, ke kp\u0254 xexl\u1ebddzesi siwo menye \u0192u\u0192lu o \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e xexl\u1ebddzesi suewo \u0192e\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Wona tsigowo \u0192e xadzra\u0256o\u0192e si \u0192e dzogoe nye dzogoe ene. Xadzra\u0256o\u0192e sia \u0192e axa \u0256eka le tsitre \u0256i na tsigo \u0256eka, eye xadzra\u0256o\u0192e sia \u0192e axa \u0256eka le tsitre \u0256i na tsi \u0192e agb\u0254s\u0254s\u0254 \u0256eka. Xadzra\u0256o\u0192e sia \u0192e xadzra\u0256o\u0192e le tsitre \u0256i na tsi \u0192e agb\u0254s\u0254s\u0254 \u0256eka. Xadzra\u0256o\u0192e sia \u0192e xadzra\u0256o\u0192e le tsitre \u0256i na tsi \u0192e agb\u0254s\u0254s\u0254 \u0256eka. Xadzra\u0256o\u0192e sia \u0192e xadzra\u0256o\u0192e le tsitre \u0256i na tsi \u0192e agb\u0254s\u0254s\u0254 \u0256eka. Xadzra\u0256o\u0192e sia \u0192e xadzra\u0256o\u0192e le tsitre \u0256i na tsi \u0192e agb\u0254s\u0254s\u0254 \u0256eka. Xadzra\u0256o\u0192e sia \u0192e xadzra\u0256o\u0192e le tsitre \u0256i na tsi \u0192e agb\u0254s\u0254s\u0254 \u0256eka. Xadzra\u0256o\u0192e sia \u0192e xadzra\u0256o\u0192e le tsitre \u0256i na tsi \u0192e agb\u0254s\u0254s\u0254 \u0256eka. Xadzra\u0256o\u0192e sia \u0192e xadzra\u0256o\u0192e le tsitre \u0256i na tsi \u0192e\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Le kata sia me la, ele be n\u00e0ts\u0254 xexl\u1ebddzesi siwo menye negatives o la \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesi si le wo \u0192e xexl\u1ebddzesi si le dzi yim la an\u0254 \u0256o\u0256o nu. Ne xexl\u1ebddzesi siwo s\u0254 le wo si la, ts\u0254 xexl\u1ebddzesi siwo le wo\u0192e xexl\u1ebddzesi si le dzi yim la n\u0254 te. Ele be n\u00e0z\u00e3e ale:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Ne \u00e8na nyagbe s kple xexl\u1ebddzesi n la, wobia tso asiw\u00f2 be n\u00e0w\u0254 d\u0254 a\u0256e si ana nya siwo kat\u00e3 le nyagbe s me siwo \u0192e gbe\u0256i\u0256iwo nye n la \u0192e \u014bk\u0254wo, ale be nya siawo nadze le nyagbe s me. Ne nyagbe s la le \u0192u\u0192lu la, ke d\u0254 la na\u014bl\u0254 \u014bk\u0254 siwo le \u0192u\u0192lu. De dzesii: \u00e0te \u014bu abu be nyagbe si n\u00e8na la me nyawo kple nyagbewo koe le. Kp\u0254\u0256e\u014buwo: select_words (((\"Mary had a little lamb\", 4) ==> [\"little\"] select_words (((\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words\" (((simple white space\", 2) ==> [] select_words (((\"Hello world\", 4) ==> [\"world\"] select_words (((\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Woana nya a\u0256e w\u00f2. W\u00f2 d\u0254 enye be n\u00e0kp\u0254 gbe\u0256i\u0256i si te \u0256e wo n\u0254ewo \u014bu wu si le gbe\u0256i\u0256i eve dome tso nya la \u0192e \u0256usime (\u014b\u0254\u014bl\u0254dzesi si nya le b\u0254b\u0254e). Gbe\u0256i\u0256i siwo le e\u0192e g\u0254medzedze kple nuwuwu mele xexl\u1ebd me o. Gbugb\u0254 nyagbe \u0192u\u0192lu la \u0256o ne m\u00e8kp\u0254 gbe\u0256i\u0256i a\u0256eke si \u0256o n\u0254n\u0254me si le etame la nu o. \u00c0te \u014bu abui be nyagbe si wots\u0254 \u0256o la me E\u028begbe \u014b\u0254\u014bl\u0254dzesiwo koe le. Kp\u0254\u0256e\u014bu: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"UULL\" get_closest_vowel (((\"quick\") ==> \"\"get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Ne ame \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo le ame \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo me la, ke ele be ame \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo nan\u0254 abe ale si w\u00f2le le ame \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo me ene. Kp\u0254\u0256e\u014bu 1: Numetoto: arr = [-3, -4, 5], k = 3 Numetoto: [-4, -3, 5] Kp\u0254\u0256e\u014bu 2: Numetoto: arr = [4, -4, 4], k = 2 Numetoto: [4, 4] Kp\u0254\u0256e\u014bu 3: Numetoto: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 Numetoto: [2] De dzesii: 1.\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Ne wode xexl\u1ebddzesi siwo menye \u0192u\u0192lu o la, tr\u0254na numegbe siwo kat\u00e3 le te\u0192e eve la \u0192e xexl\u1ebddzesi. Kp\u0254\u0256e\u014buwo \u0192e \u014bu\u0256o\u0256o (([5, 8, 7, 1]) ==> 12 \u014bu\u0256o\u0256o (([3, 3, 3, 3, 3]) ==> 9 \u014bu\u0256o\u0256o (([30, 13, 24, 321]) ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Ne wode xexl\u1ebddzesi blibo siwo nye arr kple xexl\u1ebddzesi blibo k si menye \u0192u\u0192lu o la, tr\u0254na nu siwo \u0192e xexl\u1ebddzesi siwo \u0192e xexl\u1ebddzesi eve le akpa gb\u00e3t\u0254 k me le arr me \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesi la \u0192e xexl\u1ebddzesi. Kp\u0254\u0256e\u014bu: Num\u0254mee: arr = [111,21,3,4000,5,6,7,8,9], k = 4 Num\u0254mee: 24 # sum of 21 + 3 Constraints: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Ne wode dzesi xexl\u1ebddzesi nyui n la, tr\u0254na \u014bk\u0254wo \u0192e xexl\u1ebddzesi siwo le \u0256o\u0256o nu le \u0256o\u0256o nu. Collatz \u0192e susu enye ak\u0254ntabubu si ku \u0256e xexl\u1ebddzesi siwo le \u0256o\u0256o nu la \u014bu. Efia be: dze eg\u0254me kple xexl\u1ebddzesi nyui n. Emegbe wo\u0256ea xexl\u1ebddzesi \u0256e sia \u0256e tso xexl\u1ebddzesi si do \u014bg\u0254 na wo me abe ale si gb\u0254na ene: ne xexl\u1ebddzesi si do \u014bg\u0254 na wo la nye eve la, xexl\u1ebddzesi si kpl\u0254e \u0256o la nye xexl\u1ebddzesi si do \u014bg\u0254 na wo la \u0192e af\u00e3. Ne xexl\u1ebddzesi si do \u014bg\u0254 na wo la nye eve la, xexl\u1ebddzesi si kpl\u0254e \u0256o la nye xexl\u1ebddzesi si do \u014bg\u0254 na wo la \u0192e te\u0192e 3 kple 1.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Ele be n\u00e0\u014bl\u0254 d\u0254 si ana \u014bkeke \u0192e xexl\u1ebddzesi si wona la nazu nyate\u0192e ne \u014bkeke la nye nyate\u0192e, ne menye nenema o la, anye a\u028batso. \u014akekea nye nyate\u0192e ne se siwo gb\u0254na la kat\u00e3 le eme: 1. \u014akeke \u0192e xexl\u1ebddzesi la menye \u0192u\u0192lu o. 2. \u014akeke \u0192e xexl\u1ebddzesi menye \u014bkeke 1 alo \u014bkeke 31 o le \u0263leti 1,3,5,7,8,10,12 me, eye \u014bkeke \u0192e xexl\u1ebddzesi menye \u014bkeke 1 alo \u014bkeke 30 o le \u0263leti 4,6,9,11 me. Eye \u014bkeke \u0192e xexl\u1ebddzesi menye \u014bkeke 1 alo \u014bkeke 29 o le \u0263leti 2 me. 3. \u0194letiwo mele be woanye \u0263leti 1 alo \u014bkeke 29 o le \u0263leti 2 me. 4. \u014akekea nan\u0254 \u0256o\u0256o sia me: mm-dd-yy-yy, le kp\u0254\u0256e\u014bu me: valid_date (le \u014bkeke si nye \u014bkeke si nye \u014bkeke si nye \u014bkeke si nye \u014bkeke si nye \u014bkeke si nye \u014bkeke si nye \u014bkeke si nye \u014bkeke si nye \u014bkeke\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Woana \u0263eyi\u0263i eve, afisi \u0263eyi\u0263i \u0256esia\u0256e nye xexl\u1ebddzesi blibo eve. Le kp\u0254\u0256e\u014bu me, \u0263eyi\u0263i = (dze eg\u0254me, nuwuwu) = (1, 2). \u0194eyi\u0263i siawo le eme, si fia be \u0263eyi\u0263i (dze eg\u0254me, nuwuwu) la l\u0254 g\u0254medzedze kple nuwuwu siaa \u0256e eme. Le \u0263eyi\u0263i \u0256esia\u0256e me la, wobuna be e\u0192e g\u0254medzedze le sue wu alo s\u0254 kple e\u0192e nuwuwu. W\u00f2 d\u0254e nye be n\u00e0nya ne \u0263eyi\u0263i eve siawo \u0192e te\u0192e \u0192e didime nye xexl\u1ebddzesi gb\u00e3t\u0254. Le kp\u0254\u0256e\u014bu me, \u0263eyi\u0263i (1, 3), (2, 4) \u0192e te\u0192e \u0192e didime nye (2, 3) si \u0192e didime nye 1, si menye xexl\u1ebddzesi gb\u00e3t\u0254 o. Ne te\u0192e \u0192e didime nye xexl\u1ebddzesi gb\u00e3t\u0254 la, gbugb\u0254 \"EE\", ne menye nenema o la, gbugb\u0254 \"AO\". Ne \u0263eyi\u0263i eveawo metoa te\u0192e o la, gbugb\u0254 \"AO\". [input\/output] samples: intersection ({((1, 2),\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Woana numegbe\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192le\u0192\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Ne \u00e8kp\u0254 grid si me xadzesi N kple axa N le (N >= 2) eye xadzesi k \u0192e didime nye nyuia la, xadzesi \u0256e sia \u0256e si le xadzesia me la me n\u0254a asix\u0254x\u0254 \u0256eka. Xadzesi \u0256e sia \u0256e si le [1, N * N] kple edzi la dzena zi \u0256eka p\u025b ko le xadzesia me. Ele be n\u00e0di m\u0254 si didi k \u0192e didime nyea le xadzesia me. \u00c0te \u014bu adze eg\u0254me tso xadzesi \u0256e sia \u0256e me, eye le af\u0254\u0256e\u0256e \u0256e sia \u0256e me la, \u00e0te \u014bu ayi xadzesi siwo te \u0256e e\u014bu la domet\u0254 \u0256e sia \u0256e me, le nya bubuwo me la, \u00e0te \u014bu ayi xadzesi siwo \u0192e li\u0192owo le \u0256eka kple w\u00f2 xadzesi si le eme fifia la me. De dzesii be m\u0254 si didi k fia be n\u00e0yi xadzesi k tututu (menye esiwo to vovo kokoko o). M\u00e0te\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Amesiame nya Fibonacci \u0192e \u0256o\u0256o, ak\u0254nta\u014butinunyalawo sr\u0254\u0303e nyuie le \u0192e alafa eve siwo va yi me. Gake nusi amewo menya o enye Tribonacci \u0192e \u0256o\u0256o. Wo\u0256ea Tribonacci \u0192e \u0256o\u0256o g\u0254me to t\u0254tr\u0254w\u0254w\u0254 dzi: tri(1) = 3 tri(n) = 1 + n \/ 2, ne n nye eve. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ne n nye eve. Le kp\u0254\u0256e\u014bu me: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Wona xexl\u1ebddzesi si menye neg\u0254\u0303 o n, ele be n\u00e0tr\u0254 asi le xexl\u1ebddzesi gb\u00e3t\u0254 n + 1 siwo le Tribonacci \u0192e \u0256o\u0256o la me \u014bu. Kp\u0254\u0256e\u014buwo: tri(3) = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Ne wode dzesi xexl\u1ebddzesi blibo si nye n la, tr\u0254 asi le xexl\u1ebddzesi siwo nye \u0256eka \u0192e xexl\u1ebddzesi \u014bu. Gbugb\u0254 0 ne xexl\u1ebddzesiawo kat\u00e3 nye eve. Le kp\u0254\u0256e\u014bu me: xexl\u1ebddzesi siwo nye ((1) == 1 xexl\u1ebddzesi siwo nye ((4) == 0 xexl\u1ebddzesi siwo nye ((235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Woana xexl\u1ebddzesiwo \u0192e \u014bk\u0254wo mi. Ehi\u00e3 be mia\u0256o xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo le xexl\u1ebddzesi siwo wona la \u0192e te\u0192e eve \u0192e xexl\u1ebddzesi gb\u0254, mia\u0192o nu tso nu siwo le xexl\u1ebddzesi me la domet\u0254 \u0256e sia \u0256e \u014bu le xexl\u1ebddzesi siwo le dzi la dzi gb\u00e3. Kp\u0254\u0256e\u014buwo: Ne lst = [1,2,3] la, nu si mia\u0256e la anye 14 Ne lst = [1,4,9] la, nu si mia\u0256e la anye 98 Ne lst = [1,3,5,7] la, nu si mia\u0256e anye 84 Ne lst = [1.4,4.2,0] la, nu si mia\u0256e anye 29 Ne lst = [-2.4,1,1] la, nu si mia\u0256e anye 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"W\u0254 d\u0254deasi a\u0256e si ana nu\u014b\u0254\u014bl\u0254dzesi si lolo wu si mele et\u0254 \u014bg\u0254 t\u1ebd o. Ne nu\u014b\u0254\u014bl\u0254dzesi ma meli o la, tr\u0254 -1. Nu\u014b\u0254\u014bl\u0254dzesi siwo le abe \u0256eka ene man\u0254 nu\u014b\u0254\u014bl\u0254dzesi siwo le et\u0254 megbe o. Kp\u0254\u0256e\u014buwo: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    W\u0254 d\u0254deasi a\u0256e si x\u0254a xexl\u1ebddzesi blibowo, floats, alo string siwo le tsitre \u0256i na xexl\u1ebddzesi siwo nye nyate\u0192e, eye w\u00f2nana be xexl\u1ebddzesi siwo nye nyate\u0192e la \u0192e xexl\u1ebddzesi siwo lolo wu la n\u0254a e\u0192e xexl\u1ebddzesi si wots\u0254 na me. Ne xexl\u1ebddzesiawo s\u0254 la, ekema e\u0256o None. De dzesii: Ne xexl\u1ebddzesi \u014but\u0254\u014but\u0254 le abe string ene la, ke nu si le z\u0254z\u0254m le enu ate \u014bu anye. alo, compare_one{1, 2.5) \u00e2 -> 2.5 compare_one{1, \"2,3\") \u00e2 -> \"2,3\" compare_one{5,1\", \"6\") \u00e2 -> \"6\" compare_one{1\", 1) \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Kp\u0254e \u0256a be xexl\u1ebddzesi n si wona la ate \u014bu anye xexl\u1ebddzesi eve siwo nye dzidzimet\u0254 4 \u0192e xexl\u1ebddzesi si nye wo n\u0254ewo \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddzesi \u0192e xexl\u1ebddz\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Brazil \u0192e nu\u014b\u0254\u014bl\u0254dzesi la nye: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! afisi n > 0 Le kp\u0254\u0256e\u014bu me:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Ne \u00e8kp\u0254 nyagbe a\u0256e la, ts\u0254 nyagbe siwo le ete la \u0256\u0254li te\u0192ewo, eye ne nyagbe a\u0256e me nyagbewo s\u0254 gb\u0254 wu 2 la, ts\u0254 nyagbe siwo le ete la \u0256\u0254li te\u0192ewo kple - fix_spaces (((\"Example\") == \"Example\" fix_spaces (((\"Example1\") == \"Example_1\" fix_spaces (((\"Example2\") == \"_Example_2\" fix_spaces (((\"Example 3\") == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"W\u0254 d\u0254deasi a\u0256e si x\u0254a nyadonu si le tsitre \u0256i na file \u0192e \u014bk\u0254, eye w\u00f2tr\u0254na 'Yes' ne file \u0192e \u014bk\u0254a le ete\u0192e, eye w\u00f2tr\u0254na 'No' ne menye nenema o. Wobua file \u0192e \u014bk\u0254 be enye esi le ete\u0192e ne n\u0254n\u0254me siwo gb\u0254na la kat\u00e3 le eme: - Nyadonu \u0192e \u014bk\u0254a me mele asi et\u0254\u0303 ('0'-'9') o. - Nyadonu \u0192e \u014bk\u0254a me nya \u0256eka p\u025b le. - Nyadonu \u0192e \u014bk\u0254a megan\u0254 \u0192u\u0192lu o, eye ele eg\u0254me dzem kple Latin alfabet \u0192e \u014b\u0254\u014bl\u0254dzesi ('a'-'z' kple 'A'Z'). - Nyadonu \u0192e \u014bk\u0254a le asi\u0192lu la dzi w\u00f2le be w\u00f2anye esiwo gb\u0254na domet\u0254 \u0256eka: ['txt', 'exe', 'lld'] Kp\u0254\u0256e\u014bu: file_name_check\"{example.txt.} # => 'Yes' file_name_check\"\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" D\u0254w\u0254\u0256ui sia ax\u0254 xexl\u1ebddzesi blibowo \u0192e \u014bk\u0254wo. Le xexl\u1ebddzesi blibowo kat\u00e3 \u0192e \u014bk\u0254wo gome la, d\u0254w\u0254\u0256ui la ana xexl\u1ebddzesi blibo \u0192e \u014bk\u0254wo \u0192e dzidze nan\u0254 te\u0192e eve ne e\u0192e xexl\u1ebddzesi nye 3 \u0192e te\u0192e eve eye w\u00f2ana xexl\u1ebddzesi blibo \u0192e \u014bk\u0254wo nan\u0254 te\u0192e eve ne e\u0192e xexl\u1ebddzesi nye 4 \u0192e te\u0192e eve eye menye 3 \u0192e te\u0192e eve o. D\u0254w\u0254\u0256ui la matr\u0254 \u014bk\u0254wo le xexl\u1ebddzesi siwo \u0192e xexl\u1ebddzesi menye 3 alo 4 \u0192e te\u0192e eve o la o. D\u0254w\u0254\u0256ui la aga\u0256o xexl\u1ebddzesi siwo kat\u00e3 le \u014bk\u0254awo me la \u0192e xexl\u1ebddzesi gb\u0254. Kp\u0254\u0256e\u014buwo: Ne lst = [1,2,3] la, ele be nu si woado la nanye 6 Ne lst = [] la, ele be nu si woado la nanye 0 Ne lst = [-1,-5,2,-1,-5] la, nu si woado\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Woana nyagbe a\u0256e si nye nyagbe a\u0256e si me nya a\u0256ewo le, eye woamawo \u0256e vovo, eye ele be n\u00e0tr\u0254 nyagbe a\u0256e si me nya siwo le nyagbe gb\u00e3t\u0254a me le, si \u0192e didime nye xexl\u1ebddzesi gb\u00e3t\u0254wo, nya siwo le nyagbe yeyea me \u0192e \u0256o\u0256o nan\u0254 abe esi le gb\u00e3t\u0254a me ene. Kp\u0254\u0256e\u014bu 1: \u014a\u0254\u014bl\u0254dzesi: nyagbe = \"Esia nye dodokp\u0254\" \u014a\u0254\u014bl\u0254dzesi: \"nye\" Kp\u0254\u0256e\u014bu 2: \u014a\u0254\u014bl\u0254dzesi: nyagbe = \"na m\u00edayi tsi\u0192u\u0192u me\" \u014a\u0254\u014bl\u0254dzesi: \"yi\" M\u0254xe\u0256enuwo: * 1 <= len(nyagbe) <= 100 * Nyagbe me nyawo nye \u014b\u0254\u014bl\u0254dzesiwo ko\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"W\u00f2 d\u0254 enye be n\u00e0w\u0254 d\u0254 a\u0256e si ana nya x * n nan\u0254 b\u0254b\u0254e. D\u0254w\u0254ea ana True ne x * n nye xexl\u1ebddzesi blibo eye False ne menye nenema o. X kple n siaa nye nyadri \u0192e xexl\u1ebddzesi, eye wo\u0192e n\u0254n\u0254me enye esi, <numerator>\/<denominator> afisi numerator kple denominator siaa nye xexl\u1ebddzesi blibo siwo nye dzidz\u0254wo. \u00c0te \u014bu abu x, kple n be wonye nyadri siwo s\u0254, eye womets\u0254 nu le abe numen\u0254la ene o. simplify{\"1\/5\", \"5\/1\") = True simplify{\"1\/6\", \"2\/1\") = False simplify{\"7\/10\", \"10\/2\") = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    \u014al\u0254 d\u0254 si na xexl\u1ebddzesi blibowo \u0192e xexl\u1ebddzesi siwo le xexl\u1ebddzesiawo \u0192e xexl\u1ebddzesi me le \u0256o\u0256o si dzi wole dzi yim le la me. De dzesii: ne nu gbogbo a\u0256ewo li siwo \u0192e xexl\u1ebddzesiwo \u0192e xexl\u1ebddzesiwo s\u0254 la, \u0256o wo \u0256e \u0256o\u0256o si le wo\u0192e xexl\u1ebddzesi si le nu\u014bl\u0254\u0256i gb\u00e3t\u0254a me la nu. Le kp\u0254\u0256e\u014bu me:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"\u014al\u0254 d\u0254 a\u0256e si x\u0254a xexl\u1ebddzesiwo \u0192e \u0192u\u0192o\u0192o abe nu\u014b\u0254\u014bl\u0254 ene eye w\u00f2nana numekuku siwo lolo wu 10 kple xexl\u1ebddzesi gb\u00e3t\u0254 kple maml\u025bt\u0254 siaa nye dzidzi (1, 3, 5, 7, 9). Le kp\u0254\u0256e\u014bu me: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Woana xexl\u1ebddzesi blibo si nye n w\u00f2. Ele be n\u00e0w\u0254 xexl\u1ebddzesi blibo si \u0192e didime nye n. Le i (1 \u2030\u00a4 i \u2030\u00a4 n) \u0256esia\u0256e gome la, a[i] = i * i - i + 1. \u00d0i xexl\u1ebddzesi siwo nye (a[i], a[j], a[k]) siwo nye et\u0254\u0303liawo le a si me i < j < k, eye a[i] + a[j] + a[k] nye et\u0254\u0303lia \u0192e te\u0192e et\u0254\u0303lia. Kp\u0254\u0256e\u014bu: Numetoto: n = 5 Numetoto: 1 Nume\u0256e\u0256e: a = [1, 3, 7, 13, 21] Nu et\u0254\u0303lia \u0256eka kolia si s\u0254 enye (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"\u014al\u0254 d\u0254 si x\u0254a nyagbewo \u0192e \u014bk\u0254wo abe parameter ene, e\u0256ea nyagbe siwo \u0192e didime nye \u0256eka la \u0256a le eme, eye w\u00f2nana \u014bk\u0254 siwo kat\u00e3 le eme la n\u0254a \u0256o\u0256o nu. \u014ak\u0254awo \u0192e \u014bk\u0254wo n\u0254a \u0256o\u0256o nu \u0263esia\u0263i, eye womenye xexl\u1ebddzesiwo \u0192e \u0192u\u0192o\u0192o o, eye ate \u014bu an\u0254 nu eve me. Ehi\u00e3 be \u014bk\u0254awo nan\u0254 \u0256o\u0256o nu le nyaawo \u0192e didime nu, eye ele be n\u00e0na \u014bk\u0254awo nan\u0254 \u0256o\u0256o nu le \u0256o\u0256o nu. Ne nya eve \u0192e didime s\u0254 la, ekema de \u014bk\u0254awo \u0192e \u014bk\u0254wo \u0256o\u0256o nu le alfabeta nu. D\u0254w\u0254ea na\u0256o nyagbewo \u0192e \u014bk\u0254wo \u0256e \u0256o\u0256o nu. \u00c0te \u014bu abui be nyaawo kat\u00e3 \u0192e didime s\u0254. Le kp\u0254\u0256e\u014bu me: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\"\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Efia be woa\u0256o x \u0192e asix\u0254x\u0254 \u0256e ame si nye ame gb\u00e3t\u0254 la \u014bu ne n nye ame gb\u00e3t\u0254 eye ne menye nenema o la, woa\u0256o y \u0192e asix\u0254x\u0254 \u0256e ame evelia \u014bu. Kp\u0254\u0256e\u014buwo: x_or_y ((7, 34, 12) == 34 x_or_y ((15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Meka \u0256e edzi be m\u00ed kat\u00e3 m\u00ede\u0256oa \u014bku seselel\u00e3me ma dzi ne m\u00edekp\u0254e be nu si m\u00edele m\u0254 kp\u0254m na \u0263eyi\u0263i didi a\u0256e la va eme ml\u0254eba. W\u00f2 seselel\u00e3me kple susu siwo le asiw\u00f2 le \u0263eyi\u0263i ma me la nyo be n\u00e0\u014bl\u0254 wo \u0256i ahaw\u0254 wo \u014buti k\u0254nta. W\u00f2 d\u0254e nye be n\u00e0kp\u0254e \u0256a be ame a\u0256e nya nu si tututu dz\u0254 le ho\u028bi\u028bli ge\u0256e me h\u00e3. Wona nu\u014b\u0254\u014bl\u0254 kple ak\u0254ntabubu siwo \u0192e didime s\u0254 la \u0192e \u0192u\u0192o\u0192o eve w\u00f2, eye afi si ak\u0254ntabubu \u0256e sia \u0256e le la fiaa nu si tututu dz\u0254. Na woatr\u0254 nu\u014b\u0254\u014bl\u0254 si \u0192e didime s\u0254 la \u0256e afi si wo domet\u0254 \u0256e sia \u0256e \u0192e ak\u0254ntabubu le. Ne wo\u0192o nu\u014b\u0254\u014bl\u0254a \u0256i nyuie la, ke e\u0192e asix\u0254x\u0254e nye 0, eye ne menye nenema o la, ke e\u0192e asix\u0254x\u0254e nye vovototo si le ak\u0254ntabubu kple ak\u0254ntabubu dome.\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Woa\u0256e klas \u0192e \u014bk\u0254 (dzeside) kple dodowo \u0192e \u014bk\u0254wo afia w\u00f2. Woaz\u00e3 dodowo ats\u0254 ade suku bubu siwo le klass la me. E\u0192e \u014bus\u1ebd le ale: Na CAP nanye \u014b\u0254\u014bl\u0254dzesi g\u00e3wo \u0192e xexl\u1ebdme le dodo \u0192e \u014bk\u0254 me, eye na SM nanye \u014b\u0254\u014bl\u0254dzesi suewo \u0192e xexl\u1ebdme le dodo \u0192e \u014bk\u0254 me, \u014bus\u1ebd le kpukpui CAP - SM me. W\u00f2 ya di dodo ses\u1ebdt\u0254 eye n\u00e0\u0256o string si le \u0256o\u0256o sia me: ClassName.StrongestExtensionName. Ne dodo eve alo esi wu ema le \u014bus\u1ebd \u0256eka me la, ele be n\u00e0tia esi dze \u014bg\u0254 le \u014bk\u0254a me. Le kp\u0254\u0256e\u014bu me, ne wona \"Slices\" w\u00f2zu klass kple dodowo \u0192e \u014bk\u0254: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] ekema ele be n\u00e0\u0256o 'Slices.SEviRNGCes' '\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Wode nya eve na w\u00f2. Ehi\u00e3 be n\u00e0tr\u0254 true ne nya evelia alo e\u0192e t\u0254tr\u0254 \u0256e sia \u0256e nye nya gb\u00e3t\u0254 \u0192e akpa a\u0256e cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Ne wode dzesi xexl\u1ebddzesi blibo a\u0256e la, ele be woana numek\u0254k\u0254 si nye xexl\u1ebddzesi siwo nye eve kple eve \u0192e xexl\u1ebddzesi \u0256eka. Kp\u0254\u0256e\u014bu: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Ne wode dzesi xexl\u1ebddzesi blibo a\u0256e la, ke na woats\u0254e abe Roman numeral \u0192e xexl\u1ebddzesi ene, eye n\u00e0ts\u0254e a\u0256o gbe me.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"\u014al\u0254 d\u0254 si x\u0254a nyagbewo \u0192e \u014bk\u0254wo. Nyagbe vovovowoe le \u014bk\u0254awo me. Gbugb\u0254 nya si \u0192e \u014b\u0254\u014bl\u0254dzesiwo s\u0254 gb\u0254 wu la \u0256o. Ne nyagbe ge\u0256ewo le \u014bk\u0254awo me la, gbugb\u0254 nya si dze gb\u00e3 le nyagbewo \u0192e \u0256o\u0256o nu \u0256o.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    \u00c8nye ha a\u0256e si d\u0254 le wuwum, eye \u00e8\u0256u \u014be\u014bewo \u0192e agb\u0254s\u0254s\u0254 a\u0256e xoxo, gake fifia ehi\u00e3 be n\u00e0\u0256u \u014be\u014be bubuwo wu be n\u00e0wu \u014bkekea \u0192e nu\u0256u\u0256uwo nu. ele be n\u00e0tr\u0254 asi le [ \u014be\u014be siwo n\u00e8\u0256u le w\u00f2 nu\u0256u\u0256u megbe \u0192e xexl\u1ebdme, \u014be\u014be siwo sus\u0254 le w\u00f2 nu\u0256u\u0256u megbe \u0192e xexl\u1ebdme ] \u0192e alinea \u014bu ne \u014be\u014be sus\u0254awo mes\u0254 gb\u0254 o la, \u00e0\u0256u \u014be\u014be sus\u0254awo kat\u00e3, gake d\u0254 agawu w\u00f2 kokoko. Kp\u0254\u0256e\u014bu: * \u0256u ((5, 6, 10) -> [11, 4] * \u0256u ((4, 8, 9) -> [12, 1] * \u0256u ((1, 10, 10) -> [11, 0] * \u0256u ((2, 11, 5) -> [7, 0] T\u0254tr\u0254dzesiwo: @number: \u014be\u014be \u0192e xexl\u1ebdme si n\u00e8\u0256u. @need: \u014be\u014be \u0192e xexl\u1ebdme si n\u00e8hi\u00e3 be n\u00e0\u0256u. @rema\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Ne wots\u0254 \u014bk\u0254 eve na \u014bk\u0254awo la, \u014bk\u0254a \u0192e didime nyea: operator, kple operand. \u014bk\u0254 gb\u00e3t\u0254a \u0192e didime nyea algebra basic operations, eye \u014bk\u0254 evelia nyea integers list. z\u00e3 \u014bk\u0254 eve siwo wots\u0254 n\u025b la n\u00e0ts\u0254 aw\u0254 algebraic expression eye n\u00e0ts\u0254 ana numekukua. \u014bk\u0254a \u0192e didime nyea: Addition ( +) Subtraction ( - ) Multiplication ( *) Floor division ( \/\/ ) Exponentiation ( ** Example) operator['+', '*', '-'] array = [2, 3, 4, 5] result = 2 + 3 * 4 - 5 => result = 9 De dzesii: \u014bk\u0254a \u0192e didime nyea \u014bk\u0254a \u0192e didime minus one. \u014bk\u0254a nyea \u014bk\u0254 si me integers siwo menye negatives o le. \u014bk\u0254a \u0192e didime nyea operator \u0256eka, eye \u014bk\u0254a \u0192e didime nyea operand eve.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Woana string s. ne s[i] nye \u014b\u0254\u014bl\u0254dzesi la, tr\u0254 e\u0192e \u014b\u0254\u014bl\u0254dzesi tso ete va dzi alo vice versa, ne menye nenema o la, na w\u00f2an\u0254 nenema. Ne \u014b\u0254\u014bl\u0254dzesi a\u0256eke mele string la me o la, tr\u0254 string la. Ele be d\u0254w\u0254w\u0254a nagbugb\u0254 string si do tso eme la ana. Kp\u0254\u0256e\u014buwo solve ((\"1234\") = \"4321\" solve ((\"ab\") = \"AB\" solve ((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Ne 'text' nye nyagbe \u0192u\u0192lu la, tr\u0254na 'None'\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Ne wots\u0254 xexl\u1ebddzesi blibo eve siwo nye a kple b na la, tr\u0254 asi le xexl\u1ebddzesi siwo nye a kple b dome la \u014bu le \u0256o\u0256o si le dzi yim me. Le kp\u0254\u0256e\u014bu me: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]