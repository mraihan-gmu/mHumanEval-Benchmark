[{"task_id":"HumanEval_0","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/ta dadu.     \/\/Odja si na lista di númeru ki bu da, ten dôs númeru más pértu kunpanheru di     \/\/ >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n    \/\/ (false)\n    \/\/ >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n    \/\/ (true)\n    public static bool HasCloseElements(List<float> numbers, float threshold) {\n","canonical_solution":"public static bool HasCloseElements(List<float> numbers, float threshold) {\n    numbers.Sort();\n    for (int i = 1; i < numbers.Count; i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));\n    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));\n    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));\n    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));\n    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));\n    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));\n    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_1","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Ignora kalker espasu na stringa di entrada.    \/\/Grupus separadu ta sta na ekilibri (kada braçadu abértu ta sta ben fitxadu) y es ka ta sta anbientadu na kunpanheru.    \/\/separa kes grupu na strings separadu i torna lista di kes.     \/\/Kel funson li é un stringa ki ten txeu grupu di paréntixi anbienti.    \/\/ >>> SeparateParenGroups((\"( ) (( )) (( )( ))\"))\n    \/\/ (new List<string>(new string[]{(string)\"()\", (string)\"(())\", (string)\"(()())\"}))\n    public static List<string> SeparateParenGroups(string paren_string) {\n","canonical_solution":"public static List<string> SeparateParenGroups(string paren_string) {\n        List<string> result = new List<string>();\n        StringBuilder currentGroup = new StringBuilder();\n        int balance = 0;\n\n        foreach (char c in paren_string) {\n            if (c == ' ') {\n                continue;\n            }\n\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n\n            currentGroup.Append(c);\n\n            \/\/ When balance is zero, we have a complete group\n            if (balance == 0 && currentGroup.Length > 0) {\n                result.Add(currentGroup.ToString());\n                currentGroup.Clear();\n            }\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SeparateParenGroups((\"(()()) ((())) () ((())()())\")).Equals((new List<string>(new string[]{(string)\"(()())\", (string)\"((()))\", (string)\"()\", (string)\"((())()())\"}))));\n    Debug.Assert(SeparateParenGroups((\"() (()) ((())) (((())))\")).Equals((new List<string>(new string[]{(string)\"()\", (string)\"(())\", (string)\"((()))\", (string)\"(((())))\"}))));\n    Debug.Assert(SeparateParenGroups((\"(()(())((())))\")).Equals((new List<string>(new string[]{(string)\"(()(())((())))\"}))));\n    Debug.Assert(SeparateParenGroups((\"( ) (( )) (( )( ))\")).Equals((new List<string>(new string[]{(string)\"()\", (string)\"(())\", (string)\"(()())\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_2","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna párti desimal di númeru.     \/\/(partis sobradas sénpri más pikinoti di 1).    \/\/i párti di númeru interu (maior númeru interu más pikinoti di kel númeru dadu) i dízimal     \/\/Si nu da un númeru di pontu flutuanti pozitivu, el pode ser dekompostu na     \/\/ >>> TruncateNumber((3.5f))\n    \/\/ (0.5f)\n    public static float TruncateNumber(float number) {\n","canonical_solution":"using System;\n\nclass Problem {\n    \/\/ Given a positive floating point number, it can be decomposed into\n    \/\/ an integer part (largest integer smaller than the given number) and decimals\n    \/\/ (leftover part always smaller than 1).\n    \/\/ Return the decimal part of the number.\n    public static float TruncateNumber(float number) {\n        return number - (float)Math.Floor(number);\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(TruncateNumber((3.5f)) == (0.5f));\n    Debug.Assert(TruncateNumber((1.25f)) == (0.25f));\n    Debug.Assert(TruncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"},{"task_id":"HumanEval_3","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/na kel pontu kel funson debe torna verdadi. Oxi el debe torna falsu.     \/\/bu trabadju é deteta si na kualker pontu saldo di konta kai baxu di zero, y     \/\/Bu ta dadu un lista di operason di depózitu y di retiru na un konta di banku ki ta kumesa ku     \/\/ >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (false)\n    \/\/ >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L})))\n    \/\/ (true)\n    public static bool BelowZero(List<long> operations) {\n","canonical_solution":"long balance = 0;\n    foreach (var operation in operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(BelowZero((new List<long>())) == (false));\n    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-3L, (long)1L, (long)2L, (long)-3L}))) == (false));\n    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L, (long)6L}))) == (true));\n    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (false));\n    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-5L}))) == (true));\n    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-2L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_4","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/MAD = médiku. x - x_médiku.    \/\/elementus y un pontu sentral (média na es kazu):     \/\/Diviason Absolutu Médiu é diferénsa absolutu médiku entri kada un di kes dôs varianti.    \/\/na meiu di es grupu di dadus.     \/\/Pa un lista dadu di númeru di input, kalkula divídiu médiku absolutu     \/\/ >>> MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n    \/\/ (1.0f)\n    public static float MeanAbsoluteDeviation(List<float> numbers) {\n","canonical_solution":"if (numbers == null || numbers.Count == 0)\n    {\n        throw new ArgumentException(\"The list of numbers must not be null or empty.\");\n    }\n    \n    float sum = 0.0f;\n    foreach (float number in numbers)\n    {\n        sum += number;\n    }\n\n    float mean = sum \/ numbers.Count;\n    float absoluteDeviationSum = 0.0f;\n    \n    foreach (float number in numbers)\n    {\n        absoluteDeviationSum += Math.Abs(number - mean);\n    }\n    \n    float meanAbsoluteDeviation = absoluteDeviationSum \/ numbers.Count;\n    return meanAbsoluteDeviation;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f}))) == (0.5f));\n    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));\n    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));\n    }\n\n}\n"},{"task_id":"HumanEval_5","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Inseri un númeru 'delimitru' entri kada dôs elementu konsegitivu di lista di input ∀numbers'     \/\/ >>> Intersperse((new List<long>()), (4L))\n    \/\/ (new List<long>())\n    \/\/ >>> Intersperse((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (4L))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)4L, (long)3L}))\n    public static List<long> Intersperse(List<long> numbers, long delimeter) {\n","canonical_solution":"public static List<long> Intersperse(List<long> numbers, long delimeter)\n{\n    List<long> result = new List<long>();\n\n    if (numbers == null || numbers.Count == 0)\n    {\n        return result;\n    }\n\n    for (int i = 0; i < numbers.Count; i++)\n    {\n        result.Add(numbers[i]);\n        if (i < numbers.Count - 1)\n        {\n            result.Add(delimeter);\n        }\n    }\n\n    return result;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Intersperse((new List<long>()), (7L)).Equals((new List<long>())));\n    Debug.Assert(Intersperse((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)2L})), (8L)).Equals((new List<long>(new long[]{(long)5L, (long)8L, (long)6L, (long)8L, (long)3L, (long)8L, (long)2L}))));\n    Debug.Assert(Intersperse((new List<long>(new long[]{(long)2L, (long)2L, (long)2L})), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L, (long)2L, (long)2L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_6","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu, (() (()) ten más di dôs nível di anbienti, enkuantu ((())) ten três.     \/\/Pa kada un di kes grupu, mostra kel nivel más fundu di anbienti di paréntesis.     \/\/Input di kel funson é un stringa ki ta reprezenta múltiplus grupu pa parentis anedadu separadu pa espasu.    \/\/ >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string paren_string) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> ParseNestedParens(string paren_string) {\n        List<long> nestingLevels = new List<long>();\n        string[] groups = paren_string.Split(' ');\n\n        foreach (string group in groups) {\n            long currentLevel = 0;\n            long maxLevel = 0;\n\n            foreach (char c in group) {\n                if (c == '(') {\n                    currentLevel++;\n                    if (currentLevel > maxLevel) {\n                        maxLevel = currentLevel;\n                    }\n                } else if (c == ')') {\n                    currentLevel--;\n                }\n            }\n\n            nestingLevels.Add(maxLevel);\n        }\n\n        return nestingLevels;\n    }\n\n    static void Main(string[] args) {\n        string input = \"(()()) ((())) () ((())()())\";\n        List<long> result = ParseNestedParens(input);\n        Console.WriteLine(string.Join(\", \", result));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_7","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Filtra un lista di strings ki ta inklui un substring     \/\/ >>> FilterBySubstring((new List<string>()), (\"a\"))\n    \/\/ (new List<string>())\n    \/\/ >>> FilterBySubstring((new List<string>(new string[]{(string)\"abc\", (string)\"bacd\", (string)\"cde\", (string)\"array\"})), (\"a\"))\n    \/\/ (new List<string>(new string[]{(string)\"abc\", (string)\"bacd\", (string)\"array\"}))\n    public static List<string> FilterBySubstring(List<string> strings, string substring) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<string> FilterBySubstring(List<string> strings, string substring) {\n        List<string> result = new List<string>();\n        foreach (string str in strings) {\n            if (str.Contains(substring)) {\n                result.Add(str);\n            }\n        }\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FilterBySubstring((new List<string>()), (\"john\")).Equals((new List<string>())));\n    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)\"xxx\", (string)\"asd\", (string)\"xxy\", (string)\"john doe\", (string)\"xxxAAA\", (string)\"xxx\"})), (\"xxx\")).Equals((new List<string>(new string[]{(string)\"xxx\", (string)\"xxxAAA\", (string)\"xxx\"}))));\n    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)\"xxx\", (string)\"asd\", (string)\"aaaxxy\", (string)\"john doe\", (string)\"xxxAAA\", (string)\"xxx\"})), (\"xx\")).Equals((new List<string>(new string[]{(string)\"xxx\", (string)\"aaaxxy\", (string)\"xxxAAA\", (string)\"xxx\"}))));\n    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)\"grunt\", (string)\"trumpet\", (string)\"prune\", (string)\"gruesome\"})), (\"run\")).Equals((new List<string>(new string[]{(string)\"grunt\", (string)\"prune\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_8","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Suma vazio debe ser igual a 0 i produtu vazio debe ser igual a 1.     \/\/Pa un lista di númeru interu, torna un tuple ki ta konsta di un suma i un produtu di tudu númeru interu na un lista.     \/\/ >>> SumProduct((new List<long>()))\n    \/\/ (Tuple.Create(0L, 1L))\n    \/\/ >>> SumProduct((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))\n    \/\/ (Tuple.Create(10L, 24L))\n    public static Tuple<long, long> SumProduct(List<long> numbers) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static Tuple<long, long> SumProduct(List<long> numbers) {\n        long sum = 0L;\n        long product = 1L;\n\n        foreach (var number in numbers) {\n            sum += number;\n            product *= number;\n        }\n\n        return Tuple.Create(sum, product);\n    }\n\n    static void Main(string[] args) {\n        \/\/ Test cases\n        var result1 = SumProduct(new List<long>());\n        Console.WriteLine($\"({result1.Item1}, {result1.Item2})\"); \/\/ Should output (0, 1)\n\n        var result2 = SumProduct(new List<long> { 1L, 2L, 3L, 4L });\n        Console.WriteLine($\"({result2.Item1}, {result2.Item2})\"); \/\/ Should output (10, 24)\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SumProduct((new List<long>())).Equals((Tuple.Create(0L, 1L))));\n    Debug.Assert(SumProduct((new List<long>(new long[]{(long)1L, (long)1L, (long)1L}))).Equals((Tuple.Create(3L, 1L))));\n    Debug.Assert(SumProduct((new List<long>(new long[]{(long)100L, (long)0L}))).Equals((Tuple.Create(100L, 0L))));\n    Debug.Assert(SumProduct((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))).Equals((Tuple.Create(15L, 105L))));\n    Debug.Assert(SumProduct((new List<long>(new long[]{(long)10L}))).Equals((Tuple.Create(10L, 10L))));\n    }\n\n}\n"},{"task_id":"HumanEval_9","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/na seísmu.    \/\/Di un lista di númeru interu, nu ta faze un lista di másimu elementu ki nu atxa ti ki nu da-l un momentu.    \/\/ >>> RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L}))\n    public static List<long> RollingMax(List<long> numbers) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> RollingMax(List<long> numbers) {\n        List<long> rollingMaxList = new List<long>();\n        long currentMax = long.MinValue;\n\n        foreach (var number in numbers) {\n            if (number > currentMax) {\n                currentMax = number;\n            }\n            rollingMaxList.Add(currentMax);\n        }\n\n        return rollingMaxList;\n    }\n\n    public static void Main(string[] args) {\n        List<long> numbers = new List<long> { 1L, 2L, 3L, 2L, 3L, 4L, 2L };\n        List<long> result = RollingMax(numbers);\n        Console.WriteLine(\"Rolling Max: \" + string.Join(\", \", result));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(RollingMax((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(RollingMax((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));\n    Debug.Assert(RollingMax((new List<long>(new long[]{(long)3L, (long)2L, (long)3L, (long)100L, (long)3L}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)100L, (long)100L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_10","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/- Adiciona na fin di stringa reverso di un prefixu di stringa ki ta ben antis di sufiksu palindromiku.     \/\/- Konxe postfix más lonji di stringa ki bu da ki é un palindrómu.     \/\/Kel ideia di algoritmu é sinplis:     \/\/Txiga pa palindromu más kurtu ki ta kumesa ku un stringa ki bu dadu.     \/\/ >>> MakePalindrome((\"\"))\n    \/\/ (\"\")\n    \/\/ >>> MakePalindrome((\"cat\"))\n    \/\/ (\"catac\")\n    \/\/ >>> MakePalindrome((\"cata\"))\n    \/\/ (\"catac\")\n    public static string MakePalindrome(string str) {\n","canonical_solution":"if (string.IsNullOrEmpty(str)) return str;\n\n    int maxPalindromeLength = 0;\n    for (int i = 0; i < str.Length; i++) {\n        if (IsPalindrome(str, i, str.Length - 1)) {\n            maxPalindromeLength = str.Length - i;\n            break;\n        }\n    }\n\n    string suffixToPrepend = str.Substring(0, str.Length - maxPalindromeLength);\n    char[] reversedPrefix = suffixToPrepend.Reverse().ToArray();\n    return str + new string(reversedPrefix);\n}\n\nprivate static bool IsPalindrome(string str, int left, int right) {\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(MakePalindrome((\"\")).Equals((\"\")));\n    Debug.Assert(MakePalindrome((\"x\")).Equals((\"x\")));\n    Debug.Assert(MakePalindrome((\"xyz\")).Equals((\"xyzyx\")));\n    Debug.Assert(MakePalindrome((\"xyx\")).Equals((\"xyx\")));\n    Debug.Assert(MakePalindrome((\"jerry\")).Equals((\"jerryrrej\")));\n    }\n\n}\n"},{"task_id":"HumanEval_11","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Propozi XOR bináriu na kes inputs y torna resultadu tanbe komu un stringa.     \/\/Input é dôs stringa a i b ki é só di 1 i 0.     \/\/ >>> StringXor((\"010\"), (\"110\"))\n    \/\/ (\"100\")\n    public static string StringXor(string a, string b) {\n","canonical_solution":"if (a.Length != b.Length) {\n        throw new ArgumentException(\"Input strings must be of the same length.\");\n    }\n\n    StringBuilder result = new StringBuilder(a.Length);\n\n    for (int i = 0; i < a.Length; i++) {\n        result.Append(a[i] == b[i] ? '0' : '1');\n    }\n\n    return result.ToString();\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(StringXor((\"111000\"), (\"101010\")).Equals((\"010010\")));\n    Debug.Assert(StringXor((\"1\"), (\"1\")).Equals((\"0\")));\n    Debug.Assert(StringXor((\"0101\"), (\"0000\")).Equals((\"0101\")));\n    }\n\n}\n"},{"task_id":"HumanEval_12","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/ta torna nulu si lista di input é ka ten.     \/\/Na lista di strings, torna kel más lonji.    \/\/ >>> Longest((new List<string>()))\n    \/\/ null\n    \/\/ >>> Longest((new List<string>(new string[]{(string)\"a\", (string)\"b\", (string)\"c\"})))\n    \/\/ (\"a\")\n    \/\/ >>> Longest((new List<string>(new string[]{(string)\"a\", (string)\"bb\", (string)\"ccc\"})))\n    \/\/ (\"ccc\")\n    public static string Longest(List<string> strings) {\n","canonical_solution":"if (strings == null || strings.Count == 0)\n    {\n        return null;\n    }\n    \n    string longest = strings[0];\n    \n    foreach (string str in strings)\n    {\n        if (str.Length > longest.Length)\n        {\n            longest = str;\n        }\n    }\n    \n    return longest;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Longest((new List<string>())).Equals(null));\n    Debug.Assert(Longest((new List<string>(new string[]{(string)\"x\", (string)\"y\", (string)\"z\"}))).Equals((\"x\")));\n    Debug.Assert(Longest((new List<string>(new string[]{(string)\"x\", (string)\"yyy\", (string)\"zzzz\", (string)\"www\", (string)\"kkkk\", (string)\"abc\"}))).Equals((\"zzzz\")));\n    }\n\n}\n"},{"task_id":"HumanEval_13","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna un maior kumun dividi di dôs númeru interu a y b     \/\/ >>> GreatestCommonDivisor((3L), (5L))\n    \/\/ (1L)\n    \/\/ >>> GreatestCommonDivisor((25L), (15L))\n    \/\/ (5L)\n    public static long GreatestCommonDivisor(long a, long b) {\n","canonical_solution":"\/\/ Base case: if b is 0, gcd is a\n    if (b == 0)\n        return a;\n    \n    \/\/ Recursive call: gcd(a, b) = gcd(b, a % b)\n    return GreatestCommonDivisor(b, a % b);\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(GreatestCommonDivisor((3L), (7L)) == (1L));\n    Debug.Assert(GreatestCommonDivisor((10L), (15L)) == (5L));\n    Debug.Assert(GreatestCommonDivisor((49L), (14L)) == (7L));\n    Debug.Assert(GreatestCommonDivisor((144L), (60L)) == (12L));\n    }\n\n}\n"},{"task_id":"HumanEval_14","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna lista di tudu préfiksu di más kurtu pa más longu di stringa di entrada     \/\/ >>> AllPrefixes((\"abc\"))\n    \/\/ (new List<string>(new string[]{(string)\"a\", (string)\"ab\", (string)\"abc\"}))\n    public static List<string> AllPrefixes(string str) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ Return list of all prefixes from shortest to longest of the input string\n    public static List<string> AllPrefixes(string str) {\n        List<string> prefixes = new List<string>();\n        for (int i = 1; i <= str.Length; i++) {\n            prefixes.Add(str.Substring(0, i));\n        }\n        return prefixes;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(AllPrefixes((\"\")).Equals((new List<string>())));\n    Debug.Assert(AllPrefixes((\"asdfgh\")).Equals((new List<string>(new string[]{(string)\"a\", (string)\"as\", (string)\"asd\", (string)\"asdf\", (string)\"asdfg\", (string)\"asdfgh\"}))));\n    Debug.Assert(AllPrefixes((\"WWW\")).Equals((new List<string>(new string[]{(string)\"W\", (string)\"WW\", (string)\"WWW\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_15","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna un stringa ki ten númeru dilimitadu ku espasu ki ta kumesa ku 0 ti n inkluzivu.     \/\/ >>> StringSequence((0L))\n    \/\/ (\"0\")\n    \/\/ >>> StringSequence((5L))\n    \/\/ (\"0 1 2 3 4 5\")\n    public static string StringSequence(long n) {\n","canonical_solution":"public static string StringSequence(long n) {\n    StringBuilder sb = new StringBuilder();\n    for (long i = 0; i <= n; i++) {\n        if (i > 0) {\n            sb.Append(\" \");\n        }\n        sb.Append(i);\n    }\n    return sb.ToString();\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(StringSequence((0L)).Equals((\"0\")));\n    Debug.Assert(StringSequence((3L)).Equals((\"0 1 2 3\")));\n    Debug.Assert(StringSequence((10L)).Equals((\"0 1 2 3 4 5 6 7 8 9 10\")));\n    }\n\n}\n"},{"task_id":"HumanEval_16","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Si nu da un stringa, nu ta atxa kantu karaterístiku diferenti (ka ta nporta ki bóka) el ten     \/\/ >>> CountDistinctCharacters((\"xyzXYZ\"))\n    \/\/ (3L)\n    \/\/ >>> CountDistinctCharacters((\"Jerry\"))\n    \/\/ (4L)\n    public static long CountDistinctCharacters(string str) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static long CountDistinctCharacters(string str) {\n        \/\/ Convert the string to lower case to handle case insensitivity\n        str = str.ToLower();\n\n        \/\/ Use a HashSet to store distinct characters\n        HashSet<char> distinctChars = new HashSet<char>(str);\n\n        \/\/ Return the count of distinct characters\n        return distinctChars.Count;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CountDistinctCharacters((\"\")) == (0L));\n    Debug.Assert(CountDistinctCharacters((\"abcde\")) == (5L));\n    Debug.Assert(CountDistinctCharacters((\"abcdecadeCADE\")) == (5L));\n    Debug.Assert(CountDistinctCharacters((\"aaaaAAAAaaaa\")) == (1L));\n    Debug.Assert(CountDistinctCharacters((\"Jerry jERRY JeRRRY\")) == (5L));\n    }\n\n}\n"},{"task_id":"HumanEval_17","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/'Hake' - nota di kuartu, ta dura un batimentu.    \/\/'O saide' - metadi di nota, ta dura dôs bês.    \/\/'O' - nota interu, ta dura kuatu batimentu     \/\/Un lenda ta fla:    \/\/ka ta dura.    \/\/Bu trabadju é analiza es stringa y torna lista di intirjus ki ta koresponde ku kantu batimentu kada un ta faze     \/\/Input di es funson é un stringa ki ta reprezenta nótas muzikal na un formatu spesial di ASCII.     \/\/ >>> ParseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    \/\/ (new List<long>(new long[]{(long)4L, (long)2L, (long)1L, (long)2L, (long)2L, (long)1L, (long)1L, (long)1L, (long)1L, (long)4L, (long)4L}))\n    public static List<long> ParseMusic(string music_string) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<long> ParseMusic(string music_string)\n    {\n        List<long> beats = new List<long>();\n        string[] notes = music_string.Split(' ');\n        \n        foreach (string note in notes)\n        {\n            switch (note)\n            {\n                case \"o\":\n                    beats.Add(4L);\n                    break;\n                case \"o|\":\n                    beats.Add(2L);\n                    break;\n                case \".|\":\n                    beats.Add(1L);\n                    break;\n                default:\n                    break;\n            }\n        }\n        \n        return beats;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseMusic((\"\")).Equals((new List<long>())));\n    Debug.Assert(ParseMusic((\"o o o o\")).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));\n    Debug.Assert(ParseMusic((\".| .| .| .|\")).Equals((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}))));\n    Debug.Assert(ParseMusic((\"o| o| .| .| o o o o\")).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)1L, (long)1L, (long)4L, (long)4L, (long)4L, (long)4L}))));\n    Debug.Assert(ParseMusic((\"o| .| o| .| o o| o o|\")).Equals((new List<long>(new long[]{(long)2L, (long)1L, (long)2L, (long)1L, (long)4L, (long)2L, (long)4L, (long)2L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_18","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Konta kantu bês ki un diziginason pode sta na kel diziginason ki sta na primeru.    \/\/ >>> HowManyTimes((\"\"), (\"a\"))\n    \/\/ (0L)\n    \/\/ >>> HowManyTimes((\"aaa\"), (\"a\"))\n    \/\/ (3L)\n    \/\/ >>> HowManyTimes((\"aaaa\"), (\"aa\"))\n    \/\/ (3L)\n    public static long HowManyTimes(string str, string substring) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long HowManyTimes(string str, string substring) {\n        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring)) {\n            return 0L;\n        }\n\n        long count = 0;\n        int index = 0;\n\n        while ((index = str.IndexOf(substring, index)) != -1) {\n            count++;\n            index++;\n        }\n\n        return count;\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(HowManyTimes(\"aaa\", \"a\")); \/\/ Output: 3\n        Console.WriteLine(HowManyTimes(\"aaaa\", \"aa\")); \/\/ Output: 3\n        Console.WriteLine(HowManyTimes(\"\", \"a\")); \/\/ Output: 0\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(HowManyTimes((\"\"), (\"x\")) == (0L));\n    Debug.Assert(HowManyTimes((\"xyxyxyx\"), (\"x\")) == (4L));\n    Debug.Assert(HowManyTimes((\"cacacacac\"), (\"cac\")) == (4L));\n    Debug.Assert(HowManyTimes((\"john doe\"), (\"john\")) == (1L));\n    }\n\n}\n"},{"task_id":"HumanEval_19","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna kel númeru di stringa ordenadu di más pikinoti pa más grandi     \/\/Skodjedu 'zero', 'un', 'duas', 'três', 'kuatu', 'sinku', 'seis', 'sete', 'oitu' i 'novu'.     \/\/Input é un stringa di numeral dilimitadu pa espasu di \"zero\" ti \"nove\".     \/\/ >>> SortNumbers((\"three one five\"))\n    \/\/ (\"one three five\")\n    public static string SortNumbers(string numbers) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static string SortNumbers(string numbers)\n    {\n        Dictionary<string, int> numberWords = new Dictionary<string, int>\n        {\n            { \"zero\", 0 },\n            { \"one\", 1 },\n            { \"two\", 2 },\n            { \"three\", 3 },\n            { \"four\", 4 },\n            { \"five\", 5 },\n            { \"six\", 6 },\n            { \"seven\", 7 },\n            { \"eight\", 8 },\n            { \"nine\", 9 }\n        };\n\n        List<string> numberList = new List<string>(numbers.Split(' '));\n        numberList.Sort((a, b) => numberWords[a].CompareTo(numberWords[b]));\n        return string.Join(\" \", numberList);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(SortNumbers(\"three one five\")); \/\/ Output: \"one three five\"\n        Console.WriteLine(SortNumbers(\"nine eight seven six\")); \/\/ Output: \"six seven eight nine\"\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortNumbers((\"\")).Equals((\"\")));\n    Debug.Assert(SortNumbers((\"three\")).Equals((\"three\")));\n    Debug.Assert(SortNumbers((\"three five nine\")).Equals((\"three five nine\")));\n    Debug.Assert(SortNumbers((\"five zero four seven nine eight\")).Equals((\"zero four five seven eight nine\")));\n    Debug.Assert(SortNumbers((\"six five four three two one zero\")).Equals((\"zero one two three four five six\")));\n    }\n\n}\n"},{"task_id":"HumanEval_20","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/otu i torna-s na ordi (nbru más pikinoti, númeru más grandi).     \/\/Di un lista di númeru ki bu dadu (ki ten pelu menus dôs) skodje y torna dôs ki é más pértu di kada un     \/\/ >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n    \/\/ (Tuple.Create(2.0f, 2.2f))\n    \/\/ >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n    \/\/ (Tuple.Create(2.0f, 2.0f))\n    public static Tuple<float, float> FindClosestElements(List<float> numbers) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static Tuple<float, float> FindClosestElements(List<float> numbers) {\n        if (numbers == null || numbers.Count < 2) {\n            throw new ArgumentException(\"List must contain at least two numbers.\");\n        }\n        \n        numbers.Sort();\n        float minDifference = float.MaxValue;\n        Tuple<float, float> closestPair = null;\n\n        for (int i = 0; i < numbers.Count - 1; i++) {\n            float difference = numbers[i + 1] - numbers[i];\n            if (difference < minDifference) {\n                minDifference = difference;\n                closestPair = Tuple.Create(numbers[i], numbers[i + 1]);\n            }\n        }\n\n        return closestPair;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(3.9f, 4.0f))));\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))).Equals((Tuple.Create(5.0f, 5.9f))));\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(2.0f, 2.2f))));\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))).Equals((Tuple.Create(2.0f, 2.0f))));\n    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))).Equals((Tuple.Create(2.2f, 3.1f))));\n    }\n\n}\n"},{"task_id":"HumanEval_21","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/di forma ki kel más pikinoti ta bira 0 y kel más grandi ta bira 1     \/\/Si nu da-l un lista di númeru (di pelu menus dôs elementu), nu ta aplika un transformason linear pa kel lista,     \/\/ >>> RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n    \/\/ (new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\n    public static List<float> RescaleToUnit(List<float> numbers) {\n","canonical_solution":"public static List<float> RescaleToUnit(List<float> numbers) {\n        if (numbers == null || numbers.Count < 2)\n            throw new ArgumentException(\"List must contain at least two elements.\");\n\n        float min = numbers.Min();\n        float max = numbers.Max();\n\n        if (min == max)\n            throw new ArgumentException(\"All elements are the same. Cannot rescale.\");\n\n        return numbers.Select(num => (num - min) \/ (max - min)).ToList();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)1.0f}))));\n    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)100.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)1.0f, (float)0.0f}))));\n    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))));\n    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));\n    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));\n    }\n\n}\n"},{"task_id":"HumanEval_22","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Filtra lista di kalker valor di csthon so pa númeru interu     \/\/ >>> FilterIntegers((new List<object>(new string[]{(string)\"a\", (string)3.14f, (string)5L})))\n    \/\/ (new List<long>(new long[]{(long)5L}))\n    \/\/ >>> FilterIntegers((new List<object>(new object[]{1L, 2L, 3L, \"abc\", new List<object>()})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))\n    public static List<long> FilterIntegers(List<object> values) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> FilterIntegers(List<object> values) {\n        List<long> result = new List<long>();\n        foreach (var value in values) {\n            if (value is long) {\n                result.Add((long)value);\n            }\n        }\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FilterIntegers((new List<object>())).Equals((new List<long>())));\n    Debug.Assert(FilterIntegers((new List<object>(new object[]{4L, new List<object>(), 23.2f, 9L, \"adasd\"}))).Equals((new List<long>(new long[]{(long)4L, (long)9L}))));\n    Debug.Assert(FilterIntegers((new List<object>(new object[]{3L, \"c\", 3L, 3L, \"a\", \"b\"}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_23","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retornu di kel númeru     \/\/ >>> StringLength((\"\"))\n    \/\/ (0L)\n    \/\/ >>> StringLength((\"abc\"))\n    \/\/ (3L)\n    public static long Strlen(string str) {\n","canonical_solution":"return str.Length;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Strlen((\"\")) == (0L));\n    Debug.Assert(Strlen((\"x\")) == (1L));\n    Debug.Assert(Strlen((\"asdasnakj\")) == (9L));\n    }\n\n}\n"},{"task_id":"HumanEval_24","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pa un númeru n, atxa kel númeru más grandi ki ta dividi n uniformemente, más pikinoti ki n     \/\/ >>> LargestDivisor((15L))\n    \/\/ (5L)\n    public static long LargestDivisor(long n) {\n","canonical_solution":"if (n <= 1)\n        {\n            throw new ArgumentOutOfRangeException(\"n must be greater than 1\");\n        }\n        for (long i = n \/ 2; i >= 1; i--)\n        {\n            if (n % i == 0)\n            {\n                return i;\n            }\n        }\n        return 1; \/\/ This line is theoretically unreachable since 1 is always a divisor of n\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestDivisor((3L)) == (1L));\n    Debug.Assert(LargestDivisor((7L)) == (1L));\n    Debug.Assert(LargestDivisor((10L)) == (5L));\n    Debug.Assert(LargestDivisor((100L)) == (50L));\n    Debug.Assert(LargestDivisor((49L)) == (7L));\n    }\n\n}\n"},{"task_id":"HumanEval_25","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Númeru di entrada debe ser igual a produto di tudu kes fatores     \/\/Kada un di kes faktoris debe ser lisadu un monti bês ki ta korresponde ku kantu bês el ta parse na fatorizason.    \/\/Retorna lista di fatór prima di un númeru interu dadu na ordi di más pikinoti pa más grandi.     \/\/ >>> Factorize((8L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))\n    \/\/ >>> Factorize((25L))\n    \/\/ (new List<long>(new long[]{(long)5L, (long)5L}))\n    \/\/ >>> Factorize((70L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)5L, (long)7L}))\n    public static List<long> Factorize(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> Factorize(long n) {\n        List<long> factors = new List<long>();\n        for (long i = 2; i * i <= n; i++) {\n            while (n % i == 0) {\n                factors.Add(i);\n                n \/= i;\n            }\n        }\n        if (n > 1) {\n            factors.Add(n);\n        }\n        return factors;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Factorize((2L)).Equals((new List<long>(new long[]{(long)2L}))));\n    Debug.Assert(Factorize((4L)).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));\n    Debug.Assert(Factorize((8L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))));\n    Debug.Assert(Factorize((57L)).Equals((new List<long>(new long[]{(long)3L, (long)19L}))));\n    Debug.Assert(Factorize((3249L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)19L, (long)19L}))));\n    Debug.Assert(Factorize((185193L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)19L, (long)19L, (long)19L}))));\n    Debug.Assert(Factorize((20577L)).Equals((new List<long>(new long[]{(long)3L, (long)19L, (long)19L, (long)19L}))));\n    Debug.Assert(Factorize((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)3L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_26","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Manténha ordi di kes elementu ki sta na entrada.    \/\/Di un lista di númeru interu, skodje tudu kes elementu ki ta parse más di un bês.     \/\/ >>> RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)3L, (long)4L}))\n    public static List<long> RemoveDuplicates(List<long> numbers) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem\n{\n    \/\/ From a list of integers, remove all elements that occur more than once.\n    \/\/ Keep order of elements left the same as in the input.\n    public static List<long> RemoveDuplicates(List<long> numbers)\n    {\n        var elementCount = numbers.GroupBy(n => n)\n                                  .ToDictionary(g => g.Key, g => g.Count());\n\n        return numbers.Where(n => elementCount[n] == 1).ToList();\n    }\n\n    static void Main(string[] args)\n    {\n        List<long> numbers = new List<long> { 1, 2, 3, 2, 4 };\n        List<long> result = RemoveDuplicates(numbers);\n        Console.WriteLine(string.Join(\", \", result));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(RemoveDuplicates((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L, (long)3L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)5L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_27","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pa un dizéntu dadu, torna kes karater di létra minúscula pa majuskulus i majuskulus pa minúskulus.     \/\/ >>> FlipCase((\"Hello\"))\n    \/\/ (\"hELLO\")\n    public static string FlipCase(string str) {\n","canonical_solution":"using System;\n\nclass Problem {\n    \/\/ For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    \/\/ >>> FlipCase((\"Hello\"))\n    \/\/ (\"hELLO\")\n    public static string FlipCase(string str) {\n        char[] chars = str.ToCharArray();\n        for (int i = 0; i < chars.Length; i++) {\n            if (char.IsUpper(chars[i])) {\n                chars[i] = char.ToLower(chars[i]);\n            } else if (char.IsLower(chars[i])) {\n                chars[i] = char.ToUpper(chars[i]);\n            }\n        }\n        return new string(chars);\n    }\n    \n    static void Main(string[] args) {\n        Console.WriteLine(FlipCase(\"Hello\")); \/\/ Output should be \"hELLO\"\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FlipCase((\"\")).Equals((\"\")));\n    Debug.Assert(FlipCase((\"Hello!\")).Equals((\"hELLO!\")));\n    Debug.Assert(FlipCase((\"These violent delights have violent ends\")).Equals((\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")));\n    }\n\n}\n"},{"task_id":"HumanEval_28","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Konkista lista di strings na un uniku stringa     \/\/ >>> Concatenate((new List<string>()))\n    \/\/ (\"\")\n    \/\/ >>> Concatenate((new List<string>(new string[]{(string)\"a\", (string)\"b\", (string)\"c\"})))\n    \/\/ (\"abc\")\n    public static string Concatenate(List<string> strings) {\n","canonical_solution":"return string.Concat(strings);\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Concatenate((new List<string>())).Equals((\"\")));\n    Debug.Assert(Concatenate((new List<string>(new string[]{(string)\"x\", (string)\"y\", (string)\"z\"}))).Equals((\"xyz\")));\n    Debug.Assert(Concatenate((new List<string>(new string[]{(string)\"x\", (string)\"y\", (string)\"z\", (string)\"w\", (string)\"k\"}))).Equals((\"xyzwk\")));\n    }\n\n}\n"},{"task_id":"HumanEval_29","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Filtra un lista di strings ki ta dadu so pa strings ki ta kumesa ku un prefiksu.     \/\/ >>> FilterByPrefix((new List<string>()), (\"a\"))\n    \/\/ (new List<string>())\n    \/\/ >>> FilterByPrefix((new List<string>(new string[]{(string)\"abc\", (string)\"bcd\", (string)\"cde\", (string)\"array\"})), (\"a\"))\n    \/\/ (new List<string>(new string[]{(string)\"abc\", (string)\"array\"}))\n    public static List<string> FilterByPrefix(List<string> strings, string prefix) {\n","canonical_solution":"return strings.Where(s => s.StartsWith(prefix)).ToList();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FilterByPrefix((new List<string>()), (\"john\")).Equals((new List<string>())));\n    Debug.Assert(FilterByPrefix((new List<string>(new string[]{(string)\"xxx\", (string)\"asd\", (string)\"xxy\", (string)\"john doe\", (string)\"xxxAAA\", (string)\"xxx\"})), (\"xxx\")).Equals((new List<string>(new string[]{(string)\"xxx\", (string)\"xxxAAA\", (string)\"xxx\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_30","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Devolve sô númeru pozitivu na lista.     \/\/ >>> GetPositive((new List<long>(new long[]{(long)-1L, (long)2L, (long)-4L, (long)5L, (long)6L})))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)5L, (long)6L}))\n    \/\/ >>> GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))\n    \/\/ (new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)9L, (long)123L, (long)1L}))\n    public static List<long> GetPositive(List<long> l) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<long> GetPositive(List<long> l)\n    {\n        List<long> positiveNumbers = new List<long>();\n        foreach (long number in l)\n        {\n            if (number > 0)\n            {\n                positiveNumbers.Add(number);\n            }\n        }\n        return positiveNumbers;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L, (long)4L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)4L, (long)5L, (long)6L}))));\n    Debug.Assert(GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)3L, (long)9L, (long)123L, (long)1L}))));\n    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L}))).Equals((new List<long>())));\n    Debug.Assert(GetPositive((new List<long>())).Equals((new List<long>())));\n    }\n\n}\n"},{"task_id":"HumanEval_31","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna verdadi si un númeru dadu é primo, y falsu si é ka si.     \/\/ >>> IsPrime((6L))\n    \/\/ (false)\n    \/\/ >>> IsPrime((101L))\n    \/\/ (true)\n    \/\/ >>> IsPrime((11L))\n    \/\/ (true)\n    \/\/ >>> IsPrime((13441L))\n    \/\/ (true)\n    \/\/ >>> IsPrime((61L))\n    \/\/ (true)\n    \/\/ >>> IsPrime((4L))\n    \/\/ (false)\n    \/\/ >>> IsPrime((1L))\n    \/\/ (false)\n    public static bool IsPrime(long n) {\n","canonical_solution":"public static bool IsPrime(long n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    \n    return true;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsPrime((6L)) == (false));\n    Debug.Assert(IsPrime((101L)) == (true));\n    Debug.Assert(IsPrime((11L)) == (true));\n    Debug.Assert(IsPrime((13441L)) == (true));\n    Debug.Assert(IsPrime((61L)) == (true));\n    Debug.Assert(IsPrime((4L)) == (false));\n    Debug.Assert(IsPrime((1L)) == (false));\n    Debug.Assert(IsPrime((5L)) == (true));\n    Debug.Assert(IsPrime((11L)) == (true));\n    Debug.Assert(IsPrime((17L)) == (true));\n    Debug.Assert(IsPrime((85L)) == (false));\n    Debug.Assert(IsPrime((77L)) == (false));\n    Debug.Assert(IsPrime((255379L)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_33","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/pa valor di kes indizes koresponenti di l, má ordenadu.     \/\/l' é idéntiku a l na kes indísiu ki ka ta divizedu pa três, enkuantu se valor na kes indísiu ki ta divizedu pa três é igual     \/\/Kel funson li ta toma un lista l i ta torna un lista l' sima ki     \/\/ >>> SortThird((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))\n    \/\/ >>> SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L})))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))\n    public static List<long> SortThird(List<long> l) {\n","canonical_solution":"public static List<long> SortThird(List<long> l) {\n        List<long> sortedValues = new List<long>();\n\n        \/\/ Collect values at indices divisible by three\n        for (int i = 0; i < l.Count; i++) {\n            if (i % 3 == 0) {\n                sortedValues.Add(l[i]);\n            }\n        }\n\n        \/\/ Sort the collected values\n        sortedValues.Sort();\n\n        \/\/ Place sorted values back into their positions\n        int sortedIndex = 0;\n        List<long> result = new List<long>(l);\n        for (int i = 0; i < result.Count; i++) {\n            if (i % 3 == 0) {\n                result[i] = sortedValues[sortedIndex++];\n            }\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))));\n    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)5L}))));\n    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)5L}))));\n    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L, (long)1L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_34","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Devolve un elementu úniku ordenadu na un lista     \/\/ >>> Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))\n    \/\/ (new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))\n    public static List<long> Unique(List<long> l) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ Return sorted unique elements in a list\n    public static List<long> Unique(List<long> l) {\n        HashSet<long> uniqueSet = new HashSet<long>(l);\n        List<long> uniqueList = new List<long>(uniqueSet);\n        uniqueList.Sort();\n        return uniqueList;\n    }\n    \n    static void Main(string[] args) {\n        List<long> input = new List<long>{5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L};\n        List<long> result = Unique(input);\n        Console.WriteLine(string.Join(\", \", result)); \/\/ Output: 0, 2, 3, 5, 9, 123\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_35","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna elementu másimu na lista.     \/\/ >>> MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (3L)\n    \/\/ >>> MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))\n    \/\/ (123L)\n    public static long MaxElement(List<long> l) {\n","canonical_solution":"return l.Max();\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (3L));\n    Debug.Assert(MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)124L, (long)1L, (long)-10L}))) == (124L));\n    }\n\n}\n"},{"task_id":"HumanEval_36","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna númeru di bês ki dígitu 7 ta parse na númeru interu menus ki n ki é divisível pa 11 ô 13.     \/\/ >>> FizzBuzz((50L))\n    \/\/ (0L)\n    \/\/ >>> FizzBuzz((78L))\n    \/\/ (2L)\n    \/\/ >>> FizzBuzz((79L))\n    \/\/ (3L)\n    public static long FizzBuzz(long n) {\n","canonical_solution":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\nclass Problem {\n    \/\/ Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \/\/ >>> FizzBuzz((50L))\n    \/\/ (0L)\n    \/\/ >>> FizzBuzz((78L))\n    \/\/ (2L)\n    \/\/ >>> FizzBuzz((79L))\n    \/\/ (3L)\n    public static long FizzBuzz(long n) {\n        long count = 0;\n        for (long i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                count += CountSevens(i);\n            }\n        }\n        return count;\n    }\n\n    private static int CountSevens(long num) {\n        int count = 0;\n        while (num > 0) {\n            if (num % 10 == 7) {\n                count++;\n            }\n            num \/= 10;\n        }\n        return count;\n    }\n\n    \/\/ You can test the function with the following main method:\n    static void Main(string[] args) {\n        Console.WriteLine(FizzBuzz(50));  \/\/ Output: 0\n        Console.WriteLine(FizzBuzz(78));  \/\/ Output: 2\n        Console.WriteLine(FizzBuzz(79));  \/\/ Output: 3\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FizzBuzz((50L)) == (0L));\n    Debug.Assert(FizzBuzz((78L)) == (2L));\n    Debug.Assert(FizzBuzz((79L)) == (3L));\n    Debug.Assert(FizzBuzz((100L)) == (3L));\n    Debug.Assert(FizzBuzz((200L)) == (6L));\n    Debug.Assert(FizzBuzz((4000L)) == (192L));\n    Debug.Assert(FizzBuzz((10000L)) == (639L));\n    Debug.Assert(FizzBuzz((100000L)) == (8026L));\n    }\n\n}\n"},{"task_id":"HumanEval_37","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/pa valor di kes indisiu par di l, má ordenadu.     \/\/l' é idéntiku a l na indísius di párti, enkuantu se valor na indísius di par é igual     \/\/Kel funson li ta toma un lista l i ta torna un lista l' sima ki     \/\/ >>> SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))\n    \/\/ >>> SortEven((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L})))\n    \/\/ (new List<long>(new long[]{(long)3L, (long)6L, (long)5L, (long)4L}))\n    public static List<long> SortEven(List<long> l) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ This function takes a list l and returns a list l' such that\n    \/\/ l' is identical to l in the odd indices, while its values at the even indices are equal\n    \/\/ to the values of the even indices of l, but sorted.\n    public static List<long> SortEven(List<long> l) {\n        List<long> evenIndicesValues = new List<long>();\n\n        \/\/ Collect values from even indices\n        for (int i = 0; i < l.Count; i += 2) {\n            evenIndicesValues.Add(l[i]);\n        }\n\n        \/\/ Sort the collected even index values\n        evenIndicesValues.Sort();\n\n        \/\/ Reconstruct the list with sorted values at even indices\n        List<long> result = new List<long>(l);\n\n        for (int i = 0, j = 0; i < result.Count; i += 2, j++) {\n            result[i] = evenIndicesValues[j];\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))));\n    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-10L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)5L, (long)0L, (long)9L, (long)1L, (long)123L}))));\n    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)8L, (long)-12L, (long)4L, (long)23L, (long)2L, (long)3L, (long)11L, (long)12L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-12L, (long)8L, (long)3L, (long)4L, (long)5L, (long)2L, (long)12L, (long)11L, (long)23L, (long)-10L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_39","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/prime_fib ta torna n-esimu númeru ki é un númeru di Fibonacci y tanbe é primeru.     \/\/ >>> PrimeFib((1L))\n    \/\/ (2L)\n    \/\/ >>> PrimeFib((2L))\n    \/\/ (3L)\n    \/\/ >>> PrimeFib((3L))\n    \/\/ (5L)\n    \/\/ >>> PrimeFib((4L))\n    \/\/ (13L)\n    \/\/ >>> PrimeFib((5L))\n    \/\/ (89L)\n    public static long PrimeFib(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    \/\/ Method to check if a number is prime\n    public static bool IsPrime(long num)\n    {\n        if (num <= 1) return false;\n        if (num == 2) return true;\n        if (num % 2 == 0) return false;\n\n        long boundary = (long)Math.Floor(Math.Sqrt(num));\n\n        for (long i = 3; i <= boundary; i += 2)\n        {\n            if (num % i == 0)\n                return false;\n        }\n\n        return true;\n    }\n\n    \/\/ Method to generate Fibonacci numbers and find the n-th prime Fibonacci\n    public static long PrimeFib(long n)\n    {\n        long a = 1, b = 1;\n        long primeFibCount = 0;\n\n        while (true)\n        {\n            long temp = a;\n            a = b;\n            b = temp + b;\n\n            if (IsPrime(a))\n            {\n                primeFibCount++;\n                if (primeFibCount == n)\n                {\n                    return a;\n                }\n            }\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(PrimeFib(1)); \/\/ Output: 2\n        Console.WriteLine(PrimeFib(2)); \/\/ Output: 3\n        Console.WriteLine(PrimeFib(3)); \/\/ Output: 5\n        Console.WriteLine(PrimeFib(4)); \/\/ Output: 13\n        Console.WriteLine(PrimeFib(5)); \/\/ Output: 89\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(PrimeFib((1L)) == (2L));\n    Debug.Assert(PrimeFib((2L)) == (3L));\n    Debug.Assert(PrimeFib((3L)) == (5L));\n    Debug.Assert(PrimeFib((4L)) == (13L));\n    Debug.Assert(PrimeFib((5L)) == (89L));\n    Debug.Assert(PrimeFib((6L)) == (233L));\n    Debug.Assert(PrimeFib((7L)) == (1597L));\n    Debug.Assert(PrimeFib((8L)) == (28657L));\n    Debug.Assert(PrimeFib((9L)) == (514229L));\n    Debug.Assert(PrimeFib((10L)) == (433494437L));\n    }\n\n}\n"},{"task_id":"HumanEval_40","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Suma ku no i ka nada, i ka ten nada.    \/\/ta torna verdadi si ten três elementu distintu na lista ki     \/\/triples_sum_to_zero ta toma un lista di númeru interu komu un input.     \/\/ >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))\n    \/\/ (false)\n    \/\/ >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))\n    \/\/ (true)\n    \/\/ >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))\n    \/\/ (false)\n    \/\/ >>> TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L})))\n    \/\/ (true)\n    \/\/ >>> TriplesSumToZero((new List<long>(new long[]{(long)1L})))\n    \/\/ (false)\n    public static bool TriplesSumToZero(List<long> l) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static bool TriplesSumToZero(List<long> l)\n    {\n        if (l.Count < 3)\n            return false;\n\n        l.Sort();\n\n        for (int i = 0; i < l.Count - 2; i++)\n        {\n            if (i > 0 && l[i] == l[i - 1])\n                continue;\n\n            int left = i + 1;\n            int right = l.Count - 1;\n\n            while (left < right)\n            {\n                long sum = l[i] + l[left] + l[right];\n                if (sum == 0)\n                    return true;\n                else if (sum < 0)\n                    left++;\n                else\n                    right--;\n            }\n        }\n\n        return false;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-1L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (true));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)5L, (long)7L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L}))) == (true));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-100L}))) == (false));\n    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)100L, (long)3L, (long)5L, (long)-100L}))) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_41","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Kel funson li ta mostra kantu bês ki kel tipu di asidenti kontise.     \/\/na ses trajetória sima si es ka kolaba.    \/\/Má, es karru é fórti i es ka ta kaba. Pur isu es ta kontinua ta anda.    \/\/óki un karu ki sta ta bai di ladu direitu ta da na un karu ki sta ta bai di ladu direitu pa ladu skérdu.    \/\/tudu karru ta anda ku mesmu velosidadi, ta fladu ma 2 karru ta kolidia    \/\/Es dos grupu di karru kumesa ta anda txeu lonji di     \/\/n karru sta ta konduzi pa skérda pa direita; simultánamenti, un otu grupu di n karru     \/\/Imajina un kaminhu ki é un linha perfetu, di lonji infinitivu.    public static long CarRaceCollision(long n) {\n","canonical_solution":"\/\/ Each car moving left to right will collide with each car moving right to left.\n        \/\/ So the total number of collisions is n * n.\n        return n * n;\n    }\n\n    public static void Main(string[] args) {\n        Console.WriteLine(CarRaceCollision(5));  \/\/ Example usage\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CarRaceCollision((2L)) == (4L));\n    Debug.Assert(CarRaceCollision((3L)) == (9L));\n    Debug.Assert(CarRaceCollision((4L)) == (16L));\n    Debug.Assert(CarRaceCollision((8L)) == (64L));\n    Debug.Assert(CarRaceCollision((10L)) == (100L));\n    }\n\n}\n"},{"task_id":"HumanEval_42","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Lista di retorna ku elementu inkrimentadu pa 1.     \/\/ >>> IncrList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))\n    \/\/ >>> IncrList((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))\n    \/\/ (new List<long>(new long[]{(long)6L, (long)4L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))\n    public static List<long> IncrList(List<long> l) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ Return list with elements incremented by 1.\n    public static List<long> IncrList(List<long> l) {\n        return l.Select(x => x + 1).ToList();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IncrList((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(IncrList((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)3L, (long)2L}))));\n    Debug.Assert(IncrList((new List<long>(new long[]{(long)5L, (long)2L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)6L, (long)3L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_43","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Suma ku no i ka nada, i ka ten nada.    \/\/ta torna verdadi si ten dôs elementu distintu na lista ki     \/\/pairs_sum_to_zero ta toma un lista di númeru interu komu un input.     \/\/ >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))\n    \/\/ (false)\n    \/\/ >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))\n    \/\/ (false)\n    \/\/ >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))\n    \/\/ (false)\n    \/\/ >>> PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L})))\n    \/\/ (true)\n    \/\/ >>> PairsSumToZero((new List<long>(new long[]{(long)1L})))\n    \/\/ (false)\n    public static bool PairsSumToZero(List<long> l) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static bool PairsSumToZero(List<long> l)\n    {\n        HashSet<long> seenNumbers = new HashSet<long>();\n\n        foreach (long number in l)\n        {\n            if (seenNumbers.Contains(-number))\n            {\n                return true;\n            }\n            seenNumbers.Add(number);\n        }\n\n        return false;\n    }\n\n    public static void Main(string[] args)\n    {\n        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, 5L, 0L })); \/\/ false\n        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, -2L, 1L })); \/\/ false\n        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 2L, 3L, 7L })); \/\/ false\n        Console.WriteLine(PairsSumToZero(new List<long> { 2L, 4L, -5L, 3L, 5L, 7L })); \/\/ true\n        Console.WriteLine(PairsSumToZero(new List<long> { 1L })); \/\/ false\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (false));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L}))) == (true));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L}))) == (false));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)30L}))) == (true));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)31L}))) == (true));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)30L}))) == (false));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)31L}))) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_44","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/númeru di bázis é menus di 10.     \/\/torna riprizentason di stringa dipôs di konverson.     \/\/Mudansa bazis numéris di númeru x pa bazis.     \/\/ >>> ChangeBase((8L), (3L))\n    \/\/ (\"22\")\n    \/\/ >>> ChangeBase((8L), (2L))\n    \/\/ (\"1000\")\n    \/\/ >>> ChangeBase((7L), (2L))\n    \/\/ (\"111\")\n    public static string ChangeBase(long x, long numBase) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ Change numerical base of input number x to base.\n    \/\/ return string representation after the conversion.\n    \/\/ base numbers are less than 10.\n    public static string ChangeBase(long x, long numBase) {\n        if (numBase < 2 || numBase > 9) \n            throw new ArgumentException(\"Base must be between 2 and 9.\");\n\n        if (x < 0) \n            throw new ArgumentException(\"Number must be non-negative.\");\n\n        if (x == 0) \n            return \"0\";\n\n        string result = string.Empty;\n        while (x > 0) {\n            long remainder = x % numBase;\n            result = remainder + result;\n            x \/= numBase;\n        }\n        \n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ChangeBase((8L), (3L)).Equals((\"22\")));\n    Debug.Assert(ChangeBase((9L), (3L)).Equals((\"100\")));\n    Debug.Assert(ChangeBase((234L), (2L)).Equals((\"11101010\")));\n    Debug.Assert(ChangeBase((16L), (2L)).Equals((\"10000\")));\n    Debug.Assert(ChangeBase((8L), (2L)).Equals((\"1000\")));\n    Debug.Assert(ChangeBase((7L), (2L)).Equals((\"111\")));\n    Debug.Assert(ChangeBase((2L), (3L)).Equals((\"2\")));\n    Debug.Assert(ChangeBase((3L), (4L)).Equals((\"3\")));\n    Debug.Assert(ChangeBase((4L), (5L)).Equals((\"4\")));\n    Debug.Assert(ChangeBase((5L), (6L)).Equals((\"5\")));\n    Debug.Assert(ChangeBase((6L), (7L)).Equals((\"6\")));\n    Debug.Assert(ChangeBase((7L), (8L)).Equals((\"7\")));\n    }\n\n}\n"},{"task_id":"HumanEval_45","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Dadu lonji di un ladu i altu ária di retórdi pa un triángulu.    \/\/ >>> TriangleArea((5L), (3L))\n    \/\/ (7.5f)\n    public static float TriangleArea(long a, long h) {\n","canonical_solution":"using System;\n\nclass Problem {\n    \/\/ Given length of a side and height, return area for a triangle.\n    \/\/ >>> TriangleArea((5L), (3L))\n    \/\/ (7.5f)\n    public static float TriangleArea(long a, long h) {\n        return (a * h) \/ 2.0f;\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(TriangleArea(5L, 3L)); \/\/ Output: 7.5\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(TriangleArea((5L), (3L)) == (7.5f));\n    Debug.Assert(TriangleArea((2L), (2L)) == (2.0f));\n    Debug.Assert(TriangleArea((10L), (8L)) == (40.0f));\n    }\n\n}\n"},{"task_id":"HumanEval_46","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur favor, skrebe un funson pa konputa n-ésimu elementu di sekvens di númeru fib4.    \/\/fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).     \/\/fib4(3) -> 0  ki ta da pa dentu    \/\/fib4(2) -> 2  ki ta faze    \/\/fib4(1) -> 0  ki ta da pa sabe    \/\/fib4(0) -> 0  ki ta da pa dentu    \/\/Sekuénsia di númeru Fib4 é un sekéensia sima sekéensia di Fibbonacci ki é difinidu sima siginti:     \/\/ >>> Fib4((5L))\n    \/\/ (4L)\n    \/\/ >>> Fib4((6L))\n    \/\/ (8L)\n    \/\/ >>> Fib4((7L))\n    \/\/ (14L)\n    public static long Fib4(long n) {\n","canonical_solution":"public static long Fib4(long n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n    if (n == 3) return 0;\n\n    long[] fib4Seq = new long[n + 1];\n    fib4Seq[0] = 0;\n    fib4Seq[1] = 0;\n    fib4Seq[2] = 2;\n    fib4Seq[3] = 0;\n\n    for (long i = 4; i <= n; i++) {\n        fib4Seq[i] = fib4Seq[i - 1] + fib4Seq[i - 2] + fib4Seq[i - 3] + fib4Seq[i - 4];\n    }\n\n    return fib4Seq[n];\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Fib4((5L)) == (4L));\n    Debug.Assert(Fib4((8L)) == (28L));\n    Debug.Assert(Fib4((10L)) == (104L));\n    Debug.Assert(Fib4((12L)) == (386L));\n    }\n\n}\n"},{"task_id":"HumanEval_47","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Mediana di rendimentu di elementu na lista l.     \/\/ >>> Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))\n    \/\/ (float)3L\n    \/\/ >>> Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L})))\n    \/\/ (15.0f)\n    public static float Median(List<long> l) {\n","canonical_solution":"public static float Median(List<long> l) {\n        l.Sort();\n        int count = l.Count;\n        if (count % 2 == 1) {\n            return (float)l[count \/ 2];\n        } else {\n            long mid1 = l[(count \/ 2) - 1];\n            long mid2 = l[count \/ 2];\n            return (mid1 + mid2) \/ 2.0f;\n        }\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) == (float)3L);\n    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));\n    Debug.Assert(Median((new List<long>(new long[]{(long)5L}))) == (float)5L);\n    Debug.Assert(Median((new List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));\n    Debug.Assert(Median((new List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L, (long)7L}))) == (float)7L);\n    }\n\n}\n"},{"task_id":"HumanEval_48","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Ta djobe si kel stringa ki dadu é un palindromu     \/\/ >>> IsPalindrome((\"\"))\n    \/\/ (true)\n    \/\/ >>> IsPalindrome((\"aba\"))\n    \/\/ (true)\n    \/\/ >>> IsPalindrome((\"aaaaa\"))\n    \/\/ (true)\n    \/\/ >>> IsPalindrome((\"zbcd\"))\n    \/\/ (false)\n    public static bool IsPalindrome(string text) {\n","canonical_solution":"public static bool IsPalindrome(string text) {\n    if (string.IsNullOrEmpty(text))\n        return true;\n\n    int left = 0;\n    int right = text.Length - 1;\n\n    while (left < right) {\n        if (text[left] != text[right])\n            return false;\n        left++;\n        right--;\n    }\n\n    return true;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsPalindrome((\"\")) == (true));\n    Debug.Assert(IsPalindrome((\"aba\")) == (true));\n    Debug.Assert(IsPalindrome((\"aaaaa\")) == (true));\n    Debug.Assert(IsPalindrome((\"zbcd\")) == (false));\n    Debug.Assert(IsPalindrome((\"xywyx\")) == (true));\n    Debug.Assert(IsPalindrome((\"xywyz\")) == (false));\n    Debug.Assert(IsPalindrome((\"xywzx\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_49","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna 2^n modulo p (tenpu di konhesimentu di numérismu).    \/\/ >>> Modp((3L), (5L))\n    \/\/ (3L)\n    \/\/ >>> Modp((1101L), (101L))\n    \/\/ (2L)\n    \/\/ >>> Modp((0L), (101L))\n    \/\/ (1L)\n    \/\/ >>> Modp((3L), (11L))\n    \/\/ (8L)\n    \/\/ >>> Modp((100L), (101L))\n    \/\/ (1L)\n    public static long Modp(long n, long p) {\n","canonical_solution":"using System;\nusing System.Numerics;\n\nclass Problem {\n    public static long Modp(long n, long p) {\n        \/\/ Using the property of modular arithmetic: (a^b) % c = ((a % c)^b) % c\n        \/\/ We are calculating (2^n) % p\n        BigInteger baseNum = 2;\n        BigInteger result = BigInteger.ModPow(baseNum, n, p);\n        return (long)result;\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(Modp(3L, 5L));   \/\/ (3L)\n        Console.WriteLine(Modp(1101L, 101L)); \/\/ (2L)\n        Console.WriteLine(Modp(0L, 101L));   \/\/ (1L)\n        Console.WriteLine(Modp(3L, 11L));   \/\/ (8L)\n        Console.WriteLine(Modp(100L, 101L));  \/\/ (1L)\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Modp((3L), (5L)) == (3L));\n    Debug.Assert(Modp((1101L), (101L)) == (2L));\n    Debug.Assert(Modp((0L), (101L)) == (1L));\n    Debug.Assert(Modp((3L), (11L)) == (8L));\n    Debug.Assert(Modp((100L), (101L)) == (1L));\n    Debug.Assert(Modp((30L), (5L)) == (4L));\n    Debug.Assert(Modp((31L), (5L)) == (3L));\n    }\n\n}\n"},{"task_id":"HumanEval_51","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/remove_vowels é un funson ki ta toma stringa y ta torna stringa sen vogal.     \/\/ >>> RemoveVowels((\"\"))\n    \/\/ (\"\")\n    \/\/ >>> RemoveVowels((\"abcdef\"))\n    \/\/ (\"bcdf\")\n    \/\/ >>> RemoveVowels((\"aaaaa\"))\n    \/\/ (\"\")\n    \/\/ >>> RemoveVowels((\"aaBAA\"))\n    \/\/ (\"B\")\n    \/\/ >>> RemoveVowels((\"zbcd\"))\n    \/\/ (\"zbcd\")\n    public static string RemoveVowels(string text) {\n","canonical_solution":"HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };\n        StringBuilder result = new StringBuilder();\n\n        foreach (char c in text) {\n            if (!vowels.Contains(c)) {\n                result.Append(c);\n            }\n        }\n\n        return result.ToString();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(RemoveVowels((\"\")).Equals((\"\")));\n    Debug.Assert(RemoveVowels((\"abcdef\\nghijklm\")).Equals((\"bcdf\\nghjklm\")));\n    Debug.Assert(RemoveVowels((\"fedcba\")).Equals((\"fdcb\")));\n    Debug.Assert(RemoveVowels((\"eeeee\")).Equals((\"\")));\n    Debug.Assert(RemoveVowels((\"acBAA\")).Equals((\"cB\")));\n    Debug.Assert(RemoveVowels((\"EcBOO\")).Equals((\"cB\")));\n    Debug.Assert(RemoveVowels((\"ybcd\")).Equals((\"ybcd\")));\n    }\n\n}\n"},{"task_id":"HumanEval_52","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna verdadi si tudu númeru na lista l sta baxu di limiar t.     \/\/ >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L))\n    \/\/ (true)\n    \/\/ >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L))\n    \/\/ (false)\n    public static bool BelowThreshold(List<long> l, long t) {\n","canonical_solution":"return l.All(x => x < t);\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L)) == (true));\n    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L)) == (false));\n    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (21L)) == (true));\n    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (22L)) == (true));\n    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (11L)) == (true));\n    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (10L)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_53","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Nu djunta dôs númeru x i y     \/\/ >>> Add((2L), (3L))\n    \/\/ (5L)\n    \/\/ >>> Add((5L), (7L))\n    \/\/ (12L)\n    public static long Add(long x, long y) {\n","canonical_solution":"return x + y;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Add((0L), (1L)) == (1L));\n    Debug.Assert(Add((1L), (0L)) == (1L));\n    Debug.Assert(Add((2L), (3L)) == (5L));\n    Debug.Assert(Add((5L), (7L)) == (12L));\n    Debug.Assert(Add((7L), (5L)) == (12L));\n    }\n\n}\n"},{"task_id":"HumanEval_54","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Odja si dôs palavra ten mésmu karáter.     \/\/ >>> SameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n    \/\/ (true)\n    \/\/ >>> SameChars((\"abcd\"), (\"dddddddabc\"))\n    \/\/ (true)\n    \/\/ >>> SameChars((\"dddddddabc\"), (\"abcd\"))\n    \/\/ (true)\n    \/\/ >>> SameChars((\"eabcd\"), (\"dddddddabc\"))\n    \/\/ (false)\n    \/\/ >>> SameChars((\"abcd\"), (\"dddddddabce\"))\n    \/\/ (false)\n    \/\/ >>> SameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n    \/\/ (false)\n    public static bool SameChars(string s0, string s1) {\n","canonical_solution":"public static bool SameChars(string s0, string s1) {\n        \/\/ Return true if s1 contains all characters of s0\n        return s0.All(c => s1.Contains(c)) && s1.All(c => s0.Contains(c));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\")) == (true));\n    Debug.Assert(SameChars((\"abcd\"), (\"dddddddabc\")) == (true));\n    Debug.Assert(SameChars((\"dddddddabc\"), (\"abcd\")) == (true));\n    Debug.Assert(SameChars((\"eabcd\"), (\"dddddddabc\")) == (false));\n    Debug.Assert(SameChars((\"abcd\"), (\"dddddddabcf\")) == (false));\n    Debug.Assert(SameChars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\")) == (false));\n    Debug.Assert(SameChars((\"aabb\"), (\"aaccc\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_55","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna númeru di Fibonacci di n-ésimu.     \/\/ >>> Fib((10L))\n    \/\/ (55L)\n    \/\/ >>> Fib((1L))\n    \/\/ (1L)\n    \/\/ >>> Fib((8L))\n    \/\/ (21L)\n    public static long Fib(long n) {\n","canonical_solution":"if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    long a = 0;\n    long b = 1;\n\n    for (long i = 2; i <= n; i++)\n    {\n        long temp = a + b;\n        a = b;\n        b = temp;\n    }\n\n    return b;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Fib((10L)) == (55L));\n    Debug.Assert(Fib((1L)) == (1L));\n    Debug.Assert(Fib((8L)) == (21L));\n    Debug.Assert(Fib((11L)) == (89L));\n    Debug.Assert(Fib((12L)) == (144L));\n    }\n\n}\n"},{"task_id":"HumanEval_56","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna verdadi si tudu bracket di abertura ten un bracket di konkluzon koresponenti.     \/\/parentis é un stringa di \"<\" y \">\".     \/\/ >>> CorrectBracketing((\"<\"))\n    \/\/ (false)\n    \/\/ >>> CorrectBracketing((\"<>\"))\n    \/\/ (true)\n    \/\/ >>> CorrectBracketing((\"<<><>>\"))\n    \/\/ (true)\n    \/\/ >>> CorrectBracketing((\"><<>\"))\n    \/\/ (false)\n    public static bool CorrectBracketing(string brackets) {\n","canonical_solution":"public static bool CorrectBracketing(string brackets) \n{\n    int balance = 0;\n    foreach (char c in brackets) \n    {\n        if (c == '<') \n        {\n            balance++;\n        } \n        else if (c == '>') \n        {\n            balance--;\n        }\n        \n        if (balance < 0) \n        {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CorrectBracketing((\"<>\")) == (true));\n    Debug.Assert(CorrectBracketing((\"<<><>>\")) == (true));\n    Debug.Assert(CorrectBracketing((\"<><><<><>><>\")) == (true));\n    Debug.Assert(CorrectBracketing((\"<><><<<><><>><>><<><><<>>>\")) == (true));\n    Debug.Assert(CorrectBracketing((\"<<<><>>>>\")) == (false));\n    Debug.Assert(CorrectBracketing((\"><<>\")) == (false));\n    Debug.Assert(CorrectBracketing((\"<\")) == (false));\n    Debug.Assert(CorrectBracketing((\"<<<<\")) == (false));\n    Debug.Assert(CorrectBracketing((\">\")) == (false));\n    Debug.Assert(CorrectBracketing((\"<<>\")) == (false));\n    Debug.Assert(CorrectBracketing((\"<><><<><>><>><<>\")) == (false));\n    Debug.Assert(CorrectBracketing((\"<><><<><>><>>><>\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_57","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna verdadi si elementu di lista sta monotóniku ta aumenta ô ta diminui.     \/\/ >>> Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L})))\n    \/\/ (true)\n    \/\/ >>> Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})))\n    \/\/ (false)\n    \/\/ >>> Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L})))\n    \/\/ (true)\n    public static bool Monotonic(List<long> l) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ Return true if list elements are monotonically increasing or decreasing.\n    public static bool Monotonic(List<long> l) {\n        if (l.Count < 2) return true; \/\/ Lists with less than 2 elements are trivially monotonic.\n        \n        bool increasing = true;\n        bool decreasing = true;\n\n        for (int i = 1; i < l.Count; i++) {\n            if (l[i] > l[i - 1]) {\n                decreasing = false;\n            } else if (l[i] < l[i - 1]) {\n                increasing = false;\n            }\n\n            \/\/ If both flags are false, the list is not monotonic.\n            if (!increasing && !decreasing) return false;\n        }\n\n        return true;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L}))) == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L}))) == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L}))) == (false));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L}))) == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L}))) == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)5L, (long)60L}))) == (false));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)60L}))) == (true));\n    Debug.Assert(Monotonic((new List<long>(new long[]{(long)9L, (long)9L, (long)9L, (long)9L}))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_58","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna un elementu unikamenti ordenadu pa dôs lista.     \/\/ >>> Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))\n    \/\/ >>> Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L})))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)3L}))\n    public static List<long> Common(List<long> l1, List<long> l2) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem\n{\n    public static List<long> Common(List<long> l1, List<long> l2)\n    {\n        \/\/ Use HashSet to store unique elements of l1\n        var set1 = new HashSet<long>(l1);\n\n        \/\/ Use HashSet to store unique elements of l2 and filter common elements\n        var commonSet = new HashSet<long>(l2.Where(x => set1.Contains(x)));\n\n        \/\/ Convert to a list, sort it and return\n        var result = commonSet.ToList();\n        result.Sort();\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))));\n    Debug.Assert(Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));\n    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>())).Equals((new List<long>())));\n    }\n\n}\n"},{"task_id":"HumanEval_59","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna kel maior fator primo di n. Nu assume n > 1 i ka é un primo.     \/\/ >>> LargestPrimeFactor((13195L))\n    \/\/ (29L)\n    \/\/ >>> LargestPrimeFactor((2048L))\n    \/\/ (2L)\n    public static long LargestPrimeFactor(long n) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long LargestPrimeFactor(long n) {\n        long largestFactor = -1;\n        \n        \/\/ Remove the factor of 2\n        while (n % 2 == 0) {\n            largestFactor = 2;\n            n \/= 2;\n        }\n\n        \/\/ Check odd factors from 3 upwards\n        for (long i = 3; i <= Math.Sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestFactor = i;\n                n \/= i;\n            }\n        }\n\n        \/\/ If n becomes a prime number greater than 2\n        if (n > 2) {\n            largestFactor = n;\n        }\n\n        return largestFactor;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestPrimeFactor((15L)) == (5L));\n    Debug.Assert(LargestPrimeFactor((27L)) == (3L));\n    Debug.Assert(LargestPrimeFactor((63L)) == (7L));\n    Debug.Assert(LargestPrimeFactor((330L)) == (11L));\n    Debug.Assert(LargestPrimeFactor((13195L)) == (29L));\n    }\n\n}\n"},{"task_id":"HumanEval_60","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/sum_to_n é un funson ki ta soma númeru di 1 ti n.     \/\/ >>> SumToN((30L))\n    \/\/ (465L)\n    \/\/ >>> SumToN((100L))\n    \/\/ (5050L)\n    \/\/ >>> SumToN((5L))\n    \/\/ (15L)\n    \/\/ >>> SumToN((10L))\n    \/\/ (55L)\n    \/\/ >>> SumToN((1L))\n    \/\/ (1L)\n    public static long SumToN(long n) {\n","canonical_solution":"return n * (n + 1) \/ 2;\n}\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SumToN((1L)) == (1L));\n    Debug.Assert(SumToN((6L)) == (21L));\n    Debug.Assert(SumToN((11L)) == (66L));\n    Debug.Assert(SumToN((30L)) == (465L));\n    Debug.Assert(SumToN((100L)) == (5050L));\n    }\n\n}\n"},{"task_id":"HumanEval_61","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna verdadi si tudu bracket di abertura ten un bracket di konkluzon koresponenti.     \/\/parentis é un stringa di \"(\" i \")\".     \/\/ >>> CorrectBracketing((\"(\"))\n    \/\/ (false)\n    \/\/ >>> CorrectBracketing((\"()\"))\n    \/\/ (true)\n    \/\/ >>> CorrectBracketing((\"(()())\"))\n    \/\/ (true)\n    \/\/ >>> CorrectBracketing((\")(()\"))\n    \/\/ (false)\n    public static bool CorrectBracketing(string brackets) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static bool CorrectBracketing(string brackets) {\n        int balance = 0;\n        foreach (char c in brackets) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            if (balance < 0) {\n                return false;\n            }\n        }\n        return balance == 0;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CorrectBracketing((\"()\")) == (true));\n    Debug.Assert(CorrectBracketing((\"(()())\")) == (true));\n    Debug.Assert(CorrectBracketing((\"()()(()())()\")) == (true));\n    Debug.Assert(CorrectBracketing((\"()()((()()())())(()()(()))\")) == (true));\n    Debug.Assert(CorrectBracketing((\"((()())))\")) == (false));\n    Debug.Assert(CorrectBracketing((\")(()\")) == (false));\n    Debug.Assert(CorrectBracketing((\"(\")) == (false));\n    Debug.Assert(CorrectBracketing((\"((((\")) == (false));\n    Debug.Assert(CorrectBracketing((\")\")) == (false));\n    Debug.Assert(CorrectBracketing((\"(()\")) == (false));\n    Debug.Assert(CorrectBracketing((\"()()(()())())(()\")) == (false));\n    Debug.Assert(CorrectBracketing((\"()()(()())()))()\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_62","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna derivadu di kel polinómiu na mésmu fórma.     \/\/xs[0] + xs[1] * x + xs[2] * x^2 + ....     \/\/xs ta reprezenta koefisienti di un polinomi.     \/\/ >>> Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))\n    \/\/ >>> Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)6L}))\n    public static List<long> Derivative(List<long> xs) {\n","canonical_solution":"public static List<long> Derivative(List<long> xs) {\n        List<long> derivative = new List<long>();\n        for (int i = 1; i < xs.Count; i++) {\n            derivative.Add(xs[i] * i);\n        }\n        return derivative;\n    }\n\n    static void Main(string[] args) {\n        List<long> poly1 = new List<long>{3L, 1L, 2L, 4L, 5L};\n        List<long> result1 = Derivative(poly1);\n        Console.WriteLine(string.Join(\", \", result1));\n\n        List<long> poly2 = new List<long>{1L, 2L, 3L};\n        List<long> result2 = Derivative(poly2);\n        Console.WriteLine(string.Join(\", \", result2));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))));\n    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L}))));\n    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));\n    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L, (long)0L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)0L, (long)16L}))));\n    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L}))).Equals((new List<long>())));\n    }\n\n}\n"},{"task_id":"HumanEval_63","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur favor, skrebe un funson pa konputa n-ésimu elementu di sekson di númeru fibfib.     \/\/fibib ((n) == fibib ((n-1) + fibib ((n-2) + fibib ((n-3).     \/\/fib fib ((2) == 1     \/\/fib fib ((1) == 0     \/\/fibfib(0) == 0     \/\/Sekuénsia di númeru FibFib é un sekéensia sima sekéensia di Fibbonacci ki é difinidu sima siginti:     \/\/ >>> Fibfib((1L))\n    \/\/ (0L)\n    \/\/ >>> Fibfib((5L))\n    \/\/ (4L)\n    \/\/ >>> Fibfib((8L))\n    \/\/ (24L)\n    public static long Fibfib(long n) {\n","canonical_solution":"public static long Fibfib(long n) {\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n    if (n == 2) return 1;\n\n    long a = 0, b = 0, c = 1;\n    long result = 0;\n\n    for (long i = 3; i <= n; i++) {\n        result = a + b + c;\n        a = b;\n        b = c;\n        c = result;\n    }\n\n    return result;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Fibfib((2L)) == (1L));\n    Debug.Assert(Fibfib((1L)) == (0L));\n    Debug.Assert(Fibfib((5L)) == (4L));\n    Debug.Assert(Fibfib((8L)) == (24L));\n    Debug.Assert(Fibfib((10L)) == (81L));\n    Debug.Assert(Fibfib((12L)) == (274L));\n    Debug.Assert(Fibfib((14L)) == (927L));\n    }\n\n}\n"},{"task_id":"HumanEval_64","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/vogal, má sô óras ki el sta na fin di palavra.     \/\/Na kel kazu li, vogal é 'a', 'e', 'i', 'o', 'u'.    \/\/un palavra sima input i ta torna numeru di vogal na stringa.     \/\/Skrebe un funson ki ta toma un stringa ki ta riprizenta     \/\/ >>> VowelsCount((\"abcde\"))\n    \/\/ (2L)\n    \/\/ >>> VowelsCount((\"ACEDY\"))\n    \/\/ (3L)\n    public static long VowelsCount(string s) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long VowelsCount(string s) {\n        if (s == null) return 0;\n\n        s = s.ToLower();\n        long count = 0;\n        \n        for (int i = 0; i < s.Length; i++) {\n            char c = s[i];\n            if (\"aeiou\".Contains(c) || (c == 'y' && i == s.Length - 1)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(VowelsCount(\"abcde\"));  \/\/ Output: 2\n        Console.WriteLine(VowelsCount(\"ACEDY\"));  \/\/ Output: 3\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(VowelsCount((\"abcde\")) == (2L));\n    Debug.Assert(VowelsCount((\"Alone\")) == (3L));\n    Debug.Assert(VowelsCount((\"key\")) == (2L));\n    Debug.Assert(VowelsCount((\"bye\")) == (1L));\n    Debug.Assert(VowelsCount((\"keY\")) == (2L));\n    Debug.Assert(VowelsCount((\"bYe\")) == (1L));\n    Debug.Assert(VowelsCount((\"ACEDY\")) == (3L));\n    }\n\n}\n"},{"task_id":"HumanEval_65","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Si mudansas > númeru di dígitos, torna dígitos inversu.     \/\/i torna kel rezultadu sima un stringa.     \/\/Mudansa sirkulár di dígitu di númeru ínteri x, muda di dígitu pa direitu pa mudansas     \/\/ >>> CircularShift((12L), (1L))\n    \/\/ (\"21\")\n    \/\/ >>> CircularShift((12L), (2L))\n    \/\/ (\"12\")\n    public static string CircularShift(long x, long shift) {\n","canonical_solution":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\nclass Problem {\n    \/\/ Circular shift the digits of the integer x, shift the digits right by shift\n    \/\/ and return the result as a string.\n    \/\/ If shift > number of digits, return digits reversed.\n    \n    public static string CircularShift(long x, long shift) {\n        string digits = x.ToString();\n        int length = digits.Length;\n        \n        if (shift > length) {\n            char[] reversedDigits = digits.ToCharArray();\n            Array.Reverse(reversedDigits);\n            return new string(reversedDigits);\n        }\n\n        shift = shift % length;  \/\/ Normalize shift\n        string shiftedPart = digits.Substring(length - (int)shift);\n        string remainingPart = digits.Substring(0, length - (int)shift);\n        return shiftedPart + remainingPart;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CircularShift((100L), (2L)).Equals((\"001\")));\n    Debug.Assert(CircularShift((12L), (2L)).Equals((\"12\")));\n    Debug.Assert(CircularShift((97L), (8L)).Equals((\"79\")));\n    Debug.Assert(CircularShift((12L), (1L)).Equals((\"21\")));\n    Debug.Assert(CircularShift((11L), (101L)).Equals((\"11\")));\n    }\n\n}\n"},{"task_id":"HumanEval_66","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Kódigu ASCII.     \/\/Skrebe un funson ki ta toma un stringa komu entrada i ta torna somason di kes karater más altu so'     \/\/TIZORUS DI PALAVRA DI DEUS    \/\/ >>> Digitsum((\"\"))\n    \/\/ (0L)\n    \/\/ >>> Digitsum((\"abAB\"))\n    \/\/ (131L)\n    \/\/ >>> Digitsum((\"abcCd\"))\n    \/\/ (67L)\n    \/\/ >>> Digitsum((\"helloE\"))\n    \/\/ (69L)\n    \/\/ >>> Digitsum((\"woArBld\"))\n    \/\/ (131L)\n    \/\/ >>> Digitsum((\"aAaaaXa\"))\n    \/\/ (153L)\n    public static long Digitsum(string s) {\n","canonical_solution":"public static long Digitsum(string s) {\n    long sum = 0;\n    foreach (char c in s) {\n        if (char.IsUpper(c)) {\n            sum += c; \/\/ Add ASCII value of the upper case letters.\n        }\n    }\n    return sum;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Digitsum((\"\")) == (0L));\n    Debug.Assert(Digitsum((\"abAB\")) == (131L));\n    Debug.Assert(Digitsum((\"abcCd\")) == (67L));\n    Debug.Assert(Digitsum((\"helloE\")) == (69L));\n    Debug.Assert(Digitsum((\"woArBld\")) == (131L));\n    Debug.Assert(Digitsum((\"aAaaaXa\")) == (153L));\n    Debug.Assert(Digitsum((\" How are yOu?\")) == (151L));\n    Debug.Assert(Digitsum((\"You arE Very Smart\")) == (327L));\n    }\n\n}\n"},{"task_id":"HumanEval_67","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/pa exablu:     \/\/na korbu, da nómi di fruta di manga ki sta na korbu.     \/\/naranja ku mansanha i un númeru interu ki ta riprizenta númeru total di frutas     \/\/N ta da-u un númeru di     \/\/ki ta distribuidu na un korbu di fruta ki es korbu ta kontenti     \/\/Na es tarefa, bu ta dadu un fila ki ta riprizenta un númeru di maçãs i naranhas     \/\/ >>> FruitDistribution((\"5 apples and 6 oranges\"), (19L))\n    \/\/ (8L)\n    \/\/ >>> FruitDistribution((\"0 apples and 1 oranges\"), (3L))\n    \/\/ (2L)\n    \/\/ >>> FruitDistribution((\"2 apples and 3 oranges\"), (100L))\n    \/\/ (95L)\n    \/\/ >>> FruitDistribution((\"100 apples and 1 oranges\"), (120L))\n    \/\/ (19L)\n    public static long FruitDistribution(string s, long n) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long FruitDistribution(string s, long n) {\n        var parts = s.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n        long apples = long.Parse(parts[0]);\n        long oranges = long.Parse(parts[3]);\n\n        long totalApplesAndOranges = apples + oranges;\n        long mangoes = n - totalApplesAndOranges;\n        \n        return mangoes;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FruitDistribution((\"5 apples and 6 oranges\"), (19L)) == (8L));\n    Debug.Assert(FruitDistribution((\"5 apples and 6 oranges\"), (21L)) == (10L));\n    Debug.Assert(FruitDistribution((\"0 apples and 1 oranges\"), (3L)) == (2L));\n    Debug.Assert(FruitDistribution((\"1 apples and 0 oranges\"), (3L)) == (2L));\n    Debug.Assert(FruitDistribution((\"2 apples and 3 oranges\"), (100L)) == (95L));\n    Debug.Assert(FruitDistribution((\"2 apples and 3 oranges\"), (5L)) == (0L));\n    Debug.Assert(FruitDistribution((\"1 apples and 100 oranges\"), (120L)) == (19L));\n    }\n\n}\n"},{"task_id":"HumanEval_68","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu 1:     \/\/Si ka ten ninhun valor par ô si lista ki dadu é ka ten ninhun, torna [].     \/\/Kel nódulu ki bu skodje debe ser resebedu na un lista, [ smalest_value, se indéksu ],     \/\/Si nu atxa más un nó ku mesmu mínimu valor par, nu ta torna da nó ki ten mínimu indéks.     \/\/Kel nó di puleru debe ser kel nó ki ten más poku valor par.    \/\/bu trabadju é pega un di kes nódulu i torna da-l.    \/\/\"Dadu un lista ki ta riprizenta un ramu di un árvore ki ten nódus di númeru interu ki é ka negativu     \/\/ >>> Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L})))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)1L}))\n    \/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    \/\/ Example 2:\n    \/\/ >>> Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)1L}))\n    \/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    \/\/ Example 3:\n    \/\/ >>> Pluck((new List<long>()))\n    \/\/ (new List<long>())\n    \/\/ Example 4:\n    \/\/ >>> Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L})))\n    \/\/ (new List<long>(new long[]{(long)0L, (long)1L}))\n    \/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n    \/\/ so we will choose the first zero, which has the smallest index.\n    \/\/ Constraints:\n    \/\/ * 1 <= nodes.length <= 10000\n    \/\/ * 0 <= node.value\n    public static List<long> Pluck(List<long> arr) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<long> Pluck(List<long> arr)\n    {\n        long smallestEven = long.MaxValue;\n        int indexOfSmallest = -1;\n\n        for (int i = 0; i < arr.Count; i++)\n        {\n            if (arr[i] % 2 == 0 && arr[i] < smallestEven)\n            {\n                smallestEven = arr[i];\n                indexOfSmallest = i;\n            }\n        }\n\n        if (indexOfSmallest == -1)\n        {\n            return new List<long>();\n        }\n        else\n        {\n            return new List<long> { smallestEven, indexOfSmallest };\n        }\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));\n    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));\n    Debug.Assert(Pluck((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L}))));\n    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)0L, (long)5L, (long)3L}))).Equals((new List<long>(new long[]{(long)0L, (long)3L}))));\n    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)4L, (long)8L, (long)4L, (long)8L}))).Equals((new List<long>(new long[]{(long)4L, (long)1L}))));\n    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)6L, (long)7L, (long)1L}))).Equals((new List<long>(new long[]{(long)6L, (long)1L}))));\n    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)9L, (long)7L, (long)1L}))).Equals((new List<long>())));\n    }\n\n}\n"},{"task_id":"HumanEval_69","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Si ka izisti ninhun valor di es tipu, torna -1.     \/\/Frekuénsia di un númeru interu é kel ki el ta parse na lista.     \/\/nu, y ten un frekuénsia más grandi ki ô igual a valor di própi númeru interu.     \/\/Bu ta dadu un lista di purtuges pozitivu ki ka é ka bu ta da-l.    \/\/ >>> Search((new List<long>(new long[]{(long)4L, (long)1L, (long)2L, (long)2L, (long)3L, (long)1L})))\n    \/\/ (2L)\n    \/\/ >>> Search((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L, (long)4L})))\n    \/\/ (3L)\n    \/\/ >>> Search((new List<long>(new long[]{(long)5L, (long)5L, (long)4L, (long)4L, (long)4L})))\n    \/\/ (-1L)\n    public static long Search(List<long> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem\n{\n    public static long Search(List<long> lst)\n    {\n        \/\/ Create a dictionary to store the frequency of each number\n        Dictionary<long, long> frequency = new Dictionary<long, long>();\n\n        \/\/ Count the frequency of each number in the list\n        foreach (long num in lst)\n        {\n            if (frequency.ContainsKey(num))\n            {\n                frequency[num]++;\n            }\n            else\n            {\n                frequency[num] = 1;\n            }\n        }\n\n        \/\/ Variable to store the greatest integer found\n        long result = -1;\n\n        \/\/ Go through each item in the frequency dictionary\n        foreach (var kvp in frequency)\n        {\n            long number = kvp.Key;\n            long freq = kvp.Value;\n\n            \/\/ Check if the number's frequency is greater than or equal to the number itself\n            if (freq >= number && number > 0)\n            {\n                \/\/ Update the result if this number is greater than the current result\n                result = Math.Max(result, number);\n            }\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L, (long)1L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)4L, (long)1L, (long)4L, (long)1L, (long)4L, (long)4L}))) == (4L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)3L}))) == (-1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L}))) == (8L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)3L, (long)3L, (long)2L, (long)2L}))) == (2L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)7L, (long)8L, (long)8L, (long)4L, (long)8L, (long)7L, (long)3L, (long)9L, (long)6L, (long)5L, (long)10L, (long)4L, (long)3L, (long)6L, (long)7L, (long)1L, (long)7L, (long)4L, (long)10L, (long)8L, (long)1L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)2L, (long)8L, (long)2L}))) == (2L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)7L, (long)1L, (long)8L, (long)8L, (long)10L, (long)5L, (long)8L, (long)5L, (long)3L, (long)10L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)3L, (long)6L, (long)5L, (long)6L, (long)4L}))) == (-1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)6L, (long)7L, (long)1L, (long)4L, (long)7L, (long)1L, (long)8L, (long)8L, (long)9L, (long)8L, (long)10L, (long)10L, (long)8L, (long)4L, (long)10L, (long)4L, (long)10L, (long)1L, (long)2L, (long)9L, (long)5L, (long)7L, (long)9L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)9L, (long)10L, (long)1L, (long)3L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)7L, (long)5L, (long)8L, (long)7L, (long)5L, (long)3L, (long)7L, (long)5L, (long)10L, (long)10L, (long)3L, (long)6L, (long)10L, (long)2L, (long)8L, (long)6L, (long)5L, (long)4L, (long)9L, (long)5L, (long)3L, (long)10L}))) == (5L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)1L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)10L, (long)6L, (long)4L, (long)3L, (long)5L, (long)8L, (long)2L, (long)4L, (long)2L, (long)8L, (long)4L, (long)6L, (long)10L, (long)4L, (long)2L, (long)1L, (long)10L, (long)2L, (long)1L, (long)1L, (long)5L}))) == (4L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)10L, (long)4L, (long)8L, (long)2L, (long)10L, (long)5L, (long)1L, (long)2L, (long)9L, (long)5L, (long)5L, (long)6L, (long)3L, (long)8L, (long)6L, (long)4L, (long)10L}))) == (2L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)6L, (long)10L, (long)1L, (long)6L, (long)9L, (long)10L, (long)8L, (long)6L, (long)8L, (long)7L, (long)3L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)2L, (long)4L, (long)1L, (long)5L, (long)1L, (long)5L, (long)2L, (long)5L, (long)7L, (long)7L, (long)7L, (long)3L, (long)10L, (long)1L, (long)5L, (long)4L, (long)2L, (long)8L, (long)4L, (long)1L, (long)9L, (long)10L, (long)7L, (long)10L, (long)2L, (long)8L, (long)10L, (long)9L, (long)4L}))) == (4L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)6L, (long)4L, (long)2L, (long)8L, (long)7L, (long)5L, (long)6L, (long)4L, (long)10L, (long)4L, (long)6L, (long)3L, (long)7L, (long)8L, (long)8L, (long)3L, (long)1L, (long)4L, (long)2L, (long)2L, (long)10L, (long)7L}))) == (4L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)8L, (long)6L, (long)10L, (long)2L, (long)6L, (long)10L, (long)2L, (long)7L, (long)8L, (long)10L, (long)3L, (long)8L, (long)2L, (long)6L, (long)2L, (long)3L, (long)1L}))) == (2L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)3L, (long)9L, (long)5L, (long)6L, (long)3L, (long)2L, (long)8L, (long)5L, (long)6L, (long)10L, (long)10L, (long)6L, (long)8L, (long)4L, (long)10L, (long)7L, (long)7L, (long)10L, (long)8L}))) == (-1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)10L}))) == (-1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)7L, (long)7L, (long)2L, (long)4L, (long)7L, (long)2L, (long)10L, (long)9L, (long)7L, (long)5L, (long)7L, (long)2L}))) == (2L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)4L, (long)10L, (long)2L, (long)1L, (long)1L, (long)10L, (long)3L, (long)6L, (long)1L, (long)8L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)7L, (long)9L, (long)9L, (long)9L, (long)3L, (long)4L, (long)1L, (long)5L, (long)9L, (long)1L, (long)2L, (long)1L, (long)1L, (long)10L, (long)7L, (long)5L, (long)6L, (long)7L, (long)6L, (long)7L, (long)7L, (long)6L}))) == (1L));\n    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)10L, (long)10L, (long)9L, (long)2L}))) == (-1L));\n    }\n\n}\n"},{"task_id":"HumanEval_70","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/dipôs, másimu di kes númeru interu ki resta, dipôs mínimu y asin.    \/\/Sortamentu stranhu, é óras ki bu kumesa ku valor mínimu,     \/\/Si nu da-l un lista di númeru interu, el ta torna da un lista ki ka sta na ordi.    \/\/ >>> StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))\n    \/\/ >>> StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L})))\n    \/\/ (new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))\n    \/\/ >>> StrangeSortList((new List<long>()))\n    \/\/ (new List<long>())\n    public static List<long> StrangeSortList(List<long> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static List<long> StrangeSortList(List<long> lst) {\n        List<long> result = new List<long>();\n        lst.Sort();\n        int start = 0;\n        int end = lst.Count - 1;\n        \n        while (start <= end) {\n            if (start <= end) {\n                result.Add(lst[start]);\n                start++;\n            }\n            if (start <= end) {\n                result.Add(lst[end]);\n                end--;\n            }\n        }\n        \n        return result;\n    }\n    \n    static void Main(string[] args) {\n        var example1 = StrangeSortList(new List<long> { 1L, 2L, 3L, 4L });\n        var example2 = StrangeSortList(new List<long> { 5L, 5L, 5L, 5L });\n        var example3 = StrangeSortList(new List<long>());\n\n        Console.WriteLine(string.Join(\", \", example1)); \/\/ Output: 1, 4, 2, 3\n        Console.WriteLine(string.Join(\", \", example2)); \/\/ Output: 5, 5, 5, 5\n        Console.WriteLine(string.Join(\", \", example3)); \/\/ Output: (empty line)\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))).Equals((new List<long>(new long[]{(long)5L, (long)9L, (long)6L, (long)8L, (long)7L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)9L, (long)5L, (long)8L, (long)6L, (long)7L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))).Equals((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))));\n    Debug.Assert(StrangeSortList((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L}))).Equals((new List<long>(new long[]{(long)1L, (long)8L, (long)2L, (long)7L, (long)3L, (long)6L, (long)4L, (long)5L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)0L, (long)2L, (long)2L, (long)2L, (long)5L, (long)5L, (long)-5L, (long)-5L}))).Equals((new List<long>(new long[]{(long)-5L, (long)5L, (long)-5L, (long)5L, (long)0L, (long)2L, (long)2L, (long)2L}))));\n    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)111111L}))).Equals((new List<long>(new long[]{(long)111111L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_71","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/di kel otu ladu.    \/\/Três ladu ta faze un triângulu válidu óras ki suma di kalker dos ladu é más grandi.    \/\/Si ka ten, torna da -1     \/\/triangulu arredondadu pa 2 pontu desimal si kes três ladu ta forma un triangulu válidu.     \/\/Nu ta da longi di kes três ladu di un triângulu.    \/\/ >>> TriangleArea((3L), (4L), (5L))\n    \/\/ (6.0f)\n    \/\/ >>> TriangleArea((1L), (2L), (10L))\n    \/\/ (float)-1L\n    public static float TriangleArea(long a, long b, long c) {\n","canonical_solution":"public static float TriangleArea(long a, long b, long c) {\n    \/\/ Check if the sides form a valid triangle using the triangle inequality theorem\n    if (a + b > c && a + c > b && b + c > a) {\n        \/\/ Use Heron's formula to calculate the area of the triangle\n        double s = (a + b + c) \/ 2.0;\n        double area = Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        return (float)Math.Round(area, 2);\n    }\n    return -1;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(TriangleArea((3L), (4L), (5L)) == (6.0f));\n    Debug.Assert(TriangleArea((1L), (2L), (10L)) == (float)-1L);\n    Debug.Assert(TriangleArea((4L), (8L), (5L)) == (8.18f));\n    Debug.Assert(TriangleArea((2L), (2L), (2L)) == (1.73f));\n    Debug.Assert(TriangleArea((1L), (2L), (3L)) == (float)-1L);\n    Debug.Assert(TriangleArea((10L), (5L), (7L)) == (16.25f));\n    Debug.Assert(TriangleArea((2L), (6L), (3L)) == (float)-1L);\n    Debug.Assert(TriangleArea((1L), (1L), (1L)) == (0.43f));\n    Debug.Assert(TriangleArea((2L), (2L), (10L)) == (float)-1L);\n    }\n\n}\n"},{"task_id":"HumanEval_72","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Objet q ta bai ta bai si el sta balansiadu (el é un lista palindromiku) y suma di se elementus é menus o igual a peso masimu pusível w.    \/\/Skrebe un funson ki ta torna verdadi si objetu q ta bai, y falsu si ka é verdadi.     \/\/ >>> WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L))\n    \/\/ (false)\n    \/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n    \/\/ >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L))\n    \/\/ (false)\n    \/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n    \/\/ >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L))\n    \/\/ (true)\n    \/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n    \/\/ >>> WillItFly((new List<long>(new long[]{(long)3L})), (5L))\n    \/\/ (true)\n    \/\/ # 3 is less than the maximum possible weight, and it's balanced.\n    public static bool WillItFly(List<long> q, long w) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static bool WillItFly(List<long> q, long w)\n    {\n        if (IsPalindromic(q) && SumIsLessThanOrEqual(q, w))\n        {\n            return true;\n        }\n        return false;\n    }\n\n    private static bool IsPalindromic(List<long> q)\n    {\n        int count = q.Count;\n        for (int i = 0; i < count \/ 2; i++)\n        {\n            if (q[i] != q[count - i - 1])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static bool SumIsLessThanOrEqual(List<long> q, long w)\n    {\n        long sum = 0;\n        foreach (var item in q)\n        {\n            sum += item;\n            if (sum > w)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L)) == (true));\n    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L)) == (false));\n    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L})), (5L)) == (true));\n    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L)) == (false));\n    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (6L)) == (false));\n    Debug.Assert(WillItFly((new List<long>(new long[]{(long)5L})), (5L)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_73","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/é ledu mesmu pa trás y pa frenti. Na un mudansa, bu pode muda un elementu pa kalker otu elementu.     \/\/é nesesariu muda pa faze lista palindromiku.    \/\/Si nu da un lista di númeru interu arr, nu atxa númeru mínimu di elementu ki     \/\/ >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L})))\n    \/\/ (4L)\n    \/\/ >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L})))\n    \/\/ (1L)\n    \/\/ >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L})))\n    \/\/ (0L)\n    public static long SmallestChange(List<long> arr) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static long SmallestChange(List<long> arr)\n    {\n        long changes = 0;\n        int left = 0;\n        int right = arr.Count - 1;\n\n        while (left < right)\n        {\n            if (arr[left] != arr[right])\n            {\n                changes++;\n            }\n            left++;\n            right--;\n        }\n\n        return changes;\n    }\n\n    static void Main()\n    {\n        \/\/ Example usage:\n        List<long> list1 = new List<long> { 1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L };\n        Console.WriteLine(SmallestChange(list1)); \/\/ Output: 4\n\n        List<long> list2 = new List<long> { 1L, 2L, 3L, 4L, 3L, 2L, 2L };\n        Console.WriteLine(SmallestChange(list2)); \/\/ Output: 1\n\n        List<long> list3 = new List<long> { 1L, 2L, 3L, 2L, 1L };\n        Console.WriteLine(SmallestChange(list3)); \/\/ Output: 0\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L}))) == (4L));\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L}))) == (1L));\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L}))) == (1L));\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)4L, (long)2L}))) == (1L));\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L}))) == (0L));\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)3L, (long)1L, (long)1L, (long)3L}))) == (0L));\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L}))) == (0L));\n    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));\n    }\n\n}\n"},{"task_id":"HumanEval_74","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/si kes dôs lista ten mésmu númeru di karáter, torna fla primeru lista.     \/\/total di karus na tudu strings di lista é menus ki kel otu lista.     \/\/Skrebe un funson ki ta aseita dôs lista di strings i ta torna kel lista ki ten     \/\/ >>> TotalMatch((new List<string>()), (new List<string>()))\n    \/\/ (new List<string>())\n    \/\/ >>> TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hI\", (string)\"Hi\"})))\n    \/\/ (new List<string>(new string[]{(string)\"hI\", (string)\"Hi\"}))\n    \/\/ >>> TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hi\", (string)\"hi\", (string)\"admin\", (string)\"project\"})))\n    \/\/ (new List<string>(new string[]{(string)\"hi\", (string)\"admin\"}))\n    \/\/ >>> TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hI\", (string)\"hi\", (string)\"hi\"})))\n    \/\/ (new List<string>(new string[]{(string)\"hI\", (string)\"hi\", (string)\"hi\"}))\n    \/\/ >>> TotalMatch((new List<string>(new string[]{(string)\"4\"})), (new List<string>(new string[]{(string)\"1\", (string)\"2\", (string)\"3\", (string)\"4\", (string)\"5\"})))\n    \/\/ (new List<string>(new string[]{(string)\"4\"}))\n    public static List<string> TotalMatch(List<string> lst1, List<string> lst2) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem\n{\n    public static List<string> TotalMatch(List<string> lst1, List<string> lst2)\n    {\n        int totalCharsLst1 = lst1.Sum(s => s.Length);\n        int totalCharsLst2 = lst2.Sum(s => s.Length);\n\n        if (totalCharsLst1 <= totalCharsLst2)\n        {\n            return lst1;\n        }\n        else\n        {\n            return lst2;\n        }\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(TotalMatch((new List<string>()), (new List<string>())).Equals((new List<string>())));\n    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hi\", (string)\"hi\"}))).Equals((new List<string>(new string[]{(string)\"hi\", (string)\"hi\"}))));\n    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hi\", (string)\"hi\", (string)\"admin\", (string)\"project\"}))).Equals((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"}))));\n    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)\"4\"})), (new List<string>(new string[]{(string)\"1\", (string)\"2\", (string)\"3\", (string)\"4\", (string)\"5\"}))).Equals((new List<string>(new string[]{(string)\"4\"}))));\n    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hI\", (string)\"Hi\"}))).Equals((new List<string>(new string[]{(string)\"hI\", (string)\"Hi\"}))));\n    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hI\", (string)\"hi\", (string)\"hi\"}))).Equals((new List<string>(new string[]{(string)\"hI\", (string)\"hi\", (string)\"hi\"}))));\n    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"})), (new List<string>(new string[]{(string)\"hI\", (string)\"hi\", (string)\"hii\"}))).Equals((new List<string>(new string[]{(string)\"hi\", (string)\"admin\"}))));\n    Debug.Assert(TotalMatch((new List<string>()), (new List<string>(new string[]{(string)\"this\"}))).Equals((new List<string>())));\n    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)\"this\"})), (new List<string>())).Equals((new List<string>())));\n    }\n\n}\n"},{"task_id":"HumanEval_75","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Nu sabe ma (a) é menus ki 100.     \/\/i falsu di otu manera.     \/\/Skrebe un funson ki ta torna trenu si númeru dadu é multiplikason di 3 númeru primeru     \/\/ >>> IsMultiplyPrime((30L))\n    \/\/ (true)\n    \/\/ 30 = 2 * 3 * 5\n    public static bool IsMultiplyPrime(long a) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static bool IsMultiplyPrime(long a) {\n        if (a >= 100) return false;\n        \n        List<long> primes = GeneratePrimes(100);\n        \n        int count = 0;\n        foreach (long prime in primes) {\n            while (a % prime == 0) {\n                a \/= prime;\n                count++;\n            }\n            if (count > 3) break;\n        }\n        \n        return a == 1 && count == 3;\n    }\n\n    private static List<long> GeneratePrimes(int max) {\n        List<long> primes = new List<long>();\n        bool[] isPrime = new bool[max + 1];\n        for (int i = 2; i <= max; i++) isPrime[i] = true;\n\n        for (int i = 2; i * i <= max; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= max; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        for (int i = 2; i <= max; i++) {\n            if (isPrime[i]) primes.Add(i);\n        }\n\n        return primes;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsMultiplyPrime((5L)) == (false));\n    Debug.Assert(IsMultiplyPrime((30L)) == (true));\n    Debug.Assert(IsMultiplyPrime((8L)) == (true));\n    Debug.Assert(IsMultiplyPrime((10L)) == (false));\n    Debug.Assert(IsMultiplyPrime((125L)) == (true));\n    Debug.Assert(IsMultiplyPrime((105L)) == (true));\n    Debug.Assert(IsMultiplyPrime((126L)) == (false));\n    Debug.Assert(IsMultiplyPrime((729L)) == (false));\n    Debug.Assert(IsMultiplyPrime((891L)) == (false));\n    Debug.Assert(IsMultiplyPrime((1001L)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_76","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/x é un simples puder di n si n**int=x     \/\/poténsia di n i falsu na otus kazu.     \/\/Bu trabadju é skrebe un funson ki ta torna verdadi si un númeru x é un  sinplis    \/\/ >>> IsSimplePower((1L), (4L))\n    \/\/ (true)\n    \/\/ >>> IsSimplePower((2L), (2L))\n    \/\/ (true)\n    \/\/ >>> IsSimplePower((8L), (2L))\n    \/\/ (true)\n    \/\/ >>> IsSimplePower((3L), (2L))\n    \/\/ (false)\n    \/\/ >>> IsSimplePower((3L), (1L))\n    \/\/ (false)\n    \/\/ >>> IsSimplePower((5L), (3L))\n    \/\/ (false)\n    public static bool IsSimplePower(long x, long n) {\n","canonical_solution":"if (x < 1 || n < 2)\n        return false;\n\n    while (x > 1)\n    {\n        if (x % n != 0)\n            return false;\n        x \/= n;\n    }\n\n    return true;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsSimplePower((16L), (2L)) == (true));\n    Debug.Assert(IsSimplePower((143214L), (16L)) == (false));\n    Debug.Assert(IsSimplePower((4L), (2L)) == (true));\n    Debug.Assert(IsSimplePower((9L), (3L)) == (true));\n    Debug.Assert(IsSimplePower((16L), (4L)) == (true));\n    Debug.Assert(IsSimplePower((24L), (2L)) == (false));\n    Debug.Assert(IsSimplePower((128L), (4L)) == (false));\n    Debug.Assert(IsSimplePower((12L), (6L)) == (false));\n    Debug.Assert(IsSimplePower((1L), (1L)) == (true));\n    Debug.Assert(IsSimplePower((1L), (12L)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_77","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Nota: bu pode pensa ma kel informason ki bu dadu é válidu sénpri.    \/\/si kel ingérnu é un kópu di algun númeru interu.     \/\/Skrebe un funson ki ta toma un númeru interu a i ta torna verdaderu     \/\/ >>> Iscube((1L))\n    \/\/ (true)\n    \/\/ >>> Iscube((2L))\n    \/\/ (false)\n    \/\/ >>> Iscube((-1L))\n    \/\/ (true)\n    \/\/ >>> Iscube((64L))\n    \/\/ (true)\n    \/\/ >>> Iscube((0L))\n    \/\/ (true)\n    \/\/ >>> Iscube((180L))\n    \/\/ (false)\n    public static bool Iscube(long a) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static bool Iscube(long a) {\n        if (a == 0) return true;\n        long absA = Math.Abs(a);\n        long cubeRoot = (long)Math.Round(Math.Pow(absA, 1.0 \/ 3.0));\n        return cubeRoot * cubeRoot * cubeRoot == absA;\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(Iscube(1L));    \/\/ true\n        Console.WriteLine(Iscube(2L));    \/\/ false\n        Console.WriteLine(Iscube(-1L));   \/\/ true\n        Console.WriteLine(Iscube(64L));   \/\/ true\n        Console.WriteLine(Iscube(0L));    \/\/ true\n        Console.WriteLine(Iscube(180L));  \/\/ false\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Iscube((1L)) == (true));\n    Debug.Assert(Iscube((2L)) == (false));\n    Debug.Assert(Iscube((-1L)) == (true));\n    Debug.Assert(Iscube((64L)) == (true));\n    Debug.Assert(Iscube((180L)) == (false));\n    Debug.Assert(Iscube((1000L)) == (true));\n    Debug.Assert(Iscube((0L)) == (true));\n    Debug.Assert(Iscube((1729L)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_78","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/i símbolos A,B,C,D,E,F é sénpri majuskulus.     \/\/Nota: bu pode asumi ma input é sénpri koretu ô stringa ka ten nada,     \/\/B (= désimal 11), D (= désimal 13).     \/\/Nton, bu ten ki determina un númeru di kes siginti dígitos: 2, 3, 5, 7,     \/\/Númeru prime é 2, 3, 5, 7, 11, 13, 17,...     \/\/Djiferis hexadecimal é 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.     \/\/más grandi ki 1 ki é ka un produtu di dôs númeru natural más pikinoti).     \/\/dígitos ki é primus (un númeru primo é un númeru natural     \/\/un númeru heksadesimal komu un stringa y ta konta númeru di númeru heksadesimal     \/\/Bu foi enkaregadu di skrebe un funson ki ta resebe     \/\/ >>> HexKey((\"AB\"))\n    \/\/ (1L)\n    \/\/ >>> HexKey((\"1077E\"))\n    \/\/ (2L)\n    \/\/ >>> HexKey((\"ABED1A33\"))\n    \/\/ (4L)\n    \/\/ >>> HexKey((\"123456789ABCDEF0\"))\n    \/\/ (6L)\n    \/\/ >>> HexKey((\"2020\"))\n    \/\/ (2L)\n    public static long HexKey(string num) {\n","canonical_solution":"public static long HexKey(string num) {\n    \/\/ Define a set of prime hexadecimal digits\n    HashSet<char> primeHexDigits = new HashSet<char> { '2', '3', '5', '7', 'B', 'D' };\n\n    long primeCount = 0;\n\n    \/\/ Iterate through each character in the input string\n    foreach (char c in num) {\n        \/\/ If the character is in the set of prime hex digits, increase the count\n        if (primeHexDigits.Contains(c)) {\n            primeCount++;\n        }\n    }\n\n    return primeCount;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(HexKey((\"AB\")) == (1L));\n    Debug.Assert(HexKey((\"1077E\")) == (2L));\n    Debug.Assert(HexKey((\"ABED1A33\")) == (4L));\n    Debug.Assert(HexKey((\"2020\")) == (2L));\n    Debug.Assert(HexKey((\"123456789ABCDEF0\")) == (6L));\n    Debug.Assert(HexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12L));\n    }\n\n}\n"},{"task_id":"HumanEval_79","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Kes karáter di más sta la pa djuda-nu na formatu.     \/\/Ta ben ten un par di karáter 'db' na kumesu i na fin di stringa.     \/\/Kada karáter na stringa ta ser '0' ô '1'.    \/\/fórma bináriu. Fonkson debe da un stringa, ku kada karáter ta reprezenta un  bináriu.    \/\/Bu ta dadu un númeru na fórma desimal i bu trabadju é konberta-l pa     \/\/ >>> DecimalToBinary((15L))\n    \/\/ (\"db1111db\")\n    \/\/ >>> DecimalToBinary((32L))\n    \/\/ (\"db100000db\")\n    public static string DecimalToBinary(long decimalNum) {\n","canonical_solution":"public static string DecimalToBinary(long decimalNum) {\n    string binary = Convert.ToString(decimalNum, 2);\n    return \"db\" + binary + \"db\";\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(DecimalToBinary((0L)).Equals((\"db0db\")));\n    Debug.Assert(DecimalToBinary((32L)).Equals((\"db100000db\")));\n    Debug.Assert(DecimalToBinary((103L)).Equals((\"db1100111db\")));\n    Debug.Assert(DecimalToBinary((15L)).Equals((\"db1111db\")));\n    }\n\n}\n"},{"task_id":"HumanEval_80","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Un stringa é hapcs si se lonji é pelu menus 3 i tudu 3 létra konsekutivu é distintu     \/\/Bu trabadju é djobe si stringa é hapcs ou nau.    \/\/Bu ta dadu un stringa di palavra.    \/\/ >>> IsHappy((\"a\"))\n    \/\/ (false)\n    \/\/ >>> IsHappy((\"aa\"))\n    \/\/ (false)\n    \/\/ >>> IsHappy((\"abcd\"))\n    \/\/ (true)\n    \/\/ >>> IsHappy((\"aabb\"))\n    \/\/ (false)\n    \/\/ >>> IsHappy((\"adb\"))\n    \/\/ (true)\n    \/\/ >>> IsHappy((\"xyy\"))\n    \/\/ (false)\n    public static bool IsHappy(string s) {\n","canonical_solution":"if (s.Length < 3) {\n        return false;\n    }\n\n    for (int i = 0; i <= s.Length - 3; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsHappy((\"a\")) == (false));\n    Debug.Assert(IsHappy((\"aa\")) == (false));\n    Debug.Assert(IsHappy((\"abcd\")) == (true));\n    Debug.Assert(IsHappy((\"aabb\")) == (false));\n    Debug.Assert(IsHappy((\"adb\")) == (true));\n    Debug.Assert(IsHappy((\"xyy\")) == (false));\n    Debug.Assert(IsHappy((\"iopaxpoi\")) == (true));\n    Debug.Assert(IsHappy((\"iopaxioi\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_81","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/0.0 E  ki ta    \/\/> 0.0 D-  ki    \/\/> 0,7 D  ki ta    \/\/> 1,0 D+  ki ta da pa dentu    \/\/> 1.3 C-  ki ta    \/\/> 1,7 C  ki ta    \/\/> 2.0 C+  ki ta faze    \/\/> 2.3 B-  ki ta    \/\/> 2.7 B  ki    \/\/> 3.0 B+  ki ta faze    \/\/> 3.3 A-  ki    \/\/> 3.7 A  ki ta    \/\/4.0 A+  ki ta    \/\/GPA. Nota di alfabétu.    \/\/un funson ki pode da un lista di grau di letra uzandu es tabéla:     \/\/El da-u un lista di kes midjór rezultadu di alguns studanti i bu ten ki skrebe-l.    \/\/Úniku prubléma é ki el perde kódigu ki el ta uzaba pa marka.    \/\/Pa alunos, profesor ta fazeba se própi algoritmu pa marka.    \/\/É últimu simana di semestru i profesóra ten ki da nótas.    \/\/ >>> GradeEquation((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f})))\n    \/\/ (new List<string>(new string[]{(string)\"A+\", (string)\"B\", (string)\"C-\", (string)\"C\", (string)\"A-\"}))\n    public static List<string> NumericalLetterGrade(List<float> grades) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<string> NumericalLetterGrade(List<float> grades)\n    {\n        List<string> letterGrades = new List<string>();\n\n        foreach (var gpa in grades)\n        {\n            if (gpa == 4.0f)\n                letterGrades.Add(\"A+\");\n            else if (gpa > 3.7f)\n                letterGrades.Add(\"A\");\n            else if (gpa > 3.3f)\n                letterGrades.Add(\"A-\");\n            else if (gpa > 3.0f)\n                letterGrades.Add(\"B+\");\n            else if (gpa > 2.7f)\n                letterGrades.Add(\"B\");\n            else if (gpa > 2.3f)\n                letterGrades.Add(\"B-\");\n            else if (gpa > 2.0f)\n                letterGrades.Add(\"C+\");\n            else if (gpa > 1.7f)\n                letterGrades.Add(\"C\");\n            else if (gpa > 1.3f)\n                letterGrades.Add(\"C-\");\n            else if (gpa > 1.0f)\n                letterGrades.Add(\"D+\");\n            else if (gpa > 0.7f)\n                letterGrades.Add(\"D\");\n            else if (gpa > 0.0f)\n                letterGrades.Add(\"D-\");\n            else\n                letterGrades.Add(\"E\");\n        }\n\n        return letterGrades;\n    }\n\n    static void Main(string[] args)\n    {\n        List<float> gpas = new List<float> { 4.0f, 3.0f, 1.7f, 2.0f, 3.5f };\n        List<string> grades = NumericalLetterGrade(gpas);\n        Console.WriteLine(string.Join(\", \", grades));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f}))).Equals((new List<string>(new string[]{(string)\"A+\", (string)\"B\", (string)\"C-\", (string)\"C\", (string)\"A-\"}))));\n    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.2f}))).Equals((new List<string>(new string[]{(string)\"D+\"}))));\n    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.5f}))).Equals((new List<string>(new string[]{(string)\"D-\"}))));\n    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f}))).Equals((new List<string>(new string[]{(string)\"E\"}))));\n    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))).Equals((new List<string>(new string[]{(string)\"D\", (string)\"D-\", (string)\"C-\", (string)\"B\", (string)\"B+\"}))));\n    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f, (float)0.7f}))).Equals((new List<string>(new string[]{(string)\"E\", (string)\"D-\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_82","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/lonji é un númeru primo ô é falsu si é ka si.    \/\/Skrebe un funson ki ta toma un stringa i ta torna trenu si stringa     \/\/ >>> PrimeLength((\"Hello\"))\n    \/\/ (true)\n    \/\/ >>> PrimeLength((\"abcdcba\"))\n    \/\/ (true)\n    \/\/ >>> PrimeLength((\"kittens\"))\n    \/\/ (true)\n    \/\/ >>> PrimeLength((\"orange\"))\n    \/\/ (false)\n    public static bool PrimeLength(string str) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static bool PrimeLength(string str) {\n        int length = str.Length;\n        if (length < 2) return false;\n        \n        for (int i = 2; i <= Math.Sqrt(length); i++) {\n            if (length % i == 0) return false;\n        }\n        \n        return true;\n    }\n    \n    \/\/ Example usage\n    public static void Main() {\n        Console.WriteLine(PrimeLength(\"Hello\"));    \/\/ true\n        Console.WriteLine(PrimeLength(\"abcdcba\"));  \/\/ true\n        Console.WriteLine(PrimeLength(\"kittens\"));  \/\/ true\n        Console.WriteLine(PrimeLength(\"orange\"));   \/\/ false\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(PrimeLength((\"Hello\")) == (true));\n    Debug.Assert(PrimeLength((\"abcdcba\")) == (true));\n    Debug.Assert(PrimeLength((\"kittens\")) == (true));\n    Debug.Assert(PrimeLength((\"orange\")) == (false));\n    Debug.Assert(PrimeLength((\"wow\")) == (true));\n    Debug.Assert(PrimeLength((\"world\")) == (true));\n    Debug.Assert(PrimeLength((\"MadaM\")) == (true));\n    Debug.Assert(PrimeLength((\"Wow\")) == (true));\n    Debug.Assert(PrimeLength((\"\")) == (false));\n    Debug.Assert(PrimeLength((\"HI\")) == (true));\n    Debug.Assert(PrimeLength((\"go\")) == (true));\n    Debug.Assert(PrimeLength((\"gogo\")) == (false));\n    Debug.Assert(PrimeLength((\"aaaaaaaaaaaaaaa\")) == (false));\n    Debug.Assert(PrimeLength((\"Madam\")) == (true));\n    Debug.Assert(PrimeLength((\"M\")) == (false));\n    Debug.Assert(PrimeLength((\"0\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_83","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/númeru interu pozitivu ne'ebé komesa ka termina ho 1.     \/\/Da un númeru interu puzitivu n, torna konta númeru di dígitos di n     public static long StartsOneEnds(long n) {\n","canonical_solution":"if (n == 1) return 1;\n        return (long)Math.Pow(10, n - 1) + 9 * (long)Math.Pow(10, n - 2);\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(StartsOneEnds((1L)) == (1L));\n    Debug.Assert(StartsOneEnds((2L)) == (18L));\n    Debug.Assert(StartsOneEnds((3L)) == (180L));\n    Debug.Assert(StartsOneEnds((4L)) == (1800L));\n    Debug.Assert(StartsOneEnds((5L)) == (18000L));\n    }\n\n}\n"},{"task_id":"HumanEval_84","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu     \/\/Da un númeru interu puzitivu N, torna suma di se dígitos na bináriu.     \/\/ >>> Solve((1000L))\n    \/\/ (\"1\")\n    \/\/ >>> Solve((150L))\n    \/\/ (\"110\")\n    \/\/ >>> Solve((147L))\n    \/\/ (\"1100\")\n    \/\/ Variables:\n    \/\/ @N integer\n    \/\/ Constraints: 0 ≤ N ≤ 10000.\n    \/\/ Output:\n    \/\/ a string of binary number\n    public static string Solve(long N) {\n","canonical_solution":"public static string Solve(long N) {\n        int sumOfDigits = 0;\n        while (N > 0) {\n            sumOfDigits += (int)(N % 10);\n            N \/= 10;\n        }\n        return Convert.ToString(sumOfDigits, 2);\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Solve((1000L)).Equals((\"1\")));\n    Debug.Assert(Solve((150L)).Equals((\"110\")));\n    Debug.Assert(Solve((147L)).Equals((\"1100\")));\n    Debug.Assert(Solve((333L)).Equals((\"1001\")));\n    Debug.Assert(Solve((963L)).Equals((\"10010\")));\n    }\n\n}\n"},{"task_id":"HumanEval_85","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Dadu un lista di númeru interu ki é ka válidu, primeru nu ta adiciona kes elementu páriu ki sta na indísiu páriu.    \/\/ >>> Add((new List<long>(new long[]{(long)4L, (long)2L, (long)6L, (long)7L})))\n    \/\/ (2L)\n    public static long Add(List<long> lst) {\n","canonical_solution":"long sum = 0;\n    for (int i = 1; i < lst.Count; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)88L}))) == (88L));\n    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)5L, (long)6L, (long)7L, (long)2L, (long)122L}))) == (122L));\n    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)0L, (long)6L, (long)7L}))) == (0L));\n    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)4L, (long)6L, (long)8L}))) == (12L));\n    }\n\n}\n"},{"task_id":"HumanEval_86","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Nota: Bu debe mante ordi di palavras i di espasus na frazi.     \/\/ta dizenvolve na ordi ki ta subi ku bazi na valor di ascii.     \/\/é substituídu pa un palavra novu undi tudu kes karáter ranjadu na     \/\/Vérsia ordenadu di stringa, é un stringa undi tudu palavras (separadu pa espasu)     \/\/Skrebe un funson ki ta toma un stringa i ta torna un verson ordenadu di kel stringa.     \/\/ >>> AntiShuffle((\"Hi\"))\n    \/\/ (\"Hi\")\n    \/\/ >>> AntiShuffle((\"hello\"))\n    \/\/ (\"ehllo\")\n    \/\/ >>> AntiShuffle((\"Hello World!!!\"))\n    \/\/ (\"Hello !!!Wdlor\")\n    public static string AntiShuffle(string s) {\n","canonical_solution":"using System;\nusing System.Linq;\n\nclass Problem\n{\n    public static string AntiShuffle(string s)\n    {\n        return string.Join(\" \", s.Split(' ')\n            .Select(word => string.Concat(word.OrderBy(c => c))));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(AntiShuffle((\"Hi\")).Equals((\"Hi\")));\n    Debug.Assert(AntiShuffle((\"hello\")).Equals((\"ehllo\")));\n    Debug.Assert(AntiShuffle((\"number\")).Equals((\"bemnru\")));\n    Debug.Assert(AntiShuffle((\"abcd\")).Equals((\"abcd\")));\n    Debug.Assert(AntiShuffle((\"Hello World!!!\")).Equals((\"Hello !!!Wdlor\")));\n    Debug.Assert(AntiShuffle((\"\")).Equals((\"\")));\n    Debug.Assert(AntiShuffle((\"Hi. My name is Mister Robot. How are you?\")).Equals((\".Hi My aemn is Meirst .Rboot How aer ?ouy\")));\n    }\n\n}\n"},{"task_id":"HumanEval_87","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Tanbê, ranja koordenadas di fila pa koluna na ordi di dizagregason.     \/\/Sortá kes koordenada primeru pa linhas na ordi ki ta subi.    \/\/kada tupla é un koordenada - (linha, koluna), ta kumesa ku 0.     \/\/i ta torna lista di tuplas, [(x1, y1), (x2, y2) ...] sima ki     \/\/Dadu lst, i intjeru x, atxa intjeru x na lista,     \/\/kada rixu pode ten un númeru diferenti di kolunas.     \/\/ki é sima matriz, má diferenti di matriz,     \/\/Bu ta dadu un dadus bidimensional, sima un lista anedadu,     \/\/ >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L))\n    \/\/ (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))\n    \/\/ >>> GetRow((new List<List<long>>()), (1L))\n    \/\/ (new List<Tuple<long, long>>())\n    \/\/ >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L))\n    \/\/ (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))\n    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {\n        var result = new List<Tuple<long, long>>();\n        \n        for (long row = 0; row < lst.Count; row++) {\n            List<long> currentRow = lst[(int)row];\n            var foundIndices = new List<long>();\n            \n            for (long col = 0; col < currentRow.Count; col++) {\n                if (currentRow[(int)col] == x) {\n                    foundIndices.Add(col);\n                }\n            }\n            \n            foundIndices.Sort((a, b) => b.CompareTo(a)); \/\/ Sort columns in descending order\n            \n            foreach (var col in foundIndices) {\n                result.Add(Tuple.Create(row, col));\n            }\n        }\n        \n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))));\n    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})})), (2L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 1L), (Tuple<long, long>)Tuple.Create(1L, 1L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(3L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(5L, 1L)}))));\n    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)1L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(2L, 0L), (Tuple<long, long>)Tuple.Create(3L, 2L), (Tuple<long, long>)Tuple.Create(3L, 0L), (Tuple<long, long>)Tuple.Create(4L, 3L), (Tuple<long, long>)Tuple.Create(4L, 0L), (Tuple<long, long>)Tuple.Create(5L, 4L), (Tuple<long, long>)Tuple.Create(5L, 0L), (Tuple<long, long>)Tuple.Create(6L, 5L), (Tuple<long, long>)Tuple.Create(6L, 0L)}))));\n    Debug.Assert(GetRow((new List<List<long>>()), (1L)).Equals((new List<Tuple<long, long>>())));\n    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L})})), (2L)).Equals((new List<Tuple<long, long>>())));\n    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))));\n    }\n\n}\n"},{"task_id":"HumanEval_88","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/* ka bu muda lista ki bu dadu.     \/\/Nota:     \/\/ô ranja-l na ordi di dizagregason si soma ((primeru valor di indéks, últimu valor di indéks) é par.     \/\/bu ta ranja lista ki bu dadu na ordi ki ta subi si suma ((primeru valor di indéks, últimu valor di indéks) é párti,     \/\/Dipos di un lista di intirjus ki ka é negativu, torna un cocs di kel lista dipôs di ranja,     \/\/ >>> SortArray((new List<long>()))\n    \/\/ (new List<long>())\n    \/\/ >>> SortArray((new List<long>(new long[]{(long)5L})))\n    \/\/ (new List<long>(new long[]{(long)5L}))\n    \/\/ >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L})))\n    \/\/ (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n    \/\/ >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L})))\n    \/\/ (new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))\n    public static List<long> SortArray(List<long> array) {\n","canonical_solution":"public static List<long> SortArray(List<long> array) {\n        if (array == null || array.Count <= 1) {\n            return new List<long>(array);\n        }\n        \n        long firstValue = array[0];\n        long lastValue = array[array.Count - 1];\n        long sum = firstValue + lastValue;\n\n        List<long> sortedArray = new List<long>(array);\n\n        if (sum % 2 != 0) { \/\/ sum is odd, sort ascending\n            sortedArray.Sort();\n        } else { \/\/ sum is even, sort descending\n            sortedArray.Sort();\n            sortedArray.Reverse();\n        }\n\n        return sortedArray;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)5L}))).Equals((new List<long>(new long[]{(long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)15L, (long)42L, (long)87L, (long)32L, (long)11L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)11L, (long)15L, (long)32L, (long)42L, (long)87L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)21L, (long)14L, (long)23L, (long)11L}))).Equals((new List<long>(new long[]{(long)23L, (long)21L, (long)14L, (long)11L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_89","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/N ta bai pa baxu pa dôs, multiplikadu pa dôs lugar.    \/\/Alfabétu debe rotadu di manera ki kes létra     \/\/ta torna un stringa enkriptadu ku alfabetu ta rotadu.     \/\/Kriâ un funson ki ta kriptografâ un stringa komu un argumentu y     \/\/ >>> Encrypt((\"hi\"))\n    \/\/ (\"lm\")\n    \/\/ >>> Encrypt((\"asdfghjkl\"))\n    \/\/ (\"ewhjklnop\")\n    \/\/ >>> Encrypt((\"gf\"))\n    \/\/ (\"kj\")\n    \/\/ >>> Encrypt((\"et\"))\n    \/\/ (\"ix\")\n    public static string Encrypt(string s) {\n","canonical_solution":"const int shiftAmount = 4; \/\/ 2 multiplied by 2 equals 4.\n\n    StringBuilder encrypted = new StringBuilder();\n\n    foreach (char c in s) {\n        if (char.IsLetter(c)) {\n            char start = char.IsUpper(c) ? 'A' : 'a';\n            char encryptedChar = (char)(start + (c - start + shiftAmount) % 26);\n            encrypted.Append(encryptedChar);\n        } else {\n            encrypted.Append(c); \/\/ Non-letter characters are not encrypted.\n        }\n    }\n\n    return encrypted.ToString();\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Encrypt((\"hi\")).Equals((\"lm\")));\n    Debug.Assert(Encrypt((\"asdfghjkl\")).Equals((\"ewhjklnop\")));\n    Debug.Assert(Encrypt((\"gf\")).Equals((\"kj\")));\n    Debug.Assert(Encrypt((\"et\")).Equals((\"ix\")));\n    Debug.Assert(Encrypt((\"faewfawefaewg\")).Equals((\"jeiajeaijeiak\")));\n    Debug.Assert(Encrypt((\"hellomyfriend\")).Equals((\"lippsqcjvmirh\")));\n    Debug.Assert(Encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).Equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    Debug.Assert(Encrypt((\"a\")).Equals((\"e\")));\n    }\n\n}\n"},{"task_id":"HumanEval_90","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Retorna null si ka ten ninhun elementu di es tipu.     \/\/Skrebe un funson next_smallest ki ta torna kel segundu elementu más pikinoti di lista.     \/\/Bu ta dadu un lista di númeru interu.    \/\/ >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))\n    \/\/ 2L\n    \/\/ >>> NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L})))\n    \/\/ 2L\n    \/\/ >>> NextSmallest((new List<long>()))\n    \/\/ null\n    \/\/ >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)1L})))\n    \/\/ null\n    public static Nullable<long> NextSmallest(List<long> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static Nullable<long> NextSmallest(List<long> lst) {\n        if (lst == null || lst.Count < 2) {\n            return null;\n        }\n\n        HashSet<long> uniqueElements = new HashSet<long>(lst);\n        if (uniqueElements.Count < 2) {\n            return null;\n        }\n\n        List<long> sortedUniqueElements = uniqueElements.ToList();\n        sortedUniqueElements.Sort();\n\n        return sortedUniqueElements[1];\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(NextSmallest(new List<long> {1, 2, 3, 4, 5})); \/\/ 2\n        Console.WriteLine(NextSmallest(new List<long> {5, 1, 4, 3, 2})); \/\/ 2\n        Console.WriteLine(NextSmallest(new List<long>())); \/\/ null\n        Console.WriteLine(NextSmallest(new List<long> {1, 1})); \/\/ null\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));\n    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L}))).Equals(2L));\n    Debug.Assert(NextSmallest((new List<long>())).Equals(null));\n    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));\n    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)0L}))).Equals(1L));\n    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));\n    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));\n    }\n\n}\n"},{"task_id":"HumanEval_91","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Frasi ta ser delimitadu ku '.', '?' ô '!'.     \/\/Un nómi é un frazi ki ta kumesa ku palavra \"I\".    \/\/Bu ta dadu un konjuntu di palavras, i bu trabadju é konta númeru.    \/\/ >>> IsBored((\"Hello world\"))\n    \/\/ (0L)\n    \/\/ >>> IsBored((\"The sky is blue. The sun is shining. I love this weather\"))\n    \/\/ (1L)\n    public static long IsBored(string S) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long IsBored(string S) {\n        \/\/ Split the input string into sentences based on delimiters '.', '?', '!'\n        char[] delimiters = new char[] { '.', '?', '!' };\n        string[] sentences = S.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);\n\n        \/\/ Count sentences that start with 'I' after trimming leading whitespaces\n        long boredomCount = 0;\n        foreach (string sentence in sentences) {\n            if (sentence.TrimStart().StartsWith(\"I\")) {\n                boredomCount++;\n            }\n        }\n\n        return boredomCount;\n    }\n\n    static void Main(string[] args) {\n        \/\/ Example usage:\n        Console.WriteLine(IsBored(\"Hello world\")); \/\/ Output: 0\n        Console.WriteLine(IsBored(\"The sky is blue. The sun is shining. I love this weather\")); \/\/ Output: 1\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsBored((\"Hello world\")) == (0L));\n    Debug.Assert(IsBored((\"Is the sky blue?\")) == (0L));\n    Debug.Assert(IsBored((\"I love It !\")) == (1L));\n    Debug.Assert(IsBored((\"bIt\")) == (0L));\n    Debug.Assert(IsBored((\"I feel good today. I will be productive. will kill It\")) == (2L));\n    Debug.Assert(IsBored((\"You and I are going for a walk\")) == (0L));\n    }\n\n}\n"},{"task_id":"HumanEval_92","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/Retorna falsu na tudu otu kazu.     \/\/Retorna verdadi si un di kes númeru é igual a suma di kes otu dôs, y tudu kes númeru é númeru interu.     \/\/Kre un funson ki ta toma 3 númeru.    \/\/ >>> AnyInt((float)5L, (float)2L, (float)7L)\n    \/\/ (true)\n    \/\/ >>> AnyInt((float)3L, (float)2L, (float)2L)\n    \/\/ (false)\n    \/\/ >>> AnyInt((float)3L, (float)-2L, (float)1L)\n    \/\/ (true)\n    \/\/ >>> AnyInt((3.6f), (-2.2f), (float)2L)\n    \/\/ (false)\n    public static bool AnyInt(float x, float y, float z) {\n","canonical_solution":"public static bool AnyInt(float x, float y, float z) {\n        if (x == Math.Round(x) && y == Math.Round(y) && z == Math.Round(z)) {\n            if (x == y + z || y == x + z || z == x + y) {\n                return true;\n            }\n        }\n        return false;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(AnyInt((float)2L, (float)3L, (float)1L) == (true));\n    Debug.Assert(AnyInt((2.5f), (float)2L, (float)3L) == (false));\n    Debug.Assert(AnyInt((1.5f), (float)5L, (3.5f)) == (false));\n    Debug.Assert(AnyInt((float)2L, (float)6L, (float)2L) == (false));\n    Debug.Assert(AnyInt((float)4L, (float)2L, (float)2L) == (true));\n    Debug.Assert(AnyInt((2.2f), (2.2f), (2.2f)) == (false));\n    Debug.Assert(AnyInt((float)-4L, (float)6L, (float)2L) == (true));\n    Debug.Assert(AnyInt((float)2L, (float)1L, (float)1L) == (true));\n    Debug.Assert(AnyInt((float)3L, (float)4L, (float)7L) == (true));\n    Debug.Assert(AnyInt((3.0f), (float)4L, (float)7L) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_93","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/N ta pensa sô na létras.    \/\/vogal na alfabétu di língua kabuverdianu.    \/\/kel mensaji ku kel létra ki ta parse 2 lugar antis di kel-li     \/\/manera ki el ta troka kes maiúsculas di tudu létras, el ta troka tudu vokal na     \/\/Skrebe un funson ki ta toma un mensaji, i ta kodje-l na un     \/\/ >>> Encode((\"test\"))\n    \/\/ (\"TGST\")\n    \/\/ >>> Encode((\"This is a message\"))\n    \/\/ (\"tHKS KS C MGSSCGG\")\n    public static string Encode(string message) {\n","canonical_solution":"public static string Encode(string message) {\n    \/\/ Define vowels and their replacements\n    Dictionary<char, char> vowelReplacement = new Dictionary<char, char>\n    {\n        { 'a', 'c' },\n        { 'e', 'g' },\n        { 'i', 'k' },\n        { 'o', 'q' },\n        { 'u', 'w' },\n        { 'A', 'C' },\n        { 'E', 'G' },\n        { 'I', 'K' },\n        { 'O', 'Q' },\n        { 'U', 'W' }\n    };\n\n    StringBuilder encodedMessage = new StringBuilder();\n\n    foreach (char c in message) {\n        if (char.IsLetter(c)) {\n            \/\/ Swap case\n            char swappedCaseChar = char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c);\n\n            \/\/ Replace vowels according to the defined map\n            if (vowelReplacement.ContainsKey(swappedCaseChar)) {\n                encodedMessage.Append(vowelReplacement[swappedCaseChar]);\n            } else {\n                encodedMessage.Append(swappedCaseChar);\n            }\n        } else {\n            \/\/ Non-letter characters should be appended as-is (if necessary)\n            encodedMessage.Append(c);\n        }\n    }\n\n    return encodedMessage.ToString();\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Encode((\"TEST\")).Equals((\"tgst\")));\n    Debug.Assert(Encode((\"Mudasir\")).Equals((\"mWDCSKR\")));\n    Debug.Assert(Encode((\"YES\")).Equals((\"ygs\")));\n    Debug.Assert(Encode((\"This is a message\")).Equals((\"tHKS KS C MGSSCGG\")));\n    Debug.Assert(Encode((\"I DoNt KnOw WhAt tO WrItE\")).Equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"},{"task_id":"HumanEval_94","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Bu meste atxa kel maior valor primo i torna da soma di kes dígitu.    \/\/Bu ta dadu un lista di númeru interu.    \/\/ >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L})))\n    \/\/ (10L)\n    \/\/ >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L})))\n    \/\/ (25L)\n    \/\/ >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L})))\n    \/\/ (13L)\n    \/\/ >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L})))\n    \/\/ (11L)\n    \/\/ >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L})))\n    \/\/ (3L)\n    \/\/ >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L})))\n    \/\/ (7L)\n    public static long Skjkasdkd(List<long> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static long Skjkasdkd(List<long> lst) {\n        long largestPrime = -1;\n\n        foreach (var num in lst) {\n            if (IsPrime(num) && num > largestPrime) {\n                largestPrime = num;\n            }\n        }\n\n        if (largestPrime == -1) return 0;\n\n        return SumOfDigits(largestPrime);\n    }\n\n    private static bool IsPrime(long number) {\n        if (number <= 1) return false;\n        if (number <= 3) return true;\n\n        if (number % 2 == 0 || number % 3 == 0) return false;\n\n        for (long i = 5; i * i <= number; i += 6) {\n            if (number % i == 0 || number % (i + 2) == 0) return false;\n        }\n\n        return true;\n    }\n\n    private static long SumOfDigits(long number) {\n        long sum = 0;\n        while (number != 0) {\n            sum += number % 10;\n            number \/= 10;\n        }\n        return sum;\n    }\n}\n\n\/\/ Example of usage:\n\/\/ var result = Problem.Skjkasdkd(new List<long> {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3});\n\/\/ Console.WriteLine(result); \/\/ Output will be 10","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L}))) == (10L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L}))) == (25L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L}))) == (13L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L}))) == (11L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L}))) == (3L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L}))) == (7L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L}))) == (19L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L, (long)123456L, (long)127L, (long)7L}))) == (19L));\n    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)127L, (long)97L, (long)8192L}))) == (10L));\n    }\n\n}\n"},{"task_id":"HumanEval_95","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Kel funson debe da falsu si diksionáriu ki dadu sta vazio.     \/\/kazu o tudu kes txera é strings na kazu maiuskulu, otu bes torna falsu.     \/\/Si nu da un disionáriu, torna trenu si tudu kes txeru é strings na menor     \/\/ >>> CheckDictCase((new Dictionary<string,string>(){{\"a\", \"apple\"}, {\"b\", \"banana\"}}))\n    \/\/ (true)\n    \/\/ >>> CheckDictCase((new Dictionary<string,string>(){{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}}))\n    \/\/ (false)\n    \/\/ >>> CheckDictCase((new Dictionary<string,string>(){{\"a\", \"apple\"}, {8L, \"banana\"}, {\"a\", \"apple\"}}))\n    \/\/ (false)\n    \/\/ >>> CheckDictCase((new Dictionary<string,string>(){{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}}))\n    \/\/ (false)\n    \/\/ >>> CheckDictCase((new Dictionary<string,string>(){{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}}))\n    \/\/ (true)\n    public static bool CheckDictCase(Dictionary<string,string> dict) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static bool CheckDictCase(Dictionary<string, string> dict)\n    {\n        if (dict.Count == 0)\n            return false;\n\n        bool allLower = true;\n        bool allUpper = true;\n\n        foreach (var key in dict.Keys)\n        {\n            if (key != key.ToLower())\n                allLower = false;\n            if (key != key.ToUpper())\n                allUpper = false;\n        }\n\n        return allLower || allUpper;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{\"p\", \"pineapple\"}, {\"b\", \"banana\"}})) == (true));\n    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{\"p\", \"pineapple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})) == (false));\n    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{\"p\", \"pineapple\"}, {\"5\", \"banana\"}, {\"a\", \"apple\"}})) == (false));\n    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})) == (false));\n    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})) == (true));\n    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{\"fruit\", \"Orange\"}, {\"taste\", \"Sweet\"}})) == (true));\n    Debug.Assert(CheckDictCase((new Dictionary<string,string>())) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_96","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/intxi ki é númeru primeru y menus ki n.     \/\/Implementa un funson ki ta toma un númeru interu ki ka é negativu i ta torna un lista di primeru n     \/\/ >>> CountUpTo((5L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)3L}))\n    \/\/ >>> CountUpTo((11L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))\n    \/\/ >>> CountUpTo((0L))\n    \/\/ (new List<long>())\n    \/\/ >>> CountUpTo((20L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))\n    \/\/ >>> CountUpTo((1L))\n    \/\/ (new List<long>())\n    \/\/ >>> CountUpTo((18L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))\n    public static List<long> CountUpTo(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> CountUpTo(long n) {\n        List<long> primes = new List<long>();\n        if (n <= 2) return primes;\n\n        \/\/ Check for prime numbers from 2 up to n-1\n        for (long i = 2; i < n; i++) {\n            if (IsPrime(i)) {\n                primes.Add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private static bool IsPrime(long number) {\n        if (number <= 1) return false;\n        if (number == 2) return true;\n\n        long boundary = (long)Math.Sqrt(number);\n\n        for (long i = 2; i <= boundary; i++) {\n            if (number % i == 0) return false;\n        }\n\n        return true;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CountUpTo((5L)).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));\n    Debug.Assert(CountUpTo((6L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));\n    Debug.Assert(CountUpTo((7L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));\n    Debug.Assert(CountUpTo((10L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))));\n    Debug.Assert(CountUpTo((0L)).Equals((new List<long>())));\n    Debug.Assert(CountUpTo((22L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))));\n    Debug.Assert(CountUpTo((1L)).Equals((new List<long>())));\n    Debug.Assert(CountUpTo((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));\n    Debug.Assert(CountUpTo((47L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L}))));\n    Debug.Assert(CountUpTo((101L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L, (long)47L, (long)53L, (long)59L, (long)61L, (long)67L, (long)71L, (long)73L, (long)79L, (long)83L, (long)89L, (long)97L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_97","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Nu ta asumi ma kel informason ki nu ta dadu é sénpri válidu.    \/\/kel ki ta mostra kes dígitu di kel unidadi.     \/\/Konpleta kel funson ki ta toma dôs númeru interu i ta torna     \/\/ >>> Multiply((148L), (412L))\n    \/\/ (16L)\n    \/\/ >>> Multiply((19L), (28L))\n    \/\/ (72L)\n    \/\/ >>> Multiply((2020L), (1851L))\n    \/\/ (0L)\n    \/\/ >>> Multiply((14L), (-15L))\n    \/\/ (20L)\n    public static long Multiply(long a, long b) {\n","canonical_solution":"public static long Multiply(long a, long b) {\n    int unitDigitA = (int)(Math.Abs(a) % 10);\n    int unitDigitB = (int)(Math.Abs(b) % 10);\n    return (long)(unitDigitA * unitDigitB);\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Multiply((148L), (412L)) == (16L));\n    Debug.Assert(Multiply((19L), (28L)) == (72L));\n    Debug.Assert(Multiply((2020L), (1851L)) == (0L));\n    Debug.Assert(Multiply((14L), (-15L)) == (20L));\n    Debug.Assert(Multiply((76L), (67L)) == (42L));\n    Debug.Assert(Multiply((17L), (27L)) == (49L));\n    Debug.Assert(Multiply((0L), (1L)) == (0L));\n    Debug.Assert(Multiply((0L), (0L)) == (0L));\n    }\n\n}\n"},{"task_id":"HumanEval_98","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Si nu da un stringa s, konta númeru di vogal maiúskulus na indísiu par.     \/\/ >>> CountUpper((\"aBCdEf\"))\n    \/\/ (1L)\n    \/\/ >>> CountUpper((\"abcdefg\"))\n    \/\/ (0L)\n    \/\/ >>> CountUpper((\"dBBE\"))\n    \/\/ (0L)\n    public static long CountUpper(string s) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long CountUpper(string s) {\n        long count = 0;\n        for (int i = 0; i < s.Length; i += 2) {\n            if (\"AEIOU\".Contains(s[i])) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void Main(string[] args) {\n        Console.WriteLine(CountUpper(\"aBCdEf\")); \/\/ Output: 1\n        Console.WriteLine(CountUpper(\"abcdefg\")); \/\/ Output: 0\n        Console.WriteLine(CountUpper(\"dBBE\")); \/\/ Output: 0\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CountUpper((\"aBCdEf\")) == (1L));\n    Debug.Assert(CountUpper((\"abcdefg\")) == (0L));\n    Debug.Assert(CountUpper((\"dBBE\")) == (0L));\n    Debug.Assert(CountUpper((\"B\")) == (0L));\n    Debug.Assert(CountUpper((\"U\")) == (1L));\n    Debug.Assert(CountUpper((\"\")) == (0L));\n    Debug.Assert(CountUpper((\"EEEE\")) == (2L));\n    }\n\n}\n"},{"task_id":"HumanEval_99","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/di dôs númeru interu, nu ta rodonda-l pa lonji di númeru 0.    \/\/i ta torna kel númeru ínteru más pértu di el.    \/\/Kria un funson ki ta toma un valor (stringa) ki ta riprizenta un númeru     \/\/ >>> ClosestInteger((\"10\"))\n    \/\/ (10L)\n    \/\/ >>> ClosestInteger((\"15.3\"))\n    \/\/ (15L)\n    \/\/ Note:\n    \/\/ Rounding away from zero means that if the given number is equidistant\n    \/\/ from two integers, the one you should return is the one that is the\n    \/\/ farthest from zero. For example closest_integer(\"14.5\") should\n    \/\/ return 15 and closest_integer(\"-14.5\") should return -15.\n    public static long ClosestInteger(string value) {\n","canonical_solution":"public static long ClosestInteger(string value) {\n    double number = double.Parse(value);\n    return (long)Math.Round(number, MidpointRounding.AwayFromZero);\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"},{"task_id":"HumanEval_100","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/i ta reprizenta númeru di pédra na nível (i+1).     \/\/Retorna númeru di pédra na kada nível na un lista, undi elementu na indéksu     \/\/- kel otu númeru par si n é par.     \/\/- kel otu númeru dispari si n é dispari.     \/\/Númeru di pédra na kel otu nível é:     \/\/Primeru nível ten n pédra.    \/\/Si nu da un númeru interu puzitivu n, nu ten ki faze un monti di n nível di pédra.    \/\/ >>> MakeAPile((3L))\n    \/\/ (new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))\n    public static List<long> MakeAPile(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> MakeAPile(long n) {\n        List<long> pile = new List<long>();\n        long currentStones = n;\n        \n        for (long i = 0; i < n; i++) {\n            pile.Add(currentStones);\n            currentStones += (n % 2 == 0) ? 2 : 2;\n        }\n\n        return pile;\n    }\n    \n    static void Main(string[] args) {\n        List<long> result = MakeAPile(3L);\n        Console.WriteLine(string.Join(\", \", result));  \/\/ Output: 3, 5, 7\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(MakeAPile((3L)).Equals((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))));\n    Debug.Assert(MakeAPile((4L)).Equals((new List<long>(new long[]{(long)4L, (long)6L, (long)8L, (long)10L}))));\n    Debug.Assert(MakeAPile((5L)).Equals((new List<long>(new long[]{(long)5L, (long)7L, (long)9L, (long)11L, (long)13L}))));\n    Debug.Assert(MakeAPile((6L)).Equals((new List<long>(new long[]{(long)6L, (long)8L, (long)10L, (long)12L, (long)14L, (long)16L}))));\n    Debug.Assert(MakeAPile((8L)).Equals((new List<long>(new long[]{(long)8L, (long)10L, (long)12L, (long)14L, (long)16L, (long)18L, (long)20L, (long)22L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_101","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/pa dividi stringa na palavras i torna un lista di palavras.     \/\/Bu ta dadu un sériu di palavras separadu pa vírgula ô spasu.    \/\/ >>> WordsString((\"Hi, my name is John\"))\n    \/\/ (new List<string>(new string[]{(string)\"Hi\", (string)\"my\", (string)\"name\", (string)\"is\", (string)\"John\"}))\n    \/\/ >>> WordsString((\"One, two, three, four, five, six\"))\n    \/\/ (new List<string>(new string[]{(string)\"One\", (string)\"two\", (string)\"three\", (string)\"four\", (string)\"five\", (string)\"six\"}))\n    public static List<string> WordsString(string s) {\n","canonical_solution":"public static List<string> WordsString(string s) {\n    char[] separators = new char[] { ' ', ',' };\n    var words = s.Split(separators, StringSplitOptions.RemoveEmptyEntries);\n    return new List<string>(words);\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(WordsString((\"Hi, my name is John\")).Equals((new List<string>(new string[]{(string)\"Hi\", (string)\"my\", (string)\"name\", (string)\"is\", (string)\"John\"}))));\n    Debug.Assert(WordsString((\"One, two, three, four, five, six\")).Equals((new List<string>(new string[]{(string)\"One\", (string)\"two\", (string)\"three\", (string)\"four\", (string)\"five\", (string)\"six\"}))));\n    Debug.Assert(WordsString((\"Hi, my name\")).Equals((new List<string>(new string[]{(string)\"Hi\", (string)\"my\", (string)\"name\"}))));\n    Debug.Assert(WordsString((\"One,, two, three, four, five, six,\")).Equals((new List<string>(new string[]{(string)\"One\", (string)\"two\", (string)\"three\", (string)\"four\", (string)\"five\", (string)\"six\"}))));\n    Debug.Assert(WordsString((\"\")).Equals((new List<string>())));\n    Debug.Assert(WordsString((\"ahmed     , gamal\")).Equals((new List<string>(new string[]{(string)\"ahmed\", (string)\"gamal\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_102","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/ka ten ninhun númeru di kel tipu, enton kel funson debe torna -1.    \/\/Má, si  é kel númeru más grandi di interu par ki sta na intervalu [x, y] inkluzivu.    \/\/Kel funson li ta toma dôs númeru puzitivu x y y ta torna     \/\/ >>> ChooseNum((12L), (15L))\n    \/\/ (14L)\n    \/\/ >>> ChooseNum((13L), (12L))\n    \/\/ (-1L)\n    public static long ChooseNum(long x, long y) {\n","canonical_solution":"if (x > y) {\n            return -1;\n        }\n        \n        \/\/ Ensure x is the bigger one for simplicity\n        if (x > y) {\n            long temp = x;\n            x = y;\n            y = temp;\n        }\n        \n        \/\/ Start searching from y down to x\n        for (long i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ChooseNum((12L), (15L)) == (14L));\n    Debug.Assert(ChooseNum((13L), (12L)) == (-1L));\n    Debug.Assert(ChooseNum((33L), (12354L)) == (12354L));\n    Debug.Assert(ChooseNum((5234L), (5233L)) == (-1L));\n    Debug.Assert(ChooseNum((6L), (29L)) == (28L));\n    Debug.Assert(ChooseNum((27L), (10L)) == (-1L));\n    Debug.Assert(ChooseNum((7L), (7L)) == (-1L));\n    Debug.Assert(ChooseNum((546L), (546L)) == (546L));\n    }\n\n}\n"},{"task_id":"HumanEval_104","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Nota: Lista ki ta mandadu pa repósta debe ser ordenadu di manera ki ta aumenta.    \/\/Un elementu ki ka ten ninhun dígitu par.    \/\/Si nu da un lista di purtuges puzitivu x, nu ta torna un lista ordenadu di tudu     \/\/ >>> UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))\n    \/\/ >>> UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L})))\n    \/\/ (new List<long>())\n    public static List<long> UniqueDigits(List<long> x) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static List<long> UniqueDigits(List<long> x) {\n        return x.Where(n => !n.ToString().Any(c => \"02468\".Contains(c)))\n                .OrderBy(n => n)\n                .ToList();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))));\n    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L}))).Equals((new List<long>())));\n    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)12345L, (long)2033L, (long)111L, (long)151L}))).Equals((new List<long>(new long[]{(long)111L, (long)151L}))));\n    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)135L, (long)103L, (long)31L}))).Equals((new List<long>(new long[]{(long)31L, (long)135L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_105","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Un, dôs, três, kuatu, sinku, seis, seti, oitu, novéntu.    \/\/Inverte lista ki nu ta atxa i dipôs ranja kada dígitu ku nómi ki ta koresponde di     \/\/Nu da-u un lista di númeru interu, ranja kes númeru interu ki sta entri 1 i 9 inkluzivu,     \/\/ >>> ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L})))\n    \/\/ (new List<string>(new string[]{(string)\"Eight\", (string)\"Five\", (string)\"Four\", (string)\"Three\", (string)\"Two\", (string)\"Two\", (string)\"One\", (string)\"One\"}))\n    \/\/ If the list is empty, return an empty list:\n    \/\/ >>> ByLength((new List<long>()))\n    \/\/ (new List<string>())\n    \/\/ If the list has any strange number ignore it:\n    \/\/ >>> ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L})))\n    \/\/ (new List<string>(new string[]{(string)\"One\"}))\n    public static List<string> ByLength(List<long> arr) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static List<string> ByLength(List<long> arr) {\n        \/\/ Define a dictionary to map numbers to their names.\n        var digitToName = new Dictionary<long, string> {\n            {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"},\n            {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}\n        };\n\n        \/\/ Filter the numbers that are between 1 and 9.\n        var filtered = arr.Where(x => digitToName.ContainsKey(x)).ToList();\n\n        \/\/ Sort the filtered numbers.\n        filtered.Sort();\n\n        \/\/ Reverse the list.\n        filtered.Reverse();\n\n        \/\/ Map the numbers to their names using the dictionary.\n        return filtered.Select(x => digitToName[x]).ToList();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L}))).Equals((new List<string>(new string[]{(string)\"Eight\", (string)\"Five\", (string)\"Four\", (string)\"Three\", (string)\"Two\", (string)\"Two\", (string)\"One\", (string)\"One\"}))));\n    Debug.Assert(ByLength((new List<long>())).Equals((new List<string>())));\n    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L}))).Equals((new List<string>(new string[]{(string)\"One\"}))));\n    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)3L, (long)2L}))).Equals((new List<string>(new string[]{(string)\"Three\", (string)\"Two\", (string)\"One\"}))));\n    Debug.Assert(ByLength((new List<long>(new long[]{(long)9L, (long)4L, (long)8L}))).Equals((new List<string>(new string[]{(string)\"Nine\", (string)\"Eight\", (string)\"Four\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_106","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/kel faktorial di i é multiplikason di kes númeru di 1 pa i (1 * 2 * ... * i).     \/\/N ta kumesa na 1.    \/\/ô suma di númeru di 1 ti i.     \/\/i ta torna un lista di tamanhu n, di manera ki valor di elementu na indéks i é fatorial di i si i é par     \/\/Implementa funson f ki ta toma n komu un parámetru,     \/\/ >>> F((5L))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))\n    public static List<long> F(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> F(long n) {\n        List<long> result = new List<long>();\n\n        for (long i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                result.Add(Factorial(i));\n            } else {\n                result.Add(SumUpTo(i));\n            }\n        }\n        \n        return result;\n    }\n\n    private static long Factorial(long number) {\n        if (number == 0) return 1;\n        long factorial = 1;\n        for (long i = 1; i <= number; i++) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n\n    private static long SumUpTo(long number) {\n        return (number * (number + 1)) \/ 2;\n    }\n\n    static void Main(string[] args) {\n        List<long> result = F(5);\n        foreach (long val in result) {\n            Console.WriteLine(val);\n        }\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(F((5L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))));\n    Debug.Assert(F((7L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L, (long)720L, (long)28L}))));\n    Debug.Assert(F((1L)).Equals((new List<long>(new long[]{(long)1L}))));\n    Debug.Assert(F((3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_107","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu 1:     \/\/palindromu di númeru interu ki ta fika na intervalu ((1, n), inkluzivu.     \/\/Si nu da un númeru interu pozitivu n, nu ta torna un tuple ki ten númeru di par y impar     \/\/ >>> EvenOddPalindrome((3L))\n    \/\/ (Tuple.Create(1L, 2L))\n    \/\/ Explanation:\n    \/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n    \/\/ Example 2:\n    \/\/ >>> EvenOddPalindrome((12L))\n    \/\/ (Tuple.Create(4L, 6L))\n    \/\/ Explanation:\n    \/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n    \/\/ Note:\n    \/\/ 1. 1 <= n <= 10^3\n    \/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\n    public static Tuple<long, long> EvenOddPalindrome(long n) {\n","canonical_solution":"public static Tuple<long, long> EvenOddPalindrome(long n) {\n    long evenCount = 0;\n    long oddCount = 0;\n\n    for (long i = 1; i <= n; i++) {\n        if (IsPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n\n    return Tuple.Create(evenCount, oddCount);\n}\n\nprivate static bool IsPalindrome(long number) {\n    long original = number;\n    long reversed = 0;\n\n    while (number > 0) {\n        long digit = number % 10;\n        reversed = reversed * 10 + digit;\n        number \/= 10;\n    }\n\n    return original == reversed;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(EvenOddPalindrome((123L)).Equals((Tuple.Create(8L, 13L))));\n    Debug.Assert(EvenOddPalindrome((12L)).Equals((Tuple.Create(4L, 6L))));\n    Debug.Assert(EvenOddPalindrome((3L)).Equals((Tuple.Create(1L, 2L))));\n    Debug.Assert(EvenOddPalindrome((63L)).Equals((Tuple.Create(6L, 8L))));\n    Debug.Assert(EvenOddPalindrome((25L)).Equals((Tuple.Create(5L, 6L))));\n    Debug.Assert(EvenOddPalindrome((19L)).Equals((Tuple.Create(4L, 6L))));\n    Debug.Assert(EvenOddPalindrome((9L)).Equals((Tuple.Create(4L, 5L))));\n    Debug.Assert(EvenOddPalindrome((1L)).Equals((Tuple.Create(0L, 1L))));\n    }\n\n}\n"},{"task_id":"HumanEval_108","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu, -123 ten siginifikadu di dígitu -1, 2 i 3.     \/\/Si un númeru é negativu, dipos se primeru dígitu sinadu ta ser negativu:     \/\/Númeru di elementu ki ten un soma di dígitos > 0.     \/\/Skrebe un funson count_nums ki ta toma un lista di intirjus i ta torna     \/\/ >>> CountNums((new List<long>()))\n    \/\/ (0L)\n    \/\/ >>> CountNums((new List<long>(new long[]{(long)-1L, (long)11L, (long)-11L})))\n    \/\/ (1L)\n    \/\/ >>> CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L})))\n    \/\/ (3L)\n    public static long CountNums(List<long> arr) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static long CountNums(List<long> arr) {\n        long count = 0;\n\n        foreach (long number in arr) {\n            long sumOfDigits = 0;\n            long num = number;\n            \n            while (num != 0) {\n                long digit = num % 10;\n                sumOfDigits += digit;\n                num \/= 10;\n            }\n\n            if (sumOfDigits > 0) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    static void Main(string[] args) {\n        \/\/ Test cases\n        Console.WriteLine(CountNums(new List<long>())); \/\/ (0L)\n        Console.WriteLine(CountNums(new List<long> { -1L, 11L, -11L })); \/\/ (1L)\n        Console.WriteLine(CountNums(new List<long> { 1L, 1L, 2L })); \/\/ (3L)\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CountNums((new List<long>())) == (0L));\n    Debug.Assert(CountNums((new List<long>(new long[]{(long)-1L, (long)-2L, (long)0L}))) == (0L));\n    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L, (long)-2L, (long)3L, (long)4L, (long)5L}))) == (6L));\n    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)6L, (long)9L, (long)-6L, (long)0L, (long)1L, (long)5L}))) == (5L));\n    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)100L, (long)98L, (long)-7L, (long)1L, (long)-1L}))) == (4L));\n    Debug.Assert(CountNums((new List<long>(new long[]{(long)12L, (long)23L, (long)34L, (long)-45L, (long)-56L, (long)0L}))) == (5L));\n    Debug.Assert(CountNums((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));\n    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L}))) == (1L));\n    }\n\n}\n"},{"task_id":"HumanEval_109","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Nota: É garantidu ki es lista ten un monti di elementu úniku.    \/\/Si lista ki dadu é ka ten, torna true.     \/\/Nton, torna fla verdadi ô torna fla falsu.    \/\/Si é posível pa nu atxa lista ordenadu, nu ta faze kel operason li di riba.    \/\/na pontu di partida na lista, purizénplu, na númeru 0 di inprézu.     \/\/Na kel últimu párti di lista, ta fika     \/\/Un operason di desviu pa direita signifika ki tudu elementu di lista ta ser desviadu pa un.    \/\/Bu pode faze kel mudansa di direita tudu bês ki bu krê.    \/\/kel otu operason na lista ki sta la:     \/\/é posível ranja un lista na ordi ki ka sta ta kai, na es forma:    \/\/Nhos ta ben odja si nhos ta skodje kes nómi ki sta na lista di algen ki nhos krê skodje.    \/\/Nu ten un lista 'arr' di N númeru interu arr[1], arr[2], ..., arr[N].    \/\/ >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L})))\n    \/\/ (true)\n    \/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n    \/\/ be achieved for the given list.\n    \/\/ >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L})))\n    \/\/ (false)\n    \/\/ Explanation:It is not possible to get non-decreasing order for the given\n    \/\/ list by performing any number of right shift operations.\n    public static bool MoveOneBall(List<long> arr) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static bool MoveOneBall(List<long> arr) {\n        if (arr.Count == 0) return true;\n\n        int n = arr.Count;\n        int descentCount = 0;\n        int indexOfDescent = -1;\n\n        \/\/ Find number of descents in the array\n        for (int i = 0; i < n; i++) {\n            if (arr[i] > arr[(i + 1) % n]) {\n                descentCount++;\n                indexOfDescent = (i + 1) % n;\n            }\n            if (descentCount > 1) {\n                return false;\n            }\n        }\n\n        \/\/ No descents means the array is already sorted\n        if (descentCount == 0) {\n            return true;\n        }\n\n        \/\/ Check if the single descent allows a circular sorted order\n        for (int i = 0; i < n; i++) {\n            if (arr[(indexOfDescent + i) % n] > arr[(indexOfDescent + i + 1) % n]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L}))) == (true));\n    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)10L, (long)1L, (long)2L}))) == (true));\n    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)4L, (long)3L, (long)1L, (long)2L}))) == (false));\n    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L}))) == (false));\n    Debug.Assert(MoveOneBall((new List<long>())) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_110","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Si ka ten, torna fla \"NEN\".     \/\/pa tudu elementu di lst1 ser par, torna \"YES\".     \/\/Si é pusível pa troka elementu entri lst1 i lst2 pa faze     \/\/Ka ten ninhun limiti na númeru di elementu ki ta ser skambidu entri lst1 i lst2.     \/\/pa faze un lista di sô númeru par.    \/\/i ta determina si é pusível faze un interkâmbio di elementos     \/\/Na kel prubléma li, bu ta ben inplementa un funson ki ta toma dôs lista di númeru,     \/\/ >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))\n    \/\/ (\"YES\")\n    \/\/ >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L})))\n    \/\/ (\"NO\")\n    \/\/ It is assumed that the input lists will be non-empty.\n    public static string Exchange(List<long> lst1, List<long> lst2) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem\n{\n    public static string Exchange(List<long> lst1, List<long> lst2)\n    {\n        int countOfOddsInLst1 = lst1.Count(x => x % 2 != 0);\n        int countOfEvensInLst2 = lst2.Count(x => x % 2 == 0);\n\n        return countOfOddsInLst1 <= countOfEvensInLst2 ? \"YES\" : \"NO\";\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((\"YES\")));\n    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L}))).Equals((\"NO\")));\n    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)2L, (long)1L, (long)4L, (long)3L}))).Equals((\"YES\")));\n    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)4L}))).Equals((\"YES\")));\n    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)3L}))).Equals((\"NO\")));\n    Debug.Assert(Exchange((new List<long>(new long[]{(long)3L, (long)2L, (long)6L, (long)1L, (long)8L, (long)9L})), (new List<long>(new long[]{(long)3L, (long)5L, (long)5L, (long)1L, (long)1L, (long)1L}))).Equals((\"NO\")));\n    Debug.Assert(Exchange((new List<long>(new long[]{(long)100L, (long)200L})), (new List<long>(new long[]{(long)200L, (long)200L}))).Equals((\"YES\")));\n    }\n\n}\n"},{"task_id":"HumanEval_111","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Si ten más di un létra ki ta fla kel mésmu kuza, torna fla tudu.    \/\/di kel letra ki ten más repiti y ki ten kel kontidadi korespondienti.     \/\/Si nu da-l un stringa ki ta reprizenta un létra minúskulu separadu pa un espasu, el ta torna un disionáriu     \/\/ >>> Histogram((\"a b c\"))\n    \/\/ (new Dictionary<string,long>(){{\"a\", 1L}, {\"b\", 1L}, {\"c\", 1L}})\n    \/\/ >>> Histogram((\"a b b a\"))\n    \/\/ (new Dictionary<string,long>(){{\"a\", 2L}, {\"b\", 2L}})\n    \/\/ >>> Histogram((\"a b c a b\"))\n    \/\/ (new Dictionary<string,long>(){{\"a\", 2L}, {\"b\", 2L}})\n    \/\/ >>> Histogram((\"b b b b a\"))\n    \/\/ (new Dictionary<string,long>(){{\"b\", 4L}})\n    \/\/ >>> Histogram((\"\"))\n    \/\/ (new Dictionary<string,long>())\n    public static Dictionary<string,long> Histogram(string test) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static Dictionary<string, long> Histogram(string test) {\n        if (string.IsNullOrWhiteSpace(test)) {\n            return new Dictionary<string, long>();\n        }\n\n        var words = test.Split(' ');\n        var letterCounts = new Dictionary<string, long>();\n\n        \/\/ Count the occurrences of each letter\n        foreach (var word in words) {\n            if (letterCounts.ContainsKey(word)) {\n                letterCounts[word]++;\n            } else {\n                letterCounts[word] = 1;\n            }\n        }\n\n        \/\/ Determine the maximum count\n        long maxCount = letterCounts.Values.Max();\n\n        \/\/ Create a dictionary for letters with the maximum count\n        var result = letterCounts.Where(pair => pair.Value == maxCount)\n                                 .ToDictionary(pair => pair.Key, pair => pair.Value);\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Histogram((\"a b b a\")).Equals((new Dictionary<string,long>(){{\"a\", 2L}, {\"b\", 2L}})));\n    Debug.Assert(Histogram((\"a b c a b\")).Equals((new Dictionary<string,long>(){{\"a\", 2L}, {\"b\", 2L}})));\n    Debug.Assert(Histogram((\"a b c d g\")).Equals((new Dictionary<string,long>(){{\"a\", 1L}, {\"b\", 1L}, {\"c\", 1L}, {\"d\", 1L}, {\"g\", 1L}})));\n    Debug.Assert(Histogram((\"r t g\")).Equals((new Dictionary<string,long>(){{\"r\", 1L}, {\"t\", 1L}, {\"g\", 1L}})));\n    Debug.Assert(Histogram((\"b b b b a\")).Equals((new Dictionary<string,long>(){{\"b\", 4L}})));\n    Debug.Assert(Histogram((\"r t g\")).Equals((new Dictionary<string,long>(){{\"r\", 1L}, {\"t\", 1L}, {\"g\", 1L}})));\n    Debug.Assert(Histogram((\"\")).Equals((new Dictionary<string,long>())));\n    Debug.Assert(Histogram((\"a\")).Equals((new Dictionary<string,long>(){{\"a\", 1L}})));\n    }\n\n}\n"},{"task_id":"HumanEval_112","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu     \/\/Bu debe da un tuple ki ten stringa di rezultadu y verdadi\/falsu pa verifika.     \/\/Un stringa ta txomadu palindrómu si el ta lédu na mesmu manera pa tras ku pa frenti.     \/\/dipôs djobe si kel stringa ki ta sai é palindrómu.     \/\/Nu ta dadu 2 strings s i c, nu ten ki skesi tudu karater na s ki é igual a kualker karater na c     \/\/TIZORUS DI PALAVRA DI DEUS    \/\/ >>> ReverseDelete((\"abcde\"), (\"ae\"))\n    \/\/ (Tuple.Create(\"bcd\", false))\n    \/\/ >>> ReverseDelete((\"abcdef\"), (\"b\"))\n    \/\/ (Tuple.Create(\"acdef\", false))\n    \/\/ >>> ReverseDelete((\"abcdedcba\"), (\"ab\"))\n    \/\/ (Tuple.Create(\"cdedc\", true))\n    public static Tuple<string, bool> ReverseDelete(string s, string c) {\n","canonical_solution":"using System;\nusing System.Linq;\n\nclass Problem {\n    public static Tuple<string, bool> ReverseDelete(string s, string c) {\n        \/\/ Remove characters from 's' that are in 'c'\n        string resultString = new string(s.Where(ch => !c.Contains(ch)).ToArray());\n        \n        \/\/ Check if the result string is a palindrome\n        bool isPalindrome = resultString.SequenceEqual(resultString.Reverse());\n\n        \/\/ Return the result string and palindrome check as a tuple\n        return Tuple.Create(resultString, isPalindrome);\n    }\n\n    \/\/ Example usage\n    static void Main(string[] args) {\n        var example1 = ReverseDelete(\"abcde\", \"ae\");\n        Console.WriteLine($\"(\\\"bcd\\\", false) == ({example1.Item1}, {example1.Item2})\");\n\n        var example2 = ReverseDelete(\"abcdef\", \"b\");\n        Console.WriteLine($\"(\\\"acdef\\\", false) == ({example2.Item1}, {example2.Item2})\");\n\n        var example3 = ReverseDelete(\"abcdedcba\", \"ab\");\n        Console.WriteLine($\"(\\\"cdedc\\\", true) == ({example3.Item1}, {example3.Item2})\");\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ReverseDelete((\"abcde\"), (\"ae\")).Equals((Tuple.Create(\"bcd\", false))));\n    Debug.Assert(ReverseDelete((\"abcdef\"), (\"b\")).Equals((Tuple.Create(\"acdef\", false))));\n    Debug.Assert(ReverseDelete((\"abcdedcba\"), (\"ab\")).Equals((Tuple.Create(\"cdedc\", true))));\n    Debug.Assert(ReverseDelete((\"dwik\"), (\"w\")).Equals((Tuple.Create(\"dik\", false))));\n    Debug.Assert(ReverseDelete((\"a\"), (\"a\")).Equals((Tuple.Create(\"\", true))));\n    Debug.Assert(ReverseDelete((\"abcdedcba\"), (\"\")).Equals((Tuple.Create(\"abcdedcba\", true))));\n    Debug.Assert(ReverseDelete((\"abcdedcba\"), (\"v\")).Equals((Tuple.Create(\"abcdedcba\", true))));\n    Debug.Assert(ReverseDelete((\"vabba\"), (\"v\")).Equals((Tuple.Create(\"abba\", true))));\n    Debug.Assert(ReverseDelete((\"mamma\"), (\"mia\")).Equals((Tuple.Create(\"\", true))));\n    }\n\n}\n"},{"task_id":"HumanEval_113","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/di dígitos páris na i'th stringa di entrada.     \/\/stringa i di input. \" undi tudu i debe ser substituídu pa númeru     \/\/Kada elementu i di rezultadu debe ser \"númeru di elementu páridu na     \/\/Si nu ten un lista di strings, undi kada strings é só dígitos, nu ta torna un lista.    \/\/ >>> OddCount((new List<string>(new string[]{(string)\"1234567\"})))\n    \/\/ (new List<string>(new string[]{(string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n    \/\/ >>> OddCount((new List<string>(new string[]{(string)\"3\", (string)\"11111111\"})))\n    \/\/ (new List<string>(new string[]{(string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\n    public static List<string> OddCount(List<string> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<string> OddCount(List<string> lst)\n    {\n        List<string> result = new List<string>();\n        foreach (var str in lst)\n        {\n            int oddCount = 0;\n            foreach (var c in str)\n            {\n                if ((c - '0') % 2 != 0) \/\/ Check if the digit is odd\n                {\n                    oddCount++;\n                }\n            }\n\n            string output = $\"the number of odd elements {oddCount}n the str{oddCount}ng {oddCount} of the {oddCount}nput.\";\n            result.Add(output);\n        }\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(OddCount((new List<string>(new string[]{(string)\"1234567\"}))).Equals((new List<string>(new string[]{(string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))));\n    Debug.Assert(OddCount((new List<string>(new string[]{(string)\"3\", (string)\"11111111\"}))).Equals((new List<string>(new string[]{(string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))));\n    Debug.Assert(OddCount((new List<string>(new string[]{(string)\"271\", (string)\"137\", (string)\"314\"}))).Equals((new List<string>(new string[]{(string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\", (string)\"the number of odd elements 3n the str3ng 3 of the 3nput.\", (string)\"the number of odd elements 2n the str2ng 2 of the 2nput.\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_114","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu     \/\/di nómi.    \/\/Si nu da un lista di númeru interu, nu ta atxa suma mínimu di kualker sublista ki ka é válidu     \/\/ >>> Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L})))\n    \/\/ (1L)\n    \/\/ >>> Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L})))\n    \/\/ (-6L)\n    public static long Minsubarraysum(List<long> nums) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static long Minsubarraysum(List<long> nums) {\n        long minSum = nums[0], currentSum = nums[0];\n        \n        for (int i = 1; i < nums.Count; i++) {\n            currentSum = Math.Min(nums[i], currentSum + nums[i]);\n            minSum = Math.Min(minSum, currentSum);\n        }\n        \n        return minSum;\n    }\n\n    \/\/ Example usage\n    public static void Main() {\n        Console.WriteLine(Minsubarraysum(new List<long> { 2L, 3L, 4L, 1L, 2L, 4L })); \/\/ Output: 1L\n        Console.WriteLine(Minsubarraysum(new List<long> { -1L, -2L, -3L }));         \/\/ Output: -6L\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L}))) == (1L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))) == (-6L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)2L, (long)-10L}))) == (-14L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-9999999999999999L}))) == (-9999999999999999L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)0L, (long)10L, (long)20L, (long)1000000L}))) == (0L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)10L, (long)11L, (long)13L, (long)8L, (long)3L, (long)4L}))) == (3L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-33L, (long)32L, (long)-1L, (long)0L, (long)-2L}))) == (-33L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-10L}))) == (-10L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)7L}))) == (7L));\n    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)1L, (long)-1L}))) == (-1L));\n    }\n\n}\n"},{"task_id":"HumanEval_115","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu 1:     \/\/Trazi númeru di bês ki bu meste pa bu poi kes baldi na txon.    \/\/Bu trabadju é uza kes baldi pa bu tra kes pozis.    \/\/i tudu kes baldi ten kel mésmu kapasidadi.     \/\/Kada poz ten un baldi ki pode uzadu pa tra agu di el,     \/\/i kada 1 na un rijistu ta riprizenta un úniku unidadi di águ.     \/\/Kada fila ta riprizenta un sô pozison.    \/\/ >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L))\n    \/\/ (6L)\n    \/\/ Example 2:\n    \/\/ >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L))\n    \/\/ (5L)\n    \/\/ Example 3:\n    \/\/ >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L))\n    \/\/ (0L)\n    \/\/ Constraints:\n    \/\/ * all wells have the same length\n    \/\/ * 1 <= grid.length <= 10^2\n    \/\/ * 1 <= grid[:,1].length <= 10^2\n    \/\/ * grid[i][j] -> 0 | 1\n    \/\/ * 1 <= capacity <= 10\n    public static long MaxFill(List<List<long>> grid, long capacity) {\n","canonical_solution":"public static long MaxFill(List<List<long>> grid, long capacity) {\n    long operations = 0;\n\n    foreach (var row in grid) {\n        long waterUnits = row.Sum();\n        operations += waterUnits \/ capacity;\n        if (waterUnits % capacity != 0) {\n            operations++;\n        }\n    }\n\n    return operations;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L)) == (6L));\n    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L)) == (5L));\n    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L)) == (0L));\n    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (2L)) == (4L));\n    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (9L)) == (2L));\n    }\n\n}\n"},{"task_id":"HumanEval_116","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/El debe ser inplementadu di es manera:     \/\/Pa un númeru di unis sima kel-li, ranja na bazi di valor desimal.     \/\/Númeru di un na ses reprezentason bináriu na ordi ki ta subi.     \/\/Na es kata, bu ten ki ranja un lista di intjerus non-negativu di akordu ku     \/\/ >>> SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n    \/\/ >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    \/\/ (new List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n    \/\/ >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    \/\/ (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long> arr) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static List<long> SortArray(List<long> arr) {\n        return arr.OrderBy(num => CountOnesInBinary(num))\n                  .ThenBy(num => num)\n                  .ToList();\n    }\n\n    private static int CountOnesInBinary(long num) {\n        return Convert.ToString(num, 2).Count(c => c == '1');\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_117","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Nota: bu pode pensa ma kel stringa di input ten sô létras i espasu.    \/\/Si stringa s é ka ten nada, kel funson debe da un lista ka ten nada.     \/\/n konsonanti, na ordi ki kes palavra ta parse na stringa s.     \/\/un funson ki ta torna un lista di tudu palavra di stringa s ki ten izatamenti     \/\/Nu da-u un stringa s i un númeru natural n, bu foi enkaregadu di inplementa     \/\/ >>> SelectWords((\"Mary had a little lamb\"), (4L))\n    \/\/ (new List<string>(new string[]{(string)\"little\"}))\n    \/\/ >>> SelectWords((\"Mary had a little lamb\"), (3L))\n    \/\/ (new List<string>(new string[]{(string)\"Mary\", (string)\"lamb\"}))\n    \/\/ >>> SelectWords((\"simple white space\"), (2L))\n    \/\/ (new List<string>())\n    \/\/ >>> SelectWords((\"Hello world\"), (4L))\n    \/\/ (new List<string>(new string[]{(string)\"world\"}))\n    \/\/ >>> SelectWords((\"Uncle sam\"), (3L))\n    \/\/ (new List<string>(new string[]{(string)\"Uncle\"}))\n    public static List<string> SelectWords(string s, long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<string> SelectWords(string s, long n) {\n        List<string> result = new List<string>();\n        if (string.IsNullOrEmpty(s)) \n            return result;\n\n        string[] words = s.Split(' ');\n        string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n\n        foreach (string word in words) {\n            int consonantCount = 0;\n            foreach (char c in word) {\n                if (consonants.Contains(c)) {\n                    consonantCount++;\n                }\n            }\n\n            if (consonantCount == n) {\n                result.Add(word);\n            }\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SelectWords((\"Mary had a little lamb\"), (4L)).Equals((new List<string>(new string[]{(string)\"little\"}))));\n    Debug.Assert(SelectWords((\"Mary had a little lamb\"), (3L)).Equals((new List<string>(new string[]{(string)\"Mary\", (string)\"lamb\"}))));\n    Debug.Assert(SelectWords((\"simple white space\"), (2L)).Equals((new List<string>())));\n    Debug.Assert(SelectWords((\"Hello world\"), (4L)).Equals((new List<string>(new string[]{(string)\"world\"}))));\n    Debug.Assert(SelectWords((\"Uncle sam\"), (3L)).Equals((new List<string>(new string[]{(string)\"Uncle\"}))));\n    Debug.Assert(SelectWords((\"\"), (4L)).Equals((new List<string>())));\n    Debug.Assert(SelectWords((\"a b c d e f\"), (1L)).Equals((new List<string>(new string[]{(string)\"b\", (string)\"c\", (string)\"d\", (string)\"f\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_118","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Bu pode pensa ma kel stringa ki bu dadu ten sô un létra na ingles.     \/\/atxa un vogal ki ta kunpri kel kondison li di riba.    \/\/Vokais na kumesu i na fin ka ta konta.    \/\/dôs konsonanti di ladu direita di palavra (sensivel pa maiúscula y minúscula).     \/\/Bu ta dadu un palavra. Bu trabadju é atxa kel vogal más pértu ki sta entri     \/\/ >>> GetClosestVowel((\"yogurt\"))\n    \/\/ (\"u\")\n    \/\/ >>> GetClosestVowel((\"FULL\"))\n    \/\/ (\"U\")\n    \/\/ >>> GetClosestVowel((\"quick\"))\n    \/\/ (\"\")\n    \/\/ >>> GetClosestVowel((\"ab\"))\n    \/\/ (\"\")\n    public static string GetClosestVowel(string word) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static string GetClosestVowel(string word) {\n        if (string.IsNullOrWhiteSpace(word) || word.Length < 3) {\n            return \"\";\n        }\n        \n        HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };\n        \n        for (int i = word.Length - 2; i > 0; i--) {\n            if (vowels.Contains(word[i]) && \n                !vowels.Contains(word[i - 1]) && !vowels.Contains(word[i + 1])) {\n                return word[i].ToString();\n            }\n        }\n        return \"\";\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(GetClosestVowel(\"yogurt\")); \/\/ Output: \"u\"\n        Console.WriteLine(GetClosestVowel(\"FULL\"));   \/\/ Output: \"U\"\n        Console.WriteLine(GetClosestVowel(\"quick\"));  \/\/ Output: \"\"\n        Console.WriteLine(GetClosestVowel(\"ab\"));     \/\/ Output: \"\"\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(GetClosestVowel((\"yogurt\")).Equals((\"u\")));\n    Debug.Assert(GetClosestVowel((\"full\")).Equals((\"u\")));\n    Debug.Assert(GetClosestVowel((\"easy\")).Equals((\"\")));\n    Debug.Assert(GetClosestVowel((\"eAsy\")).Equals((\"\")));\n    Debug.Assert(GetClosestVowel((\"ali\")).Equals((\"\")));\n    Debug.Assert(GetClosestVowel((\"bad\")).Equals((\"a\")));\n    Debug.Assert(GetClosestVowel((\"most\")).Equals((\"o\")));\n    Debug.Assert(GetClosestVowel((\"ab\")).Equals((\"\")));\n    Debug.Assert(GetClosestVowel((\"ba\")).Equals((\"\")));\n    Debug.Assert(GetClosestVowel((\"quick\")).Equals((\"\")));\n    Debug.Assert(GetClosestVowel((\"anime\")).Equals((\"i\")));\n    Debug.Assert(GetClosestVowel((\"Asia\")).Equals((\"\")));\n    Debug.Assert(GetClosestVowel((\"Above\")).Equals((\"o\")));\n    }\n\n}\n"},{"task_id":"HumanEval_119","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Retorna 'Si' si ten un manera di faze un stringa dretu, y retorna 'Nen' si ka ten.     \/\/' (()) ' é ka kel-li.     \/\/é ekilibradu. Pur izénplu: stringa '(((() ' é dretu, enkuantu stringa     \/\/Un stringa S é konsideradu sima bon si i sô si tudu paréntesis na S     \/\/alguns ordi, ki e resultanti stringa ta ser bon.     \/\/Bu trabadju é odja si é posível konkansa kes dôs stringa na     \/\/sô na paréntesis \" ((\") ô na paréntesis di fin di palavra \") \".     \/\/Bu ta dadu un lista di dôs stringa, tudu dôs stringa ta konsta di abértu     \/\/ >>> MatchParens((new List<string>(new string[]{(string)\"()(\", (string)\")\"})))\n    \/\/ (\"Yes\")\n    \/\/ >>> MatchParens((new List<string>(new string[]{(string)\")\", (string)\")\"})))\n    \/\/ (\"No\")\n    public static string MatchParens(List<string> lst) {\n","canonical_solution":"public static string MatchParens(List<string> lst) {\n        if (lst.Count != 2) return \"No\";\n\n        string str1 = lst[0];\n        string str2 = lst[1];\n\n        \/\/ Check both possible concatenations\n        if (IsValidParentheses(str1 + str2) || IsValidParentheses(str2 + str1))\n            return \"Yes\";\n        \n        return \"No\";\n    }\n\n    private static bool IsValidParentheses(string s) {\n        int balance = 0;\n        foreach (char c in s) {\n            if (c == '(') {\n                balance++;\n            } else if (c == ')') {\n                balance--;\n            }\n            if (balance < 0) {\n                return false; \/\/ More closing parens than opening\n            }\n        }\n        return balance == 0;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"()(\", (string)\")\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\")\", (string)\")\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"(()(())\", (string)\"())())\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\")())\", (string)\"(()()(\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"(())))\", (string)\"(()())((\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"()\", (string)\"())\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"(()(\", (string)\"()))()\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"((((\", (string)\"((())\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\")(()\", (string)\"(()(\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\")(\", (string)\")(\"}))).Equals((\"No\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\"(\", (string)\")\"}))).Equals((\"Yes\")));\n    Debug.Assert(MatchParens((new List<string>(new string[]{(string)\")\", (string)\"(\"}))).Equals((\"Yes\")));\n    }\n\n}\n"},{"task_id":"HumanEval_120","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu 1:     \/\/di lonji k ku más k númeru na arr.     \/\/Si nu da un lista di ar di númeru interu y un númeru interu pozitivu k, nu ta torna un lista ordenadu     \/\/ >>> Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L))\n    \/\/ (new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))\n    \/\/ Example 2:\n    \/\/ >>> Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L))\n    \/\/ (new List<long>(new long[]{(long)4L, (long)4L}))\n    \/\/ Example 3:\n    \/\/ >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))\n    \/\/ (new List<long>(new long[]{(long)2L}))\n    \/\/ Note:\n    \/\/ 1. The length of the list will be in the range of [1, 1000].\n    \/\/ 2. The elements in the list will be in the range of [-1000, 1000].\n    \/\/ 3. 0 <= k <= len(arr)\n    public static List<long> Maximum(List<long> arr, long k) {\n","canonical_solution":"public static List<long> Maximum(List<long> arr, long k) {\n    return arr.OrderByDescending(n => n).Take((int)k).OrderBy(n => n).ToList();\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L)).Equals((new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L)).Equals((new List<long>(new long[]{(long)4L, (long)4L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L)).Equals((new List<long>(new long[]{(long)2L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)123L, (long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (3L)).Equals((new List<long>(new long[]{(long)2L, (long)20L, (long)123L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (4L)).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)20L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)5L, (long)15L, (long)0L, (long)3L, (long)-13L, (long)-8L, (long)0L})), (7L)).Equals((new List<long>(new long[]{(long)-13L, (long)-8L, (long)0L, (long)0L, (long)3L, (long)5L, (long)15L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-1L, (long)0L, (long)2L, (long)5L, (long)3L, (long)-10L})), (2L)).Equals((new List<long>(new long[]{(long)3L, (long)5L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)0L, (long)5L, (long)-7L})), (1L)).Equals((new List<long>(new long[]{(long)5L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L})), (2L)).Equals((new List<long>(new long[]{(long)-4L, (long)4L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-10L, (long)10L})), (2L)).Equals((new List<long>(new long[]{(long)-10L, (long)10L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)-23L, (long)243L, (long)-400L, (long)0L})), (0L)).Equals((new List<long>())));\n    }\n\n}\n"},{"task_id":"HumanEval_121","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/Da un lista di intjerus ki ka é ka bu torna suma di tudu kes elementu di uns ki sta na pozison par.     \/\/ >>> Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L})))\n    \/\/ (12L)\n    \/\/ >>> Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L})))\n    \/\/ (9L)\n    \/\/ >>> Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L})))\n    \/\/ (0L)\n    public static long Solution(List<long> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static long Solution(List<long> lst) {\n        long sum = 0;\n        for (int i = 0; i < lst.Count; i += 2) { \/\/ Iterate over even indices\n            if (lst[i] % 2 != 0) { \/\/ Check if the element is odd\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n    \n    static void Main() {\n        Console.WriteLine(Solution(new List<long>{5L, 8L, 7L, 1L})); \/\/ Output: 12\n        Console.WriteLine(Solution(new List<long>{3L, 3L, 3L, 3L, 3L})); \/\/ Output: 9\n        Console.WriteLine(Solution(new List<long>{30L, 13L, 24L, 321L})); \/\/ Output: 0\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L}))) == (12L));\n    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L}))) == (9L));\n    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L}))) == (0L));\n    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)9L}))) == (5L));\n    Debug.Assert(Solution((new List<long>(new long[]{(long)2L, (long)4L, (long)8L}))) == (0L));\n    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)23L, (long)32L}))) == (23L));\n    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)13L, (long)2L, (long)9L}))) == (3L));\n    }\n\n}\n"},{"task_id":"HumanEval_122","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/é suma di kes elementu ki ten más di dôs dígitu di kes primeru k elementu di arr.     \/\/Si nu ten un lista di númeru interu ki é ka válidu arr i un númeru interu k, torna     \/\/ >>> AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L))\n    \/\/ (24L)\n    \/\/ Constraints:\n    \/\/ 1. 1 <= len(arr) <= 100\n    \/\/ 2. 1 <= k <= len(arr)\n    public static long AddElements(List<long> arr, long k) {\n","canonical_solution":"public static long AddElements(List<long> arr, long k) {\n        long sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (arr[i] >= -99 && arr[i] <= 99) {\n                sum += arr[i];\n            }\n        }\n        return sum;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L, (long)-2L, (long)-3L, (long)41L, (long)57L, (long)76L, (long)87L, (long)88L, (long)99L})), (3L)) == (-4L));\n    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)121L, (long)3L, (long)4000L, (long)5L, (long)6L})), (2L)) == (0L));\n    Debug.Assert(AddElements((new List<long>(new long[]{(long)11L, (long)21L, (long)3L, (long)90L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (125L));\n    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (24L));\n    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L})), (1L)) == (1L));\n    }\n\n}\n"},{"task_id":"HumanEval_123","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/get_odd_collatz(5) ta torna [1, 5] # Sekuensia di collatz pa 5 é [5, 16, 8, 4, 2, 1], pur isu ki kes númeru dispari é so 1, y 5.     \/\/Pur izénplu:     \/\/2. lista ki nu manda pa tras, ordenadu pa kada un di es.     \/\/1. Collatz ((1) é [1].     \/\/Nota:     \/\/term + 1 . Konjetura é ki ka ta nporta kal ki é valor di n, seixénsia sénpri ta txiga 1.     \/\/Si kel térmu antis é párti, kel otu térmu é 3 bês más grandi ki kel antis.    \/\/kel otu térmu é metadi di     \/\/sima siginti: kumesa ku kualker númeru interu pozitivu n. Dipôs kada térmu ta ser obidu di     \/\/Konjetura di Collatz é un konjetura na matimátika ki ta trata di un sekson difinidu     \/\/Si nu da un númeru interu puzitivu n, torna un lista ordenadu ki ten kes númeru párti na sekvensia di collatz.     \/\/ >>> GetOddCollatz((5L))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)5L}))\n    public static List<long> GetOddCollatz(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<long> GetOddCollatz(long n)\n    {\n        HashSet<long> oddNumbers = new HashSet<long>();\n\n        while (n != 1)\n        {\n            if (n % 2 != 0)\n            {\n                oddNumbers.Add(n);\n            }\n\n            if (n % 2 == 0)\n            {\n                n \/= 2;\n            }\n            else\n            {\n                n = 3 * n + 1;\n            }\n        }\n\n        oddNumbers.Add(1); \/\/ Add 1 to the set as per problem statement\n\n        List<long> result = new List<long>(oddNumbers);\n        result.Sort();\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(GetOddCollatz((14L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));\n    Debug.Assert(GetOddCollatz((5L)).Equals((new List<long>(new long[]{(long)1L, (long)5L}))));\n    Debug.Assert(GetOddCollatz((12L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)5L}))));\n    Debug.Assert(GetOddCollatz((1L)).Equals((new List<long>(new long[]{(long)1L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_124","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/4. Data debe ser na formatu: mm-dd-yyyy     \/\/3. Kel mês ka debe ser menus di 1 i más di 12.    \/\/2. Númeru di dias ka é menus ki 1 ou más ki 31 dia pa mês 1,3,5,7,8,10,12. I númeru di dias ka é menus ki 1 ou más ki 30 dia pa mês 4,6,9,11. I, númeru di dias ka é menus ki 1 ou más ki 29 dia pa mês 2.    \/\/1. Stringa di data ka sta vazio.    \/\/Kel data é válidu si tudu kes régra li ta kunpri:     \/\/ta torna verdadi si data é válidu si é ka verdadi é falsu.     \/\/Bu ten ki skrebe un funson ki ta valida un data dadu i     \/\/ >>> ValidDate((\"03-11-2000\"))\n    \/\/ (true)\n    \/\/ >>> ValidDate((\"15-01-2012\"))\n    \/\/ (false)\n    \/\/ >>> ValidDate((\"04-0-2040\"))\n    \/\/ (false)\n    \/\/ >>> ValidDate((\"06-04-2020\"))\n    \/\/ (true)\n    \/\/ >>> ValidDate((\"06\/04\/2020\"))\n    \/\/ (false)\n    public static bool ValidDate(string date) {\n","canonical_solution":"public static bool ValidDate(string date)\n{\n    if (string.IsNullOrEmpty(date) || date.Length != 10) return false;\n\n    string[] dateParts = date.Split('-');\n    if (dateParts.Length != 3) return false;\n\n    if (!int.TryParse(dateParts[0], out int month) || !int.TryParse(dateParts[1], out int day) || !int.TryParse(dateParts[2], out int year))\n    {\n        return false;\n    }\n\n    if (month < 1 || month > 12) return false;\n\n    if (year < 1) return false;\n\n    bool isValidDay = false;\n\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day >= 1 && day <= 31)\n    {\n        isValidDay = true;\n    }\n    else if ((month == 4 || month == 6 || month == 9 || month == 11) && day >= 1 && day <= 30)\n    {\n        isValidDay = true;\n    }\n    else if (month == 2 && day >= 1 && day <= 29)\n    {\n        isValidDay = true;\n    }\n\n    return isValidDay;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ValidDate((\"03-11-2000\")) == (true));\n    Debug.Assert(ValidDate((\"15-01-2012\")) == (false));\n    Debug.Assert(ValidDate((\"04-0-2040\")) == (false));\n    Debug.Assert(ValidDate((\"06-04-2020\")) == (true));\n    Debug.Assert(ValidDate((\"01-01-2007\")) == (true));\n    Debug.Assert(ValidDate((\"03-32-2011\")) == (false));\n    Debug.Assert(ValidDate((\"\")) == (false));\n    Debug.Assert(ValidDate((\"04-31-3000\")) == (false));\n    Debug.Assert(ValidDate((\"06-06-2005\")) == (true));\n    Debug.Assert(ValidDate((\"21-31-2000\")) == (false));\n    Debug.Assert(ValidDate((\"04-12-2003\")) == (true));\n    Debug.Assert(ValidDate((\"04122003\")) == (false));\n    Debug.Assert(ValidDate((\"20030412\")) == (false));\n    Debug.Assert(ValidDate((\"2003-04\")) == (false));\n    Debug.Assert(ValidDate((\"2003-04-12\")) == (false));\n    Debug.Assert(ValidDate((\"04-2003\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_126","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/Númeru, torna falsu. Ka ten númeru negativu i sô númeru interu.    \/\/Si lista ten más di un kópia di kel mésmu     \/\/Si nu dadu un lista di númeru, nu ta torna mostra si es sta ordenadu ô nau.    \/\/ >>> IsSorted((new List<long>(new long[]{(long)5L})))\n    \/\/ (true)\n    \/\/ >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))\n    \/\/ (true)\n    \/\/ >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L})))\n    \/\/ (false)\n    \/\/ >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})))\n    \/\/ (true)\n    \/\/ >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L})))\n    \/\/ (true)\n    \/\/ >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L})))\n    \/\/ (false)\n    \/\/ >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L})))\n    \/\/ (true)\n    \/\/ >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L})))\n    \/\/ (false)\n    public static bool IsSorted(List<long> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static bool IsSorted(List<long> lst) {\n        if (lst.Count == 0) return true;\n\n        \/\/ To store the occurrence of each number\n        var occurrences = new Dictionary<long, int>();\n\n        for (int i = 0; i < lst.Count - 1; i++) {\n            \/\/ Check if the current number is greater than the next number\n            if (lst[i] > lst[i + 1]) {\n                return false;\n            }\n\n            \/\/ Count the occurrences of each number\n            if (occurrences.ContainsKey(lst[i])) {\n                occurrences[lst[i]]++;\n            } else {\n                occurrences[lst[i]] = 1;\n            }\n\n            \/\/ If any number occurs more than twice\n            if (occurrences[lst[i]] > 2) {\n                return false;\n            }\n        }\n\n        \/\/ Check the last element in the list for more than two occurrences\n        if (occurrences.ContainsKey(lst[lst.Count - 1])) {\n            occurrences[lst[lst.Count - 1]]++;\n            if (occurrences[lst[lst.Count - 1]] > 2) {\n                return false;\n            }\n        } else {\n            occurrences[lst[lst.Count - 1]] = 1;\n        }\n\n        return true;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)5L}))) == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))) == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L}))) == (false));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}))) == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (false));\n    Debug.Assert(IsSorted((new List<long>())) == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L}))) == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))) == (false));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L}))) == (false));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L}))) == (false));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L}))) == (true));\n    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_127","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/[input\/output] amostra:     \/\/Si kes dôs intervalu ka ta kruza, torna \"NON\".     \/\/di otu manera, torna \"NEN\".     \/\/Si longu di intersésu é un númeru primeru, torna \"SI\",     \/\/ki se lonji é 1, ki é ka un númeru primo.     \/\/Pur izénplu, intersezon di intervalu (1, 3), (2, 4) é (2, 3)     \/\/N ta atxa ma kel númeru li é un númeru primeru.    \/\/Bu trabadju é determina si longi di interseison di es dos    \/\/Pa kada intervalu dadu, ta asumidu ma se kumesu é menus o igual a se fin.     \/\/ta inklui kumesu i fin.     \/\/Kes intervalu ki dadu é fitxadu, ki siginifika ma intervalu (prinsipi, fin)     \/\/undi kada intervalu é un par di númeru interu. Pur izénplu, intervalu = (inisiu, fin) = (1, 2).    \/\/Bu ta dadu dôs intervalu,     \/\/ >>> Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L)))\n    \/\/ (\"NO\")\n    \/\/ >>> Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L)))\n    \/\/ (\"NO\")\n    \/\/ >>> Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L)))\n    \/\/ (\"YES\")\n    public static string Intersection(Tuple<long, long> interval1, Tuple<long, long> interval2) {\n","canonical_solution":"long start1 = interval1.Item1;\n    long end1 = interval1.Item2;\n    long start2 = interval2.Item1;\n    long end2 = interval2.Item2;\n\n    long intersectStart = Math.Max(start1, start2);\n    long intersectEnd = Math.Min(end1, end2);\n\n    if (intersectStart > intersectEnd) {\n        return \"NO\";\n    }\n\n    long intersectionLength = intersectEnd - intersectStart + 1;\n\n    if (IsPrime(intersectionLength)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n\nprivate static bool IsPrime(long number) {\n    if (number < 2) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n\n    long boundary = (long)Math.Floor(Math.Sqrt(number));\n\n    for (long i = 3; i <= boundary; i += 2) {\n        if (number % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L))).Equals((\"YES\")));\n    Debug.Assert(Intersection((Tuple.Create(-2L, 2L)), (Tuple.Create(-4L, 0L))).Equals((\"YES\")));\n    Debug.Assert(Intersection((Tuple.Create(-11L, 2L)), (Tuple.Create(-1L, -1L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(3L, 5L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(1L, 2L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(-2L, -2L)), (Tuple.Create(-3L, -2L))).Equals((\"NO\")));\n    }\n\n}\n"},{"task_id":"HumanEval_128","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Nota: torna nulu pa ar ki ka ten ninhun.     \/\/di kada númeru na lista, reprezentadu pa 1, -1 ô 0.     \/\/Suma di magnitudes di intjerus multiplikadu pa produtu di tudu sinplis     \/\/Bu ta dadu un lista di ar di númeru interu i bu ten ki torna     \/\/ >>> ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L})))\n    \/\/ 9L\n    \/\/ >>> ProdSigns((new List<long>(new long[]{(long)0L, (long)1L})))\n    \/\/ 0L\n    \/\/ >>> ProdSigns((new List<long>()))\n    \/\/ null\n    public static Nullable<long> ProdSigns(List<long> arr) {\n","canonical_solution":"public static Nullable<long> ProdSigns(List<long> arr) {\n        if (arr == null || arr.Count == 0) return null;\n\n        long sumOfMagnitudes = 0;\n        long productOfSigns = 1;\n\n        foreach (var num in arr) {\n            sumOfMagnitudes += Math.Abs(num);\n\n            if (num > 0) {\n                productOfSigns *= 1;\n            } else if (num < 0) {\n                productOfSigns *= -1;\n            } else {\n                productOfSigns = 0;\n                break;\n            }\n        }\n\n        return sumOfMagnitudes * productOfSigns;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L}))).Equals(-9L));\n    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)0L, (long)1L}))).Equals(0L));\n    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)2L, (long)3L, (long)-1L, (long)1L}))).Equals(-10L));\n    Debug.Assert(ProdSigns((new List<long>())).Equals(null));\n    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)2L, (long)-1L, (long)-1L, (long)9L}))).Equals(20L));\n    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)-1L, (long)1L}))).Equals(4L));\n    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)1L}))).Equals(-4L));\n    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)0L}))).Equals(0L));\n    }\n\n}\n"},{"task_id":"HumanEval_129","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Retorna un lista ordenadu di valor na kes pilon ki kaminhu mínimu ta pasa pa el.     \/\/Nu ten sertéza ma respósta é úniku.     \/\/N ta konkorda ku bu.    \/\/sima ki lst_A[i] < lst_B[i] i pa kualker j (1 <= j < i) nu ten     \/\/di lst_B, na otu palavras, ten un indéks di númeru interu i (1 <= i <= k)     \/\/através di (nu txoma-s lst_A i lst_B), lst_A é leksikografikamenti menus     \/\/Dipôs di faze lista ordenadu di valor na kel pilon A i B,    \/\/Un kaminhu A (di lonji k) ta konsideradu más pikinoti ki un kaminhu B (di lonji k) si     \/\/NHU ka pode sai di lugar.    \/\/é nesesariu distintu).    \/\/Pur favor, nhos toma nota ma un kaminhu di lonji k signifika vizita izatamenti k pilula (no     \/\/di sel.     \/\/na otu palavra, bu pode bai pa kes pilon ki ta partilha un borda ku bo     \/\/di kualker pilula, y na kada pasu bu pode muda pa kualker pilula vizinhu,     \/\/Bu ten ki atxa kaminhu mínimu di lonji k na grelha.    \/\/inkluzivu ta parse sô un bês na kes pilon di kel grelu.     \/\/kada númeru interu na intervalu [1, N * N]     \/\/Si nu da un redi ku N riju i N koluna (N >= 2) i un númeru interu k,     \/\/ >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))\n    \/\/ >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L))\n    \/\/ (new List<long>(new long[]{(long)1L}))\n    public static List<long> Minpath(List<List<long>> grid, long k) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> Minpath(List<List<long>> grid, long k) {\n        int n = grid.Count;\n        List<long> result = new List<long>();\n        long[,] dp = new long[n, n];\n        (int, int)[,] parent = new (int, int)[n, n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i, j] = long.MaxValue;\n            }\n        }\n\n        var directions = new List<(int, int)>() { (0, 1), (1, 0), (0, -1), (-1, 0) };\n        SortedSet<(long, int, int)> pq = new SortedSet<(long, int, int)>((a, b) => a.Item1 == b.Item1 ? (a.Item2 == b.Item2 ? a.Item3.CompareTo(b.Item3) : a.Item2.CompareTo(b.Item2)) : a.Item1.CompareTo(b.Item1));\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i, j] = grid[i][j];\n                pq.Add((grid[i][j], i, j));\n            }\n        }\n\n        while (pq.Count > 0) {\n            var curr = pq.Min;\n            pq.Remove(curr);\n            long currValue = curr.Item1;\n            int x = curr.Item2;\n            int y = curr.Item3;\n\n            foreach (var dir in directions) {\n                int newX = x + dir.Item1;\n                int newY = y + dir.Item2;\n                if (newX >= 0 && newX < n && newY >= 0 && newY < n) {\n                    long newCost = currValue + grid[newX][newY];\n                    if (dp[newX, newY] > newCost) {\n                        if (dp[newX, newY] != long.MaxValue) {\n                            pq.Remove((dp[newX, newY], newX, newY));\n                        }\n                        dp[newX, newY] = newCost;\n                        parent[newX, newY] = (x, y);\n                        pq.Add((dp[newX, newY], newX, newY));\n                    }\n                }\n            }\n        }\n\n        (int, int) end = (0, 0);\n        long minPathSum = long.MaxValue;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (minPathSum > dp[i, j]) {\n                    minPathSum = dp[i, j];\n                    end = (i, j);\n                }\n            }\n        }\n\n        Stack<long> pathStack = new Stack<long>();\n        (int, int) node = end;\n        for (int step = 0; step < k; step++) {\n            pathStack.Push(grid[node.Item1][node.Item2]);\n            node = parent[node.Item1, node.Item2];\n        }\n\n        while (pathStack.Count > 0) {\n            result.Add(pathStack.Pop());\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L)).Equals((new List<long>(new long[]{(long)1L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L}), (List<long>)new List<long>(new long[]{(long)9L, (long)10L, (long)11L, (long)12L}), (List<long>)new List<long>(new long[]{(long)13L, (long)14L, (long)15L, (long)16L})})), (4L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)10L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)12L, (long)1L}), (List<long>)new List<long>(new long[]{(long)3L, (long)16L, (long)11L, (long)15L}), (List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L})})), (7L)).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)1L, (long)10L, (long)1L, (long)10L, (long)1L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L}), (List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)15L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)12L}), (List<long>)new List<long>(new long[]{(long)3L, (long)10L, (long)11L, (long)16L})})), (5L)).Equals((new List<long>(new long[]{(long)1L, (long)7L, (long)1L, (long)7L, (long)1L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L})})), (9L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L})})), (12L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)6L, (long)8L, (long)9L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)3L, (long)8L, (long)9L}), (List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L}))));\n    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)3L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_130","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/primeru n + 1 númeru di sekson di Tribonacci.     \/\/Bu ta dadu un númeru interu n ki é ka negativu, bu ten ki torna un lista di     \/\/= 2 + 3 + 3 = 8     \/\/tri(3) = tri(2) + tri(1) + tri(4)     \/\/tri(4) = 3  ki ta faze    \/\/tri(2) = 1 + (2 \/ 2) = 2     \/\/Pur izénplu:     \/\/tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1), si n é párti.     \/\/tri (n) = 1 + n \/ 2, si n é par.     \/\/tri(1) = 3  ki ta faze    \/\/Sekuénsia di Tribonacci ta definidu pa rekursu:     \/\/Má, kel ki pesoas ka konxe é sezison di Tribonacci.    \/\/Tudu algen konxe seleson di Fibonacci, foi studadu di manera profundu pa matemátiku na     \/\/ >>> Tri((3L))\n    \/\/ (new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))\n    public static List<long> Tri(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<long> Tri(long n)\n    {\n        List<long> tribonacci = new List<long>(new long[n + 1]);\n\n        for (long i = 0; i <= n; i++)\n        {\n            if (i == 0)\n                tribonacci[(int)i] = 1;\n            else if (i == 1)\n                tribonacci[(int)i] = 3;\n            else if (i % 2 == 0)\n                tribonacci[(int)i] = 1 + i \/ 2;\n            else\n                tribonacci[(int)i] = tribonacci[(int)(i - 1)] + tribonacci[(int)(i - 2)] + tribonacci[(int)(i + 1)];\n        }\n        \n        return tribonacci;\n    }\n    \n    static void Main(string[] args)\n    {\n        \/\/ Example usage:\n        Console.WriteLine(string.Join(\", \", Tri(3)));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Tri((3L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))));\n    Debug.Assert(Tri((4L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L}))));\n    Debug.Assert(Tri((5L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L}))));\n    Debug.Assert(Tri((6L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L}))));\n    Debug.Assert(Tri((7L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L}))));\n    Debug.Assert(Tri((8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L}))));\n    Debug.Assert(Tri((9L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L}))));\n    Debug.Assert(Tri((20L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L, (long)6L, (long)48L, (long)7L, (long)63L, (long)8L, (long)80L, (long)9L, (long)99L, (long)10L, (long)120L, (long)11L}))));\n    Debug.Assert(Tri((0L)).Equals((new List<long>(new long[]{(long)1L}))));\n    Debug.Assert(Tri((1L)).Equals((new List<long>(new long[]{(long)1L, (long)3L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_131","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Retorna 0 si tudu dígitu é par.     \/\/Si nu da un númeru interu puzitivu n, da rezultadu di prujetu di kes dígitu páridu.     \/\/ >>> Digits((1L))\n    \/\/ (1L)\n    \/\/ >>> Digits((4L))\n    \/\/ (0L)\n    \/\/ >>> Digits((235L))\n    \/\/ (15L)\n    public static long Digits(long n) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long Digits(long n) {\n        long product = 1;\n        bool hasOdd = false;\n\n        while (n > 0) {\n            long digit = n % 10;\n            if (digit % 2 != 0) {\n                product *= digit;\n                hasOdd = true;\n            }\n            n \/= 10;\n        }\n\n        return hasOdd ? product : 0;\n    }\n\n    static void Main(string[] args) {\n        Console.WriteLine(Digits(1L));    \/\/ Output: 1\n        Console.WriteLine(Digits(4L));    \/\/ Output: 0\n        Console.WriteLine(Digits(235L));  \/\/ Output: 15\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Digits((5L)) == (5L));\n    Debug.Assert(Digits((54L)) == (5L));\n    Debug.Assert(Digits((120L)) == (1L));\n    Debug.Assert(Digits((5014L)) == (5L));\n    Debug.Assert(Digits((98765L)) == (315L));\n    Debug.Assert(Digits((5576543L)) == (2625L));\n    Debug.Assert(Digits((2468L)) == (0L));\n    }\n\n}\n"},{"task_id":"HumanEval_132","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/undi ki pelu menus un parénti di subsekvensia sta anadu.     \/\/Kel funson debe torna verdadi si i sô si ten un subsekvensia válidu di parentis     \/\/Kria un funson ki ta toma un stringa komu entrada ki ten so brackets kuadradu.     \/\/ >>> IsNested((\"[[]]\"))\n    \/\/ (true)\n    \/\/ >>> IsNested((\"[]]]]]]][[[[[]\"))\n    \/\/ (false)\n    \/\/ >>> IsNested((\"[][]\"))\n    \/\/ (false)\n    \/\/ >>> IsNested((\"[]\"))\n    \/\/ (false)\n    \/\/ >>> IsNested((\"[[][]]\"))\n    \/\/ (true)\n    \/\/ >>> IsNested((\"[[]][[\"))\n    \/\/ (true)\n    public static bool IsNested(string str) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static bool IsNested(string str) {\n        Stack<char> stack = new Stack<char>();\n        bool hasNested = false;\n        \n        foreach (char ch in str) {\n            if (ch == '[') {\n                stack.Push(ch);\n            } else if (ch == ']') {\n                if (stack.Count > 0) {\n                    stack.Pop();\n                    hasNested = true;\n                } else {\n                    return false; \/\/ More closing brackets than opening\n                }\n            }\n\n            \/\/ Check for nesting\n            if (stack.Count > 1) {\n                hasNested = true;\n            }\n        }\n        \n        return stack.Count == 0 && hasNested;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsNested((\"[[]]\")) == (true));\n    Debug.Assert(IsNested((\"[]]]]]]][[[[[]\")) == (false));\n    Debug.Assert(IsNested((\"[][]\")) == (false));\n    Debug.Assert(IsNested((\"[]\")) == (false));\n    Debug.Assert(IsNested((\"[[[[]]]]\")) == (true));\n    Debug.Assert(IsNested((\"[]]]]]]]]]]\")) == (false));\n    Debug.Assert(IsNested((\"[][][[]]\")) == (true));\n    Debug.Assert(IsNested((\"[[]\")) == (false));\n    Debug.Assert(IsNested((\"[]]\")) == (false));\n    Debug.Assert(IsNested((\"[[]][[\")) == (true));\n    Debug.Assert(IsNested((\"[[][]]\")) == (true));\n    Debug.Assert(IsNested((\"\")) == (false));\n    Debug.Assert(IsNested((\"[[[[[[[[\")) == (false));\n    Debug.Assert(IsNested((\"]]]]]]]]\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_133","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/purmeru, ta rodondu kada elementu na lista pa kel int ((Takal) más altu.     \/\/Bu meste torna da suma di kuadratus di númeru na lista ki bu dadu,     \/\/Bu ta dadu un lista di nómi di algen.    \/\/ >>> Lst((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})))\n    \/\/ (14L)\n    \/\/ >>> Lst((new List<float>(new float[]{(float)1.0f, (float)4.0f, (float)9.0f})))\n    \/\/ (98L)\n    \/\/ >>> Lst((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n    \/\/ (84L)\n    \/\/ >>> Lst((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f})))\n    \/\/ (29L)\n    \/\/ >>> Lst((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f})))\n    \/\/ (6L)\n    public static long SumSquares(List<float> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static long SumSquares(List<float> lst)\n    {\n        long sum = 0;\n        foreach (float num in lst)\n        {\n            int roundedNum = (int)Math.Ceiling(num);\n            sum += (long)(roundedNum * roundedNum);\n        }\n        return sum;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f}))) == (29L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)10000.0f, (float)10000.0f}))) == (200000000L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)0.0f}))) == (0L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f}))) == (1L));\n    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2L));\n    }\n\n}\n"},{"task_id":"HumanEval_134","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Nota: \"palavra\" é un grupu di karateris separadu pa un espasu.     \/\/un párti di un palavra, y falsu di otu manera.     \/\/di un dizéntu dadu é un karáter alfabétiku y é ka     \/\/Kre un funson ki ta torna tratu si últimu karáter     \/\/ >>> CheckIfLastCharIsALetter((\"apple pie\"))\n    \/\/ (false)\n    \/\/ >>> CheckIfLastCharIsALetter((\"apple pi e\"))\n    \/\/ (true)\n    \/\/ >>> CheckIfLastCharIsALetter((\"apple pi e \"))\n    \/\/ (false)\n    \/\/ >>> CheckIfLastCharIsALetter((\"\"))\n    \/\/ (false)\n    public static bool CheckIfLastCharIsALetter(string txt) {\n","canonical_solution":"public static bool CheckIfLastCharIsALetter(string txt) {\n        if (string.IsNullOrWhiteSpace(txt)) {\n            return false;\n        }\n\n        txt = txt.Trim();\n        if (txt.Length == 0) {\n            return false;\n        }\n\n        int lastIndex = txt.Length - 1;\n        char lastChar = txt[lastIndex];\n\n        if (!char.IsLetter(lastChar)) {\n            return false;\n        }\n\n        if (lastIndex == 0 || char.IsWhiteSpace(txt[lastIndex - 1])) {\n            return true;\n        }\n\n        return false;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CheckIfLastCharIsALetter((\"apple\")) == (false));\n    Debug.Assert(CheckIfLastCharIsALetter((\"apple pi e\")) == (true));\n    Debug.Assert(CheckIfLastCharIsALetter((\"eeeee\")) == (false));\n    Debug.Assert(CheckIfLastCharIsALetter((\"A\")) == (true));\n    Debug.Assert(CheckIfLastCharIsALetter((\"Pumpkin pie \")) == (false));\n    Debug.Assert(CheckIfLastCharIsALetter((\"Pumpkin pie 1\")) == (false));\n    Debug.Assert(CheckIfLastCharIsALetter((\"\")) == (false));\n    Debug.Assert(CheckIfLastCharIsALetter((\"eeeee e \")) == (false));\n    Debug.Assert(CheckIfLastCharIsALetter((\"apple pie\")) == (false));\n    Debug.Assert(CheckIfLastCharIsALetter((\"apple pi e \")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_135","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/valor duplikadu.     \/\/ka ten ninhun elementu di es tipu, torna -1. Kel lista ki dadu ka ta ten     \/\/é ka más grandi ki ô igual a kel elementu ki ta pirsigui-l.    \/\/Kria un funson ki ta torna maior indéks di un elementu ki     \/\/ >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L})))\n    \/\/ (3L)\n    \/\/ >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))\n    \/\/ (-1L)\n    public static long CanArrange(List<long> arr) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ Create a function which returns the largest index of an element which\n    \/\/ is not greater than or equal to the element immediately preceding it.\n    \/\/ If no such element exists, then return -1.\n    public static long CanArrange(List<long> arr) {\n        for (int i = arr.Count - 1; i > 0; i--) {\n            if (arr[i] < arr[i - 1]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))) == (3L));\n    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)5L}))) == (-1L));\n    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L}))) == (2L));\n    Debug.Assert(CanArrange((new List<long>(new long[]{(long)4L, (long)8L, (long)5L, (long)7L, (long)3L}))) == (4L));\n    Debug.Assert(CanArrange((new List<long>())) == (-1L));\n    }\n\n}\n"},{"task_id":"HumanEval_136","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Si ka ten ninhun númeru interu negativu ô pozitivu, torna-s sima númeru nulu.     \/\/di númeru pozitivu na un lista.     \/\/kel ki é más grandi di kes númeru negativu, y 'b' é kel más pikinoti     \/\/Kre un funson ki ta torna un tuple (a, b), undi 'a' é     \/\/ >>> LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L})))\n    \/\/ Tuple.Create((Nullable<long>)null, 1L)\n    \/\/ >>> LargestSmallestIntegers((new List<long>()))\n    \/\/ Tuple.Create((Nullable<long>)null, (Nullable<long>)null)\n    \/\/ >>> LargestSmallestIntegers((new List<long>(new long[]{(long)0L})))\n    \/\/ Tuple.Create((Nullable<long>)null, (Nullable<long>)null)\n    public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {\n","canonical_solution":"public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {\n        Nullable<long> largestNegative = null;\n        Nullable<long> smallestPositive = null;\n\n        foreach (var number in lst) {\n            if (number < 0) {\n                if (largestNegative == null || number > largestNegative) {\n                    largestNegative = number;\n                }\n            } else if (number > 0) {\n                if (smallestPositive == null || number < smallestPositive) {\n                    smallestPositive = number;\n                }\n            }\n        }\n\n        return Tuple.Create(largestNegative, smallestPositive);\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L, 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L, (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L, 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L, (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L, 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));\n    }\n\n}\n"},{"task_id":"HumanEval_138","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu     \/\/VALUÁ si númeru n pode ser skrebedu komu suma di izatu 4 númeru par ki é pozitivu     \/\/ >>> IsEqualToSumEven((4L))\n    \/\/ (false)\n    \/\/ >>> IsEqualToSumEven((6L))\n    \/\/ (false)\n    \/\/ >>> IsEqualToSumEven((8L))\n    \/\/ (true)\n    public static bool IsEqualToSumEven(long n) {\n","canonical_solution":"using System;\n\nclass Problem {\n    \/\/ Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    public static bool IsEqualToSumEven(long n) {\n        \/\/ Check if n is at least the sum of the smallest 4 positive even numbers (2 + 2 + 2 + 2 = 8)\n        return n >= 8 && n % 2 == 0;\n    }\n    \n    static void Main() {\n        Console.WriteLine(IsEqualToSumEven(4L));  \/\/ false\n        Console.WriteLine(IsEqualToSumEven(6L));  \/\/ false\n        Console.WriteLine(IsEqualToSumEven(8L));  \/\/ true\n        Console.WriteLine(IsEqualToSumEven(10L)); \/\/ true\n        Console.WriteLine(IsEqualToSumEven(12L)); \/\/ true\n        Console.WriteLine(IsEqualToSumEven(15L)); \/\/ false\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IsEqualToSumEven((4L)) == (false));\n    Debug.Assert(IsEqualToSumEven((6L)) == (false));\n    Debug.Assert(IsEqualToSumEven((8L)) == (true));\n    Debug.Assert(IsEqualToSumEven((10L)) == (true));\n    Debug.Assert(IsEqualToSumEven((11L)) == (false));\n    Debug.Assert(IsEqualToSumEven((12L)) == (true));\n    Debug.Assert(IsEqualToSumEven((13L)) == (false));\n    Debug.Assert(IsEqualToSumEven((16L)) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_139","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/undi n > 0     \/\/brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1!     \/\/Fatorizadu di Brazil é difinidu komu:     \/\/ >>> SpecialFactorial((4L))\n    \/\/ (288L)\n    \/\/ The function will receive an integer as input and should return the special\n    \/\/ factorial of this integer.\n    public static long SpecialFactorial(long n) {\n","canonical_solution":"using System;\nusing System.Numerics;\n\nclass Problem {\n    public static long SpecialFactorial(long n) {\n        if (n <= 0)\n            throw new ArgumentException(\"n must be greater than 0\");\n        \n        BigInteger brazilianFactorial = 1;\n        \n        for (long i = 1; i <= n; i++) {\n            brazilianFactorial *= Factorial(i);\n        }\n        \n        return (long)brazilianFactorial;\n    }\n    \n    private static BigInteger Factorial(long num) {\n        BigInteger result = 1;\n        for (long i = 1; i <= num; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SpecialFactorial((4L)) == (288L));\n    Debug.Assert(SpecialFactorial((5L)) == (34560L));\n    Debug.Assert(SpecialFactorial((7L)) == (125411328000L));\n    Debug.Assert(SpecialFactorial((1L)) == (1L));\n    }\n\n}\n"},{"task_id":"HumanEval_140","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/dipôs ranja tudu stras dipos ku -     \/\/i si un númeru ten más di 2 spasu konsekutivu,     \/\/Si nu da un stringa di testu, nu ta ranja tudu strangerus ku sigintis siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti siginti    \/\/ >>> FixSpaces((\" Example\"))\n    \/\/ (\"Example\")\n    \/\/ >>> FixSpaces((\" Example 1\"))\n    \/\/ (\"Example_1\")\n    \/\/ >>> FixSpaces((\" Example 2\"))\n    \/\/ (\"_Example_2\")\n    \/\/ >>> FixSpaces((\" Example 3\"))\n    \/\/ (\"_Example-3\")\n    public static string FixSpaces(string text) {\n","canonical_solution":"public static string FixSpaces(string text) {\n        StringBuilder result = new StringBuilder();\n        int spaceCount = 0;\n\n        for (int i = 0; i < text.Length; i++) {\n            if (text[i] == ' ') {\n                spaceCount++;\n            } else {\n                if (spaceCount > 2) {\n                    result.Append('-');\n                } else {\n                    for (int j = 0; j < spaceCount; j++) {\n                        result.Append('_');\n                    }\n                }\n                result.Append(text[i]);\n                spaceCount = 0;\n            }\n        }\n\n        if (spaceCount > 2) {\n            result.Append('-');\n        } else {\n            for (int j = 0; j < spaceCount; j++) {\n                result.Append('_');\n            }\n        }\n\n        return result.ToString();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FixSpaces((\"Example\")).Equals((\"Example\")));\n    Debug.Assert(FixSpaces((\"Mudasir Hanif \")).Equals((\"Mudasir_Hanif_\")));\n    Debug.Assert(FixSpaces((\"Yellow Yellow  Dirty  Fellow\")).Equals((\"Yellow_Yellow__Dirty__Fellow\")));\n    Debug.Assert(FixSpaces((\"Exa   mple\")).Equals((\"Exa-mple\")));\n    Debug.Assert(FixSpaces((\"   Exa 1 2 2 mple\")).Equals((\"-Exa_1_2_2_mple\")));\n    }\n\n}\n"},{"task_id":"HumanEval_141","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/- Kel substringa dipos di pontu debe ser un di kes: ['txt', 'exe', 'dll']     \/\/alfabétu latinu ('a'-'z' i 'A'-'Z').     \/\/- Kel substringa antis di pontu ka debe sta vazio, y el ta kumesa ku un letra di     \/\/- Nomi di arquivu ten exatamente un pontu '.'     \/\/- Na nómi di arquivu ka debe ten más di três dígitos ('0'-'9').     \/\/ta kunpri:     \/\/Un nómi di arquivu ta konsideradu válidu si y so si tudu kes kondison li di baxu sta kunpri     \/\/'Si' si nómi di arquivu é válidu, y torna 'Nen' si é ka si.     \/\/Kria un funson ki ta toma un stringa ki ta riprizenta nómi di un arquivu, y ta torna     \/\/ >>> FileNameCheck((\"example.txt\"))\n    \/\/ (\"Yes\")\n    \/\/ >>> FileNameCheck((\"1example.dll\"))\n    \/\/ (\"No\")\n    public static string FileNameCheck(string file_name) {\n","canonical_solution":"using System;\nusing System.Text.RegularExpressions;\n\nclass Problem {\n    public static string FileNameCheck(string file_name) {\n        \/\/ Regular expression to validate the file name\n        string pattern = @\"^[a-zA-Z][^.]*\\.[^.]+$\";\n        \n        \/\/ Check if there is exactly one dot and matches the overall pattern\n        if (Regex.IsMatch(file_name, pattern)) {\n            string[] parts = file_name.Split('.');\n            \n            \/\/ Check if the file extension is one of the allowed values\n            if (new[] { \"txt\", \"exe\", \"dll\" }.Contains(parts[1])) {\n                \/\/ Count the number of digits in the file name\n                int digitCount = file_name.Count(char.IsDigit);\n                \n                \/\/ Validate the digit count\n                if (digitCount <= 3) {\n                    return \"Yes\";\n                }\n            }\n        }\n        \n        return \"No\";\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FileNameCheck((\"example.txt\")).Equals((\"Yes\")));\n    Debug.Assert(FileNameCheck((\"1example.dll\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"s1sdf3.asd\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"K.dll\")).Equals((\"Yes\")));\n    Debug.Assert(FileNameCheck((\"MY16FILE3.exe\")).Equals((\"Yes\")));\n    Debug.Assert(FileNameCheck((\"His12FILE94.exe\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"_Y.txt\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"?aREYA.exe\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"\/this_is_valid.dll\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"this_is_valid.wow\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"this_is_valid.txt\")).Equals((\"Yes\")));\n    Debug.Assert(FileNameCheck((\"this_is_valid.txtexe\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"#this2_i4s_5valid.ten\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"@this1_is6_valid.exe\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"this_is_12valid.6exe4.txt\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"all.exe.txt\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"I563_No.exe\")).Equals((\"Yes\")));\n    Debug.Assert(FileNameCheck((\"Is3youfault.txt\")).Equals((\"Yes\")));\n    Debug.Assert(FileNameCheck((\"no_one#knows.dll\")).Equals((\"Yes\")));\n    Debug.Assert(FileNameCheck((\"1I563_Yes3.exe\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"I563_Yes3.txtt\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"final..txt\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"final132\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"_f4indsartal132.\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\".txt\")).Equals((\"No\")));\n    Debug.Assert(FileNameCheck((\"s.\")).Equals((\"No\")));\n    }\n\n}\n"},{"task_id":"HumanEval_142","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/muda kes entrada na lista ki ses indisi ka é múltiplus di 3 ou 4.    \/\/multiplu di 3 i ta kubiku entrada di intjeru si se indisi é un multiplu di 4 i ka un multiplu di 3.    \/\/Kel funson li ta toma un lista di númeru interu. Pa tudu númeru na lista, kel funson li ta skvadra númeru interu si se indéksu é     \/\/\"  N ta faze un diskursu    \/\/ >>> lst\n    \/\/ (long)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})\n    \/\/ >>> lst\n    \/\/ (long)new List<long>()\n    \/\/ >>> lst\n    \/\/ (long)new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L})\n    public static long SumSquares(List<long> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static long SumSquares(List<long> lst)\n    {\n        for (int i = 0; i < lst.Count; i++)\n        {\n            if (i % 3 == 0)\n            {\n                lst[i] = lst[i] * lst[i];\n            }\n            else if (i % 4 == 0)\n            {\n                lst[i] = lst[i] * lst[i] * lst[i];\n            }\n        }\n        long sum = 0;\n        foreach (long number in lst)\n        {\n            sum += number;\n        }\n        return sum;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (6L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)4L, (long)9L}))) == (14L));\n    Debug.Assert(SumSquares((new List<long>())) == (0L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L}))) == (9L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L}))) == (-3L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)0L}))) == (0L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L}))) == (-126L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-56L, (long)-99L, (long)1L, (long)0L, (long)-2L}))) == (3030L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)-1L}))) == (0L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-16L, (long)-9L, (long)-2L, (long)36L, (long)36L, (long)26L, (long)-20L, (long)25L, (long)-40L, (long)20L, (long)-4L, (long)12L, (long)-26L, (long)35L, (long)37L}))) == (-14196L));\n    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-3L, (long)17L, (long)-1L, (long)-15L, (long)13L, (long)-1L, (long)14L, (long)-14L, (long)-12L, (long)-5L, (long)14L, (long)-14L, (long)6L, (long)13L, (long)11L, (long)16L, (long)16L, (long)4L, (long)10L}))) == (-1448L));\n    }\n\n}\n"},{"task_id":"HumanEval_143","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu 1:     \/\/Orden di palavras na kel núven novu debe ser kel mésmu ki na kel núven orijinal.    \/\/ki ten un númeru primeru,     \/\/i bu ten ki torna un stringa ki ten kes palavra di kel frazi orijinal,     \/\/kel frazi ten alguns palavra ki sta separadu ku un espasu,     \/\/Bu ta dadu un stringa ki ta riprizenta un frazi,     \/\/ >>> WordsInSentence((\"This is a test\"))\n    \/\/ (\"is\")\n    \/\/ Example 2:\n    \/\/ >>> WordsInSentence((\"lets go for swimming\"))\n    \/\/ (\"go for\")\n    \/\/ Constraints:\n    \/\/ * 1 <= len(sentence) <= 100\n    \/\/ * sentence contains only letters\n    public static string WordsInSentence(string sentence) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static string WordsInSentence(string sentence) {\n        bool IsPrime(int number) {\n            if (number <= 1) return false;\n            if (number == 2) return true;\n            for (int i = 2; i * i <= number; i++) {\n                if (number % i == 0) return false;\n            }\n            return true;\n        }\n\n        string[] words = sentence.Split(' ');\n        List<string> primeLengthWords = new List<string>();\n\n        foreach (string word in words) {\n            if (IsPrime(word.Length)) {\n                primeLengthWords.Add(word);\n            }\n        }\n\n        return string.Join(\" \", primeLengthWords);\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(WordsInSentence((\"This is a test\")).Equals((\"is\")));\n    Debug.Assert(WordsInSentence((\"lets go for swimming\")).Equals((\"go for\")));\n    Debug.Assert(WordsInSentence((\"there is no place available here\")).Equals((\"there is no place\")));\n    Debug.Assert(WordsInSentence((\"Hi I am Hussein\")).Equals((\"Hi am Hussein\")));\n    Debug.Assert(WordsInSentence((\"go for it\")).Equals((\"go for it\")));\n    Debug.Assert(WordsInSentence((\"here\")).Equals((\"\")));\n    Debug.Assert(WordsInSentence((\"here is\")).Equals((\"is\")));\n    }\n\n}\n"},{"task_id":"HumanEval_144","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Bu pode asumi ma x, y n é frakusons válidu, y ka ten zeru komu denominador.    \/\/<numerador>\/<denominador> undi tantu numerador komu denominador é númeru interu puzitivu.     \/\/Sinon, x i n, é un raprizentason di un frason, y ten kel formatu li:     \/\/x * n. Kel funson ta torna verdadi si x * n é un númeru interu i falsu     \/\/Bu trabadju é inplementa un funson ki ta simplifika es spreson     \/\/ >>> Simplify((\"1\/5\"), (\"5\/1\"))\n    \/\/ (true)\n    \/\/ >>> Simplify((\"1\/6\"), (\"2\/1\"))\n    \/\/ (false)\n    \/\/ >>> Simplify((\"7\/10\"), (\"10\/2\"))\n    \/\/ (false)\n    public static bool Simplify(string x, string n) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static bool Simplify(string x, string n) {\n        var xParts = x.Split('\/');\n        var nParts = n.Split('\/');\n        \n        int xNumerator = int.Parse(xParts[0]);\n        int xDenominator = int.Parse(xParts[1]);\n        \n        int nNumerator = int.Parse(nParts[0]);\n        int nDenominator = int.Parse(nParts[1]);\n        \n        \/\/ Calculate the resulting fraction for x * n\n        int resultNumerator = xNumerator * nNumerator;\n        int resultDenominator = xDenominator * nDenominator;\n        \n        \/\/ Simplify the fraction by finding the gcd\n        int gcd = GCD(resultNumerator, resultDenominator);\n        resultNumerator \/= gcd;\n        resultDenominator \/= gcd;\n        \n        \/\/ It is a whole number if the simplified denominator is 1\n        return resultDenominator == 1;\n    }\n    \n    private static int GCD(int a, int b) {\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Simplify((\"1\/5\"), (\"5\/1\")) == (true));\n    Debug.Assert(Simplify((\"1\/6\"), (\"2\/1\")) == (false));\n    Debug.Assert(Simplify((\"5\/1\"), (\"3\/1\")) == (true));\n    Debug.Assert(Simplify((\"7\/10\"), (\"10\/2\")) == (false));\n    Debug.Assert(Simplify((\"2\/10\"), (\"50\/10\")) == (true));\n    Debug.Assert(Simplify((\"7\/2\"), (\"4\/2\")) == (true));\n    Debug.Assert(Simplify((\"11\/6\"), (\"6\/1\")) == (true));\n    Debug.Assert(Simplify((\"2\/3\"), (\"5\/2\")) == (false));\n    Debug.Assert(Simplify((\"5\/2\"), (\"3\/5\")) == (false));\n    Debug.Assert(Simplify((\"2\/4\"), (\"8\/4\")) == (true));\n    Debug.Assert(Simplify((\"2\/4\"), (\"4\/2\")) == (true));\n    Debug.Assert(Simplify((\"1\/5\"), (\"5\/1\")) == (true));\n    Debug.Assert(Simplify((\"1\/5\"), (\"1\/5\")) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_145","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/N ta ranja-s ku bazi na ses indísiu na lista orijinal.    \/\/Nota: si ten más di un artigu ku un suma di dígitu di kel-li,     \/\/na ordi ki ta subi di akordu ku soma di ses dígitu.     \/\/Skrebe un funson ki ta ranja lista di númeru interu     \/\/ >>> OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L})))\n    \/\/ (new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))\n    \/\/ >>> OrderByPoints((new List<long>()))\n    \/\/ (new List<long>())\n    public static List<long> OrderByPoints(List<long> nums) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem\n{\n    public static List<long> OrderByPoints(List<long> nums)\n    {\n        return nums.Select((num, index) => new { Number = num, Index = index, DigitSum = SumOfDigits(num) })\n                   .OrderBy(item => item.DigitSum)\n                   .ThenBy(item => item.Index)\n                   .Select(item => item.Number)\n                   .ToList();\n    }\n\n    private static int SumOfDigits(long number)\n    {\n        number = Math.Abs(number);\n        int sum = 0;\n        while (number > 0)\n        {\n            sum += (int)(number % 10);\n            number \/= 10;\n        }\n        return sum;\n    }\n\n    static void Main(string[] args)\n    {\n        var sortedList = OrderByPoints(new List<long> { 1L, 11L, -1L, -11L, -12L });\n        Console.WriteLine(string.Join(\", \", sortedList));\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L}))).Equals((new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))));\n    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1234L, (long)423L, (long)463L, (long)145L, (long)2L, (long)423L, (long)423L, (long)53L, (long)6L, (long)37L, (long)3457L, (long)3L, (long)56L, (long)0L, (long)46L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)6L, (long)53L, (long)423L, (long)423L, (long)423L, (long)1234L, (long)145L, (long)37L, (long)46L, (long)56L, (long)463L, (long)3457L}))));\n    Debug.Assert(OrderByPoints((new List<long>())).Equals((new List<long>())));\n    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)-11L, (long)-32L, (long)43L, (long)54L, (long)-98L, (long)2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)-3L, (long)-32L, (long)-98L, (long)-11L, (long)1L, (long)2L, (long)43L, (long)54L}))));\n    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L, (long)11L}))).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)2L, (long)11L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))));\n    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)0L, (long)6L, (long)6L, (long)-76L, (long)-21L, (long)23L, (long)4L}))).Equals((new List<long>(new long[]{(long)-76L, (long)-21L, (long)0L, (long)4L, (long)23L, (long)6L, (long)6L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_146","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/primeru i últimu dígitu di un númeru é párti (1, 3, 5, 7, 9).     \/\/Númeru di elementu na lista ki é más grandi ki 10 i tudu dôs     \/\/Skrebe un funson ki ta toma un lista di númeru komu entrada i ta torna     \/\/ >>> Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L})))\n    \/\/ (1L)\n    \/\/ >>> Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L})))\n    \/\/ (2L)\n    public static long Specialfilter(List<long> nums) {\n","canonical_solution":"public static long Specialfilter(List<long> nums) {\n        return nums.Count(num => {\n            if (num <= 10) return false;\n            long positiveNum = Math.Abs(num);\n            string numStr = positiveNum.ToString();\n            char firstDigit = numStr[0];\n            char lastDigit = numStr[numStr.Length - 1];\n            return IsOddDigit(firstDigit) && IsOddDigit(lastDigit);\n        });\n    }\n\n    private static bool IsOddDigit(char digit) {\n        return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9';\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)5L, (long)-2L, (long)1L, (long)-5L}))) == (0L));\n    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L}))) == (1L));\n    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L}))) == (2L));\n    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)43L, (long)-12L, (long)93L, (long)125L, (long)121L, (long)109L}))) == (4L));\n    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)71L, (long)-2L, (long)-33L, (long)75L, (long)21L, (long)19L}))) == (3L));\n    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)1L}))) == (0L));\n    Debug.Assert(Specialfilter((new List<long>())) == (0L));\n    }\n\n}\n"},{"task_id":"HumanEval_147","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:    \/\/i a[i] + a[j] + a[k] é un múltipu di 3.     \/\/Retorna númeru di triples (a[i], a[j], a[k]) di a undi i < j < k,     \/\/Pa kada i (1 ≤ i ≤ n), valor di a[i] = i * i - i + 1.     \/\/Bu ta dadu un númeru interu pozitivu n. Bu ten ki kria un lista di númeru interu a di lonji n.     \/\/ >>> GetMaxTriples((5L))\n    \/\/ (1L)\n    \/\/ Explanation: \n    \/\/ a = [1, 3, 7, 13, 21]\n    \/\/ The only valid triple is (1, 7, 13).\n    public static long GetMaxTriples(long n) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static long GetMaxTriples(long n) {\n        List<long> a = new List<long>();\n        for (long i = 1; i <= n; i++) {\n            a.Add(i * i - i + 1);\n        }\n\n        long count = 0;\n        for (int i = 0; i < a.Count; i++) {\n            for (int j = i + 1; j < a.Count; j++) {\n                for (int k = j + 1; k < a.Count; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    static void Main(string[] args) {\n        long n = 5; \/\/ Example input\n        Console.WriteLine(GetMaxTriples(n)); \/\/ Should output 1 based on the example given\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(GetMaxTriples((5L)) == (1L));\n    Debug.Assert(GetMaxTriples((6L)) == (4L));\n    Debug.Assert(GetMaxTriples((10L)) == (36L));\n    Debug.Assert(GetMaxTriples((100L)) == (53361L));\n    }\n\n}\n"},{"task_id":"HumanEval_148","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/é ka nómi di planéta.    \/\/Kel funson debe da un tuple vaziu si planet1 o planet2     \/\/é kel ki ta fika más pértu di sól.    \/\/situadu entri órbita di Planéta 1 i órbita di Planéta 2, ordenadu pa     \/\/Kel funson debe da un tuple ki ta kontínua ku tudu planetas ki ten órbita     \/\/Skrebe un funson ki ta toma dôs nómi di planéta komu strings planet1 i planet2.     \/\/Uranu, Netunu.    \/\/é Merkúrio, kel otu é Vénus, dipôs Téra, Marsu, Júpiter, Saturnu,     \/\/Nu ten 8 planeta na nos sistema solar:    \/\/ >>> Bf((\"Jupiter\"), (\"Neptune\"))\n    \/\/ (new List<string>(new string[]{(string)\"Saturn\", (string)\"Uranus\"}))\n    \/\/ >>> Bf((\"Earth\"), (\"Mercury\"))\n    \/\/ (List<string>(\"Venus\"))\n    \/\/ >>> Bf((\"Mercury\"), (\"Uranus\"))\n    \/\/ (new List<string>(new string[]{(string)\"Venus\", (string)\"Earth\", (string)\"Mars\", (string)\"Jupiter\", (string)\"Saturn\"}))\n    public static List<string> Bf(string planet1, string planet2) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<string> Bf(string planet1, string planet2) {\n        List<string> planets = new List<string> { \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n        int index1 = planets.IndexOf(planet1);\n        int index2 = planets.IndexOf(planet2);\n\n        if (index1 == -1 || index2 == -1) {\n            return new List<string>();\n        }\n        \n        List<string> result = new List<string>();\n        int start = Math.Min(index1, index2);\n        int end = Math.Max(index1, index2);\n\n        for (int i = start + 1; i < end; i++) {\n            result.Add(planets[i]);\n        }\n\n        return result;\n    }\n\n    public static void Main() {\n        Console.WriteLine(string.Join(\", \", Bf(\"Jupiter\", \"Neptune\"))); \/\/ Output: Saturn, Uranus\n        Console.WriteLine(string.Join(\", \", Bf(\"Earth\", \"Mercury\")));   \/\/ Output: Venus\n        Console.WriteLine(string.Join(\", \", Bf(\"Mercury\", \"Uranus\"))); \/\/ Output: Venus, Earth, Mars, Jupiter, Saturn\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Bf((\"Jupiter\"), (\"Neptune\")).Equals((new List<string>(new string[]{(string)\"Saturn\", (string)\"Uranus\"}))));\n    Debug.Assert(Bf((\"Earth\"), (\"Mercury\")).Equals((new List<string>(new string[]{(string)\"Venus\"}))));\n    Debug.Assert(Bf((\"Mercury\"), (\"Uranus\")).Equals((new List<string>(new string[]{(string)\"Venus\", (string)\"Earth\", (string)\"Mars\", (string)\"Jupiter\", (string)\"Saturn\"}))));\n    Debug.Assert(Bf((\"Neptune\"), (\"Venus\")).Equals((new List<string>(new string[]{(string)\"Earth\", (string)\"Mars\", (string)\"Jupiter\", (string)\"Saturn\", (string)\"Uranus\"}))));\n    Debug.Assert(Bf((\"Earth\"), (\"Earth\")).Equals((new List<string>())));\n    Debug.Assert(Bf((\"Mars\"), (\"Earth\")).Equals((new List<string>())));\n    Debug.Assert(Bf((\"Jupiter\"), (\"Makemake\")).Equals((new List<string>())));\n    }\n\n}\n"},{"task_id":"HumanEval_149","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/Bu pode pensa ma tudu palavra ten mésmu largura.    \/\/Kel funson debe da un lista di strings na ordi ordenadu.     \/\/Si dôs palavra ten mésmu largura, ranja es lista pa orden alfabétiku.     \/\/debe torna lista ordenadu pa kel régra.     \/\/Orden di es lista debe ser di forma asesual pa largura di kada palavra, y bo     \/\/i el pode ten duplikadu.     \/\/Lista é sénpri un lista di strings i nunka un lista di númeru,     \/\/i ta torna ta mostra lista ki nu atxa ku un ordi ordenadu,     \/\/ta skese strings ki ten longi pádu di el,     \/\/Skrebe un funson ki ta aseita un lista di strings komu un parámetru,     \/\/ >>> ListSort((new List<string>(new string[]{(string)\"aa\", (string)\"a\", (string)\"aaa\"})))\n    \/\/ (new List<string>(new string[]{(string)\"aa\"}))\n    \/\/ >>> ListSort((new List<string>(new string[]{(string)\"ab\", (string)\"a\", (string)\"aaa\", (string)\"cd\"})))\n    \/\/ (new List<string>(new string[]{(string)\"ab\", (string)\"cd\"}))\n    public static List<string> SortedListSum(List<string> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem {\n    public static List<string> ListSort(List<string> lst) {\n        return lst.Where(x => x.Length % 2 == 0)\n                  .OrderBy(x => x.Length)\n                  .ThenBy(x => x)\n                  .ToList();\n    }\n    \n    static void Main() {\n        var result1 = ListSort(new List<string> { \"aa\", \"a\", \"aaa\" });\n        Console.WriteLine(string.Join(\", \", result1)); \/\/ Output: aa\n\n        var result2 = ListSort(new List<string> { \"ab\", \"a\", \"aaa\", \"cd\" });\n        Console.WriteLine(string.Join(\", \", result2)); \/\/ Output: ab, cd\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)\"aa\", (string)\"a\", (string)\"aaa\"}))).Equals((new List<string>(new string[]{(string)\"aa\"}))));\n    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)\"school\", (string)\"AI\", (string)\"asdf\", (string)\"b\"}))).Equals((new List<string>(new string[]{(string)\"AI\", (string)\"asdf\", (string)\"school\"}))));\n    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)\"d\", (string)\"b\", (string)\"c\", (string)\"a\"}))).Equals((new List<string>())));\n    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)\"d\", (string)\"dcba\", (string)\"abcd\", (string)\"a\"}))).Equals((new List<string>(new string[]{(string)\"abcd\", (string)\"dcba\"}))));\n    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)\"AI\", (string)\"ai\", (string)\"au\"}))).Equals((new List<string>(new string[]{(string)\"AI\", (string)\"ai\", (string)\"au\"}))));\n    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)\"a\", (string)\"b\", (string)\"b\", (string)\"c\", (string)\"c\", (string)\"a\"}))).Equals((new List<string>())));\n    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)\"aaaa\", (string)\"bbbb\", (string)\"dd\", (string)\"cc\"}))).Equals((new List<string>(new string[]{(string)\"cc\", (string)\"dd\", (string)\"aaaa\", (string)\"bbbb\"}))));\n    }\n\n}\n"},{"task_id":"HumanEval_150","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/un númeru primo y el debe da valor di y di otu manera.     \/\/Un programa sinplis ki ta torna valor di x si n é     \/\/ >>> XOrY((7L), (34L), (12L))\n    \/\/ (34L)\n    \/\/ >>> XOrY((15L), (8L), (5L))\n    \/\/ (5L)\n    public static long XOrY(long n, long x, long y) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static long XOrY(long n, long x, long y) {\n        return IsPrime(n) ? x : y;\n    }\n\n    private static bool IsPrime(long number) {\n        if (number <= 1) return false;\n        if (number <= 3) return true;\n        if (number % 2 == 0 || number % 3 == 0) return false;\n        \n        for (long i = 5; i * i <= number; i += 6) {\n            if (number % i == 0 || number % (i + 2) == 0) return false;\n        }\n        \n        return true;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(XOrY((7L), (34L), (12L)) == (34L));\n    Debug.Assert(XOrY((15L), (8L), (5L)) == (5L));\n    Debug.Assert(XOrY((3L), (33L), (5212L)) == (33L));\n    Debug.Assert(XOrY((1259L), (3L), (52L)) == (3L));\n    Debug.Assert(XOrY((7919L), (-1L), (12L)) == (-1L));\n    Debug.Assert(XOrY((3609L), (1245L), (583L)) == (583L));\n    Debug.Assert(XOrY((91L), (56L), (129L)) == (129L));\n    Debug.Assert(XOrY((6L), (34L), (1234L)) == (1234L));\n    Debug.Assert(XOrY((1L), (2L), (0L)) == (0L));\n    Debug.Assert(XOrY((2L), (2L), (0L)) == (2L));\n    }\n\n}\n"},{"task_id":"HumanEval_151","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Nu ka ta nporta ku kes númeru ki é negativu ô ki é ka númeru interu.    \/\/Si nu da-u un lista di númeru, da-nu suma di kuadradus di kes númeru     \/\/ >>> DoubleTheDifference((new List<float>(new long[]{(long)1L, (long)3L, (long)2L, (long)0L})))\n    \/\/ (10L)\n    \/\/ >>> DoubleTheDifference((new List<float>(new long[]{(long)-1L, (long)-2L, (long)0L})))\n    \/\/ (0L)\n    \/\/ >>> DoubleTheDifference((new List<float>(new long[]{(long)9L, (long)-2L})))\n    \/\/ (81L)\n    \/\/ >>> DoubleTheDifference((new List<float>(new long[]{(long)0L})))\n    \/\/ (0L)\n    \/\/ If the input list is empty, return 0.\n    public static long DoubleTheDifference(List<float> lst) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    \/\/ Given a list of numbers, return the sum of squares of the numbers\n    \/\/ in the list that are odd. Ignore numbers that are negative or not integers.\n    public static long DoubleTheDifference(List<float> lst) {\n        long sum = 0;\n        foreach (var num in lst) {\n            if (num >= 0 && num == (long)num && ((long)num % 2) != 0) {\n                sum += (long)num * (long)num;\n            }\n        }\n        return sum;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(DoubleTheDifference((new List<float>())) == (0L));\n    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)5.0f, (float)4.0f}))) == (25L));\n    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.1f, (float)0.2f, (float)0.3f}))) == (0L));\n    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0L));\n    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0L));\n    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.2f, (float)3.0f, (float)5.0f}))) == (34L));\n    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165L));\n    }\n\n}\n"},{"task_id":"HumanEval_152","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/izénplu:     \/\/valor é 0, y si é ka si, valor é diferénsa absolutu entri adivinha y pontu.     \/\/Retorna un lista di mesmu lonji ki ta indika kantu lonji di kada adivinhansa.    \/\/Bu ta dadu dôs lista di pontuason i di asuntus di mesmu longu, undi kada indísiu ta mostra un konparason.     \/\/Bu trabadju é odja si un algen dja adivinha koretamenti rezultadus di un monti di konparason.    \/\/é verdadi ki nu meste toma nota i konpara-l.     \/\/Kel ki bu ta xinti i pensa na kel momentu é     \/\/N ta atxa ma nos tudu nu ta lenbra di kel sentimentu ki nu ta xintiba kantu nu ta speraba rezultadu di algun kuza ki nu tinha dja ten txeu ténpu .    \/\/ >>> Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L})))\n    \/\/ (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))\n    \/\/ >>> Compare((new List<long>(new long[]{(long)0L, (long)5L, (long)0L, (long)0L, (long)0L, (long)4L})), (new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L, (long)0L, (long)-2L})))\n    \/\/ (new List<long>(new long[]{(long)4L, (long)4L, (long)1L, (long)0L, (long)0L, (long)6L}))\n    public static List<long> Compare(List<long> game, List<long> guess) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static List<long> Compare(List<long> game, List<long> guess)\n    {\n        List<long> differences = new List<long>();\n        for (int i = 0; i < game.Count; i++)\n        {\n            differences.Add(Math.Abs(game[i] - guess[i]));\n        }\n        return differences;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))));\n    Debug.Assert(Compare((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L})), (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))));\n    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L}))));\n    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L})), (new List<long>(new long[]{(long)-1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)0L, (long)0L, (long)1L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_153","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/(se forsa é -1).    \/\/torna \"Slices.SErviNGSliCes\" pamodi \"SErviNGSliCes\" é kel más fórti di es izenplu     \/\/Nton bu debe     \/\/Pur izénplu, si bu dadu \"Slices\" komu klasi i un lista di     \/\/skodje kel ki sta na primeru lugar na lista.    \/\/Si ten dôs ô más prujétu di stenson ku mésmu forsa, bu debe     \/\/format: ClassName.StrongestExtensionName.  Nomi di skola.    \/\/Bu debe atxa kel más fórti i torna un stringa na kel     \/\/na nómi di kel prujétu, forsa é dadu pa frason CAP - SM.     \/\/létras na nómi di kel extenson, i SM é númeru di létras minúskulus     \/\/forsa di es izenson é sima siginti: dexa CAP ser númeru di majuskulus     \/\/Kes extenson ta uzadu pa karga klasi adisiunal na kel klasi.    \/\/Bu ta dadu nómi di un klasi (un stringa) i un lista di extensons.     \/\/ >>> StrongestExtension((\"my_class\"), (new List<string>(new string[]{(string)\"AA\", (string)\"Be\", (string)\"CC\"})))\n    \/\/ (\"my_class.AA\")\n    public static string StrongestExtension(string class_name, List<string> extensions) {\n","canonical_solution":"public static string StrongestExtension(string class_name, List<string> extensions) {\n        string strongestExtension = null;\n        int maxStrength = int.MinValue;\n\n        foreach (var extension in extensions) {\n            int countUpper = extension.Count(char.IsUpper);\n            int countLower = extension.Count(char.IsLower);\n            int strength = countUpper - countLower;\n\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = extension;\n            }\n        }\n\n        return $\"{class_name}.{strongestExtension}\";\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(StrongestExtension((\"Watashi\"), (new List<string>(new string[]{(string)\"tEN\", (string)\"niNE\", (string)\"eIGHt8OKe\"}))).Equals((\"Watashi.eIGHt8OKe\")));\n    Debug.Assert(StrongestExtension((\"Boku123\"), (new List<string>(new string[]{(string)\"nani\", (string)\"NazeDa\", (string)\"YEs.WeCaNe\", (string)\"32145tggg\"}))).Equals((\"Boku123.YEs.WeCaNe\")));\n    Debug.Assert(StrongestExtension((\"__YESIMHERE\"), (new List<string>(new string[]{(string)\"t\", (string)\"eMptY\", (string)\"nothing\", (string)\"zeR00\", (string)\"NuLl__\", (string)\"123NoooneB321\"}))).Equals((\"__YESIMHERE.NuLl__\")));\n    Debug.Assert(StrongestExtension((\"K\"), (new List<string>(new string[]{(string)\"Ta\", (string)\"TAR\", (string)\"t234An\", (string)\"cosSo\"}))).Equals((\"K.TAR\")));\n    Debug.Assert(StrongestExtension((\"__HAHA\"), (new List<string>(new string[]{(string)\"Tab\", (string)\"123\", (string)\"781345\", (string)\"-_-\"}))).Equals((\"__HAHA.123\")));\n    Debug.Assert(StrongestExtension((\"YameRore\"), (new List<string>(new string[]{(string)\"HhAas\", (string)\"okIWILL123\", (string)\"WorkOut\", (string)\"Fails\", (string)\"-_-\"}))).Equals((\"YameRore.okIWILL123\")));\n    Debug.Assert(StrongestExtension((\"finNNalLLly\"), (new List<string>(new string[]{(string)\"Die\", (string)\"NowW\", (string)\"Wow\", (string)\"WoW\"}))).Equals((\"finNNalLLly.WoW\")));\n    Debug.Assert(StrongestExtension((\"_\"), (new List<string>(new string[]{(string)\"Bb\", (string)\"91245\"}))).Equals((\"_.Bb\")));\n    Debug.Assert(StrongestExtension((\"Sp\"), (new List<string>(new string[]{(string)\"671235\", (string)\"Bb\"}))).Equals((\"Sp.671235\")));\n    }\n\n}\n"},{"task_id":"HumanEval_154","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Bu ta dadu 2 palavra. bu ten ki torna verdadi si kel sugundu palavra ô kualker di se rotasons é un substringa na primeru palavra     \/\/ >>> CycpatternCheck((\"abcd\"), (\"abd\"))\n    \/\/ (false)\n    \/\/ >>> CycpatternCheck((\"hello\"), (\"ell\"))\n    \/\/ (true)\n    \/\/ >>> CycpatternCheck((\"whassup\"), (\"psus\"))\n    \/\/ (false)\n    \/\/ >>> CycpatternCheck((\"abab\"), (\"baa\"))\n    \/\/ (true)\n    \/\/ >>> CycpatternCheck((\"efef\"), (\"eeff\"))\n    \/\/ (false)\n    \/\/ >>> CycpatternCheck((\"himenss\"), (\"simen\"))\n    \/\/ (true)\n    public static bool CycpatternCheck(string a, string b) {\n","canonical_solution":"using System;\n\nclass Problem {\n    public static bool CycpatternCheck(string a, string b) {\n        if (a.Length < b.Length) {\n            return false;\n        }\n\n        string combinedB = b + b;\n        for (int i = 0; i < b.Length; i++) {\n            string rotation = combinedB.Substring(i, b.Length);\n            if (a.Contains(rotation)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(CycpatternCheck((\"xyzw\"), (\"xyw\")) == (false));\n    Debug.Assert(CycpatternCheck((\"yello\"), (\"ell\")) == (true));\n    Debug.Assert(CycpatternCheck((\"whattup\"), (\"ptut\")) == (false));\n    Debug.Assert(CycpatternCheck((\"efef\"), (\"fee\")) == (true));\n    Debug.Assert(CycpatternCheck((\"abab\"), (\"aabb\")) == (false));\n    Debug.Assert(CycpatternCheck((\"winemtt\"), (\"tinem\")) == (true));\n    }\n\n}\n"},{"task_id":"HumanEval_155","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Da un númeru interu. Retorna un tuple ki ten númeru di dígitos par y párus respectivamente.     \/\/ >>> EvenOddCount((-12L))\n    \/\/ (Tuple.Create(1L, 1L))\n    \/\/ >>> EvenOddCount((123L))\n    \/\/ (Tuple.Create(1L, 2L))\n    public static Tuple<long, long> EvenOddCount(long num) {\n","canonical_solution":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\nclass Problem {\n    public static Tuple<long, long> EvenOddCount(long num) {\n        \/\/ Convert the number to positive to handle negative numbers\n        num = Math.Abs(num);\n        long evenCount = 0;\n        long oddCount = 0;\n        \n        while (num > 0) {\n            long digit = num % 10;\n            if (digit % 2 == 0)\n                evenCount++;\n            else\n                oddCount++;\n            num \/= 10;\n        }\n        \n        return Tuple.Create(evenCount, oddCount);\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(EvenOddCount((7L)).Equals((Tuple.Create(0L, 1L))));\n    Debug.Assert(EvenOddCount((-78L)).Equals((Tuple.Create(1L, 1L))));\n    Debug.Assert(EvenOddCount((3452L)).Equals((Tuple.Create(2L, 2L))));\n    Debug.Assert(EvenOddCount((346211L)).Equals((Tuple.Create(3L, 3L))));\n    Debug.Assert(EvenOddCount((-345821L)).Equals((Tuple.Create(3L, 3L))));\n    Debug.Assert(EvenOddCount((-2L)).Equals((Tuple.Create(1L, 0L))));\n    Debug.Assert(EvenOddCount((-45347L)).Equals((Tuple.Create(2L, 3L))));\n    Debug.Assert(EvenOddCount((0L)).Equals((Tuple.Create(1L, 0L))));\n    }\n\n}\n"},{"task_id":"HumanEval_156","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/Restritu: 1 <= númeru <= 1000     \/\/i torna skrebe-l ku létra minúscula.     \/\/Si nu da un númeru interu puzitivu, nu ta atxa se ekivalenti numeral romanu na forma di un númeru,     \/\/ >>> IntToMiniRoman((19L))\n    \/\/ (\"xix\")\n    \/\/ >>> IntToMiniRoman((152L))\n    \/\/ (\"clii\")\n    \/\/ >>> IntToMiniRoman((426L))\n    \/\/ (\"cdxxvi\")\n    public static string IntToMiniRoman(long number) {\n","canonical_solution":"if (number < 1 || number > 1000)\n            throw new ArgumentOutOfRangeException(\"number\", \"Input must be between 1 and 1000\");\n\n        \/\/ Mapping of Roman numerals\n        var romanNumerals = new List<(int value, string numeral)>\n        {\n            (1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n            (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n            (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"),\n            (1, \"i\")\n        };\n\n        var sb = new StringBuilder();\n\n        foreach (var (value, numeral) in romanNumerals)\n        {\n            while (number >= value)\n            {\n                sb.Append(numeral);\n                number -= value;\n            }\n        }\n\n        return sb.ToString();\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(IntToMiniRoman((19L)).Equals((\"xix\")));\n    Debug.Assert(IntToMiniRoman((152L)).Equals((\"clii\")));\n    Debug.Assert(IntToMiniRoman((251L)).Equals((\"ccli\")));\n    Debug.Assert(IntToMiniRoman((426L)).Equals((\"cdxxvi\")));\n    Debug.Assert(IntToMiniRoman((500L)).Equals((\"d\")));\n    Debug.Assert(IntToMiniRoman((1L)).Equals((\"i\")));\n    Debug.Assert(IntToMiniRoman((4L)).Equals((\"iv\")));\n    Debug.Assert(IntToMiniRoman((43L)).Equals((\"xliii\")));\n    Debug.Assert(IntToMiniRoman((90L)).Equals((\"xc\")));\n    Debug.Assert(IntToMiniRoman((94L)).Equals((\"xciv\")));\n    Debug.Assert(IntToMiniRoman((532L)).Equals((\"dxxxii\")));\n    Debug.Assert(IntToMiniRoman((900L)).Equals((\"cm\")));\n    Debug.Assert(IntToMiniRoman((994L)).Equals((\"cmxciv\")));\n    Debug.Assert(IntToMiniRoman((1000L)).Equals((\"m\")));\n    }\n\n}\n"},{"task_id":"HumanEval_157","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/90 grau.     \/\/Un triángulu ku ángulu rectangulu é un triángulu undi un ángulu é ángulu rectangulu ô     \/\/ladu ta forma un triângulu di ángulu retu, otu manera é falsu.    \/\/Retorna verdadi si kes três ladu di un triângulu     \/\/ >>> RightAngleTriangle((3L), (4L), (5L))\n    \/\/ (true)\n    \/\/ >>> RightAngleTriangle((1L), (2L), (3L))\n    \/\/ (false)\n    public static bool RightAngleTriangle(long a, long b, long c) {\n","canonical_solution":"using System;\n\nclass Problem\n{\n    public static bool RightAngleTriangle(long a, long b, long c)\n    {\n        \/\/ Sort the sides to make it easier to apply the Pythagorean theorem.\n        long[] sides = { a, b, c };\n        Array.Sort(sides);\n\n        \/\/ Check if the sum of the squares of the smaller two sides equals the square of the largest side.\n        return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(RightAngleTriangle((3L), (4L), (5L)) == (true));\n    Debug.Assert(RightAngleTriangle((1L), (2L), (3L)) == (false));\n    Debug.Assert(RightAngleTriangle((10L), (6L), (8L)) == (true));\n    Debug.Assert(RightAngleTriangle((2L), (2L), (2L)) == (false));\n    Debug.Assert(RightAngleTriangle((7L), (24L), (25L)) == (true));\n    Debug.Assert(RightAngleTriangle((10L), (5L), (7L)) == (false));\n    Debug.Assert(RightAngleTriangle((5L), (12L), (13L)) == (true));\n    Debug.Assert(RightAngleTriangle((15L), (8L), (17L)) == (true));\n    Debug.Assert(RightAngleTriangle((48L), (55L), (73L)) == (true));\n    Debug.Assert(RightAngleTriangle((1L), (1L), (1L)) == (false));\n    Debug.Assert(RightAngleTriangle((2L), (2L), (10L)) == (false));\n    }\n\n}\n"},{"task_id":"HumanEval_158","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/ta torna kel ki ta ben primeru na ordi leksikografiku.     \/\/Si txeu stringa ten un númeru más altu di karateris úniku     \/\/Kel lista ten más di un palavra.    \/\/Skrebe un funson ki ta aseita un lista di strings.     \/\/ >>> FindMax((new List<string>(new string[]{(string)\"name\", (string)\"of\", (string)\"string\"})))\n    \/\/ (\"string\")\n    \/\/ >>> FindMax((new List<string>(new string[]{(string)\"name\", (string)\"enam\", (string)\"game\"})))\n    \/\/ (\"enam\")\n    \/\/ >>> FindMax((new List<string>(new string[]{(string)\"aaaaaaa\", (string)\"bb\", (string)\"cc\"})))\n    \/\/ (\"aaaaaaa\")\n    public static string FindMax(List<string> words) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Problem\n{\n    public static string FindMax(List<string> words)\n    {\n        string result = string.Empty;\n        int maxUniqueChars = 0;\n\n        foreach (var word in words)\n        {\n            var uniqueChars = word.ToCharArray().Distinct().Count();\n\n            if (uniqueChars > maxUniqueChars || (uniqueChars == maxUniqueChars && string.Compare(word, result, StringComparison.Ordinal) < 0))\n            {\n                maxUniqueChars = uniqueChars;\n                result = word;\n            }\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"name\", (string)\"of\", (string)\"string\"}))).Equals((\"string\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"name\", (string)\"enam\", (string)\"game\"}))).Equals((\"enam\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"aaaaaaa\", (string)\"bb\", (string)\"cc\"}))).Equals((\"aaaaaaa\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"abc\", (string)\"cba\"}))).Equals((\"abc\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"play\", (string)\"this\", (string)\"game\", (string)\"of\", (string)\"footbott\"}))).Equals((\"footbott\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"we\", (string)\"are\", (string)\"gonna\", (string)\"rock\"}))).Equals((\"gonna\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"we\", (string)\"are\", (string)\"a\", (string)\"mad\", (string)\"nation\"}))).Equals((\"nation\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"this\", (string)\"is\", (string)\"a\", (string)\"prrk\"}))).Equals((\"this\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"b\"}))).Equals((\"b\")));\n    Debug.Assert(FindMax((new List<string>(new string[]{(string)\"play\", (string)\"play\", (string)\"play\"}))).Equals((\"play\")));\n    }\n\n}\n"},{"task_id":"HumanEval_159","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplu:     \/\/si ka ten sufisienti karóta ki resta, bu ta kume tudu kes karóta ki resta, má inda bu ta xinti fómi.    \/\/N ta konkorda ku nhos.    \/\/bu debe manda un lista di [ númeru total di karóta ki bu kume dipôs di refeição,     \/\/Má gósi bu meste kume más karóta pa bu pode kumeba tudu dia.    \/\/Bu é un coelho ku fome, y dja bu kume un certo numero di cenouras,     \/\/ >>> Eat((5L), (6L), (10L))\n    \/\/ (new List<long>(new long[]{(long)11L, (long)4L}))\n    \/\/ >>> Eat((4L), (8L), (9L))\n    \/\/ (new List<long>(new long[]{(long)12L, (long)1L}))\n    \/\/ >>> Eat((1L), (10L), (10L))\n    \/\/ (new List<long>(new long[]{(long)11L, (long)0L}))\n    \/\/ >>> Eat((2L), (11L), (5L))\n    \/\/ (new List<long>(new long[]{(long)7L, (long)0L}))\n    \/\/ Variables:\n    \/\/ @number : integer\n    \/\/ the number of carrots that you have eaten.\n    \/\/ @need : integer\n    \/\/ the number of carrots that you need to eat.\n    \/\/ @remaining : integer\n    \/\/ the number of remaining carrots thet exist in stock\n    \/\/ Constrain:\n    \/\/ * 0 <= number <= 1000\n    \/\/ * 0 <= need <= 1000\n    \/\/ * 0 <= remaining <= 1000\n    \/\/ Have fun :)\n    public static List<long> Eat(long number, long need, long remaining) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem {\n    public static List<long> Eat(long number, long need, long remaining) {\n        long totalEaten = number;\n        long leftAfterMeals;\n\n        if(remaining >= need) {\n            totalEaten += need;\n            leftAfterMeals = remaining - need;\n        } else {\n            totalEaten += remaining;\n            leftAfterMeals = 0;\n        }\n        \n        return new List<long>{ totalEaten, leftAfterMeals };\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Eat((5L), (6L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)4L}))));\n    Debug.Assert(Eat((4L), (8L), (9L)).Equals((new List<long>(new long[]{(long)12L, (long)1L}))));\n    Debug.Assert(Eat((1L), (10L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)0L}))));\n    Debug.Assert(Eat((2L), (11L), (5L)).Equals((new List<long>(new long[]{(long)7L, (long)0L}))));\n    Debug.Assert(Eat((4L), (5L), (7L)).Equals((new List<long>(new long[]{(long)9L, (long)2L}))));\n    Debug.Assert(Eat((4L), (5L), (1L)).Equals((new List<long>(new long[]{(long)5L, (long)0L}))));\n    }\n\n}\n"},{"task_id":"HumanEval_160","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Lista di operador ten pelu menus un operador, y lista di operandu ten pelu menus dôs operandu.     \/\/Operandu é un lista di númeru interu ki é ka negativu.    \/\/Léta di lista di operador é igual a lonji di lista di operandu mínus un.     \/\/Nota:     \/\/=> rezultadu = 9     \/\/rezultadu = 2 + 3 * 4 - 5     \/\/lista = [2, 3, 4, 5]     \/\/operador['+', '*', '-']     \/\/Izénplu:     \/\/Exponentiason (**)     \/\/Divididu pa andar ( \/\/ )     \/\/Multiplikason (*)     \/\/Subtraison ( - )     \/\/Adison (+)     \/\/Operason di algébra báziku:     \/\/N ta uza es palavra pa fla ma N ta uza es palavra pa fla ma N ta uza kel palavra la.    \/\/Kel sugundu lista é un lista di númeru interu. Uza kes dôs lista ki nu da pa konstrui kel áljibri     \/\/Dadu dôs lista di operador, y operandu. Primeru lista ten operason di algébra báziku, y     public static long DoAlgebra(List<string> op, List<long> operand) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    public static long DoAlgebra(List<string> op, List<long> operand)\n    {\n        if (op.Count + 1 != operand.Count || operand.Count < 2)\n        {\n            throw new ArgumentException(\"Invalid input lists.\");\n        }\n\n        long result = operand[0];\n\n        for (int i = 0; i < op.Count; i++)\n        {\n            string currentOp = op[i];\n            long currentOperand = operand[i + 1];\n\n            switch (currentOp)\n            {\n                case \"+\":\n                    result += currentOperand;\n                    break;\n                case \"-\":\n                    result -= currentOperand;\n                    break;\n                case \"*\":\n                    result *= currentOperand;\n                    break;\n                case \"\/\/\":\n                    result \/= currentOperand;\n                    break;\n                case \"**\":\n                    result = (long)Math.Pow(result, currentOperand);\n                    break;\n                default:\n                    throw new InvalidOperationException($\"Unsupported operator: {currentOp}\");\n            }\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)\"**\", (string)\"*\", (string)\"+\"})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (37L));\n    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)\"+\", (string)\"*\", (string)\"-\"})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (9L));\n    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)\"\/\/\", (string)\"*\"})), (new List<long>(new long[]{(long)7L, (long)3L, (long)4L}))) == (8L));\n    }\n\n}\n"},{"task_id":"HumanEval_161","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Izénplus     \/\/Kel funson debe da stringa ki nu atxa.    \/\/Si stringa ka ten ninhun létra, inverta kel stringa.    \/\/Má si ka é si, ka ta fazedu nada.    \/\/si s[i] é un létra, inverti se kazu di baxu pa riba ô vice-versa,     \/\/Bu ta dadu un stringa di palavra.    \/\/ >>> Solve((\"1234\"))\n    \/\/ (\"4321\")\n    \/\/ >>> Solve((\"ab\"))\n    \/\/ (\"AB\")\n    \/\/ >>> Solve((\"#a@C\"))\n    \/\/ (\"#A@c\")\n    public static string Solve(string s) {\n","canonical_solution":"public static string Solve(string s) {\n        bool hasLetter = s.Any(char.IsLetter);\n        if (hasLetter) {\n            var result = new StringBuilder(s.Length);\n            foreach (char c in s) {\n                if (char.IsLetter(c)) {\n                    result.Append(char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c));\n                } else {\n                    result.Append(c);\n                }\n            }\n            return result.ToString();\n        } else {\n            char[] charArray = s.ToCharArray();\n            Array.Reverse(charArray);\n            return new string(charArray);\n        }\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(Solve((\"AsDf\")).Equals((\"aSdF\")));\n    Debug.Assert(Solve((\"1234\")).Equals((\"4321\")));\n    Debug.Assert(Solve((\"ab\")).Equals((\"AB\")));\n    Debug.Assert(Solve((\"#a@C\")).Equals((\"#A@c\")));\n    Debug.Assert(Solve((\"#AsdfW^45\")).Equals((\"#aSDFw^45\")));\n    Debug.Assert(Solve((\"#6@2\")).Equals((\"2@6#\")));\n    Debug.Assert(Solve((\"#$a^D\")).Equals((\"#$A^d\")));\n    Debug.Assert(Solve((\"#ccc\")).Equals((\"#CCC\")));\n    }\n\n}\n"},{"task_id":"HumanEval_162","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Si 'text' é un stringa vaziu, torna null.     \/\/Si nu da un stringa 'text', torna se stringa ekivalenti di hash md5.     \/\/ >>> StringToMd5((\"Hello world\"))\n    \/\/ (\"3e25960a79dbc69b674cd4ec67a72c62\")\n    public static string StringToMd5(string text) {\n","canonical_solution":"using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nclass Problem {\n    public static string StringToMd5(string text) {\n        if (string.IsNullOrEmpty(text)) {\n            return null;\n        }\n        \n        using (MD5 md5 = MD5.Create()) {\n            byte[] inputBytes = Encoding.UTF8.GetBytes(text);\n            byte[] hashBytes = md5.ComputeHash(inputBytes);\n            \n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < hashBytes.Length; i++) {\n                sb.Append(hashBytes[i].ToString(\"x2\"));\n            }\n            return sb.ToString();\n        }\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(StringToMd5((\"Hello world\")).Equals((\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    Debug.Assert(StringToMd5((\"\")).Equals(null));\n    Debug.Assert(StringToMd5((\"A B C\")).Equals((\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    Debug.Assert(StringToMd5((\"password\")).Equals((\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n    }\n\n}\n"},{"task_id":"HumanEval_163","nl":"kea_Latn","pl":"cs","prompt":"using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    \/\/Pur izénplu:     \/\/i b, na ordi di kresimentu.     \/\/Si nu da dôs númeru interu puzitivu a i b, torna mostra kes dígitu par di a     \/\/ >>> GenerateIntegers((2L), (8L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))\n    \/\/ >>> GenerateIntegers((8L), (2L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))\n    \/\/ >>> GenerateIntegers((10L), (14L))\n    \/\/ (new List<long>())\n    public static List<long> GenerateIntegers(long a, long b) {\n","canonical_solution":"using System;\nusing System.Collections.Generic;\n\nclass Problem\n{\n    \/\/ Given two positive integers a and b, return the even digits between a\n    \/\/ and b, in ascending order.\n    \/\/ For example:\n    \/\/ >>> GenerateIntegers((2L), (8L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))\n    \/\/ >>> GenerateIntegers((8L), (2L))\n    \/\/ (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))\n    \/\/ >>> GenerateIntegers((10L), (14L))\n    \/\/ (new List<long>())\n    \n    public static List<long> GenerateIntegers(long a, long b)\n    {\n        List<long> evenDigits = new List<long> { 2, 4, 6, 8 };\n        List<long> result = new List<long>();\n\n        if (a > b)\n        {\n            \/\/ Swap values if a is greater than b to ensure ascending order\n            long temp = a;\n            a = b;\n            b = temp;\n        }\n\n        foreach (var even in evenDigits)\n        {\n            if (even >= a && even <= b)\n            {\n                result.Add(even);\n            }\n        }\n\n        return result;\n    }\n}","tests":"    }\n    public static void Main(string[] args) {\n    Debug.Assert(GenerateIntegers((2L), (10L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));\n    Debug.Assert(GenerateIntegers((10L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));\n    Debug.Assert(GenerateIntegers((132L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));\n    Debug.Assert(GenerateIntegers((17L), (89L)).Equals((new List<long>())));\n    }\n\n}\n"}]