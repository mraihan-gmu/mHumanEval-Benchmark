[{"task_id":"HumanEval_0","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ ambang sing diwenehake. \/\/\/ Priksa manawa ing vektor nomer sing diwenehake, ana rong nomer sing luwih cedhak tinimbang \/\/\/ >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n\/\/\/ false\n\/\/\/ >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\/\/\/ true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n","canonical_solution":"fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"},{"task_id":"HumanEval_1","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Ora digatèkaké spasi ing string input. \/\/\/ Kelompok kapisah seimbang (saben brace mbukak ditutup kanthi bener) lan ora nested ing siji liyane \/\/\/ misahake kelompok kasebut dadi senar sing kapisah lan bali vektor kasebut. \/\/\/ Input kanggo fungsi iki senar ngemot macem-macem kelompok kurung nested. goal Panjenengan kanggo \/\/\/ >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n\/\/\/ vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n","canonical_solution":"fn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut current_group = String::new();\n    let mut open_count = 0;\n\n    for char in paren_string.chars() {\n        if char == '(' {\n            open_count += 1;\n            current_group.push(char);\n        } else if char == ')' {\n            open_count -= 1;\n            current_group.push(char);\n        }\n\n        if open_count == 0 && !current_group.is_empty() {\n            groups.push(current_group.clone());\n            current_group.clear();\n        }\n    }\n\n    groups\n}","tests":"}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n"},{"task_id":"HumanEval_2","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Nguripake bagean desimal saka nomer. \/\/\/ (bagean sisa tansah luwih cilik tinimbang 1). \/\/\/ lan bagean saka wilangan bulat (jumlah bulat paling gedhe sing luwih cilik tinimbang nomer sing diwenehake) lan desimal \/\/\/ Given a nomer positif floating point, iku bisa decomposed menyang \/\/\/ >>> truncate_number(3.5)\n\/\/\/ 0.5\nfn truncate_number(number: f64) -> f64 {\n","canonical_solution":"fn truncate_number(number: f64) -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    println!(\"{}\", truncate_number(3.5)); \/\/ 0.5\n}","tests":"}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"},{"task_id":"HumanEval_3","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ ing titik fungsi kudu bali bener. Yen ora, kudu bali palsu. \/\/\/ imbangan nul. tugas Panjenengan kanggo ndeteksi yen ing sembarang titik imbangan akun Falls ngisor nul, lan \/\/\/ Sampeyan diwenehi vektor saka simpenan lan penarikan operasi ing akun bank sing diwiwiti karo \/\/\/ >>> below_zero(vec![1, 2, 3])\n\/\/\/ false\n\/\/\/ >>> below_zero(vec![1, 2, -4, 5])\n\/\/\/ true\nfn below_zero(operations: Vec<isize>) -> bool {\n","canonical_solution":"fn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations {\n        balance += operation;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", below_zero(vec![1, 2, 3])); \/\/ false\n    println!(\"{}\", below_zero(vec![1, 2, -4, 5])); \/\/ true\n    println!(\"{}\", below_zero(vec![1, -1, -1, 2])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n"},{"task_id":"HumanEval_4","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ MAD = rata-rata ∙ x - x_mean ∙\/\/\/ unsur lan titik tengah (rata-rata ing kasus iki): \/\/\/ Rata-rata Absolute Deviation punika rata-rata beda Absolute antarane saben \/\/\/ ing sekitar rata-rata dataset iki. \/\/\/ Kanggo vektor nomer input sing diwenehake, ngitung Deviasi Absolute Rata-rata \/\/\/ >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n\/\/\/ 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n","canonical_solution":"fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    let n = numbers.len() as f64;\n    if n == 0.0 {\n        return 0.0;\n    }\n\n    let mean: f64 = numbers.iter().sum::<f64>() \/ n;\n    let mad: f64 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f64>() \/ n;\n    \n    mad\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0];\n    println!(\"{}\", mean_absolute_deviation(numbers)); \/\/ Output: 1.0\n}","tests":"}\n\nfn main() {\n    let candidate = mean_absolute_deviation;\n    assert_eq!(candidate(vec![1.0, 2.0]), 0.5);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0]), 1.0);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), 1.2);\n}\n"},{"task_id":"HumanEval_5","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Lebokake nomer 'delimeter' ing antarane saben rong elemen berturut-turut vektor input ∀numbers' \/\/\/ >>> intersperse(vec![], 4)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> intersperse(vec![1, 2, 3], 4)\n\/\/\/ vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n","canonical_solution":"fn intersperse(numbers: Vec<isize>, delimiter: isize) -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n    }\n    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n    for (i, &num) in numbers.iter().enumerate() {\n        result.push(num);\n        if i != numbers.len() - 1 {\n            result.push(delimiter);\n        }\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", intersperse(vec![], 4)); \/\/ Output: Vec::<isize>::new()\n    println!(\"{:?}\", intersperse(vec![1, 2, 3], 4)); \/\/ Output: vec![1, 4, 2, 4, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"},{"task_id":"HumanEval_6","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contone (() (()) duwe maksimal rong level nyarang nalika ((())) duwe telu. \/\/\/ Kanggo saben klompok, output tingkat paling jero saka panyimpenan kurung. \/\/\/ Input kanggo fungsi iki minangka senar sing makili pirang-pirang klompok kanggo kurung sing disarang kanthi spasi. \/\/\/ >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n\/\/\/ vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    paren_string.split_whitespace().map(|group| {\n        let mut max_depth = 0;\n        let mut current_depth = 0;\n        for char in group.chars() {\n            match char {\n                '(' => {\n                    current_depth += 1;\n                    if current_depth > max_depth {\n                        max_depth = current_depth;\n                    }\n                },\n                ')' => {\n                    current_depth -= 1;\n                },\n                _ => {}\n            }\n        }\n        max_depth\n    }).collect()\n}\n\nfn main() {\n    let result = parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"));\n    println!(\"{:?}\", result); \/\/ Output: [2, 3, 1, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n"},{"task_id":"HumanEval_7","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Filter vektor input string mung kanggo sing ngemot substring diwenehi \/\/\/ >>> filter_by_substring(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.into_iter().filter(|s| s.contains(&substring)).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\")), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"},{"task_id":"HumanEval_8","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Jumlah kosong kudu padha karo 0 lan produk kosong kudu padha karo 1. \/\/\/ Kanggo vektor wilangan bulat sing diwenehake, baliake tuple sing kalebu jumlah lan produk kabeh wilangan bulat ing vektor. \/\/\/ >>> sum_product(vec![])\n\/\/\/ (0, 1)\n\/\/\/ >>> sum_product(vec![1, 2, 3, 4])\n\/\/\/ (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n","canonical_solution":"fn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n}\n\nfn main() {\n    println!(\"{:?}\", sum_product(vec![])); \/\/ (0, 1)\n    println!(\"{:?}\", sum_product(vec![1, 2, 3, 4])); \/\/ (10, 24)\n}","tests":"}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"},{"task_id":"HumanEval_9","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ ing urutan. \/\/\/ Saka vektor integer sing diwenehake, ngasilake vektor elemen maksimum gulung sing ditemokake nganti wayahe tartamtu \/\/\/ >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n\/\/\/ vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max = isize::MIN;\n    for &num in &numbers {\n        if num > current_max {\n            current_max = num;\n        }\n        result.push(current_max);\n    }\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"},{"task_id":"HumanEval_10","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ - Tambahake ing pungkasan string reverse saka prefiks string sing teka sadurunge sufiks palindromik. \/\/\/ - Temokake postfix paling dawa saka string sing diwenehake sing dadi palindrome. \/\/\/ Gagasan algoritma punika prasaja: \/\/\/ Temokake palindrom paling cendhak sing diwiwiti karo string sing diwenehake. \/\/\/ >>> make_palindrome(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> make_palindrome(String::from(\"cat\"))\n\/\/\/ String::from(\"catac\")\n\/\/\/ >>> make_palindrome(String::from(\"cata\"))\n\/\/\/ String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n","canonical_solution":"fn make_palindrome(string: String) -> String {\n    fn is_palindrome(s: &str) -> bool {\n        s.chars().eq(s.chars().rev())\n    }\n\n    if string.is_empty() || is_palindrome(&string) {\n        return string;\n    }\n\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..]) {\n            let prefix = &string[..i];\n            let reversed_prefix: String = prefix.chars().rev().collect();\n            return string + &reversed_prefix;\n        }\n    }\n\n    string\n}\n\nfn main() {\n    println!(\"{:?}\", make_palindrome(String::from(\"\"))); \/\/ String::from(\"\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cat\"))); \/\/ String::from(\"catac\")\n    println!(\"{:?}\", make_palindrome(String::from(\"cata\"))); \/\/ String::from(\"catac\")\n}","tests":"}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n}\n"},{"task_id":"HumanEval_11","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Nindakake XOR binar ing input kasebut lan ngasilake asil uga minangka senar. \/\/\/ Input punika kalih senar a lan b dumadi mung saka 1s lan 0s. \/\/\/ >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n\/\/\/ String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n","canonical_solution":"fn string_xor(a: String, b: String) -> String {\n    a.chars()\n     .zip(b.chars())\n     .map(|(char_a, char_b)| if char_a == char_b { '0' } else { '1' })\n     .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"},{"task_id":"HumanEval_12","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ strings of the same length. Return None in case the input vector is empty. \/\/\/ Saka vektor strings, bali sing paling dawa. Bali sing pisanan ing cilik saka kaping \/\/\/ >>> longest(vec![])\n\/\/\/ None\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ Some(String::from(\"a\"))\n\/\/\/ >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\/\/\/ Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n","canonical_solution":"fn longest(strings: Vec<String>) -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len())\n}","tests":"}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"},{"task_id":"HumanEval_13","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Mbalekake pembagi umum paling gedhe saka rong wilangan bulat a lan b \/\/\/ >>> greatest_common_divisor(3, 5)\n\/\/\/ 1\n\/\/\/ >>> greatest_common_divisor(25, 15)\n\/\/\/ 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n","canonical_solution":"fn greatest_common_divisor(mut a: isize, mut b: isize) -> isize {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}","tests":"}\n\nfn main() {\n    let candidate = greatest_common_divisor;\n    assert_eq!(candidate(3, 7), 1);\n    assert_eq!(candidate(10, 15), 5);\n    assert_eq!(candidate(49, 14), 7);\n    assert_eq!(candidate(144, 60), 12);\n}\n"},{"task_id":"HumanEval_14","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Vektor bali kabeh awalan saka paling cendhak nganti paling dawa saka string input \/\/\/ >>> all_prefixes(String::from(\"abc\"))\n\/\/\/ vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n","canonical_solution":"fn all_prefixes(string: String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 1..=string.len() {\n        prefixes.push(string[..i].to_string());\n    }\n    prefixes\n}\n\n\/\/ Example usage\nfn main() {\n    let prefixes = all_prefixes(String::from(\"abc\"));\n    println!(\"{:?}\", prefixes);\n}","tests":"}\n\nfn main() {\n    let candidate = all_prefixes;\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"asdfgh\")), vec![String::from(\"a\"), String::from(\"as\"), String::from(\"asd\"), String::from(\"asdf\"), String::from(\"asdfg\"), String::from(\"asdfgh\")]);\n    assert_eq!(candidate(String::from(\"WWW\")), vec![String::from(\"W\"), String::from(\"WW\"), String::from(\"WWW\")]);\n}\n"},{"task_id":"HumanEval_15","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali string ngemot nomer spasi-delimited miwiti saka 0 nganti n klebu. \/\/\/ >>> string_sequence(0)\n\/\/\/ String::from(\"0\")\n\/\/\/ >>> string_sequence(5)\n\/\/\/ String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n","canonical_solution":"fn string_sequence(n: isize) -> String {\n    (0..=n).map(|num| num.to_string()).collect::<Vec<String>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = string_sequence;\n    assert_eq!(candidate(0), String::from(\"0\"));\n    assert_eq!(candidate(3), String::from(\"0 1 2 3\"));\n    assert_eq!(candidate(10), String::from(\"0 1 2 3 4 5 6 7 8 9 10\"));\n}\n"},{"task_id":"HumanEval_16","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Given a string, mangerteni carane akeh karakter béda (preduli saka cilik) iku dumadi saka \/\/\/ >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n\/\/\/ 3\n\/\/\/ >>> count_distinct_characters(String::from(\"Jerry\"))\n\/\/\/ 4\nfn count_distinct_characters(string: String) -> isize {\n","canonical_solution":"use std::collections::HashSet;\n\nfn count_distinct_characters(string: String) -> isize {\n    let lowercase_string = string.to_lowercase();\n    let distinct_chars: HashSet<char> = lowercase_string.chars().collect();\n    distinct_chars.len() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_distinct_characters;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abcde\")), 5);\n    assert_eq!(candidate(String::from(\"abcdecadeCADE\")), 5);\n    assert_eq!(candidate(String::from(\"aaaaAAAAaaaa\")), 1);\n    assert_eq!(candidate(String::from(\"Jerry jERRY JeRRRY\")), 5);\n}\n"},{"task_id":"HumanEval_17","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ '. Saji' - quater note, lasts one beat \/\/\/ 'o \" s \" - setengah cathetan, suwene rong ketukan \/\/\/ 'o' - kabèh cathetan, tahan patang ketukan \/\/\/ Ing kéné ana legenda: \/\/\/ ora pungkasan. \/\/\/ Tugas sampeyan yaiku kanggo parse senar iki lan ngasilake vektor saka wilangan bulat sing cocog karo pirang-pirang ketukan saben \/\/\/ Input kanggo fungsi iki yaiku senar sing makili cathetan musik ing format ASCII khusus. \/\/\/ >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n\/\/\/ vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n","canonical_solution":"fn parse_music(music_string: String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let notes: Vec<&str> = music_string.split_whitespace().collect();\n\n    for note in notes {\n        match note {\n            \"o\" => result.push(4),\n            \"o|\" => result.push(2),\n            \".|\" => result.push(1),\n            _ => (),\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let music_string = String::from(\"o o| .| o| o| .| .| .| .| o o\");\n    let beats = parse_music(music_string);\n    println!(\"{:?}\", beats); \/\/ Outputs: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"},{"task_id":"HumanEval_18","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Temokake kaping pirang-pirang substring sing bisa ditemokake ing senar asli. Ngetung kasus sing tumpang tindih. \/\/\/ >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n\/\/\/ 0\n\/\/\/ >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n\/\/\/ 3\n\/\/\/ >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n\/\/\/ 3\nfn how_many_times(string: String, substring: String) -> isize {\n","canonical_solution":"fn how_many_times(string: String, substring: String) -> isize {\n    if substring.is_empty() || string.is_empty() {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut position = 0;\n\n    while let Some(pos) = string[position..].find(&substring) {\n        count += 1;\n        position += pos + 1; \/\/ Move to the start of the next potential substring\n    }\n\n    count\n}\n\nfn main() {\n    println!(\"{}\", how_many_times(String::from(\"\"), String::from(\"a\"))); \/\/ 0\n    println!(\"{}\", how_many_times(String::from(\"aaa\"), String::from(\"a\"))); \/\/ 3\n    println!(\"{}\", how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))); \/\/ 3\n}","tests":"}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n"},{"task_id":"HumanEval_19","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Nguripake string kanthi nomer sing diurutake saka paling cilik nganti paling gedhe \/\/\/ Pilihan sing bener yaiku 'nol', 'siji', 'rong', 'telung', 'papat', 'lima', 'enem', 'pitu', 'wolung' lan 'sembilan'. \/\/\/ Input punika string spasi-delimited saka numerals saka 'nol' kanggo 'sembilan'. \/\/\/ >>> sort_numbers(String::from(\"three one five\"))\n\/\/\/ String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n","canonical_solution":"fn sort_numbers(numbers: String) -> String {\n    let word_to_number = |word: &str| -> u32 {\n        match word {\n            \"zero\" => 0,\n            \"one\" => 1,\n            \"two\" => 2,\n            \"three\" => 3,\n            \"four\" => 4,\n            \"five\" => 5,\n            \"six\" => 6,\n            \"seven\" => 7,\n            \"eight\" => 8,\n            \"nine\" => 9,\n            _ => panic!(\"Invalid input\"),\n        }\n    };\n\n    let words: Vec<&str> = numbers.split_whitespace().collect();\n    let mut number_words: Vec<(&str, u32)> = words.iter().map(|&w| (w, word_to_number(w))).collect();\n\n    number_words.sort_by_key(|&(_, number)| number);\n\n    number_words.iter().map(|&(word, _)| word).collect::<Vec<&str>>().join(\" \")\n}","tests":"}\n\nfn main() {\n    let candidate = sort_numbers;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"three\")), String::from(\"three\"));\n    assert_eq!(candidate(String::from(\"three five nine\")), String::from(\"three five nine\"));\n    assert_eq!(candidate(String::from(\"five zero four seven nine eight\")), String::from(\"zero four five seven eight nine\"));\n    assert_eq!(candidate(String::from(\"six five four three two one zero\")), String::from(\"zero one two three four five six\"));\n}\n"},{"task_id":"HumanEval_20","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ liyane lan bali kanthi urutan (jumlah sing luwih cilik, jumlah sing luwih gedhe).\/\/\/ Saka vektor nomer sing diwenehake (dawane paling ora rong) pilih lan bali loro sing paling cedhak karo saben \/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\/\/\/ (2.0, 2.2)\n\/\/\/ >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\/\/\/ (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n","canonical_solution":"fn find_closest_elements(mut numbers: Vec<f64>) -> (f64, f64) {\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::INFINITY;\n    let mut result = (0.0, 0.0);\n\n    for i in 0..(numbers.len() - 1) {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff {\n            min_diff = diff;\n            result = (numbers[i], numbers[i + 1]);\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    \/\/ Example usage\n    let vec1 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2];\n    let res1 = find_closest_elements(vec1);\n    println!(\"{:?}\", res1); \/\/ (2.0, 2.2)\n\n    let vec2 = vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0];\n    let res2 = find_closest_elements(vec2);\n    println!(\"{:?}\", res2); \/\/ (2.0, 2.0)\n}","tests":"}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"},{"task_id":"HumanEval_21","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ saéngga nomer paling cilik bakal dadi 0 lan nomer paling gedhe bakal dadi 1 \/\/\/ Given vektor nomer (paling ora rong unsur), aplikasi linear transformasi kanggo vektor kasebut, \/\/\/ >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n\/\/\/ vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n","canonical_solution":"fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let min_value = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max_value = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\n    numbers.into_iter().map(|x| (x - min_value) \/ (max_value - min_value)).collect()\n}\n\nfn main() {\n    let numbers = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let rescaled = rescale_to_unit(numbers);\n    println!(\"{:?}\", rescaled);\n}","tests":"}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"},{"task_id":"HumanEval_23","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Length bali saka string diwenehi \/\/\/ >>> strlen(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> strlen(String::from(\"abc\"))\n\/\/\/ 3\nfn strlen(string: String) -> isize {\n","canonical_solution":"fn strlen(string: String) -> isize {\n    string.chars().count() as isize\n}\n\nfn main() {\n    println!(\"{}\", strlen(String::from(\"\"))); \/\/ Output: 0\n    println!(\"{}\", strlen(String::from(\"abc\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = strlen;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"x\")), 1);\n    assert_eq!(candidate(String::from(\"asdasnakj\")), 9);\n}\n"},{"task_id":"HumanEval_24","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Kanggo nomer tartamtu n, golek nomer paling gedhé sing dibagi n merata, luwih cilik saka n \/\/\/ >>> largest_divisor(15)\n\/\/\/ 5\nfn largest_divisor(n: isize) -> isize {\n","canonical_solution":"fn largest_divisor(n: isize) -> isize {\n    for i in (1..n).rev() {\n        if n % i == 0 {\n            return i;\n        }\n    }\n    1 \/\/ If no other divisor is found, return 1\n}\n\nfn main() {\n    println!(\"{}\", largest_divisor(15)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = largest_divisor;\n    assert_eq!(candidate(3), 1);\n    assert_eq!(candidate(7), 1);\n    assert_eq!(candidate(10), 5);\n    assert_eq!(candidate(100), 50);\n    assert_eq!(candidate(49), 7);\n}\n"},{"task_id":"HumanEval_25","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Input nomer kudu padha karo produk saka kabeh faktor \/\/\/ Saben faktor kudu diukur kaping pirang-pirang sing cocog karo kaping pirang-pirang muncul ing faktorisasi. \/\/\/ Vektor bali saka faktor utama saka integer sing diwenehake kanthi urutan saka paling cilik nganti paling gedhe. \/\/\/ >>> factorize(8)\n\/\/\/ vec![2, 2, 2]\n\/\/\/ >>> factorize(25)\n\/\/\/ vec![5, 5]\n\/\/\/ >>> factorize(70)\n\/\/\/ vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n","canonical_solution":"fn factorize(mut n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    while n >= divisor * divisor {\n        while n % divisor == 0 {\n            factors.push(divisor);\n            n \/= divisor;\n        }\n        divisor += 1;\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", factorize(8));  \/\/ Should print: [2, 2, 2]\n    println!(\"{:?}\", factorize(25)); \/\/ Should print: [5, 5]\n    println!(\"{:?}\", factorize(70)); \/\/ Should print: [2, 5, 7]\n}","tests":"}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"},{"task_id":"HumanEval_26","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tansah urutan unsur kiwa padha ing input. \/\/\/ Saka vektor saka wilangan bulat, copot kabeh unsur sing ana luwih saka sepisan. \/\/\/ >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n\/\/\/ vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut occurrences = HashMap::new();\n    \n    \/\/ Count occurrences of each number\n    for &number in &numbers {\n        *occurrences.entry(number).or_insert(0) += 1;\n    }\n\n    \/\/ Filter out numbers that occur more than once\n    numbers.into_iter()\n        .filter(|&number| occurrences[&number] == 1)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_duplicates;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 4, 3, 5]), vec![1, 4, 5]);\n}\n"},{"task_id":"HumanEval_27","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Kanggo string tartamtu, flip karakter cilik kanggo huruf gedhe lan huruf gedhe kanggo huruf cilik. \/\/\/ >>> flip_case(String::from(\"Hello\"))\n\/\/\/ String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n","canonical_solution":"fn flip_case(string: String) -> String {\n    string.chars().map(|c| {\n        if c.is_lowercase() {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")), String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n}\n"},{"task_id":"HumanEval_28","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Concatenate vektor senar menyang senar siji \/\/\/ >>> concatenate(vec![])\n\/\/\/ String::from(\"\")\n\/\/\/ >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n\/\/\/ String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n","canonical_solution":"fn concatenate(strings: Vec<String>) -> String {\n    strings.concat()\n}","tests":"}\n\nfn main() {\n    let candidate = concatenate;\n    assert_eq!(candidate(Vec::<String>::new()), String::from(\"\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\")]), String::from(\"xyz\"));\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"z\"), String::from(\"w\"), String::from(\"k\")]), String::from(\"xyzwk\"));\n}\n"},{"task_id":"HumanEval_29","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Filter vektor input string mung kanggo sing miwiti karo awalan tartamtu. \/\/\/ >>> filter_by_prefix(vec![], String::from(\"a\"))\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n\/\/\/ vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n","canonical_solution":"fn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = filter_by_prefix;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n}\n"},{"task_id":"HumanEval_30","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Mung ngasilake nomer positif ing vektor. \/\/\/ >>> get_positive(vec![-1, 2, -4, 5, 6])\n\/\/\/ vec![2, 5, 6]\n\/\/\/ >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().filter(|&x| x > 0).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = get_positive;\n    assert_eq!(candidate(vec![-1, -2, 4, 5, 6]), vec![4, 5, 6]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]), vec![5, 3, 2, 3, 3, 9, 123, 1]);\n    assert_eq!(candidate(vec![-1, -2]), Vec::<isize>::new());\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_31","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali bener yen nomer diwenehi iku prima, lan palsu digunakake. \/\/\/ >>> is_prime(6)\n\/\/\/ false\n\/\/\/ >>> is_prime(101)\n\/\/\/ true\n\/\/\/ >>> is_prime(11)\n\/\/\/ true\n\/\/\/ >>> is_prime(13441)\n\/\/\/ true\n\/\/\/ >>> is_prime(61)\n\/\/\/ true\n\/\/\/ >>> is_prime(4)\n\/\/\/ false\n\/\/\/ >>> is_prime(1)\n\/\/\/ false\nfn is_prime(n: isize) -> bool {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_prime;\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(101), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(13441), true);\n    assert_eq!(candidate(61), true);\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(1), false);\n    assert_eq!(candidate(5), true);\n    assert_eq!(candidate(11), true);\n    assert_eq!(candidate(17), true);\n    assert_eq!(candidate(85), false);\n    assert_eq!(candidate(77), false);\n    assert_eq!(candidate(255379), false);\n}\n"},{"task_id":"HumanEval_33","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ kanggo nilai indeks sing cocog karo l, nanging diurutake. \/\/\/ l 'padha karo l ing indeks sing ora bisa dibagi telu, dene regane ing indeks sing bisa dibagi telu padha \/\/\/ Fungsi iki njupuk vektor l lan ngasilake vektor l 'kaya \/\/\/ >>> sort_third(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n\/\/\/ vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut divisible_by_three: Vec<(usize, isize)> = l.iter()\n        .enumerate()\n        .filter(|&(i, _)| i % 3 == 0)\n        .map(|(i, &value)| (i, value))\n        .collect();\n\n    \/\/ Sort the values that are at indices divisible by 3\n    divisible_by_three.sort_by_key(|&(_, value)| value);\n\n    let mut result = l.clone();\n    for (sorted_index, (original_index, _)) in divisible_by_three.iter().enumerate() {\n        result[*original_index] = divisible_by_three[sorted_index].1;\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_third;\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2]), vec![2, 6, 3, 4, 8, 9, 5]);\n    assert_eq!(candidate(vec![5, 8, 3, 4, 6, 9, 2]), vec![2, 8, 3, 4, 6, 9, 5]);\n    assert_eq!(candidate(vec![5, 6, 9, 4, 8, 3, 2]), vec![2, 6, 9, 4, 8, 3, 5]);\n    assert_eq!(candidate(vec![5, 6, 3, 4, 8, 9, 2, 1]), vec![2, 6, 3, 4, 8, 9, 5, 1]);\n}\n"},{"task_id":"HumanEval_34","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Nguripake unsur unik sing diurutake ing vektor \/\/\/ >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique(mut l: Vec<isize>) -> Vec<isize> {\n    l.sort_unstable();\n    l.dedup();\n    l\n}\n\nfn main() {\n    let result = unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]);\n    println!(\"{:?}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = unique;\n    assert_eq!(candidate(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]), vec![0, 2, 3, 5, 9, 123]);\n}\n"},{"task_id":"HumanEval_35","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Mbalekake unsur maksimum ing vektor. \/\/\/ >>> max_element(vec![1, 2, 3])\n\/\/\/ 3\n\/\/\/ >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\/\/\/ 123\nfn max_element(l: Vec<isize>) -> isize {\n","canonical_solution":"fn max_element(l: Vec<isize>) -> isize {\n    l.into_iter().max().unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = max_element;\n    assert_eq!(candidate(vec![1, 2, 3]), 3);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]), 124);\n}\n"},{"task_id":"HumanEval_36","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Mbalekake kaping digit 7 katon ing wilangan bulat kurang saka n sing bisa dibagi 11 utawa 13. \/\/\/ >>> fizz_buzz(50)\n\/\/\/ 0\n\/\/\/ >>> fizz_buzz(78)\n\/\/\/ 2\n\/\/\/ >>> fizz_buzz(79)\n\/\/\/ 3\nfn fizz_buzz(n: isize) -> isize {\n","canonical_solution":"fn fizz_buzz(n: isize) -> isize {\n    (0..n)\n        .filter(|&x| x % 11 == 0 || x % 13 == 0)\n        .flat_map(|x| x.to_string().chars())\n        .filter(|&c| c == '7')\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = fizz_buzz;\n    assert_eq!(candidate(50), 0);\n    assert_eq!(candidate(78), 2);\n    assert_eq!(candidate(79), 3);\n    assert_eq!(candidate(100), 3);\n    assert_eq!(candidate(200), 6);\n    assert_eq!(candidate(4000), 192);\n    assert_eq!(candidate(10000), 639);\n    assert_eq!(candidate(100000), 8026);\n}\n"},{"task_id":"HumanEval_37","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ kanggo nilai saka indeks malah saka l, nanging diurutake. \/\/\/ l 'padha karo l ing indeks aneh, dene regane ing indeks malah padha \/\/\/ Fungsi iki njupuk vektor l lan ngasilake vektor l 'kaya \/\/\/ >>> sort_even(vec![1, 2, 3])\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> sort_even(vec![5, 6, 3, 4])\n\/\/\/ vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    \/\/ Collect even indexed elements and sort them\n    let mut even_elements: Vec<isize> = l.iter().enumerate()\n        .filter(|&(i, _)| i % 2 == 0)\n        .map(|(_, &val)| val)\n        .collect();\n    even_elements.sort();\n\n    \/\/ Reconstruct the vector `l'`\n    let mut result = l.clone();\n    let mut even_index = 0;\n\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result[i] = even_elements[even_index];\n            even_index += 1;\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"},{"task_id":"HumanEval_39","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ prime_fib ngasilake nomer nomer Fibonacci sing nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer nomer\/\/\/ >>> prime_fib(1)\n\/\/\/ 2\n\/\/\/ >>> prime_fib(2)\n\/\/\/ 3\n\/\/\/ >>> prime_fib(3)\n\/\/\/ 5\n\/\/\/ >>> prime_fib(4)\n\/\/\/ 13\n\/\/\/ >>> prime_fib(5)\n\/\/\/ 89\nfn prime_fib(n: isize) -> isize {\n","canonical_solution":"fn prime_fib(n: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        if num <= 3 {\n            return true;\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    fn fibonacci() -> impl Iterator<Item = isize> {\n        let mut a: isize = 0;\n        let mut b: isize = 1;\n        std::iter::from_fn(move || {\n            let next = a + b;\n            a = b;\n            b = next;\n            Some(a)\n        })\n    }\n\n    let mut count = 0;\n    for fib_num in fibonacci() {\n        if is_prime(fib_num) {\n            count += 1;\n            if count == n {\n                return fib_num;\n            }\n        }\n    }\n    -1\n}","tests":"}\n\nfn main() {\n    let candidate = prime_fib;\n    assert_eq!(candidate(1), 2);\n    assert_eq!(candidate(2), 3);\n    assert_eq!(candidate(3), 5);\n    assert_eq!(candidate(4), 13);\n    assert_eq!(candidate(5), 89);\n    assert_eq!(candidate(6), 233);\n    assert_eq!(candidate(7), 1597);\n    assert_eq!(candidate(8), 28657);\n    assert_eq!(candidate(9), 514229);\n    assert_eq!(candidate(10), 433494437);\n}\n"},{"task_id":"HumanEval_40","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ total dadi nol, lan palsu. \/\/\/ iku ngasilake bener yen ana telung unsur sing beda ing vektor sing \/\/\/ triples_sum_to_zero njupuk vektor saka wilangan bulat minangka input. \/\/\/ >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\/\/\/ true\n\/\/\/ >>> triples_sum_to_zero(vec![1])\n\/\/\/ false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    let n = l.len();\n    if n < 3 {\n        return false;\n    }\n\n    let mut sorted_l = l.clone();\n    sorted_l.sort();\n\n    for i in 0..n-2 {\n        let a = sorted_l[i];\n        let mut left = i + 1;\n        let mut right = n - 1;\n\n        while left < right {\n            let sum = a + sorted_l[left] + sorted_l[right];\n            if sum == 0 {\n                return true;\n            } else if sum < 0 {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n    }\n\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n}\n"},{"task_id":"HumanEval_41","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Fungsi iki ngasilake jumlah tabrakan kasebut. \/\/\/ ing lintasan kaya-kaya ora tabrakan. \/\/\/ Nanging, mobil-mobil kasebut kuwat banget lan kuwat; minangka asil, dheweke terus maju \/\/\/ nalika mobil sing obah kiwa menyang tengen nabrak mobil sing obah tengen menyang kiwa. \/\/\/ saben liyane. Kabeh mobil pindhah ing kacepetan padha. Loro mobil sing ngandika kanggo tabrakan \/\/\/ lagi nyopir tengen kiwa. loro pasang mobil miwiti kang adoh banget saka \/\/\/ n mobil sing nyopir kiwa nengen; bebarengan, set beda saka n mobil \/\/\/ Bayangake dalan sing lurus banget garis dawa tanpa wates. fn car_race_collision(n: isize) -> isize {\n","canonical_solution":"fn car_race_collision(n: isize) -> isize {\n    \/\/ Since every car moving left to right will collide exactly once\n    \/\/ with every car moving right to left, the number of collisions is n * n\n    n * n\n}\n\nfn main() {\n    let n = 5;\n    println!(\"Number of collisions: {}\", car_race_collision(n));\n}","tests":"}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"},{"task_id":"HumanEval_42","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Vektor bali kanthi unsur sing ditambah 1. \/\/\/ >>> incr_list(vec![1, 2, 3])\n\/\/\/ vec![2, 3, 4]\n\/\/\/ >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n\/\/\/ vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|&x| x + 1).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = incr_list;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![3, 2, 1]), vec![4, 3, 2]);\n    assert_eq!(candidate(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]), vec![6, 3, 6, 3, 4, 4, 10, 1, 124]);\n}\n"},{"task_id":"HumanEval_43","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ total dadi nol, lan palsu. \/\/\/ iku ngasilake bener yen ana rong unsur sing beda ing vektor sing \/\/\/ pairs_sum_to_zero njupuk vektor saka wilangan bulat minangka input. \/\/\/ >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n\/\/\/ false\n\/\/\/ >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n\/\/\/ true\n\/\/\/ >>> pairs_sum_to_zero(vec![1])\n\/\/\/ false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n","canonical_solution":"fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    use std::collections::HashSet;\n    let mut seen = HashSet::new();\n    \n    for &num in &l {\n        if seen.contains(&-num) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, 5, 0])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 3, -2, 1])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![1, 2, 3, 7])); \/\/ false\n    println!(\"{}\", pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])); \/\/ true\n    println!(\"{}\", pairs_sum_to_zero(vec![1])); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n"},{"task_id":"HumanEval_44","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ nomer basa kurang saka 10. \/\/\/ ngasilake representasi senar sawise konversi. \/\/\/ Ganti basa angka saka input nomer x kanggo basa. \/\/\/ >>> change_base(8, 3)\n\/\/\/ String::from(\"22\")\n\/\/\/ >>> change_base(8, 2)\n\/\/\/ String::from(\"1000\")\n\/\/\/ >>> change_base(7, 2)\n\/\/\/ String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n","canonical_solution":"fn change_base(x: isize, base: isize) -> String {\n    if base < 2 || base > 9 {\n        panic!(\"Base must be between 2 and 9\");\n    }\n    \n    if x == 0 {\n        return String::from(\"0\");\n    }\n    \n    let mut result = String::new();\n    let mut number = x;\n    \n    while number > 0 {\n        let remainder = number % base;\n        result.push_str(&remainder.to_string());\n        number \/= base;\n    }\n    \n    result.chars().rev().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"},{"task_id":"HumanEval_45","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Given dawa saka sisih lan dhuwur bali area kanggo segitiga. \/\/\/ >>> triangle_area(5, 3)\n\/\/\/ 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, h: isize) -> f64 {\n    (a as f64 * h as f64) \/ 2.0\n}\n\nfn main() {\n    let area = triangle_area(5, 3);\n    println!(\"{}\", area);\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5, 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10, 8), 40.0);\n}\n"},{"task_id":"HumanEval_46","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tulis fungsi kanggo kanthi efisien ngetung unsur n-th saka urutan nomer fib4. Aja nggunakake rekursi. \/\/\/ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). \/\/\/ fib4(3) -> 0 \/\/\/ fib4(2) -> 2 \/\/\/ fib4(1) -> 0 \/\/\/ fib4(0) -> 0 \/\/\/ Urutan angka Fib4 iku sawijining urutan sing mèmper karo urutan Fibbonacci sing ditetepaké kaya mangkéné: \/\/\/ >>> fib4(5)\n\/\/\/ 4\n\/\/\/ >>> fib4(6)\n\/\/\/ 8\n\/\/\/ >>> fib4(7)\n\/\/\/ 14\nfn fib4(n: isize) -> isize {\n","canonical_solution":"fn fib4(n: isize) -> isize {\n    if n < 0 {\n        return 0; \/\/ Define behavior for negative input\n    }\n\n    let mut sequence = vec![0, 0, 2, 0];\n\n    if n < 4 {\n        return sequence[n as usize];\n    }\n\n    for i in 4..=n {\n        let next_value = sequence[(i - 1) as usize] \n                       + sequence[(i - 2) as usize] \n                       + sequence[(i - 3) as usize] \n                       + sequence[(i - 4) as usize];\n        sequence.push(next_value);\n    }\n\n    sequence[n as usize]\n}\n\nfn main() {\n    println!(\"{}\", fib4(5)); \/\/ 4\n    println!(\"{}\", fib4(6)); \/\/ 8\n    println!(\"{}\", fib4(7)); \/\/ 14\n}","tests":"}\n\nfn main() {\n    let candidate = fib4;\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 28);\n    assert_eq!(candidate(10), 104);\n    assert_eq!(candidate(12), 386);\n}\n"},{"task_id":"HumanEval_47","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali median unsur ing vektor l. \/\/\/ >>> median(vec![3, 1, 2, 4, 5])\n\/\/\/ 3.0\n\/\/\/ >>> median(vec![-10, 4, 6, 1000, 10, 20])\n\/\/\/ 15.0\nfn median(l: Vec<isize>) -> f64 {\n","canonical_solution":"fn median(l: Vec<isize>) -> f64 {\n    let mut l = l.clone();\n    l.sort();\n    let len = l.len();\n\n    if len % 2 == 0 {\n        let mid1 = len \/ 2;\n        let mid2 = mid1 - 1;\n        ((l[mid1] as f64) + (l[mid2] as f64)) \/ 2.0\n    } else {\n        l[len \/ 2] as f64\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]), 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6, 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"},{"task_id":"HumanEval_48","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Priksa manawa string diwenehi minangka palindrome \/\/\/ >>> is_palindrome(String::from(\"\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aba\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"aaaaa\"))\n\/\/\/ true\n\/\/\/ >>> is_palindrome(String::from(\"zbcd\"))\n\/\/\/ false\nfn is_palindrome(text: String) -> bool {\n","canonical_solution":"fn is_palindrome(text: String) -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in 0..len \/ 2 {\n        if chars[i] != chars[len - 1 - i] {\n            return false;\n        }\n    }\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"},{"task_id":"HumanEval_49","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali 2^n modulo p (ngerti angka). \/\/\/ >>> modp(3, 5)\n\/\/\/ 3\n\/\/\/ >>> modp(1101, 101)\n\/\/\/ 2\n\/\/\/ >>> modp(0, 101)\n\/\/\/ 1\n\/\/\/ >>> modp(3, 11)\n\/\/\/ 8\n\/\/\/ >>> modp(100, 101)\n\/\/\/ 1\nfn modp(n: isize, p: isize) -> isize {\n","canonical_solution":"fn modp(n: isize, p: isize) -> isize {\n    if p == 1 {\n        return 0;\n    }\n    let mut result = 1;\n    let mut base = 2 % p;\n    let mut exponent = n;\n    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base) % p;\n        }\n        base = (base * base) % p;\n        exponent \/= 2;\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"},{"task_id":"HumanEval_51","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ remove_vowels iku sawijining fungsi sing njupuk senar lan ngasilake senar tanpa vokal. \/\/\/ >>> remove_vowels(String::from(\"\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"abcdef\"))\n\/\/\/ String::from(\"bcdf\")\n\/\/\/ >>> remove_vowels(String::from(\"aaaaa\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> remove_vowels(String::from(\"aaBAA\"))\n\/\/\/ String::from(\"B\")\n\/\/\/ >>> remove_vowels(String::from(\"zbcd\"))\n\/\/\/ String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n","canonical_solution":"fn remove_vowels(text: String) -> String {\n    text.chars()\n        .filter(|&c| !\"aeiouAEIOU\".contains(c))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = remove_vowels;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"abcdef\nghijklm\")), String::from(\"bcdf\nghjklm\"));\n    assert_eq!(candidate(String::from(\"fedcba\")), String::from(\"fdcb\"));\n    assert_eq!(candidate(String::from(\"eeeee\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"acBAA\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"EcBOO\")), String::from(\"cB\"));\n    assert_eq!(candidate(String::from(\"ybcd\")), String::from(\"ybcd\"));\n}\n"},{"task_id":"HumanEval_52","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali bener yen kabeh nomer ing vektor l ana ing sangisore ambang t. \/\/\/ >>> below_threshold(vec![1, 2, 4, 10], 100)\n\/\/\/ true\n\/\/\/ >>> below_threshold(vec![1, 20, 4, 10], 5)\n\/\/\/ false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n","canonical_solution":"fn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    l.iter().all(|&x| x < t)\n}\n\nfn main() {\n    println!(\"{}\", below_threshold(vec![1, 2, 4, 10], 100)); \/\/ true\n    println!(\"{}\", below_threshold(vec![1, 20, 4, 10], 5));  \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = below_threshold;\n    assert_eq!(candidate(vec![1, 2, 4, 10], 100), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 5), false);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 21), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10], 22), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 11), true);\n    assert_eq!(candidate(vec![1, 8, 4, 10], 10), false);\n}\n"},{"task_id":"HumanEval_53","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tambah loro nomer x lan y \/\/\/ >>> add(2, 3)\n\/\/\/ 5\n\/\/\/ >>> add(5, 7)\n\/\/\/ 12\nfn add(x: isize, y: isize) -> isize {\n","canonical_solution":"fn add(x: isize, y: isize) -> isize {\n    x + y\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(0, 1), 1);\n    assert_eq!(candidate(1, 0), 1);\n    assert_eq!(candidate(2, 3), 5);\n    assert_eq!(candidate(5, 7), 12);\n    assert_eq!(candidate(7, 5), 12);\n}\n"},{"task_id":"HumanEval_54","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Priksa manawa rong tembung duwe karakter sing padha. \/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n\/\/\/ false\n\/\/\/ >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n\/\/\/ false\nfn same_chars(s0: String, s1: String) -> bool {\n","canonical_solution":"use std::collections::HashSet;\n\nfn same_chars(s0: String, s1: String) -> bool {\n    let set0: HashSet<char> = s0.chars().collect();\n    let set1: HashSet<char> = s1.chars().collect();\n    set0 == set1\n}\n\nfn main() {\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))); \/\/ false\n    println!(\"{}\", same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"aabb\"), String::from(\"aaccc\")), false);\n}\n"},{"task_id":"HumanEval_55","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali nomer Fibonacci n-th. \/\/\/ >>> fib(10)\n\/\/\/ 55\n\/\/\/ >>> fib(1)\n\/\/\/ 1\n\/\/\/ >>> fib(8)\n\/\/\/ 21\nfn fib(n: isize) -> isize {\n","canonical_solution":"fn fib(n: isize) -> isize {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }\n}\n\nfn main() {\n    println!(\"{}\", fib(10)); \/\/ 55\n    println!(\"{}\", fib(1));  \/\/ 1\n    println!(\"{}\", fib(8));  \/\/ 21\n}","tests":"}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10), 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n    assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"},{"task_id":"HumanEval_56","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ bali bener yen saben kurung pambuka duwe kurung penutupan sing cocog. \/\/\/ kurung iku senar \"<\" lan \">\". \/\/\/ >>> correct_bracketing(String::from(\"<\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"<>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"<<><>>\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"><<>\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n            balance += 1;\n        } else if bracket == '>' {\n            balance -= 1;\n            if balance < 0 {\n                return false;\n            }\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n}\n"},{"task_id":"HumanEval_57","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali bener yaiku elemen vektor kanthi monoton nambah utawa nyuda. \/\/\/ >>> monotonic(vec![1, 2, 4, 20])\n\/\/\/ true\n\/\/\/ >>> monotonic(vec![1, 20, 4, 10])\n\/\/\/ false\n\/\/\/ >>> monotonic(vec![4, 1, 0, -10])\n\/\/\/ true\nfn monotonic(l: Vec<isize>) -> bool {\n","canonical_solution":"fn monotonic(l: Vec<isize>) -> bool {\n    if l.len() <= 1 {\n        return true;\n    }\n    \n    let mut increasing = true;\n    let mut decreasing = true;\n    \n    for i in 0..l.len() - 1 {\n        if l[i] < l[i + 1] {\n            decreasing = false;\n        }\n        if l[i] > l[i + 1] {\n            increasing = false;\n        }\n    }\n    \n    increasing || decreasing\n}\n\nfn main() {\n    println!(\"{}\", monotonic(vec![1, 2, 4, 20])); \/\/ true\n    println!(\"{}\", monotonic(vec![1, 20, 4, 10])); \/\/ false\n    println!(\"{}\", monotonic(vec![4, 1, 0, -10])); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1, 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1, 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n    assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]), true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"},{"task_id":"HumanEval_58","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Mbalekake unsur umum unik sing diurutake kanggo rong vektor. \/\/\/ >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n\/\/\/ vec![1, 5, 653]\n\/\/\/ >>> common(vec![5, 3, 2, 8], vec![3, 2])\n\/\/\/ vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"use std::collections::HashSet;\n\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    \/\/ Convert both vectors to hash sets to remove duplicates and allow set operations\n    let set1: HashSet<_> = l1.into_iter().collect();\n    let set2: HashSet<_> = l2.into_iter().collect();\n\n    \/\/ Find the intersection of both sets\n    let intersection: HashSet<_> = set1.intersection(&set2).cloned().collect();\n\n    \/\/ Convert the intersection set to a sorted vector\n    let mut result: Vec<_> = intersection.into_iter().collect();\n    result.sort();\n\n    result\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])); \/\/ Should print: [1, 5, 653]\n    println!(\"{:?}\", common(vec![5, 3, 2, 8], vec![3, 2])); \/\/ Should print: [2, 3]\n}","tests":"}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_59","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali faktor utama paling gedhe saka n. Nganggep n > 1 lan ora dadi prima. \/\/\/ >>> largest_prime_factor(13195)\n\/\/\/ 29\n\/\/\/ >>> largest_prime_factor(2048)\n\/\/\/ 2\nfn largest_prime_factor(n: isize) -> isize {\n","canonical_solution":"fn largest_prime_factor(mut n: isize) -> isize {\n    let mut largest_factor = 1;\n\n    \/\/ Check for number of twos that divide n\n    while n % 2 == 0 {\n        largest_factor = 2;\n        n \/= 2;\n    }\n\n    \/\/ n must be odd at this point, so we can skip even numbers\n    let mut factor = 3;\n    while factor * factor <= n {\n        while n % factor == 0 {\n            largest_factor = factor;\n            n \/= factor;\n        }\n        factor += 2;\n    }\n\n    \/\/ If n becomes a prime number greater than 2\n    if n > 2 {\n        largest_factor = n;\n    }\n\n    largest_factor\n}\n\nfn main() {\n    println!(\"{}\", largest_prime_factor(13195));\n    println!(\"{}\", largest_prime_factor(2048));\n}","tests":"}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"},{"task_id":"HumanEval_60","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ sum_to_n iku sawijining fungsi sing ngétung angka saka 1 nganti n. \/\/\/ >>> sum_to_n(30)\n\/\/\/ 465\n\/\/\/ >>> sum_to_n(100)\n\/\/\/ 5050\n\/\/\/ >>> sum_to_n(5)\n\/\/\/ 15\n\/\/\/ >>> sum_to_n(10)\n\/\/\/ 55\n\/\/\/ >>> sum_to_n(1)\n\/\/\/ 1\nfn sum_to_n(n: isize) -> isize {\n","canonical_solution":"fn sum_to_n(n: isize) -> isize {\n    n * (n + 1) \/ 2\n}","tests":"}\n\nfn main() {\n    let candidate = sum_to_n;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(6), 21);\n    assert_eq!(candidate(11), 66);\n    assert_eq!(candidate(30), 465);\n    assert_eq!(candidate(100), 5050);\n}\n"},{"task_id":"HumanEval_61","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ bali bener yen saben kurung pambuka duwe kurung penutupan sing cocog. \/\/\/ kurung iku senar \"(\" lan \")\". \/\/\/ >>> correct_bracketing(String::from(\"(\"))\n\/\/\/ false\n\/\/\/ >>> correct_bracketing(String::from(\"()\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\"(()())\"))\n\/\/\/ true\n\/\/\/ >>> correct_bracketing(String::from(\")(()\"))\n\/\/\/ false\nfn correct_bracketing(brackets: String) -> bool {\n","canonical_solution":"fn correct_bracketing(brackets: String) -> bool {\n    let mut balance = 0;\n    \n    for c in brackets.chars() {\n        if c == '(' {\n            balance += 1;\n        } else if c == ')' {\n            balance -= 1;\n        }\n\n        if balance < 0 {\n            return false;\n        }\n    }\n    \n    balance == 0\n}","tests":"}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n}\n"},{"task_id":"HumanEval_62","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Ngasilake turunan polinomial iki kanthi wujud sing padha. \/\/\/ xs[0] + xs[1] * x + xs[2] * x^2 + .... \/\/\/ xs minangka koefisien saka polinomial.\/\/\/ >>> derivative(vec![3, 1, 2, 4, 5])\n\/\/\/ vec![1, 4, 12, 20]\n\/\/\/ >>> derivative(vec![1, 2, 3])\n\/\/\/ vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &coeff) in xs.iter().enumerate().skip(1) {\n        result.push(coeff * i as isize);\n    }\n    result\n}\n\nfn main() {\n    let poly1 = vec![3, 1, 2, 4, 5];\n    let poly2 = vec![1, 2, 3];\n    println!(\"{:?}\", derivative(poly1)); \/\/ Output: [1, 4, 12, 20]\n    println!(\"{:?}\", derivative(poly2)); \/\/ Output: [2, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_63","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tulis fungsi kanggo kanthi efisien ngetung unsur n-th saka urutan nomer fibfib. \/\/\/ fibfib{n) == fibfib{n-1) + fibfib{n-2) + fibfib{n-3). \/\/\/ fib fib ((2) == 1 \/\/\/ fib fib ((1) == 0 \/\/\/ fib fib ((0) == 0 \/\/\/ Urutan angka FibFib minangka urutan sing padha karo urutan Fibbonacci sing ditetepake kaya ing ngisor iki: \/\/\/ >>> fibfib(1)\n\/\/\/ 0\n\/\/\/ >>> fibfib(5)\n\/\/\/ 4\n\/\/\/ >>> fibfib(8)\n\/\/\/ 24\nfn fibfib(n: isize) -> isize {\n","canonical_solution":"fn fibfib(n: isize) -> isize {\n    if n < 0 {\n        \/\/ Optionally handle negative indices as an error or specific value\n        return -1; \/\/ Example error indicator\n    }\n    match n {\n        0 => 0,\n        1 => 0,\n        2 => 1,\n        _ => {\n            let mut a = 0;\n            let mut b = 0;\n            let mut c = 1;\n            let mut result = 0;\n            for _ in 3..=n {\n                result = a + b + c;\n                a = b;\n                b = c;\n                c = result;\n            }\n            result\n        }\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = fibfib;\n    assert_eq!(candidate(2), 1);\n    assert_eq!(candidate(1), 0);\n    assert_eq!(candidate(5), 4);\n    assert_eq!(candidate(8), 24);\n    assert_eq!(candidate(10), 81);\n    assert_eq!(candidate(12), 274);\n    assert_eq!(candidate(14), 927);\n}\n"},{"task_id":"HumanEval_64","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ vokal, nanging mung nalika ing pungkasan tembung sing diwenehake. \/\/\/ Vokal ing kasus iki yaiku 'a', 'e', 'i', 'o', 'u'. Ing kene, 'y' uga a \/\/\/ tembung minangka input lan ngasilake nomer vokal ing senar. \/\/\/ Tulis fungsi vowels_count kang njupuk senar makili \/\/\/ >>> vowels_count(String::from(\"abcde\"))\n\/\/\/ 2\n\/\/\/ >>> vowels_count(String::from(\"ACEDY\"))\n\/\/\/ 3\nfn vowels_count(s: String) -> isize {\n","canonical_solution":"fn vowels_count(s: String) -> isize {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let s = s.to_lowercase();\n    let mut count = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(&c) || (c == 'y' && i == s.len() - 1) {\n            count += 1;\n        }\n    }\n    \n    count\n}\n\nfn main() {\n    println!(\"{}\", vowels_count(String::from(\"abcde\"))); \/\/ Output: 2\n    println!(\"{}\", vowels_count(String::from(\"ACEDY\"))); \/\/ Output: 3\n}","tests":"}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"},{"task_id":"HumanEval_65","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Yen shift > nomer digit, digit bali bali. \/\/\/ lan ngasilake asil minangka senar. \/\/\/ Circular shift digit saka integer x, ngalih digit tengen dening shift \/\/\/ >>> circular_shift(12, 1)\n\/\/\/ String::from(\"21\")\n\/\/\/ >>> circular_shift(12, 2)\n\/\/\/ String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n","canonical_solution":"fn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits: Vec<char> = x.abs().to_string().chars().collect();\n    let len = digits.len() as isize;\n    \n    if shift > len {\n        digits.reverse();\n    } else {\n        digits.rotate_right(shift as usize % len as usize);\n    }\n    \n    digits.into_iter().collect()\n}","tests":"}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100, 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12, 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"11\"));\n}\n"},{"task_id":"HumanEval_66","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Kode ASCII. \/\/\/ Tulis fungsi sing njupuk senar minangka input lan ngasilake jumlah karakter ndhuwur mung' \/\/\/ Tugas \/\/\/ >>> digitSum(String::from(\"\"))\n\/\/\/ 0\n\/\/\/ >>> digitSum(String::from(\"abAB\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"abcCd\"))\n\/\/\/ 67\n\/\/\/ >>> digitSum(String::from(\"helloE\"))\n\/\/\/ 69\n\/\/\/ >>> digitSum(String::from(\"woArBld\"))\n\/\/\/ 131\n\/\/\/ >>> digitSum(String::from(\"aAaaaXa\"))\n\/\/\/ 153\nfn digitSum(s: String) -> isize {\n","canonical_solution":"fn digitSum(s: String) -> isize {\n    s.chars()\n     .filter(|c| c.is_uppercase())\n     .map(|c| c as isize)\n     .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = digitSum;\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"abAB\")), 131);\n    assert_eq!(candidate(String::from(\"abcCd\")), 67);\n    assert_eq!(candidate(String::from(\"helloE\")), 69);\n    assert_eq!(candidate(String::from(\"woArBld\")), 131);\n    assert_eq!(candidate(String::from(\"aAaaaXa\")), 153);\n    assert_eq!(candidate(String::from(\" How are yOu?\")), 151);\n    assert_eq!(candidate(String::from(\"You arE Very Smart\")), 327);\n}\n"},{"task_id":"HumanEval_67","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ kanggo examble: \/\/\/ ing kranjang ngasilake nomer woh-wohan mangga ing kranjang. \/\/\/ jeruk lan apel lan nomer wutuh sing makili total woh-wohan \/\/\/ apel, jeruk, lan woh-wohan mangga. Given string sing makili nomer total \/\/\/ sing disebar ing kranjang woh-wohan kranjang iki ngemot \/\/\/ Ing tugas iki, sampeyan bakal diwenehi senar sing makili nomer apel lan oranye \/\/\/ >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n\/\/\/ 8\n\/\/\/ >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n\/\/\/ 2\n\/\/\/ >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n\/\/\/ 95\n\/\/\/ >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n\/\/\/ 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n","canonical_solution":"fn fruit_distribution(s: String, n: isize) -> isize {\n    let mut parts = s.split_whitespace();\n    let apples: isize = parts.next().unwrap().parse().unwrap();\n    parts.next(); \/\/ skip \"apples\"\n    parts.next(); \/\/ skip \"and\"\n    let oranges: isize = parts.next().unwrap().parse().unwrap();\n    \n    n - (apples + oranges)\n}\n\nfn main() {\n    assert_eq!(fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120), 19);\n    println!(\"All test cases passed!\");\n}","tests":"}\n\nfn main() {\n    let candidate = fruit_distribution;\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(candidate(String::from(\"5 apples and 6 oranges\"), 21), 10);\n    assert_eq!(candidate(String::from(\"0 apples and 1 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"1 apples and 0 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 100), 95);\n    assert_eq!(candidate(String::from(\"2 apples and 3 oranges\"), 5), 0);\n    assert_eq!(candidate(String::from(\"1 apples and 100 oranges\"), 120), 19);\n}\n"},{"task_id":"HumanEval_68","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha 1: \/\/\/ Yen ora ana nilai malah utawa vektor sing diwenehake kosong, bali []. \/\/\/ simpul dijupuk kudu bali ing vektor, [small_value, indeks sawijining ], \/\/\/ Yen macem-macem simpul karo nilai malah cilik padha ditemokaké bali simpul sing wis indeks cilik. \/\/\/ Node sing dijupuk kudu dadi node kanthi nilai malah paling cilik. \/\/\/ tugas sampeyan kanggo pluck salah siji saka simpul lan bali iku. \/\/\/ \"Given a vektor makili cabang wit sing wis non-negatif intèr simpul \/\/\/ >>> pluck(vec![4, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 2:\n\/\/\/ >>> pluck(vec![1, 2, 3])\n\/\/\/ vec![2, 1]\n\/\/\/ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\/\/\/ Example 3:\n\/\/\/ >>> pluck(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ Example 4:\n\/\/\/ >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\/\/\/ vec![0, 1]\n\/\/\/ Explanation: 0 is the smallest value, but  there are two zeros,\n\/\/\/ so we will choose the first zero, which has the smallest index.\n\/\/\/ Constraints:\n\/\/\/ * 1 <= nodes.length <= 10000\n\/\/\/ * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even: Option<(isize, usize)> = None;\n\n    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n            match smallest_even {\n                None => smallest_even = Some((value, index)),\n                Some((smallest_value, _)) if value < smallest_value => smallest_even = Some((value, index)),\n                _ => {}\n            }\n        }\n    }\n\n    match smallest_even {\n        Some((value, index)) => vec![value, index as isize],\n        None => Vec::new(),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_69","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Yen ora ana nilai kasebut, bali -1. \/\/\/ Frekuensi saka integer iku nomer kaping katon ing vektor. \/\/\/ nol, lan duwe frekuensi luwih gedhe utawa padha karo nilai saka integer dhewe. \/\/\/ Sampeyan diwenehi vektor non-kosong saka wilangan bulat positif. Mbalekake wilangan bulat paling gedhe sing luwih gedhe tinimbang \/\/\/ >>> search(vec![4, 1, 2, 2, 3, 1])\n\/\/\/ 2\n\/\/\/ >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n\/\/\/ 3\n\/\/\/ >>> search(vec![5, 5, 4, 4, 4])\n\/\/\/ -1\nfn search(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn search(lst: Vec<isize>) -> isize {\n    use std::collections::HashMap;\n    \n    let mut frequency_map = HashMap::new();\n    \n    \/\/ Count the frequency of each integer in the vector\n    for &num in &lst {\n        *frequency_map.entry(num).or_insert(0) += 1;\n    }\n    \n    let mut result = -1;\n    \n    \/\/ Iterate over the map to find the greatest integer with a frequency\n    \/\/ greater than or equal to its value\n    for (&num, &freq) in &frequency_map {\n        if freq >= num && num > result {\n            result = num;\n        }\n    }\n    \n    result\n}\n\n\/\/ Test cases\nfn main() {\n    assert_eq!(search(vec![4, 1, 2, 2, 3, 1]), 2);\n    assert_eq!(search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4]), 3);\n    assert_eq!(search(vec![5, 5, 4, 4, 4]), -1);\n}","tests":"}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5, 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n    assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n    assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3, 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1, 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]), 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]), -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n}\n"},{"task_id":"HumanEval_70","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ banjur maksimum saka wilangan bulat sing isih, banjur minimal lan liya-liyane. \/\/\/ Ngurutake aneh, nalika sampeyan miwiti karo nilai minimal, \/\/\/ Given vektor saka wilangan bulat, bali vektor ing urutan aneh. \/\/\/ >>> strange_sort_list(vec![1, 2, 3, 4])\n\/\/\/ vec![1, 4, 2, 3]\n\/\/\/ >>> strange_sort_list(vec![5, 5, 5, 5])\n\/\/\/ vec![5, 5, 5, 5]\n\/\/\/ >>> strange_sort_list(vec![])\n\/\/\/ Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn strange_sort_list(mut lst: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(lst.len());\n    lst.sort();\n\n    while !lst.is_empty() {\n        \/\/ Take the smallest element\n        if let Some(min) = lst.first().cloned() {\n            result.push(min);\n            lst.remove(0);\n        }\n        \/\/ Take the largest element\n        if let Some(max) = lst.last().cloned() {\n            result.push(max);\n            lst.pop();\n        }\n    }\n\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", strange_sort_list(vec![1, 2, 3, 4])); \/\/ Output: vec![1, 4, 2, 3]\n    println!(\"{:?}\", strange_sort_list(vec![5, 5, 5, 5])); \/\/ Output: vec![5, 5, 5, 5]\n    println!(\"{:?}\", strange_sort_list(vec![])); \/\/ Output: Vec::<isize>::new()\n}","tests":"}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]), vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1, 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5, 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0, 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]), vec![111111]);\n}\n"},{"task_id":"HumanEval_71","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ saka sisih katelu. \/\/\/ Telu sisi nggawe segitiga sing bener yen jumlah loro sisi luwih gedhe .\/\/\/ Yen ora bali -1 \/\/\/ segitiga dibunderaké dadi 2 titik desimal yen telung sisi mbentuk segitiga sing bener. \/\/\/ Given dawane telung sisih segitiga. Nguripake area \/\/\/ >>> triangle_area(3, 4, 5)\n\/\/\/ 6.0\n\/\/\/ >>> triangle_area(1, 2, 10)\n\/\/\/ -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n","canonical_solution":"fn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 \/ 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        (area * 100.0).round() \/ 100.0\n    } else {\n        -1.0\n    }\n}\n\nfn main() {\n    println!(\"{}\", triangle_area(3, 4, 5)); \/\/ 6.0\n    println!(\"{}\", triangle_area(1, 2, 10)); \/\/ -1.0\n}","tests":"}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3, 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4, 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1, 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2, 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2, 2, 10), -1.0);\n}\n"},{"task_id":"HumanEval_72","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Objek q bakal mabur yen seimbang (iku vektor palindromik) lan jumlah unsur-unsur kurang saka utawa padha karo bobot maksimum sing bisa ditindakake w. \/\/\/ Tulis fungsi sing ngasilake bener yen obyek q bakal mabur, lan palsu yen ora. \/\/\/ >>> will_it_fly(vec![1, 2], 5)\n\/\/\/ false\n\/\/\/ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 1)\n\/\/\/ false\n\/\/\/ # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\/\/\/ >>> will_it_fly(vec![3, 2, 3], 9)\n\/\/\/ true\n\/\/\/ # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\/\/\/ >>> will_it_fly(vec![3], 5)\n\/\/\/ true\n\/\/\/ # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n","canonical_solution":"fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let is_palindromic = q.iter().eq(q.iter().rev());\n\n    is_palindromic && sum <= w\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{}\", will_it_fly(vec![1, 2], 5)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 1)); \/\/ false\n    println!(\"{}\", will_it_fly(vec![3, 2, 3], 9)); \/\/ true\n    println!(\"{}\", will_it_fly(vec![3], 5)); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"},{"task_id":"HumanEval_73","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ diwaca padha maju lan mundur. Ing siji pangowahan, sampeyan bisa ngganti siji unsur menyang unsur liyane. \/\/\/ perlu diowahi kanggo nggawe vektor palindromik. Vektor palindromik yaiku vektor sing \/\/\/ Given a vektor arr saka wilangan bulat, golek nomer minimal unsur sing \/\/\/ >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n\/\/\/ 4\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n\/\/\/ 1\n\/\/\/ >>> smallest_change(vec![1, 2, 3, 2, 1])\n\/\/\/ 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn smallest_change(arr: Vec<isize>) -> isize {\n    let mut changes = 0;\n    let n = arr.len();\n    \n    for i in 0..n\/2 {\n        if arr[i] != arr[n - i - 1] {\n            changes += 1;\n        }\n    }\n    \n    changes\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]);\n\/\/     println!(\"{}\", result); \/\/ Outputs: 4\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = smallest_change;\n    assert_eq!(candidate(vec![1, 2, 3, 5, 4, 7, 9, 6]), 4);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 3, 2, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 4, 4, 2]), 1);\n    assert_eq!(candidate(vec![1, 2, 3, 2, 1]), 0);\n    assert_eq!(candidate(vec![3, 1, 1, 3]), 0);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(vec![0, 1]), 1);\n}\n"},{"task_id":"HumanEval_74","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ yen loro vektor duwe nomer padha chars, bali vektor pisanan. \/\/\/ total nomer chars ing kabeh senar vektor kurang saka vektor liyane. \/\/\/ Tulis fungsi sing nampa loro vektor strings lan ngasilake vektor sing wis \/\/\/ >>> total_match(vec![], vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"Hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n\/\/\/ vec![String::from(\"hi\"), String::from(\"admin\")]\n\/\/\/ >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\/\/\/ vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n\/\/\/ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n\/\/\/ vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let char_count = |lst: &Vec<String>| lst.iter().map(|s| s.len()).sum::<usize>();\n\n    if char_count(&lst1) <= char_count(&lst2) {\n        lst1\n    } else {\n        lst2\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    let result1 = total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    println!(\"{:?}\", result1);\n\n    let result2 = total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]);\n    println!(\"{:?}\", result2);\n}","tests":"}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\")]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(), vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"},{"task_id":"HumanEval_75","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Ngerti yen (a) kurang saka 100. \/\/\/ lan palsu liyane. \/\/\/ Tulis fungsi sing ngasilake bener yen nomer sing diwenehake yaiku perkalian 3 nomer prima \/\/\/ >>> is_multiply_prime(30)\n\/\/\/ true\n\/\/\/ 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n","canonical_solution":"fn is_multiply_prime(a: isize) -> bool {\n    fn is_prime(n: isize) -> bool {\n        if n <= 1 {\n            return false;\n        }\n        if n <= 3 {\n            return true;\n        }\n        if n % 2 == 0 || n % 3 == 0 {\n            return false;\n        }\n        let mut i = 5;\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2) == 0 {\n                return false;\n            }\n            i += 6;\n        }\n        true\n    }\n\n    if a < 2 {\n        return false;\n    }\n\n    let mut primes = Vec::new();\n    for i in 2..a {\n        if is_prime(i) {\n            primes.push(i);\n        }\n    }\n\n    let p_len = primes.len();\n    for i in 0..p_len {\n        for j in i..p_len {\n            for k in j..p_len {\n                if primes[i] * primes[j] * primes[k] == a {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = is_multiply_prime;\n    assert_eq!(candidate(5), false);\n    assert_eq!(candidate(30), true);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(125), true);\n    assert_eq!(candidate(105), true);\n    assert_eq!(candidate(126), false);\n    assert_eq!(candidate(729), false);\n    assert_eq!(candidate(891), false);\n    assert_eq!(candidate(1001), true);\n}\n"},{"task_id":"HumanEval_76","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ x iku pangkat prasaja saka n yèn n**int=x \/\/\/ pangkat n lan palsu ing kasus liyane. \/\/\/ Tugasmu yaiku nulis fungsi sing ngasilake bener yen nomer x iku \/\/\/ >>> is_simple_power(1, 4)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(2, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(8, 2)\n\/\/\/ true\n\/\/\/ >>> is_simple_power(3, 2)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(3, 1)\n\/\/\/ false\n\/\/\/ >>> is_simple_power(5, 3)\n\/\/\/ false\nfn is_simple_power(x: isize, n: isize) -> bool {\n","canonical_solution":"fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n        return false;\n    } else if x == 1 {\n        return true;\n    } else if n == 1 {\n        return x == 1;\n    }\n\n    let mut power_n = n;\n    while power_n < x {\n        power_n *= n;\n    }\n    power_n == x\n}\n\nfn main() {\n    println!(\"{}\", is_simple_power(1, 4)); \/\/ true\n    println!(\"{}\", is_simple_power(2, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(8, 2)); \/\/ true\n    println!(\"{}\", is_simple_power(3, 2)); \/\/ false\n    println!(\"{}\", is_simple_power(3, 1)); \/\/ false\n    println!(\"{}\", is_simple_power(5, 3)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"},{"task_id":"HumanEval_77","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Cathetan: sampeyan bisa nganggep input tansah bener. \/\/\/ yen ingeger iki minangka kubus saka sawetara nomer bulat. \/\/\/ Tulis fungsi sing njupuk integer a lan ngasilake bener \/\/\/ >>> iscube(1)\n\/\/\/ true\n\/\/\/ >>> iscube(2)\n\/\/\/ false\n\/\/\/ >>> iscube(-1)\n\/\/\/ true\n\/\/\/ >>> iscube(64)\n\/\/\/ true\n\/\/\/ >>> iscube(0)\n\/\/\/ true\n\/\/\/ >>> iscube(180)\n\/\/\/ false\nfn iscube(a: isize) -> bool {\n","canonical_solution":"fn iscube(a: isize) -> bool {\n    if a < 0 {\n        \/\/ For negative numbers, take the cube root of the absolute value.\n        let cube_root = (-a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    } else {\n        let cube_root = (a as f64).cbrt();\n        let rounded_cube = cube_root.round() as isize;\n        rounded_cube * rounded_cube * rounded_cube == a\n    }\n}\n\nfn main() {\n    println!(\"{}\", iscube(1));   \/\/ true\n    println!(\"{}\", iscube(2));   \/\/ false\n    println!(\"{}\", iscube(-1));  \/\/ true\n    println!(\"{}\", iscube(64));  \/\/ true\n    println!(\"{}\", iscube(0));   \/\/ true\n    println!(\"{}\", iscube(180)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n"},{"task_id":"HumanEval_78","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ lan simbol A,B,C,D,E,F tansah huruf kapital. \/\/\/ Cathetan: sampeyan bisa nganggep input tansah bener utawa kosong senar, \/\/\/ B (= desimal 11), D (= desimal 13). \/\/\/ Dadi sampeyan kudu nemtokake nomer saka digit ing ngisor iki: 2, 3, 5, 7, \/\/\/ Angka prima yaiku 2, 3, 5, 7, 11, 13, 17,... \/\/\/ Angka heksadesimal yaiku 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \/\/\/ luwih gedhe saka 1 sing ora produk saka rong nomer asli sing luwih cilik). \/\/\/ digit sing dadi wilangan prima (angka prima, utawa wilangan prima, iku wilangan asli \/\/\/ nomer hexadecimal minangka senar lan ngetung nomer hexadecimal \/\/\/ Sampeyan wis ditugasake kanggo nulis fungsi sing nampa \/\/\/ >>> hex_key(String::from(\"AB\"))\n\/\/\/ 1\n\/\/\/ >>> hex_key(String::from(\"1077E\"))\n\/\/\/ 2\n\/\/\/ >>> hex_key(String::from(\"ABED1A33\"))\n\/\/\/ 4\n\/\/\/ >>> hex_key(String::from(\"123456789ABCDEF0\"))\n\/\/\/ 6\n\/\/\/ >>> hex_key(String::from(\"2020\"))\n\/\/\/ 2\nfn hex_key(num: String) -> isize {\n","canonical_solution":"fn hex_key(num: String) -> isize {\n    let prime_hex_chars = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars()\n        .filter(|c| prime_hex_chars.contains(c))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"},{"task_id":"HumanEval_79","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Karakter ekstra ana kanggo mbantu format. \/\/\/ Bakal ana tambahan karakter 'db' ing wiwitan lan pungkasan string. \/\/Saben karakter ing string bakal dadi '0' utawa '1'.\/\/\/ format binar. Fungsi kudu bali string, karo saben karakter makili binary \/\/\/ Sampeyan bakal diwenehi nomer ing wangun desimal lan tugas sampeyan kanggo ngowahi iku kanggo \/\/\/ >>> decimal_to_binary(15)\n\/\/\/ String::from(\"db1111db\")\n\/\/\/ >>> decimal_to_binary(32)\n\/\/\/ String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n","canonical_solution":"fn decimal_to_binary(decimal: isize) -> String {\n    let binary_string = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary_string)\n}\n\nfn main() {\n    \/\/ Example usage\n    let binary_15 = decimal_to_binary(15);\n    let binary_32 = decimal_to_binary(32);\n    println!(\"{}\", binary_15); \/\/ Outputs: db1111db\n    println!(\"{}\", binary_32); \/\/ Outputs: db100000db\n}","tests":"}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n}\n"},{"task_id":"HumanEval_80","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ String haprs yen dawane paling ora 3 lan saben 3 huruf berturut-turut beda \/\/\/ Tugas sampeyan yaiku mriksa yen senar kasebut bener utawa ora. \/\/\/ Sampeyan diwenehi senar s. \/\/\/ >>> is_happy(String::from(\"a\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"aa\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"abcd\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"aabb\"))\n\/\/\/ false\n\/\/\/ >>> is_happy(String::from(\"adb\"))\n\/\/\/ true\n\/\/\/ >>> is_happy(String::from(\"xyy\"))\n\/\/\/ false\nfn is_happy(s: String) -> bool {\n","canonical_solution":"fn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n\n    let chars: Vec<char> = s.chars().collect();\n    for i in 0..(chars.len() - 2) {\n        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] == chars[i + 2] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    println!(\"{}\", is_happy(String::from(\"a\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"aa\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"abcd\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"aabb\"))); \/\/ false\n    println!(\"{}\", is_happy(String::from(\"adb\"))); \/\/ true\n    println!(\"{}\", is_happy(String::from(\"xyy\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"},{"task_id":"HumanEval_81","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ 0.0 E \/\/\/ > 0.0 D- \/\/\/ > 0,7 D \/\/\/ > 1.0 D+ \/\/\/ > 1.3 C- \/\/\/ > 1.7 C \/\/\/ > 2.0 C+ \/\/\/ > 2.3 B- \/\/\/ > 2.7 B \/\/\/ > 3.0 B+ \/\/\/ > 3.3 A- \/\/\/ > 3.7 A \/\/\/ 4.0 A+ \/\/\/ GPA   Sastra kelas \/\/\/ fungsi sing bisa output vektor saka gelar huruf nggunakake tabel ing ngisor iki: \/\/\/ Dheweke wis menehi vektor GPA kanggo sawetara siswa lan sampeyan kudu nulis \/\/\/ Siji-sijine masalah yaiku, dheweke wis ilang kode sing digunakake kanggo menehi nilai. \/\/\/ kanggo siswa. guru wis nggawe algoritma dhewe kanggo menehi nilai. \/\/\/ Iku minggu pungkasan saka semester lan guru wis menehi nilai \/\/\/ >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n\/\/\/ vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n","canonical_solution":"fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    grades.into_iter().map(|gpa| {\n        match gpa {\n            4.0 => String::from(\"A+\"),\n            v if v > 3.7 => String::from(\"A\"),\n            v if v > 3.3 => String::from(\"A-\"),\n            v if v > 3.0 => String::from(\"B+\"),\n            v if v > 2.7 => String::from(\"B\"),\n            v if v > 2.3 => String::from(\"B-\"),\n            v if v > 2.0 => String::from(\"C+\"),\n            v if v > 1.7 => String::from(\"C\"),\n            v if v > 1.3 => String::from(\"C-\"),\n            v if v > 1.0 => String::from(\"D+\"),\n            v if v > 0.7 => String::from(\"D\"),\n            v if v > 0.0 => String::from(\"D-\"),\n            _ => String::from(\"E\"),\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = numerical_letter_grade;\n    assert_eq!(candidate(vec![4.0, 3.0, 1.7, 2.0, 3.5]), vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]);\n    assert_eq!(candidate(vec![1.2]), vec![String::from(\"D+\")]);\n    assert_eq!(candidate(vec![0.5]), vec![String::from(\"D-\")]);\n    assert_eq!(candidate(vec![0.0]), vec![String::from(\"E\")]);\n    assert_eq!(candidate(vec![1.0, 0.3, 1.5, 2.8, 3.3]), vec![String::from(\"D\"), String::from(\"D-\"), String::from(\"C-\"), String::from(\"B\"), String::from(\"B+\")]);\n    assert_eq!(candidate(vec![0.0, 0.7]), vec![String::from(\"E\"), String::from(\"D-\")]);\n}\n"},{"task_id":"HumanEval_82","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ dawa iku nomer prima utawa palsu yen ora \/\/\/ Tulis fungsi sing njupuk senar lan ngasilake bener yen senar \/\/\/ >>> prime_length(String::from(\"Hello\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"abcdcba\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"kittens\"))\n\/\/\/ true\n\/\/\/ >>> prime_length(String::from(\"orange\"))\n\/\/\/ false\nfn prime_length(string: String) -> bool {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn prime_length(string: String) -> bool {\n    let length = string.len();\n    is_prime(length)\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", prime_length(String::from(\"Hello\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"abcdcba\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"kittens\"))); \/\/ true\n    println!(\"{}\", prime_length(String::from(\"orange\"))); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = prime_length;\n    assert_eq!(candidate(String::from(\"Hello\")), true);\n    assert_eq!(candidate(String::from(\"abcdcba\")), true);\n    assert_eq!(candidate(String::from(\"kittens\")), true);\n    assert_eq!(candidate(String::from(\"orange\")), false);\n    assert_eq!(candidate(String::from(\"wow\")), true);\n    assert_eq!(candidate(String::from(\"world\")), true);\n    assert_eq!(candidate(String::from(\"MadaM\")), true);\n    assert_eq!(candidate(String::from(\"Wow\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"HI\")), true);\n    assert_eq!(candidate(String::from(\"go\")), true);\n    assert_eq!(candidate(String::from(\"gogo\")), false);\n    assert_eq!(candidate(String::from(\"aaaaaaaaaaaaaaa\")), false);\n    assert_eq!(candidate(String::from(\"Madam\")), true);\n    assert_eq!(candidate(String::from(\"M\")), false);\n    assert_eq!(candidate(String::from(\"0\")), false);\n}\n"},{"task_id":"HumanEval_83","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ wilangan bulat positif sing diwiwiti utawa dipungkasi karo 1. \/\/\/ Given a integer positif n, bali count saka nomer saka n-digit fn starts_one_ends(n: isize) -> isize {\n","canonical_solution":"fn starts_one_ends(n: isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1; \/\/ only '1' satisfies the condition for a single-digit\n    }\n\n    \/\/ Consider numbers starting with '1' (1XXXX...)\n    let start_with_one = 9isize.pow((n-1) as u32);\n\n    \/\/ Consider numbers ending with '1' (...XXXX1)\n    let end_with_one = 9isize.pow((n-1) as u32);\n    \n    \/\/ Consider numbers both starting and ending with '1' and check overlaps (1XXX1)\n    let both_start_end_one = 9isize.pow((n-2) as u32);\n\n    \/\/ Total numbers starting or ending with '1'\n    start_with_one + end_with_one - both_start_end_one\n}\n\nfn main() {\n    \/\/ Example usage:\n    let n = 3;\n    println!(\"Count of n-digit numbers starting or ending with 1: {}\", starts_one_ends(n));\n}","tests":"}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n    assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"},{"task_id":"HumanEval_84","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ Given a integer positif N, bali jumlah total digit ing binar. \/\/\/ >>> solve(1000)\n\/\/\/ String::from(\"1\")\n\/\/\/ >>> solve(150)\n\/\/\/ String::from(\"110\")\n\/\/\/ >>> solve(147)\n\/\/\/ String::from(\"1100\")\n\/\/\/ Variables:\n\/\/\/ @N integer\n\/\/\/ Constraints: 0 ≤ N ≤ 10000.\n\/\/\/ Output:\n\/\/\/ a string of binary number\nfn solve(N: isize) -> String {\n","canonical_solution":"fn solve(N: isize) -> String {\n    let sum_of_digits: isize = N\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as isize)\n        .sum();\n    \n    format!(\"{:b}\", sum_of_digits)\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(1000), String::from(\"1\"));\n    assert_eq!(candidate(150), String::from(\"110\"));\n    assert_eq!(candidate(147), String::from(\"1100\"));\n    assert_eq!(candidate(333), String::from(\"1001\"));\n    assert_eq!(candidate(963), String::from(\"10010\"));\n}\n"},{"task_id":"HumanEval_85","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Given a non-kosong vektor saka wilangan bulat lst. nambah unsur malah sing ing indeks aneh .. \/\/\/ >>> add(vec![4, 2, 6, 7])\n\/\/\/ 2\nfn add(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn add(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, _)| i % 2 == 1) \/\/ select odd indices\n        .map(|(_, &x)| x) \/\/ get the values at odd indices\n        .filter(|&x| x % 2 == 0) \/\/ filter even values\n        .sum() \/\/ sum the values\n}","tests":"}\n\nfn main() {\n    let candidate = add;\n    assert_eq!(candidate(vec![4, 88]), 88);\n    assert_eq!(candidate(vec![4, 5, 6, 7, 2, 122]), 122);\n    assert_eq!(candidate(vec![4, 0, 6, 7]), 0);\n    assert_eq!(candidate(vec![4, 4, 6, 8]), 12);\n}\n"},{"task_id":"HumanEval_86","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Cathetan: Sampeyan kudu tetep urutan tembung lan spasi kosong ing ukara. \/\/\/ urutan munggah adhedhasar nilai ASCII. \/\/\/ diganti nganggo tembung anyar ing ngendi kabeh karakter disusun ing \/\/\/ versi urutan saka senar, iku senar ngendi kabeh tembung (dipisahake dening spasi) \/\/\/ Tulis fungsi sing njupuk senar lan ngasilake versi sing diurutake. \/\/\/ >>> anti_shuffle(String::from(\"Hi\"))\n\/\/\/ String::from(\"Hi\")\n\/\/\/ >>> anti_shuffle(String::from(\"hello\"))\n\/\/\/ String::from(\"ehllo\")\n\/\/\/ >>> anti_shuffle(String::from(\"Hello World!!!\"))\n\/\/\/ String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n","canonical_solution":"fn anti_shuffle(s: String) -> String {\n    let mut result = String::new();\n    let mut word = String::new();\n\n    for c in s.chars() {\n        if c.is_whitespace() {\n            if !word.is_empty() {\n                let mut chars: Vec<char> = word.chars().collect();\n                chars.sort_unstable();\n                result.push_str(&chars.into_iter().collect::<String>());\n                word.clear();\n            }\n            result.push(c);\n        } else {\n            word.push(c);\n        }\n    }\n\n    if !word.is_empty() {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort_unstable();\n        result.push_str(&chars.into_iter().collect::<String>());\n    }\n\n    result\n}\n\nfn main() {\n    \/\/ Example usages:\n    println!(\"{}\", anti_shuffle(String::from(\"Hi\")));              \/\/ \"Hi\"\n    println!(\"{}\", anti_shuffle(String::from(\"hello\")));           \/\/ \"ehllo\"\n    println!(\"{}\", anti_shuffle(String::from(\"Hello World!!!\")));  \/\/ \"Hello !!!Wdlor\"\n}","tests":"}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n}\n"},{"task_id":"HumanEval_87","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Uga, Urut koordinat baris dening kolom ing urutan mudhun. \/\/\/ Urut koordinat dhisik kanthi baris kanthi urutan munggah. \/\/\/ saben tuple iku koordinat - (baris, kolom), diwiwiti karo 0. \/\/\/ lan bali vektor saka tuples, [(x1, y1), (x2, y2) ...] kayata sing \/\/\/ Given lst, lan integer x, golek integer x ing vektor, \/\/\/ saben baris bisa ngemot nomer kolom sing beda. \/\/\/ kang padha karo matriks, nanging ora kaya matriks, \/\/\/ Sampeyan diwenehi data 2 dimensi, minangka vektor sing dipasang, \/\/\/ >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n\/\/\/ vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\/\/\/ >>> get_row(vec![], 1)\n\/\/\/ Vec::<(isize, isize)>::new()\n\/\/\/ >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n\/\/\/ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n","canonical_solution":"fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut result = Vec::new();\n\n    for (row_index, row) in lst.iter().enumerate() {\n        let mut found_indices: Vec<isize> = row.iter()\n            .enumerate()\n            .filter(|&(_, &value)| value == x)\n            .map(|(col_index, _)| col_index as isize)\n            .collect();\n\n        found_indices.sort_by(|a, b| b.cmp(a)); \/\/ Sort column indices in descending order\n\n        for col_index in found_indices {\n            result.push((row_index as isize, col_index));\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"},{"task_id":"HumanEval_88","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ * aja ngganti vektor sing diwenehake. \/\/\/ Cathetan: \/\/\/ utawa ngurutake kanthi urutan mudhun yen jumlah ((nilai indeks pertama, nilai indeks pungkasan) malah. \/\/\/ sampeyan bakal ngurutake vektor sing diwenehake kanthi urutan munggah yen jumlah ((nilai indeks pertama, nilai indeks terakhir) ganjil, \/\/\/ Given a vektor saka non-negatif wilangan bulat, bali cors saka vektor diwenehi sawise ngurutake, \/\/\/ >>> sort_array(vec![])\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> sort_array(vec![5])\n\/\/\/ vec![5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n\/\/\/ vec![0, 1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n\/\/\/ vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.is_empty() {\n        return Vec::<isize>::new();\n    }\n\n    let first = array.first().unwrap_or(&0);\n    let last = array.last().unwrap_or(&0);\n    let sum = first + last;\n\n    let mut sorted_array = array.clone();\n    if sum % 2 == 0 {\n        sorted_array.sort_by(|a, b| b.cmp(a)); \/\/ Descending order\n    } else {\n        sorted_array.sort(); \/\/ Ascending order\n    }\n\n    sorted_array\n}\n\nfn main() {\n    \/\/ Test cases\n    println!(\"{:?}\", sort_array(vec![])); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", sort_array(vec![5])); \/\/ vec![5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5])); \/\/ vec![0, 1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![2, 4, 3, 0, 1, 5, 6])); \/\/ vec![6, 5, 4, 3, 2, 1, 0]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"},{"task_id":"HumanEval_89","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ shift mudhun dening loro ping pindho kanggo rong panggonan. \/\/\/ Abjad kudu diputer kanthi cara supaya huruf \/\/\/ ngasilake senar sing dienkripsi kanthi alfabet sing diputer. \/\/\/ Nggawe fungsi enkripsi sing njupuk senar minangka argumen lan \/\/\/ >>> encrypt(String::from(\"hi\"))\n\/\/\/ String::from(\"lm\")\n\/\/\/ >>> encrypt(String::from(\"asdfghjkl\"))\n\/\/\/ String::from(\"ewhjklnop\")\n\/\/\/ >>> encrypt(String::from(\"gf\"))\n\/\/\/ String::from(\"kj\")\n\/\/\/ >>> encrypt(String::from(\"et\"))\n\/\/\/ String::from(\"ix\")\nfn encrypt(s: String) -> String {\n","canonical_solution":"fn encrypt(s: String) -> String {\n    s.chars()\n        .map(|c| {\n            if c.is_ascii_lowercase() {\n                let offset = (c as u8 - b'a' + 4) % 26;\n                (b'a' + offset) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"},{"task_id":"HumanEval_90","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Bali None yen ora ana unsur kasebut. \/\/\/ Tulis fungsi next_smallest (() sing ngasilake unsur paling cilik nomer 2 saka vektor. \/\/\/ Sampeyan diwenehi vektor saka wilangan bulat. \/\/\/ >>> next_smallest(vec![1, 2, 3, 4, 5])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![5, 1, 4, 3, 2])\n\/\/\/ Some(2)\n\/\/\/ >>> next_smallest(vec![])\n\/\/\/ None\n\/\/\/ >>> next_smallest(vec![1, 1])\n\/\/\/ None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n    let mut unique_elements: Vec<isize> = lst.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect();\n    if unique_elements.len() < 2 {\n        return None;\n    }\n    unique_elements.sort();\n    Some(unique_elements[1])\n}\n\nfn main() {\n    println!(\"{:?}\", next_smallest(vec![1, 2, 3, 4, 5])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![5, 1, 4, 3, 2])); \/\/ Some(2)\n    println!(\"{:?}\", next_smallest(vec![])); \/\/ None\n    println!(\"{:?}\", next_smallest(vec![1, 1])); \/\/ None\n}","tests":"}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"},{"task_id":"HumanEval_91","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Ukara diwatesi karo '.', '?' utawa '!'. \/\/\/ saka boredoms. A bosen punika ukara sing wiwit karo tembung \"I\". \/\/\/ Sampeyan bakal diwenehi senar tembung, lan tugas sampeyan yaiku ngetung nomer kasebut \/\/\/ >>> is_bored(String::from(\"Hello world\"))\n\/\/\/ 0\n\/\/\/ >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n\/\/\/ 1\nfn is_bored(S: String) -> isize {\n","canonical_solution":"fn is_bored(S: String) -> isize {\n    S.split(|c| c == '.' || c == '?' || c == '!')\n        .filter(|sentence| sentence.trim_start().starts_with(\"I\"))\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are going for a walk\")), 0);\n}\n"},{"task_id":"HumanEval_92","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ Bali palsu ing kasus liyane. \/\/\/ Bali bener yen salah siji saka nomer padha karo jumlah saka loro liyane, lan kabeh nomer sing wilangan bulat. \/\/\/ Nggawe fungsi sing njupuk 3 nomer. \/\/\/ >>> any_int(5, 2, 7)\n\/\/\/ true\n\/\/\/ >>> any_int(3, 2, 2)\n\/\/\/ false\n\/\/\/ >>> any_int(3, -2, 1)\n\/\/\/ true\n\/\/\/ >>> any_int(3.6, -2.2, 2)\n\/\/\/ false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n","canonical_solution":"fn any_int(x: f64, y: f64, z: f64) -> bool {\n    \/\/ Check if all the numbers are integers\n    if x.fract() == 0.0 && y.fract() == 0.0 && z.fract() == 0.0 {\n        \/\/ Convert f64 to i64 because they are integers\n        let xi = x as i64;\n        let yi = y as i64;\n        let zi = z as i64;\n\n        \/\/ Check if any one of the numbers is equal to the sum of the other two\n        xi == yi + zi || yi == xi + zi || zi == xi + yi\n    } else {\n        false\n    }\n}\n\nfn main() {\n    \/\/ Examples\n    println!(\"{}\", any_int(5.0, 2.0, 7.0)); \/\/ true\n    println!(\"{}\", any_int(3.0, 2.0, 2.0)); \/\/ false\n    println!(\"{}\", any_int(3.0, -2.0, 1.0)); \/\/ true\n    println!(\"{}\", any_int(3.6, -2.2, 2.0)); \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0, 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5, 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0, 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0, 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"},{"task_id":"HumanEval_93","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Mung nganggep huruf. \/\/\/ vokal ing abjad Inggris. \/\/\/ pesen karo huruf sing katon 2 papan ing ngarep \/\/\/ cara sing ngganti kasus kabeh huruf, ngganti kabeh vokal ing \/\/\/ Tulis fungsi sing njupuk pesen, lan encodes ing kuwi \/\/\/ >>> encode(String::from(\"test\"))\n\/\/\/ String::from(\"TGST\")\n\/\/\/ >>> encode(String::from(\"This is a message\"))\n\/\/\/ String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n","canonical_solution":"fn encode(message: String) -> String {\n    message.chars().map(|c| {\n        match c {\n            'a' => 'C',\n            'e' => 'G',\n            'i' => 'K',\n            'o' => 'Q',\n            'u' => 'W',\n            'A' => 'c',\n            'E' => 'g',\n            'I' => 'k',\n            'O' => 'q',\n            'U' => 'w',\n            'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n    }).collect()\n}","tests":"}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"},{"task_id":"HumanEval_94","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Sampeyan kudu nemokake nilai prima paling gedhe lan bali jumlah digit. \/\/\/ Sampeyan diwenehi vektor saka wilangan bulat. \/\/\/ >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n\/\/\/ 10\n\/\/\/ >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n\/\/\/ 25\n\/\/\/ >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n\/\/\/ 13\n\/\/\/ >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n\/\/\/ 11\n\/\/\/ >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n\/\/\/ 3\n\/\/\/ >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n\/\/\/ 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn digit_sum(n: isize) -> isize {\n    n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()\n}\n\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    match lst.into_iter().filter(is_prime).max() {\n        Some(max_prime) => digit_sum(max_prime),\n        None => 0,\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n"},{"task_id":"HumanEval_95","nl":"jav_Latn","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ Tuladha: \/\/\/ Fungsi kudu bali palsu yen HashMap diwenehi kosong. \/\/\/ kasus utawa kabeh tombol strings ing huruf gedhe, yen ora bali palsu. \/\/\/ Given a HashMap, bali bener yen kabeh tombol strings ing ngisor \/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n\/\/\/ true\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n\/\/\/ false\n\/\/\/ >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n\/\/\/ true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n","canonical_solution":"use std::collections::HashMap;\n\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return false;\n    }\n\n    let mut lowercase = true;\n    let mut uppercase = true;\n\n    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_lowercase()) {\n            lowercase = false;\n        }\n        if !key.chars().all(|c| c.is_uppercase()) {\n            uppercase = false;\n        }\n    }\n\n    lowercase || uppercase\n}\n\nfn main() {\n    let dict1 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict1), true);\n\n    let dict2 = HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]);\n    assert_eq!(check_dict_case(dict2), false);\n\n    let dict3 = HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]);\n    assert_eq!(check_dict_case(dict3), true);\n\n    let dict4 = HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]);\n    assert_eq!(check_dict_case(dict4), false);\n}","tests":"}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"},{"task_id":"HumanEval_96","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ contoné: \/\/\/ wilangan bulat sing wilangan prima lan kurang saka n. \/\/\/ Ngleksanakake fungsi sing njupuk integer non-negatif lan ngasilake vektor saka n pisanan \/\/\/ >>> count_up_to(5)\n\/\/\/ vec![2, 3]\n\/\/\/ >>> count_up_to(11)\n\/\/\/ vec![2, 3, 5, 7]\n\/\/\/ >>> count_up_to(0)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(20)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n\/\/\/ >>> count_up_to(1)\n\/\/\/ Vec::<isize>::new()\n\/\/\/ >>> count_up_to(18)\n\/\/\/ vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n","canonical_solution":"fn count_up_to(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n\n    for num in 2..n {\n        let mut is_prime = true;\n\n        for divisor in 2..=((num as f64).sqrt() as isize) {\n            if num % divisor == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n\n        if is_prime {\n            primes.push(num);\n        }\n    }\n\n    primes\n}\n\nfn main() {\n    println!(\"{:?}\", count_up_to(5)); \/\/ vec![2, 3]\n    println!(\"{:?}\", count_up_to(11)); \/\/ vec![2, 3, 5, 7]\n    println!(\"{:?}\", count_up_to(0)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(20)); \/\/ vec![2, 3, 5, 7, 11, 13, 17, 19]\n    println!(\"{:?}\", count_up_to(1)); \/\/ Vec::<isize>::new()\n    println!(\"{:?}\", count_up_to(18)); \/\/ vec![2, 3, 5, 7, 11, 13, 17]\n}","tests":"}\n\nfn main() {\n    let candidate = count_up_to;\n    assert_eq!(candidate(5), vec![2, 3]);\n    assert_eq!(candidate(6), vec![2, 3, 5]);\n    assert_eq!(candidate(7), vec![2, 3, 5]);\n    assert_eq!(candidate(10), vec![2, 3, 5, 7]);\n    assert_eq!(candidate(0), Vec::<isize>::new());\n    assert_eq!(candidate(22), vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    assert_eq!(candidate(1), Vec::<isize>::new());\n    assert_eq!(candidate(18), vec![2, 3, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(47), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n    assert_eq!(candidate(101), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}\n"},{"task_id":"HumanEval_97","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Anggep input tansah bener. \/\/\/ produk saka digit unit. \/\/\/ Rampungake fungsi sing njupuk loro wilangan bulat lan ngasilake \/\/\/ >>> multiply(148, 412)\n\/\/\/ 16\n\/\/\/ >>> multiply(19, 28)\n\/\/\/ 72\n\/\/\/ >>> multiply(2020, 1851)\n\/\/\/ 0\n\/\/\/ >>> multiply(14, -15)\n\/\/\/ 20\nfn multiply(a: isize, b: isize) -> isize {\n","canonical_solution":"fn multiply(a: isize, b: isize) -> isize {\n    let unit_digit_a = (a % 10).abs();\n    let unit_digit_b = (b % 10).abs();\n    unit_digit_a * unit_digit_b\n}","tests":"}\n\nfn main() {\n    let candidate = multiply;\n    assert_eq!(candidate(148, 412), 16);\n    assert_eq!(candidate(19, 28), 72);\n    assert_eq!(candidate(2020, 1851), 0);\n    assert_eq!(candidate(14, -15), 20);\n    assert_eq!(candidate(76, 67), 42);\n    assert_eq!(candidate(17, 27), 49);\n    assert_eq!(candidate(0, 1), 0);\n    assert_eq!(candidate(0, 0), 0);\n}\n"},{"task_id":"HumanEval_98","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Given a string s, count the number of uppercase vowels in even indices. \/\/\/ >>> count_upper(String::from(\"aBCdEf\"))\n\/\/\/ 1\n\/\/\/ >>> count_upper(String::from(\"abcdefg\"))\n\/\/\/ 0\n\/\/\/ >>> count_upper(String::from(\"dBBE\"))\n\/\/\/ 0\nfn count_upper(s: String) -> isize {\n","canonical_solution":"fn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(i, c)| {\n        *i % 2 == 0 && matches!(c, 'A' | 'E' | 'I' | 'O' | 'U')\n    }).count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"},{"task_id":"HumanEval_99","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ saka rong wilangan bulat, bunder saka nol. \/\/\/ lan ngasilake wilangan bulat sing paling cedhak. Yen nomer iku equidistant \/\/\/ Nggawe fungsi sing njupuk nilai (string) sing makili nomer \/\/\/ >>> closest_integer(String::from(\"10\"))\n\/\/\/ 10\n\/\/\/ >>> closest_integer(String::from(\"15.3\"))\n\/\/\/ 15\n\/\/\/ Note:\n\/\/\/ Rounding away from zero means that if the given number is equidistant\n\/\/\/ from two integers, the one you should return is the one that is the\n\/\/\/ farthest from zero. For example closest_integer(\"14.5\") should\n\/\/\/ return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n","canonical_solution":"fn closest_integer(value: String) -> isize {\n    let num: f64 = value.parse().expect(\"Invalid number format\");\n    if num.fract().abs() == 0.5 {\n        if num.is_sign_positive() {\n            num.ceil() as isize\n        } else {\n            num.floor() as isize\n        }\n    } else {\n        num.round() as isize\n    }\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", closest_integer(String::from(\"10\")));   \/\/ Output: 10\n    println!(\"{}\", closest_integer(String::from(\"15.3\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"14.5\"))); \/\/ Output: 15\n    println!(\"{}\", closest_integer(String::from(\"-14.5\"))); \/\/ Output: -15\n}","tests":"}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"},{"task_id":"HumanEval_100","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ i nggambarake jumlah watu ing tingkat (i + 1). \/\/\/ Mbalekake nomer watu ing saben tingkat ing vektor, ing endi unsur ing indeks \/\/\/ - nomer malah sabanjuré yen n malah. \/\/\/ - nomer ganjil sabanjure yen n ganjil. \/\/\/ Jumlah watu ing tingkat sabanjuré yaiku: \/\/\/ Tingkat pisanan nduweni n watu. \/\/\/ Given a integer positif n, sampeyan kudu nggawe tumpukan n tingkat saka watu. \/\/\/ >>> make_a_pile(3)\n\/\/\/ vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n","canonical_solution":"fn make_a_pile(n: isize) -> Vec<isize> {\n    let mut pile = Vec::new();\n    let mut current = n;\n    \n    for _ in 0..n {\n        pile.push(current);\n        current = if n % 2 == 1 {\n            current + 2\n        } else {\n            current + 2\n        };\n    }\n    \n    pile\n}\n\nfn main() {\n    let level = make_a_pile(3);\n    println!(\"{:?}\", level);\n}","tests":"}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3), vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5), vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"},{"task_id":"HumanEval_101","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ kanggo misahake senar dadi tembung lan bali vektor tembung. \/\/\/ Sampeyan bakal diwenehi senar tembung dipisahake dening koma utawa spasi.\/\/\/ >>> words_string(String::from(\"Hi, my name is John\"))\n\/\/\/ vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n\/\/\/ >>> words_string(String::from(\"One, two, three, four, five, six\"))\n\/\/\/ vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n","canonical_solution":"fn words_string(s: String) -> Vec<String> {\n    s.split(|c: char| c.is_whitespace() || c == ',')\n        .filter(|word| !word.is_empty())\n        .map(String::from)\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = words_string;\n    assert_eq!(candidate(String::from(\"Hi, my name is John\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]);\n    assert_eq!(candidate(String::from(\"One, two, three, four, five, six\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"Hi, my name\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\")]);\n    assert_eq!(candidate(String::from(\"One,, two, three, four, five, six,\")), vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"\")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"ahmed     , gamal\")), vec![String::from(\"ahmed\"), String::from(\"gamal\")]);\n}\n"},{"task_id":"HumanEval_102","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ ora ana nomer kuwi, banjur fungsi kudu bali -1. \/\/\/ nomer paling gedhé sing ana ing kisaran [x, y] kalebu.\/\/\/ Fungsi iki njupuk loro nomer positif x lan y lan ngasilake \/\/\/ >>> choose_num(12, 15)\n\/\/\/ 14\n\/\/\/ >>> choose_num(13, 12)\n\/\/\/ -1\nfn choose_num(x: isize, y: isize) -> isize {\n","canonical_solution":"fn choose_num(x: isize, y: isize) -> isize {\n    let (start, end) = if x < y { (x, y) } else { (y, x) };\n    for n in (start..=end).rev() {\n        if n % 2 == 0 {\n            return n;\n        }\n    }\n    -1\n}\n\nfn main() {\n    println!(\"{}\", choose_num(12, 15)); \/\/ 14\n    println!(\"{}\", choose_num(13, 12)); \/\/ -1\n}","tests":"}\n\nfn main() {\n    let candidate = choose_num;\n    assert_eq!(candidate(12, 15), 14);\n    assert_eq!(candidate(13, 12), -1);\n    assert_eq!(candidate(33, 12354), 12354);\n    assert_eq!(candidate(5234, 5233), -1);\n    assert_eq!(candidate(6, 29), 28);\n    assert_eq!(candidate(27, 10), -1);\n    assert_eq!(candidate(7, 7), -1);\n    assert_eq!(candidate(546, 546), 546);\n}\n"},{"task_id":"HumanEval_104","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Cathetan: Vektor sing dibalekake kudu diurutake kanthi nambah. \/\/\/ unsur sing ora duwe digit malah. \/\/\/ Given a vektor saka wilangan bulat positif x. bali vektor diurutake kabeh \/\/\/ >>> unique_digits(vec![15, 33, 1422, 1])\n\/\/\/ vec![1, 15, 33]\n\/\/\/ >>> unique_digits(vec![152, 323, 1422, 10])\n\/\/\/ Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize> = x.into_iter()\n        .filter(|&num| {\n            num.to_string().chars().all(|c| {\n                match c {\n                    '0' | '2' | '4' | '6' | '8' => false,\n                    _ => true,\n                }\n            })\n        })\n        .collect();\n    result.sort();\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = unique_digits;\n    assert_eq!(candidate(vec![15, 33, 1422, 1]), vec![1, 15, 33]);\n    assert_eq!(candidate(vec![152, 323, 1422, 10]), Vec::<isize>::new());\n    assert_eq!(candidate(vec![12345, 2033, 111, 151]), vec![111, 151]);\n    assert_eq!(candidate(vec![135, 103, 31]), vec![31, 135]);\n}\n"},{"task_id":"HumanEval_105","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ \"Siji\", \"Loro\", \"Telung\", \"Papat\", \"Lima\", \"Enem\", \"Pitung\", \"Wolu\", \"Sembilan\". \/\/\/ mbalikke vektor sing diasilake, banjur ganti saben digit kanthi jeneng sing cocog saka \/\/\/ Given a vektor saka wilangan bulat, ngurutake wilangan bulat sing antarane 1 lan 9 klebu, \/\/\/ >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n\/\/\/ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n\/\/\/ If the vector is empty, return an empty vector:\n\/\/\/ >>> by_length(vec![])\n\/\/\/ Vec::<String>::new()\n\/\/\/ If the vector has any strange number ignore it:\n\/\/\/ >>> by_length(vec![1, -1, 55])\n\/\/\/ vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n","canonical_solution":"fn by_length(arr: Vec<isize>) -> Vec<String> {\n    let digit_names = [\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \n        \"Six\", \"Seven\", \"Eight\", \"Nine\",\n    ];\n\n    let mut filtered: Vec<isize> = arr.into_iter()\n        .filter(|&x| x >= 1 && x <= 9)\n        .collect();\n\n    filtered.sort();\n    filtered.reverse();\n\n    filtered.into_iter()\n        .map(|x| String::from(digit_names[(x - 1) as usize]))\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"},{"task_id":"HumanEval_106","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ faktoril i yaiku perkalian nomer saka 1 nganti i (1 * 2 * ... * i). \/\/\/ i diwiwiti saka 1. \/\/\/ utawa jumlah nomer saka 1 nganti i. \/\/\/ lan ngasilake vektor ukuran n, saengga nilai unsur ing indeks i yaiku faktoril i yen i malah \/\/\/ Ngleksanakake fungsi f sing njupuk n minangka parameter, \/\/\/ >>> f(5)\n\/\/\/ vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n","canonical_solution":"fn f(n: isize) -> Vec<isize> {\n    fn factorial(x: isize) -> isize {\n        (1..=x).product()\n    }\n\n    fn sum_up_to(x: isize) -> isize {\n        (1..=x).sum()\n    }\n\n    (1..=n)\n        .map(|i| if i % 2 == 0 { factorial(i) } else { sum_up_to(i) })\n        .collect()\n}","tests":"}\n\nfn main() {\n    let candidate = f;\n    assert_eq!(candidate(5), vec![1, 2, 6, 24, 15]);\n    assert_eq!(candidate(7), vec![1, 2, 6, 24, 15, 720, 28]);\n    assert_eq!(candidate(1), vec![1]);\n    assert_eq!(candidate(3), vec![1, 2, 6]);\n}\n"},{"task_id":"HumanEval_107","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha 1: \/\/\/ palindrom integer sing ana ing kisaran ((1, n), kalebu. \/\/\/ Given a integer positif n, bali tuple sing wis nomer malah lan aneh \/\/\/ >>> even_odd_palindrome(3)\n\/\/\/ (1, 2)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\/\/\/ Example 2:\n\/\/\/ >>> even_odd_palindrome(12)\n\/\/\/ (4, 6)\n\/\/\/ Explanation:\n\/\/\/ Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\/\/\/ Note:\n\/\/\/ 1. 1 <= n <= 10^3\n\/\/\/ 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n","canonical_solution":"fn is_palindrome(x: isize) -> bool {\n    let s = x.to_string();\n    s == s.chars().rev().collect::<String>()\n}\n\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    \n    for i in 1..=n {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_palindrome;\n    assert_eq!(candidate(123), (8, 13));\n    assert_eq!(candidate(12), (4, 6));\n    assert_eq!(candidate(3), (1, 2));\n    assert_eq!(candidate(63), (6, 8));\n    assert_eq!(candidate(25), (5, 6));\n    assert_eq!(candidate(19), (4, 6));\n    assert_eq!(candidate(9), (4, 5));\n    assert_eq!(candidate(1), (0, 1));\n}\n"},{"task_id":"HumanEval_108","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ contoné -123 duwé tandha angka -1, 2, lan 3. \/\/\/ Yen nomer negatif, banjur digit pisanan ditandatangani bakal negatif: \/\/\/ nomer unsur sing jumlah digit > 0. \/\/\/ Tulis fungsi count_nums kang njupuk vektor saka wilangan bulat lan ngasilake \/\/\/ >>> count_nums(vec![])\n\/\/\/ 0\n\/\/\/ >>> count_nums(vec![-1, 11, -11])\n\/\/\/ 1\n\/\/\/ >>> count_nums(vec![1, 1, 2])\n\/\/\/ 3\nfn count_nums(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn count_nums(arr: Vec<isize>) -> isize {\n    arr.into_iter()\n        .filter(|&num| {\n            let mut n = num;\n            let mut sum = 0;\n            let mut is_first_digit = true;\n\n            while n != 0 {\n                let digit = if is_first_digit {\n                    is_first_digit = false;\n                    n % 10\n                } else {\n                    (n % 10).abs()\n                };\n                sum += digit;\n                n \/= 10;\n            }\n            sum > 0\n        })\n        .count() as isize\n}","tests":"}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n"},{"task_id":"HumanEval_109","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Cathetan: Vektor sing diwenehake dijamin duwe unsur unik. \/\/\/ Yen vektor diwenehi kosong banjur bali bener. \/\/\/ banjur bali bener utawa bali palsu. \/\/\/ Yen iku bisa kanggo njaluk vektor diurutake dening Performing operasi ndhuwur \/\/\/ posisi wiwitan ing vektor yaiku indeks 0th. \/\/\/ posisi ing arah sing bener. unsur pungkasan saka vektor bakal dipindhah menyang \/\/\/ Siji operasi shift tengen tegese obah kabeh unsur vektor dening siji \/\/\/ Sampeyan diijini nindakake operasi shift tengen sembarang nomer kaping. \/\/\/ operasi ing ngisor iki ing vektor sing diwenehake: \/\/\/ iku bisa kanggo njaluk vektor diurutake ing non-mundhak urutan dening Performing \/\/\/ nomer ing vektor bakal acak supaya. tugas Panjenengan kanggo nemtokake yen \/\/\/ Kita duwe vektor 'arr' saka N wilangan bulat arr[1], arr[2], ..., arr[N]. \/\/\/ >>> move_one_ball(vec![3, 4, 5, 1, 2])\n\/\/\/ true\n\/\/\/ Explanation: By performin 2 right shift operations, non-decreasing order can\n\/\/\/ be achieved for the given vector.\n\/\/\/ >>> move_one_ball(vec![3, 5, 4, 1, 2])\n\/\/\/ false\n\/\/\/ Explanation:It is not possible to get non-decreasing order for the given\n\/\/\/ vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n","canonical_solution":"fn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.is_empty() {\n        return true; \/\/ An empty array is already considered sorted.\n    }\n    \n    let mut break_point = 0;\n    let mut break_found = false;\n    let len = arr.len();\n\n    for i in 0..len {\n        if arr[i] > arr[(i + 1) % len] {\n            if break_found {\n                return false;  \/\/ Found more than one break point, not possible.\n            }\n            break_point = i + 1;\n            break_found = true;\n        }\n    }\n    \n    \/\/ After finding a single break point, simulate the right shift by 'break_point'\n    for i in 0..len {\n        if arr[(break_point + i) % len] > arr[(break_point + i + 1) % len] {\n            return false; \/\/ Not sorted in non-decreasing order with this shift.\n        }\n    }\n    \n    true\n}\n\n\/\/ Example usages:\n\n\/\/ This will return true, as we can shift twice to sort it.\nassert_eq!(move_one_ball(vec![3, 4, 5, 1, 2]), true);\n\n\/\/ This will return false, as we can't sort this by any number of shifts.\nassert_eq!(move_one_ball(vec![3, 5, 4, 1, 2]), false);","tests":"}\n\nfn main() {\n    let candidate = move_one_ball;\n    assert_eq!(candidate(vec![3, 4, 5, 1, 2]), true);\n    assert_eq!(candidate(vec![3, 5, 10, 1, 2]), true);\n    assert_eq!(candidate(vec![4, 3, 1, 2]), false);\n    assert_eq!(candidate(vec![3, 5, 4, 1, 2]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n}\n"},{"task_id":"HumanEval_110","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Yen ora, bali \"Ora\". \/\/\/ kabeh unsur lst1 kanggo dadi malah, bali \"YES\". \/\/\/ Yen iku bisa kanggo ijolan unsur antarane lst1 lan lst2 kanggo nggawe \/\/\/ Ora ana watesan ing nomer unsur sing ijol-ijolan antarane lst1 lan lst2. \/\/\/ antarane wong-wong mau kanggo nggawe lst1 vektor saka malah nomer mung. \/\/\/ lan nemtokake manawa bisa nindakake ijol-ijolan unsur \/\/Ing masalah iki, sampeyan bakal ngleksanakake fungsi sing njupuk rong vektor nomer, \/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n\/\/\/ String::from(\"YES\")\n\/\/\/ >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n\/\/\/ String::from(\"NO\")\n\/\/\/ It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n","canonical_solution":"fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut even_in_lst2 = false;\n    for &num in &lst2 {\n        if num % 2 == 0 {\n            even_in_lst2 = true;\n            break;\n        }\n    }\n\n    if even_in_lst2 {\n        for &num in &lst1 {\n            if num % 2 != 0 {\n                return String::from(\"YES\");\n            }\n        }\n        return String::from(\"YES\");\n    }\n\n    String::from(\"NO\")\n}\n\nfn main() {\n    \/\/ Example cases\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])); \/\/ \"YES\"\n    println!(\"{}\", exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])); \/\/ \"NO\"\n}","tests":"}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200, 200]), String::from(\"YES\"));\n}\n"},{"task_id":"HumanEval_111","nl":"jav_Latn","pl":"rs","prompt":"use std::collections::HashMap;\n\n\/\/\/ Tuladha: \/\/\/ Yen sawetara huruf duwe kedadeyan sing padha, bali kabeh. \/\/\/ saka huruf karo paling repetition lan ngemot count cocog. \/\/\/ Given a string representing a space separated lowercase letters, return a HashMap \/\/\/ >>> histogram(String::from(\"a b c\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\/\/\/ >>> histogram(String::from(\"a b b a\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"a b c a b\"))\n\/\/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\/\/\/ >>> histogram(String::from(\"b b b b a\"))\n\/\/\/ HashMap::from([(String::from(\"b\"), 4)])\n\/\/\/ >>> histogram(String::from(\"\"))\n\/\/\/ HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n","canonical_solution":"use std::collections::HashMap;\n\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut counts: HashMap<String, isize> = HashMap::new();\n    let mut max_count = 0;\n\n    for letter in test.split_whitespace() {\n        let count = counts.entry(letter.to_string()).or_insert(0);\n        *count += 1;\n        if *count > max_count {\n            max_count = *count;\n        }\n    }\n\n    counts.retain(|_, &mut val| val == max_count);\n    counts\n}\n\nfn main() {\n    let result = histogram(String::from(\"a b c\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n\n    let result = histogram(String::from(\"a b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"a b c a b\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n\n    let result = histogram(String::from(\"b b b b a\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([(String::from(\"b\"), 4)])\n\n    let result = histogram(String::from(\"\"));\n    println!(\"{:?}\", result); \/\/ HashMap::from([])\n}","tests":"}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")), HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"a\"), 1)]));\n}\n"},{"task_id":"HumanEval_112","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ Sampeyan kudu bali tuple ngemot strings asil lan bener \/ palsu kanggo mriksa. \/\/\/ String diarani palindrome yen maca padha mburi minangka maju. \/\/\/ banjur priksa manawa asil senar iku palindrom. \/\/\/ Kita diwenehi loro senar s lan c, sampeyan kudu mbusak kabeh karakter ing s sing padha karo karakter ing c \/\/\/ Tugas \/\/\/ >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n\/\/\/ (String::from(\"bcd\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n\/\/\/ (String::from(\"acdef\"), false)\n\/\/\/ >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n\/\/\/ (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n","canonical_solution":"fn reverse_delete(s: String, c: String) -> (String, bool) {\n    \/\/ Create a set of characters to delete for quick lookup\n    let delete_chars: std::collections::HashSet<char> = c.chars().collect();\n    \n    \/\/ Filter the string, keeping only characters not in the delete set\n    let filtered: String = s.chars().filter(|ch| !delete_chars.contains(ch)).collect();\n    \n    \/\/ Check if the filtered string is a palindrome\n    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();\n    \n    \/\/ Return the filtered string and whether it's a palindrome\n    (filtered, is_palindrome)\n}","tests":"}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"},{"task_id":"HumanEval_113","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ saka digit ganjil ing senar i'th saka input. \/\/\/ string i saka input. \" ngendi kabeh i kudu diganti karo nomer \/\/\/ Saben unsur i saka output kudu \"nomer unsur ganjil ing \/\/\/ Given a vektor strings, ngendi saben senar kasusun saka mung digit, bali vektor. \/\/\/ >>> odd_count(vec![String::from(\"1234567\")])\n\/\/\/ vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n\/\/\/ >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n\/\/\/ vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn odd_count(lst: Vec<String>) -> Vec<String> {\n    lst.iter()\n        .map(|s| {\n            let odd_count = s.chars().filter(|&c| {\n                match c {\n                    '1' | '3' | '5' | '7' | '9' => true,\n                    _ => false,\n                }\n            }).count();\n            format!(\"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\", odd_count)\n        })\n        .collect()\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result = odd_count(vec![String::from(\"1234567\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ \n\/\/     let result = odd_count(vec![String::from(\"3\"), String::from(\"11111111\")]);\n\/\/     println!(\"{:?}\", result);\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = odd_count;\n    assert_eq!(candidate(vec![String::from(\"1234567\")]), vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"3\"), String::from(\"11111111\")]), vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]);\n    assert_eq!(candidate(vec![String::from(\"271\"), String::from(\"137\"), String::from(\"314\")]), vec![String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\"), String::from(\"the number of odd elements 3n the str3ng 3 of the 3nput.\"), String::from(\"the number of odd elements 2n the str2ng 2 of the 2nput.\")]);\n}\n"},{"task_id":"HumanEval_114","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ saka nomer. \/\/\/ Given a vektor saka wilangan bulat n, golek jumlah minimal sembarang non-kosong sub-vektor \/\/\/ >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n\/\/\/ 1\n\/\/\/ >>> minSubArraySum(vec![-1, -2, -3])\n\/\/\/ -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut min_sum = nums[0];\n    let mut current_sum = nums[0];\n\n    for &num in nums.iter().skip(1) {\n        current_sum = current_sum.min(current_sum + num);\n        min_sum = min_sum.min(current_sum);\n    }\n\n    min_sum\n}","tests":"}\n\nfn main() {\n    let candidate = minSubArraySum;\n    assert_eq!(candidate(vec![2, 3, 4, 1, 2, 4]), 1);\n    assert_eq!(candidate(vec![-1, -2, -3]), -6);\n    assert_eq!(candidate(vec![-1, -2, -3, 2, -10]), -14);\n    assert_eq!(candidate(vec![-9999999999999999]), -9999999999999999);\n    assert_eq!(candidate(vec![0, 10, 20, 1000000]), 0);\n    assert_eq!(candidate(vec![-1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![100, -1, -2, -3, 10, -5]), -6);\n    assert_eq!(candidate(vec![10, 11, 13, 8, 3, 4]), 3);\n    assert_eq!(candidate(vec![100, -33, 32, -1, 0, -2]), -33);\n    assert_eq!(candidate(vec![-10]), -10);\n    assert_eq!(candidate(vec![7]), 7);\n    assert_eq!(candidate(vec![1, -1]), -1);\n}\n"},{"task_id":"HumanEval_115","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha 1: \/\/\/ Output nomer kaping sampeyan kudu kanggo mudhun ember. \/\/\/ Tugasmu yaiku nggunakake ember kanggo kosongake sumur. \/\/\/ lan kabeh ember duwe kapasitas sing padha. \/\/\/ Saben sumur duwe ember sing cocog sing bisa digunakake kanggo ngekstrak banyu saka kono, \/\/\/ lan saben 1 ing baris makili unit banyu tunggal. \/\/\/ Sampeyan diwenehi kothak persegi panjang sumur. saben baris makili sumur siji, \/\/\/ >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n\/\/\/ 6\n\/\/\/ Example 2:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n\/\/\/ 5\n\/\/\/ Example 3:\n\/\/\/ >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n\/\/\/ 0\n\/\/\/ Constraints:\n\/\/\/ * all wells have the same length\n\/\/\/ * 1 <= grid.length <= 10^2\n\/\/\/ * 1 <= grid[:,1].length <= 10^2\n\/\/\/ * grid[i][j] -> 0 | 1\n\/\/\/ * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n","canonical_solution":"fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total_water_units = 0;\n\n    for row in grid.iter() {\n        for &unit in row.iter() {\n            total_water_units += unit;\n        }\n    }\n\n    \/\/ Calculate how many times we need to lower the bucket to extract all water units\n    (total_water_units + capacity - 1) \/ capacity\n}\n\nfn main() {\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)); \/\/ 6\n    println!(\"{}\", max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)); \/\/ 5\n    println!(\"{}\", max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"},{"task_id":"HumanEval_116","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Sampeyan kudu dileksanakake kaya iki: \/\/\/ Kanggo nomer sing padha, atur adhedhasar nilai desimal. \/\/\/ nomer siji ing perwakilan binar kanthi urutan munggah. \/\/Ing kata iki, sampeyan kudu nyortir vektor saka wilangan bulat non-negatif miturut \/\/\/ >>> sort_array(vec![1, 5, 2, 3, 4])\n\/\/\/ vec![1, 2, 3, 4, 5]\n\/\/\/ >>> sort_array(vec![-2, -3, -4, -5, -6])\n\/\/\/ vec![-6, -5, -4, -3, -2]\n\/\/\/ >>> sort_array(vec![1, 0, 2, 3, 4])\n\/\/\/ vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_by(|&a, &b| {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n        if ones_a == ones_b {\n            a.cmp(&b)\n        } else {\n            ones_a.cmp(&ones_b)\n        }\n    });\n    arr\n}\n\nfn main() {\n    println!(\"{:?}\", sort_array(vec![1, 5, 2, 3, 4])); \/\/ Output: [1, 2, 3, 4, 5]\n    println!(\"{:?}\", sort_array(vec![-2, -3, -4, -5, -6])); \/\/ Output: [-6, -5, -4, -3, -2]\n    println!(\"{:?}\", sort_array(vec![1, 0, 2, 3, 4])); \/\/ Output: [0, 1, 2, 3, 4]\n}","tests":"}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1, 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4, -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3, 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]), vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2, 4, 8, 16, 32]);\n}\n"},{"task_id":"HumanEval_117","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Cathetan: sampeyan bisa nganggep senar input ngemot mung huruf lan spasi. \/\/\/ Yen senar s kosong banjur fungsi kudu bali vektor kosong. \/\/\/ n konsonan, supaya tembung-tembung kasebut katon ing senar s. \/\/\/ fungsi sing ngasilake vektor kabeh tembung saka senar s sing ngemot persis \/\/\/ Given a string s lan nomer alam n, sampeyan wis diutus kanggo ngleksanakake \/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\/\/\/ vec![String::from(\"little\")]\n\/\/\/ >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n\/\/\/ vec![String::from(\"Mary\"), String::from(\"lamb\")]\n\/\/\/ >>> select_words(String::from(\"simple white space\"), 2)\n\/\/\/ Vec::<String>::new()\n\/\/\/ >>> select_words(String::from(\"Hello world\"), 4)\n\/\/\/ vec![String::from(\"world\")]\n\/\/\/ >>> select_words(String::from(\"Uncle sam\"), 3)\n\/\/\/ vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n","canonical_solution":"fn select_words(s: String, n: isize) -> Vec<String> {\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let mut result = Vec::new();\n\n    for word in s.split_whitespace() {\n        let consonant_count = word.chars().filter(|c| consonants.contains(*c)).count();\n        if consonant_count == n as usize {\n            result.push(word.to_string());\n        }\n    }\n\n    result\n}","tests":"}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"},{"task_id":"HumanEval_118","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Sampeyan bisa nganggep yen string diwenehi ngandhut huruf Inggris mung. \/\/\/ nemokake vokal sing cocog karo kahanan ing ndhuwur. \/\/\/ Vowels ing awal lan pungkasan ora count. Mbalik kosong senar yen sampeyan ora \/\/\/ rong konsonan saka sisih tengen tembung (case sensitive). \/\/\/ Sampeyan diwenehi tembung. tugas Panjenengan iku kanggo nemokake vokal cedhak sing stands antarane \/\/\/ >>> get_closest_vowel(String::from(\"yogurt\"))\n\/\/\/ String::from(\"u\")\n\/\/\/ >>> get_closest_vowel(String::from(\"FULL\"))\n\/\/\/ String::from(\"U\")\n\/\/\/ >>> get_closest_vowel(String::from(\"quick\"))\n\/\/\/ String::from(\"\")\n\/\/\/ >>> get_closest_vowel(String::from(\"ab\"))\n\/\/\/ String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n","canonical_solution":"fn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let chars: Vec<char> = word.chars().collect();\n    if chars.len() < 3 {\n        return String::from(\"\");\n    }\n\n    for i in (1..chars.len() - 1).rev() {\n        if vowels.contains(chars[i]) && !vowels.contains(chars[i-1]) && !vowels.contains(chars[i+1]) {\n            return chars[i].to_string();\n        }\n    }\n    String::from(\"\")\n}","tests":"}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"},{"task_id":"HumanEval_119","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Bali 'Ya' yen ana cara kanggo nggawe senar apik, lan bali 'Ora' yen ora. \/\/\/ \"()) ' ora. \/\/\/ seimbang. Contone: senar '(())))' apik, dene senar \/\/\/ String S dianggep apik yen lan mung yen kabeh kurung ing S \/\/\/ sawetara supaya, sing strings asil bakal apik. \/\/\/ Tugasmu yaiku mriksa manawa bisa ngiket loro senar kasebut \/\/\/ kurung \" ((\" utawa kurung cedhak \") \" mung. \/\/\/ Sampeyan diwenehi vektor saka rong senar, loro senar kasusun saka mbukak \/\/\/ >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n\/\/\/ String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n","canonical_solution":"fn match_parens(lst: Vec<String>) -> String {\n    fn is_balanced(s: &str) -> bool {\n        let mut balance = 0;\n        for ch in s.chars() {\n            if ch == '(' {\n                balance += 1;\n            } else {\n                balance -= 1;\n            }\n            if balance < 0 {\n                return false;\n            }\n        }\n        balance == 0\n    }\n\n    if lst.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let s1 = &lst[0];\n    let s2 = &lst[1];\n\n    let combined1 = format!(\"{}{}\", s1, s2);\n    let combined2 = format!(\"{}{}\", s2, s1);\n\n    if is_balanced(&combined1) || is_balanced(&combined2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"(())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\")(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"},{"task_id":"HumanEval_120","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha 1: \/\/\/ dawa k kanthi nomer maksimal k ing arr. \/\/\/ Given a vektor arr saka wilangan bulat lan positif wilangan bulat k, bali vektor diurutake \/\/\/ >>> maximum(vec![-3, -4, 5], 3)\n\/\/\/ vec![-4, -3, 5]\n\/\/\/ Example 2:\n\/\/\/ >>> maximum(vec![4, -4, 4], 2)\n\/\/\/ vec![4, 4]\n\/\/\/ Example 3:\n\/\/\/ >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n\/\/\/ vec![2]\n\/\/\/ Note:\n\/\/\/ 1. The length of the vector will be in the range of [1, 1000].\n\/\/\/ 2. The elements in the vector will be in the range of [-1000, 1000].\n\/\/\/ 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_unstable_by(|a, b| b.cmp(a));\n    let k = k as usize;\n    let mut result: Vec<isize> = arr.into_iter().take(k).collect();\n    result.sort_unstable();\n    result\n}\n\nfn main() {\n    assert_eq!(maximum(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(maximum(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n}","tests":"}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3, -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4, 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n    assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0, 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4, -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10, 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n}\n"},{"task_id":"HumanEval_121","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ Given a non-kosong vektor saka wilangan bulat, bali jumlah kabeh unsur ganjil sing ing malah posisi. \/\/\/ >>> solution(vec![5, 8, 7, 1])\n\/\/\/ 12\n\/\/\/ >>> solution(vec![3, 3, 3, 3, 3])\n\/\/\/ 9\n\/\/\/ >>> solution(vec![30, 13, 24, 321])\n\/\/\/ 0\nfn solution(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn solution(lst: Vec<isize>) -> isize {\n    lst.iter()\n        .enumerate()\n        .filter(|(i, &x)| i % 2 == 0 && x % 2 != 0)\n        .map(|(_, &x)| x)\n        .sum()\n}","tests":"}\n\nfn main() {\n    let candidate = solution;\n    assert_eq!(candidate(vec![5, 8, 7, 1]), 12);\n    assert_eq!(candidate(vec![3, 3, 3, 3, 3]), 9);\n    assert_eq!(candidate(vec![30, 13, 24, 321]), 0);\n    assert_eq!(candidate(vec![5, 9]), 5);\n    assert_eq!(candidate(vec![2, 4, 8]), 0);\n    assert_eq!(candidate(vec![30, 13, 23, 32]), 23);\n    assert_eq!(candidate(vec![3, 13, 2, 9]), 3);\n}\n"},{"task_id":"HumanEval_122","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ jumlah unsur kanthi paling ora rong digit saka k unsur pertama arr. \/\/\/ Given a non-empty vector of integer arr lan integer k, return \/\/\/ >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n\/\/\/ 24\n\/\/\/ Constraints:\n\/\/\/ 1. 1 <= len(arr) <= 100\n\/\/\/ 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n","canonical_solution":"fn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    arr.iter()\n        .take(k as usize)\n        .filter(|&&x| x > -100 && x < 100)\n        .sum()\n}\n\nfn main() {\n    let result = add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);\n    println!(\"{}\", result);  \/\/ Output: 24\n}","tests":"}\n\nfn main() {\n    let candidate = add_elements;\n    assert_eq!(candidate(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n    assert_eq!(candidate(vec![111, 121, 3, 4000, 5, 6], 2), 0);\n    assert_eq!(candidate(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n    assert_eq!(candidate(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n    assert_eq!(candidate(vec![1], 1), 1);\n}\n"},{"task_id":"HumanEval_123","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ get_odd_collatz(5) ngasilake [1, 5] # Urutan collatz kanggo 5 yaiku [5, 16, 8, 4, 2, 1], mula nomer ganjil mung 1, lan 5. \/\/\/ Contoné: \/\/\/ 2. bali vektor diurutake kanthi nambah. \/\/\/ 1. Collatz(1) yaiku [1]. \/\/\/ Cathetan: \/\/\/ istilah plus 1. Konjeksi yaiku ora ketompo apa nilai n, urutan kasebut mesthi bakal tekan 1. \/\/\/ istilah sadurungé. Yen istilah sadurungé ganjil, istilah sabanjuré punika 3 kaping sadurunge \/\/\/ istilah sadurungé kaya ing ngisor iki: yen istilah sadurungé malah, istilah sabanjuré iku setengah saka \/\/\/ kaya ing ngisor iki: miwiti karo sembarang wilangan bulat positif n. Banjur saben istilah dijupuk saka \/\/\/ Konjektor Collatz minangka konjektor ing matematika sing gegayutan karo urutan sing ditemtokake \/\/\/ Given a integer positif n, bali vektor diurutake sing wis nomer aneh ing urutan collatz. \/\/\/ >>> get_odd_collatz(5)\n\/\/\/ vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n","canonical_solution":"fn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut sequence = Vec::new();\n    let mut current = n;\n\n    while current != 1 {\n        if current % 2 != 0 {\n            sequence.push(current);\n        }\n\n        if current % 2 == 0 {\n            current \/= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    \n    \/\/ Add the final odd number 1 if n is 1\n    sequence.push(1);\n\n    sequence.sort();\n    sequence\n}\n\nfn main() {\n    let result = get_odd_collatz(5);\n    println!(\"{:?}\", result); \/\/ Outputs: [1, 5]\n}","tests":"}\n\nfn main() {\n    let candidate = get_odd_collatz;\n    assert_eq!(candidate(14), vec![1, 5, 7, 11, 13, 17]);\n    assert_eq!(candidate(5), vec![1, 5]);\n    assert_eq!(candidate(12), vec![1, 3, 5]);\n    assert_eq!(candidate(1), vec![1]);\n}\n"},{"task_id":"HumanEval_124","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ 4. Tanggal kudu ing format: mm-dd-yyyy \/\/\/ 3. Wulan ora kudu kurang saka 1 utawa luwih saka 12. \/\/\/ 2. Jumlah dina ora kurang saka 1 utawa luwih saka 31 dina kanggo sasi 1,3,5,7,8,10,12. Lan nomer dina ora kurang saka 1 utawa luwih saka 30 dina kanggo sasi 4,6,9,11. Lan, nomer dina ora kurang saka 1 utawa luwih saka 29 kanggo sasi 2. \/\/\/ 1. string tanggal ora kosong. \/\/\/ Tanggal kasebut sah yen kabeh aturan ing ngisor iki wis kepenak: \/\/\/ ngasilake bener yen tanggal bener yen ora salah. \/\/\/ Sampeyan kudu nulis fungsi kang validates string tanggal diwenehi lan \/\/\/ >>> valid_date(String::from(\"03-11-2000\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"15-01-2012\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"04-0-2040\"))\n\/\/\/ false\n\/\/\/ >>> valid_date(String::from(\"06-04-2020\"))\n\/\/\/ true\n\/\/\/ >>> valid_date(String::from(\"06\/04\/2020\"))\n\/\/\/ false\nfn valid_date(date: String) -> bool {\n","canonical_solution":"fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return false;\n    }\n\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n\n    let maybe_month = parts[0].parse::<u32>();\n    let maybe_day = parts[1].parse::<u32>();\n    let maybe_year = parts[2].parse::<u32>();\n\n    if maybe_month.is_err() || maybe_day.is_err() || maybe_year.is_err() {\n        return false;\n    }\n\n    let month = maybe_month.unwrap();\n    let day = maybe_day.unwrap();\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n                return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n                return false;\n            }\n        }\n        2 => {\n            if day < 1 || day > 29 {\n                return false;\n            }\n        }\n        _ => return false, \/\/ This case should never be reached\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"},{"task_id":"HumanEval_126","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ nomer, bali palsu. Anggep ora ana nomer negatif lan mung wilangan bulat. \/\/\/ ing urutan munggah. Yen vektor wis luwih saka 1 duplikat padha \/\/\/ Given a vector of numbers, return whether or not they are sorted \/\/\/ >>> is_sorted(vec![5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n\/\/\/ false\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n\/\/\/ true\n\/\/\/ >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n\/\/\/ false\nfn is_sorted(lst: Vec<isize>) -> bool {\n","canonical_solution":"fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.is_empty() || lst.len() == 1 {\n        return true;\n    }\n    \n    let mut previous = lst[0];\n    let mut repeat_count = 0;\n\n    for &current in &lst[1..] {\n        if current < previous {\n            return false;\n        }\n        if current == previous {\n            repeat_count += 1;\n            if repeat_count >= 2 {\n                return false;\n            }\n        } else {\n            repeat_count = 0;\n        }\n        previous = current;\n    }\n\n    true\n}","tests":"}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n}\n"},{"task_id":"HumanEval_127","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ [input\/output] conto: \/\/\/ Yen rong interval ora intersect, bali \"Ora\". \/\/\/ Yen ora, bali \"Ora\". \/\/\/ Yen dawa persimpangan iku nomer dhasar, bali \"YA\", \/\/\/ kang dawane 1, kang ora wilangan prima. \/\/\/ Conto, persimpangan interval (1, 3), (2, 4) yaiku (2, 3) \/\/\/ interval iku nomer prima. \/\/\/ Tugas sampeyan yaiku nemtokake manawa dawa persimpangan saka loro iki \/\/\/ Kanggo saben interval tartamtu, diasumsikan yen wiwitan kurang utawa padha karo pungkasane. \/\/\/ kalebu loro wiwitan lan pungkasan. \/\/\/ Interval sing diwenehake ditutup sing tegese interval (wiwitan, pungkasan) \/\/\/ ing endi saben interval minangka pasangan saka wilangan bulat. Contone, interval = (wiwitan, pungkasan) = (1, 2). \/\/\/ Sampeyan diwenehi rong interval, \/\/\/ >>> intersection((1, 2), (2, 3))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-1, 1), (0, 4))\n\/\/\/ String::from(\"NO\")\n\/\/\/ >>> intersection((-3, -1), (-5, 5))\n\/\/\/ String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start_intersection = std::cmp::max(start1, start2);\n    let end_intersection = std::cmp::min(end1, end2);\n\n    if start_intersection <= end_intersection {\n        let length = (end_intersection - start_intersection + 1) as usize;\n        if is_prime(length) {\n            return String::from(\"YES\");\n        }\n    }\n    String::from(\"NO\")\n}\n\n\/\/ Example usage\nfn main() {\n    println!(\"{}\", intersection((1, 2), (2, 3))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-1, 1), (0, 4))); \/\/ \"NO\"\n    println!(\"{}\", intersection((-3, -1), (-5, 5))); \/\/ \"YES\"\n}","tests":"}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"},{"task_id":"HumanEval_128","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Cathetan: bali None kanggo ar kosong. \/\/\/ saben nomer ing vektor, diwakili dening 1, -1 utawa 0. \/\/\/ jumlah gedhene saka wilangan bulat dikalikan dening produk kabeh tandha \/\/\/ Sampeyan diwenehi vektor arr saka wilangan bulat lan sampeyan kudu bali \/\/\/ >>> prod_signs(vec![1, 2, 2, -4])\n\/\/\/ Some(9)\n\/\/\/ >>> prod_signs(vec![0, 1])\n\/\/\/ Some(0)\n\/\/\/ >>> prod_signs(vec![])\n\/\/\/ None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n","canonical_solution":"fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut sum_of_magnitudes = 0;\n    let mut product_of_signs = 1;\n\n    for &num in &arr {\n        sum_of_magnitudes += num.abs();\n        if num == 0 {\n            product_of_signs = 0;\n            break;\n        } else if num > 0 {\n            product_of_signs *= 1;\n        } else {\n            product_of_signs *= -1;\n        }\n    }\n\n    Some(sum_of_magnitudes * product_of_signs)\n}","tests":"}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n}\n"},{"task_id":"HumanEval_129","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Mbalekake vektor sing dipesen saka nilai ing sel sing dalan minimal. \/\/\/ Dijamin manawa wangsulane unik. \/\/\/ lst_A[j] = lst_B[j]. \/\/\/ kaya lst_A[i] < lst_B[i] lan kanggo sembarang j (1 <= j < i) kita duwe \/\/\/ saka lst_B, ing tembung liyane, ana ana ana indeks integer i (1 <= i <= k) \/\/\/ liwat (ayo padha nelpon lst_A lan lst_B), lst_A kurang lexicographically \/\/\/ sawise nggawe vektor dipesen saka angka ing sel sing A lan B pindhah \/\/\/ Jalur A (dawa k) dianggep luwih cilik tinimbang jalur B (dawa k) yen \/\/\/ Sampeyan ora bisa pindhah metu saka kothak. \/\/\/ mesthi beda). \/\/\/ Elinga yen dalan dawa k tegese ngunjungi sel k persis (ora \/\/\/ sel. \/\/\/ ing tembung liyane, sampeyan bisa pindhah menyang sel sing nuduhake pinggiran karo sampeyan saiki \/\/\/ saka sel apa wae, lan ing saben langkah sampeyan bisa pindhah menyang sel tetanggan, \/\/Sampeyan kudu nemokake path minimal dawa k ing kothak. Sampeyan bisa miwiti \/\/\/ kalebu katon persis sapisan ing sel kothak. \/\/\/ saben sel saka kothak ngemot nilai. Saben integer ing sawetara [1, N * N] \/\/\/ Given a kothak karo N larik lan N kolom (N > = 2) lan integer positif k, \/\/\/ >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n\/\/\/ vec![1, 2, 1]\n\/\/\/ >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n\/\/\/ vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n","canonical_solution":"fn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let n = grid.len();\n    let mut best_path = vec![];\n    let mut best_values = vec![isize::MAX; k as usize];\n    \n    fn dfs(\n        grid: &Vec<Vec<isize>>, \n        row: usize, \n        col: usize, \n        path: &mut Vec<(usize, usize)>, \n        values: &mut Vec<isize>, \n        k: isize, \n        best_values: &mut Vec<isize>\n    ) {\n        if path.len() == k as usize {\n            if values < best_values {\n                best_values.clone_from(values);\n            }\n            return;\n        }\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n        for &(dr, dc) in directions.iter() {\n            let new_row = row as isize + dr;\n            let new_col = col as isize + dc;\n            if new_row >= 0 && new_row < grid.len() as isize && new_col >= 0 && new_col < grid.len() as isize {\n                path.push((new_row as usize, new_col as usize));\n                values.push(grid[new_row as usize][new_col as usize]);\n                dfs(grid, new_row as usize, new_col as usize, path, values, k, best_values);\n                values.pop();\n                path.pop();\n            }\n        }\n    }\n\n    for r in 0..n {\n        for c in 0..n {\n            let mut path = vec![(r, c)];\n            let mut values = vec![grid[r][c]];\n            dfs(&grid, r, c, &mut path, &mut values, k, &mut best_values);\n        }\n    }\n\n    best_values\n}","tests":"}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n"},{"task_id":"HumanEval_130","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ nomer n + 1 pisanan saka urutan Tribonacci. \/\/\/ Sampeyan diwenehi nomer integer non-negatif n, sampeyan kudu bali vektor saka \/\/\/ = 2 + 3 + 3 = 8 \/\/\/ tri(3) = tri(2) + tri(1) + tri(4) \/\/\/ tri(4) = 3 \/\/\/ tri(2) = 1 + (2 \/ 2) = 2 \/\/\/ Contoné: \/\/\/ tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), yen n iku ganjil. \/\/\/ tri (n) = 1 + n \/ 2, yèn n iku pasangan. \/\/\/ tri(1) = 3 \/\/\/ Urutan Tribonacci ditetepake kanthi kamulyan: \/\/Nanging, apa wong ora ngerti iku urutan Tribonacci.\/\/\/ Saben uwong mangerténi urutan Fibonacci, iki sinau rumiyin dening matematikawan ing \/\/\/ >>> tri(3)\n\/\/\/ vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n","canonical_solution":"fn tri(n: isize) -> Vec<isize> {\n    fn tribonacci(n: isize, memo: &mut Vec<isize>) -> isize {\n        if n < memo.len() as isize {\n            return memo[n as usize];\n        }\n\n        let result = if n == 1 {\n            3\n        } else if n % 2 == 0 {\n            1 + n \/ 2\n        } else {\n            tribonacci(n - 1, memo) + tribonacci(n - 2, memo) + tribonacci(n + 1, memo)\n        };\n\n        if n as usize >= memo.len() {\n            memo.resize(n as usize + 1, 0);\n        }\n        memo[n as usize] = result;\n        result\n    }\n\n    let mut sequence = Vec::new();\n    let mut memo = Vec::new();\n\n    for i in 0..=n {\n        sequence.push(tribonacci(i, &mut memo));\n    }\n\n    sequence\n}","tests":"}\n\nfn main() {\n    let candidate = tri;\n    assert_eq!(candidate(3), vec![1, 3, 2, 8]);\n    assert_eq!(candidate(4), vec![1, 3, 2, 8, 3]);\n    assert_eq!(candidate(5), vec![1, 3, 2, 8, 3, 15]);\n    assert_eq!(candidate(6), vec![1, 3, 2, 8, 3, 15, 4]);\n    assert_eq!(candidate(7), vec![1, 3, 2, 8, 3, 15, 4, 24]);\n    assert_eq!(candidate(8), vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);\n    assert_eq!(candidate(9), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);\n    assert_eq!(candidate(20), vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]);\n    assert_eq!(candidate(0), vec![1]);\n    assert_eq!(candidate(1), vec![1, 3]);\n}\n"},{"task_id":"HumanEval_131","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Bali 0 yen kabeh digit padha. \/\/\/ Given a integer positif n, bali produk saka digit aneh. \/\/\/ >>> digits(1)\n\/\/\/ 1\n\/\/\/ >>> digits(4)\n\/\/\/ 0\n\/\/\/ >>> digits(235)\n\/\/\/ 15\nfn digits(n: isize) -> isize {\n","canonical_solution":"fn digits(n: isize) -> isize {\n    let mut product = 1;\n    let mut has_odd = false;\n    let mut num = n;\n\n    while num > 0 {\n        let digit = num % 10;\n        if digit % 2 != 0 {\n            product *= digit;\n            has_odd = true;\n        }\n        num \/= 10;\n    }\n\n    if has_odd {\n        product\n    } else {\n        0\n    }\n}\n\nfn main() {\n    println!(\"{}\", digits(1));  \/\/ 1\n    println!(\"{}\", digits(4));  \/\/ 0\n    println!(\"{}\", digits(235)); \/\/ 15\n}","tests":"}\n\nfn main() {\n    let candidate = digits;\n    assert_eq!(candidate(5), 5);\n    assert_eq!(candidate(54), 5);\n    assert_eq!(candidate(120), 1);\n    assert_eq!(candidate(5014), 5);\n    assert_eq!(candidate(98765), 315);\n    assert_eq!(candidate(5576543), 2625);\n    assert_eq!(candidate(2468), 0);\n}\n"},{"task_id":"HumanEval_132","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ ing ngendi paling ora siji kurung ing subsekresi wis nested. \/\/\/ Fungsi kudu bali bener yen lan mung yen ana subsequence bener saka kurung \/\/\/ Nggawe fungsi sing njupuk senar minangka input sing ngemot mung kurung persegi. \/\/\/ >>> is_nested(String::from(\"[[]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[][]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[]\"))\n\/\/\/ false\n\/\/\/ >>> is_nested(String::from(\"[[][]]\"))\n\/\/\/ true\n\/\/\/ >>> is_nested(String::from(\"[[]][[\"))\n\/\/\/ true\nfn is_nested(string: String) -> bool {\n","canonical_solution":"fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let mut nested = false;\n\n    for bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n        } else if bracket == ']' {\n            if let Some(_) = stack.pop() {\n                if !stack.is_empty() {\n                    nested = true;\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n\n    nested\n}\n\nfn main() {\n    println!(\"{}\", is_nested(String::from(\"[[]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[]]]]]]][[[[[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[][]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[]\"))); \/\/ false\n    println!(\"{}\", is_nested(String::from(\"[[][]]\"))); \/\/ true\n    println!(\"{}\", is_nested(String::from(\"[[]][[\"))); \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"},{"task_id":"HumanEval_133","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ babak saben unsur ing vektor menyang int ndhuwur ((Lof) pisanan. \/\/\/ Sampeyan kudu bali jumlah nomer kuadrat ing vektor diwenehi, \/\/\/ Sampeyan diwenehi vektor nomer. \/\/\/ >>> lst(vec![1.0, 2.0, 3.0])\n\/\/\/ 14\n\/\/\/ >>> lst(vec![1.0, 4.0, 9.0])\n\/\/\/ 98\n\/\/\/ >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n\/\/\/ 84\n\/\/\/ >>> lst(vec![1.4, 4.2, 0.0])\n\/\/\/ 29\n\/\/\/ >>> lst(vec![-2.4, 1.0, 1.0])\n\/\/\/ 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .map(|&x| x.ceil() as isize)  \/\/ Round each element to the nearest upper integer\n        .map(|x| x * x)               \/\/ Square each element\n        .sum()                        \/\/ Sum all the squared elements\n}\n\nfn main() {\n    println!(\"{}\", sum_squares(vec![1.0, 2.0, 3.0])); \/\/ 14\n    println!(\"{}\", sum_squares(vec![1.0, 4.0, 9.0])); \/\/ 98\n    println!(\"{}\", sum_squares(vec![1.0, 3.0, 5.0, 7.0])); \/\/ 84\n    println!(\"{}\", sum_squares(vec![1.4, 4.2, 0.0])); \/\/ 29\n    println!(\"{}\", sum_squares(vec![-2.4, 1.0, 1.0])); \/\/ 6\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0]), 14);\n    assert_eq!(candidate(vec![1.0, 3.0, 5.0, 7.0]), 84);\n    assert_eq!(candidate(vec![1.4, 4.2, 0.0]), 29);\n    assert_eq!(candidate(vec![-2.4, 1.0, 1.0]), 6);\n    assert_eq!(candidate(vec![100.0, 1.0, 15.0, 2.0]), 10230);\n    assert_eq!(candidate(vec![10000.0, 10000.0]), 200000000);\n    assert_eq!(candidate(vec![-1.4, 4.6, 6.3]), 75);\n    assert_eq!(candidate(vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n    assert_eq!(candidate(vec![0.0]), 0);\n    assert_eq!(candidate(vec![-1.0]), 1);\n    assert_eq!(candidate(vec![-1.0, 1.0, 0.0]), 2);\n}\n"},{"task_id":"HumanEval_134","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Cathetan: \"tembung\" minangka klompok karakter sing dipisahake kanthi spasi. \/\/\/ bagéan saka tembung, lan palsu liyane. \/\/\/ saka string diwenehi iku karakter abjad lan ora \/\/\/ Nggawe fungsi sing ngasilake bener yen karakter pungkasan \/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n\/\/\/ true\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n\/\/\/ false\n\/\/\/ >>> check_if_last_char_is_a_letter(String::from(\"\"))\n\/\/\/ false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n","canonical_solution":"fn check_if_last_char_is_a_letter(txt: String) -> bool {\n    if let Some(c) = txt.trim().chars().rev().next() {\n        if c.is_alphabetic() {\n            if let Some(prev_char) = txt.chars().rev().skip_while(|&ch| ch.is_whitespace()).nth(1) {\n                return !prev_char.is_alphabetic();\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pie\")));  \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e\"))); \/\/ true\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"apple pi e \"))); \/\/ false\n    println!(\"{}\", check_if_last_char_is_a_letter(String::from(\"\")));           \/\/ false\n}","tests":"}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n"},{"task_id":"HumanEval_135","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Nilai duplikat. \/\/\/ ora ana unsur kasebut banjur bali -1. Vektor sing diwenehake ora bakal ngemot \/\/\/ ora luwih gedhé utawa padha karo unsur sing langsung ndhisiki.\/\/\/ Nggawe fungsi sing ngasilake indeks paling gedhe saka unsur sing \/\/\/ >>> can_arrange(vec![1, 2, 4, 3, 5])\n\/\/\/ 3\n\/\/\/ >>> can_arrange(vec![1, 2, 3])\n\/\/\/ -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n","canonical_solution":"fn can_arrange(arr: Vec<isize>) -> isize {\n    for i in (1..arr.len()).rev() {\n        if arr[i] < arr[i - 1] {\n            return i as isize;\n        }\n    }\n    -1\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 4, 3, 5])); \/\/ Outputs: 3\n\/\/     println!(\"{}\", can_arrange(vec![1, 2, 3])); \/\/ Outputs: -1\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n"},{"task_id":"HumanEval_136","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Yen ora ana negatif utawa positif wilangan bulat, bali minangka None. \/\/\/ saka wilangan bulat positif ing vektor. \/\/\/ nomer paling gedhé saka wilangan bulat negatif, lan 'b' nomer paling cilik \/\/\/ Nggawe fungsi sing ngasilake tuple (a, b), ing ngendi 'a' yaiku \/\/\/ >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n\/\/\/ (None, Some(1))\n\/\/\/ >>> largest_smallest_integers(vec![])\n\/\/\/ (None, None)\n\/\/\/ >>> largest_smallest_integers(vec![0])\n\/\/\/ (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n","canonical_solution":"fn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative: Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\n    for &num in &lst {\n        if num < 0 {\n            largest_negative = match largest_negative {\n                Some(largest) => Some(largest.max(num)),\n                None => Some(num),\n            };\n        } else if num > 0 {\n            smallest_positive = match smallest_positive {\n                Some(smallest) => Some(smallest.min(num)),\n                None => Some(num),\n            };\n        }\n    }\n\n    (largest_negative, smallest_positive)\n}\n\nfn main() {\n    println!(\"{:?}\", largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])); \/\/ (None, Some(1))\n    println!(\"{:?}\", largest_smallest_integers(vec![])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![0])); \/\/ (None, None)\n    println!(\"{:?}\", largest_smallest_integers(vec![-5, -1, -3, 0, 2, 3])); \/\/ (Some(-1), Some(2))\n}","tests":"}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3), Some(1)));\n}\n"},{"task_id":"HumanEval_138","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ Evaluasi apa nomer sing diwenehake n bisa ditulis minangka jumlah persis 4 nomer malah positif \/\/\/ >>> is_equal_to_sum_even(4)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(6)\n\/\/\/ false\n\/\/\/ >>> is_equal_to_sum_even(8)\n\/\/\/ true\nfn is_equal_to_sum_even(n: isize) -> bool {\n","canonical_solution":"fn is_equal_to_sum_even(n: isize) -> bool {\n    \/\/ A number n can be expressed as the sum of 4 positive even numbers if and only if\n    \/\/ it is greater than or equal to 8 and even\n    n >= 8 && n % 2 == 0\n}\n\n\/\/ Test cases\nfn main() {\n    println!(\"{}\", is_equal_to_sum_even(4));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(6));  \/\/ false\n    println!(\"{}\", is_equal_to_sum_even(8));  \/\/ true\n}","tests":"}\n\nfn main() {\n    let candidate = is_equal_to_sum_even;\n    assert_eq!(candidate(4), false);\n    assert_eq!(candidate(6), false);\n    assert_eq!(candidate(8), true);\n    assert_eq!(candidate(10), true);\n    assert_eq!(candidate(11), false);\n    assert_eq!(candidate(12), true);\n    assert_eq!(candidate(13), false);\n    assert_eq!(candidate(16), true);\n}\n"},{"task_id":"HumanEval_139","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ ing ngendi n > 0 \/\/\/ brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! \/\/\/ Faktor Brasil ditetepake minangka: \/\/\/ >>> special_factorial(4)\n\/\/\/ 288\n\/\/\/ The function will receive an integer as input and should return the special\n\/\/\/ factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n","canonical_solution":"fn factorial(n: isize) -> isize {\n    (1..=n).product()\n}\n\nfn special_factorial(n: isize) -> isize {\n    (1..=n).map(factorial).product()\n}\n\nfn main() {\n    let result = special_factorial(4);\n    println!(\"{}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = special_factorial;\n    assert_eq!(candidate(4), 288);\n    assert_eq!(candidate(5), 34560);\n    assert_eq!(candidate(7), 125411328000);\n    assert_eq!(candidate(1), 1);\n}\n"},{"task_id":"HumanEval_140","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ banjur ganti kabeh spasi berturut-turut karo - \/\/\/ lan yen senar wis luwih saka 2 spasi consecutive, \/\/\/ Given a string teks, ngganti kabeh spasi ing iku karo underscores, \/\/\/ >>> fix_spaces(String::from(\" Example\"))\n\/\/\/ String::from(\"Example\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 1\"))\n\/\/\/ String::from(\"Example_1\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 2\"))\n\/\/\/ String::from(\"_Example_2\")\n\/\/\/ >>> fix_spaces(String::from(\" Example 3\"))\n\/\/\/ String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n","canonical_solution":"fn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut space_count = 0;\n\n    for c in text.chars() {\n        if c == ' ' {\n            space_count += 1;\n        } else {\n            if space_count > 2 {\n                result.push('-');\n            } else if space_count > 0 {\n                result.push_str(&\"_\".repeat(space_count));\n            }\n            result.push(c);\n            space_count = 0;\n        }\n    }\n\n    if space_count > 2 {\n        result.push('-');\n    } else if space_count > 0 {\n        result.push_str(&\"_\".repeat(space_count));\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = fix_spaces;\n    assert_eq!(candidate(String::from(\"Example\")), String::from(\"Example\"));\n    assert_eq!(candidate(String::from(\"Mudasir Hanif \")), String::from(\"Mudasir_Hanif_\"));\n    assert_eq!(candidate(String::from(\"Yellow Yellow  Dirty  Fellow\")), String::from(\"Yellow_Yellow__Dirty__Fellow\"));\n    assert_eq!(candidate(String::from(\"Exa   mple\")), String::from(\"Exa-mple\"));\n    assert_eq!(candidate(String::from(\"   Exa 1 2 2 mple\")), String::from(\"-Exa_1_2_2_mple\"));\n}\n"},{"task_id":"HumanEval_141","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ - Ing substring sawise titik kudu salah siji saka iki: ['txt', 'exe', 'dll'] \/\/\/ aksara Latin ('a'-'z' lan 'A'-'Z'). \/\/\/ - Substring sadurunge titik ora kudu kosong, lan diwiwiti kanthi huruf saka \/\/\/ - Jeneng file ngemot persis siji titik '.' \/\/\/ - Ora ana luwih saka telung digit ('0'-'9') ing jeneng file. \/\/\/ wis ketemu: \/\/\/ Jeneng file dianggep bener yen lan mung yen kabeh kondisi ing ngisor iki \/\/\/ 'Ya' yen jeneng file iku bener, lan ngasilake 'Ora' yen ora. \/\/\/ Nggawe fungsi sing njupuk senar sing makili jeneng file, lan ngasilake \/\/\/ >>> file_name_check(String::from(\"example.txt\"))\n\/\/\/ String::from(\"Yes\")\n\/\/\/ >>> file_name_check(String::from(\"1example.dll\"))\n\/\/\/ String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n","canonical_solution":"fn file_name_check(file_name: String) -> String {\n    let parts: Vec<&str> = file_name.split('.').collect();\n\n    if parts.len() != 2 {\n        return String::from(\"No\");\n    }\n\n    let before_dot = parts[0];\n    let after_dot = parts[1];\n\n    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() {\n        return String::from(\"No\");\n    }\n\n    let digit_count = before_dot.chars().filter(|c| c.is_digit(10)).count();\n    if digit_count > 3 {\n        return String::from(\"No\");\n    }\n\n    match after_dot {\n        \"txt\" | \"exe\" | \"dll\" => String::from(\"Yes\"),\n        _ => String::from(\"No\"),\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\/this_is_valid.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n}\n"},{"task_id":"HumanEval_142","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ ngganti entri ing vektor kang indeks ora kelipatan 3 utawa 4. fungsi banjur bakal bali jumlah kabeh entri. \/\/\/ kelipatan 3 lan bakal dadi kubus entitas integer yen indeksé kelipatan 4 lan dudu kelipatan 3. Fungsi kasebut ora bakal \/\/\/ Fungsi iki bakal njupuk vektor saka wilangan bulat. Kanggo kabeh entri ing vektor, fungsi kudu kuadrat entri wilangan bulat yen indeksé yaiku \/\/\/ \" \/\/\/ >>> lst\n\/\/\/ vec![1, 2, 3]\n\/\/\/ >>> lst\n\/\/\/ vec![]\n\/\/\/ >>> lst\n\/\/\/ vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n","canonical_solution":"fn sum_squares(lst: Vec<isize>) -> isize {\n    lst.into_iter()\n        .enumerate()\n        .map(|(i, value)| {\n            if i % 3 == 0 {\n                value * value\n            } else if i % 4 == 0 {\n                value * value * value\n            } else {\n                value\n            }\n        })\n        .sum()\n}\n\nfn main() {\n    let lst = vec![1, 2, 3];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 14\n\n    let lst = vec![];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 0\n\n    let lst = vec![-1, -5, 2, -1, -5];\n    println!(\"{}\", sum_squares(lst)); \/\/ Outputs: 112\n}","tests":"}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1, 2, 3]), 6);\n    assert_eq!(candidate(vec![1, 4, 9]), 14);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n    assert_eq!(candidate(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n    assert_eq!(candidate(vec![0]), 0);\n    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);\n    assert_eq!(candidate(vec![-56, -99, 1, 0, -2]), 3030);\n    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);\n    assert_eq!(candidate(vec![-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n}\n"},{"task_id":"HumanEval_143","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha 1: \/\/\/ urutan tembung ing senar anyar kudu padha karo sing asli. \/\/\/ kang dawa nomer perdana, \/\/\/ lan sampeyan kudu bali string sing ngemot tembung saka ukara asli, \/\/\/ ukara ngandhut sawetara tembung dipisahake dening spasi, \/\/\/ Sampeyan diwenehi senar sing makili ukara, \/\/\/ >>> words_in_sentence(String::from(\"This is a test\"))\n\/\/\/ String::from(\"is\")\n\/\/\/ Example 2:\n\/\/\/ >>> words_in_sentence(String::from(\"lets go for swimming\"))\n\/\/\/ String::from(\"go for\")\n\/\/\/ Constraints:\n\/\/\/ * 1 <= len(sentence) <= 100\n\/\/\/ * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n","canonical_solution":"fn is_prime(n: usize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n <= 3 {\n        return true;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return false;\n    }\n    let mut i = 5;\n    while i * i <= n {\n        if n % i == 0 || n % (i + 2) == 0 {\n            return false;\n        }\n        i += 6;\n    }\n    true\n}\n\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n    let prime_length_words: Vec<&str> = words\n        .iter()\n        .filter(|&&word| is_prime(word.len()))\n        .cloned()\n        .collect();\n    prime_length_words.join(\" \")\n}\n\nfn main() {\n    assert_eq!(\n        words_in_sentence(String::from(\"This is a test\")),\n        String::from(\"is\")\n    );\n    assert_eq!(\n        words_in_sentence(String::from(\"lets go for swimming\")),\n        String::from(\"go for\")\n    );\n}","tests":"}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"));\n}\n"},{"task_id":"HumanEval_144","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Sampeyan bisa nganggep yen x, lan n iku pecahan sing bener, lan ora duwe nol minangka penyebut. \/\/\/ <numerator>\/<denominator> ing ngendi loro panemu lan denominator minangka nomer bulat positif. \/\/\/ utawa liya. Loro-lorone x lan n, minangka representasi senar pecahan, lan duwe format ing ngisor iki, \/\/\/ x * n. Fungsi ngasilake bener yen x * n ngevaluasi kanggo nomer wutuh lan palsu \/\/\/ Tugasmu yaiku kanggo ngleksanakake fungsi sing bakal nyederhanakake ekspresi \/\/\/ >>> simplify(String::from(\"1\/5\"), String::from(\"5\/1\"))\n\/\/\/ true\n\/\/\/ >>> simplify(String::from(\"1\/6\"), String::from(\"2\/1\"))\n\/\/\/ false\n\/\/\/ >>> simplify(String::from(\"7\/10\"), String::from(\"10\/2\"))\n\/\/\/ false\nfn simplify(x: String, n: String) -> bool {\n","canonical_solution":"fn gcd(a: u32, b: u32) -> u32 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn simplify(x: String, n: String) -> bool {\n    let x_parts: Vec<&str> = x.split('\/').collect();\n    let n_parts: Vec<&str> = n.split('\/').collect();\n    \n    let x_num: u32 = x_parts[0].parse().unwrap();\n    let x_den: u32 = x_parts[1].parse().unwrap();\n    let n_num: u32 = n_parts[0].parse().unwrap();\n    let n_den: u32 = n_parts[1].parse().unwrap();\n    \n    let result_num = x_num * n_num;\n    let result_den = x_den * n_den;\n    \n    let gcd_value = gcd(result_num, result_den);\n    \n    result_den \/ gcd_value == 1\n}","tests":"}\n\nfn main() {\n    let candidate = simplify;\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/6\"), String::from(\"2\/1\")), false);\n    assert_eq!(candidate(String::from(\"5\/1\"), String::from(\"3\/1\")), true);\n    assert_eq!(candidate(String::from(\"7\/10\"), String::from(\"10\/2\")), false);\n    assert_eq!(candidate(String::from(\"2\/10\"), String::from(\"50\/10\")), true);\n    assert_eq!(candidate(String::from(\"7\/2\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"11\/6\"), String::from(\"6\/1\")), true);\n    assert_eq!(candidate(String::from(\"2\/3\"), String::from(\"5\/2\")), false);\n    assert_eq!(candidate(String::from(\"5\/2\"), String::from(\"3\/5\")), false);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"8\/4\")), true);\n    assert_eq!(candidate(String::from(\"2\/4\"), String::from(\"4\/2\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"5\/1\")), true);\n    assert_eq!(candidate(String::from(\"1\/5\"), String::from(\"1\/5\")), false);\n}\n"},{"task_id":"HumanEval_145","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ supaya wong-wong mau adhedhasar indeks ing vektor asli. \/\/\/ Cathetan: yen ana pirang-pirang item kanthi jumlah digit sing padha, \/\/\/ ing urutan munggah miturut jumlah digit. \/\/\/ Tulis fungsi kang ngurutake vektor wilangan bulat \/\/\/ >>> order_by_points(vec![1, 11, -1, -11, -12])\n\/\/\/ vec![-1, -11, 1, -12, 11]\n\/\/\/ >>> order_by_points(vec![])\n\/\/\/ Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut nums_with_indices: Vec<(isize, usize)> = nums.iter().cloned().enumerate().collect();\n\n    nums_with_indices.sort_by_key(|&(num, index)| {\n        let sum_of_digits = num.abs().to_string().chars().map(|c| c.to_digit(10).unwrap_or(0) as isize).sum::<isize>();\n        (sum_of_digits, index)\n    });\n\n    nums_with_indices.iter().map(|&(num, _)| num).collect()\n}\n\nfn main() {\n    \/\/ Example usage\n    let sorted = order_by_points(vec![1, 11, -1, -11, -12]);\n    println!(\"{:?}\", sorted); \/\/ Output: [-1, -11, 1, -12, 11]\n}","tests":"}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"},{"task_id":"HumanEval_146","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ digit pisanan lan pungkasan saka nomer iku ganjil (1, 3, 5, 7, 9). \/\/\/ jumlah unsur ing vektor sing luwih gedhe saka 10 lan loro \/\/\/ Tulis fungsi sing njupuk vektor nomer minangka input lan ngasilake \/\/\/ >>> specialFilter(vec![15, -73, 14, -15])\n\/\/\/ 1\n\/\/\/ >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n\/\/\/ 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n","canonical_solution":"fn specialFilter(nums: Vec<isize>) -> isize {\n    nums.into_iter().filter(|&num| {\n        let abs_num = num.abs();\n        abs_num > 10 && {\n            let digits: Vec<u8> = abs_num.to_string().bytes().map(|b| b - b'0').collect();\n            let first_digit = digits.first().unwrap();\n            let last_digit = digits.last().unwrap();\n            first_digit % 2 == 1 && last_digit % 2 == 1\n        }\n    }).count() as isize\n}\n\n\/\/ Example usage:\n\/\/ fn main() {\n\/\/     let result1 = specialFilter(vec![15, -73, 14, -15]);\n\/\/     println!(\"{}\", result1); \/\/ Output: 1\n\n\/\/     let result2 = specialFilter(vec![33, -2, -3, 45, 21, 109]);\n\/\/     println!(\"{}\", result2); \/\/ Output: 2\n\/\/ }","tests":"}\n\nfn main() {\n    let candidate = specialFilter;\n    assert_eq!(candidate(vec![5, -2, 1, -5]), 0);\n    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);\n    assert_eq!(candidate(vec![33, -2, -3, 45, 21, 109]), 2);\n    assert_eq!(candidate(vec![43, -12, 93, 125, 121, 109]), 4);\n    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);\n    assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n}\n"},{"task_id":"HumanEval_147","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ lan a[i] + a[j] + a[k] iku kelipatan saka 3. \/\/\/ Mbalekake nomer telu (a[i], a[j], a[k]) saka a ing ngendi i < j < k, \/\/\/ Kanggo saben i (1 ≤ i ≤ n), nilai a[i] = i * i - i + 1. \/\/\/ Sampeyan diwenehi integer positif n. Sampeyan kudu nggawe vektor integer a saka dawa n. \/\/\/ >>> get_max_triples(5)\n\/\/\/ 1\n\/\/\/ Explanation: \n\/\/\/ a = [1, 3, 7, 13, 21]\n\/\/\/ The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n","canonical_solution":"fn get_max_triples(n: isize) -> isize {\n    let mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    \n    let mut count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    println!(\"{}\", get_max_triples(5)); \/\/ Output: 1\n}","tests":"}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5), 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n    assert_eq!(candidate(100), 53361);\n}\n"},{"task_id":"HumanEval_149","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ Sampeyan bisa nganggep manawa kabeh tembung bakal padha dawa. \/\/\/ Fungsi kudu bali vektor senar ing urutan diurutake. \/\/\/ Yen rong tembung duwe dawa sing padha, atur vektor kanthi abjad. \/\/\/ kudu bali vektor diurutake dening aturan sing. \/\/\/ Urutan vektor kudu munggah kanthi dawa saben tembung, lan sampeyan \/\/\/ lan bisa uga ngemot duplikat. \/\/Vektor iku tansah vektor string lan ora tau vektor angka, \/\/\/ lan ngasilake vektor sing diasilake kanthi urutan sing diurutake, \/\/\/ mbusak senar sing duwe dawa ganjil saka iku, \/\/\/ Tulis fungsi sing nampa vektor strings minangka parameter, \/\/\/ >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n\/\/\/ vec![String::from(\"aa\")]\n\/\/\/ >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n\/\/\/ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n","canonical_solution":"fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut even_length_strings: Vec<String> = lst\n        .into_iter()\n        .filter(|s| s.len() % 2 == 0)\n        .collect();\n    \n    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    \n    even_length_strings\n}\n\nfn main() {\n    let result = sorted_list_sum(vec![\n        String::from(\"aa\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"aa\"]\n\n    let result = sorted_list_sum(vec![\n        String::from(\"ab\"),\n        String::from(\"a\"),\n        String::from(\"aaa\"),\n        String::from(\"cd\"),\n    ]);\n    println!(\"{:?}\", result); \/\/ Should print: [\"ab\", \"cd\"]\n}","tests":"}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")]);\n}\n"},{"task_id":"HumanEval_150","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ nomer dhasar lan kudu bali ing Nilai y digunakake. \/\/\/ Program prasaja kang kudu bali ing Nilai saka x yen n punika \/\/\/ >>> x_or_y(7, 34, 12)\n\/\/\/ 34\n\/\/\/ >>> x_or_y(15, 8, 5)\n\/\/\/ 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n","canonical_solution":"fn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    fn is_prime(num: isize) -> bool {\n        if num <= 1 {\n            return false;\n        }\n        for i in 2..=((num as f64).sqrt() as isize) {\n            if num % i == 0 {\n                return false;\n            }\n        }\n        true\n    }\n    \n    if is_prime(n) {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    println!(\"{}\", x_or_y(7, 34, 12)); \/\/ Output: 34\n    println!(\"{}\", x_or_y(15, 8, 5)); \/\/ Output: 5\n}","tests":"}\n\nfn main() {\n    let candidate = x_or_y;\n    assert_eq!(candidate(7, 34, 12), 34);\n    assert_eq!(candidate(15, 8, 5), 5);\n    assert_eq!(candidate(3, 33, 5212), 33);\n    assert_eq!(candidate(1259, 3, 52), 3);\n    assert_eq!(candidate(7919, -1, 12), -1);\n    assert_eq!(candidate(3609, 1245, 583), 583);\n    assert_eq!(candidate(91, 56, 129), 129);\n    assert_eq!(candidate(6, 34, 1234), 1234);\n    assert_eq!(candidate(1, 2, 0), 0);\n    assert_eq!(candidate(2, 2, 0), 2);\n}\n"},{"task_id":"HumanEval_151","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ ing vektor sing ganjil. ora nggatekake nomer sing negatif utawa ora wilangan bulat. \/\/\/ Given a vektor nomer, bali jumlah saka kothak nomer \/\/\/ >>> double_the_difference(vec![1, 3, 2, 0])\n\/\/\/ 10\n\/\/\/ >>> double_the_difference(vec![-1, -2, 0])\n\/\/\/ 0\n\/\/\/ >>> double_the_difference(vec![9, -2])\n\/\/\/ 81\n\/\/\/ >>> double_the_difference(vec![0])\n\/\/\/ 0\n\/\/\/ If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n","canonical_solution":"fn double_the_difference(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .filter(|&&x| x.fract() == 0.0 && x > 0.0 && x as isize % 2 != 0)\n        .map(|&x| (x as isize).pow(2))\n        .sum()\n}\n\nfn main() {\n    println!(\"{}\", double_the_difference(vec![1.0, 3.0, 2.0, 0.0])); \/\/ 10\n    println!(\"{}\", double_the_difference(vec![-1.0, -2.0, 0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![9.0, -2.0])); \/\/ 81\n    println!(\"{}\", double_the_difference(vec![0.0])); \/\/ 0\n    println!(\"{}\", double_the_difference(vec![])); \/\/ 0\n}","tests":"}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()), 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1, 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n    assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2, 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"},{"task_id":"HumanEval_152","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ tuladha: \/\/\/ regane 0, lan yen ora, regane beda mutlak antarane tebakan lan skor. \/\/\/ Mbalikake vektor sing dawa padha nuduhake sepira adoh saben guess. Yen wis guessed bener, \/\/\/ Sampeyan diwenehi rong vektor skor lan tebakan sing dawa padha, ing endi saben indeks nuduhake pertandhingan. \/\/\/ Tugas sampeyan yaiku nemtokake manawa ana wong sing bener ngira asil saka sawetara pertandingan. \/\/\/ temtu worth nyathet mudhun lan mbandingaken. \/\/\/ acara pungkasanipun dikenal.\/\/\/ Aku mikir kita kabeh elinga sing koyo nalika asil saka sawetara dawa-ngenteni \/\/\/ >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n\/\/\/ vec![0, 0, 0, 0, 3, 3]\n\/\/\/ >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n\/\/\/ vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n","canonical_solution":"fn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    game.iter()\n        .zip(guess.iter())\n        .map(|(g, gss)| (g - gss).abs())\n        .collect()\n}\n\nfn main() {\n    let result1 = compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]);\n    let result2 = compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]);\n    println!(\"{:?}\", result1); \/\/ Output: [0, 0, 0, 0, 3, 3]\n    println!(\"{:?}\", result2); \/\/ Output: [4, 4, 1, 0, 0, 6]\n}","tests":"}\n\nfn main() {\n    let candidate = compare;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]), vec![0, 0, 0, 0, 3, 3]);\n    assert_eq!(candidate(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]), vec![0, 0, 0, 0, 0, 0]);\n    assert_eq!(candidate(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);\n    assert_eq!(candidate(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]), vec![2, 0, 0, 1]);\n}\n"},{"task_id":"HumanEval_153","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ (kekuwatane yaiku -1). \/\/\/ bali 'Slices.SErviNGSliCes' amarga 'SErviNGSliCes' minangka ekstensi sing paling kuat \/\/\/ ekstensi: ['SErviNGSliCes', 'Cheese', 'StuFfed'] banjur sampeyan kudu \/\/\/ Contone, yen sampeyan diwenehi \"Slices\" minangka kelas lan vektor saka \/\/\/ pilih sing teka pisanan ing vektor. \/\/\/ Yen ana loro utawa luwih ekstensi karo kekuatan sing padha, sampeyan kudu \/\/\/ format: ClassName.StrongestExtensionName. \/\/\/ Sampeyan kudu nemokake ekstensi sing paling kuat lan bali string ing iki \/\/\/ ing jeneng extension, kekuatan diwenehake dening pecahan CAP - SM. \/\/\/ aksara ing jeneng extension, lan supaya SM dadi nomer huruf cilik \/\/\/ kekuatan saka extension minangka nderek: Ayo CAP dadi nomer saka huruf gedhe \/\/\/ Ekstensi kasebut digunakake kanggo mbukak kelas tambahan menyang kelas.\/\/\/ Sampeyan bakal diwenehi jeneng saka kelas (string) lan vektor ekstensi. \/\/\/ >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n\/\/\/ String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n","canonical_solution":"fn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut strongest_extension = String::new();\n    let mut max_strength = i32::MIN;\n\n    for extension in extensions {\n        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;\n        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;\n        let strength = cap_count - sm_count;\n\n        if strength > max_strength {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, strongest_extension)\n}","tests":"}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"__YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]), String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"), vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"-_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]), String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"_\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"},{"task_id":"HumanEval_154","nl":"jav_Latn","pl":"rs","prompt":"\/\/Sampeyan kudu bali bener yen tembung kapindho utawa sembarang saka rotasi sawijining substring ing tembung pisanan \/\/\/ >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n\/\/\/ true\n\/\/\/ >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n\/\/\/ false\n\/\/\/ >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n\/\/\/ true\nfn cycpattern_check(a: String, b: String) -> bool {\n","canonical_solution":"fn cycpattern_check(a: String, b: String) -> bool {\n    let len_b = b.len();\n    if len_b == 0 {\n        return true;\n    }\n    let doubled_b = b.clone() + &b;\n    for i in 0..len_b {\n        if let Some(sub) = doubled_b.get(i..i + len_b) {\n            if a.contains(sub) {\n                return true;\n            }\n        }\n    }\n    false\n}","tests":"}\n\nfn main() {\n    let candidate = cycpattern_check;\n    assert_eq!(candidate(String::from(\"xyzw\"), String::from(\"xyw\")), false);\n    assert_eq!(candidate(String::from(\"yello\"), String::from(\"ell\")), true);\n    assert_eq!(candidate(String::from(\"whattup\"), String::from(\"ptut\")), false);\n    assert_eq!(candidate(String::from(\"efef\"), String::from(\"fee\")), true);\n    assert_eq!(candidate(String::from(\"abab\"), String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"winemtt\"), String::from(\"tinem\")), true);\n}\n"},{"task_id":"HumanEval_155","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Given a integer. bali tuple sing wis nomer digit malah lan aneh mungguh. \/\/\/ >>> even_odd_count(-12)\n\/\/\/ (1, 1)\n\/\/\/ >>> even_odd_count(123)\n\/\/\/ (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n","canonical_solution":"fn even_odd_count(num: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    let num_str = num.abs().to_string();\n    \n    for ch in num_str.chars() {\n        if let Some(digit) = ch.to_digit(10) {\n            if digit % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    \n    (even_count, odd_count)\n}","tests":"}\n\nfn main() {\n    let candidate = even_odd_count;\n    assert_eq!(candidate(7), (0, 1));\n    assert_eq!(candidate(-78), (1, 1));\n    assert_eq!(candidate(3452), (2, 2));\n    assert_eq!(candidate(346211), (3, 3));\n    assert_eq!(candidate(-345821), (3, 3));\n    assert_eq!(candidate(-2), (1, 0));\n    assert_eq!(candidate(-45347), (2, 3));\n    assert_eq!(candidate(0), (1, 0));\n}\n"},{"task_id":"HumanEval_156","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ Watesan: 1 <= num <= 1000 \/\/\/ lan bali ing huruf cilik. \/\/\/ Given a integer positif, njaluk sawijining roman angka padha minangka senar, \/\/\/ >>> int_to_mini_roman(19)\n\/\/\/ String::from(\"xix\")\n\/\/\/ >>> int_to_mini_roman(152)\n\/\/\/ String::from(\"clii\")\n\/\/\/ >>> int_to_mini_roman(426)\n\/\/\/ String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n","canonical_solution":"fn int_to_mini_roman(mut number: isize) -> String {\n    let roman_numerals = [\n        (1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n        (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n        (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"),\n        (1, \"i\"),\n    ];\n    \n    let mut result = String::new();\n    \n    for &(value, symbol) in roman_numerals.iter() {\n        while number >= value {\n            number -= value;\n            result.push_str(symbol);\n        }\n    }\n    \n    result\n}","tests":"}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19), String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426), String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4), String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94), String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994), String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"));\n}\n"},{"task_id":"HumanEval_157","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ 90 derajat. \/\/\/ Segitiga persegi panjang iku segitiga kang siji sudhuté lurus utawa \/\/\/ sisih mbentuk segitiga persegi panjang, palsu liyane. \/\/\/ Given dawa saka telung sisih segitiga. Bali bener yen telu \/\/\/ >>> right_angle_triangle(3, 4, 5)\n\/\/\/ true\n\/\/\/ >>> right_angle_triangle(1, 2, 3)\n\/\/\/ false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n","canonical_solution":"fn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let mut sides = [a, b, c];\n    sides.sort_unstable();\n\n    let [x, y, z] = sides;\n    x * x + y * y == z * z\n}","tests":"}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3, 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10, 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7, 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5, 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48, 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2, 2, 10), false);\n}\n"},{"task_id":"HumanEval_158","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ karakter, bali sing siji sing rawuh pisanan ing urutan lexicographical. \/\/\/ karakter unik. yen pirang-pirang senar duwe nomer maksimum unik \/\/\/ Vektor ngandhut tembung beda. Mbalekake tembung karo nomer maksimum \/\/\/ Tulis fungsi sing nampa vektor strings. \/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n\/\/\/ String::from(\"string\")\n\/\/\/ >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n\/\/\/ String::from(\"enam\")\n\/\/\/ >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n\/\/\/ String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n","canonical_solution":"fn find_max(words: Vec<String>) -> String {\n    fn unique_char_count(s: &str) -> usize {\n        let mut chars: std::collections::HashSet<char> = std::collections::HashSet::new();\n        for c in s.chars() {\n            chars.insert(c);\n        }\n        chars.len()\n    }\n\n    words\n        .into_iter()\n        .max_by(|a, b| {\n            let count_a = unique_char_count(a);\n            let count_b = unique_char_count(b);\n            count_a.cmp(&count_b).then_with(|| a.cmp(b))\n        })\n        .unwrap()\n}","tests":"}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n"},{"task_id":"HumanEval_159","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha: \/\/\/ yen ora cukup wortel sing isih ana, sampeyan bakal mangan kabeh wortel sing isih ana, nanging isih bakal keluwen. \/\/\/ cacahing wortel kang isih ana sawise mangan ] \/\/\/ sampeyan kudu bali vektor [total nomer wortel dipangan sawise mangan, \/\/\/ nanging saiki sampeyan kudu mangan wortel liyane kanggo ngrampungake dina iki. \/\/\/ Kowe iku kelinci luwe, lan sampeyan wis mangan sawetara tartamtu saka wortel, \/\/\/ >>> eat(5, 6, 10)\n\/\/\/ vec![11, 4]\n\/\/\/ >>> eat(4, 8, 9)\n\/\/\/ vec![12, 1]\n\/\/\/ >>> eat(1, 10, 10)\n\/\/\/ vec![11, 0]\n\/\/\/ >>> eat(2, 11, 5)\n\/\/\/ vec![7, 0]\n\/\/\/ Variables:\n\/\/\/ @number : integer\n\/\/\/ the number of carrots that you have eaten.\n\/\/\/ @need : integer\n\/\/\/ the number of carrots that you need to eat.\n\/\/\/ @remaining : integer\n\/\/\/ the number of remaining carrots thet exist in stock\n\/\/\/ Constrain:\n\/\/\/ * 0 <= number <= 1000\n\/\/\/ * 0 <= need <= 1000\n\/\/\/ * 0 <= remaining <= 1000\n\/\/\/ Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n","canonical_solution":"fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let to_eat = if need <= remaining { need } else { remaining };\n    vec![number + to_eat, remaining - to_eat]\n}","tests":"}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"},{"task_id":"HumanEval_160","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Vektor operator paling ora duwe siji operator, lan vektor operand paling ora duwe rong operand. \/\/\/ Operand iku sawijining vektor saka saka saka wilangan bulat non-negatif. \/\/\/ Dawa vektor operator padha karo dawa vektor operand minus siji. \/\/\/ Cathetan: \/\/\/ => asil = 9 \/\/\/ asil = 2 + 3 * 4 - 5 \/\/\/ vektor = [2, 3, 4, 5] \/\/\/ operator['+', '*', '-'] \/\/\/ Tuladha: \/\/\/ Eksponensiasi (**) \/\/\/ Divisi lantai ( \/\/) \/\/\/ Multiplikasi ( *) \/\/\/ Pengurangan ( - ) \/\/\/ Tambahan ( +) \/\/Operasi aljabar dhasar: \/\/\/ expression lan bali evaluasi saka expression iki. \/\/\/ vektor kapindho iku vektor saka wilangan bulat. Gunakake loro vektor diwenehi kanggo mbangun aljabar \/\/\/ Diwenehi loro operator vektor, lan operand. Vektor pisanan duwé operasi aljabar dhasar, lan fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n","canonical_solution":"fn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = operand[0];\n    \n    for i in 0..operator.len() {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i+1],\n            \"-\" => result -= operand[i+1],\n            \"*\" => result *= operand[i+1],\n            \"\/\/\" => result \/= operand[i+1],\n            \"**\" => result = result.pow(operand[i+1] as u32),\n            _ => panic!(\"Unexpected operator\"),\n        }\n    }\n    \n    result\n}\n\nfn main() {\n    let operators = vec![\"+\",\"*\",\"-\"].iter().map(|s| s.to_string()).collect();\n    let operands = vec![2, 3, 4, 5];\n    let result = do_algebra(operators, operands);\n    println!(\"Result: {}\", result);\n}","tests":"}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"**\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"+\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\/\/\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"},{"task_id":"HumanEval_161","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Tuladha \/\/\/ Fungsi kudu bali strings asil. \/\/\/ Yen senar ora ngemot huruf, mbalikke senar. \/\/\/ Yen ora, tetep kaya ngono. \/\/\/ yen s[i] iku aksara, mbalikke kasus saka ngisor menyang ndhuwur utawa kosok balene, \/\/\/ Sampeyan diwenehi senar s. \/\/\/ >>> solve(String::from(\"1234\"))\n\/\/\/ String::from(\"4321\")\n\/\/\/ >>> solve(String::from(\"ab\"))\n\/\/\/ String::from(\"AB\")\n\/\/\/ >>> solve(String::from(\"#a@C\"))\n\/\/\/ String::from(\"#A@c\")\nfn solve(s: String) -> String {\n","canonical_solution":"fn solve(s: String) -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n        s.chars()\n            .map(|c| {\n                if c.is_lowercase() {\n                    c.to_ascii_uppercase()\n                } else if c.is_uppercase() {\n                    c.to_ascii_lowercase()\n                } else {\n                    c\n                }\n            })\n            .collect()\n    }\n}","tests":"}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"},{"task_id":"HumanEval_162","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Yen 'teks' iku string kosong, bali None. \/\/\/ Given a string 'text', return its md5 hash equivalent string. \/\/\/ >>> string_to_md5(String::from(\"Hello world\"))\n\/\/\/ Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n","canonical_solution":"use md5;\n\nfn string_to_md5(text: String) -> Option<String> {\n    if text.is_empty() {\n        return None;\n    }\n    let digest = md5::compute(text);\n    Some(format!(\"{:x}\", digest))\n}","tests":"}\n\nfn main() {\n    let candidate = string_to_md5;\n    assert_eq!(candidate(String::from(\"Hello world\")), Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n    assert_eq!(candidate(String::from(\"\")), None);\n    assert_eq!(candidate(String::from(\"A B C\")), Some(String::from(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n    assert_eq!(candidate(String::from(\"password\")), Some(String::from(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n}\n"},{"task_id":"HumanEval_163","nl":"jav_Latn","pl":"rs","prompt":"\/\/\/ Contoné: \/\/\/ lan b, kanthi urutan mundhak. \/\/\/ Given loro wilangan bulat positif a lan b, bali digit malah antarane a \/\/\/ >>> generate_integers(2, 8)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(8, 2)\n\/\/\/ vec![2, 4, 6, 8]\n\/\/\/ >>> generate_integers(10, 14)\n\/\/\/ Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n","canonical_solution":"fn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let (start, end) = if a < b { (a, b) } else { (b, a) };\n    (start..=end).filter(|&x| x % 2 == 0).collect()\n}\n\nfn main() {\n    let result1 = generate_integers(2, 8);\n    println!(\"{:?}\", result1); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result2 = generate_integers(8, 2);\n    println!(\"{:?}\", result2); \/\/ Output: vec![2, 4, 6, 8]\n\n    let result3 = generate_integers(10, 14);\n    println!(\"{:?}\", result3); \/\/ Output: vec![10, 12, 14]\n}","tests":"}\n\nfn main() {\n    let candidate = generate_integers;\n    assert_eq!(candidate(2, 10), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(17, 89), Vec::<isize>::new());\n}\n"}]