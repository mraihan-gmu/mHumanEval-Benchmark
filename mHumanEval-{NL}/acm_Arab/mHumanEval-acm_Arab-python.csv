task_id,nl,pl,prompt,canonical_solution,test,Unnamed: 6,Unnamed: 7,Unnamed: 8
HumanEval/0,acm_Arab,python,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """"""تحقق اذا في قائمة ارقام معطاة، اي رقمين اقرب من بعضهم اكثر من العتبة المعطاة. مثال: >>> has_close_elements (([1.0, 2.0, 3.0], 0.5) غلط >>> has_close_elements (([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) صحيح """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

",,,
HumanEval/1,acm_Arab,python,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """"""ايدخل هذه الوظيفة سلسلة تحتوي على مجموعات متعددة من القوسين المترابطين. هدفك هو فصل تلك المجموعة الى سلسلات منفصلة ويعيد قائمة تلك. المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) و لا تربط داخل بعضها البعض تجاهل اي مساحات في سلسلة الإدخال. مثال: >>> separate_paren_groups'(( ) (() (()))))))) ['() ', '(()) ', '((()) ']""""""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
",,,
HumanEval/2,acm_Arab,python,"

def truncate_number(number: float) -> float:
    """"""وبالنظر الى عدد نقطة عائمة ايجابية، يمكن تفكيكه الى جزء صحيح (اكبر عدد صحيح اقل من الرقم المحدد) و اعشاريات (الجزء المتبقي اقل دائما من 1). ادي الجزء العشاري من الرقم. مثال: >>> truncate_number(3.5) 0.5 """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
",,,
HumanEval/3,acm_Arab,python,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """"""اُعطيت قائمة بالعمليات الوديعة والسحب على حساب بنكي تبدأ بـ صفر رصيد. مهمتك هي اكتشاف اذا في اي نقطة رصيد الحساب هبط تحت الصفر، وفي تلك النقطة يجب ان ترجع الدالة صحيح. و الا يجب ان ترجع غلط. مثال: >>> تحت_صفر (([1, 2, 3]) غلط >>> تحت_صفر (([1, 2, -4, 5]) صحيح """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
",,,
HumanEval/4,acm_Arab,python,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """"""لليسته المحدده من الارقام المدخلة، احسب متوسط الانحراف المطلق حول متوسط مجموعة البيانات. متوسط الانحراف المطلق هو متوسط الاختلاف المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة): MAD = average. x - x_mean. مثال: >>> mean_absolute_deviation (([1.0, 2.0, 3.0, 4.0]) 1.0 """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

",,,
HumanEval/5,acm_Arab,python,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """"""ادخل رقم ""محدد"" بين كل عنصرين متتاليين من قائمة المدخلات `numbers' >>> intersperse([], 4) [] >>> intersperse([1, 2, 3], 4) [1, 4, 2, 4, 3] """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
",,,
HumanEval/6,acm_Arab,python,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """"""ايدخل هذه الوظيفة سلسلة تمثل مجموعات متعددة للقوسين المترابطين منفصلين عن بعضهما بفارق. لكل مجموعة ايدخل اعمق مستوى من التترابط بين القوسين. مثل (() (()) لديه حد اعلى مستويين من التترابط بينما ((())) لديه ثلاثة. >>> parse_nested_parens('((()) ((())) () ((()) (((()) [2, 3, 1, 3] """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
",,,
HumanEval/7,acm_Arab,python,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """"""تصفية قائمة دخول من السلاسل فقط للكلمات التي تحتوي على سلاسل فرعية معينة >>> filter_by_substring([], 'a') [] >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') ['abc', 'bacd', 'array'] """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
",,,
HumanEval/8,acm_Arab,python,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """"""لليسته معطيه من الأعداد الصحيحة، ارجع توبل يتكون من مجموع ومضاعف لكل الأعداد الصحيحة في القائمة. المجموع الفارغ يجب ان يكون يساوي 0 والمضاعف الفارغ يجب ان يكون يساوي 1. >>> sum_product([]) (0, 1) >>> sum_product([1, 2, 3, 4]) (10, 24) """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
",,,
HumanEval/9,acm_Arab,python,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """"""من قائمة معينة من الأعداد الصحيحة، احصل على قائمة من العناصر القصوى المتداولة التي تم العثور عليها حتى لحظة معينة في التسلسل. >>> rolling_max (([1, 2, 3, 2, 3, 4, 2]) [1, 2, 3, 3, 3, 4, 4] """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
",,,
HumanEval/10,acm_Arab,python,"

def is_palindrome(string: str) -> bool:
    """"""اعثر على اقصر بالندروم يبدأ بحبلة معطاة. الفكرة من الخوارزمية بسيطة: - اعثر على أطول بُعد الحبلة المقدمة والذي هو بالندروم. - اضف الى نهاية الحبلة عكس حبلة مقدمة تأتي قبل اللحاء بالندروم. >>> make_palindrome('') '' >>> make_palindrome('cat') 'catac' >>> make_palindrome('catac') 'catac' """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """"""اختبار اذا السلسلة المعطية بالندروم """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
",,,
HumanEval/11,acm_Arab,python,"from typing import List


def string_xor(a: str, b: str) -> str:
    """"""المدخلين هما سلاسل a و b المكونين فقط من 1 و 0. اعمل XOR ثنائي على هذه المدخلات و ارجع النتيجة كسلسلة. >>> string_xor('010', '110') '100' """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
",,,
HumanEval/12,acm_Arab,python,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """"""خارج قائمة السلاسل، ارجع اطول واحد. ارجع الاول في حالة وجود سلسلات متعددة من نفس الطول. ارجع لا شيء في حالة ان القائمة فارغة. >>> اطول ((([]) >>> اطول ((['a','b','c']) 'a' >>> اطول ((['a','bb', 'ccc']) 'ccc' """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
",,,
HumanEval/13,acm_Arab,python,"

def greatest_common_divisor(a: int, b: int) -> int:
    """"""ارجع اكبر مقسم مشترك لعددين صحيحين a و b >>> اكبر_مشترك_قاسم ((3, 5) 1 >>> اكبر_مشترك_قاسم ((25, 15) 5 """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
",,,
HumanEval/14,acm_Arab,python,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """"""يعيد قائمة بكل المسبقات من الأقصر الى الأطول من السلسلة المضافة >>> all_prefixes (('abc') ['a'، 'ab'، 'abc'] """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
",,,
HumanEval/15,acm_Arab,python,"

def string_sequence(n: int) -> str:
    """"""يرد سلاسلة تحتوي على ارقام محددة مساحة تبدأ من 0 حتى n. >>> string_sequence(0) '0' >>> string_sequence(5) '0 1 2 3 4 5' """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
",,,
HumanEval/16,acm_Arab,python,"

def count_distinct_characters(string: str) -> int:
    """"""معطوفة سلسلة، اعثر على كم حرف مميز (بغض النظر عن الحالة) هل تتكون من >>> count_distinct_characters (('xyzXYZ') 3 >>> count_distinct_characters (('Jerry') 4 """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
",,,
HumanEval/17,acm_Arab,python,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """"""ايدخل هذا الدور هو سلسلة تمثل الملاحظات الموسيقية في شكل ASCII خاص. مهمتك هي تحليل قائمة السلاسل من الأعداد الصحيحة المقابلة للعديد من الضربات. هنا هو أسطورة: 'o' note, lasts four beats 'o 112' - half note, lasts two beats 112' - quater note, lasts one beat >>> parse_music. 'o o .""""""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
",,,
HumanEval/18,acm_Arab,python,"

def how_many_times(string: str, substring: str) -> int:
    """"""اعثر على كم مرة يمكن العثور على سلسلة فرعية معينة في السلسلة الاصلية. عد الحالات المتداخلة. >>> how_many_times('', 'a') 0 >>> how_many_times('aaa', 'a') 3 >>> how_many_times('aaaa', 'aa') 3 """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
",,,
HumanEval/19,acm_Arab,python,"from typing import List


def sort_numbers(numbers: str) -> str:
    """"""الإدخال هو سلسلة من الأرقام المحدودة بالفراغ من ""صفر"" لـ ""تسعة"". الاختيارات الصالحة هي ""صفر""، ""واحد""، ""اثنين""، ""ثلاثة""، ""أربعة""، ""خمسة""، ""ستة""، ""سبعة""، ""ثمانية"" و ""تسعة"". يرجع السلسلة بأرقام مرتبة من الأصغر إلى الأكبر >>> sort_numbers ((('ثلاثة واحد خمسة') 'واحد ثلاثة خمسة' """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
",,,
HumanEval/20,acm_Arab,python,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """"""من قائمة ارقام (طولها اثنين على الاقل) اختر واسترد اثنين اقرب لبعضهم واستردهم بالترتيب (الرقم الاصغر، الرقم الاكبر). >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) (2.0, 2.2) >>> find_closest_elements (([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) (2.0, 2.0) """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

",,,
HumanEval/21,acm_Arab,python,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """"""وبالنظر الى قائمة ارقام (من عنصرين على الاقل) ، اطلب تحويل خطي على تلك القائمة، بحيث يصبح اقل عدد 0 واكبر عدد يصبح 1 >>> rescale_to_unit (([1.0, 2.0, 3.0, 4.0, 5.0]) [0.0, 0.25, 0.5, 0.75, 1.0] """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
",,,
HumanEval/22,acm_Arab,python,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """"""تصفية قائمة معطاة من اي قيم بايثون فقط للأعداد الصحيحة >>> filter_integers(['a', 3.14, 5]) [5] >>> filter_integers([1, 2, 3, 'abc', {}, []]) [1, 2, 3] """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
",,,
HumanEval/23,acm_Arab,python,"

def strlen(string: str) -> int:
    """"""عودة طول السلسلة المحددة >>> strlen('') 0 >>> strlen('abc') 3 """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
",,,
HumanEval/24,acm_Arab,python,"

def largest_divisor(n: int) -> int:
    """"""لعدد معين n، اعثر على اكبر عدد يقسم n بالتساوي، اصغر من n >>> اكبر_قسمة ((15) 5 """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
",,,
HumanEval/25,acm_Arab,python,"from typing import List


def factorize(n: int) -> List[int]:
    """"""اعاد قائمة العوامل الاولية لعدد صحيح معين بالترتيب من الاصغر الى الاكبر. كل من العوامل يجب ان يتم سردها عدة مرات تتوافق مع عدد المرات التي تظهر فيها في العامل. يجب ان يكون رقم الإدخال يساوي ناتج جميع العوامل >>> فاكتوريز ((8) [2, 2, 2] >>> فاكتوريز ((25) [5, 5] >>> فاكتوريز ((70) [2, 5, 7] """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
",,,
HumanEval/26,acm_Arab,python,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """"""من قائمة من الأعداد الصحيحة، اخرج كل العناصر التي تظهر اكثر من مرة. اترك ترتيب العناصر كما هو في المدخلات. >>> remove_duplicates (([1, 2, 3, 2, 4]) [1, 3, 4] """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
",,,
HumanEval/27,acm_Arab,python,"

def flip_case(string: str) -> str:
    """"""لسلسلة معينة، اقلب الحروف الصغيرة الى الكبيرة والكبيرة الى الصغيرة. >>> flip_case ((('Hello') 'hELLO' """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
",,,
HumanEval/28,acm_Arab,python,"from typing import List


def concatenate(strings: List[str]) -> str:
    """"""Concatenate list of strings into a single string >>> concatenate([]) '' >>> concatenate(['a', 'b', 'c']) 'abc' """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
",,,
HumanEval/29,acm_Arab,python,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """"""تصفية قائمة دخول من السلاسل فقط للكلمات التي تبدأ ب ب بوابة معينة. >>> filter_by_prefix([], 'a') [] >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') ['abc', 'array'] """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
",,,
HumanEval/30,acm_Arab,python,"

def get_positive(l: list):
    """"""ارجع فقط الارقام الايجابية في القائمة. >>> get_positive (([-1, 2, -4, 5, 6]) [2, 5, 6] >>> get_positive (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) [5, 3, 2, 3, 9, 123, 1] """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

",,,
HumanEval/31,acm_Arab,python,"

def is_prime(n):
    """"""ارجع صحيح اذا كان رقم معين عادي، و غلط اذا لم يكن. >>> is_prime(6) False >>> is_prime(101) صحيح >>> is_prime(11) صحيح >>> is_prime(13441) صحيح >>> is_prime(61) صحيح >>> is_prime(4) غلط >>> is_prime(1) غلط """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

",,,
HumanEval/32,acm_Arab,python,"import math


def poly(xs: list, x: float):
    """"""xs هي معامل لـ polynomial. find_zero find x مثل poly(x) = 0. find_zero يعيد فقط فقط نقطة الصفر، حتى لو كان هناك الكثير. علاوة على ذلك، find_zero يأخذ فقط قائمة xs مع عدد زوج من المعاملات وأكبر معامل غير صفري لأنها تضمن حل. >>> round(find_zero[(1, 2] ، 2) # f(x) = 1 + 2x -0.5 >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3 1.0 """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """"""يقيّم كثياري مع معاملات xs في نقطة x. يرد xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

",,,
HumanEval/33,acm_Arab,python,"

def sort_third(l: list):
    """"""هذي الوظيفة تأخذ قائمة l وتعيد قائمة l' بحيث تكون l' متطابقة مع l في المؤشرات التي لا تقسم على ثلاثة، بينما قيمها في المؤشرات التي تقسم على ثلاثة تساوي قيم المؤشرات المقابلة لـ l، لكن مرتبة. >>> sort_third (([1, 2, 3]) [1, 2, 3] >>> sort_third (([5, 6, 3, 4, 8, 9, 2]) [2, 6, 3, 4, 8, 9, 5] """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

",,,
HumanEval/34,acm_Arab,python,"

def unique(l: list):
    """"""يعيد العناصر المفرقة المفرقة في قائمة >>> unique (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [0, 2, 3, 5, 9, 123] """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

",,,
HumanEval/35,acm_Arab,python,"

def max_element(l: list):
    """"""يعيد اعلى عنصر في القائمة. >>> max_element (([1, 2, 3]) 3 >>> max_element (([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) 123 """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
",,,
HumanEval/36,acm_Arab,python,"

def fizz_buzz(n: int):
    """"""اعيد عدد المرات اللى يظهر فيها الرقم 7 في عدد كامل اقل من n القابل للقسمة على 11 او 13. >>> fizz_buzz(50) 0 >>> fizz_buzz(78) 2 >>> fizz_buzz(79) 3 """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

",,,
HumanEval/37,acm_Arab,python,"

def sort_even(l: list):
    """"""هذي الوظيفه تاخذ قائمة l وتعيد قائمة l' بحيث تكون l' متطابقة مع l في المؤشرات الغير متغازلة، بينما قيمها في المؤشرات الزوجية تساوي قيم المؤشرات الزوجية لـ l، لكن مرتبة. >>> sort_even (([1, 2, 3]) [1, 2, 3] >>> sort_even (([5, 6, 3, 4]) [3, 6, 5, 4] """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

",,,
HumanEval/38,acm_Arab,python,"

def encode_cyclic(s: str):
    """"""يخذ كسلسلة مدفوعة مع الوظيفة encode_cyclic. يرجع السلسلة المفككة.""""""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""يعود سلاسل مشفرة من خلال مجموعات دورية من ثلاث حروف.""""""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

",,,
HumanEval/39,acm_Arab,python,"

def prime_fib(n: int):
    """"""prime_fib يرد رقم n-th وهو رقم فيبوناتشي وهو ايضاً رقم رئيسي. >>> prime_fib(1) 2 >>> prime_fib(2) 3 >>> prime_fib(3) 5 >>> prime_fib(4) 13 >>> prime_fib(5) 89 """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

",,,
HumanEval/40,acm_Arab,python,"

def triples_sum_to_zero(l: list):
    """"""triples_sum_to_zero يَأْخُذُ قائمة من الأعداد الصحيحة كمدخل. يُرجع صحيح إذا كان هناك ثلاثة عناصر متميزة في القائمة التي تُجَمِّعُ الصفر، و غلط خلاف ذلك. >>> triples_sum_to_zero (([1, 3, 5, 0]) غلط >>> triples_sum_to_zero (([1, 3, -2, 1]) صحيح >>> triples_sum_to_zero (([1, 2, 3, 7]) غلط >>> triples_sum_to_zero (([2, 4, -5, 3, 9, 7]) صحيح >>> triples_sum_to_zero (([1]) غلط """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

",,,
HumanEval/41,acm_Arab,python,"

def car_race_collision(n: int):
    """"""تخيل طريق مستقيم جداً خط طويل بلا حدود. n سيارات تسير من اليسار الى اليمين; في نفس الوقت مجموعة مختلفة من n سيارات تسير من اليمين الى اليسار. مجموعتين من السيارات تبدا بعيدة جداً عن بعضها البعض. كل السيارات تتحرك بنفس السرعة. يقال ان سيارتين تتصادم عندما تتصادم سيارة تتحرك من اليسار الى اليمين مع سيارة تتحرك من اليمين الى اليسار. لكن السيارات قوية بلا حدود؛ ونتيجة لذلك، فهي تستمر في التنقل في مسارها كما لو لم تتصادم. هذه الدالة تخرج عدد مثل هذه الاصطدامات.""""""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

",,,
HumanEval/42,acm_Arab,python,"

def incr_list(l: list):
    """"""يُرجع القائمة مع العناصر المتزايدة بـ 1. >>> incr_list (([1, 2, 3]) [2, 3, 4] >>> incr_list (([5, 3, 5, 2, 3, 3, 9, 0, 123]) [6, 4, 6, 3, 4, 4, 10, 1, 124] """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

",,,
HumanEval/43,acm_Arab,python,"

def pairs_sum_to_zero(l):
    """"""pairs_sum_to_zero يَأْخُذُ قائمة من الأعداد الصحيحة كمدخل. يَرُدُّ صحيح إذا كان هناك عنصرين مُمَيِّزين في القائمة يُجَمِّعُون إلى الصفر، و False خلاف ذلك. >>> pairs_sum_to_zero (([1, 3, 5, 0]) False >>> pairs_sum_to_zero (([1, 3, -2, 1]) False >>> pairs_sum_to_zero (([1, 2, 3, 7]) False >>> pairs_sum_to_zero (([2, 4, -5, 3, 5, 7]) True >>> pairs_sum_to_zero (([1]) False """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

",,,
HumanEval/44,acm_Arab,python,"

def change_base(x: int, base: int):
    """"""غيّر القاعدة العدديّة لعدد المدخل x الى قاعدة. ارجع تمثيل السلسلة بعد التحول. ارقام القاعدة اقل من 10. >>> change_base(8, 3) '22' >>> change_base(8, 2) '1000' >>> change_base(7, 2) '111' """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

",,,
HumanEval/45,acm_Arab,python,"

def triangle_area(a, h):
    """"""معطى طول جانب ومساحة عودة عالية للمثلث. >>> مثلث_مساحة{5, 3) 7.5 """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

",,,
HumanEval/46,acm_Arab,python,"

def fib4(n: int):
    """"""تسلسل الارقام فيبوناچي هو تسلسل مشابه لسلسلة فيبوناچي والذي يعرف على النحو التالي: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). ارجوك اكتب دالة لحساب العنصر الـ n من تسلسل الارقام فيبوناچي بفعالية. لا تستخدم الانتكاس. >>> fib4(5) 4 >>> fib4(6) >>> 8 fib4(7) 14 """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

",,,
HumanEval/47,acm_Arab,python,"

def median(l: list):
    """"""اعادة الوسط العنصر في القائمة l. >>> الوسط (([3, 1, 2, 4, 5]) 3 >>> الوسط (([-10, 4, 6, 1000, 10, 20]) 15.0 """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

",,,
HumanEval/48,acm_Arab,python,"

def is_palindrome(text: str):
    """"""يُفَحِّص إنْ كانت السلسلة المُعطَاة عبارة عن حِلْفَة >>> is_palindrome (('') صحيح >>> is_palindrome (('aba') صحيح >>> is_palindrome (('aaaaa') صحيح >>> is_palindrome (('zbcd') غلط """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

",,,
HumanEval/49,acm_Arab,python,"

def modp(n: int, p: int):
    """"""ارجع 2^n مودولو p (انبهري عن الرقمية). >>> modp(3, 5) 3 >>> modp(1101, 101) 2 >>> modp(0, 101) 1 >>> modp(3, 11) 8 >>> modp(100, 101) 1 """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

",,,
HumanEval/50,acm_Arab,python,"

def encode_shift(s: str):
    """"""يخذ كسلسلة مدخول مشفرة مع دالة encode_shift. يرجع السلسلة المفككة. """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""يعود السلسلة المشفرة عن طريق تحريك كل حرف بخمسة في الأبجدية.""""""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

",,,
HumanEval/51,acm_Arab,python,"

def remove_vowels(text):
    """"""remove_vowels هو دالة تأخذ السلاسل وتعيد السلاسل بدون حروف عطف. >>> remove_vowels('') '' >>> remove_vowels(""abcdef\nghijklm"") 'bcdf\nghjklm' >>> remove_vowels('abcdef') 'bcdf' >>> remove_vowels('aaaaa') '' >>> remove_vowels('aaBAA') 'B' >>> remove_vowels('zbcd') 'zbcd' """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

",,,
HumanEval/52,acm_Arab,python,"

def below_threshold(l: list, t: int):
    """"""يرجع صحيح اذا كل الارقام في القائمة l هي تحت العتبة t. >>> below_threshold (([1, 2, 4, 10], 100) صحيح >>> below_threshold (([1, 20, 4, 10], 5) غلط """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

",,,
HumanEval/53,acm_Arab,python,"

def add(x: int, y: int):
    """"""جمع رقمين x و y >>> جمع (((2, 3) 5 >>> جمع (((5, 7) 12 """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

",,,
HumanEval/54,acm_Arab,python,"

def same_chars(s0: str, s1: str):
    """"""تحقق اذا كان للكلمتين نفس الحروف. >>> same_chars (('eabcdzzzz', 'dddzzzzzzzddeddabc') صحيح >>> same_chars (('abcd', 'dddddddddabc') صحيح >>> same_chars (('dddddddabc', 'abcd') صحيح >>> same_chars (('eabcd', 'dddddddddabc') غلط >>> same_chars ((('abcd', 'dddddddabddce') غلط >>> same_chars (((abcdzzzz', 'dddzzzzzzzddabc') غلط """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

",,,
HumanEval/55,acm_Arab,python,"

def fib(n: int):
    """"""ارجع رقم فيبوناتشي الـ n. >>> fib(10) 55 >>> fib(1) 1 >>> fib(8) 21 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

",,,
HumanEval/56,acm_Arab,python,"

def correct_bracketing(brackets: str):
    """"""brackets هو سلسلة من ""<"" و "">"". return True اذا كل قوس افتتاحيه له قوس اغلاق متوافق. >>> correct_bracketing(""<"") False >>> correct_bracketing(""<>"") True >>> correct_bracketing(""<><>>"") True >>> correct_bracketing(""><<>"") False """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

",,,
HumanEval/57,acm_Arab,python,"

def monotonic(l: list):
    """"""اعيد صحيح هو عناصر القائمة تزيد او تنخفض بشكل متواصل. >>> متواصل (([1, 2, 4, 20]) صحيح >>> متواصل (([1, 20, 4, 10]) غلط >>> متواصل (([4, 1, 0, -10]) صحيح """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

",,,
HumanEval/58,acm_Arab,python,"

def common(l1: list, l2: list):
    """"""يعيد العناصر المشتركة المفرزة المفردة لقائمتين. >>> مشتركة (([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) [1, 5, 653] >>> مشتركة (([5, 3, 2, 8], [3, 2]) [2, 3] """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

",,,
HumanEval/59,acm_Arab,python,"

def largest_prime_factor(n: int):
    """"""ارجع اكبر عامل أولي لـ n. افترض n > 1 و هو مو عامل أولي. >>> largest_prime_factor ((13195) 29 >>> largest_prime_factor ((2048) 2 """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

",,,
HumanEval/60,acm_Arab,python,"

def sum_to_n(n: int):
    """"""sum_to_n هو دالة تُجمع الأرقام من 1 إلى n. >>> sum_to_n(30) 465 >>> sum_to_n(100) 5050 >>> sum_to_n(5) 15 >>> sum_to_n(10) 55 >>> sum_to_n(1) 1 """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

",,,
HumanEval/61,acm_Arab,python,"

def correct_bracketing(brackets: str):
    """"""brackets هو سلسلة من ""("" و "")"". return True إذا كل قوس افتتاحي له قوس إغلاق متوافق. >>> correct_bracketing(""("") False >>> correct_bracketing(""() True >>> correct_bracketing(""())) True >>> correct_bracketing("")""""""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

",,,
HumanEval/62,acm_Arab,python,"

def derivative(xs: list):
    """"""xs يمثل معامل متعدد الحدود. xs[0] + xs[1] * x + xs[2] * x^2 + .... ارجع مشتقة هذا متعدد الحدود بنفس الشكل. >>> مشتقة (([3, 1, 2, 4, 5]) [1, 4, 12, 20] >>> مشتقة (([1, 2, 3]) [2, 6] """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

",,,
HumanEval/63,acm_Arab,python,"

def fibfib(n: int):
    """"""تسلسل الافافافيب هو تسلسل مشابه لسلسلة فيبوناتشي والذي يعرف على النحو التالي: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3 ارجوك اكتب دالة لحساب العنصر الـ n من تسلسل الافافيب. >>> fibfib(1) 0 >>> fib fib(5) 4 >>> fibfib(8) 24 """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

",,,
HumanEval/64,acm_Arab,python,"
FIX = """"""اكتب دالة vowels_count التي تأخذ سلسلة تمثل كلمة كمدخل وتعيد عدد الحروف المقطوعة في السلسلة. الحروف المقطوعة في هذه الحالة هي 'a'، 'e'، 'i'، 'o'، 'u'. هنا، 'y' هو ايضا حروف مقطوعة، لكن فقط عندما يكون في نهاية الكلمة المعطاة. مثال: >>> vowels_count (((""abcde"") 2 >>> vowels_count (((""ACEDY"") 3 """"""

def vowels_count(s):
    """"""اضف المزيد من حالات الاختبار.""""""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/65,acm_Arab,python,"
def circular_shift(x, shift):
    """"""حلقية تحرك ارقام العدد الصحيح x، تحرك الارقام للييمين بحركة وتعيد النتيجة كسلسلة. اذا تحرك > عدد الارقام، ارجع الارقام عكس الارقام. >>> circular_shift(12, 1) ""21"" >>> circular_shift(12, 2) ""12"" """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/66,acm_Arab,python,"
def digitSum(s):
    """"""مهمة اكتب دالة تأخذ سلسلة كمدخل وتعيد مجموع الحروف العليا فقط' ASCII كود. مثال: digitSum("""") => 0 digitSum(""abAB"") => 131 digitSum(""abcCd"") => 67 digitSum(""helloE"") => 69 digitSum(""woArBld"") => 131 digitSum(""aAaaaXa"") => 153 """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

",,,
HumanEval/67,acm_Arab,python,"
def fruit_distribution(s,n):
    """"""فِي هَذِهِ المُهِمَّةِ، سَتُعْطَى سِلْسِلَةً تَعْرِفُ عَدَدَ التُّفَّاحِ وَالْبُرتُونِ الْمُوزَعِينَ فِي سَلْسِلَةٍ مِنْ فَاكِهَةٍ تَتَضَمَّنُ التُّفَاحَ وَالْبُرتُونَ وَالْمَنْجُوزَ. وَبِمَا أَنَّ السِلْسِلَةَ تَعْرِفُ عَدَدَ التُّفَاحِ وَالتُّفَاحِ وَالْبُرتُونِ الْمُوزَعِينَ وَعَدَدَ التُّفَاحِ وَالْبُرتُونِ الْمُوزَعِينَ يَعْرِضُ عَ عَ عَدَدَدَةَ فَ الثَّمَرِيرِ.""""""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
",,,
HumanEval/68,acm_Arab,python,"
def pluck(arr):
    """"""""بإعطاء صف يمثل فرع من شجرة التي لها عقد غير سليمة السلبية، مهمتك هي انتزاع واحد من العقد وإعادتها. العقد المنتزاع يجب ان يكون العقد مع اقل قيمة حتى. اذا وجدت عقدات متعددة مع اقل قيمة حتى نفسها اعادة العقدة التي لها اقل مؤشر. العقد المنتزاع يجب ان يعاد في قائمة، [smallest_value، مؤشرها ]، اذا لم تكن هناك قيم حتى او المصفوفة المحددة فارغة، اعادة []. مثال 1: المدخل: [4,2,3] المخرج: [2, 1] التفسير: 2 لها اقل قيمة حتى، و 2 لها اقل مؤشر. مثال 2: المدخل: [1,2,3] المخرج: [2, 1] التفسير: 2 لها اقل قيمة حتى، و 2 لها اقل مؤشر. مثال 3: المدخل: [] المخرج: [] المدخل: [4: 5, 3, 4, 2] المخرج: 1، 0 المخرج: 1، اقل قيمة حتى، ولكن هناك صفر. مثال 1: 1 * الاصغرغر، لكن هناك صفر.""""""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

",,,
HumanEval/69,acm_Arab,python,"
def search(lst):
    '''اُعطيت قائمة غير فارغة من الأعداد الصحيحة الايجابية. ارجع اكبر عدد صحيح اكبر من الصفر، وله تواتر اكبر من او يساوي قيمة العدد الصحيح نفسه. تواتر العدد الصحيح هو عدد المرات التي يظهر فيها في القائمة. اذا لم توجد قيمة كهذه، ارجع -1. مثال: search (([4, 1, 2, 2, 3, 1]) == 2 search (([1, 2, 2, 3, 3, 3, 4, 4]) == 3 search (([5, 5, 4, 4, 4]) == -1 '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

",,,
HumanEval/70,acm_Arab,python,"
def strange_sort_list(lst):
    '''وَبِمَا انْتَبَهَ لِلْعَدَدِ الْمُتَعَدِّدِ، يَعُودُ الْعَدَدُ بِمَنْزِلَةٍ غَرِيبَةٍ. الْمُنَزِّلُ غَرِيبٌ، هو عندما تبدأ بِالْقِيمَةِ الدُّنْيَا، ثُمَّ الْقِيمَةِ الأَكْبَرِ لِلْعَدَدِ الْمُتَعَدِّدِ الْمُتَعَدِّدِ، ثُمَّ الْقِيمَةُ الأَدْنَى، وهَكَذَا. مثال: strange_sort_list (([1, 2, 3, 4]) == [1, 4, 2, 3] strange_sort_list (([5, 5, 5, 5]) == [] '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/71,acm_Arab,python,"
def triangle_area(a, b, c):
    '''معطوف على طول الضلوع الثلاثة للمثلث. ارجع مساحة المثلث مقربة لـ 2 نقطة عشرية اذا كان الضلوع الثلاثة يشكلون مثلث صحيح. و الا ارجع -1 ثلاثة ضلعين يشكلون مثلث صحيح اذا كانت مجموع اي جانبين اكبر من الجانب الثالث. مثال: مثلث_مساحة{3,4,5) == 6.00 مثلث_مساحة{1,2,10) == -1 '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

",,,
HumanEval/72,acm_Arab,python,"
def will_it_fly(q,w):
    '''اكتب دالة ترجع صحيح اذا كان الكائن q سيهرب، وكذب خلاف ذلك. الكائن q سيهرب اذا كان متوازن (انه قائمة بالندروم) ومجموع عناصره اقل من او يساوي الوزن الاكبر المحتمل w. مثال: will_it_fly (([1, 2], 5) â -> كذب # 1+2 اقل من الوزن الاكبر المحتمل، ولكنه غير متوازن. will_it_fly (([3, 2, 3], 1) â -> كذب # انه متوازن، لكن 3+2+3 اكبر من الوزن الاكبر المحتمل. will_it_fly (([3, 2, 3], 9) â -> صحيح # 3+23 اقل من الوزن الاكبر المحتمل، وهو متوازن. will_it_fly ((([3], â 5) -> صحيح # 3 اقل من الوزن الاكبر المحتمل، وهو متوازن '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

",,,
HumanEval/73,acm_Arab,python,"
def smallest_change(arr):
    """"""وبالنظر الى صف من الأعداد الصحيحة، اعثر على الحد الادنى من العناصر التي تحتاج للتغيير لجعل المصف بالندروم. المصف بالندروم هو صف يقرأ بنفس الطريقة للخلف والعكس. في تغيير واحد، يمكنك تغيير عنصر واحد لأي عنصر آخر. مثلًا: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0 """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

",,,
HumanEval/74,acm_Arab,python,"
def total_match(lst1, lst2):
    '''اكتب دالة تقبل قائمتين من السلاسل وتعيد القائمة التي لديها عدد كلي من الحروف في كل السلاسل من القائمة اقل من القائمة الاخرى. اذا كانت القائمتين لها نفس عدد الحروف، ارجع القائمة الاولى. مثالات total_match (([]، (()) -> (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((('''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

",,,
HumanEval/75,acm_Arab,python,"
def is_multiply_prime(a):
    """"""اكتب دالة تعيد صحيح اذا كان العدد المحدد ضرب 3 أرقام أولية و غلط اذا لم يكن. مع العلم ان (أ) اقل من 100. مثال: is_multiply_prime(30) == صحيح 30 = 2 * 3 * 5 """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

",,,
HumanEval/76,acm_Arab,python,"
def is_simple_power(x, n):
    """"""مهمتك هي ان تكتب دالة تعيد صحيح اذا كان الرقم x قوة بسيطة من n و كاذبة في الحالات الاخرى. x قوة بسيطة من n اذا n**int=x مثلاً: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) => false is_simple_power(5, 3) => false """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/77,acm_Arab,python,"
def iscube(a):
    '''اكتب دالة تأخذ عدد صحيح a وتعود صحيح اذا كان هذا ingeger مكعب لعدد صحيح. ملاحظة: يمكنك ان تفترض ان المدخل صحيح دائما. مثال: iscube ((1) ==> true ((2) ==> false ((-1) ==> true ((64) ==> true ((0) ==> true ((180) ==> false '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

",,,
HumanEval/78,acm_Arab,python,"
def hex_key(num):
    """"""اعمل على كتابة دالة تستقبل رقم عشري عشري كسلسلة و تحسب عدد الارقام عشري عشري الاولية (عدد أولي هو عدد طبيعي اكبر من 1 و ليس ناتج من عددين طبيعيين اصغر) ارقام عشري عشري هي 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، A، B، C، D، E، F. الارقام الاولية هي 2، 3، 5، 7، 11، 13، 17، ... لذلك عليك ان تحدد عدد من الارقام التالية: 2، 3، 5، 7، B (= عشري 11) ، D (= عشري 13) ملاحظة: يمكنك ان تفترض ان المدخل صحيح او فارغ دائماً، و الرموز A،B،C،D،E،F دائماً بحروف كبيرة. مثال: لnum = AB يجب ان يكون المخرج num = 1. لnum = 1077E يجب ان يكون المخرج 2. لnum = ""AB33"" يجب ان يكون num = 4.BCD = 6.06712345 لnum = 6.045 لnum يجب ان يكون المخرج 2.2020""""""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

",,,
HumanEval/79,acm_Arab,python,"
def decimal_to_binary(decimal):
    """"""راح تعطيك رقم في شكل عشري ومهمتك هي تحويله الى شكل ثنائي. المهام يجب ان تعيد سلاسل، مع كل حرف يمثل رقم ثنائي. كل حرف في السلاسل سيكون '0' او '1'. راح يكون هناك زوجين اضافين من الحروف 'db' في بداية ونهاية السلاسل. الحروف الاضافية موجودة لمساعدة في الشكل. مثال: decimal_to_binary(15) # تعيد ""db1111db"" decimal_to_binary32) # تعيد ""db100000db""""""""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/80,acm_Arab,python,"
def is_happy(s):
    """"""تُعْطَى لكِ سِلْكَة s. مهمتكِ هي التحقق من ان كانت السلسلة سعيدة او لا. السلسلة سعيدة اذا طولها 3 على الاقل وكل 3 حروف متتالية متميزة. مثل: is_happy ((a) => False is_happy ((aa) => False is_happy ((abcd)) => True is_happy ((aabb)) => False is_happy ((adb)) => True is_happy ((xyy)) => False """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
",,,
HumanEval/81,acm_Arab,python,"
def numerical_letter_grade(grades):
    """"""هوه الاسبوع الاخير من الفصل الدراسي ويجب على المعلم اعطاء الدرجات للطلاب. المعلم عمل خوارزمية خاصة به للتصنيف. المشكلة الوحيدة هي انها فقدت الشفرة التي استخدمتها للتصنيف. لقد اعطتك قائمة من معدل النتائج العليا لبعض الطلاب ويجب عليك كتابة دالة يمكنها انتاج قائمة من درجات الحروف باستخدام الجدول التالي: معدل النتائج العليا. درجة الحروف 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: مثال grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']""""""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/82,acm_Arab,python,"
def prime_length(string):
    """"""اكتب دالة تأخذ سلسلة وترجع صحيح اذا طول السلسلة عدد أولي او غلط اذا لم يكن مثال prime_length{'hello') == true prime_length{'abcdcba') == true prime_length{'kittens') == true prime_length{'orange') == false """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

",,,
HumanEval/83,acm_Arab,python,"
def starts_one_ends(n):
    """"""معطيا عدد صحيح موجب n، ارجع عدد ارقام الصحيحين الايجابين من رقم n اللى تبدا او تنتهي بـ 1.""""""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/84,acm_Arab,python,"
def solve(N):
    """"""وبالنظر الى عدد صحيح ايجابي N، ارجع مجموع ارقامه في النموذج الثنائي. مثال لـ N = 1000، مجموع الارقام سيكون 1 وينبغي ان يكون الناتج ""1"". لـ N = 150, مجموع الارقام سيكون 6 وينبغي ان يكون الناتج ""110"". لـ N = 147, مجموع الارقام سيكون 12 وينبغي ان يكون الناتج ""1100"". متغيرات: @N عدد صحيح قيود: 0 â‰¤ N â‰¤ 10000. الناتج: سلسلة من الأرقام الثنائية """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

",,,
HumanEval/85,acm_Arab,python,"
def add(lst):
    """"""وبالنظر الى قائمة غير فارغة من الأعداد الصحيحة lst. اضف العناصر الزوجية التي في المؤشرات الغريبة. مثال: اضف (([4, 2, 6, 7]) ==> 2 """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
",,,
HumanEval/86,acm_Arab,python,"
def anti_shuffle(s):
    """"""اكتب دالة تأخذ سلسلة وترجع نسخة مرتبة منها. نسخة مرتبة من السلسلة، هي سلسلة حيث يتم استبدال كافة الكلمات (مفصولة بالفراغ) بكلمة جديدة حيث يتم ترتيب جميع الحروف بالترتيب الصاعد بناء على قيمة ascii. ملاحظة: يجب عليك الاحتفاظ بترتيب الكلمات والفراغات الفارغة في الجملة. مثل: anti_shuffle ((('Hi') يرجع 'Hi' anti_shuffle ((('hello') يرجع 'ehllo' anti_shuffle (('Hello World!!!') يرجع 'Hello !!!Wdlor' """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/87,acm_Arab,python,"
def get_row(lst, x):
    """"""تُعْطَى بيانات ثنائية الأبعاد ، كقوائم متداخلة ، والتي تشبه المصفوفة ، ومع ذلك ، على عكس المصفوفات ، يمكن لكل صف أن يحتوي على عدد مختلف من الأعمدة. مع إعطاء lst ، والعدد الكلي x ، ابحث عن الأعداد الصحيحة x في القائمة ، وإرجاع قائمة من التوبلات ، [(x1 ، y1 ، (x2 ، y2) ...) بحيث يكون كل توبل هو إحداثي - (صف ، أعمدة) ، تبدأ ب 0. رتب الإحداثيات في البداية حسب الصفوف بالترتيب الصاعد. أيضا ، رتب إحداثيات الصف حسب الأعمدة بالترتيب الهبوطي. الأمثلة: get_row [1,2,3,4,5,6 ] ، [1,2,3,4,1,6 ] ، [1,2,3,4,5,1] ، 1) == [0,0, 0, 0 ] ، (1, 4), 0 ، (2 ، 5), (2 ، 0) get_(] ، 1) [] ==_[[صف 1 ، 2 ، 3]] ، [2, 2]""""""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/88,acm_Arab,python,"
def sort_array(array):
    """"""وَمَعَ رُبُطِ الأعدادِ الصحيحةِ الغيرِ السلبيةِ، ارْجِعْ نسخةً من الرُبُطِ الْمَعْطُوِيِ بعدَ التَصْنِيفِ، وَتُصنِّفُ الرُبُطَ الْمَعْطُوِيَّ بِالتَّرْتِيبِ الصَّاعِدِ إِنْ كَانَتْ المُضَارَبَةُ ((قِيمَةُ المُؤَوِّلِ، قِيمَةُ المُؤَوِّلِ الْآخِرِ)) فَرِدَةً، أَوْ تُصنِّفُهُ بِالتَّرْتِيبِ الْهَابِطِ إِنْ كَانَتْ المُؤَوِّلَةُ ((قِيمَةُ المُؤَوِّلِ، قِيمَةُ الْآخِرِ)) زَرِفَةً.""""""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

",,,
HumanEval/89,acm_Arab,python,"
def encrypt(s):
    """"""اعمل وظيفة encrypt التي تأخذ سلسلة كحجة وتعيد سلسلة مشفرة مع تدوير الأبجدية. يجب تدوير الأبجدية بطريقة تتحول الحروف للأسفل بمضاعفة اثنين لمكانين. مثل: encrypt ((('hi') تعيد 'lm' encrypt ((('asdfghjkl') تعيد 'ewhjklnop' encrypt ((('gf') تعيد 'kj' encrypt ((('et') تعيد 'ix' """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/90,acm_Arab,python,"
def next_smallest(lst):
    """"""تُعْطَى لك قائمة من الأعداد الصحيحة. اكتب دالة next_smallest (() التي ترجع ثاني أصغر عنصر في القائمة. ترجع لا شيء اذا لم يكن هناك عنصر كهذا. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == لا شيء next_smallest (([1, 1]) == لا شيء """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/91,acm_Arab,python,"
def is_bored(S):
    """"""سَتُعْطَى لكِ سلسلة كلمات، وَمُهِمَّتُكِ هي عِدَّةُ المملات. المملة هي جملة تبدأ بكلمة ""I"". تُقَيَّدُ الجُمُلُ بـ """"., ""?' او ""! "" . مثلًا: >>> is_bored(""Hello world"") 0 >>> is_bored(""السماء زرقاء. الشمس تَشْرَق. احب هذا الطقس"") 1 """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/92,acm_Arab,python,"
def any_int(x, y, z):
    '''اعمل دالة تأخذ 3 ارقام. ترجع صحيح اذا كان واحد من الارقام يساوي مجموع الارقام الاخرى اثنين، وكل الارقام عددا صحيحين. ترجع غلط في اي حالات اخرى. مثالات any_int{5, 2, 7} -> True any_int{3, 2, 2} -> False any_int{3, -2, 1) -> True any_int{3.6, -2.2, 2) -> False '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

",,,
HumanEval/93,acm_Arab,python,"
def encode(message):
    """"""اكتب دالة تأخذ رسالة، وتقوم بتشفيرها بطريقة تغير الحروف الكبيرة، وتستبدل كل الحروف الصوتية في الرسالة بحرف يظهر مكانين قبل هذا الحرف الصوتي في الأبجدية الانجليزية. افترض الحروف فقط. مثال: >>> encode('test') 'TGST' >>> encode('This is a message') 'tHKS KS C MGSSCGG' """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/94,acm_Arab,python,"

def skjkasdkd(lst):
    """"""اُعْطِيَتْكَ قائمة من الأعداد الصحيحة. تُريد ان تَجِدَ القيمة الأولية الأكبر وتُرجِع مجموع أرقامها. مثال: لـ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] الخروج يجب ان يكون 10 لـ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] الخروج يجب ان يكون 25 لـ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] الخروج يجب ان يكون 13 لـ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] الخروج يجب ان يكون 11 لـ lst = [0,81,12,31,21] الخروج يجب ان يكون 3 لـ lst = [0,8,1,2,1,7] الخروج يجب ان يكون 7""""""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
",,,
HumanEval/95,acm_Arab,python,"
def check_dict_case(dict):
    """"""وبالنظر الى قاموس، ارجع صحيح اذا كانت كل المفاتيح سلسلة حروف صغيرة او كل المفاتيح سلسلة حروف كبيرة، و الا ارجع غلط. يجب ان ترجع الوظيفة غلط اذا كان القاموس فارغ. مثال: check_dict_case{""a"":""apple"", ""b"":""banana""}) يجب ان ترجع صحيح. check_dict_case{""a"":""apple"", ""A"":""banana"", ""B"":""banana""}) يجب ان ترجع غلط. check_dict_case{""a"":""apple"", 8:""banana"", ""a"":""apple""}) يجب ان ترجع غلط. check_dict_case{""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) يجب ان ترجع غلط. check_dict_case{""NC"":""STATE"", ""ZIP:""12345"" }) يجب ان ترجع صحيح.""""""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

",,,
HumanEval/96,acm_Arab,python,"
def count_up_to(n):
    """"""اعملي دالة تأخذ عدداً صحيحاً غير سلبي وترجع صف من الاول n عدداً صحيحاً اولية واصغر من n. مثل: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17] """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

",,,
HumanEval/97,acm_Arab,python,"
def multiply(a, b):
    """"""اكمل الدالة اللى تأخذ اثنين من الأعداد الصحيحة وتعود بإنتاج رقم وحدتها. افترض ان المدخلات صالحة دائما. مثال: ضرب 148, 412) يجب ان يعود 16. ضرب 19، 28 يجب ان يعود 72. ضرب 2020، 1851 يجب ان يعود 0. ضرب 14، 15 يجب ان يعود 20.""""""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

",,,
HumanEval/98,acm_Arab,python,"
def count_upper(s):
    """"""معطاة سلسلة s، عد عدد الحروف العلوية الكبيرة في المؤشرات الزوجية. مثلاً: count_upper (('aBCdEf') يرجع 1 count_upper (('abcdefg') يرجع 0 count_upper (('dBBE') يرجع 0 """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/99,acm_Arab,python,"
def closest_integer(value):
    '''اعمل دالة تأخذ قيمة (سلسلة) تمثل رقم وتعيد اقرب عدد صحيح له. اذا كان الرقم مساوي من عددين صحيحين، اقربها من الصفر. مثال >>> اقرب عدد صحيح (((""10"") 10 >>> اقرب عدد صحيح (((""15.3"") 15 ملاحظة: اقرب من الصفر يعني اذا كان الرقم المعطى مساوي من عددين صحيحين، فان الاكثر ابعد من الصفر هو الاكثر ابعد من الصفر. مثلا اقرب عدد صحيح (((14.5"") يجب ان يعود 15 وا اقرب عدد صحيح (((-14.5"") يجب ان يعود -15. '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

",,,
HumanEval/100,acm_Arab,python,"
def make_a_pile(n):
    """"""وبالنظر الى عدد صحيح موجب n، عليك ان تصنع كومة من n مستويات من الحجارة. المستوى الاول فيها n حجر. عدد الحجارة في المستوى التالي هو: - العدد الغريب التالي اذا كان n غريبا. - العدد الزوج التالي اذا كان n زوجا. ارجع عدد الحجارة في كل مستوى في قائمة، حيث يمثل العنصر في المؤشر i عدد الحجارة في المستوى (i+1).""""""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/101,acm_Arab,python,"
def words_string(s):
    """"""سَتُعْطَى سِلْكَةً مِنْ كَلِمَاتٍ مُفَرَّقَةً بِالْفُرْقَةِ. وَمُهِمُّكَ هُوَ انْقِسَامُ السِلْكَةِ لِكَلِمَاتٍ وَرُجُوعُ مَصْفٍ مِنَ الْكَلِمَاتِ. مثلًا: words_string (((""مرحبا اسمي جون"") == [""مرحبا""، ""اسمي""، ""اسمي""، ""جون""] words_string (((""واحد، اثنين، ثلاثة، أربعة، خمسة، ستة"") == [""واحد""، ""اثنين""، ""ثلاثة""، ""أربعة""، ""خمس""، ""ستة""] """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

",,,
HumanEval/102,acm_Arab,python,"
def choose_num(x, y):
    """"""هذي الدالة تاخذ اثنين من الأرقام الإيجابية x و y وتعيد اكبر عدد صحيح زوج في النطاق [x، y] شامل. اذا ما كان هناك مثل هذا العدد، فالدالة يجب ان ترجع -1. مثلا: choose_num(12, 15) = 14 choose_num(13, 12) = -1 """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

",,,
HumanEval/103,acm_Arab,python,"
def rounded_avg(n, m):
    """"""اُعْطِيَكَ اثنين من الأعداد الصحيحة الايجابية n و m، و مهمتك هي حساب متوسط الأعداد الصحيحة من n الى m (بما في ذلك n و m). اقترب من الجواب الى اقرب عدد صحيح و حول هذا الى ثنائي. اذا n اكبر من m، ارجع -1. مثال: rounded_avg(1, 5) => ""0b11"" rounded_avg(7, 5) => -1 rounded_avg(10, 20) => ""0b1111"" rounded_avg(20, 33) => ""0b11010"" """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

",,,
HumanEval/104,acm_Arab,python,"
def unique_digits(x):
    """"""وَمِنْ قِبَلِ قِائِمَةٍ مِنْ الأَعْدَادِ الصَّحِيحَةِ x، ارْجِعْ بِقِيَامَةٍ مُنَقَّضَةٍ مِنْ كُلِّ العَنَاصِرِ الَّتِي لا تَتَضَمَّنُ أَيَّ أَرْقَامٍ زَوِيَّةٍ. لاحظ: القِيَامَة الْمُرْجَعَةُ يَجِبُ أَنْ تُنَقَّبَ بِالتَّرْتِيبِ الْمُتَزَايِد. مثلًا: >>> unique_digits (([15, 33, 1422, 1]) [1, 15, 33] >>> unique_digits (([152, 323, 1422, 10]) [] """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/105,acm_Arab,python,"
def by_length(arr):
    """"""وَمِنْ مَصْفَرِ الأعدادِ الصحيحة، فَصَفِّ الأعدادَ الصحيحةَ التي تَتَراوحُ بين 1 و 9، وَعَكِّسِ المَصْفَرَ النَّاتِجَ، وَبَعْدَ ذلكَ اسْتَبْدِلْ كُلَّ رقمٍ بِاسْمِهِ المُتَوافقِ مِنْ ""واحد""، ""اثنين""، ""ثلاثة""، ""أربعة""، ""خمْسَة""، ""ستة""، ""سبعة""، ""ثمانية""، ""تِسْعَة"". مثلً: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> sort arr -> [1, 1, 2, 3, 4, 5, 8] -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1] return [""ثمانية""، ""أربعة""، ""ثلاثة""، ""اثنين""، ""اثنين""، ""اثنين""، ""واحد""، ""واحد""] إذا كان المَصْفَرُ فاضًا، فَرِدْ: arr = [] return [] [] If the resulting array has any odd number, ignore it: arr = [1, - 1 , - 55 -> arr -> arr - 1، - 1 -> arr -> [1, - 1]""""""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

",,,
HumanEval/106,acm_Arab,python,"
def f(n):
    """"""اعملي الدالة f التي تأخذ n كمعلم، وتعيد قائمة بحجم n، بحيث تكون قيمة العنصر في المؤشر i هو عامل i اذا i زوج او مجموع الأرقام من 1 الى i خلاف ذلك. i تبدأ من 1. عامل i هو ضرب الأرقام من 1 الى i (1 * 2 * ... * i). مثال: f(5) == [1, 2, 6, 24, 15] """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
",,,
HumanEval/107,acm_Arab,python,"
def even_odd_palindrome(n):
    """"""وبالنظر الى عدد صحيح موجب n، ارجع توبل يحتوي على عدد من palindromes عدد صحيح متساوي و غير متساوي يقعون في النطاق ((1، n) ، متضمنين. مثال1: المدخل: 3 الناتج: (1, 2) التفسير: palindrome عدد صحيح هو 1، 2، 3. واحد منهم متساوي، واثنين منهم غير متساوي. مثال2: المدخل: 12 الناتج: (4, 6) التفسير: palindrome عدد صحيح هو 1، 2، 3، 4، 5، 6، 7، 8، 9، 11. أربعة منهم متساوي، و 6 منهم غير متساوي. ملاحظة: 1 <= n <= 10^3 2. توبل ارجع عدد من palindromes عدد صحيح متساوي و غير متساوي على التوالي. """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/108,acm_Arab,python,"
def count_nums(arr):
    """"""اكتب دالة count_nums التي تأخذ صف من الأعداد الصحيحة وتعيد عدد العناصر التي لها مجموع من الأرقام > 0. اذا كان الرقم سلبي، فان اول رقم موقعه سيكون سلبي: مثلاً -123 لديه أرقام موقعة -1, 2 و 3. >>> count_nums (([]) == 0 >>> count_nums (([-1, 11, -11]) == 1 >>> count_nums (([1, 1, 2]) == 3 """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/109,acm_Arab,python,"
def move_one_ball(arr):
    """"""عِنْدَنَا صف 'arr' مِنْ N عدد صحيح arr[1], arr[2], ..., arr[N]. الارقام في المصف سيتم ترتيبها بشكل عشوائي. مهمتك هي تحديد اذا كان من الممكن ان يتم ترتيب المصف بالترتيب غير المتناقص عن طريق اجراء العملية التالية على المصف: يُسمح لك ان تقوم بعملية التحول اليميني اي عدد من المرات. عملية التحول اليميني الواحدة تعني ان تقوم بتحريك جميع عناصر المصف بموقع واحد في الاتجاه الايمن. العنصر الاخير من المصف سيتم نقله الى الموقع الاول في المصف يعني 0th index. اذا كان من الممكن الحصول على المصف المصنف من خلال اجراء العملية اعلاه ثم اعادة True اذا كان المصف فارغ ثم اعادة False. ملاحظة: يضمن ان القائمة المحددة لها عناصر فريدة. مثل: move_one_(ball_[3, 4, 5, 2]==>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>""""""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
",,,
HumanEval/110,acm_Arab,python,"
def exchange(lst1, lst2):
    """"""في هذه المشكلة، ستقوم على تطبيق دالة تأخذ اثنين من القوائم من الأرقام، وتحدد اذا كان من الممكن القيام بتبادل العناصر بينهم لجعل lst1 قائمة من الأرقام الزوجية فقط. لا يوجد حد على عدد العناصر المتبادلة بين lst1 و lst2. اذا كان من الممكن تبادل العناصر بين lst1 و lst2 لجعل كل عناصر lst1 زوجية، ارجع ""نعم"". و الا ارجع ""لا"". مثلا: تبادل[(1, 2, 3, 4], [1, 2, 3, 4]) => ""نعم"" تبادل[(1, 2, 3, 4], [1, 5, 3, 4]) => ""لا"" يفترض ان القوائم المضافة لن تكون فارغة.""""""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

",,,
HumanEval/111,acm_Arab,python,"
def histogram(test):
    """"""وَبِمَا انْتَهَى من سِلْطَة تمثِل حروفًا صغيرة منفصلة عن بعضها بـ فَرْق، ارْجِعْ معجمًا للكِتَابِ الْمُتَكَرَّرِ وَالْمُتَوافِقِ. وَاذا كان لعدة حروف نفس الحروف، ارْجِعْ كُلَّهُمْ. مثال: هِستُوْرَام ((('a b c') == {'a': 1, 'b': 1, 'c': 1} هِستُوْرَام ((('a b b a') == {'a': 2, 'b': 2} هِستُوْرَام ((('a b c a b') == {'a': 2, 'b': 2} هِستُوْرَام ((('b b a') == {'b 4}': هِستُوْرَام (((')) == {} }""""""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

",,,
HumanEval/112,acm_Arab,python,"
def reverse_delete(s,c):
    """"""مهمة احنا اعطينا سلاسل s و c، عليك حذف كل الحروف في s التي تساوي اي حرف في c ثم تحقق اذا كان السلاسل الناتج هو بالندروم. السلاسل تسمى بالندروم اذا كانت تقرأ نفس الوضع للخلف والامام. يجب عليك ارجاع توبل يحتوي على السلاسل الناتج و True/False للتحقق. مثال لـ s = ""abcde""، c = ""ae""، النتيجة يجب ان تكون ('bcd'، False) لـ s = ""abcdef""، c = ""b"" النتيجة يجب ان تكون ('acdef'، False) لـ s = ""abcdedcba""، c = ""ab"", النتيجة يجب ان تكون ('cdedc'، True)""""""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
",,,
HumanEval/113,acm_Arab,python,"
def odd_count(lst):
    """"""وبالنظر الى قائمة من السلاسل، حيث كل سلاسل تتكون من ارقام فقط، ارجع قائمة. كل عنصر i من الناتج يجب ان يكون ""عدد العناصر الغير عادلة في السلاسل i من المدخل. "" حيث يجب ان يتم استبدال جميع is بعدد من الارقام الغير عادلة في السلاسل i من المدخل. >>> odd_count['1234567']) [""عدد العناصر الغير عادلة 4n the str4ng 4 of the 4nput.""] >>> odd_count['3',""111111""]) [""عدد العناصر الغير عادلة 1n the str1ng 1 of the 1nput. ""، ""عدد العناصر الغير عادلة 8n the str8ng 8 of the 8nput. ""]""""""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/114,acm_Arab,python,"
def minSubArraySum(nums):
    """"""معطياً صف من الأعداد الصحيحة n، اعثر على الحد الادنى من مجموع أي صف فرعي من الأعداد غير فارغ. مثال minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6 """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
",,,
HumanEval/115,acm_Arab,python,"
def max_fill(grid, capacity):
    import math
    """"""اُعطيت شبكة مستطيلة من الآبار. كل صف يمثل بئر واحد، وكل واحد في صف يمثل وحدة واحدة من المياه. كل بئر لديه دلو متوافق يمكن استخراج المياه منه، وكل الدلوين لها نفس القدرة. مهمتك هي استخدام الدلوين لتفريغ الآبار. اخرج عدد المرات التي تحتاجها لخفض الدلوين. مثال 1: مدخل: شبكة: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 اخرج: 6 مثال 2: مدخل: شبكة: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 اخرج: 5 مثال 3: مدخل: [[:0,0,0], [0,0,0]] bucket_capacity: 5 اخرج: 0 * * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 2 * 1 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 1 * 2 * 2 * 1 * 2 * 2 * 3 * 1 * 2 * 2 * 3 * 4 * 5 * 6 * 1 * 1 * 2 * 2 * 2 * 2 * 6 * 1 * 2 * 2 * 2 * 3 * 4 * 5 * 6 * 6 * 7 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 *""""""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

",,,
HumanEval/116,acm_Arab,python,"
def sort_array(arr):
    """"""في هذه الكاتا، عليك ان تقوم بترتيب صفيف من الأعداد الصحيحة غير السالبة حسب عدد الواحد في التمثيل الثنائي لها بالترتيب الصاعد. لعدد مماثل من الواحد، ترتيب على أساس القيمة العشرية. يجب تنفيذها مثل هذا: >>> sort_array (([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5] >>> sort_array (([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2] >>> sort_array (([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4] """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/117,acm_Arab,python,"
def select_words(s, n):
    """"""وَبِمَا انْتَبَهْتَ لِسِلْطَةِ s وَلِعَدَدِ n، فَقَدْ تُكَلَّفْتَ بِتَنْفِيذِ دَلِيلٍ يَرُدُّ قِيَامَ كُلِّ الكَلِمَاتِ مِنْ سِلْطَةِ s الَّتِي تَتَضَمَّنُ نَحْوَ نُحُوًا مِنَ الْمُضَارِعِ، لِيَظْهَرَ هَذِهِ الْكَلِمَاتُ فِي سِلْطَةِ s. وَإِنْ كَانَتْ سِلْطَةُ s فَارِغَةً فَيَجِبُ أَنْ تَرُدَّ قِيَامَهَا فَارِغَةً.""""""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

",,,
HumanEval/118,acm_Arab,python,"
def get_closest_vowel(word):
    """"""اُعْطِيَتْكَ كَلِمَةٌ. مُهِمَّتُكَ هِيَ انْ تَجِدَ الْحَرْفَ الْأَقْرَبَ الْمَوْجُودَ بَيْنَ حَرْفَيْنِ مِنْ الْجِهَةِ الْيُمْنَى مِنَ الْكَلِمَةِ (حَاسِسَ الْحَرْفِ). الْحَرْفَانِ فِي الْبَدْءِ وَالْانْتِهَاءِ لا يُعَدُّونَ. ارْجِعِ السِّلْكَ الفارِغَ إِنْ كُنْتَ لا تَجِدُ حَرْفًا يُوَافِقُ الشَّرْطَ الْمَذْكُورَ. يُمْكَنُ أَنْ السِّلْكَ يَ الْتَحَرْفُ.""""""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/119,acm_Arab,python,"
def match_parens(lst):
    '''اُعْطِيَتْكَ قِيَامَةٌ مِنْ سِلْسِلَتَيْنِ، كُلُّ السِلْسِلَتَيْنِ مَكْتُوبَتَانِ مِنْ قُرْبَتَيْنِ مَفْتُوحَتَيْنِ '(' أَوْ قُرْبَتَيْنِ مَغْلُوبَتَيْنِ ') '. مُهِمُّكَ انْ تَتَحَقَّقَ مِنْ إمكانِ تَصَرُّفِ السِلْسِلَتَيْنِ بِمُتَوَالِي، وَيَكُونُ السِلْسِلَةُ النَّاتِجَةُ مُحْسَنَةً. سِلْسِلَةُ S تُعْتَبَرُ مُورَةً وَةً وَ الْسِلْسِلَةُ '(((()) ')) '==' == 'لا''''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

",,,
HumanEval/120,acm_Arab,python,"
def maximum(arr, k):
    """"""وبالنظر الى صف arr من الأعداد الصحيحة و k من الأعداد الصحيحة الايجابية، ارجع قائمة مرتبة بطول k مع اعلى عدد k في arr. مثال1: المدخلات: arr = [-3, -4, 5], k = 3 الناتج: [-4, -3, 5] مثال2: المدخلات: arr = [4, -4, 4], k = 2 الناتج: [4, 4] مثال3: المدخلات: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 الناتج: [2] ملاحظة: 1. طول المصفوفة سيكون في نطاق [1, 1000]. 2. العناصر في المصفوفة ستكون في نطاق [-1000, 1000]. 3. 0 <= k <= len ((arr) """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

",,,
HumanEval/121,acm_Arab,python,"
def solution(lst):
    """"""وبالنظر الى قائمة غير فارغة من الأعداد الصحيحة، ارجع مجموع كل العناصر الغريبة التي في مواقع متساوية. مثال حل (([5, 8, 7, 1]) ==> 12 حل (([3, 3, 3, 3, 3]) ==> 9 حل (([30, 13, 24, 321]) ==> 0 """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

",,,
HumanEval/122,acm_Arab,python,"
def add_elements(arr, k):
    """"""وبالنظر الى صف غير فارغ من الأعداد الصحيحة arr و k، ارجع مجموع العناصر مع رقمين كحد أقصى من العناصر k الاولى من arr. مثال: المدخلات: arr = [111,21,3,4000,5,6,7,8,9], k = 4 الناتج: 24 # مجموع 21 + 3 القيود: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)""""""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/123,acm_Arab,python,"
def get_odd_collatz(n):
    """"""وبالنظر الى عدد صحيح ايجابي n، ارجع قائمة مرتبة فيها الأرقام الغير متساوية في تسلسل كولاتز. تخمين كولاتز هو تخمين في الرياضيات يتعلق بتسلسل محدد على النحو التالي: ابدأ بأي عدد صحيح ايجابي n. ثم كل عبارة يتم الحصول عليها من العبارة السابقة على النحو التالي: اذا كانت العبارة السابقة زوجية، العبارة التالية هي نصف العبارة السابقة. اذا كانت العبارة السابقة فريدة، العبارة التالية هي 3 مرات العبارة السابقة زائد 1. التخمين هو انه بغض النظر عن اي قيمة لـ n، سيتم الوصول الى التسلسل دائما 1. لاحظ: 1. كولاتز (((1) هو [1] 2. القائمة المرجعة مرتبة بالترتيب المتزايد. مثلا: get_odd_collatz ((5) يرجع [1, 5] # تسلسل كولاتز لـ 5 هو [5, 8, 16, 4, 2, 1], لذلك الأرقام الغير متساوية هي فقط 1 و 5.""""""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/124,acm_Arab,python,"
def valid_date(date):
    """"""اِكْتِبْ دَلِيل يُصَحِّحُ سِلْطَةَ تاريخٍ مَعْطُوفٍ وَيَرُدُّ صَحِيحًا إِنْ كَانَتْ الصَّحِيحَةَ وَإِلا فَكَذِبًا. الصِّحَاحُ صَحِيحٌ إِنْ كُلُّ الْقَوَانِينِ التَالِيَةِ تَكُنْ مُطْمَئِنَّةً: 1. سِلْطَةُ التَّاريخِ لَيْسَتْ فَارِغَةً. 2. عدد الأيَّام لا يَكُونُ اقل من 1 أو اكبر من 31 يومًا لأشهر 1,3,5,7,8,10,12. وعدد الأيَّام لا يَكُونُ اقل من 1 أو اكبر من 30 يومًا لأشهر 4,6,9,11. وعدد الأيَّام لا يَكُونَ اقل من 1 أو اكبر من 29 يومًا لأشهر 2. 3. الشُشهر لا يَجِبَرُوا 1 أو اكبر من 12.""""""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
",,,
HumanEval/125,acm_Arab,python,"
def split_words(txt):
    '''وبالنظر الى سلسلة كلمات، ارجع قائمة كلمات مقسمة على الفراغ، اذا ما كان هناك فراغ في النص يجب ان تقسم على الفواصل '، اذا لم تكن هناك فواصل يجب ان ترجع عدد الحروف الصغيرة بالترتيب الغريب في الأبجدية، ord('a') = 0، ord'(b') = 1، ... ord('z') = 25 امثلة split_words (((""مرحبا العالم!"") â -> [""مرحبا العالم!""] split_words (((""مرحبا العالم!"") â -> [""مرحبا العالم!""] split_words (((""abcdef"") == 3 '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
",,,
HumanEval/126,acm_Arab,python,"
def is_sorted(lst):
    '''وَمِنْ قِبَلِ قِائِمَةٍ مِنَ الأَرْقَامِ، ارْجِعْ سَوَاءٌ هُمْ مُصَفَّفُونَ بِالتَّرْتِيبِ الصَّاعِدِ. وَإِنْ كَانَتْ قِائِمَةُ الأَرْقَامِ مُتَكَاثِلَةً، ارْجِعْ عَنْ الْكَذِبِ. لا تَتَأَمَّلْ أَنْ لا يَكُونَ أَرْقَامٌ سَلبِيَّةٌ وَإِنَّمَا الأَرْقَامُ كُلُّهَا عَدَدٌ كَامِلٌ.'''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

",,,
HumanEval/127,acm_Arab,python,"
def intersection(interval1, interval2):
    """"""اُعْطِيَتْكَ فَسَاطَتَانِ، حيثُ كُلُّ فَسَاطٍ زوجٌ مِنْ الأعدادِ الصحيحة. مثلًا، فَسَاط = (بداية، نهاية) = (1, 2). فَسَاطَتَانِ مَغْلُولَتَانِ، وَمَعْنَاهُمَا أنَّ فَسَاطَ (بداية، نهاية) يَشْمَلُ بِدَايَةً وَنهايةً. فَلِكُلِّ فَسَاطٍ مَعْطُوْلٍ، يُفترضُ أنَّ بَدَايَتَهُ اِسْتَقْصَرَتْ مِنْ نهايتِهَا. مُهِمَّةُكَ هِيَ تَحْدِيدُ طُولِ تَقاطعِ هَذَيْنِ الْفَسَاتَيْنِ عَدَيْدَيْ. فَإِنْ طُولِ التَقاطعِ هُوَ ""نَا"" وَلا، وَإِلا، فَ ""لا"".""""""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

",,,
HumanEval/128,acm_Arab,python,"
def prod_signs(arr):
    """"""اُعطيت صف من الأعداد الصحيحة ويحتاجك ان ترجع مجموع مقادير الأعداد الصحيحة مضروبة ب ضرب كل علامات كل رقم في المصفوفة، الممثل بـ 1، -1 او 0. ملاحظة: ارجع لا شيء لصف فارغ. مثال: >>> prod_signs (([1, 2, 2, -4]) == -9 >>> prod_signs (([0, 1]) == 0 >>> prod_signs (([]) == لا شيء""""""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/129,acm_Arab,python,"
def minPath(grid, k):
    """"""وَبِمَا انْتَبَهْتَ لِشُبْكَةٍ بِنُتُبِ نُتُبٍ وَنُتُبِ عَمُودٍ (ن >= 2) وَكُلُّ خُلاَءٍ مِنْهَا عَدَدٌ كَامِلٌ مُوجِبٌ لِكُلِّ خُلاَءٍ مِنْهَا. وَكُلُّ عَدَدٍ كَامِلٍ مِنْ نُتُبِ يَظْهَرُ مَرَّةً فِي خُلاَءِ الشبْكَةِ. وَيَجِبُ أَنْ تَجِدَ حَدَثَةً حَدَثِيَّةً فِي خُلاَءِ الشبْكَةِ. وَيَجِبُ أَنْ تَبْدَأَ مِي مِنْ كُلُتُبْكَةٍ وَيَ تَتُبْكَ تَتُرَةً وَخْ تَخْرَةً. وَجَدَدَدَ الْتْتْتُ الْ مِيَةُ الْ تَتَوَقِيْعَةُ الْ وَةُ.""""""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

",,,
HumanEval/130,acm_Arab,python,"
def tri(n):
    """"""كل شخص يعرف تسلسل فيبوناتشي، وقد درسوه بعمق من قبل علماء الرياضيات في القرنين الماضيين. لكن ما لا يعرفه الناس هو تسلسل تريبوناتشي. يتم تعريف تسلسل تريبوناتشي من خلال التكرار: tri(1) = 3 tri(n) = 1 + n / 2، اذا n زوج. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1) ، اذا n فريد. مثلا: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 تعطيك عدد صحيح غير سالب n، عليك ان ترجع قائمة بأول n + 1 ارقام من تسلسل تريبوناتشي. مثال: tri(3) = [1, 3, 2, 8]""""""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
",,,
HumanEval/131,acm_Arab,python,"
def digits(n):
    """"""معطيا عدد صحيح موجب n، ارجع ضرب الارقام الغريبة. ارجع 0 اذا كانت الارقام زوجية. مثلًا: ارقام ((1) == 1 ارقام ((4) == 0 ارقام ((235) == 15 """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

",,,
HumanEval/132,acm_Arab,python,"
def is_nested(string):
    '''اعمل دالة تأخذ كمدخلة سلسلة من الأقواس المربعة فقط. يجب ان تعيد دالة True اذا كان هناك سلسلة من الأقواس صالحة فيها اقلاً قوس واحد في التسلسل. is_nested'[[]]') â -> True is_nested'[[]]]]]]]]][[[[[]') â -> False is_nested'[][]') â -> False is_nested'[]') â -> False is_nested'[[]') â -> False is_nested'[[][]]') â -> True is_nested'[[]]]]]]]]]]'''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

",,,
HumanEval/133,acm_Arab,python,"

def sum_squares(lst):
    """"""اُعْطِيَتْكَ قائمة من الأرقام. اُحتاجُكَ انْ تُرجِعَ مجموع الأرقام المربعة في القائمة المُعطَاة، و تُقِرُّ كل عنصر في القائمة الى العُلْيَا اولا. مثال: لـ lst = [1,2,3] الخروج يجب ان يكون 14 لـ lst = [1,4,9] الخروج يجب ان يكون 98 لـ lst = [1,3,5,7] الخروج يجب ان يكون 84 لـ lst = [1.4,4.2,0] الخروج يجب ان يكون 29 لـ lst = [-2.4,1,1] الخروج يجب ان يكون 6 """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/134,acm_Arab,python,"
def check_if_last_char_is_a_letter(txt):
    '''اعمل دالة تعيد صحيح اذا اخر حرف في سلسلة معينة هو حرف حروف ابجدية وليس جزء من كلمة، و غلط اذا لم يكن. ملاحظة: ""كلمة"" هي مجموعة من الحروف منفصلة عن بعضها باستخدام الفراغ. مثال: check_if_last_char_is_a_letter (((""كعكة التفاحة"") â -> false check_if_last_char_is_a_letter (((""كعكة التفاحة e"") â -> true check_if_last_char_is_a_letter (((""كعكة التفاحة e"") â -> false check_if_last_char_is_a_letter"" ((("") â -> false check_if_last_char_is_a_letter ""'''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/135,acm_Arab,python,"
def can_arrange(arr):
    """"""اعمل دالة تعيد اكبر مؤشر لعنصر لا اكبر من او يساوي العنصر الاول مباشرة. اذا لم يكن هناك مثل هذا العنصر اعيد -1. المصفوفة المحددة لن تحتوي على قيم مكررة. مثال: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1 """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

",,,
HumanEval/136,acm_Arab,python,"
def largest_smallest_integers(lst):
    '''اعمل دالة تعيد توبل (a, b) ، حيث 'a' هو اكبر عدد صحيح سالب، و'b' هو الاصغر عدد صحيح موجب في القائمة. اذا ما كان هناك عدد صحيح سالب او ايجابي، اعادهم باسم لا. مثال: اكبر_اصغر_مجموعات صحيح[2, 4, 1, 3, 5, 7]) == (لا, 1) اكبر_اصغر_مجموعات صحيح (([]) == (لا, لا) اكبر_اصغر_مجموعات صحيح (([0]) == (لا, لا)'''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
",,,
HumanEval/137,acm_Arab,python,"
def compare_one(a, b):
    """"""اعمل دالة تأخذ عدداً صحيحاً، عَائِمَةً، او سلاسل تمثل أرقاماً حقيقية، وتعيد المتغير الأكبر في نوع المتغير المحدد. ترجع لا شيء اذا كانت القيم متساوية. ملاحظة: اذا تمثل رقم حقيقي كسلسلة، النقطة العائمة قد تكون . او , compare_one{1,2,5} -> 2.5 compare_one{1,2,3}) -> ""2,3"" compare_one{5,1}"", ""6"") -> ""6"" compare_one{1}"", 1) -> لا شيء """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/138,acm_Arab,python,"
def is_equal_to_sum_even(n):
    """"""احصلي اذا كان الرقم المعطى n يمكن ان يكتب كمجموع 4 ارقام زوجية ايجابية بالضبط. مثال is_equal_to_sum_even ((4) == غلط is_equal_to_sum_even ((6) == غلط is_equal_to_sum_even ((8) == صحيح """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
",,,
HumanEval/139,acm_Arab,python,"
def special_factorial(n):
    """"""العامل البرازيلي يعرف على شكل: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! حيث n > 0 مثلاً: >>> special_factorial(4) 288 الوظيفة ستستلم عدد صحيح كمدخل ويجب ترجع العامل الخاص لهذا العدد الصحيح. """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

",,,
HumanEval/140,acm_Arab,python,"
def fix_spaces(text):
    """"""_مثال-3ِ، اِبْدَلْ كُلَ الْفُرُوجِ بِالْخُفْضِ، وَإِنْ كَانَتْ فِي الْفُرُوجِ فُرُوجُ مُتَتَابِعَةٍ اِبْدَلْ كُلَ الْفُرُوجِ بِ - fix_spaces (((""مثال"") == ""مثال"" fix_spaces (((""مثال1"") == ""مثال1"" fix_spaces (((""مثال2"") == ""مثال_2"" fix_spaces (((""مثال 3"") == ""مثال-3"" ""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

",,,
HumanEval/141,acm_Arab,python,"
def file_name_check(file_name):
    """"""اعمل دالة تأخذ سلسلة تمثل اسم الملف، وتعود ""نعم"" اذا كان اسم الملف صحيح، وتعود ""لا"" اذا لم يكن صحيح. اسم الملف يعتبر صحيح اذا و فقط اذا تم الوفاء بجميع الشروط التالية: - لا يجب ان يكون هناك اكثر من ثلاث ارقام ('0'-'9') في اسم الملف. - اسم الملف يحتوي على نقطة واحدة بالضبط. - لا يجب ان يكون السلسلة الفرعية قبل النقطة فارغة، ويجب ان تبدأ بحرف من الحروف الالفا لاتينية ('a'-'z' و 'A'Z'). - السلسلة الفرعية بعد النقطة يجب ان تكون واحدة من هذه: ['txt', 'exe', 'lld'] امثلة: file_name_check""(example.txt"") # => 'نعم' file_name_check""(example.dll1"") => 'لا' # (اسم الملف يجب ان يبدأ بحرف الالفا لاتينية)""""""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

",,,
HumanEval/142,acm_Arab,python,"


def sum_squares(lst):
    """""""" هذي الدالة راح تأخذ قائمة من الأعداد الصحيحة. لكل المداخل في القائمة، الدالة راح تربيع مدخل العدد الصحيح اذا كان مؤشرها مضاعف لـ 3 و راح تثني مدخل العدد الصحيح اذا كان مؤشرها مضاعف لـ 4 و ليس مضاعف لـ 3. الدالة راح لا تغير المداخل في القائمة التي مؤشراتها ليست مضاعفة لـ 3 او 4. الدالة راح ترجع بعدين مجموع كل المداخل. مثال: لـ lst = [1,2,3] المخرجة يجب ان تكون 6 لـ lst = [] المخرجة يجب ان تكون 0 لـ lst = [-1,-5,2,-1,-5] المخرجة يجب ان تكون -126 """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
",,,
HumanEval/143,acm_Arab,python,"
def words_in_sentence(sentence):
    """"""تُعْطَى لكِ سِلْسِلَة مُمَثِّلة لِجُمْلَة، وَالْجُمْلَة تَتَضَمَّن كَلِمَات بَعْضها مُفَارِق بِفَرْق، وَعَلَيْكِ انْتِقَال سِلْسِلَة تَتَضَمَّن كَلِمَات جُمْلَة الْأُصْلِيَّة، وَالْمُتَقَدِّمَات أَعْدَادَة، وَيَجِبُ انْتِقَال الْكَلِمَات في السِّلْسِلَة الجديدة بنفس الترتيب الْأَصْلِي. مثال1: إدخال: جُمْلَة = ""هذه اختبار"" إخراج: ""هو"" مثال2: إدخال: جُمْلَة = ""لنذهب للسباح"" إخراج: ""go for"" قياقات: * 1 <= len(جُمْلَة) <= 100 * جُمْلَة جُمْلَةُ جُ جُمْلَ جُمْلَةُ جُمْلَ جُمْلَةُ جُمْلِ جُمْلُمْلُمْ""""""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

",,,
HumanEval/144,acm_Arab,python,"
def simplify(x, n):
    """"""مُهمتُكَ تَنْفَذُ دَالةً تُبَسِّطُ التَّعْبِيرَ x * n. تَرُدُّ دَالةً True إذا x * n تُقَيِّمُ لعدد كلي و False إذا لا. كُلٌّ مِنَ x و n، هي تمثيلات سلسلة للكسر، ولها الشكل التالي، <numerator>/<denominator> حيث كل من المقام والمقاسم عدداً كاملاً إيجابياً. يمكنك أن تفترض أن x و n كسور صحيحين، وليس لـ صفر كمقام. simplify{""1/5""}، ""5/1"") = True{""1/6""}، ""2/1"") = False{""7/10""}، ""10/2"") = False """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

",,,
HumanEval/145,acm_Arab,python,"
def order_by_points(nums):
    """"""اكتب دالة تفرز القائمة المقدمة من الأعداد الصحيحة بالترتيب الصاعد حسب مجموع أرقامها. ملاحظة: اذا كان هناك عدة عناصر بمجموع أرقام مشابهة، ففرزها بناء على فهرسها في القائمة الأصلية. مثلًا: >>> order_by_points (([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points ([]) == [] """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/146,acm_Arab,python,"
def specialFilter(nums):
    """"""اكتب دالة تأخذ صف من الارقام كمدخل وتعيد عدد العناصر في المصف اكبر من 10 والاعداد الأول والاخير من الرقم عادي (1, 3, 5, 7, 9). مثلا: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2 """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

",,,
HumanEval/147,acm_Arab,python,"
def get_max_triples(n):
    """"""اُعْطِيَكَ عدد صحيح موجب n. اُعْطِيَكَ صف صف صفوفي a من طول n. لكل i (1 ‰¤ i ‰¤ n) ، قيمة a[i] = i * i - i + 1. اُرجِعْ عدد الثلاثيات (a[i], a[j], a[k]) من a حيث i < j < k، و a[i] + a[j] + a[k] مضاعفة ل 3. مثال: مدخل: n = 5 مخرج: 1 تفسير: a = [1, 3, 7, 13, 21] الثلاثية الوحيدة الصالحة هي (1, 7, 13).""""""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
",,,
HumanEval/148,acm_Arab,python,"
def bf(planet1, planet2):
    '''ثَمَانِي كَوْكَبٍ فِي نَظْمِنَا الشَّمْسِ: الأَقْرَبُ مِنَ الشَّمْسِ هُوَ زَهْرُوبُ، التَّالِي هُوَ الْقُمْسُ، ثُمَّ الْأَرْضُ وَمَارِسُ وَالْجُمْسُورُ وَزَهْرُوبُ وَيُورَانُسُ وَنَبْتُونُ. اُكْتُبْ دَلِيلًا يَأْخُذُ اسْمَيْ كَوْكَبٍ كَكَوْكَبٍ وَكَوْكَبٍ. يَجِبُ أَنْ يُرْجِعَ مُضَارَبَةً مَعَ كُلِّ الْكَوْكَبِ الَّتَيْنِ بَيْنَا بَ الْكَوْكَبِ وَالْكَكَبِبِ.'''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

",,,
HumanEval/149,acm_Arab,python,"
def sorted_list_sum(lst):
    """"""اكتب دالة تقبل قائمة من السلاسل كمعلم، وتحذف السلاسل التي لها طول فريد منها، وتعيد القائمة الناتجة مع ترتيب مرتب، القائمة دائما قائمة من السلاسل وليس صف من الأرقام، ويمكن ان تحتوي على المكررات. يجب ان يكون ترتيب القائمة صاعدا حسب طول كل كلمة، ويجب ان ترجع القائمة مرتبة من خلال هذه القاعدة. اذا كان للكلمتين طول واحد، رتب القائمة حسب الأبجدية. يجب ان ترجع الدالة قائمة من السلاسل بترتيب مرتب. يمكنك ان تفترض ان كل الكلمات سيكون لها طول واحد. مثل: assert list_sort[""aa""""، ""a""""، ""aaa""]) => assert list_sort[""ab""""، ""aaaa""""، ""cd"" => [""ab"", ""cd""]""""""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

",,,
HumanEval/150,acm_Arab,python,"
def x_or_y(n, x, y):
    """"""برنامج بسيط الذي يجب ان يرجع قيمة x اذا n هو عدد أولي ويجب ان يرجع قيمة y غير ذلك. مثال: ل x_or_y(7, 34, 12) == 34 ل x_or_y(15, 8, 5) == 5 """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

",,,
HumanEval/151,acm_Arab,python,"
def double_the_difference(lst):
    '''وبالنظر الى قائمة من الارقام، ارجع مجموع مربعات الارقام في القائمة التي هي فريدة. تجاهل الارقام التي هي سلبية او ليست عدد صحيح. double_the_difference (([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 double_the_difference (([-1, -2, 0]) == 0 double_the_difference (([9, -2]) == 81 double_the_difference (([0]) == 0 اذا القائمة الفردية فارغة، ارجع 0 '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

",,,
HumanEval/152,acm_Arab,python,"
def compare(game,guess):
    """"""اظن اننا كلنا نتذكر هذا الشعور عندما تكون نتيجة حدث طال انتظاره معروفة اخيرا. المشاعر والافكار التي لديك في تلك اللحظة تستحق بالتأكيد ان تلاحظها وتقارنها. مهمتك هي تحديد اذا كان الشخص خمنت بشكل صحيح نتائج عدد من المباريات. تعطيك اثنين من المصفوفات من النتائج والخميسات من طول متساوي، حيث يظهر كل مؤشر تطابق. ارجع صف من نفس الطول يشير إلى مدى كل تخمين. اذا كان قد خمنت بشكل صحيح، القيمة هي 0، وإذا لم تكن، القيمة هي الفرق المطلق بين التخمين والنتيجة. مثال: ((([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare ((([0,5,0,4,0,1,0,4]) -> [4,0,1,0,6]""""""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/153,acm_Arab,python,"
def Strongest_Extension(class_name, extensions):
    """"""سَتُعطَى اسم فِئَة (سلسلة) وقائمة من التوسعات. التوسعات ستُستخدم لتحميل فئات إضافية للفئة. قوة التوسعة هي كما يلي: دعو CAP يكون عدد الحروف الكبيرة في اسم التوسعة، ودعو SM يكون عدد الحروف الصغيرة في اسم التوسعة، ويتم اعطاء القوة بواسطة كسر CAP - SM. يجب عليك ايجاد أقوى توسعة وترجع سلسلة في هذا التنسيق: ClassName.StrongestExtensionName. اذا كان هناك اثنين او اكثر من التوسعات بنفس القوة، يجب عليك اختيار الاكثر قوة في القائمة. مثلا، اذا اعطيت ""Slices"" كالفئة وقائمة من التوسعات: ['SEviRNGSliCes'، 'Cheese', 'StuFfed'] ثم يجب عليك ارجاع 'Slices.SEviRNGSliCes'، لأن التوسعة هي أقوى (مثال: 'AA_Beats'، 'AA_Class'='Strongest_Extension').""""""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
",,,
HumanEval/154,acm_Arab,python,"
def cycpattern_check(a , b):
    """"""اُعطيت كلمتين. عليك ان ترجع صحيح اذا الكلمة الثانية او اي من تدويراتها هي سلسلة فرعية في الكلمة الاولى cycpattern_check (((""abcd"",""abd"") => كذب cycpattern_check (((""hello"",""ell"") => كذب cycpattern_check (((""whassup"",""psus"") => كذب cycpattern_check (((""abab"",""baa"") => كذب cycpattern_check (((""efef"",""eeff"") => كذب cycpattern_check (((hims"",""simen"") => صحيح """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

",,,
HumanEval/155,acm_Arab,python,"
def even_odd_count(num):
    """"""معطوف على عدد صحيح. يرجع توبل بيكون فيه عدد من الارقام الزوجية والفردية على التوالي. مثال: حتى_عدد_الفردية(-12) ==> (1, 1) حتى_عدد_الفردية(123) ==> (1, 2) """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/156,acm_Arab,python,"
def int_to_mini_roman(number):
    """"""وبالنظر الى عدد صحيح ايجابي، احصل على ما يعادله من الارقام الرومانية كسلسلة، و ارجعها بحرف صغير. القيود: 1 <= num <= 1000 مثالات: >>> int_to_mini_roman(19) == 'xix' >>> int_to_mini_roman(152) == 'clii' >>> int_to_mini_roman(426) == 'cdxxvi' """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/157,acm_Arab,python,"
def right_angle_triangle(a, b, c):
    '''معطى طول الضلوع الثلاثة للمثلث. يرجع صحيح اذا الضلوع الثلاثة تشكل مثلث ذي زاوية مستقيمة، غلط خلاف ذلك. مثلث ذي زاوية مستقيمة هو مثلث فيه زاوية واحدة زاوية مستقيمة او 90 درجة. مثال: right_angle_triangle ((3, 4, 5) == True right_angle_triangle ((1, 2, 3) == False '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

",,,
HumanEval/158,acm_Arab,python,"
def find_max(words):
    """"""اكتب دالة تقبل قائمة من السلاسل. القائمة تحتوي على كلمات مختلفة. ارجع الكلمة مع الحد الأقصى لعدد الحروف الفريدة. اذا كان هناك عدد من السلاسل مع الحد الأقصى لعدد الحروف الفريدة، ارجع اول حرف حسب الترتيب المفرد.""""""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

",,,
HumanEval/159,acm_Arab,python,"
def eat(number, need, remaining):
    """"""انت ارنب جائع، و انت اكلت بالفعل عدد معين من الجزر، لكن الان انت بحاجة الى اكلة المزيد من الجزر لاستكمال وجبات اليوم. يجب عليك ان ترجع صف من [العدد الكلي للجزر المأكول بعد الوجبات، وعدد الجزر المتبقي بعد الوجبات ] اذا لم يكن هناك ما يكفي من الجزر المتبقي، فستأكل كل الجزر المتبقي، ولكنك ستبقى جائع. مثال: * اكل ((5, 6, 10) -> [11, 4] * اكل ((4, 8, 9) -> [12, 1] * اكل ((1, 10, 10) -> [11, 0] * اكل ((2, 11, 5) -> [7, 0] متغيرات: @number: عدد صحيح لعدد الجزر الذي اكلته. @need: عدد صحيح لعدد الجزر الذي تحتاج لتأكله. @remaining: عدد صحيح لعدد الجزر المتبقي في المخزون. Constrain: *= 0 <= 0 * 1000 <= 0 * 0 <= 1000 <= 0 = 1000""""""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

",,,
HumanEval/160,acm_Arab,python,"
def do_algebra(operator, operand):
    """"""وبالنظر الى اثنين من القوائم عامل، و operand. القائمة الاولى لها عمليات الجبر الاساسية، والقائمة الثانية هي قائمة من الأعداد الصحيحة. استخدم القائمتين المقدمتين لبناء التعبير الجبري و اعادة تقييم هذا التعبير. عمليات الجبر الاساسية: الجمع (+) الخصم (- ) الضرب (*) القسمة الارضية (//) التكبير (**) المثال: عامل['+'، '*'، '-'] المصفوف = [2, 3, 4, 5] النتيجة = 2 + 3 * 4 - 5 => النتيجة = 9 ملاحظة: طول قائمة المفعول يساوي طول قائمة العميل ناقص واحد. العميل هو قائمة من الأعداد الصحيحة غير السالبة. قائمة العميل لها على الأقل عامل واحد، وقائمة العميل لها على الأقل اثنين من العملاء.""""""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
HumanEval/161,acm_Arab,python,"
def solve(s):
    """"""اعطي لك سلسلة s. اذا s[i] هو حرف، اعكس حروفها من الاسفل الى الاعلى او العكس، و الا ابقيه كما هو. اذا لا تحتوي السلسلة على حروف، اعكس السلسلة. يجب ان تعيد الدالة السلسلة الناتجة. مثال حل ((""1234"") = ""4321"" حل (((""ab"") = ""AB"" حل (((""#a@C"") = ""#A@c"" """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
",,,
HumanEval/162,acm_Arab,python,"
def string_to_md5(text):
    """"""معطوفة سلسلة 'text', ارجع سلسلة مُساوية لـ md5. اذا 'text' كانت سلسلة فارغة، ارجع لا شيء. >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62' """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

",,,
HumanEval/163,acm_Arab,python,"
def generate_integers(a, b):
    """"""معطين اثنين من الأعداد الصحيحة الإيجابية a و b، ارجع الرقم الزوج بين a و b، بالترتيب الصاعد. مثلاً: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => [] """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

",,,
