task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //    //जाँचें कि संख्याओं की दी गई सूची में, क्या कोई दो संख्याएँ  से एक दूसरे के करीब हैं।    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)), (0.5f))
    // (false)
    // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))
    // (true)
    def hasCloseElements(numbers : List[Float], threshold : Float) : Boolean = {
","def hasCloseElements(numbers: List[Float], threshold: Float): Boolean = {
      val sortedNumbers = numbers.sorted
      for (i <- 1 until sortedNumbers.length) {
        if (abs(sortedNumbers(i) - sortedNumbers(i - 1)) < threshold) {
          return true
        }
      }
      false
    }
}","    }
    def main(args: Array[String]) = {
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));
    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));
    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));
    }

}
"
HumanEval_1,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इनपुट स्ट्रिंग में किसी भी रिक्त स्थान को अनदेखा करें.    //अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुले कंस ठीक से बंद होते हैं) और एक दूसरे के भीतर नहीं घोंसले होते हैं।    //उन समूहों को अलग-अलग स्ट्रिंग में अलग करें और उन लोगों की सूची वापस करें।    //इस फलन का इनपुट एक स्ट्रिंग है जिसमें नेस्टेड कोष्ठक के कई समूह होते हैं. आपका लक्ष्य है     // >>> separateParenGroups((""( ) (( )) (( )( ))""))
    // (List[String](""()"", ""(())"", ""(()())""))
    def separateParenGroups(paren_string : String) : List[String] = {
","def separateParenGroups(paren_string: String): List[String] = {
    val result = ListBuffer[String]()
    val sanitizedInput = paren_string.replaceAll(""\\s"", """")
    var balance = 0
    var currentGroup = new StringBuilder()

    for (char <- sanitizedInput) {
        currentGroup.append(char)
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1

        if (balance == 0 && currentGroup.nonEmpty) {
            result += currentGroup.toString()
            currentGroup = new StringBuilder()
        }
    }

    result.toList
}","    }
    def main(args: Array[String]) = {
    assert(separateParenGroups((""(()()) ((())) () ((())()())"")).equals((List[String](""(()())"", ""((()))"", ""()"", ""((())()())""))));
    assert(separateParenGroups((""() (()) ((())) (((())))"")).equals((List[String](""()"", ""(())"", ""((()))"", ""(((())))""))));
    assert(separateParenGroups((""(()(())((())))"")).equals((List[String](""(()(())((())))""))));
    assert(separateParenGroups((""( ) (( )) (( )( ))"")).equals((List[String](""()"", ""(())"", ""(()())""))));
    }

}
"
HumanEval_2,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //संख्या का दशमलव भाग लौटाएँ.    //(अवशेष भाग हमेशा 1 से छोटा होता है)    //और पूर्णांक भाग (दिली गई संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव     //एक सकारात्मक अस्थिर अंक संख्या को देखते हुए, इसे  में विघटित किया जा सकता है।    // >>> truncateNumber((3.5f))
    // (0.5f)
    def truncateNumber(number : Float) : Float = {
","val integerPart = number.floor
        val decimalPart = number - integerPart
        decimalPart.toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(truncateNumber((3.5f)) == (0.5f));
    assert(truncateNumber((1.25f)) == (0.25f));
    assert(truncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उस बिंदु पर फ़ंक्शन को सही लौटना चाहिए. अन्यथा यह गलत लौटना चाहिए.    //शून्य शेष राशि. आपका कार्य यह पता लगाने के लिए है कि किसी भी बिंदु पर खाते का शेष शून्य से नीचे गिर जाता है, और     //आपको एक बैंक खाते में जमा और निकासी की एक सूची दी जाती है जो  से शुरू होती है    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (false)
    // >>> belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong)))
    // (true)
    def belowZero(operations : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def belowZero(operations: List[Long]): Boolean = {
    var balance: Long = 0
    for (operation <- operations) {
      balance += operation
      if (balance < 0) {
        return true
      }
    }
    false
  }

  def main(args: Array[String]): Unit = {
    println(belowZero(List(1L, 2L, 3L)))         // false
    println(belowZero(List(1L, 2L, -4L, 5L)))    // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowZero((List[Long]())) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -3l.toLong, 1l.toLong, 2l.toLong, -3l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (false));
    assert(belowZero((List[Long](1l.toLong, -1l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -5l.toLong))) == (true));
    assert(belowZero((List[Long](1l.toLong, -2l.toLong, 2l.toLong, -2l.toLong, 5l.toLong, -5l.toLong, 4l.toLong, -4l.toLong))) == (true));
    }

}
"
HumanEval_4,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //MAD = औसत। x - x_mean।    //तत्व और एक केंद्रबिंदु (इस मामले में औसत):    //औसत निरपेक्ष विचलन प्रत्येक के बीच औसत निरपेक्ष अंतर है     //इस डेटासेट के औसत के आसपास।    //इनपुट संख्याओं की दी गई सूची के लिए, औसत निरपेक्ष विचलन की गणना करें।    // >>> meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat)))
    // (1.0f)
    def meanAbsoluteDeviation(numbers : List[Float]) : Float = {
","val mean = numbers.sum / numbers.size
    val deviations = numbers.map(num => math.abs(num - mean))
    val mad = deviations.sum / deviations.size
    mad
  }
}","    }
    def main(args: Array[String]) = {
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat))) == (0.5f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))) == (1.0f));
    assert(meanAbsoluteDeviation((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))) == (1.2f));
    }

}
"
HumanEval_5,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इनपुट सूची के प्रत्येक दो लगातार तत्वों के बीच एक संख्या 'डिलिमिटर' डालें ∀numbers'     // >>> intersperse((List[Long]()), (4l))
    // (List[Long]())
    // >>> intersperse((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (4l))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))
    def intersperse(numbers : List[Long], delimeter : Long) : List[Long] = {
","if (numbers.isEmpty) {
        List()
      } else {
        numbers.init.flatMap(n => List(n, delimeter)) :+ numbers.last
      }
    }
}","    }
    def main(args: Array[String]) = {
    assert(intersperse((List[Long]()), (7l)).equals((List[Long]())));
    assert(intersperse((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));
    assert(intersperse((List[Long](2l.toLong, 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    }

}
"
HumanEval_6,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए, (() (()) में अधिकतम दो स्तर के घोंसले होते हैं जबकि ((())) में तीन होते हैं।    //समूह के प्रत्येक के लिए, कोष्ठक के घोंसले के सबसे गहरे स्तर का उत्पादन करें।    //इस फलन का इनपुट एक स्ट्रिंग है जो स्थानों द्वारा अलग किए गए घोंसले वाले कोष्ठक के लिए कई समूहों का प्रतिनिधित्व करता है।    // >>> parseNestedParens((""(()()) ((())) () ((())()())""))
    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))
    def parseNestedParens(paren_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseNestedParens(paren_string: String): List[Long] = {
    paren_string.split("" "").toList.map { group =>
      var maxDepth = 0
      var currentDepth = 0
      group.foreach {
        case '(' => 
          currentDepth += 1
          maxDepth = max(maxDepth, currentDepth)
        case ')' => 
          currentDepth -= 1
      }
      maxDepth.toLong
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    val result = parseNestedParens(""(()()) ((())) () ((())()())"")
    println(s""Result: ${result.mkString("", "")}"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseNestedParens((""(()()) ((())) () ((())()())"")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(parseNestedParens((""() (()) ((())) (((())))"")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(parseNestedParens((""(()(())((())))"")).equals((List[Long](4l.toLong))));
    }

}
"
HumanEval_7,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इनपुट स्ट्रिंग्स की सूची को केवल उन लोगों के लिए फ़िल्टर करें जिनमें दी गई सबस्ट्रिंग है    // >>> filterBySubstring((List[String]()), (""a""))
    // (List[String]())
    // >>> filterBySubstring((List[String](""abc"", ""bacd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""bacd"", ""array""))
    def filterBySubstring(strings : List[String], substring : String) : List[String] = {
","strings.filter(_.contains(substring))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterBySubstring((List[String]()), (""john"")).equals((List[String]())));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""xxx"", ""asd"", ""aaaxxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xx"")).equals((List[String](""xxx"", ""aaaxxy"", ""xxxAAA"", ""xxx""))));
    assert(filterBySubstring((List[String](""grunt"", ""trumpet"", ""prune"", ""gruesome"")), (""run"")).equals((List[String](""grunt"", ""prune""))));
    }

}
"
HumanEval_8,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //खाली योग 0 और खाली उत्पाद 1 के बराबर होना चाहिए।    //पूर्णांक की दी गई सूची के लिए, एक सूची में सभी पूर्णांक के योग और उत्पाद से युक्त एक टपल लौटाएं।    // >>> sumProduct((List[Long]()))
    // ((0l, 1l))
    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // ((10l, 24l))
    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long] = {
","def sumProduct(numbers: List[Long]): (Long, Long) = {
        val sum = numbers.sum
        val product = numbers.foldLeft(1L)(_ * _)
        (sum, product)
    }

    def main(args: Array[String]): Unit = {
        // Test examples
        println(sumProduct(List[Long]())) // (0L, 1L)
        println(sumProduct(List[Long](1L, 2L, 3L, 4L))) // (10L, 24L)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumProduct((List[Long]())).equals(((0l, 1l))));
    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l, 1l))));
    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l, 0l))));
    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l, 105l))));
    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));
    }

}
"
HumanEval_9,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //क्रम में।    //पूर्णांक की दी गई सूची से, दिए गए क्षण तक पाए गए रोलिंग अधिकतम तत्व की सूची उत्पन्न करें।    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))
    def rollingMax(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def rollingMax(numbers: List[Long]): List[Long] = {
        var maxSoFar = Long.MinValue
        numbers.map { num =>
            maxSoFar = max(maxSoFar, num)
            maxSoFar
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(rollingMax((List[Long]())).equals((List[Long]())));
    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));
    }

}
"
HumanEval_10,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //- स्ट्रिंग के अंत में एक स्ट्रिंग उपसर्ग का रिवर्स जोड़ें जो पालिंड्रोमिक प्रत्यय से पहले आता है।    //- दी गई स्ट्रिंग का सबसे लंबा पोस्टफिक्स ढूंढें जो एक पैलिंड्रोम है।    //एल्गोरिथ्म विचार सरल हैः     //सबसे छोटा पैलिंड्रोम खोजें जो आपूर्ति की गई स्ट्रिंग से शुरू होता है।    // >>> makePalindrome((""""))
    // ("""")
    // >>> makePalindrome((""cat""))
    // (""catac"")
    // >>> makePalindrome((""cata""))
    // (""catac"")
    def makePalindrome(string : String) : String = {
","def makePalindrome(string: String): String = {
    // Helper function to check if a string is a palindrome
    def isPalindrome(s: String): Boolean = s == s.reverse

    // Find the longest palindromic suffix
    var endIndex = string.length
    while (endIndex > 0 && !isPalindrome(string.substring(endIndex - 1))) {
      endIndex -= 1
    }

    // Extract the non-palindromic prefix
    val prefix = string.substring(0, endIndex - 1)

    // Append the reverse of the prefix to form the shortest palindrome
    string + prefix.reverse
  }
}","    }
    def main(args: Array[String]) = {
    assert(makePalindrome(("""")).equals(("""")));
    assert(makePalindrome((""x"")).equals((""x"")));
    assert(makePalindrome((""xyz"")).equals((""xyzyx"")));
    assert(makePalindrome((""xyx"")).equals((""xyx"")));
    assert(makePalindrome((""jerry"")).equals((""jerryrrej"")));
    }

}
"
HumanEval_11,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इन इनपुट पर बाइनरी XOR करें और परिणाम को स्ट्रिंग के रूप में भी लौटाएं.    //इनपुट दो स्ट्रिंग्स a और b हैं जिनमें केवल 1s और 0s हैं.    // >>> stringXor((""010""), (""110""))
    // (""100"")
    def stringXor(a : String, b : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringXor(a: String, b: String): String = {
    (a zip b).map { case (charA, charB) => 
      if (charA == charB) '0' else '1'
    }.mkString
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringXor((""111000""), (""101010"")).equals((""010010"")));
    assert(stringXor((""1""), (""1"")).equals((""0"")));
    assert(stringXor((""0101""), (""0000"")).equals((""0101"")));
    }

}
"
HumanEval_12,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //समान लंबाई की स्ट्रिंग्स. इनपुट सूची खाली होने पर कोई नहीं लौटाएं.    //स्ट्रिंग्स की सूची में से सबसे लम्बी स्ट्रिंग लौटाएँ. यदि कई स्ट्रिंग्स हैं तो सबसे पहले एक को लौटाएँ.    // >>> longest((List[String]()))
    // None
    // >>> longest((List[String](""a"", ""b"", ""c"")))
    // Some(""a"")
    // >>> longest((List[String](""a"", ""bb"", ""ccc"")))
    // Some(""ccc"")
    def longest(strings : List[String]) : Option[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Out of list of strings, return the longest one. Return the first one in case of multiple
    // strings of the same length. Return None in case the input list is empty.
    def longest(strings: List[String]): Option[String] = {
        if (strings.isEmpty) None
        else Some(strings.maxBy(_.length))
    }
}","    }
    def main(args: Array[String]) = {
    assert(longest((List[String]())).equals(None));
    assert(longest((List[String](""x"", ""y"", ""z""))).equals(Some(""x"")));
    assert(longest((List[String](""x"", ""yyy"", ""zzzz"", ""www"", ""kkkk"", ""abc""))).equals(Some(""zzzz"")));
    }

}
"
HumanEval_13,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //दो पूर्णांक a और b का सबसे बड़ा सामान्य भाजक लौटाएँ     // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return a greatest common divisor of two integers a and b
    // >>> greatestCommonDivisor((3l), (5l))
    // (1l)
    // >>> greatestCommonDivisor((25l), (15l))
    // (5l)
    def greatestCommonDivisor(a: Long, b: Long): Long = {
        if (b == 0) a else greatestCommonDivisor(b, a % b)
    }
}","    }
    def main(args: Array[String]) = {
    assert(greatestCommonDivisor((3l), (7l)) == (1l));
    assert(greatestCommonDivisor((10l), (15l)) == (5l));
    assert(greatestCommonDivisor((49l), (14l)) == (7l));
    assert(greatestCommonDivisor((144l), (60l)) == (12l));
    }

}
"
HumanEval_14,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इनपुट स्ट्रिंग के सबसे छोटे से सबसे लंबे तक सभी उपसर्गों की सूची लौटाता है    // >>> allPrefixes((""abc""))
    // (List[String](""a"", ""ab"", ""abc""))
    def allPrefixes(string : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return list of all prefixes from shortest to longest of the input string
  // >>> allPrefixes((""abc""))
  // (List[String](""a"", ""ab"", ""abc""))
  def allPrefixes(string: String): List[String] = {
    (1 to string.length).map(i => string.substring(0, i)).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(allPrefixes(("""")).equals((List[String]())));
    assert(allPrefixes((""asdfgh"")).equals((List[String](""a"", ""as"", ""asd"", ""asdf"", ""asdfg"", ""asdfgh""))));
    assert(allPrefixes((""WWW"")).equals((List[String](""W"", ""WW"", ""WWW""))));
    }

}
"
HumanEval_15,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //0 से लेकर n तक समावेशी स्थान-सीमित संख्याओं वाली स्ट्रिंग लौटाता है.     // >>> stringSequence((0l))
    // (""0"")
    // >>> stringSequence((5l))
    // (""0 1 2 3 4 5"")
    def stringSequence(n : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def stringSequence(n: Long): String = {
    (0L to n).mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(stringSequence((0l)).equals((""0"")));
    assert(stringSequence((3l)).equals((""0 1 2 3"")));
    assert(stringSequence((10l)).equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //एक स्ट्रिंग दी गई, पता लगाएं कि कितने अलग-अलग वर्ण (कोई भी केस) इसमें शामिल हैं।    // >>> countDistinctCharacters((""xyzXYZ""))
    // (3l)
    // >>> countDistinctCharacters((""Jerry""))
    // (4l)
    def countDistinctCharacters(string : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a string, find out how many distinct characters (regardless of case) does it consist of
  // >>> countDistinctCharacters((""xyzXYZ""))
  // (3l)
  // >>> countDistinctCharacters((""Jerry""))
  // (4l)
  def countDistinctCharacters(string: String): Long = {
    string.toLowerCase.toSet.size.toLong
  }
}","    }
    def main(args: Array[String]) = {
    assert(countDistinctCharacters(("""")) == (0l));
    assert(countDistinctCharacters((""abcde"")) == (5l));
    assert(countDistinctCharacters((""abcdecadeCADE"")) == (5l));
    assert(countDistinctCharacters((""aaaaAAAAaaaa"")) == (1l));
    assert(countDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5l));
    }

}
"
HumanEval_17,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //' 'हाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहाहा    //'ओ-डाय' - आधा नोट, दो धड़कनों तक चलता है।    //'ओ' - पूरा नोट, चार धड़कनों तक रहता है।    //यहाँ एक किंवदंती हैः     //अंतिम नहीं।    //आपका कार्य इस स्ट्रिंग को पार्स करना है और पूर्णांक की सूची वापस करना है जो प्रत्येक में कितने बीट्स करता है।    //इस फंक्शन का इनपुट एक विशेष ASCII प्रारूप में संगीत नोटों का प्रतिनिधित्व करने वाली स्ट्रिंग है।    // >>> parseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))
    def parseMusic(music_string : String) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def parseMusic(music_string: String): List[Long] = {
    val noteMap = Map(""o"" -> 4L, ""o|"" -> 2L, "".|"" -> 1L)
    val notes = music_string.split("" "")
    notes.toList.map(note => noteMap(note))
  }
}","    }
    def main(args: Array[String]) = {
    assert(parseMusic(("""")).equals((List[Long]())));
    assert(parseMusic((""o o o o"")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic(("".| .| .| .|"")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));
    assert(parseMusic((""o| o| .| .| o o o o"")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));
    assert(parseMusic((""o| .| o| .| o o| o o|"")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));
    }

}
"
HumanEval_18,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //मूल स्ट्रिंग में दिए गए सबस्ट्रिंग को कितनी बार पाया जा सकता है, यह ज्ञात करें। ओवरलैपिंग मामलों की गणना करें।    // >>> howManyTimes((""""), (""a""))
    // (0l)
    // >>> howManyTimes((""aaa""), (""a""))
    // (3l)
    // >>> howManyTimes((""aaaa""), (""aa""))
    // (3l)
    def howManyTimes(string : String, substring : String) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def howManyTimes(string: String, substring: String): Long = {
        if (substring.isEmpty || string.isEmpty) return 0L
        var count: Long = 0L
        for (i <- 0 to (string.length - substring.length)) {
            if (string.substring(i, i + substring.length) == substring) {
                count += 1
            }
        }
        count
    }

    // Test cases
    def main(args: Array[String]): Unit = {
        println(howManyTimes("""", ""a""))    // Output: 0
        println(howManyTimes(""aaa"", ""a"")) // Output: 3
        println(howManyTimes(""aaaa"", ""aa"")) // Output: 3
    }
}","    }
    def main(args: Array[String]) = {
    assert(howManyTimes((""""), (""x"")) == (0l));
    assert(howManyTimes((""xyxyxyx""), (""x"")) == (4l));
    assert(howManyTimes((""cacacacac""), (""cac"")) == (4l));
    assert(howManyTimes((""john doe""), (""john"")) == (1l));
    }

}
"
HumanEval_19,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //संख्याओं के साथ स्ट्रिंग को सबसे छोटे से सबसे बड़े क्रम में लौटाता है    //वैध विकल्प हैं 'शून्य', 'एक', 'दो', 'तीन', 'चार', 'पांच', 'छह', 'सात', 'आठ' और 'नौ'।    //इनपुट 'शून्य' से 'नौ' तक संख्याओं की एक स्थान-सीमित स्ट्रिंग है।    // >>> sortNumbers((""three one five""))
    // (""one three five"")
    def sortNumbers(numbers : String) : String = {
","def sortNumbers(numbers: String): String = {
    val numberWords = Map(
      ""zero"" -> 0,
      ""one"" -> 1,
      ""two"" -> 2,
      ""three"" -> 3,
      ""four"" -> 4,
      ""five"" -> 5,
      ""six"" -> 6,
      ""seven"" -> 7,
      ""eight"" -> 8,
      ""nine"" -> 9
    )
    
    numbers.split("" "")
      .sortBy(word => numberWords(word))
      .mkString("" "")
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortNumbers(("""")).equals(("""")));
    assert(sortNumbers((""three"")).equals((""three"")));
    assert(sortNumbers((""three five nine"")).equals((""three five nine"")));
    assert(sortNumbers((""five zero four seven nine eight"")).equals((""zero four five seven eight nine"")));
    assert(sortNumbers((""six five four three two one zero"")).equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //अन्य और उन्हें क्रम में लौटाएं (कम संख्या, अधिक संख्या) ।    //संख्याओं की एक सूची से (कम से कम दो लंबाई की) चयन करें और दो को वापस करें जो प्रत्येक के सबसे करीब हैं।    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))
    // ((2.0f, 2.2f))
    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))
    // ((2.0f, 2.0f))
    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findClosestElements(numbers: List[Float]): (Float, Float) = {
    require(numbers.length >= 2, ""List must contain at least two elements"")
    val sortedNumbers = numbers.sorted

    var minDiff = Float.MaxValue
    var closestPair = (0.0f, 0.0f)

    for(i <- 0 until sortedNumbers.length - 1) {
      val currentDiff = abs(sortedNumbers(i) - sortedNumbers(i + 1))
      if(currentDiff < minDiff) {
        minDiff = currentDiff
        closestPair = (sortedNumbers(i), sortedNumbers(i + 1))
      }
    }
    
    closestPair
  }
}","    }
    def main(args: Array[String]) = {
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f, 4.0f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f, 2.2f))));
    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));
    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));
    }

}
"
HumanEval_21,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इस तरह कि सबसे छोटी संख्या 0 बन जाएगी और सबसे बड़ी संख्या 1 बन जाएगी।    //संख्याओं की सूची दी गई (कम से कम दो तत्वों की), उस सूची में एक रैखिक परिवर्तन लागू करें,    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))
    // (List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))
    def rescaleToUnit(numbers : List[Float]) : List[Float] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given list of numbers (of at least two elements), apply a linear transform to that list,
  // such that the smallest number will become 0 and the largest will become 1
  def rescaleToUnit(numbers: List[Float]): List[Float] = {
    val minVal = numbers.min
    val maxVal = numbers.max
    numbers.map(num => (num - minVal) / (maxVal - minVal))
  }
}

// Usage example
object Main extends App {
  val numbers = List[Float](1.0f, 2.0f, 3.0f, 4.0f, 5.0f)
  val rescaledNumbers = Problem.rescaleToUnit(numbers)
  println(rescaledNumbers) // Output: List(0.0, 0.25, 0.5, 0.75, 1.0)
}","    }
    def main(args: Array[String]) = {
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](100.0f.toFloat, 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));
    assert(rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));
    assert(rescaleToUnit((List[Float](2.0f.toFloat, 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    assert(rescaleToUnit((List[Float](12.0f.toFloat, 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat, 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));
    }

}
"
HumanEval_22,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //किसी भी स्केलेथॉन मानों की दी गई सूची को केवल पूर्णांक के लिए फ़िल्टर करें    // >>> filterIntegers((List[Any](""a"", 3.14f, 5l)))
    // (List[Long](5l.toLong))
    // >>> filterIntegers((List[Any](1l, 2l, 3l, ""abc"", Map[Long,Long](), List[Long]())))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    def filterIntegers(values : List[Any]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def filterIntegers(values: List[Any]): List[Long] = {
    values.collect {
      case l: Long => l
    }
  }

  def main(args: Array[String]): Unit = {
    println(filterIntegers(List[Any](""a"", 3.14f, 5l))) // List(5)
    println(filterIntegers(List[Any](1l, 2l, 3l, ""abc"", Map[Long, Long](), List[Long]()))) // List(1, 2, 3)
  }
}","    }
    def main(args: Array[String]) = {
    assert(filterIntegers((List[Any]())).equals((List[Long]())));
    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f, 9l, ""adasd""))).equals((List[Long](4l.toLong, 9l.toLong))));
    assert(filterIntegers((List[Any](3l, ""c"", 3l, 3l, ""a"", ""b""))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_23,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //दिए गए स्ट्रिंग की लौटाई लंबाई     // >>> stringLength((""""))
    // (0l)
    // >>> stringLength((""abc""))
    // (3l)
    def strlen(string : String) : Long = {
","def strlen(string: String): Long = {
        string.length.toLong
    }
}","    }
    def main(args: Array[String]) = {
    assert(strlen(("""")) == (0l));
    assert(strlen((""x"")) == (1l));
    assert(strlen((""asdasnakj"")) == (9l));
    }

}
"
HumanEval_24,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //किसी दी गई संख्या n के लिए, सबसे बड़ी संख्या ज्ञात कीजिए जो n से छोटी है और n को समान रूप से विभाजित करती है     // >>> largestDivisor((15l))
    // (5l)
    def largestDivisor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // For a given number n, find the largest number that divides n evenly, smaller than n
    // >>> largestDivisor(15l)
    // (5l)
    def largestDivisor(n: Long): Long = {
        for (i <- (n / 2) to 1 by -1) {
            if (n % i == 0) return i
        }
        1L  // if no divisor found, return 1 (since 1 divides any number)
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestDivisor((3l)) == (1l));
    assert(largestDivisor((7l)) == (1l));
    assert(largestDivisor((10l)) == (5l));
    assert(largestDivisor((100l)) == (50l));
    assert(largestDivisor((49l)) == (7l));
    }

}
"
HumanEval_25,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इनपुट संख्या सभी कारकों के उत्पाद के बराबर होना चाहिए     //प्रत्येक कारक को उस संख्या के अनुसार सूचीबद्ध किया जाना चाहिए जो कारककरण में प्रकट होती है।    //दिए गए पूर्णांक के अभाज्य गुणकों की सूची सबसे छोटे से सबसे बड़े क्रम में लौटाता है।    // >>> factorize((8l))
    // (List[Long](2l.toLong, 2l.toLong, 2l.toLong))
    // >>> factorize((25l))
    // (List[Long](5l.toLong, 5l.toLong))
    // >>> factorize((70l))
    // (List[Long](2l.toLong, 5l.toLong, 7l.toLong))
    def factorize(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def factorize(n: Long): List[Long] = {
    var num = n
    val factors = ListBuffer[Long]()
    
    var i = 2L
    while (i <= sqrt(num).toLong) {
      while (num % i == 0) {
        factors += i
        num /= i
      }
      i += 1
    }
    
    if (num > 1) {
      factors += num
    }
    
    factors.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(factorize((2l)).equals((List[Long](2l.toLong))));
    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(factorize((8l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong))));
    assert(factorize((57l)).equals((List[Long](3l.toLong, 19l.toLong))));
    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((185193l)).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((20577l)).equals((List[Long](3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));
    assert(factorize((18l)).equals((List[Long](2l.toLong, 3l.toLong, 3l.toLong))));
    }

}
"
HumanEval_26,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //तत्वों का क्रम इनपुट में जैसा ही छोड़ दिया है।    //पूर्णांक की सूची से, उन सभी तत्वों को हटाएं जो एक से अधिक बार होते हैं।    // >>> removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 3l.toLong, 4l.toLong))
    def removeDuplicates(numbers : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def removeDuplicates(numbers: List[Long]): List[Long] = {
    val elementCount = numbers.groupBy(identity).mapValues(_.size)
    numbers.filter(num => elementCount(num) == 1)
  }

  def main(args: Array[String]): Unit = {
    val numbers = List[Long](1L, 2L, 3L, 2L, 4L)
    println(removeDuplicates(numbers)) // Output: List(1, 3, 4)
  }
}","    }
    def main(args: Array[String]) = {
    assert(removeDuplicates((List[Long]())).equals((List[Long]())));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));
    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 5l.toLong))));
    }

}
"
HumanEval_27,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //किसी दिए गए स्ट्रिंग के लिए, लघु अक्षरों को अपरकेस और अपरकेस को लघु अक्षरों में घुमाएं।    // >>> flipCase((""Hello""))
    // (""hELLO"")
    def flipCase(string : String) : String = {
","def flipCase(string: String): String = {
    string.map {
      case c if c.isLower => c.toUpper
      case c if c.isUpper => c.toLower
      case c => c
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(flipCase(("""")).equals(("""")));
    assert(flipCase((""Hello!"")).equals((""hELLO!"")));
    assert(flipCase((""These violent delights have violent ends"")).equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //स्ट्रिंग्स की सूची को एक स्ट्रिंग में जोड़ें    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Concatenate list of strings into a single string
    // >>> concatenate((List[String]()))
    // ("""")
    // >>> concatenate((List[String](""a"", ""b"", ""c"")))
    // (""abc"")
    def concatenate(strings: List[String]): String = {
        strings.mkString("""")
    }
}","    }
    def main(args: Array[String]) = {
    assert(concatenate((List[String]())).equals(("""")));
    assert(concatenate((List[String](""x"", ""y"", ""z""))).equals((""xyz"")));
    assert(concatenate((List[String](""x"", ""y"", ""z"", ""w"", ""k""))).equals((""xyzwk"")));
    }

}
"
HumanEval_29,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इनपुट स्ट्रिंग्स की सूची को केवल उन लोगों के लिए फ़िल्टर करें जो दिए गए उपसर्ग से शुरू होते हैं.    // >>> filterByPrefix((List[String]()), (""a""))
    // (List[String]())
    // >>> filterByPrefix((List[String](""abc"", ""bcd"", ""cde"", ""array"")), (""a""))
    // (List[String](""abc"", ""array""))
    def filterByPrefix(strings : List[String], prefix : String) : List[String] = {
","strings.filter(_.startsWith(prefix))
    }
}","    }
    def main(args: Array[String]) = {
    assert(filterByPrefix((List[String]()), (""john"")).equals((List[String]())));
    assert(filterByPrefix((List[String](""xxx"", ""asd"", ""xxy"", ""john doe"", ""xxxAAA"", ""xxx"")), (""xxx"")).equals((List[String](""xxx"", ""xxxAAA"", ""xxx""))));
    }

}
"
HumanEval_30,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //सूची में केवल सकारात्मक संख्याएँ लौटाएँ।    // >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](2l.toLong, 5l.toLong, 6l.toLong))
    // >>> getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))
    def getPositive(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def getPositive(l: List[Long]): List[Long] = {
        l.filter(_ > 0)
    }
}","    }
    def main(args: Array[String]) = {
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong, 6l.toLong))));
    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));
    assert(getPositive((List[Long](-1l.toLong, -2l.toLong))).equals((List[Long]())));
    assert(getPositive((List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_31,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यदि कोई दी गई संख्या अभाज्य है तो सही लौटाएं, और अन्यथा गलत।    // >>> isPrime((6l))
    // (false)
    // >>> isPrime((101l))
    // (true)
    // >>> isPrime((11l))
    // (true)
    // >>> isPrime((13441l))
    // (true)
    // >>> isPrime((61l))
    // (true)
    // >>> isPrime((4l))
    // (false)
    // >>> isPrime((1l))
    // (false)
    def isPrime(n : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if a given number is prime, and false otherwise.
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPrime((6l)) == (false));
    assert(isPrime((101l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((13441l)) == (true));
    assert(isPrime((61l)) == (true));
    assert(isPrime((4l)) == (false));
    assert(isPrime((1l)) == (false));
    assert(isPrime((5l)) == (true));
    assert(isPrime((11l)) == (true));
    assert(isPrime((17l)) == (true));
    assert(isPrime((85l)) == (false));
    assert(isPrime((77l)) == (false));
    assert(isPrime((255379l)) == (false));
    }

}
"
HumanEval_33,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //के मानों के लिए, लेकिन क्रमबद्ध।    //l' उन सूचकांकों में l के समान है जो तीन से विभाज्य नहीं हैं, जबकि तीन से विभाज्य सूचकांकों में इसके मान समान हैं।    //यह फंक्शन एक सूची l लेता है और एक सूची l' देता है जो कि     // >>> sortThird((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))
    def sortThird(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def sortThird(l: List[Long]): List[Long] = {
    // Get the elements at indices divisible by 3
    val elementsAtThirdIndices = l.zipWithIndex.collect {
      case (value, index) if index % 3 == 0 => value
    }
    
    // Sort the collected elements
    val sortedElements = elementsAtThirdIndices.sorted
    
    // Replace elements at indices divisible by 3 with the sorted ones
    l.zipWithIndex.map {
      case (_, index) if index % 3 == 0 => sortedElements(index / 3)
      case (value, _) => value
    }
  }

  // Example usage:
  def main(args: Array[String]): Unit = {
    println(sortThird(List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    println(sortThird(List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortThird((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));
    }

}
"
HumanEval_34,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //सूची में क्रमबद्ध अद्वितीय तत्व लौटाता है    // >>> unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))
    def unique(l : List[Long]) : List[Long] = {
","def unique(l: List[Long]): List[Long] = {
    l.toSet.toList.sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(unique((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));
    }

}
"
HumanEval_35,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //सूची में अधिकतम तत्व लौटाता है.    // >>> maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (3l)
    // >>> maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong)))
    // (123l)
    def maxElement(l : List[Long]) : Long = {
","def maxElement(l: List[Long]): Long = {
    l.max
  }
}","    }
    def main(args: Array[String]) = {
    assert(maxElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (3l));
    assert(maxElement((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));
    }

}
"
HumanEval_36,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //पूर्णांक 7 की संख्या को n से कम पूर्णांक में प्रकट होने की संख्या को लौटाएं जो 11 या 13 से विभाज्य है।    // >>> fizzBuzz((50l))
    // (0l)
    // >>> fizzBuzz((78l))
    // (2l)
    // >>> fizzBuzz((79l))
    // (3l)
    def fizzBuzz(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fizzBuzz(n: Long): Long = {
    var count = 0L
    for (i <- 1L until n) {
      if (i % 11 == 0 || i % 13 == 0) {
        count += i.toString.count(_ == '7')
      }
    }
    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(fizzBuzz((50l)) == (0l));
    assert(fizzBuzz((78l)) == (2l));
    assert(fizzBuzz((79l)) == (3l));
    assert(fizzBuzz((100l)) == (3l));
    assert(fizzBuzz((200l)) == (6l));
    assert(fizzBuzz((4000l)) == (192l));
    assert(fizzBuzz((10000l)) == (639l));
    assert(fizzBuzz((100000l)) == (8026l));
    }

}
"
HumanEval_37,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //l के सम सूचकांक के मूल्यों के लिए, लेकिन क्रमबद्ध।    //l' विषम सूचकांकों में l के समान है, जबकि सम सूचकांकों में इसके मान समान हैं।    //यह फंक्शन एक सूची l लेता है और एक सूची l' देता है जो कि     // >>> sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))
    // >>> sortEven((List[Long](5l.toLong, 6l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](3l.toLong, 6l.toLong, 5l.toLong, 4l.toLong))
    def sortEven(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // This function takes a list l and returns a list l' such that
  // l' is identical to l in the odd indicies, while its values at the even indicies are equal
  // to the values of the even indicies of l, but sorted.
  def sortEven(l: List[Long]): List[Long] = {
    val evenIndices = l.indices.filter(_ % 2 == 0)
    val sortedEvens = evenIndices.map(l(_)).sorted

    l.indices.map { index =>
      if (index % 2 == 0) sortedEvens(evenIndices.indexOf(index))
      else l(index)
    }.toList
  }

  // Examples
  def main(args: Array[String]): Unit = {
    println(sortEven(List[Long](1L, 2L, 3L)))
    println(sortEven(List[Long](5L, 6L, 3L, 4L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortEven((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong, -10l.toLong))).equals((List[Long](-10l.toLong, 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 5l.toLong, 0l.toLong, 9l.toLong, 1l.toLong, 123l.toLong))));
    assert(sortEven((List[Long](5l.toLong, 8l.toLong, -12l.toLong, 4l.toLong, 23l.toLong, 2l.toLong, 3l.toLong, 11l.toLong, 12l.toLong, -10l.toLong))).equals((List[Long](-12l.toLong, 8l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 2l.toLong, 12l.toLong, 11l.toLong, 23l.toLong, -10l.toLong))));
    }

}
"
HumanEval_39,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //prime_fib n-वें नंबर को लौटाता है जो एक फाइबोनैचि संख्या है और यह भी प्राइम है।     // >>> primeFib((1l))
    // (2l)
    // >>> primeFib((2l))
    // (3l)
    // >>> primeFib((3l))
    // (5l)
    // >>> primeFib((4l))
    // (13l)
    // >>> primeFib((5l))
    // (89l)
    def primeFib(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeFib(n: Long): Long = {
    // Function to check if a number is prime
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num == 2) return true
      if (num % 2 == 0) return false
      for (i <- Range(3, math.sqrt(num).toInt + 1, 2)) {
        if (num % i == 0) return false
      }
      true
    }

    // Function to generate Fibonacci numbers
    def fibonacciStream(): Stream[Long] = {
      def fibs(a: Long, b: Long): Stream[Long] = a #:: fibs(b, a + b)
      fibs(0, 1)
    }

    // Find the n-th Fibonacci number that is also prime
    val primeFibs = fibonacciStream().filter(isPrime)
    primeFibs.take(n.toInt).last
  }

  // Test the function
  def main(args: Array[String]): Unit = {
    println(primeFib(1L)) // 2
    println(primeFib(2L)) // 3
    println(primeFib(3L)) // 5
    println(primeFib(4L)) // 13
    println(primeFib(5L)) // 89
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeFib((1l)) == (2l));
    assert(primeFib((2l)) == (3l));
    assert(primeFib((3l)) == (5l));
    assert(primeFib((4l)) == (13l));
    assert(primeFib((5l)) == (89l));
    assert(primeFib((6l)) == (233l));
    assert(primeFib((7l)) == (1597l));
    assert(primeFib((8l)) == (28657l));
    assert(primeFib((9l)) == (514229l));
    assert(primeFib((10l)) == (433494437l));
    }

}
"
HumanEval_40,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //शून्य तक योग, और अन्यथा गलत।    //यह सही लौटाता है यदि सूची में तीन अलग-अलग तत्व हैं जो     //triples_sum_to_zero पूर्णांक की सूची को इनपुट के रूप में लेता है।    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))
    // (true)
    // >>> triplesSumToZero((List[Long](1l.toLong)))
    // (false)
    def triplesSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // triples_sum_to_zero takes a list of integers as an input.
    // it returns true if there are three distinct elements in the list that
    // sum to zero, and false otherwise.
    def triplesSumToZero(l: List[Long]): Boolean = {
        val n = l.length
        if (n < 3) return false

        // Sort the list to use the two-pointer technique
        val sortedList = l.sorted

        // Iterate over the list
        for (i <- 0 until n - 2) {
            var left = i + 1
            var right = n - 1

            // Use two pointers to find the remaining two numbers
            while (left < right) {
                val currentSum = sortedList(i) + sortedList(left) + sortedList(right)
                if (currentSum == 0) {
                    return true
                } else if (currentSum < 0) {
                    left += 1
                } else {
                    right -= 1
                }
            }
        }

        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 2l.toLong, 5l.toLong, 7l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));
    assert(triplesSumToZero((List[Long](1l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    assert(triplesSumToZero((List[Long](100l.toLong, 3l.toLong, 5l.toLong, -100l.toLong))) == (false));
    }

}
"
HumanEval_41,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यह फलन ऐसे टकरावों की संख्या को आउटपुट करता है।    //जैसे कि वे टकराए ही नहीं।    //हालांकि, कारें असीम रूप से मजबूत और मजबूत हैं; नतीजतन, वे आगे बढ़ते रहते हैं।    //जब एक कार जो बाएं से दाएं जा रही है एक कार को हिट करती है जो दाएं से बाएं जा रही है।    //सभी कारें एक ही गति से चलती हैं. दो कारों को टकराव कहा जाता है.    //कारों के दो सेट शुरू बहुत दूर से किया जा रहा है    //n कारें बायीं से दाईं ओर जा रही हैं; साथ ही, n कारों का एक अलग सेट     //एक सड़क की कल्पना करो जो एक पूरी तरह से सीधी अनंत लंबी रेखा है।    def carRaceCollision(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Imagine a road that's a perfectly straight infinitely long line.
  // n cars are driving left to right; simultaneously, a different set of n cars
  // are driving right to left. The two sets of cars start out being very far from
  // each other. All cars move at the same speed. Two cars are said to collide
  // when a car that's moving left to right hits a car that's moving right to left.
  // However, the cars are infinitely sturdy and strong; as a result, they continue moving
  // in their trajectory as if they did not collide.
  // This function outputs the number of such collisions.
  def carRaceCollision(n: Long): Long = {
    n
  }
}","    }
    def main(args: Array[String]) = {
    assert(carRaceCollision((2l)) == (4l));
    assert(carRaceCollision((3l)) == (9l));
    assert(carRaceCollision((4l)) == (16l));
    assert(carRaceCollision((8l)) == (64l));
    assert(carRaceCollision((10l)) == (100l));
    }

}
"
HumanEval_42,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //1 से वृद्धि के साथ तत्वों के साथ वापसी सूची।    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))
    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))
    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))
    def incrList(l : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Return list with elements incremented by 1.
    def incrList(l: List[Long]): List[Long] = {
        l.map(_ + 1)
    }
}","    }
    def main(args: Array[String]) = {
    assert(incrList((List[Long]())).equals((List[Long]())));
    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));
    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));
    }

}
"
HumanEval_43,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //शून्य तक योग, और अन्यथा गलत।    //यह सही लौटाता है यदि सूची में दो अलग-अलग तत्व हैं जो     //pairs_sum_to_zero इनपुट के रूप में पूर्णांक की सूची लेता है।    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong)))
    // (false)
    // >>> pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (true)
    // >>> pairsSumToZero((List[Long](1l.toLong)))
    // (false)
    def pairsSumToZero(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def pairsSumToZero(l: List[Long]): Boolean = {
        val seen = HashSet[Long]()
        for (num <- l) {
            if (seen.contains(-num)) {
                return true
            }
            seen.add(num)
        }
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 3l.toLong, -2l.toLong, 1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 7l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](2l.toLong, 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](1l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 30l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));
    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));
    }

}
"
HumanEval_44,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //आधार संख्या 10 से कम है।    //रूपांतरण के बाद स्ट्रिंग प्रतिनिधित्व लौटाएं।    //इनपुट संख्या x का संख्यात्मक आधार आधार में बदलें।    // >>> changeBase((8l), (3l))
    // (""22"")
    // >>> changeBase((8l), (2l))
    // (""1000"")
    // >>> changeBase((7l), (2l))
    // (""111"")
    def changeBase(x : Long, base : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def changeBase(x: Long, base: Long): String = {
        require(base > 1 && base < 10, ""Base must be between 2 and 9"")
        
        if (x == 0) return ""0""

        val result = new StringBuilder()
        var number = x

        while (number > 0) {
            val remainder = number % base
            result.append(remainder.toString)
            number /= base
        }

        result.reverse.toString()
    }
}","    }
    def main(args: Array[String]) = {
    assert(changeBase((8l), (3l)).equals((""22"")));
    assert(changeBase((9l), (3l)).equals((""100"")));
    assert(changeBase((234l), (2l)).equals((""11101010"")));
    assert(changeBase((16l), (2l)).equals((""10000"")));
    assert(changeBase((8l), (2l)).equals((""1000"")));
    assert(changeBase((7l), (2l)).equals((""111"")));
    assert(changeBase((2l), (3l)).equals((""2"")));
    assert(changeBase((3l), (4l)).equals((""3"")));
    assert(changeBase((4l), (5l)).equals((""4"")));
    assert(changeBase((5l), (6l)).equals((""5"")));
    assert(changeBase((6l), (7l)).equals((""6"")));
    assert(changeBase((7l), (8l)).equals((""7"")));
    }

}
"
HumanEval_45,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //एक त्रिभुज के लिए एक पक्ष की लंबाई और उच्च वापसी क्षेत्र दिया गया है।    // >>> triangleArea((5l), (3l))
    // (7.5f)
    def triangleArea(a : Long, h : Long) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> triangleArea(5l, 3l)
    // (7.5f)
    def triangleArea(a: Long, h: Long): Float = {
        (a * h / 2.0).toFloat
    }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((5l), (3l)) == (7.5f));
    assert(triangleArea((2l), (2l)) == (2.0f));
    assert(triangleArea((10l), (8l)) == (40.0f));
    }

}
"
HumanEval_46,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //कृपया एक फ़ंक्शन लिखें जो fib4 संख्या अनुक्रम के n-वें तत्व की कुशलतापूर्वक गणना करे। पुनरावृत्ति का उपयोग न करें।    //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) ।    //fib4(3) -> 0     //fib4(2) -> 2     //fib4(1) -> 0     //fib4(0) -> 0     //Fib4 संख्या अनुक्रम एक अनुक्रम है जो Fibbonacci अनुक्रम के समान है जिसे निम्नानुसार परिभाषित किया गया है:     // >>> fib4((5l))
    // (4l)
    // >>> fib4((6l))
    // (8l)
    // >>> fib4((7l))
    // (14l)
    def fib4(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fib4(n: Long): Long = {
    if (n == 0 || n == 1) return 0
    if (n == 2) return 2
    if (n == 3) return 0

    var a: Long = 0
    var b: Long = 0
    var c: Long = 2
    var d: Long = 0
    
    var result: Long = 0
    
    for (i <- 4L to n) {
      result = a + b + c + d
      a = b
      b = c
      c = d
      d = result
    }
    
    result
  }
}","    }
    def main(args: Array[String]) = {
    assert(fib4((5l)) == (4l));
    assert(fib4((8l)) == (28l));
    assert(fib4((10l)) == (104l));
    assert(fib4((12l)) == (386l));
    }

}
"
HumanEval_47,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //सूची में तत्वों का रिटर्न मध्यवर्ती l.     // >>> median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // 3l
    // >>> median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong)))
    // (15.0f)
    def median(l : List[Long]) : Float = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return median of elements in the list l.
  def median(l: List[Long]): Float = {
    val sortedList = l.sorted
    val n = sortedList.length
    if (n % 2 == 1) {
      sortedList(n / 2).toFloat
    } else {
      (sortedList(n / 2 - 1) + sortedList(n / 2)).toFloat / 2
    }
  }

  def main(args: Array[String]): Unit = {
    println(median(List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) // 3.0
    println(median(List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) // 15.0
  }
}","    }
    def main(args: Array[String]) = {
    assert(median((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == 3l);
    assert(median((List[Long](-10l.toLong, 4l.toLong, 6l.toLong, 1000l.toLong, 10l.toLong, 20l.toLong))) == (8.0f));
    assert(median((List[Long](5l.toLong))) == 5l);
    assert(median((List[Long](6l.toLong, 5l.toLong))) == (5.5f));
    assert(median((List[Long](8l.toLong, 1l.toLong, 3l.toLong, 9l.toLong, 9l.toLong, 2l.toLong, 7l.toLong))) == 7l);
    }

}
"
HumanEval_48,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //जाँचता है कि दी गई स्ट्रिंग एक पैलिंड्रोम है या नहीं     // >>> isPalindrome((""""))
    // (true)
    // >>> isPalindrome((""aba""))
    // (true)
    // >>> isPalindrome((""aaaaa""))
    // (true)
    // >>> isPalindrome((""zbcd""))
    // (false)
    def isPalindrome(text : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Checks if given string is a palindrome
  def isPalindrome(text: String): Boolean = {
    val length = text.length
    for (i <- 0 until length / 2) {
      if (text(i) != text(length - i - 1)) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isPalindrome(("""")) == (true));
    assert(isPalindrome((""aba"")) == (true));
    assert(isPalindrome((""aaaaa"")) == (true));
    assert(isPalindrome((""zbcd"")) == (false));
    assert(isPalindrome((""xywyx"")) == (true));
    assert(isPalindrome((""xywyz"")) == (false));
    assert(isPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //2^n मॉडुलो p लौटाएँ (संख्याओं के बारे में जागरूक रहें) ।    // >>> modp((3l), (5l))
    // (3l)
    // >>> modp((1101l), (101l))
    // (2l)
    // >>> modp((0l), (101l))
    // (1l)
    // >>> modp((3l), (11l))
    // (8l)
    // >>> modp((100l), (101l))
    // (1l)
    def modp(n : Long, p : Long) : Long = {
","def modp(n: Long, p: Long): Long = {
    // Calculate 2^n modulo p using iterative exponentiation by squaring.
    def powMod(base: Long, exp: Long, mod: Long): Long = {
      var result = 1L
      var b = base % mod
      var e = exp
      
      while (e > 0) {
        if ((e & 1) == 1) { // Check if e is odd
          result = (result * b) % mod
        }
        e >>= 1
        b = (b * b) % mod
      }

      result
    }

    powMod(2, n, p)
  }
}","    }
    def main(args: Array[String]) = {
    assert(modp((3l), (5l)) == (3l));
    assert(modp((1101l), (101l)) == (2l));
    assert(modp((0l), (101l)) == (1l));
    assert(modp((3l), (11l)) == (8l));
    assert(modp((100l), (101l)) == (1l));
    assert(modp((30l), (5l)) == (4l));
    assert(modp((31l), (5l)) == (3l));
    }

}
"
HumanEval_51,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //remove_vowels एक फ़ंक्शन है जो स्ट्रिंग लेता है और स्वरों के बिना स्ट्रिंग लौटाता है.     // >>> removeVowels((""""))
    // ("""")
    // >>> removeVowels((""abcdef""))
    // (""bcdf"")
    // >>> removeVowels((""aaaaa""))
    // ("""")
    // >>> removeVowels((""aaBAA""))
    // (""B"")
    // >>> removeVowels((""zbcd""))
    // (""zbcd"")
    def removeVowels(text : String) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def removeVowels(text: String): String = {
        val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        text.filterNot(vowels.contains)
    }
}","    }
    def main(args: Array[String]) = {
    assert(removeVowels(("""")).equals(("""")));
    assert(removeVowels((""abcdef\nghijklm"")).equals((""bcdf\nghjklm"")));
    assert(removeVowels((""fedcba"")).equals((""fdcb"")));
    assert(removeVowels((""eeeee"")).equals(("""")));
    assert(removeVowels((""acBAA"")).equals((""cB"")));
    assert(removeVowels((""EcBOO"")).equals((""cB"")));
    assert(removeVowels((""ybcd"")).equals((""ybcd"")));
    }

}
"
HumanEval_52,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यदि सूची में सभी संख्याएँ सीमा t से नीचे हैं तो सही लौटाएं।    // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
    // (true)
    // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
    // (false)
    def belowThreshold(l : List[Long], t : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if all numbers in the list l are below threshold t.
  // >>> belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l))
  // (true)
  // >>> belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l))
  // (false)
  def belowThreshold(l: List[Long], t: Long): Boolean = {
    l.forall(_ < t)
  }
}","    }
    def main(args: Array[String]) = {
    assert(belowThreshold((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong)), (100l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (5l)) == (false));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (21l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)), (22l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (11l)) == (true));
    assert(belowThreshold((List[Long](1l.toLong, 8l.toLong, 4l.toLong, 10l.toLong)), (10l)) == (false));
    }

}
"
HumanEval_53,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //दो संख्याओं x और y जोड़ें     // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    // Add two numbers x and y
    // >>> add((2l), (3l))
    // (5l)
    // >>> add((5l), (7l))
    // (12l)
    def add(x: Long, y: Long): Long = {
        x + y
    }
}","    }
    def main(args: Array[String]) = {
    assert(add((0l), (1l)) == (1l));
    assert(add((1l), (0l)) == (1l));
    assert(add((2l), (3l)) == (5l));
    assert(add((5l), (7l)) == (12l));
    assert(add((7l), (5l)) == (12l));
    }

}
"
HumanEval_54,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //जाँचें कि क्या दो शब्दों में एक ही अक्षर हैं।    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> sameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> sameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> sameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> sameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    def sameChars(s0 : String, s1 : String) : Boolean = {
","import scala.collection.mutable._

object Problem {
  def sameChars(s0: String, s1: String): Boolean = {
    def charSet(s: String): Set[Char] = s.toSet
    charSet(s0) == charSet(s1) && charSet(s0).forall(c => s0.count(_ == c) <= s1.count(_ == c) && s1.count(_ == c) <= s0.count(_ == c))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    assert(sameChars((""abcd""), (""dddddddabc"")) == (true));
    assert(sameChars((""dddddddabc""), (""abcd"")) == (true));
    assert(sameChars((""eabcd""), (""dddddddabc"")) == (false));
    assert(sameChars((""abcd""), (""dddddddabcf"")) == (false));
    assert(sameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    assert(sameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //n-वां फाइबोनैचि संख्या लौटाएँ.     // >>> fib((10l))
    // (55l)
    // >>> fib((1l))
    // (1l)
    // >>> fib((8l))
    // (21l)
    def fib(n : Long) : Long = {
","def fib(n: Long): Long = {
        if (n <= 1) n
        else {
            var a: Long = 0
            var b: Long = 1
            for (_ <- 2L to n) {
                val temp = a + b
                a = b
                b = temp
            }
            b
        }
    }
}","    }
    def main(args: Array[String]) = {
    assert(fib((10l)) == (55l));
    assert(fib((1l)) == (1l));
    assert(fib((8l)) == (21l));
    assert(fib((11l)) == (89l));
    assert(fib((12l)) == (144l));
    }

}
"
HumanEval_56,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यदि प्रत्येक खुलने वाले कोष्ठक में एक संबंधित समापन कोष्ठक हो तो true लौटाएं।    //कोष्ठक ""<"" और "">"" की एक स्ट्रिंग है।    // >>> correctBracketing((""<""))
    // (false)
    // >>> correctBracketing((""<>""))
    // (true)
    // >>> correctBracketing((""<<><>>""))
    // (true)
    // >>> correctBracketing((""><<>""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","import scala.collection.mutable.Stack

object Problem {
  def correctBracketing(brackets: String): Boolean = {
    val stack = new Stack[Char]()
    for (char <- brackets) {
      if (char == '<') {
        stack.push(char)
      } else if (char == '>') {
        if (stack.isEmpty || stack.pop() != '<') {
          return false
        }
      }
    }
    stack.isEmpty
  }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""<>"")) == (true));
    assert(correctBracketing((""<<><>>"")) == (true));
    assert(correctBracketing((""<><><<><>><>"")) == (true));
    assert(correctBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    assert(correctBracketing((""<<<><>>>>"")) == (false));
    assert(correctBracketing((""><<>"")) == (false));
    assert(correctBracketing((""<"")) == (false));
    assert(correctBracketing((""<<<<"")) == (false));
    assert(correctBracketing(("">"")) == (false));
    assert(correctBracketing((""<<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>><<>"")) == (false));
    assert(correctBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //लौटाएँ सही है सूची तत्व एकतरफा बढ़ते या घटते हैं।    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
    // (true)
    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
    // (false)
    // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
    // (true)
    def monotonic(l : List[Long]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return true if list elements are monotonically increasing or decreasing.
  // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))
  // (true)
  // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong)))
  // (false)
  // >>> monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong)))
  // (true)
  def monotonic(l: List[Long]): Boolean = {
    if (l.isEmpty || l.length == 1) return true

    val increasing = l.sliding(2).forall { case List(a, b) => a <= b }
    val decreasing = l.sliding(2).forall { case List(a, b) => a >= b }

    increasing || decreasing
  }
}","    }
    def main(args: Array[String]) = {
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 10l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong, 10l.toLong))) == (false));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 0l.toLong, -10l.toLong))) == (true));
    assert(monotonic((List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))) == (true));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));
    assert(monotonic((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));
    assert(monotonic((List[Long](9l.toLong, 9l.toLong, 9l.toLong, 9l.toLong))) == (true));
    }

}
"
HumanEval_58,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //दो सूचियों के लिए क्रमबद्ध अद्वितीय सामान्य तत्व लौटाता है।    // >>> common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))
    // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))
    // >>> common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))
    // (List[Long](2l.toLong, 3l.toLong))
    def common(l1 : List[Long], l2 : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Return sorted unique common elements for two lists.
  def common(l1: List[Long], l2: List[Long]): List[Long] = {
    (l1.toSet intersect l2.toSet).toList.sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(common(List[Long](1L, 4L, 3L, 34L, 653L, 2L, 5L), List[Long](5L, 7L, 1L, 5L, 9L, 653L, 121L)))
    println(common(List[Long](5L, 3L, 2L, 8L), List[Long](3L, 2L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(common((List[Long](1l.toLong, 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong, 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 653l.toLong))));
    assert(common((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 3l.toLong, 4l.toLong))));
    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));
    }

}
"
HumanEval_59,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //n का सबसे बड़ा अभाज्य गुणक लौटाएँ. मान लें कि n > 1 है और अभाज्य नहीं है.     // >>> largestPrimeFactor((13195l))
    // (29l)
    // >>> largestPrimeFactor((2048l))
    // (2l)
    def largestPrimeFactor(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def largestPrimeFactor(n: Long): Long = {
        var number = n
        var largestFactor = 1L

        // Check for number of 2s that divide n
        while (number % 2 == 0) {
            largestFactor = 2L
            number /= 2
        }

        // n must be odd at this point, so a skip of 2 (i = i + 2) can be used
        var i = 3
        while (i <= sqrt(number)) {
            while (number % i == 0) {
                largestFactor = i
                number /= i
            }
            i += 2
        }

        // This condition is to check if number is a prime number greater than 2
        if (number > 2) {
            largestFactor = number
        }

        largestFactor
    }
}","    }
    def main(args: Array[String]) = {
    assert(largestPrimeFactor((15l)) == (5l));
    assert(largestPrimeFactor((27l)) == (3l));
    assert(largestPrimeFactor((63l)) == (7l));
    assert(largestPrimeFactor((330l)) == (11l));
    assert(largestPrimeFactor((13195l)) == (29l));
    }

}
"
HumanEval_60,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //sum_to_n एक फंक्शन है जो 1 से n तक की संख्याओं को जोड़ता है।    // >>> sumToN((30l))
    // (465l)
    // >>> sumToN((100l))
    // (5050l)
    // >>> sumToN((5l))
    // (15l)
    // >>> sumToN((10l))
    // (55l)
    // >>> sumToN((1l))
    // (1l)
    def sumToN(n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    def sumToN(n: Long): Long = {
        (1L to n).sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumToN((1l)) == (1l));
    assert(sumToN((6l)) == (21l));
    assert(sumToN((11l)) == (66l));
    assert(sumToN((30l)) == (465l));
    assert(sumToN((100l)) == (5050l));
    }

}
"
HumanEval_61,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यदि प्रत्येक खुलने वाले कोष्ठक में एक संबंधित समापन कोष्ठक हो तो true लौटाएं।    //कोष्ठक ""("" और """") की एक स्ट्रिंग है।    // >>> correctBracketing((""(""))
    // (false)
    // >>> correctBracketing((""()""))
    // (true)
    // >>> correctBracketing((""(()())""))
    // (true)
    // >>> correctBracketing(("")(()""))
    // (false)
    def correctBracketing(brackets : String) : Boolean = {
","var balance = 0
        for (ch <- brackets) {
            if (ch == '(') balance += 1
            else if (ch == ')') balance -= 1
            
            if (balance < 0) return false
        }
        balance == 0
    }
}","    }
    def main(args: Array[String]) = {
    assert(correctBracketing((""()"")) == (true));
    assert(correctBracketing((""(()())"")) == (true));
    assert(correctBracketing((""()()(()())()"")) == (true));
    assert(correctBracketing((""()()((()()())())(()()(()))"")) == (true));
    assert(correctBracketing((""((()())))"")) == (false));
    assert(correctBracketing(("")(()"")) == (false));
    assert(correctBracketing((""("")) == (false));
    assert(correctBracketing((""(((("")) == (false));
    assert(correctBracketing(("")"")) == (false));
    assert(correctBracketing((""(()"")) == (false));
    assert(correctBracketing((""()()(()())())(()"")) == (false));
    assert(correctBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इस बहुपद के व्युत्पन्न को उसी रूप में लौटाएँ.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....     //xs बहुपद के गुणांक को दर्शाता है।    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))
    // >>> derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 6l.toLong))
    def derivative(xs : List[Long]) : List[Long] = {
","import scala.collection.mutable._

object Problem {
  def derivative(xs: List[Long]): List[Long] = {
    xs.zipWithIndex.tail.map { case (coeff, index) => coeff * index }
  }
}","    }
    def main(args: Array[String]) = {
    assert(derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))));
    assert(derivative((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));
    assert(derivative((List[Long](3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 0l.toLong, 16l.toLong))));
    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_63,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //कृपया एक फ़ंक्शन लिखें जो फाइबफिन संख्या अनुक्रम के n-वें तत्व की कुशलतापूर्वक गणना करे।    //fibfib (n) == fibfib (n-1) + fibfib (n-2) + fibfib (n-3).     //fib fib ((2) == 1     //फ्फफफफफफफफफफफफफफफफफफफफफफफफफफफफफफफफफफफफफ    //fib fib ((0) == 0     //FibFib संख्या अनुक्रम Fibbonacci अनुक्रम के समान एक अनुक्रम है जिसे निम्नानुसार परिभाषित किया गया है:     // >>> fibfib((1l))
    // (0l)
    // >>> fibfib((5l))
    // (4l)
    // >>> fibfib((8l))
    // (24l)
    def fibfib(n : Long) : Long = {
","def fibfib(n: Long): Long = {
    if (n == 0) return 0
    if (n == 1) return 0
    if (n == 2) return 1

    var a: Long = 0
    var b: Long = 0
    var c: Long = 1
    var d: Long = 0

    for (_ <- 3L to n) {
      d = a + b + c
      a = b
      b = c
      c = d
    }
    d
  }
}","    }
    def main(args: Array[String]) = {
    assert(fibfib((2l)) == (1l));
    assert(fibfib((1l)) == (0l));
    assert(fibfib((5l)) == (4l));
    assert(fibfib((8l)) == (24l));
    assert(fibfib((10l)) == (81l));
    assert(fibfib((12l)) == (274l));
    assert(fibfib((14l)) == (927l));
    }

}
"
HumanEval_64,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //स्वर, लेकिन केवल तब जब यह दिए गए शब्द के अंत में हो।    //इस मामले में स्वर 'अ', 'ई', 'आई', 'ओ', 'यू' हैं। यहाँ, 'य' भी एक है।    //एक शब्द इनपुट के रूप में और स्ट्रिंग में स्वरों की संख्या देता है।    //एक फ़ंक्शन vowels_count लिखें जो एक स्ट्रिंग लेता है जो     // >>> vowelsCount((""abcde""))
    // (2l)
    // >>> vowelsCount((""ACEDY""))
    // (3l)
    def vowelsCount(s : String) : Long = {
","def vowelsCount(s: String): Long = {
    val vowels = Set('a', 'e', 'i', 'o', 'u')
    val lowerCaseWord = s.toLowerCase
    var count = 0L

    for (i <- lowerCaseWord.indices) {
      if (vowels.contains(lowerCaseWord(i)) || (lowerCaseWord(i) == 'y' && i == lowerCaseWord.length - 1)) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(vowelsCount((""abcde"")) == (2l));
    assert(vowelsCount((""Alone"")) == (3l));
    assert(vowelsCount((""key"")) == (2l));
    assert(vowelsCount((""bye"")) == (1l));
    assert(vowelsCount((""keY"")) == (2l));
    assert(vowelsCount((""bYe"")) == (1l));
    assert(vowelsCount((""ACEDY"")) == (3l));
    }

}
"
HumanEval_65,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यदि shift > अंकों की संख्या, तो अंकों को उल्टा लौटाएं।    //और परिणाम को स्ट्रिंग के रूप में लौटाता है.    //परिपत्र पूर्णांक x के अंक को स्थानांतरित करें, अंक को दाईं ओर स्थानांतरित करें।    // >>> circularShift((12l), (1l))
    // (""21"")
    // >>> circularShift((12l), (2l))
    // (""12"")
    def circularShift(x : Long, shift : Long) : String = {
","def circularShift(x: Long, shift: Long): String = {
  val digits = x.toString
  val length = digits.length
  
  if (shift >= length) {
    digits.reverse
  } else {
    val effectiveShift = (length - shift % length).toInt
    (digits.drop(effectiveShift) + digits.take(effectiveShift))
  }
}","    }
    def main(args: Array[String]) = {
    assert(circularShift((100l), (2l)).equals((""001"")));
    assert(circularShift((12l), (2l)).equals((""12"")));
    assert(circularShift((97l), (8l)).equals((""79"")));
    assert(circularShift((12l), (1l)).equals((""21"")));
    assert(circularShift((11l), (101l)).equals((""11"")));
    }

}
"
HumanEval_66,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //एएससीआईआई कोड।    //एक फ़ंक्शन लिखें जो इनपुट के रूप में एक स्ट्रिंग लेता है और केवल ऊपरी वर्णों का योग देता है'     //कार्य     // >>> digitSum((""""))
    // (0l)
    // >>> digitSum((""abAB""))
    // (131l)
    // >>> digitSum((""abcCd""))
    // (67l)
    // >>> digitSum((""helloE""))
    // (69l)
    // >>> digitSum((""woArBld""))
    // (131l)
    // >>> digitSum((""aAaaaXa""))
    // (153l)
    def digitSum(s : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def digitSum(s: String): Long = {
    s.filter(_.isUpper).map(_.toLong).sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(digitSum(("""")) == (0l));
    assert(digitSum((""abAB"")) == (131l));
    assert(digitSum((""abcCd"")) == (67l));
    assert(digitSum((""helloE"")) == (69l));
    assert(digitSum((""woArBld"")) == (131l));
    assert(digitSum((""aAaaaXa"")) == (153l));
    assert(digitSum(("" How are yOu?"")) == (151l));
    assert(digitSum((""You arE Very Smart"")) == (327l));
    }

}
"
HumanEval_67,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //के लिए examble:     //टोकरी में टोकरी में आम के फलों की संख्या लौटाएं।    //संतरे और सेब और एक पूर्णांक जो फल की कुल संख्या का प्रतिनिधित्व करता है     //सेब, संतरे, और आम के फल. दिया स्ट्रिंग है कि  की कुल संख्या का प्रतिनिधित्व करता है    //जो फल की टोकरी में वितरित किए जाते हैं, इस टोकरी में फल होते हैं।    //इस कार्य में, आपको एक स्ट्रिंग दी जाएगी जो कि सेब और संतरे की संख्या का प्रतिनिधित्व करती है     // >>> fruitDistribution((""5 apples and 6 oranges""), (19l))
    // (8l)
    // >>> fruitDistribution((""0 apples and 1 oranges""), (3l))
    // (2l)
    // >>> fruitDistribution((""2 apples and 3 oranges""), (100l))
    // (95l)
    // >>> fruitDistribution((""100 apples and 1 oranges""), (120l))
    // (19l)
    def fruitDistribution(s : String, n : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fruitDistribution(s: String, n: Long): Long = {
    val fruits = s.split("" and "").map(_.split("" "")(0).toLong)
    val totalApplesAndOranges = fruits.sum
    n - totalApplesAndOranges
  }
}","    }
    def main(args: Array[String]) = {
    assert(fruitDistribution((""5 apples and 6 oranges""), (19l)) == (8l));
    assert(fruitDistribution((""5 apples and 6 oranges""), (21l)) == (10l));
    assert(fruitDistribution((""0 apples and 1 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""1 apples and 0 oranges""), (3l)) == (2l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (100l)) == (95l));
    assert(fruitDistribution((""2 apples and 3 oranges""), (5l)) == (0l));
    assert(fruitDistribution((""1 apples and 100 oranges""), (120l)) == (19l));
    }

}
"
HumanEval_68,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण 1:     //यदि कोई सम मान नहीं हैं या दी गई सूची खाली है, तो वापस करें []।    //चुराए गए नोड को सूची में लौटाया जाना चाहिए, [ smalest_value, इसका सूचकांक ],     //यदि एक ही सबसे छोटे सम मान के साथ कई नोड्स पाए जाते हैं तो सबसे छोटा सूचकांक वाला नोड लौटाएं।     //चुराया गया नोड सबसे छोटा सम मान वाला नोड होना चाहिए।    //आपका कार्य नोड्स में से एक को तोड़ना और इसे वापस करना है।    //""एक पेड़ की शाखा का प्रतिनिधित्व करने वाली सूची दी गई जिसमें गैर-ऋणात्मक पूर्णांक नोड्स हैं     // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (List[Long](2l.toLong, 1l.toLong))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> pluck((List[Long]()))
    // (List[Long]())
    // Example 4:
    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    def pluck(arr : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def pluck(arr: List[Long]): List[Long] = {
    val evenNodes = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }
    if (evenNodes.isEmpty) {
      List.empty[Long]
    } else {
      val (smallestValue, index) = evenNodes.minBy { case (value, index) => (value, index) }
      List(smallestValue, index.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));
    assert(pluck((List[Long]())).equals((List[Long]())));
    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));
    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));
    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));
    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));
    }

}
"
HumanEval_69,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //यदि ऐसा कोई मान मौजूद नहीं है, तो -1 लौटाएं।    //किसी पूर्णांक की आवृत्ति सूची में उसके प्रकट होने की संख्या है।    //शून्य, और पूर्णांक के मूल्य से अधिक या उसके बराबर आवृत्ति है।    //आपको धनात्मक पूर्णांक की एक गैर-खाली सूची दी गई है. सबसे बड़ा पूर्णांक लौटाएं जो  से बड़ा हो    // >>> search((List[Long](4l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))
    // (2l)
    // >>> search((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (3l)
    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))
    // (-1l)
    def search(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def search(lst: List[Long]): Long = {
    val frequencyMap = lst.groupBy(identity).mapValues(_.size)
    lst.filter(num => frequencyMap(num) >= num).sorted(Ordering[Long].reverse) match {
      case x :: _ => x
      case Nil => -1L
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(search((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](4l.toLong, 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](3l.toLong, 3l.toLong))) == (-1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));
    assert(search((List[Long](2l.toLong, 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](2l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong, 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong, 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong, 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 7l.toLong, 9l.toLong))) == (1l));
    assert(search((List[Long](1l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](6l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong, 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong))) == (5l));
    assert(search((List[Long](1l.toLong))) == (1l));
    assert(search((List[Long](8l.toLong, 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong, 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 5l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong, 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong))) == (2l));
    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong, 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong, 3l.toLong))) == (1l));
    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong, 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong, 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));
    assert(search((List[Long](2l.toLong, 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong, 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong, 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong))) == (4l));
    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong, 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong, 10l.toLong, 8l.toLong))) == (-1l));
    assert(search((List[Long](10l.toLong))) == (-1l));
    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong, 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong, 7l.toLong, 2l.toLong))) == (2l));
    assert(search((List[Long](5l.toLong, 4l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 1l.toLong, 8l.toLong))) == (1l));
    assert(search((List[Long](7l.toLong, 9l.toLong, 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));
    assert(search((List[Long](3l.toLong, 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));
    }

}
"
HumanEval_70,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //तो शेष पूर्णांक का अधिकतम, तो न्यूनतम और इतने पर।    //अजीब छँटाई, जब आप न्यूनतम मूल्य के साथ शुरू होता है,     //पूर्णांक की सूची दी गई, अजीब क्रम में सूची लौटाएं।    // >>> strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))
    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong)))
    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))
    // >>> strangeSortList((List[Long]()))
    // (List[Long]())
    def strangeSortList(lst : List[Long]) : List[Long] = {
","def strangeSortList(lst: List[Long]): List[Long] = {
    val buffer = lst.sorted.toBuffer
    val result = ArrayBuffer[Long]()
    var takeMin = true

    while (buffer.nonEmpty) {
      if (takeMin) {
        result += buffer.remove(0) // take the minimum
      } else {
        result += buffer.remove(buffer.length - 1) // take the maximum of the remaining
      }
      takeMin = !takeMin
    }

    result.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong, 8l.toLong, 6l.toLong, 7l.toLong))));
    assert(strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long]())).equals((List[Long]())));
    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong, 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));
    assert(strangeSortList((List[Long](0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong, 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));
    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));
    }

}
"
HumanEval_71,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //तीसरे पक्ष की तुलना में।    //तीन पक्ष एक वैध त्रिकोण बनाते हैं जब किसी भी दो पक्षों का योग अधिक होता है।    //अन्यथा वापसी -1     //त्रिकोण को 2 दशमलव बिंदुओं तक गोल किया जाता है यदि तीनों पक्ष एक वैध त्रिकोण बनाते हैं।    //एक त्रिकोण के तीन पक्षों की लंबाई को देखते हुए।  का क्षेत्रफल लौटाएं    // >>> triangleArea((3l), (4l), (5l))
    // (6.0f)
    // >>> triangleArea((1l), (2l), (10l))
    // -1l
    def triangleArea(a : Long, b : Long, c : Long) : Float = {
","import scala.math._

object Problem {
  def triangleArea(a: Long, b: Long, c: Long): Float = {
    if (a + b > c && a + c > b && b + c > a) {
      val s = (a + b + c) / 2.0
      val area = sqrt(s * (s - a) * (s - b) * (s - c))
      BigDecimal(area).setScale(2, BigDecimal.RoundingMode.HALF_UP).toFloat
    } else {
      -1f
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(triangleArea((3l), (4l), (5l)) == (6.0f));
    assert(triangleArea((1l), (2l), (10l)) == -1l);
    assert(triangleArea((4l), (8l), (5l)) == (8.18f));
    assert(triangleArea((2l), (2l), (2l)) == (1.73f));
    assert(triangleArea((1l), (2l), (3l)) == -1l);
    assert(triangleArea((10l), (5l), (7l)) == (16.25f));
    assert(triangleArea((2l), (6l), (3l)) == -1l);
    assert(triangleArea((1l), (1l), (1l)) == (0.43f));
    assert(triangleArea((2l), (2l), (10l)) == -1l);
    }

}
"
HumanEval_72,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //वस्तु q उड़ जाएगा अगर यह संतुलित है (यह एक palindromic सूची है) और इसके तत्वों का योग कम से कम या अधिकतम संभव वजन के बराबर है w।    //एक ऐसा फलन लिखें जो अगर ऑब्जेक्ट q उड़ जाएगा तो true और अन्यथा false लौटाता है.    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> willItFly((List[Long](3l.toLong)), (5l))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    def willItFly(q : List[Long], w : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def willItFly(q: List[Long], w: Long): Boolean = {
    val isPalindromic = q == q.reverse
    val sumOfElements = q.sum
    isPalindromic && sumOfElements <= w
  }

  def main(args: Array[String]): Unit = {
    println(willItFly(List[Long](1L, 2L), 5L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 1L)) // false
    println(willItFly(List[Long](3L, 2L, 3L), 9L)) // true
    println(willItFly(List[Long](3L), 5L)) // true
  }
}","    }
    def main(args: Array[String]) = {
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));
    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));
    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) == (false));
    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (6l)) == (false));
    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));
    }

}
"
HumanEval_73,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //एक बदलाव में, आप एक तत्व को किसी अन्य तत्व में बदल सकते हैं।    //सूची को पालिंड्रोमिक बनाने के लिए इसे बदलने की आवश्यकता है। एक पालिंड्रोमिक सूची एक सूची है जो     //पूर्णांक की एक सूची arr को देखते हुए, तत्वों की न्यूनतम संख्या ज्ञात कीजिए जो     // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))
    // (4l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))
    // (1l)
    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))
    // (0l)
    def smallestChange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a list arr of integers, find the minimum number of elements that
  // need to be changed to make the list palindromic.

  def smallestChange(arr: List[Long]): Long = {
    var changes: Long = 0

    for (i <- 0 until arr.length / 2) {
      if (arr(i) != arr(arr.length - 1 - i)) {
        changes += 1
      }
    }

    changes
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(smallestChange(List(1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L)))  // Output: 4
    println(smallestChange(List(1L, 2L, 3L, 4L, 3L, 2L, 2L)))  // Output: 1
    println(smallestChange(List(1L, 2L, 3L, 2L, 1L)))  // Output: 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));
    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));
    assert(smallestChange((List[Long](3l.toLong, 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));
    assert(smallestChange((List[Long](1l.toLong))) == (0l));
    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));
    }

}
"
HumanEval_74,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //यदि दो सूचियों में वर्णों की संख्या समान है, तो पहली सूची लौटाएं।    //सूची के सभी स्ट्रिंग में वर्णों की कुल संख्या अन्य सूची से कम है।    //एक फ़ंक्शन लिखें जो स्ट्रिंग्स की दो सूचियों को स्वीकार करता है और उस सूची को लौटाता है जिसमें     // >>> totalMatch((List[String]()), (List[String]()))
    // (List[String]())
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi"")))
    // (List[String](""hI"", ""Hi""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project"")))
    // (List[String](""hi"", ""admin""))
    // >>> totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi"")))
    // (List[String](""hI"", ""hi"", ""hi""))
    // >>> totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5"")))
    // (List[String](""4""))
    def totalMatch(lst1 : List[String], lst2 : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def totalMatch(lst1: List[String], lst2: List[String]): List[String] = {
    val sum1 = lst1.map(_.length).sum
    val sum2 = lst2.map(_.length).sum
    if (sum1 <= sum2) lst1 else lst2
  }
}","    }
    def main(args: Array[String]) = {
    assert(totalMatch((List[String]()), (List[String]())).equals((List[String]())));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi""))).equals((List[String](""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hi"", ""hi"", ""admin"", ""project""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String](""4"")), (List[String](""1"", ""2"", ""3"", ""4"", ""5""))).equals((List[String](""4""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""Hi""))).equals((List[String](""hI"", ""Hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hi""))).equals((List[String](""hI"", ""hi"", ""hi""))));
    assert(totalMatch((List[String](""hi"", ""admin"")), (List[String](""hI"", ""hi"", ""hii""))).equals((List[String](""hi"", ""admin""))));
    assert(totalMatch((List[String]()), (List[String](""this""))).equals((List[String]())));
    assert(totalMatch((List[String](""this"")), (List[String]())).equals((List[String]())));
    }

}
"
HumanEval_75,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //यह जानते हुए कि (ए) 100 से कम है।    //और अन्यथा गलत।    //एक ऐसा फलन लिखें जो सही लौटाता है यदि दी गई संख्या 3 अभाज्य संख्याओं का गुणन है     // >>> isMultiplyPrime((30l))
    // (true)
    // 30 = 2 * 3 * 5
    def isMultiplyPrime(a : Long) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isMultiplyPrime(a: Long): Boolean = {
    def isPrime(num: Long): Boolean = {
      if (num <= 1) return false
      if (num <= 3) return true
      if (num % 2 == 0 || num % 3 == 0) return false
      var i = 5
      while (i * i <= num) {
        if (num % i == 0 || num % (i + 2) == 0) return false
        i += 6
      }
      true
    }

    val primes = (2L to 100L).filter(isPrime)
    val primeList = primes.toList

    for {
      i <- primeList.indices
      j <- i until primeList.size
      k <- j until primeList.size
      if primeList(i) * primeList(j) * primeList(k) == a
    } return true

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isMultiplyPrime((5l)) == (false));
    assert(isMultiplyPrime((30l)) == (true));
    assert(isMultiplyPrime((8l)) == (true));
    assert(isMultiplyPrime((10l)) == (false));
    assert(isMultiplyPrime((125l)) == (true));
    assert(isMultiplyPrime((105l)) == (true));
    assert(isMultiplyPrime((126l)) == (false));
    assert(isMultiplyPrime((729l)) == (false));
    assert(isMultiplyPrime((891l)) == (false));
    assert(isMultiplyPrime((1001l)) == (true));
    }

}
"
HumanEval_76,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //x n का एक साधारण शक्ति है यदि n**int=x     //n की शक्ति और अन्य मामलों में गलत।    //आपका कार्य एक फ़ंक्शन लिखना है जो सही लौटाता है यदि एक संख्या x एक साधारण है     // >>> isSimplePower((1l), (4l))
    // (true)
    // >>> isSimplePower((2l), (2l))
    // (true)
    // >>> isSimplePower((8l), (2l))
    // (true)
    // >>> isSimplePower((3l), (2l))
    // (false)
    // >>> isSimplePower((3l), (1l))
    // (false)
    // >>> isSimplePower((5l), (3l))
    // (false)
    def isSimplePower(x : Long, n : Long) : Boolean = {
","def isSimplePower(x: Long, n: Long): Boolean = {
        if (n == 1) {
            return x == 1
        }
        
        var value: Long = n
        while (value <= x) {
            if (value == x) {
                return true
            }
            
            if (value > Long.MaxValue / n) {
                return false
            }
            value *= n
        }
        
        false
    }
}","    }
    def main(args: Array[String]) = {
    assert(isSimplePower((16l), (2l)) == (true));
    assert(isSimplePower((143214l), (16l)) == (false));
    assert(isSimplePower((4l), (2l)) == (true));
    assert(isSimplePower((9l), (3l)) == (true));
    assert(isSimplePower((16l), (4l)) == (true));
    assert(isSimplePower((24l), (2l)) == (false));
    assert(isSimplePower((128l), (4l)) == (false));
    assert(isSimplePower((12l), (6l)) == (false));
    assert(isSimplePower((1l), (1l)) == (true));
    assert(isSimplePower((1l), (12l)) == (true));
    }

}
"
HumanEval_77,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //नोटः आप मान सकते हैं कि इनपुट हमेशा मान्य है।    //अगर यह ingeger किसी पूर्णांक संख्या का घन है।    //एक ऐसा फलन लिखें जो एक पूर्णांक a लेता है और true देता है     // >>> iscube((1l))
    // (true)
    // >>> iscube((2l))
    // (false)
    // >>> iscube((-1l))
    // (true)
    // >>> iscube((64l))
    // (true)
    // >>> iscube((0l))
    // (true)
    // >>> iscube((180l))
    // (false)
    def iscube(a : Long) : Boolean = {
","def iscube(a: Long): Boolean = {
  val cubeRoot = math.cbrt(a.toDouble).round
  cubeRoot * cubeRoot * cubeRoot == a
}","    }
    def main(args: Array[String]) = {
    assert(iscube((1l)) == (true));
    assert(iscube((2l)) == (false));
    assert(iscube((-1l)) == (true));
    assert(iscube((64l)) == (true));
    assert(iscube((180l)) == (false));
    assert(iscube((1000l)) == (true));
    assert(iscube((0l)) == (true));
    assert(iscube((1729l)) == (false));
    }

}
"
HumanEval_78,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //और प्रतीक ए, बी, सी, डी, ई, एफ हमेशा बड़े अक्षरों में होते हैं।    //नोट: आप मान सकते हैं कि इनपुट हमेशा सही या खाली स्ट्रिंग है,     //बी (= दशमलव 11), डी (= दशमलव 13) ।    //तो आप निम्नलिखित अंकों में से एक संख्या निर्धारित करना होगाः 2, 3, 5, 7,     //अभाज्य संख्याएँ 2, 3, 5, 7, 11, 13, 17,... हैं।    //हेक्साडेसिमल अंक 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ए, बी, सी, डी, ई, एफ हैं।    //1 से बड़ा है जो दो छोटी प्राकृतिक संख्याओं का गुणनफल नहीं है) ।    //अभाज्य संख्याएँ (अभाज्य संख्या, या एक अभाज्य संख्या, एक प्राकृतिक संख्या है)    //एक हेक्साडेसिमल संख्या को एक स्ट्रिंग के रूप में और हेक्साडेसिमल की संख्या को गिनती करता है     //आपको एक फ़ंक्शन लिखने का काम दिया गया है जो प्राप्त करता है     // >>> hexKey((""AB""))
    // (1l)
    // >>> hexKey((""1077E""))
    // (2l)
    // >>> hexKey((""ABED1A33""))
    // (4l)
    // >>> hexKey((""123456789ABCDEF0""))
    // (6l)
    // >>> hexKey((""2020""))
    // (2l)
    def hexKey(num : String) : Long = {
","def hexKey(num: String): Long = {
  val primeHexDigits = Set('2', '3', '5', '7', 'B', 'D')
  num.count(ch => primeHexDigits.contains(ch)).toLong
}","    }
    def main(args: Array[String]) = {
    assert(hexKey((""AB"")) == (1l));
    assert(hexKey((""1077E"")) == (2l));
    assert(hexKey((""ABED1A33"")) == (4l));
    assert(hexKey((""2020"")) == (2l));
    assert(hexKey((""123456789ABCDEF0"")) == (6l));
    assert(hexKey((""112233445566778899AABBCCDDEEFF00"")) == (12l));
    }

}
"
HumanEval_79,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //अतिरिक्त अक्षर प्रारूप में मदद करने के लिए हैं।    //स्ट्रिंग के प्रारंभ और अंत में अतिरिक्त 'db' अक्षरों का एक जोड़ा होगा।    //स्ट्रिंग में प्रत्येक वर्ण '0' या '1' होगा.    //द्विआधारी प्रारूप. फ़ंक्शन को एक स्ट्रिंग लौटना चाहिए, जिसमें प्रत्येक वर्ण एक द्विआधारी  का प्रतिनिधित्व करता है.    //आपको दशमलव रूप में एक संख्या दी जाएगी और आपका कार्य इसे परिवर्तित करना है     // >>> decimalToBinary((15l))
    // (""db1111db"")
    // >>> decimalToBinary((32l))
    // (""db100000db"")
    def decimalToBinary(decimal : Long) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def decimalToBinary(decimal: Long): String = {
    ""db"" + decimal.toBinaryString + ""db""
  }
}","    }
    def main(args: Array[String]) = {
    assert(decimalToBinary((0l)).equals((""db0db"")));
    assert(decimalToBinary((32l)).equals((""db100000db"")));
    assert(decimalToBinary((103l)).equals((""db1100111db"")));
    assert(decimalToBinary((15l)).equals((""db1111db"")));
    }

}
"
HumanEval_80,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //एक स्ट्रिंग हाप्सकेला है यदि इसकी लंबाई कम से कम 3 है और प्रत्येक 3 लगातार अक्षर अलग हैं।    //आपका कार्य यह जांचना है कि स्ट्रिंग हैप्सकेला है या नहीं।    //आपको एक स्ट्रिंग s दी जाती है.    // >>> isHappy((""a""))
    // (false)
    // >>> isHappy((""aa""))
    // (false)
    // >>> isHappy((""abcd""))
    // (true)
    // >>> isHappy((""aabb""))
    // (false)
    // >>> isHappy((""adb""))
    // (true)
    // >>> isHappy((""xyy""))
    // (false)
    def isHappy(s : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isHappy(s: String): Boolean = {
    if (s.length < 3) return false 

    for (i <- 0 until s.length - 2) {
      if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {
        return false
      }
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(isHappy((""a"")) == (false));
    assert(isHappy((""aa"")) == (false));
    assert(isHappy((""abcd"")) == (true));
    assert(isHappy((""aabb"")) == (false));
    assert(isHappy((""adb"")) == (true));
    assert(isHappy((""xyy"")) == (false));
    assert(isHappy((""iopaxpoi"")) == (true));
    assert(isHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //0.0 ई     //> 0.0 डी-    //> 0.7 D     //> 1.0 डी+     //> 1.3 C-     //> 1.7 C    //> 2.0 C+     //> 2.3 बी-     //> 2.7 B     //> 3.0 बी+     //> 3.3 ए-     //> 3.7 ए     //4.0 ए+     //GPA। पत्र ग्रेड।    //एक फ़ंक्शन जो निम्न तालिका का उपयोग करके अक्षर ग्रेड की सूची आउटपुट कर सकता हैः     //उसने आपको कुछ छात्रों के जीपीए की सूची दी है और आपको लिखना है।    //केवल समस्या यह है कि वह उस कोड को खो चुकी है जिसका उपयोग वह ग्रेडिंग के लिए करती थी।    //शिक्षक ग्रेडिंग के लिए अपना एल्गोरिथ्म बना रहा है।    //यह सेमेस्टर का अंतिम सप्ताह है और शिक्षक को ग्रेड देना है।    // >>> gradeEquation((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat)))
    // (List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))
    def numericalLetterGrade(grades : List[Float]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def numericalLetterGrade(grades: List[Float]): List[String] = {
    grades.map { gpa =>
      gpa match {
        case g if g == 4.0 => ""A+""
        case g if g > 3.7 => ""A""
        case g if g > 3.3 => ""A-""
        case g if g > 3.0 => ""B+""
        case g if g > 2.7 => ""B""
        case g if g > 2.3 => ""B-""
        case g if g > 2.0 => ""C+""
        case g if g > 1.7 => ""C""
        case g if g > 1.3 => ""C-""
        case g if g > 1.0 => ""D+""
        case g if g > 0.7 => ""D""
        case g if g > 0.0 => ""D-""
        case _ => ""E""
      }
    }
  }

  def main(args: Array[String]): Unit = {
    val grades = List[Float](4.0f, 3.0f, 1.7f, 2.0f, 3.5f)
    println(numericalLetterGrade(grades)) // Output: List(A+, B, C-, C, A-)
  }
}","    }
    def main(args: Array[String]) = {
    assert(numericalLetterGrade((List[Float](4.0f.toFloat, 3l.toFloat, 1.7f.toFloat, 2l.toFloat, 3.5f.toFloat))).equals((List[String](""A+"", ""B"", ""C-"", ""C"", ""A-""))));
    assert(numericalLetterGrade((List[Float](1.2f.toFloat))).equals((List[String](""D+""))));
    assert(numericalLetterGrade((List[Float](0.5f.toFloat))).equals((List[String](""D-""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat))).equals((List[String](""E""))));
    assert(numericalLetterGrade((List[Float](1.0f.toFloat, 0.3f.toFloat, 1.5f.toFloat, 2.8f.toFloat, 3.3f.toFloat))).equals((List[String](""D"", ""D-"", ""C-"", ""B"", ""B+""))));
    assert(numericalLetterGrade((List[Float](0.0f.toFloat, 0.7f.toFloat))).equals((List[String](""E"", ""D-""))));
    }

}
"
HumanEval_82,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //लंबाई एक अभाज्य संख्या है या अन्यथा गलत है     //एक फ़ंक्शन लिखें जो एक स्ट्रिंग लेता है और यदि स्ट्रिंग     // >>> primeLength((""Hello""))
    // (true)
    // >>> primeLength((""abcdcba""))
    // (true)
    // >>> primeLength((""kittens""))
    // (true)
    // >>> primeLength((""orange""))
    // (false)
    def primeLength(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def primeLength(string: String): Boolean = {
    val length = string.length

    if (length <= 1) return false
    
    for (i <- 2 to sqrt(length).toInt) {
      if (length % i == 0) return false
    }
    true
  }
}","    }
    def main(args: Array[String]) = {
    assert(primeLength((""Hello"")) == (true));
    assert(primeLength((""abcdcba"")) == (true));
    assert(primeLength((""kittens"")) == (true));
    assert(primeLength((""orange"")) == (false));
    assert(primeLength((""wow"")) == (true));
    assert(primeLength((""world"")) == (true));
    assert(primeLength((""MadaM"")) == (true));
    assert(primeLength((""Wow"")) == (true));
    assert(primeLength(("""")) == (false));
    assert(primeLength((""HI"")) == (true));
    assert(primeLength((""go"")) == (true));
    assert(primeLength((""gogo"")) == (false));
    assert(primeLength((""aaaaaaaaaaaaaaa"")) == (false));
    assert(primeLength((""Madam"")) == (true));
    assert(primeLength((""M"")) == (false));
    assert(primeLength((""0"")) == (false));
    }

}
"
HumanEval_83,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //धनात्मक पूर्णांक जो 1 से शुरू या समाप्त होते हैं।    //एक सकारात्मक पूर्णांक n को देखते हुए, n-अंकीय संख्याओं की गणना लौटाएं     def startsOneEnds(n : Long) : Long = {
","def startsOneEnds(n: Long): Long = {
        if (n <= 0) return 0
        
        // Calculate numbers starting with 1: 1XX...X (n-1) digits after 1
        val startWithOne: Long = math.pow(10, n - 1).toLong
        
        // Calculate numbers ending with 1: XX...X1 (n-1) digits before 1
        // but without leading zeroes allowed, i.e., the first digit can't be zero
        val endWithOne: Long = math.pow(10, n - 1).toLong
        
        // Reverse counting: numbers starting and ending with 1 (11XX...X)
        val bothStartAndEndWithOne: Long = if (n > 1) math.pow(10, n - 2).toLong else 0
        
        // The total numbers starting or ending, or both, with 1
        startWithOne + endWithOne - bothStartAndEndWithOne
    }
}","    }
    def main(args: Array[String]) = {
    assert(startsOneEnds((1l)) == (1l));
    assert(startsOneEnds((2l)) == (18l));
    assert(startsOneEnds((3l)) == (180l));
    assert(startsOneEnds((4l)) == (1800l));
    assert(startsOneEnds((5l)) == (18000l));
    }

}
"
HumanEval_84,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //एक धनात्मक पूर्णांक N को देखते हुए, बाइनरी में इसके अंकों का कुल योग लौटाएं।     // >>> solve((1000l))
    // (""1"")
    // >>> solve((150l))
    // (""110"")
    // >>> solve((147l))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    def solve(N : Long) : String = {
","import scala.math._
import scala.collection.mutable._
object Problem {
    // Given a positive integer N, return the total sum of its digits in binary.
    def solve(N: Long): String = {
        val sumOfDigits = N.toString.map(_.asDigit).sum
        sumOfDigits.toBinaryString
    }

    def main(args: Array[String]): Unit = {
        println(solve(1000L))  // should print ""1""
        println(solve(150L))   // should print ""110""
        println(solve(147L))   // should print ""1100""
    }
}","    }
    def main(args: Array[String]) = {
    assert(solve((1000l)).equals((""1"")));
    assert(solve((150l)).equals((""110"")));
    assert(solve((147l)).equals((""1100"")));
    assert(solve((333l)).equals((""1001"")));
    assert(solve((963l)).equals((""10010"")));
    }

}
"
HumanEval_85,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //पूर्णांक की एक गैर-खाली सूची दी गई lst. जोड़े तत्वों को जोड़ें जो विषम सूचकांकों पर हैं ..     // >>> add((List[Long](4l.toLong, 2l.toLong, 6l.toLong, 7l.toLong)))
    // (2l)
    def add(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Given a non-empty list of integers lst. add the even elements that are at odd indices.
  def add(lst: List[Long]): Long = {
    lst.zipWithIndex.collect {
      case (value, index) if index % 2 == 1 && value % 2 == 0 => value
    }.sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(add((List[Long](4l.toLong, 88l.toLong))) == (88l));
    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));
    assert(add((List[Long](4l.toLong, 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));
    assert(add((List[Long](4l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));
    }

}
"
HumanEval_86,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //नोट: आपको वाक्य में शब्दों और रिक्त स्थानों का क्रम रखना चाहिए।    //ascending order आधार पर ascii मूल्य।    //एक नए शब्द से बदल दिए जाते हैं जहां सभी वर्णों में व्यवस्थित होते हैं     //स्ट्रिंग का क्रमबद्ध संस्करण, एक स्ट्रिंग है जहाँ सभी शब्द (अंतर द्वारा अलग)     //एक फ़ंक्शन लिखें जो एक स्ट्रिंग लेता है और उसका एक क्रमबद्ध संस्करण देता है.    // >>> antiShuffle((""Hi""))
    // (""Hi"")
    // >>> antiShuffle((""hello""))
    // (""ehllo"")
    // >>> antiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    def antiShuffle(s : String) : String = {
","import scala.collection.mutable.ArrayBuffer

object Problem {
  def antiShuffle(s: String): String = {
    val words = s.split(""(?<=\\s)"")
    val sortedWords = words.map(word => {
      val trimmedWord = word.trim
      val sortedChars = trimmedWord.sorted
      word.replace(trimmedWord, sortedChars)
    })
    sortedWords.mkString("""")
  }

  def main(args: Array[String]): Unit = {
    println(antiShuffle(""Hi""))
    println(antiShuffle(""hello""))
    println(antiShuffle(""Hello World!!!""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(antiShuffle((""Hi"")).equals((""Hi"")));
    assert(antiShuffle((""hello"")).equals((""ehllo"")));
    assert(antiShuffle((""number"")).equals((""bemnru"")));
    assert(antiShuffle((""abcd"")).equals((""abcd"")));
    assert(antiShuffle((""Hello World!!!"")).equals((""Hello !!!Wdlor"")));
    assert(antiShuffle(("""")).equals(("""")));
    assert(antiShuffle((""Hi. My name is Mister Robot. How are you?"")).equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //इसके अलावा, घटते क्रम में पंक्ति के निर्देशांक को स्तंभों के अनुसार क्रमबद्ध करें।    //निर्देशांक को क्रमशः क्रमशः क्रम में क्रमबद्ध करें।    //प्रत्येक टपल एक निर्देशांक है - (पंक्ति, स्तंभ), 0 से शुरू होता है।    //और ट्यूपल्स की सूची लौटाएं, [(x1, y1), (x2, y2) ...] जैसे कि     //lst, और पूर्णांक x को देखते हुए, सूची में पूर्णांक x को ढूँढें,     //प्रत्येक पंक्ति में भिन्न संख्या में स्तंभ हो सकते हैं।    //जो मैट्रिक्स के समान है, हालांकि, मैट्रिक्स के विपरीत,     //आप एक 2 आयामी डेटा दिया जाता है, एक नेस्टेड सूचियों के रूप में,     // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))
    // (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))
    // >>> getRow((List[List[Long]]()), (1l))
    // (List[Tuple2[Long, Long]]())
    // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))
    // (List[Tuple2[Long, Long]]((2l, 2l)))
    def getRow(lst : List[List[Long]], x : Long) : List[Tuple2[Long, Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def getRow(lst: List[List[Long]], x: Long): List[(Long, Long)] = {
    val coordinates = for {
      (row, rowIndex) <- lst.zipWithIndex
      (value, colIndex) <- row.zipWithIndex
      if value == x
    } yield (rowIndex.toLong, colIndex.toLong)

    coordinates
      .groupBy(_._1)
      .toList
      .sortBy(_._1)
      .flatMap { case (rowIndex, coords) =>
        coords.sortBy(-_._2)
      }
  }
}","    }
    def main(args: Array[String]) = {
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));
    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));
    assert(getRow((List[List[Long]]()), (1l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](1l.toLong))), (2l)).equals((List[Tuple2[Long, Long]]())));
    assert(getRow((List[List[Long]](List[Long](), List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long, Long]]((2l, 2l)))));
    }

}
"
HumanEval_88,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //* दी गई सूची को न बदलें।    //नोटः     //या इसे घटते क्रम में क्रमबद्ध करें यदि योग ((पहला सूचकांक मान, अंतिम सूचकांक मान) सम है।    //आप दिए गए सूची को आरोही क्रम में क्रमबद्ध करेंगे यदि योग ((पहला सूचकांक मान, अंतिम सूचकांक मान) विषम है,     //गैर-ऋणात्मक पूर्णांक की सूची दी गई, क्रमबद्ध करने के बाद दी गई सूची का एक कोस्केला लौटाएं,    // >>> sortArray((List[Long]()))
    // (List[Long]())
    // >>> sortArray((List[Long](5l.toLong)))
    // (List[Long](5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))
    // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))
    def sortArray(array : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def sortArray(array: List[Long]): List[Long] = {
    if (array.isEmpty) {
      array
    } else {
      val first = array.head
      val last = array.last
      val sum = first + last
      if (sum % 2 == 0) {
        array.sorted(Ordering[Long].reverse)
      } else {
        array.sorted
      }
    }
  }

  def main(args: Array[String]): Unit = {
    println(sortArray(List[Long]())) // (List[Long]())
    println(sortArray(List[Long](5L))) // (List[Long](5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L))) // (List[Long](0L, 1L, 2L, 3L, 4L, 5L))
    println(sortArray(List[Long](2L, 4L, 3L, 0L, 1L, 5L, 6L))) // (List[Long](6L, 5L, 4L, 3L, 2L, 1L, 0L))
  }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));
    assert(sortArray((List[Long](15l.toLong, 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));
    assert(sortArray((List[Long](21l.toLong, 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong, 14l.toLong, 11l.toLong))));
    }

}
"
HumanEval_89,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //दो स्थानों पर दो गुना नीचे ले जाएँ।    //वर्णमाला को इस तरह से घुमाया जाना चाहिए कि अक्षर     //वर्णमाला के साथ एन्क्रिप्टेड एक स्ट्रिंग लौटाता है जो घूर्णन किया जा रहा है।    //एक फ़ंक्शन एन्क्रिप्ट बनाएं जो तर्क के रूप में एक स्ट्रिंग लेता है और     // >>> encrypt((""hi""))
    // (""lm"")
    // >>> encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> encrypt((""gf""))
    // (""kj"")
    // >>> encrypt((""et""))
    // (""ix"")
    def encrypt(s : String) : String = {
","def encrypt(s: String): String = {
  s.map(c => {
    val rotatedChar = (c - 'a' + 4) % 26 + 'a'
    rotatedChar.toChar
  })
}","    }
    def main(args: Array[String]) = {
    assert(encrypt((""hi"")).equals((""lm"")));
    assert(encrypt((""asdfghjkl"")).equals((""ewhjklnop"")));
    assert(encrypt((""gf"")).equals((""kj"")));
    assert(encrypt((""et"")).equals((""ix"")));
    assert(encrypt((""faewfawefaewg"")).equals((""jeiajeaijeiak"")));
    assert(encrypt((""hellomyfriend"")).equals((""lippsqcjvmirh"")));
    assert(encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    assert(encrypt((""a"")).equals((""e"")));
    }

}
"
HumanEval_90,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यदि ऐसा कोई तत्व नहीं है तो कोई नहीं लौटाएं.    //एक फ़ंक्शन next_smallest() लिखें जो सूची का दूसरा सबसे छोटा तत्व लौटाता है.     //आपको पूर्णांक की सूची दी जाती है।    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))
    // Some(2l)
    // >>> nextSmallest((List[Long]()))
    // None
    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))
    // None
    def nextSmallest(lst : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def nextSmallest(lst: List[Long]): Option[Long] = {
    if (lst.size < 2) return None

    val distinctSorted = lst.distinct.sorted
    if (distinctSorted.size < 2) None
    else Some(distinctSorted(1))
  }
}","    }
    def main(args: Array[String]) = {
    assert(nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long](5l.toLong, 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(Some(2l)));
    assert(nextSmallest((List[Long]())).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(1l)));
    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));
    assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(Some(-35l)));
    }

}
"
HumanEval_91,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //वाक्य '', '?' या '!' से विभक्त होते हैं।    //बोरियत का एक वाक्य है जो ""मैं"" शब्द से शुरू होता है।    //आपको शब्दों की एक श्रृंखला दी जाएगी, और आपका कार्य संख्या को गिनना है     // >>> isBored((""Hello world""))
    // (0l)
    // >>> isBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1l)
    def isBored(S : String) : Long = {
","def isBored(S: String): Long = {
    // Split the input string into sentences using '.', '?' or '!' as delimiters
    val sentences = S.split(""[.!?]"").map(_.trim)

    // Filter sentences that start with 'I' and count them
    sentences.count(sentence => sentence.startsWith(""I""))
  }
}","    }
    def main(args: Array[String]) = {
    assert(isBored((""Hello world"")) == (0l));
    assert(isBored((""Is the sky blue?"")) == (0l));
    assert(isBored((""I love It !"")) == (1l));
    assert(isBored((""bIt"")) == (0l));
    assert(isBored((""I feel good today. I will be productive. will kill It"")) == (2l));
    assert(isBored((""You and I are going for a walk"")) == (0l));
    }

}
"
HumanEval_92,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //किसी भी अन्य मामले में गलत लौटाता है।    //सही लौटाता है यदि संख्याओं में से एक अन्य दो के योग के बराबर है, और सभी संख्याएं पूर्णांक हैं।    //एक फ़ंक्शन बनाएँ जो 3 संख्याएँ लेता है.    // >>> anyInt(5l, 2l, 7l)
    // (true)
    // >>> anyInt(3l, 2l, 2l)
    // (false)
    // >>> anyInt(3l, -2l, 1l)
    // (true)
    // >>> anyInt((3.6f), (-2.2f), 2l)
    // (false)
    def anyInt(x : Float, y : Float, z : Float) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  // Create a function that takes 3 numbers.
  // Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
  // Returns false in any other cases.
  def anyInt(x: Float, y: Float, z: Float): Boolean = {
    val xLong = x.toLong
    val yLong = y.toLong
    val zLong = z.toLong

    // Check if all inputs are actually integers
    if (xLong == x && yLong == y && zLong == z) {
      return xLong + yLong == zLong || xLong + zLong == yLong || yLong + zLong == xLong
    }
    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(anyInt(2l, 3l, 1l) == (true));
    assert(anyInt((2.5f), 2l, 3l) == (false));
    assert(anyInt((1.5f), 5l, (3.5f)) == (false));
    assert(anyInt(2l, 6l, 2l) == (false));
    assert(anyInt(4l, 2l, 2l) == (true));
    assert(anyInt((2.2f), (2.2f), (2.2f)) == (false));
    assert(anyInt(-4l, 6l, 2l) == (true));
    assert(anyInt(2l, 1l, 1l) == (true));
    assert(anyInt(3l, 4l, 7l) == (true));
    assert(anyInt((3.0f), 4l, 7l) == (false));
    }

}
"
HumanEval_93,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //केवल अक्षरों को मानें।    //अंग्रेजी वर्णमाला में स्वर।    //उस संदेश के साथ पत्र जो 2 स्थानों से पहले दिखाई देता है     //जिस तरह से यह सभी अक्षरों के केस को बदलता है,  में सभी स्वरों को बदलता है    //एक फ़ंक्शन लिखें जो एक संदेश लेता है, और इस तरह के एक में एन्कोड करता है     // >>> encode((""test""))
    // (""TGST"")
    // >>> encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    def encode(message : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def encode(message: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    val vowelMap = Map(
      'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w',
      'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'
    )
    
    message.map { char =>
      if (vowels.contains(char)) {
        vowelMap(char)
      } else if (char.isLetter) {
        if (char.isLower) char.toUpper else char.toLower
      } else {
        char
      }
    }.mkString
  }

  // Test cases
  def main(args: Array[String]): Unit = {
    println(encode(""test""))            // should print ""TGST""
    println(encode(""This is a message"")) // should print ""tHKS KS C MGSSCGG""
  }
}","    }
    def main(args: Array[String]) = {
    assert(encode((""TEST"")).equals((""tgst"")));
    assert(encode((""Mudasir"")).equals((""mWDCSKR"")));
    assert(encode((""YES"")).equals((""ygs"")));
    assert(encode((""This is a message"")).equals((""tHKS KS C MGSSCGG"")));
    assert(encode((""I DoNt KnOw WhAt tO WrItE"")).equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //आपको सबसे बड़ा प्राइम मान ढूंढना होगा और उसके अंकों का योग लौटा देना होगा.    //आपको पूर्णांक की सूची दी जाती है।    // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))
    // (10l)
    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))
    // (25l)
    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))
    // (13l)
    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))
    // (11l)
    // >>> skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))
    // (3l)
    // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong)))
    // (7l)
    def skjkasdkd(lst : List[Long]) : Long = {
","def skjkasdkd(lst: List[Long]): Long = {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) false
    else if (n == 2) true
    else if (n % 2 == 0) false
    else !(3L to math.sqrt(n).toLong by 2).exists(n % _ == 0)
  }

  def sumOfDigits(n: Long): Long = n.toString.map(_.asDigit).sum

  val largestPrime = lst.filter(isPrime).sorted.lastOption.getOrElse(0L)
  sumOfDigits(largestPrime)
}","    }
    def main(args: Array[String]) = {
    assert(skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));
    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));
    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));
    assert(skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));
    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong))) == (3l));
    assert(skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));
    assert(skjkasdkd((List[Long](8191l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong, 7l.toLong))) == (19l));
    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong, 8192l.toLong))) == (10l));
    }

}
"
HumanEval_95,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //फ़ंक्शन को false लौटना चाहिए यदि दिया गया मानचित्र खाली है।    //यदि सभी कुंजी अपरकेस में स्ट्रिंग हैं, तो अन्यथा false लौटाएं.    //एक नक्शा दिया, यदि सभी कुंजी कम में तार हैं सच लौटें     // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""b"" -> ""banana"")))
    // (true)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", ""A"" -> ""banana"", ""B"" -> ""banana"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""a"" -> ""apple"", 8l -> ""banana"", ""a"" -> ""apple"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston"")))
    // (false)
    // >>> checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345"")))
    // (true)
    def checkDictCase(dict : Map[String,String]) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def checkDictCase(dict: Map[String, String]): Boolean = {
    if (dict.isEmpty) return false

    val keys = dict.keys.toList
    val allLowerCase = keys.forall(key => key == key.toLowerCase)
    val allUpperCase = keys.forall(key => key == key.toUpperCase)

    allLowerCase || allUpperCase
  }
}","    }
    def main(args: Array[String]) = {
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""b"" -> ""banana""))) == (true));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""A"" -> ""banana"", ""B"" -> ""banana""))) == (false));
    assert(checkDictCase((Map[String,String](""p"" -> ""pineapple"", ""5"" -> ""banana"", ""a"" -> ""apple""))) == (false));
    assert(checkDictCase((Map[String,String](""Name"" -> ""John"", ""Age"" -> ""36"", ""City"" -> ""Houston""))) == (false));
    assert(checkDictCase((Map[String,String](""STATE"" -> ""NC"", ""ZIP"" -> ""12345""))) == (true));
    assert(checkDictCase((Map[String,String](""fruit"" -> ""Orange"", ""taste"" -> ""Sweet""))) == (true));
    assert(checkDictCase((Map[String,String]())) == (false));
    }

}
"
HumanEval_96,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //पूर्णांक जो अभाज्य संख्याएं हैं और n से कम हैं।    //एक फ़ंक्शन लागू करें जो एक गैर-ऋणात्मक पूर्णांक लेता है और पहले n की सूची देता है     // >>> countUpTo((5l))
    // (List[Long](2l.toLong, 3l.toLong))
    // >>> countUpTo((11l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))
    // >>> countUpTo((0l))
    // (List[Long]())
    // >>> countUpTo((20l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))
    // >>> countUpTo((1l))
    // (List[Long]())
    // >>> countUpTo((18l))
    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))
    def countUpTo(n : Long) : List[Long] = {
","def countUpTo(n: Long): List[Long] = {
    def isPrime(num: Long): Boolean = {
      if (num < 2) return false
      for (i <- 2L to math.sqrt(num).toLong) {
        if (num % i == 0) return false
      }
      true
    }

    (2L until n).filter(isPrime).map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));
    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));
    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));
    assert(countUpTo((0l)).equals((List[Long]())));
    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));
    assert(countUpTo((1l)).equals((List[Long]())));
    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));
    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));
    }

}
"
HumanEval_97,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //मान लें कि इनपुट हमेशा मान्य है।    //उनके इकाई अंकों का गुणनफल।    //फ़ंक्शन को पूरा करें जो दो पूर्णांक लेता है और रिटर्न देता है     // >>> multiply((148l), (412l))
    // (16l)
    // >>> multiply((19l), (28l))
    // (72l)
    // >>> multiply((2020l), (1851l))
    // (0l)
    // >>> multiply((14l), (-15l))
    // (20l)
    def multiply(a : Long, b : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def multiply(a: Long, b: Long): Long = {
        val unitDigitA = abs(a % 10)
        val unitDigitB = abs(b % 10)
        unitDigitA * unitDigitB
    }

    def main(args: Array[String]): Unit = {
        println(multiply(148l, 412l))  // 16l
        println(multiply(19l, 28l))    // 72l
        println(multiply(2020l, 1851l)) // 0l
        println(multiply(14l, -15l))   // 20l
    }
}","    }
    def main(args: Array[String]) = {
    assert(multiply((148l), (412l)) == (16l));
    assert(multiply((19l), (28l)) == (72l));
    assert(multiply((2020l), (1851l)) == (0l));
    assert(multiply((14l), (-15l)) == (20l));
    assert(multiply((76l), (67l)) == (42l));
    assert(multiply((17l), (27l)) == (49l));
    assert(multiply((0l), (1l)) == (0l));
    assert(multiply((0l), (0l)) == (0l));
    }

}
"
HumanEval_98,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //एक स्ट्रिंग s को देखते हुए, सम सूचकांकों में अपरकेस स्वरों की संख्या गिनें।    // >>> countUpper((""aBCdEf""))
    // (1l)
    // >>> countUpper((""abcdefg""))
    // (0l)
    // >>> countUpper((""dBBE""))
    // (0l)
    def countUpper(s : String) : Long = {
","def countUpper(s: String): Long = {
  val uppercaseVowels = Set('A', 'E', 'I', 'O', 'U')
  s.zipWithIndex.collect {
    case (ch, index) if index % 2 == 0 && uppercaseVowels.contains(ch) => ch
  }.size.toLong
}","    }
    def main(args: Array[String]) = {
    assert(countUpper((""aBCdEf"")) == (1l));
    assert(countUpper((""abcdefg"")) == (0l));
    assert(countUpper((""dBBE"")) == (0l));
    assert(countUpper((""B"")) == (0l));
    assert(countUpper((""U"")) == (1l));
    assert(countUpper(("""")) == (0l));
    assert(countUpper((""EEEE"")) == (2l));
    }

}
"
HumanEval_99,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //दो पूर्णांक से, इसे शून्य से दूर गोल करें।    //और यह करने के लिए निकटतम पूर्णांक देता है. यदि संख्या समदूर है     //एक फ़ंक्शन बनाएँ जो एक मान (स्ट्रिंग) लेता है जो एक संख्या का प्रतिनिधित्व करता है     // >>> closestInteger((""10""))
    // (10l)
    // >>> closestInteger((""15.3""))
    // (15l)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    def closestInteger(value : String) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def closestInteger(value: String): Long = {
    val num = value.toDouble
    val lower = floor(num).toLong
    val upper = ceil(num).toLong
    
    if (abs(num - lower) == abs(num - upper)) {
      if (num > 0) upper else lower
    } else {
      round(num)
    }
  }

  def main(args: Array[String]): Unit = {
    println(closestInteger(""10""))  // 10
    println(closestInteger(""15.3"")) // 15
    println(closestInteger(""14.5"")) // 15
    println(closestInteger(""-14.5"")) // -15
  }
}","    }
    def main(args: Array[String]) = {
    assert(closestInteger((""10"")) == (10l));
    assert(closestInteger((""14.5"")) == (15l));
    assert(closestInteger((""-15.5"")) == (-16l));
    assert(closestInteger((""15.3"")) == (15l));
    assert(closestInteger((""0"")) == (0l));
    }

}
"
HumanEval_100,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //i स्तर (i+1) में पत्थरों की संख्या का प्रतिनिधित्व करता है।    //सूची में प्रत्येक स्तर में पत्थरों की संख्या लौटाता है, जहां तत्व सूचकांक में है।    //- अगली सम संख्या यदि n सम है।    //- अगली विषम संख्या यदि n विषम है।    //अगले स्तर में पत्थरों की संख्या है:     //प्रथम स्तर में n पत्थर हैं।    //एक सकारात्मक पूर्णांक n को देखते हुए, आपको पत्थरों के n स्तरों का ढेर बनाना होगा।    // >>> makeAPile((3l))
    // (List[Long](3l.toLong, 5l.toLong, 7l.toLong))
    def makeAPile(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
    def makeAPile(n: Long): List[Long] = {
        val pile = ListBuffer[Long]()
        var currentStones = n
        for (_ <- 0 until n.toInt) {
            pile += currentStones
            currentStones += (if (currentStones % 2 == 0) 2 else 2)
        }
        pile.toList
    }

    def main(args: Array[String]): Unit = {
        val result = makeAPile(3L)
        println(result)
    }
}","    }
    def main(args: Array[String]) = {
    assert(makeAPile((3l)).equals((List[Long](3l.toLong, 5l.toLong, 7l.toLong))));
    assert(makeAPile((4l)).equals((List[Long](4l.toLong, 6l.toLong, 8l.toLong, 10l.toLong))));
    assert(makeAPile((5l)).equals((List[Long](5l.toLong, 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));
    assert(makeAPile((6l)).equals((List[Long](6l.toLong, 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));
    assert(makeAPile((8l)).equals((List[Long](8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));
    }

}
"
HumanEval_101,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //स्ट्रिंग को शब्दों में विभाजित करने और शब्दों की सूची वापस करने के लिए।    //आपको अल्पविराम या रिक्त स्थान द्वारा अलग शब्दों की एक स्ट्रिंग दी जाएगी। आपका कार्य है     // >>> wordsString((""Hi, my name is John""))
    // (List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))
    // >>> wordsString((""One, two, three, four, five, six""))
    // (List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))
    def wordsString(s : String) : List[String] = {
","def wordsString(s: String): List[String] = {
    s.split(""[, ]+"").toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(wordsString((""Hi, my name is John"")).equals((List[String](""Hi"", ""my"", ""name"", ""is"", ""John""))));
    assert(wordsString((""One, two, three, four, five, six"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString((""Hi, my name"")).equals((List[String](""Hi"", ""my"", ""name""))));
    assert(wordsString((""One,, two, three, four, five, six,"")).equals((List[String](""One"", ""two"", ""three"", ""four"", ""five"", ""six""))));
    assert(wordsString(("""")).equals((List[String]())));
    assert(wordsString((""ahmed     , gamal"")).equals((List[String](""ahmed"", ""gamal""))));
    }

}
"
HumanEval_102,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //वहाँ कोई ऐसी संख्या है, तो समारोह वापस आना चाहिए -1.    //सबसे बड़ी सम पूर्णांक संख्या जो [x, y] समावेशी सीमा में है। यदि     //यह फलन दो धनात्मक संख्याओं x और y को लेता है और  को लौटाता है    // >>> chooseNum((12l), (15l))
    // (14l)
    // >>> chooseNum((13l), (12l))
    // (-1l)
    def chooseNum(x : Long, y : Long) : Long = {
","def chooseNum(x: Long, y: Long): Long = {
    // Ensure x is the lesser value and y is the greater value
    val (start, end) = if (x > y) (y, x) else (x, y)
    
    // Start from the end of the range and search backwards for an even number
    for (i <- end to start by -1 if i % 2 == 0) {
      return i
    }
    
    // If no even number is found, return -1
    -1
  }
}","    }
    def main(args: Array[String]) = {
    assert(chooseNum((12l), (15l)) == (14l));
    assert(chooseNum((13l), (12l)) == (-1l));
    assert(chooseNum((33l), (12354l)) == (12354l));
    assert(chooseNum((5234l), (5233l)) == (-1l));
    assert(chooseNum((6l), (29l)) == (28l));
    assert(chooseNum((27l), (10l)) == (-1l));
    assert(chooseNum((7l), (7l)) == (-1l));
    assert(chooseNum((546l), (546l)) == (546l));
    }

}
"
HumanEval_103,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //यदि n m से बड़ा है, तो -1 लौटाएँ.    //उत्तर को निकटतम पूर्णांक में गोल करें और इसे बाइनरी में परिवर्तित करें।    //n से m तक के पूर्णांक का औसत (n और m सहित) ।    //आप दो सकारात्मक पूर्णांक n और m दिया जाता है, और अपने कार्य की गणना करने के लिए है     // >>> roundedAvg((1l), (5l))
    // ""0b11""
    // >>> roundedAvg((7l), (5l))
    // -1l
    // >>> roundedAvg((10l), (20l))
    // ""0b1111""
    // >>> roundedAvg((20l), (33l))
    // ""0b11010""
    def roundedAvg(n : Long, m : Long) : Either[String, Long] = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  // Function to compute the average of the integers from n through m
  def roundedAvg(n: Long, m: Long): Either[String, Long] = {
    if (n > m) {
      Right(-1L)
    } else {
      val count = m - n + 1
      val sum = (n + m) * count / 2
      val average = round(sum.toDouble / count)
      Left(""0b"" + average.toLong.toBinaryString)
    }
  }

  def main(args: Array[String]): Unit = {
    println(roundedAvg(1L, 5L))    // Left(""0b11"")
    println(roundedAvg(7L, 5L))    // Right(-1L)
    println(roundedAvg(10L, 20L))  // Left(""0b1111"")
    println(roundedAvg(20L, 33L))  // Left(""0b11010"")
  }
}","    }
    def main(args: Array[String]) = {
    assert(roundedAvg((1l), (5l)).equals(""0b11""));
    assert(roundedAvg((7l), (13l)).equals(""0b1010""));
    assert(roundedAvg((964l), (977l)).equals(""0b1111001010""));
    assert(roundedAvg((996l), (997l)).equals(""0b1111100100""));
    assert(roundedAvg((560l), (851l)).equals(""0b1011000010""));
    assert(roundedAvg((185l), (546l)).equals(""0b101101110""));
    assert(roundedAvg((362l), (496l)).equals(""0b110101101""));
    assert(roundedAvg((350l), (902l)).equals(""0b1001110010""));
    assert(roundedAvg((197l), (233l)).equals(""0b11010111""));
    assert(roundedAvg((7l), (5l)).equals(-1l));
    assert(roundedAvg((5l), (1l)).equals(-1l));
    assert(roundedAvg((5l), (5l)).equals(""0b101""));
    }

}
"
HumanEval_104,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //नोटः लौटाई गई सूची को बढ़ते क्रम में क्रमबद्ध किया जाना चाहिए।    //तत्वों कि कोई भी अंक नहीं है।    //सकारात्मक पूर्णांक x की सूची दी गई है. सभी की एक क्रमबद्ध सूची लौटाएँ     // >>> uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong)))
    // (List[Long](1l.toLong, 15l.toLong, 33l.toLong))
    // >>> uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong)))
    // (List[Long]())
    def uniqueDigits(x : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def uniqueDigits(x: List[Long]): List[Long] = {
    def hasEvenDigit(n: Long): Boolean = {
      n.toString.exists(c => (c - '0') % 2 == 0)
    }

    x.filterNot(hasEvenDigit).sorted
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(uniqueDigits(List[Long](15L, 33L, 1422L, 1L)))
    println(uniqueDigits(List[Long](152L, 323L, 1422L, 10L)))
  }
}","    }
    def main(args: Array[String]) = {
    assert(uniqueDigits((List[Long](15l.toLong, 33l.toLong, 1422l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 15l.toLong, 33l.toLong))));
    assert(uniqueDigits((List[Long](152l.toLong, 323l.toLong, 1422l.toLong, 10l.toLong))).equals((List[Long]())));
    assert(uniqueDigits((List[Long](12345l.toLong, 2033l.toLong, 111l.toLong, 151l.toLong))).equals((List[Long](111l.toLong, 151l.toLong))));
    assert(uniqueDigits((List[Long](135l.toLong, 103l.toLong, 31l.toLong))).equals((List[Long](31l.toLong, 135l.toLong))));
    }

}
"
HumanEval_105,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //एक, दो, तीन, चार, पांच, छह, सात, आठ, नौ।    //परिणामी सूची को उलट दें, और फिर प्रत्येक अंक को उसके संबंधित नाम से  से प्रतिस्थापित करें।    //पूर्णांक की सूची दी, पूर्णांक है कि 1 और 9 के बीच हैं क्रमबद्ध करें,     // >>> byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong)))
    // (List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))
    // If the list is empty, return an empty list:
    // >>> byLength((List[Long]()))
    // (List[String]())
    // If the list has any strange number ignore it:
    // >>> byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong)))
    // (List[String](""One""))
    def byLength(arr : List[Long]) : List[String] = {
","import scala.collection.mutable._

object Problem {
  def byLength(arr: List[Long]): List[String] = {
    // Map of digit to its corresponding name
    val numToName = Map(
      1L -> ""One"",
      2L -> ""Two"",
      3L -> ""Three"",
      4L -> ""Four"",
      5L -> ""Five"",
      6L -> ""Six"",
      7L -> ""Seven"",
      8L -> ""Eight"",
      9L -> ""Nine""
    )

    // Filter numbers between 1 and 9
    val filteredAndSorted = arr.filter(num => num >= 1 && num <= 9).sorted(Ordering[Long].reverse)
    // Map filtered and sorted numbers to their corresponding names
    filteredAndSorted.map(numToName)
  }
}","    }
    def main(args: Array[String]) = {
    assert(byLength((List[Long](2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 8l.toLong, 2l.toLong, 3l.toLong))).equals((List[String](""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""))));
    assert(byLength((List[Long]())).equals((List[String]())));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 55l.toLong))).equals((List[String](""One""))));
    assert(byLength((List[Long](1l.toLong, -1l.toLong, 3l.toLong, 2l.toLong))).equals((List[String](""Three"", ""Two"", ""One""))));
    assert(byLength((List[Long](9l.toLong, 4l.toLong, 8l.toLong))).equals((List[String](""Nine"", ""Eight"", ""Four""))));
    }

}
"
HumanEval_106,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //i का कारक 1 से i तक की संख्याओं का गुणन है (1 * 2 * ... * i).    //i 1 से शुरू होता है।    //या 1 से i तक की संख्याओं का योग।    //और आकार n की एक सूची लौटाता है, जैसे कि सूचकांक i पर तत्व का मान i का कारक है यदि i सम है     //फलन f को लागू करें जो n को पैरामीटर के रूप में लेता है,     // >>> f((5l))
    // (List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))
    def f(n : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def f(n: Long): List[Long] = {
        def factorial(x: Long): Long = if (x == 0) 1 else x * factorial(x - 1)
        
        (1L to n).map { i =>
            if (i % 2 == 0) factorial(i) else (1L to i).sum
        }.toList
    }
}","    }
    def main(args: Array[String]) = {
    assert(f((5l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));
    assert(f((7l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));
    assert(f((1l)).equals((List[Long](1l.toLong))));
    assert(f((3l)).equals((List[Long](1l.toLong, 2l.toLong, 6l.toLong))));
    }

}
"
HumanEval_107,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण 1:     //पूर्णांक पालिंड्रोम जो कि श्रेणी के भीतर आते हैं ((1, n), समावेशी।     //एक सकारात्मक पूर्णांक n को देखते हुए, एक टपल लौटाएं जिसमें सम और विषम की संख्या है     // >>> evenOddPalindrome((3l))
    // ((1l, 2l))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> evenOddPalindrome((12l))
    // ((4l, 6l))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    def evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {
","def evenOddPalindrome(n: Long): (Long, Long) = {
  def isPalindrome(x: Long): Boolean = {
    val str = x.toString
    str == str.reverse
  }

  var evenCount: Long = 0
  var oddCount: Long = 0

  for (i <- 1L to n) {
    if (isPalindrome(i)) {
      if (i % 2 == 0) evenCount += 1
      else oddCount += 1
    }
  }

  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddPalindrome((123l)).equals(((8l, 13l))));
    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((3l)).equals(((1l, 2l))));
    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));
    assert(evenOddPalindrome((25l)).equals(((5l, 6l))));
    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));
    assert(evenOddPalindrome((9l)).equals(((4l, 5l))));
    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));
    }

}
"
HumanEval_108,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए, -123 में अंक -1, 2, और 3 हैं।    //यदि कोई संख्या ऋणात्मक है, तो उसका पहला हस्ताक्षरित अंक ऋणात्मक होगा:     //तत्वों की संख्या जिसमें अंकों का योग > 0 है।    //एक फंक्शन count_nums लिखें जो पूर्णांक की सूची लेता है और रिटर्न देता है     // >>> countNums((List[Long]()))
    // (0l)
    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))
    // (1l)
    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))
    // (3l)
    def countNums(arr : List[Long]) : Long = {
","def countNums(arr: List[Long]): Long = {
  arr.count(num => {
    val sumOfDigits = num.toString.foldLeft(0) { (acc, char) =>
      if (char == '-') acc else acc + (char - '0')
    }
    sumOfDigits > 0
  }).toLong
}","    }
    def main(args: Array[String]) = {
    assert(countNums((List[Long]())) == (0l));
    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));
    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));
    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));
    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));
    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));
    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));
    assert(countNums((List[Long](1l.toLong))) == (1l));
    }

}
"
HumanEval_109,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //नोटः दी गई सूची में अद्वितीय तत्वों की गारंटी है।    //यदि दी गई सूची खाली है तो true लौटाएं.    //तो सही लौटाएँ या फिर गलत लौटाएँ.    //यदि उपरोक्त कार्य करके क्रमबद्ध सूची प्राप्त करना संभव हो तो     //सूची में प्रारंभिक स्थिति यानी 0वीं सूचकांक।    //सूची का अंतिम तत्व  पर ले जाया जाएगा    //एक दाएँ शिफ्ट ऑपरेशन का अर्थ है सूची के सभी तत्वों को एक से स्थानांतरित करना।    //आपको दाहिनी ओर की शिफ्ट ऑपरेशन को किसी भी संख्या में बार करने की अनुमति है।    //दी गई सूची में निम्नलिखित क्रिया:     //यह संभव है कि एक सूची को गैर-घटते क्रम में क्रमबद्ध किया जाए।    //सूची में संख्याओं को यादृच्छिक क्रम में रखा जाएगा. आपका कार्य यह निर्धारित करना है कि     //हमारे पास एन पूर्णांक arr[1], arr[2], ..., arr[N] की सूची 'arr' है।    // >>> moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong)))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    def moveOneBall(arr : List[Long]) : Boolean = {
","def moveOneBall(arr: List[Long]): Boolean = {
  if (arr.isEmpty) return true

  // Find how many times the array needs to be shifted to become sorted
  val n = arr.length
  var shiftIndex = -1

  for (i <- 0 until n) {
    if (arr(i) > arr((i + 1) % n)) {
      // More than one place where the order breaks means it can't be sorted with a shift
      if (shiftIndex != -1) return false
      shiftIndex = i + 1
    }
  }

  // If no break in order was found, the array is already sorted
  if (shiftIndex == -1) return true

  // Check if shifting by the found index sorts the array
  for (i <- 1 until n) {
    if (arr((shiftIndex + i) % n) < arr((shiftIndex + i - 1) % n)) return false
  }
  
  true
}","    }
    def main(args: Array[String]) = {
    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));
    assert(moveOneBall((List[Long](4l.toLong, 3l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));
    assert(moveOneBall((List[Long]())) == (true));
    }

}
"
HumanEval_110,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //अन्यथा, ""नहीं"" लौटाएं।    //lst1 के सभी तत्वों को भी, ""YES"" लौटाएं।    //यदि यह संभव है कि lst1 और lst2 के बीच तत्वों का आदान-प्रदान करने के लिए     //lst1 और lst2 के बीच आदान-प्रदान किए जाने वाले तत्वों की संख्या पर कोई सीमा नहीं है।    //केवल सम संख्याओं की सूची बनाने के लिए।    //और यह निर्धारित करता है कि क्या तत्वों का आदान-प्रदान करना संभव है     //इस समस्या में, आप एक समारोह है कि संख्याओं की दो सूचियों लेता है लागू होगा,     // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (""YES"")
    // >>> exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong)))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    def exchange(lst1 : List[Long], lst2 : List[Long]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def exchange(lst1: List[Long], lst2: List[Long]): String = {
    // Check if all elements in lst1 are already even
    if (lst1.forall(_ % 2 == 0)) return ""YES""

    // Find if there's any even number in lst2 to exchange with lst1
    val lst2EvensExist = lst2.exists(_ % 2 == 0)

    // Check if there's also at least one odd in lst1 to swap it out
    val lst1OddsExist = lst1.exists(_ % 2 != 0)

    // Only possible if both an even element in lst2 and an odd element in lst1 exist
    if (lst2EvensExist && lst1OddsExist) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((""YES"")));
    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((""NO"")));
    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((""YES"")));
    }

}
"
HumanEval_111,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //यदि कई अक्षरों में एक ही घटना हो, तो उन सभी को वापस करें।    //सबसे अधिक बार दोहराए जाने वाले अक्षर का नाम और उसके अनुरूप संख्या।    //एक स्ट्रिंग को एक स्थान से अलग छोटे अक्षरों का प्रतिनिधित्व करने के लिए दिया गया है, एक मानचित्र लौटाएं     // >>> histogram((""a b c""))
    // (Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l))
    // >>> histogram((""a b b a""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""a b c a b""))
    // (Map[String,Long](""a"" -> 2l, ""b"" -> 2l))
    // >>> histogram((""b b b b a""))
    // (Map[String,Long](""b"" -> 4l))
    // >>> histogram((""""))
    // (Map[String,Long]())
    def histogram(test : String) : Map[String,Long] = {
","def histogram(test: String): Map[String, Long] = {
        val words = test.split("" "")
        val frequencyMap = words.groupBy(identity).mapValues(_.length.toLong)

        if (frequencyMap.isEmpty) return Map.empty[String, Long]

        val maxCount = frequencyMap.values.max
        frequencyMap.filter { case (_, count) => count == maxCount }
    }
}","    }
    def main(args: Array[String]) = {
    assert(histogram((""a b b a"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c a b"")).equals((Map[String,Long](""a"" -> 2l, ""b"" -> 2l))));
    assert(histogram((""a b c d g"")).equals((Map[String,Long](""a"" -> 1l, ""b"" -> 1l, ""c"" -> 1l, ""d"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram((""b b b b a"")).equals((Map[String,Long](""b"" -> 4l))));
    assert(histogram((""r t g"")).equals((Map[String,Long](""r"" -> 1l, ""t"" -> 1l, ""g"" -> 1l))));
    assert(histogram(("""")).equals((Map[String,Long]())));
    assert(histogram((""a"")).equals((Map[String,Long](""a"" -> 1l))));
    }

}
"
HumanEval_112,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //आपको परिणाम स्ट्रिंग और सत्यापन के लिए सही/गलत युक्त एक ट्यूपल लौटना चाहिए।    //एक स्ट्रिंग को पालिंड्रोम कहा जाता है यदि यह पीछे की ओर और आगे की ओर समान रूप से पढ़ता है।    //फिर जाँचें कि परिणाम स्ट्रिंग palindrome है।    //हमें दो तार s और c दिए गए हैं, आपको s में सभी वर्णों को हटाना होगा जो c में किसी भी वर्ण के बराबर है     //कार्य     // >>> reverseDelete((""abcde""), (""ae""))
    // ((""bcd"", false))
    // >>> reverseDelete((""abcdef""), (""b""))
    // ((""acdef"", false))
    // >>> reverseDelete((""abcdedcba""), (""ab""))
    // ((""cdedc"", true))
    def reverseDelete(s : String, c : String) : Tuple2[String, Boolean] = {
","def reverseDelete(s: String, c: String): Tuple2[String, Boolean] = {
    // Convert the characters to be deleted into a set for quick lookup
    val deleteSet = c.toSet
    
    // Filter out characters from s that are present in deleteSet
    val filteredString = s.filterNot(deleteSet.contains)
    
    // Check if the filtered string is a palindrome
    val isPalindrome = filteredString == filteredString.reverse
    
    // Return the tuple with the filtered string and the palindrome check result
    (filteredString, isPalindrome)
  }
}","    }
    def main(args: Array[String]) = {
    assert(reverseDelete((""abcde""), (""ae"")).equals(((""bcd"", false))));
    assert(reverseDelete((""abcdef""), (""b"")).equals(((""acdef"", false))));
    assert(reverseDelete((""abcdedcba""), (""ab"")).equals(((""cdedc"", true))));
    assert(reverseDelete((""dwik""), (""w"")).equals(((""dik"", false))));
    assert(reverseDelete((""a""), (""a"")).equals((("""", true))));
    assert(reverseDelete((""abcdedcba""), ("""")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""abcdedcba""), (""v"")).equals(((""abcdedcba"", true))));
    assert(reverseDelete((""vabba""), (""v"")).equals(((""abba"", true))));
    assert(reverseDelete((""mamma""), (""mia"")).equals((("""", true))));
    }

}
"
HumanEval_113,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इनपुट की i'th स्ट्रिंग में विषम अंकों की।    //इनपुट की स्ट्रिंग i. "" जहां सभी i को संख्या  से प्रतिस्थापित किया जाना चाहिए    //आउटपुट के प्रत्येक तत्व i को ""असमान तत्वों की संख्या होना चाहिए    //स्ट्रिंग्स की सूची दी गई, जहां प्रत्येक स्ट्रिंग में केवल अंक होते हैं, एक सूची लौटाएं।    // >>> oddCount((List[String](""1234567"")))
    // (List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))
    // >>> oddCount((List[String](""3"", ""11111111"")))
    // (List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))
    def oddCount(lst : List[String]) : List[String] = {
","def oddCount(lst: List[String]): List[String] = {
    lst.map { str =>
      val oddCount = str.count(c => c.asDigit % 2 != 0)
      val replacedString = s""the number of odd elements ${oddCount}n the str${oddCount}ng ${oddCount} of the ${oddCount}nput.""
      replacedString
    }
  }

  // Example usage
  def main(args: Array[String]): Unit = {
    println(oddCount(List(""1234567"")))  // List(""the number of odd elements 4n the str4ng 4 of the 4nput."")
    println(oddCount(List(""3"", ""11111111"")))  // List(""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput."")
  }
}","    }
    def main(args: Array[String]) = {
    assert(oddCount((List[String](""1234567""))).equals((List[String](""the number of odd elements 4n the str4ng 4 of the 4nput.""))));
    assert(oddCount((List[String](""3"", ""11111111""))).equals((List[String](""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""))));
    assert(oddCount((List[String](""271"", ""137"", ""314""))).equals((List[String](""the number of odd elements 2n the str2ng 2 of the 2nput."", ""the number of odd elements 3n the str3ng 3 of the 3nput."", ""the number of odd elements 2n the str2ng 2 of the 2nput.""))));
    }

}
"
HumanEval_114,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //    //पूर्णांक संख्याओं की सूची दी गई, किसी भी गैर-खाली उप-सूची का न्यूनतम योग ज्ञात करें     // >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))
    // (1l)
    // >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))
    // (-6l)
    def minSubArraySum(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minSubArraySum(nums: List[Long]): Long = {
    var minEndingHere = nums.head
    var minSoFar = nums.head
    
    for (i <- 1 until nums.length) {
      minEndingHere = min(nums(i), minEndingHere + nums(i))
      minSoFar = min(minSoFar, minEndingHere)
    }
    
    minSoFar
  }

  // Test Cases
  def main(args: Array[String]): Unit = {
    println(minSubArraySum(List(2l, 3l, 4l, 1l, 2l, 4l))) // Output: 1
    println(minSubArraySum(List(-1l, -2l, -3l))) // Output: -6
  }
}","    }
    def main(args: Array[String]) = {
    assert(minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));
    assert(minSubArraySum((List[Long](-9999999999999999l.toLong))) == (-9999999999999999l));
    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 1000000l.toLong))) == (0l));
    assert(minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](100l.toLong, -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));
    assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong, 3l.toLong, 4l.toLong))) == (3l));
    assert(minSubArraySum((List[Long](100l.toLong, -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));
    assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));
    assert(minSubArraySum((List[Long](7l.toLong))) == (7l));
    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));
    }

}
"
HumanEval_115,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण 1:     //उस समय को आउटपुट करें जब आपको बाल्टी को नीचे उतारने की आवश्यकता हो।    //आपका कार्य इन बाल्टियों का उपयोग करके इन कुओं को खाली करना है।    //और सभी बाल्टियों की क्षमता समान है।    //प्रत्येक कुएं में एक उपयुक्त बाल्टी होती है जिसका उपयोग उससे पानी निकालने के लिए किया जा सकता है,    //और प्रत्येक 1 एक पंक्ति में पानी की एक इकाई का प्रतिनिधित्व करता है।    //आपको कुओं का एक आयताकार ग्रिड दिया जाता है। प्रत्येक पंक्ति एक कुएं का प्रतिनिधित्व करती है,     // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l))
    // (6l)
    // Example 2:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l))
    // (5l)
    // Example 3:
    // >>> maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l))
    // (0l)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    def maxFill(grid : List[List[Long]], capacity : Long) : Long = {
","def maxFill(grid: List[List[Long]], capacity: Long): Long = {
  var totalWaterUnits = 0L

  for (row <- grid) {
    totalWaterUnits += row.sum
  }

  // Calculate the number of times you need to lower the buckets
  val bucketOperations = totalWaterUnits / capacity + (if (totalWaterUnits % capacity != 0) 1 else 0)

  bucketOperations
}","    }
    def main(args: Array[String]) = {
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) == (6l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));
    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) == (0l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (4l));
    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (9l)) == (2l));
    }

}
"
HumanEval_116,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //इसे इस प्रकार लागू किया जाना चाहिए:    //समान संख्या के लिए दशमलव मान के आधार पर क्रमबद्ध करें।    //एक के संख्या उनके द्विआधारी प्रतिनिधित्व में आरोही क्रम में।    //इस Kata में, आप के अनुसार गैर-ऋणात्मक पूर्णांक की एक सूची क्रमबद्ध करने के लिए है     // >>> sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))
    // >>> sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong)))
    // (List[Long](-6l.toLong, -5l.toLong, -4l.toLong, -3l.toLong, -2l.toLong))
    // >>> sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))
    def sortArray(arr : List[Long]) : List[Long] = {
","def sortArray(arr: List[Long]): List[Long] = {
        arr.sortBy(n => (n.toBinaryString.count(_ == '1'), n))
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));
    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));
    assert(sortArray((List[Long](1l.toLong, 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));
    assert(sortArray((List[Long]())).equals((List[Long]())));
    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong, 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 7l.toLong, 77l.toLong))));
    assert(sortArray((List[Long](3l.toLong, 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong, 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));
    }

}
"
HumanEval_117,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //नोटः आप मान सकते हैं कि इनपुट स्ट्रिंग में केवल अक्षर और रिक्त स्थान हैं।    //यदि स्ट्रिंग s खाली है तो फ़ंक्शन को खाली सूची लौटना चाहिए.     //n व्यंजन, क्रम में इन शब्दों में दिखाई देते हैं स्ट्रिंग s.     //एक फ़ंक्शन जो स्ट्रिंग s से सभी शब्दों की सूची देता है जिसमें ठीक     //एक स्ट्रिंग s और एक प्राकृतिक संख्या n को देखते हुए, आपको लागू करने का कार्य सौंपा गया है     // >>> selectWords((""Mary had a little lamb""), (4l))
    // (List[String](""little""))
    // >>> selectWords((""Mary had a little lamb""), (3l))
    // (List[String](""Mary"", ""lamb""))
    // >>> selectWords((""simple white space""), (2l))
    // (List[String]())
    // >>> selectWords((""Hello world""), (4l))
    // (List[String](""world""))
    // >>> selectWords((""Uncle sam""), (3l))
    // (List[String](""Uncle""))
    def selectWords(s : String, n : Long) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def selectWords(s: String, n: Long): List[String] = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    def consonantCount(word: String): Int = {
      word.count(c => c.isLetter && !vowels.contains(c))
    }

    if (s.isEmpty) {
      List()
    } else {
      s.split(""\\s+"").filter(word => consonantCount(word) == n).toList
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(selectWords((""Mary had a little lamb""), (4l)).equals((List[String](""little""))));
    assert(selectWords((""Mary had a little lamb""), (3l)).equals((List[String](""Mary"", ""lamb""))));
    assert(selectWords((""simple white space""), (2l)).equals((List[String]())));
    assert(selectWords((""Hello world""), (4l)).equals((List[String](""world""))));
    assert(selectWords((""Uncle sam""), (3l)).equals((List[String](""Uncle""))));
    assert(selectWords((""""), (4l)).equals((List[String]())));
    assert(selectWords((""a b c d e f""), (1l)).equals((List[String](""b"", ""c"", ""d"", ""f""))));
    }

}
"
HumanEval_118,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //आप मान सकते हैं कि दिए गए स्ट्रिंग में केवल अंग्रेजी अक्षर हैं।    //किसी भी स्वर को उपरोक्त शर्त को पूरा करने के लिए खोजें।    //शुरुआत और अंत में स्वरों की गिनती नहीं होती है. यदि आपने नहीं किया है तो खाली स्ट्रिंग लौटाएं     //शब्द के दाहिनी ओर से दो व्यंजन (केस संवेदनशील) ।    //आपको एक शब्द दिया जाता है. आपका कार्य निकटतम स्वर को ढूंढना है जो बीच में खड़ा है     // >>> getClosestVowel((""yogurt""))
    // (""u"")
    // >>> getClosestVowel((""FULL""))
    // (""U"")
    // >>> getClosestVowel((""quick""))
    // ("""")
    // >>> getClosestVowel((""ab""))
    // ("""")
    def getClosestVowel(word : String) : String = {
","def getClosestVowel(word: String): String = {
    val vowels = Set('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
    
    for (i <- word.length - 2 until 0 by -1) {
      if (!vowels.contains(word(i)) && vowels.contains(word(i + 1)) && !vowels.contains(word(i + 2))) {
        return word(i + 1).toString
      }
    }
    
    """"
  }
}","    }
    def main(args: Array[String]) = {
    assert(getClosestVowel((""yogurt"")).equals((""u"")));
    assert(getClosestVowel((""full"")).equals((""u"")));
    assert(getClosestVowel((""easy"")).equals(("""")));
    assert(getClosestVowel((""eAsy"")).equals(("""")));
    assert(getClosestVowel((""ali"")).equals(("""")));
    assert(getClosestVowel((""bad"")).equals((""a"")));
    assert(getClosestVowel((""most"")).equals((""o"")));
    assert(getClosestVowel((""ab"")).equals(("""")));
    assert(getClosestVowel((""ba"")).equals(("""")));
    assert(getClosestVowel((""quick"")).equals(("""")));
    assert(getClosestVowel((""anime"")).equals((""i"")));
    assert(getClosestVowel((""Asia"")).equals(("""")));
    assert(getClosestVowel((""Above"")).equals((""o"")));
    }

}
"
HumanEval_119,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //यदि कोई अच्छा स्ट्रिंग बनाने का कोई तरीका है तो 'हाँ' लौटाएं, और अन्यथा 'नहीं' लौटाएं।    //"" (()) "" नहीं है।    //उदाहरण के लिए: स्ट्रिंग '(()))) अच्छा है, जबकि स्ट्रिंग     //एक स्ट्रिंग S को अच्छा माना जाता है यदि और केवल यदि S में सभी कोष्ठक     //कुछ आदेश, कि परिणामी स्ट्रिंग अच्छा होगा।    //आपका काम यह जांचना है कि क्या दो तारों को जोड़ना संभव है     //केवल कोष्ठक "" (("" या बंद कोष्ठक "") ""।    //आप दो तारों की एक सूची दी जाती है, दोनों तारों में शामिल हैं खुला     // >>> matchParens((List[String](""()("", "")"")))
    // (""Yes"")
    // >>> matchParens((List[String]("")"", "")"")))
    // (""No"")
    def matchParens(lst : List[String]) : String = {
","def matchParens(lst: List[String]): String = {
    def isBalanced(s: String): Boolean = {
      var balance = 0
      for (char <- s) {
        if (char == '(') balance += 1
        else if (char == ')') balance -= 1
        if (balance < 0) return false
      }
      balance == 0
    }
    
    val combinations = List(
      lst(0) + lst(1),
      lst(1) + lst(0)
    )
    
    if (combinations.exists(isBalanced)) ""Yes"" else ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(matchParens((List[String](""()("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", "")""))).equals((""No"")));
    assert(matchParens((List[String](""(()(())"", ""())())""))).equals((""No"")));
    assert(matchParens((List[String]("")())"", ""(()()(""))).equals((""Yes"")));
    assert(matchParens((List[String](""(())))"", ""(()())((""))).equals((""Yes"")));
    assert(matchParens((List[String](""()"", ""())""))).equals((""No"")));
    assert(matchParens((List[String](""(()("", ""()))()""))).equals((""Yes"")));
    assert(matchParens((List[String](""(((("", ""((())""))).equals((""No"")));
    assert(matchParens((List[String]("")(()"", ""(()(""))).equals((""No"")));
    assert(matchParens((List[String]("")("", "")(""))).equals((""No"")));
    assert(matchParens((List[String](""("", "")""))).equals((""Yes"")));
    assert(matchParens((List[String]("")"", ""(""))).equals((""Yes"")));
    }

}
"
HumanEval_120,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण 1:     //की लंबाई k के साथ अधिकतम k संख्याओं में arr.    //पूर्णांक arr की सूची और एक सकारात्मक पूर्णांक k को देखते हुए, एक क्रमबद्ध सूची लौटाएं     // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))
    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))
    // Example 2:
    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))
    // (List[Long](4l.toLong, 4l.toLong))
    // Example 3:
    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))
    // (List[Long](2l.toLong))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    def maximum(arr : List[Long], k : Long) : List[Long] = {
","def maximum(arr: List[Long], k: Long): List[Long] = {
    arr.sorted(Ordering[Long].reverse).take(k.toInt).sorted
  }
}","    }
    def main(args: Array[String]) = {
    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));
    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));
    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));
    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));
    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));
    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));
    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));
    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));
    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));
    }

}
"
HumanEval_121,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //पूर्णांक की एक गैर-खाली सूची दी, सभी विषम तत्वों के योग जो भी पदों में हैं लौटाएं।    // >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))
    // (12l)
    // >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))
    // (9l)
    // >>> solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))
    // (0l)
    def solution(lst : List[Long]) : Long = {
","def solution(lst: List[Long]): Long = {
  lst.zipWithIndex.collect {
    case (num, idx) if idx % 2 == 0 && num % 2 != 0 => num
  }.sum
}","    }
    def main(args: Array[String]) = {
    assert(solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));
    assert(solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));
    assert(solution((List[Long](5l.toLong, 9l.toLong))) == (5l));
    assert(solution((List[Long](2l.toLong, 4l.toLong, 8l.toLong))) == (0l));
    assert(solution((List[Long](30l.toLong, 13l.toLong, 23l.toLong, 32l.toLong))) == (23l));
    assert(solution((List[Long](3l.toLong, 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));
    }

}
"
HumanEval_122,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //arr के पहले k तत्वों के अधिकतम दो अंकों वाले तत्वों का योग।    //पूर्णांक arr और पूर्णांक k की एक गैर-खाली सूची दी गई, वापसी     // >>> addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l))
    // (24l)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    def addElements(arr : List[Long], k : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def addElements(arr: List[Long], k: Long): Long = {
    arr.take(k.toInt).filter(x => x >= -99 && x <= 99).sum
  }

  def main(args: Array[String]): Unit = {
    val result = addElements(List[Long](111L, 21L, 3L, 4000L, 5L, 6L, 7L, 8L, 9L), 4L)
    println(result) // Output will be 24L
  }
}","    }
    def main(args: Array[String]) = {
    assert(addElements((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 41l.toLong, 57l.toLong, 76l.toLong, 87l.toLong, 88l.toLong, 99l.toLong)), (3l)) == (-4l));
    assert(addElements((List[Long](111l.toLong, 121l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong)), (2l)) == (0l));
    assert(addElements((List[Long](11l.toLong, 21l.toLong, 3l.toLong, 90l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (125l));
    assert(addElements((List[Long](111l.toLong, 21l.toLong, 3l.toLong, 4000l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong)), (4l)) == (24l));
    assert(addElements((List[Long](1l.toLong)), (1l)) == (1l));
    }

}
"
HumanEval_123,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //get_odd_collatz(5) रिटर्न [1, 5] # 5 के लिए collatz अनुक्रम है [5, 16, 8, 4, 2, 1], तो विषम संख्या केवल 1, और 5 हैं।     //उदाहरण के लिए:     //2. लौटी सूची क्रमशः बढ़ते क्रम में क्रमबद्ध।    //1. Collatz(1) है [1].     //नोटः     //पद प्लस 1. अनुमान यह है कि n का कोई भी मान, अनुक्रम हमेशा 1 तक पहुंच जाएगा।    //पिछले पद. अगर पिछले पद विषम है, अगले पद 3 बार पिछले है     //पिछले पद के रूप में निम्नानुसार: यदि पिछले पद भी है, अगले पद के एक आधा है     //निम्नानुसार: किसी भी धनात्मक पूर्णांक n से प्रारंभ करें। फिर प्रत्येक पद  से प्राप्त होता है।    //कोलाट्ज़ अनुमान गणित में एक अनुमान है जो एक क्रम को परिभाषित करता है।    //एक धनात्मक पूर्णांक n को देखते हुए, एक क्रमबद्ध सूची लौटाएं जिसमें कोलाट्ज़ अनुक्रम में विषम संख्याएं हों।    // >>> getOddCollatz((5l))
    // (List[Long](1l.toLong, 5l.toLong))
    def getOddCollatz(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def getOddCollatz(n: Long): List[Long] = {
    val oddNumbers = ListBuffer[Long]()
    var number = n
    while (number != 1) {
      if (number % 2 == 1) {
        oddNumbers += number
      }
      number = if (number % 2 == 0) number / 2 else 3 * number + 1
    }
    oddNumbers += 1
    oddNumbers.sorted.toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(getOddCollatz((14l)).equals((List[Long](1l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));
    assert(getOddCollatz((5l)).equals((List[Long](1l.toLong, 5l.toLong))));
    assert(getOddCollatz((12l)).equals((List[Long](1l.toLong, 3l.toLong, 5l.toLong))));
    assert(getOddCollatz((1l)).equals((List[Long](1l.toLong))));
    }

}
"
HumanEval_124,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //4. तिथि इस प्रारूप में होनी चाहिए: mm-dd-yyyy     //3. महीने 1 से कम या 12 से अधिक नहीं होने चाहिए।    //2. महीनों 1,3,5,7,8,10,12 के लिए दिनों की संख्या 1 से कम या 31 दिनों से अधिक नहीं है और महीनों 4,6,9,11 के लिए दिनों की संख्या 1 से कम या 30 दिनों से अधिक नहीं है। और, महीने 2 के लिए दिनों की संख्या 1 से कम या 29 से अधिक नहीं है।    //1. दिनांक स्ट्रिंग खाली नहीं है।    //यह तिथि वैध है यदि निम्नलिखित सभी नियम पूरा हों:    //यदि दिनांक मान्य है तो सही लौटाता है अन्यथा गलत।    //आपको एक फ़ंक्शन लिखना है जो किसी दिए गए दिनांक स्ट्रिंग को मान्य करता है और     // >>> validDate((""03-11-2000""))
    // (true)
    // >>> validDate((""15-01-2012""))
    // (false)
    // >>> validDate((""04-0-2040""))
    // (false)
    // >>> validDate((""06-04-2020""))
    // (true)
    // >>> validDate((""06/04/2020""))
    // (false)
    def validDate(date : String) : Boolean = {
","import scala.util.Try

object Problem {
  def validDate(date: String): Boolean = {
    if (date.isEmpty) return false
    
    val datePattern = """"""^(\d{2})-(\d{2})-(\d{4})$"""""".r

    date match {
      case datePattern(monthStr, dayStr, yearStr) => 
        (Try(monthStr.toInt).toOption, Try(dayStr.toInt).toOption) match {
          case (Some(month), Some(day)) if month >= 1 && month <= 12 =>
            month match {
              case 1 | 3 | 5 | 7 | 8 | 10 | 12 => day >= 1 && day <= 31
              case 4 | 6 | 9 | 11 => day >= 1 && day <= 30
              case 2 => day >= 1 && day <= 29
              case _ => false
            }
          case _ => false
        }
      case _ => false
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(validDate((""03-11-2000"")) == (true));
    assert(validDate((""15-01-2012"")) == (false));
    assert(validDate((""04-0-2040"")) == (false));
    assert(validDate((""06-04-2020"")) == (true));
    assert(validDate((""01-01-2007"")) == (true));
    assert(validDate((""03-32-2011"")) == (false));
    assert(validDate(("""")) == (false));
    assert(validDate((""04-31-3000"")) == (false));
    assert(validDate((""06-06-2005"")) == (true));
    assert(validDate((""21-31-2000"")) == (false));
    assert(validDate((""04-12-2003"")) == (true));
    assert(validDate((""04122003"")) == (false));
    assert(validDate((""20030412"")) == (false));
    assert(validDate((""2003-04"")) == (false));
    assert(validDate((""2003-04-12"")) == (false));
    assert(validDate((""04-2003"")) == (false));
    }

}
"
HumanEval_125,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //वर्णमाला, ऑर्ड{""अ"") = 0, ऑर्ड{""बी"") = 1, ... ऑर्ड{""ज़"") = 25     //यदि कोई अल्पविराम मौजूद नहीं है तो आपको  में विषम क्रम के साथ छोटे अक्षरों की संख्या लौटना चाहिए    //शब्दों की एक स्ट्रिंग दी, रिक्त स्थान पर विभाजित शब्दों की एक सूची लौटाएं, यदि कोई रिक्त स्थान पाठ में मौजूद नहीं है तो आप     // >>> splitWords((""Hello world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""Hello,world!""))
    // List[String](""Hello"", ""world!"")
    // >>> splitWords((""abcdef""))
    // 3l
    def splitWords(txt : String) : Either[List[String], Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def splitWords(txt: String): Either[List[String], Long] = {
    if (txt.contains("" "")) {
      Left(txt.split(""\\s+"").toList)
    } else if (txt.contains("","")) {
      Left(txt.split("","").toList)
    } else {
      val oddOrderCount = txt.toCharArray
        .count(c => ('a' to 'z').contains(c) && (c - 'a') % 2 == 0)
      Right(oddOrderCount.toLong)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(splitWords((""Hello world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello,world!"")).equals(List[String](""Hello"", ""world!"")));
    assert(splitWords((""Hello world,!"")).equals(List[String](""Hello"", ""world,!"")));
    assert(splitWords((""Hello,Hello,world !"")).equals(List[String](""Hello,Hello,world"", ""!"")));
    assert(splitWords((""abcdef"")).equals(3l));
    assert(splitWords((""aaabb"")).equals(2l));
    assert(splitWords((""aaaBb"")).equals(1l));
    assert(splitWords(("""")).equals(0l));
    }

}
"
HumanEval_126,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //संख्या, झूठी लौटाता है. कोई नकारात्मक संख्या और केवल पूर्णांक मानें.    //यदि सूची में एक से अधिक दोहरे हैं तो एक ही सूची के दोहरे प्रतियां    //संख्याओं की सूची दी गई है, चाहे वे क्रमबद्ध हों या नहीं।    // >>> isSorted((List[Long](5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)))
    // (false)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong)))
    // (true)
    // >>> isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))
    // (false)
    def isSorted(lst : List[Long]) : Boolean = {
","def isSorted(lst: List[Long]): Boolean = {
    if (lst.isEmpty || lst.length == 1) return true

    var hasDuplicate = false

    for (i <- 1 until lst.length) {
        if (lst(i) < lst(i - 1)) {
            return false
        }
        if (lst(i) == lst(i - 1)) {
            if (hasDuplicate) return false
            hasDuplicate = true
        } else {
            hasDuplicate = false
        }
    }

    true
}","    }
    def main(args: Array[String]) = {
    assert(isSorted((List[Long](5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))) == (false));
    assert(isSorted((List[Long]())) == (true));
    assert(isSorted((List[Long](1l.toLong))) == (true));
    assert(isSorted((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (false));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 4l.toLong))) == (true));
    assert(isSorted((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))) == (true));
    }

}
"
HumanEval_127,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //[इनपुट/आउटपुट] नमूनेः     //यदि दो अंतराल नहीं करते हैं, तो ""नहीं"" लौटाएं।    //अन्यथा, ""नहीं"" लौटाएं।    //यदि चौराहे की लंबाई एक अभाज्य संख्या है, तो ""YES"" लौटाएं,     //जो इसकी लंबाई 1 है, जो एक प्राइम नंबर नहीं है।    //उदाहरण के लिए, अंतराल (1, 3), (2, 4) का चौराहा (2, 3) है।    //अंतराल एक अभाज्य संख्या है।    //आपका कार्य यह निर्धारित करना है कि इन दोनों की चौराहे की लंबाई     //प्रत्येक दिए गए अंतराल के लिए, यह माना जाता है कि इसकी शुरुआत इसके अंत से कम या बराबर है।    //इसमें प्रारंभ और अंत दोनों शामिल हैं।    //दिए गए अंतराल बंद हैं जिसका अर्थ है कि अंतराल (शुरू, अंत)     //जहाँ प्रत्येक अंतराल पूर्णांक का एक जोड़ा है. उदाहरण के लिए, अंतराल = (शुरू, अंत) = (1, 2).    //आपको दो अंतराल दिए गए हैं,     // >>> intersection(((1l, 2l)), ((2l, 3l)))
    // (""NO"")
    // >>> intersection(((-1l, 1l)), ((0l, 4l)))
    // (""NO"")
    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))
    // (""YES"")
    def intersection(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : String = {
","import scala.math._

object Problem {
  def isPrime(n: Long): Boolean = {
    if (n <= 1) return false
    if (n <= 3) return true
    if (n % 2 == 0 || n % 3 == 0) return false
    var i = 5
    while (i * i <= n) {
      if (n % i == 0 || n % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def intersection(interval1: (Long, Long), interval2: (Long, Long)): String = {
    val start = max(interval1._1, interval2._1)
    val end = min(interval1._2, interval2._2)
    if (start > end) return ""NO""

    val length = end - start
    if (isPrime(length)) ""YES"" else ""NO""
  }
}","    }
    def main(args: Array[String]) = {
    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((""NO"")));
    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((""NO"")));
    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((""YES"")));
    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((""YES"")));
    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((""NO"")));
    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((""NO"")));
    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((""NO"")));
    }

}
"
HumanEval_128,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //नोटः रिक्त arr के लिए कोई नहीं लौटाता है.    //सूची में प्रत्येक संख्या का प्रतिनिधित्व 1, -1 या 0 द्वारा किया जाता है।    //पूर्णांक के परिमाणों का योग सभी संकेतों के उत्पाद से गुणा     //आप पूर्णांक की एक सूची arr दिया जाता है और आप वापस करने की जरूरत है     // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong)))
    // Some(9l)
    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))
    // Some(0l)
    // >>> prodSigns((List[Long]()))
    // None
    def prodSigns(arr : List[Long]) : Option[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def prodSigns(arr: List[Long]): Option[Long] = {
    if (arr.isEmpty) return None

    val productOfSigns = arr.foldLeft(1l)((acc, num) => acc * sign(num))
    val sumOfMagnitudes = arr.map(_.abs).sum

    Some(sumOfMagnitudes * productOfSigns)
  }

  private def sign(num: Long): Long = {
    if (num > 0) 1
    else if (num < 0) -1
    else 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(Some(-9l)));
    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(Some(0l)));
    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(Some(-10l)));
    assert(prodSigns((List[Long]())).equals(None));
    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(Some(20l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(Some(4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(Some(-4l)));
    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(Some(0l)));
    }

}
"
HumanEval_129,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //कक्षों पर मानों की एक क्रमबद्ध सूची लौटाता है जिसके माध्यम से न्यूनतम पथ जाता है.    //यह गारंटी है कि उत्तर अद्वितीय है।    //lst_A[j] = lst_B[j]     //इस प्रकार lst_A[i] < lst_B[i] और किसी भी j (1 <= j <i) के लिए हमारे पास     //lst_B से, दूसरे शब्दों में, एक पूर्णांक सूचकांक i (1 <= i <= k)  मौजूद है    //के माध्यम से (चलो उन्हें lst_A और lst_B कहते हैं), lst_A शब्दकोशात्मक रूप से कम है     //आदेशित सूची बनाने के बाद कक्षों पर मानों की जो ए और बी जाते हैं     //एक पथ A (लंबाई k) को पथ B (लंबाई k) से छोटा माना जाता है यदि     //आप ग्रिड से बाहर नहीं जा सकते।    //आवश्यक रूप से अलग) ।    //कृपया ध्यान दें कि लंबाई k का पथ का अर्थ है कि ठीक k कोशिकाओं का दौरा करना (नहीं     //सेल.     //दूसरे शब्दों में, आप कोशिकाओं जो आप वर्तमान के साथ एक किनारे साझा करने के लिए जा सकते हैं     //किसी भी सेल से, और प्रत्येक चरण में आप किसी भी पड़ोसी कोशिकाओं के लिए स्थानांतरित कर सकते हैं,     //आप ग्रिड में लंबाई k की न्यूनतम पथ खोजने के लिए है. आप शुरू कर सकते हैं     //समावेशी ग्रिड के कक्षों पर ठीक एक बार दिखाई देता है।    //ग्रिड के प्रत्येक कक्ष में एक मान होता है. [1, N * N] की सीमा में प्रत्येक पूर्णांक     //एन पंक्तियों और एन स्तंभों (एन >= 2) और एक सकारात्मक पूर्णांक के साथ एक ग्रिड दिया गया है,    // >>> minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l))
    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))
    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l))
    // (List[Long](1l.toLong))
    def minPath(grid : List[List[Long]], k : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def minPath(grid: List[List[Long]], k: Long): List[Long] = {
    val n = grid.length
    val directions = List((0, 1), (1, 0), (0, -1), (-1, 0))

    def isValid(x: Int, y: Int): Boolean = x >= 0 && y >= 0 && x < n && y < n

    def dfs(x: Int, y: Int, path: List[Long]): List[Long] = {
      if (path.length == k) return path
      var minPath: List[Long] = List.fill(k)(Long.MaxValue)
      for ((dx, dy) <- directions) {
        val nx = x + dx
        val ny = y + dy
        if (isValid(nx, ny)) {
          val newPath = dfs(nx, ny, path :+ grid(nx)(ny))
          if (lexCompare(newPath, minPath)) {
            minPath = newPath
          }
        }
      }
      minPath
    }

    def lexCompare(a: List[Long], b: List[Long]): Boolean = {
      a.zip(b).find { case (x, y) => x != y } match {
        case Some((x, y)) => x < y
        case None => false
      }
    }

    var minPathOverall = List.fill(k)(Long.MaxValue)
    for {
      i <- 0 until n
      j <- 0 until n
    } {
      val startingPath = List(grid(i)(j))
      val currentPath = dfs(i, j, startingPath)
      if (lexCompare(currentPath, minPathOverall)) {
        minPathOverall = currentPath
      }
    }
    minPathOverall
  }
}","    }
    def main(args: Array[String]) = {
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong), List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong, 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](8l.toLong, 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong, 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong, 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong, 1l.toLong, 7l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));
    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong, 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong, 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));
    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong), List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong, 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    assert(minPath((List[List[Long]](List[Long](6l.toLong, 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong, 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong))));
    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong), List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_130,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //त्रिबोनाची अनुक्रम के पहले n + 1 संख्याएँ।    //आप एक गैर ऋणात्मक पूर्णांक संख्या n दिया जाता है, आप के लिए एक सूची वापस करने के लिए है     //= 2 + 3 + 3 = 8     //त्रि (३) = त्रि (२) + त्रि (१) + त्रि (४)    //त्रि ((4) = 3     //त्रि ((2) = 1 + (2 / 2) = 2     //उदाहरण के लिए:     //त्रिकुटि (n) = त्रिकुटि (n - 1) + त्रिकुटि (n - 2) + त्रिकुटि (n + 1), यदि n विषम है।    //tri (n) = 1 + n / 2, यदि n सम है।    //त्रि ((1) = 3     //त्रिबोनाची अनुक्रम को पुनरावृत्ति द्वारा परिभाषित किया गया हैः    //हालांकि, क्या लोगों को पता नहीं है Tribonacci अनुक्रम है।    //हर कोई फाइबोनैचि अनुक्रम जानता है, यह गहराई से अध्ययन किया गया था में गणितज्ञों द्वारा     // >>> tri((3l))
    // (List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))
    def tri(n : Long) : List[Long] = {
","import scala.collection.mutable.ListBuffer

object Problem {
  def tri(n: Long): List[Long] = {
    // Initialize list with the first element of the Tribonacci sequence
    val tribonacciSeq = ListBuffer[Long](3)

    // Generate remaining elements up to the nth element
    for (i <- 1L to n) {
      if (i % 2 == 0) {
        // If even, the formula is 1 + n / 2
        tribonacciSeq.append(1 + i / 2)
      } else {
        // If odd, the formula is tri(n - 1) + tri(n - 2) + tri(n + 1)
        // tri(n + 1) is handled as we iterate further
        val tri_i_minus_1 = if (i - 1 >= 0) tribonacciSeq((i - 1).toInt) else 0
        val tri_i_minus_2 = if (i - 2 >= 0) tribonacciSeq((i - 2).toInt) else 0
        val tri_i_plus_1 = if (i + 1 <= n) 1 + (i + 1) / 2 else 0 // calculated as if the next is even
        tribonacciSeq.append(tri_i_minus_1 + tri_i_minus_2 + tri_i_plus_1)
      }
    }

    // Return as a list
    tribonacciSeq.toList
  }

  // Test examples
  def main(args: Array[String]): Unit = {
    println(tri(3)) // List(3, 2, 8)
  }
}","    }
    def main(args: Array[String]) = {
    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));
    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));
    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));
    assert(tri((6l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));
    assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));
    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));
    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong))));
    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));
    assert(tri((0l)).equals((List[Long](1l.toLong))));
    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));
    }

}
"
HumanEval_131,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //यदि सभी अंक सम हों तो 0 लौटाएँ.    //एक धनात्मक पूर्णांक n को देखते हुए, विषम अंकों का गुणनफल लौटाएँ.     // >>> digits((1l))
    // (1l)
    // >>> digits((4l))
    // (0l)
    // >>> digits((235l))
    // (15l)
    def digits(n : Long) : Long = {
","def digits(n: Long): Long = {
    val product = n.toString.map(_.asDigit).filter(_ % 2 != 0).product
    if (product == 1 && n.toString.forall(_.asDigit % 2 == 0)) 0L else product
}","    }
    def main(args: Array[String]) = {
    assert(digits((5l)) == (5l));
    assert(digits((54l)) == (5l));
    assert(digits((120l)) == (1l));
    assert(digits((5014l)) == (5l));
    assert(digits((98765l)) == (315l));
    assert(digits((5576543l)) == (2625l));
    assert(digits((2468l)) == (0l));
    }

}
"
HumanEval_132,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //जहां उपक्रम में कम से कम एक ब्रैकेट नेस्टेड है।    //फ़ंक्शन को true लौटना चाहिए यदि और केवल यदि ब्रैकेट का एक वैध उपक्रम है।    //एक फ़ंक्शन बनाएँ जो इनपुट के रूप में एक स्ट्रिंग लेता है जिसमें केवल वर्ग कोष्ठक होते हैं.    // >>> isNested((""[[]]""))
    // (true)
    // >>> isNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> isNested((""[][]""))
    // (false)
    // >>> isNested((""[]""))
    // (false)
    // >>> isNested((""[[][]]""))
    // (true)
    // >>> isNested((""[[]][[""))
    // (true)
    def isNested(string : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isNested(string: String): Boolean = {
    var stack = new Stack[Char]()
    var nested = false

    for (char <- string) {
      char match {
        case '[' => stack.push(char)
        case ']' =>
          if (stack.nonEmpty) {
            stack.pop()
            if (stack.nonEmpty) {
              nested = true
            }
          }
      }
      if (nested) return true
    }

    false
  }
}","    }
    def main(args: Array[String]) = {
    assert(isNested((""[[]]"")) == (true));
    assert(isNested((""[]]]]]]][[[[[]"")) == (false));
    assert(isNested((""[][]"")) == (false));
    assert(isNested((""[]"")) == (false));
    assert(isNested((""[[[[]]]]"")) == (true));
    assert(isNested((""[]]]]]]]]]]"")) == (false));
    assert(isNested((""[][][[]]"")) == (true));
    assert(isNested((""[[]"")) == (false));
    assert(isNested((""[]]"")) == (false));
    assert(isNested((""[[]][["")) == (true));
    assert(isNested((""[[][]]"")) == (true));
    assert(isNested(("""")) == (false));
    assert(isNested((""[[[[[[[["")) == (false));
    assert(isNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //सूची में प्रत्येक तत्व को पहले ऊपरी int{}सीलिंग तक गोल करें।    //आपको दिए गए सूची में दिए गए संख्याओं के वर्ग का योग लौटना होगा,     //आपको संख्याओं की सूची दी जाती है।    // >>> lst((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)))
    // (14l)
    // >>> lst((List[Float](1.0f.toFloat, 4.0f.toFloat, 9.0f.toFloat)))
    // (98l)
    // >>> lst((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))
    // (84l)
    // >>> lst((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat)))
    // (29l)
    // >>> lst((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat)))
    // (6l)
    def sumSquares(lst : List[Float]) : Long = {
","import scala.math._

object Problem {
  def sumSquares(lst: List[Float]): Long = {
    lst.map(x => ceil(x.toDouble).toLong)
      .map(x => x * x)
      .sum
  }

  // Example usage, you can test the function with the given examples:
  def main(args: Array[String]): Unit = {
    println(sumSquares(List(1.0f, 2.0f, 3.0f))) // Output: 14
    println(sumSquares(List(1.0f, 4.0f, 9.0f))) // Output: 98
    println(sumSquares(List(1.0f, 3.0f, 5.0f, 7.0f))) // Output: 84
    println(sumSquares(List(1.4f, 4.2f, 0.0f))) // Output: 29
    println(sumSquares(List(-2.4f, 1.0f, 1.0f))) // Output: 6
  }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))) == (14l));
    assert(sumSquares((List[Float](1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));
    assert(sumSquares((List[Float](1.4f.toFloat, 4.2f.toFloat, 0.0f.toFloat))) == (29l));
    assert(sumSquares((List[Float](-2.4f.toFloat, 1.0f.toFloat, 1.0f.toFloat))) == (6l));
    assert(sumSquares((List[Float](100.0f.toFloat, 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));
    assert(sumSquares((List[Float](10000.0f.toFloat, 10000.0f.toFloat))) == (200000000l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 4.6f.toFloat, 6.3f.toFloat))) == (75l));
    assert(sumSquares((List[Float](-1.4f.toFloat, 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));
    assert(sumSquares((List[Float](0.0f.toFloat))) == (0l));
    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));
    assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) == (2l));
    }

}
"
HumanEval_134,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //नोटः ""शब्द"" वर्णों का एक समूह है जो रिक्त स्थान से अलग हैं।    //एक शब्द का एक भाग, और अन्यथा गलत।    //किसी दिए गए स्ट्रिंग का एक वर्णमाला वर्ण है और नहीं है     //एक फ़ंक्शन बनाएँ जो अंतिम वर्ण  के लिए true लौटाता है    // >>> checkIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> checkIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> checkIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> checkIfLastCharIsALetter((""""))
    // (false)
    def checkIfLastCharIsALetter(txt : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def checkIfLastCharIsALetter(txt: String): Boolean = {
        if (txt.isEmpty) return false
        val trimmed = txt.trim
        if (trimmed.isEmpty) return false
        val parts = trimmed.split("" "")
        val lastChars = parts.map(_.last)
        if (lastChars.isEmpty) return false
        val lastChar = trimmed.last
        lastChars.contains(lastChar) && lastChar.isLetter
    }
}","    }
    def main(args: Array[String]) = {
    assert(checkIfLastCharIsALetter((""apple"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e"")) == (true));
    assert(checkIfLastCharIsALetter((""eeeee"")) == (false));
    assert(checkIfLastCharIsALetter((""A"")) == (true));
    assert(checkIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    assert(checkIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    assert(checkIfLastCharIsALetter(("""")) == (false));
    assert(checkIfLastCharIsALetter((""eeeee e "")) == (false));
    assert(checkIfLastCharIsALetter((""apple pie"")) == (false));
    assert(checkIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //दोहरे मान।    //ऐसा कोई तत्व मौजूद नहीं है तो वापसी -1. दी गई सूची में शामिल नहीं होगा     //से अधिक या उसके तत्काल पूर्ववर्ती तत्व के बराबर नहीं है। यदि     //एक फ़ंक्शन बनाएँ जो किसी तत्व का सबसे बड़ा सूचकांक लौटाता है जो     // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong)))
    // (3l)
    // >>> canArrange((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))
    // (-1l)
    def canArrange(arr : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._
object Problem {
  def canArrange(arr: List[Long]): Long = {
    for (i <- arr.indices.drop(1)) {
      if (arr(i) < arr(i - 1)) return i.toLong
    }
    -1L
  }
}","    }
    def main(args: Array[String]) = {
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));
    assert(canArrange((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));
    assert(canArrange((List[Long](1l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))) == (2l));
    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong, 7l.toLong, 3l.toLong))) == (4l));
    assert(canArrange((List[Long]())) == (-1l));
    }

}
"
HumanEval_136,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //यदि कोई ऋणात्मक या धनात्मक पूर्णांक नहीं है, तो उन्हें None के रूप में लौटाएं।    //एक सूची में धनात्मक पूर्णांक का।    //सबसे बड़ा नकारात्मक पूर्णांक, और 'बी' सबसे छोटा है     //एक फ़ंक्शन बनाएँ जो एक टपल (a, b) लौटाता है, जहाँ 'a' है     // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))
    // (Some(None), Some(1l))
    // >>> largestSmallestIntegers((List[Long]()))
    // (Some(None), Some(None))
    // >>> largestSmallestIntegers((List[Long](0l.toLong)))
    // (Some(None), Some(None))
    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long], Option[Long]] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def largestSmallestIntegers(lst: List[Long]): Tuple2[Option[Long], Option[Long]] = {
    val negativeIntegers = lst.filter(_ < 0)
    val positiveIntegers = lst.filter(_ > 0)

    val largestNegative = if (negativeIntegers.nonEmpty) Some(negativeIntegers.max) else None
    val smallestPositive = if (positiveIntegers.nonEmpty) Some(positiveIntegers.min) else None

    (largestNegative, smallestPositive)
  }
}","    }
    def main(args: Array[String]) = {
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));
    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));
    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));
    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));
    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, 1l.toLong))).equals((-3l, 1l)));
    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));
    }

}
"
HumanEval_138,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //मूल्यांकन करें कि क्या दी गई संख्या n को ठीक 4 सकारात्मक सम संख्याओं के योग के रूप में लिखा जा सकता है     // >>> isEqualToSumEven((4l))
    // (false)
    // >>> isEqualToSumEven((6l))
    // (false)
    // >>> isEqualToSumEven((8l))
    // (true)
    def isEqualToSumEven(n : Long) : Boolean = {
","def isEqualToSumEven(n: Long): Boolean = {
    // Explanation: A number is the sum of 4 positive even numbers if it is at least 8 and even.
    n >= 8 && n % 2 == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(isEqualToSumEven((4l)) == (false));
    assert(isEqualToSumEven((6l)) == (false));
    assert(isEqualToSumEven((8l)) == (true));
    assert(isEqualToSumEven((10l)) == (true));
    assert(isEqualToSumEven((11l)) == (false));
    assert(isEqualToSumEven((12l)) == (true));
    assert(isEqualToSumEven((13l)) == (false));
    assert(isEqualToSumEven((16l)) == (true));
    }

}
"
HumanEval_139,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //जहां n > 0     //ब्राजीलियाई_फैक्टोरियल (n) = n! * (n-1)! * (n-2)! * ... * 1!     //ब्राजीलियाई कारक को इस प्रकार परिभाषित किया गया है:    // >>> specialFactorial((4l))
    // (288l)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    def specialFactorial(n : Long) : Long = {
","def specialFactorial(n: Long): Long = {
        def factorial(x: Long): Long = {
            if (x == 0 || x == 1) 1L
            else x * factorial(x - 1)
        }

        (1L to n).map(factorial).product
    }
}","    }
    def main(args: Array[String]) = {
    assert(specialFactorial((4l)) == (288l));
    assert(specialFactorial((5l)) == (34560l));
    assert(specialFactorial((7l)) == (125411328000l));
    assert(specialFactorial((1l)) == (1l));
    }

}
"
HumanEval_140,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //फिर सभी लगातार रिक्त स्थानों को -  से बदलें    //और यदि एक स्ट्रिंग में 2 से अधिक लगातार रिक्त स्थान हैं,     //पाठ स्ट्रिंग को देखते हुए, इसमें सभी रिक्त स्थानों को रेखांकित करें,     // >>> fixSpaces(("" Example""))
    // (""Example"")
    // >>> fixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> fixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> fixSpaces(("" Example 3""))
    // (""_Example-3"")
    def fixSpaces(text : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fixSpaces(text: String): String = {
    val result = new StringBuilder()
    var spaceCount = 0
    var leadingSpace = true
    
    for (ch <- text) {
      if (ch == ' ') {
        spaceCount += 1
      } else {
        if (spaceCount > 0) {
          if (leadingSpace && result.isEmpty) {
            result.append('_')
          } else if (spaceCount == 1) {
            result.append('_')
          } else if (spaceCount > 1) {
            result.append('-')
          }
          spaceCount = 0
        }
        result.append(ch)
        leadingSpace = false
      }
    }
    
    if (spaceCount == 1) {
      result.append('_')
    } else if (spaceCount > 1) {
      result.append('-')
    }
    
    result.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(fixSpaces((""Example"")).equals((""Example"")));
    assert(fixSpaces((""Mudasir Hanif "")).equals((""Mudasir_Hanif_"")));
    assert(fixSpaces((""Yellow Yellow  Dirty  Fellow"")).equals((""Yellow_Yellow__Dirty__Fellow"")));
    assert(fixSpaces((""Exa   mple"")).equals((""Exa-mple"")));
    assert(fixSpaces((""   Exa 1 2 2 mple"")).equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //- बिंदु के बाद सबस्ट्रिंग इनमें से एक होना चाहिएः ['txt', 'exe', 'dll']     //लैटिन वर्णमाला ('a'-'z' और 'A'-'Z') ।    //- बिंदु से पहले सबस्ट्रिंग खाली नहीं होना चाहिए, और यह एक पत्र से शुरू होता है     //- फ़ाइल के नाम में ठीक एक बिंदु है '.'     //- फ़ाइल के नाम में तीन से अधिक अंक नहीं होने चाहिए ('0'-'9') ।    //पूरी की जाती हैं:     //किसी फ़ाइल का नाम वैध माना जाता है यदि और केवल यदि निम्नलिखित सभी शर्तें पूरी हों     //यदि फ़ाइल का नाम मान्य है तो 'हाँ' और अन्यथा 'नहीं' देता है।    //एक फ़ंक्शन बनाएँ जो फ़ाइल के नाम का प्रतिनिधित्व करने वाली स्ट्रिंग लेता है, और रिटर्न     // >>> fileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> fileNameCheck((""1example.dll""))
    // (""No"")
    def fileNameCheck(file_name : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def fileNameCheck(file_name: String): String = {
    val validExtensions = Set(""txt"", ""exe"", ""dll"")
    val dotIndex = file_name.lastIndexOf('.')

    if (dotIndex == -1) return ""No""

    val beforeDot = file_name.substring(0, dotIndex)
    val afterDot = file_name.substring(dotIndex + 1)

    if (beforeDot.isEmpty || !beforeDot.head.isLetter) return ""No""

    val digitCount = beforeDot.count(_.isDigit)
    if (digitCount > 3) return ""No""

    if (!validExtensions.contains(afterDot)) return ""No""

    ""Yes""
  }

  def main(args: Array[String]): Unit = {
    println(fileNameCheck(""example.txt"")) // ""Yes""
    println(fileNameCheck(""1example.dll"")) // ""No""
    println(fileNameCheck(""test123.exe"")) // ""Yes""
    println(fileNameCheck("".hidden.txt"")) // ""No""
    println(fileNameCheck(""file..txt"")) // ""No""
  }
}","    }
    def main(args: Array[String]) = {
    assert(fileNameCheck((""example.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""1example.dll"")).equals((""No"")));
    assert(fileNameCheck((""s1sdf3.asd"")).equals((""No"")));
    assert(fileNameCheck((""K.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""MY16FILE3.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""His12FILE94.exe"")).equals((""No"")));
    assert(fileNameCheck((""_Y.txt"")).equals((""No"")));
    assert(fileNameCheck((""?aREYA.exe"")).equals((""No"")));
    assert(fileNameCheck((""/this_is_valid.dll"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.wow"")).equals((""No"")));
    assert(fileNameCheck((""this_is_valid.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""this_is_valid.txtexe"")).equals((""No"")));
    assert(fileNameCheck((""#this2_i4s_5valid.ten"")).equals((""No"")));
    assert(fileNameCheck((""@this1_is6_valid.exe"")).equals((""No"")));
    assert(fileNameCheck((""this_is_12valid.6exe4.txt"")).equals((""No"")));
    assert(fileNameCheck((""all.exe.txt"")).equals((""No"")));
    assert(fileNameCheck((""I563_No.exe"")).equals((""Yes"")));
    assert(fileNameCheck((""Is3youfault.txt"")).equals((""Yes"")));
    assert(fileNameCheck((""no_one#knows.dll"")).equals((""Yes"")));
    assert(fileNameCheck((""1I563_Yes3.exe"")).equals((""No"")));
    assert(fileNameCheck((""I563_Yes3.txtt"")).equals((""No"")));
    assert(fileNameCheck((""final..txt"")).equals((""No"")));
    assert(fileNameCheck((""final132"")).equals((""No"")));
    assert(fileNameCheck((""_f4indsartal132."")).equals((""No"")));
    assert(fileNameCheck(("".txt"")).equals((""No"")));
    assert(fileNameCheck((""s."")).equals((""No"")));
    }

}
"
HumanEval_142,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //सूची में प्रविष्टियों को बदलना जिनकी सूचकांक 3 या 4 का गुणक नहीं है फ़ंक्शन तब सभी प्रविष्टियों का योग लौटाएगा।    //3 का गुणक और पूर्णांक प्रविष्टि को घन करेगा यदि इसका सूचकांक 4 का गुणक है और 3 का गुणक नहीं है।    //यह फलन पूर्णांकों की सूची लेगा. सूची में सभी प्रविष्टियों के लिए, फलन पूर्णांक प्रविष्टि को वर्ग में लाएगा यदि इसका सूचकांक a है।    //""     // >>> lst
    // List[Long](1l.toLong, 2l.toLong, 3l.toLong)
    // >>> lst
    // List[Long]()
    // >>> lst
    // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)
    def sumSquares(lst : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def sumSquares(lst: List[Long]): Long = {
        lst.zipWithIndex.map { case (value, index) =>
            if (index % 3 == 0) {
                value * value
            } else if (index % 4 == 0) {
                value * value * value
            } else {
                value
            }
        }.sum
    }
}","    }
    def main(args: Array[String]) = {
    assert(sumSquares((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (6l));
    assert(sumSquares((List[Long](1l.toLong, 4l.toLong, 9l.toLong))) == (14l));
    assert(sumSquares((List[Long]())) == (0l));
    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));
    assert(sumSquares((List[Long](-1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong))) == (-3l));
    assert(sumSquares((List[Long](0l.toLong))) == (0l));
    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong))) == (-126l));
    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong, 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));
    assert(sumSquares((List[Long](-1l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong))) == (0l));
    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong, 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong, -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));
    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong, -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong, 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong, 4l.toLong, 10l.toLong))) == (-1448l));
    }

}
"
HumanEval_143,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण 1:     //नए स्ट्रिंग में शब्दों का क्रम मूल स्ट्रिंग के समान होना चाहिए।    //जिनकी लंबाई अभाज्य संख्याएँ हैं,     //और आप एक स्ट्रिंग है कि मूल वाक्य से शब्दों को शामिल करता है वापस करने के लिए है,     //वाक्य में कुछ शब्द हैं जो एक स्पेस से अलग हैं,     //आपको एक वाक्य का प्रतिनिधित्व करने वाली एक स्ट्रिंग दी जाती है,     // >>> wordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> wordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    def wordsInSentence(sentence : String) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def isPrime(n: Int): Boolean = {
    if (n < 2) false
    else if (n == 2) true
    else !(2 to sqrt(n).toInt).exists(n % _ == 0)
  }

  def wordsInSentence(sentence: String): String = {
    val words = sentence.split("" "")
    val primeLengthWords = words.filter(word => isPrime(word.length))
    primeLengthWords.mkString("" "")
  }
  
  // Example usage:
  // println(wordsInSentence(""This is a test""))
  // println(wordsInSentence(""lets go for swimming""))
}","    }
    def main(args: Array[String]) = {
    assert(wordsInSentence((""This is a test"")).equals((""is"")));
    assert(wordsInSentence((""lets go for swimming"")).equals((""go for"")));
    assert(wordsInSentence((""there is no place available here"")).equals((""there is no place"")));
    assert(wordsInSentence((""Hi I am Hussein"")).equals((""Hi am Hussein"")));
    assert(wordsInSentence((""go for it"")).equals((""go for it"")));
    assert(wordsInSentence((""here"")).equals(("""")));
    assert(wordsInSentence((""here is"")).equals((""is"")));
    }

}
"
HumanEval_144,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //आप मान सकते हैं कि x, और n मान्य अंश हैं, और शून्य के रूप में भाजक नहीं है।    //<संख्या>/<नाम> जहां संख्या और नाम दोनों धनात्मक पूर्ण संख्याएँ हैं।    //अन्यथा. दोनों x और n, एक अंश का स्ट्रिंग प्रतिनिधित्व है, और निम्न प्रारूप है,     //x * n. फ़ंक्शन सच लौटाता है यदि x * n एक पूर्णांक और झूठी     //आपका कार्य एक फ़ंक्शन को लागू करना है जो अभिव्यक्ति को सरल करेगा     // >>> simplify((""1/5""), (""5/1""))
    // (true)
    // >>> simplify((""1/6""), (""2/1""))
    // (false)
    // >>> simplify((""7/10""), (""10/2""))
    // (false)
    def simplify(x : String, n : String) : Boolean = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def simplify(x: String, n: String): Boolean = {
    def parseFraction(fraction: String): (Int, Int) = {
      val parts = fraction.split(""/"")
      (parts(0).toInt, parts(1).toInt)
    }

    val (numX, denX) = parseFraction(x)
    val (numN, denN) = parseFraction(n)

    val multipliedNumerator = numX * numN
    val multipliedDenominator = denX * denN

    multipliedNumerator % multipliedDenominator == 0
  }
}","    }
    def main(args: Array[String]) = {
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/6""), (""2/1"")) == (false));
    assert(simplify((""5/1""), (""3/1"")) == (true));
    assert(simplify((""7/10""), (""10/2"")) == (false));
    assert(simplify((""2/10""), (""50/10"")) == (true));
    assert(simplify((""7/2""), (""4/2"")) == (true));
    assert(simplify((""11/6""), (""6/1"")) == (true));
    assert(simplify((""2/3""), (""5/2"")) == (false));
    assert(simplify((""5/2""), (""3/5"")) == (false));
    assert(simplify((""2/4""), (""8/4"")) == (true));
    assert(simplify((""2/4""), (""4/2"")) == (true));
    assert(simplify((""1/5""), (""5/1"")) == (true));
    assert(simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //मूल सूची में उनके सूचकांक के आधार पर उन्हें क्रमबद्ध करें।    //नोटः यदि कई आइटम हैं जिनके अंकों का योग समान है, तो     //उनके अंकों के योग के अनुसार आरोही क्रम में।    //एक फ़ंक्शन लिखें जो पूर्णांक की दी गई सूची को क्रमबद्ध करता है     // >>> orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))
    // (List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))
    // >>> orderByPoints((List[Long]()))
    // (List[Long]())
    def orderByPoints(nums : List[Long]) : List[Long] = {
","def orderByPoints(nums: List[Long]): List[Long] = {
    def digitSum(n: Long): Int = n.abs.toString.map(_.asDigit).sum
    
    nums.zipWithIndex
      .sortBy { case (num, index) => (digitSum(num), index) }
      .map(_._1)
  }
}","    }
    def main(args: Array[String]) = {
    assert(orderByPoints((List[Long](1l.toLong, 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong, -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));
    assert(orderByPoints((List[Long](1234l.toLong, 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong, 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong, 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong, 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));
    assert(orderByPoints((List[Long]())).equals((List[Long]())));
    assert(orderByPoints((List[Long](1l.toLong, -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong, -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));
    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));
    assert(orderByPoints((List[Long](0l.toLong, 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong, -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));
    }

}
"
HumanEval_146,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //किसी संख्या के प्रथम और अंतिम अंक विषम हैं (1, 3, 5, 7, 9) ।    //सूची में तत्वों की संख्या जो 10 से अधिक है और दोनों     //एक फ़ंक्शन लिखें जो इनपुट और रिटर्न के रूप में संख्याओं की सूची लेता है।    // >>> specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong)))
    // (1l)
    // >>> specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong)))
    // (2l)
    def specialFilter(nums : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def specialFilter(nums: List[Long]): Long = {
    def isOddDigit(c: Char): Boolean = c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
    
    nums.count { num =>
      val absNumStr = num.abs.toString
      val firstDigit = absNumStr.head
      val lastDigit = absNumStr.last
      
      num > 10 && isOddDigit(firstDigit) && isOddDigit(lastDigit)
    }.toLong
  }

  def main(args: Array[String]): Unit = {
    println(specialFilter(List(15L, -73L, 14L, -15L))) // Output: 1
    println(specialFilter(List(33L, -2L, -3L, 45L, 21L, 109L))) // Output: 2
  }
}","    }
    def main(args: Array[String]) = {
    assert(specialFilter((List[Long](5l.toLong, -2l.toLong, 1l.toLong, -5l.toLong))) == (0l));
    assert(specialFilter((List[Long](15l.toLong, -73l.toLong, 14l.toLong, -15l.toLong))) == (1l));
    assert(specialFilter((List[Long](33l.toLong, -2l.toLong, -3l.toLong, 45l.toLong, 21l.toLong, 109l.toLong))) == (2l));
    assert(specialFilter((List[Long](43l.toLong, -12l.toLong, 93l.toLong, 125l.toLong, 121l.toLong, 109l.toLong))) == (4l));
    assert(specialFilter((List[Long](71l.toLong, -2l.toLong, -33l.toLong, 75l.toLong, 21l.toLong, 19l.toLong))) == (3l));
    assert(specialFilter((List[Long](1l.toLong))) == (0l));
    assert(specialFilter((List[Long]())) == (0l));
    }

}
"
HumanEval_147,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:    //और a[i] + a[j] + a[k] 3 का गुणक है.    //a के तिगुने (a[i], a[j], a[k]) की संख्या लौटाएँ जहाँ i < j < k,     //प्रत्येक i (1 ≤ i ≤ n) के लिए, a[i] = i * i - i + 1 का मान।    //आपको एक धनात्मक पूर्णांक n दिया जाता है. आपको लंबाई n की पूर्णांक सूची a बनाना होगा.    // >>> getMaxTriples((5l))
    // (1l)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    def getMaxTriples(n : Long) : Long = {
","def getMaxTriples(n: Long): Long = {
    val a = (1L to n).map(i => i * i - i + 1).toList
    var count = 0L

    for {
      i <- 0L until n
      j <- i + 1 until n
      k <- j + 1 until n
    } {
      if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) {
        count += 1
      }
    }

    count
  }
}","    }
    def main(args: Array[String]) = {
    assert(getMaxTriples((5l)) == (1l));
    assert(getMaxTriples((6l)) == (4l));
    assert(getMaxTriples((10l)) == (36l));
    assert(getMaxTriples((100l)) == (53361l));
    }

}
"
HumanEval_148,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //सही ग्रह नाम नहीं हैं।    //फ़ंक्शन को एक खाली टपल लौटा देना चाहिए यदि planet1 या planet2     //सूर्य के निकटता।    //ग्रह 1 की कक्षा और ग्रह 2 की कक्षा के बीच स्थित, क्रमबद्ध     //फ़ंक्शन को एक टपल लौटना चाहिए जिसमें सभी ग्रह शामिल हों जिनकी कक्षाएं     //एक फलन लिखिए जो दो ग्रह नामों को स्ट्रिंग्स ग्रह1 और ग्रह2 के रूप में लेता है।    //यूरेनस, नेप्च्यून।    //बुध है, अगले एक शुक्र है, तो पृथ्वी, मंगल, बृहस्पति, शनि,     //हमारे सौर मंडल में आठ ग्रह हैं: सूर्य के सबसे निकटतम।    // >>> bf((""Jupiter""), (""Neptune""))
    // (List[String](""Saturn"", ""Uranus""))
    // >>> bf((""Earth""), (""Mercury""))
    // (List[String](""Venus""))
    // >>> bf((""Mercury""), (""Uranus""))
    // (List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))
    def bf(planet1 : String, planet2 : String) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def bf(planet1: String, planet2: String): List[String] = {
    val planets = List(""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    
    // Find the indices of the given planets
    val index1Opt = planets.indexOf(planet1)
    val index2Opt = planets.indexOf(planet2)
    
    // If either planet is not found, return an empty list
    if (index1Opt == -1 || index2Opt == -1) {
      return List.empty
    }
    
    // Sort indices to ensure proper traversal direction
    val (startIndex, endIndex) = if (index1Opt < index2Opt) (index1Opt, index2Opt) else (index2Opt, index1Opt)
    
    // Get the planets between the indices
    planets.slice(startIndex + 1, endIndex)
  }
}","    }
    def main(args: Array[String]) = {
    assert(bf((""Jupiter""), (""Neptune"")).equals((List[String](""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Mercury"")).equals((List[String](""Venus""))));
    assert(bf((""Mercury""), (""Uranus"")).equals((List[String](""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""))));
    assert(bf((""Neptune""), (""Venus"")).equals((List[String](""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""))));
    assert(bf((""Earth""), (""Earth"")).equals((List[String]())));
    assert(bf((""Mars""), (""Earth"")).equals((List[String]())));
    assert(bf((""Jupiter""), (""Makemake"")).equals((List[String]())));
    }

}
"
HumanEval_149,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //आप मान सकते हैं कि सभी शब्दों की लंबाई समान होगी।    //फ़ंक्शन को क्रमबद्ध क्रम में स्ट्रिंग्स की सूची लौटना चाहिए.    //यदि दो शब्दों की लंबाई समान है, तो सूची को वर्णमाला क्रम में क्रमबद्ध करें।    //इस नियम के अनुसार सूची को क्रमबद्ध करके लौटा देना चाहिए।    //सूची का क्रम प्रत्येक शब्द की लंबाई के अनुसार आरोही होना चाहिए, और आप     //और इसमें डुप्लिकेट हो सकते हैं।    //सूची हमेशा तारों की सूची है और संख्याओं की सूची कभी नहीं,     //और क्रमबद्ध क्रम के साथ परिणामी सूची लौटाता है,     //स्ट्रिंग्स है कि यह से विषम लंबाई है हटा देता है,     //एक फ़ंक्शन लिखें जो स्ट्रिंग्स की सूची को पैरामीटर के रूप में स्वीकार करता है,    // >>> listSort((List[String](""aa"", ""a"", ""aaa"")))
    // (List[String](""aa""))
    // >>> listSort((List[String](""ab"", ""a"", ""aaa"", ""cd"")))
    // (List[String](""ab"", ""cd""))
    def sortedListSum(lst : List[String]) : List[String] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
    def listSort(lst: List[String]): List[String] = {
        lst.filter(_.length % 2 == 0)
           .sorted
           .sortBy(_.length)
    }
}","    }
    def main(args: Array[String]) = {
    assert(sortedListSum((List[String](""aa"", ""a"", ""aaa""))).equals((List[String](""aa""))));
    assert(sortedListSum((List[String](""school"", ""AI"", ""asdf"", ""b""))).equals((List[String](""AI"", ""asdf"", ""school""))));
    assert(sortedListSum((List[String](""d"", ""b"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""d"", ""dcba"", ""abcd"", ""a""))).equals((List[String](""abcd"", ""dcba""))));
    assert(sortedListSum((List[String](""AI"", ""ai"", ""au""))).equals((List[String](""AI"", ""ai"", ""au""))));
    assert(sortedListSum((List[String](""a"", ""b"", ""b"", ""c"", ""c"", ""a""))).equals((List[String]())));
    assert(sortedListSum((List[String](""aaaa"", ""bbbb"", ""dd"", ""cc""))).equals((List[String](""cc"", ""dd"", ""aaaa"", ""bbbb""))));
    }

}
"
HumanEval_150,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //एक अभाज्य संख्या है और y के मान को लौटाता है अन्यथा.    //एक सरल प्रोग्राम जो x का मान लौटाता है यदि n  है    // >>> xOrY((7l), (34l), (12l))
    // (34l)
    // >>> xOrY((15l), (8l), (5l))
    // (5l)
    def xOrY(n : Long, x : Long, y : Long) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  
  def isPrime(num: Long): Boolean = {
    if (num <= 1) return false
    if (num <= 3) return true
    if (num % 2 == 0 || num % 3 == 0) return false
    var i = 5
    while (i * i <= num) {
      if (num % i == 0 || num % (i + 2) == 0) return false
      i += 6
    }
    true
  }

  def xOrY(n: Long, x: Long, y: Long): Long = {
    if (isPrime(n)) x else y
  }
}","    }
    def main(args: Array[String]) = {
    assert(xOrY((7l), (34l), (12l)) == (34l));
    assert(xOrY((15l), (8l), (5l)) == (5l));
    assert(xOrY((3l), (33l), (5212l)) == (33l));
    assert(xOrY((1259l), (3l), (52l)) == (3l));
    assert(xOrY((7919l), (-1l), (12l)) == (-1l));
    assert(xOrY((3609l), (1245l), (583l)) == (583l));
    assert(xOrY((91l), (56l), (129l)) == (129l));
    assert(xOrY((6l), (34l), (1234l)) == (1234l));
    assert(xOrY((1l), (2l), (0l)) == (0l));
    assert(xOrY((2l), (2l), (0l)) == (2l));
    }

}
"
HumanEval_151,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //सूची में जो विषम हैं. संख्याओं है कि नकारात्मक हैं या पूर्णांक नहीं हैं की अनदेखी करें.    //संख्याओं की सूची दी गई, संख्याओं के वर्गों का योग लौटाएं     // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))
    // (10l)
    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong, 0l.toLong)))
    // (0l)
    // >>> doubleTheDifference((List[Float](9l.toLong, -2l.toLong)))
    // (81l)
    // >>> doubleTheDifference((List[Float](0l.toLong)))
    // (0l)
    // If the input list is empty, return 0.
    def doubleTheDifference(lst : List[Float]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doubleTheDifference(lst: List[Float]): Long = {
    lst.filter(x => x > 0 && x.isValidLong && x.toLong % 2 != 0)
      .map(x => x.toLong * x.toLong)
      .sum
  }
}","    }
    def main(args: Array[String]) = {
    assert(doubleTheDifference((List[Float]())) == (0l));
    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat))) == (25l));
    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat, 0.3f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-10.0f.toFloat, -20.0f.toFloat, -30.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](-1.0f.toFloat, -2.0f.toFloat, 8.0f.toFloat))) == (0l));
    assert(doubleTheDifference((List[Float](0.2f.toFloat, 3.0f.toFloat, 5.0f.toFloat))) == (34l));
    assert(doubleTheDifference((List[Float](-9.0f.toFloat, -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));
    }

}
"
HumanEval_152,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //मान 0 है और यदि नहीं, तो मान अनुमान और स्कोर के बीच पूर्ण अंतर है।    //एक ही लंबाई की सूची लौटाएं जो प्रत्येक अनुमान को कितनी दूर दर्शाता है। यदि उन्होंने सही अनुमान लगाया है, तो     //आपको समान लंबाई की दो सूचियाँ दी जाती हैं, जहाँ प्रत्येक सूचकांक एक मैच दिखाता है।    //आपका कार्य यह निर्धारित करना है कि क्या किसी व्यक्ति ने सही ढंग से कई मैचों के परिणामों का अनुमान लगाया है।    //निश्चित रूप से ध्यान देने योग्य और तुलना करने योग्य।    //इस घटना के बारे में अंततः पता चल जाता है।    //मुझे लगता है कि हम सभी को वह एहसास याद है जब कुछ लंबे समय से प्रतीक्षित परिणाम    // >>> compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong)))
    // (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))
    // >>> compare((List[Long](0l.toLong, 5l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 4l.toLong)), (List[Long](4l.toLong, 1l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, -2l.toLong)))
    // (List[Long](4l.toLong, 4l.toLong, 1l.toLong, 0l.toLong, 0l.toLong, 6l.toLong))
    def compare(game : List[Long], guess : List[Long]) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def compare(game: List[Long], guess: List[Long]): List[Long] = {
    game.zip(guess).map { case (g, gs) => abs(g - gs) }
  }
}","    }
    def main(args: Array[String]) = {
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));
    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));
    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));
    }

}
"
HumanEval_153,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //(इसकी ताकत -1 है) ।    //'Slices.SERVINGSliCes' लौटाएं क्योंकि 'SERVINGSliCes' सबसे मजबूत एक्सटेंशन है।    //विस्तारः ['सेर्विंग्स','चीज़', 'स्टूफ़ेड'] तो आपको चाहिए     //उदाहरण के लिए, यदि आप वर्ग के रूप में ""स्लाइस"" और  की एक सूची दी जाती है    //सूची में पहले आने वाले को चुनें।    //यदि दो या अधिक एक्सटेंशन एक ही शक्ति के साथ हैं, तो आपको चाहिए    //स्वरूपः ClassName.StrongestExtensionName.     //आपको सबसे मजबूत एक्सटेंशन ढूंढना चाहिए और इसमें एक स्ट्रिंग लौटना चाहिए     //विस्तार के नाम में, शक्ति को CAP-SM अंश द्वारा दिया जाता है।    //एक्सटेंशन के नाम में अक्षरों, और SM लघु अक्षरों की संख्या हो     //विस्तार की शक्ति निम्नानुसार हैः CAP को अपरकेस की संख्या मानें     //एक्सटेंशन का उपयोग वर्ग के अतिरिक्त वर्गों को लोड करने के लिए किया जाना है।    //आपको एक वर्ग का नाम (एक स्ट्रिंग) और एक्सटेंशन की एक सूची दी जाएगी।    // >>> StrongestExtension((""my_class""), (List[String](""AA"", ""Be"", ""CC"")))
    // (""my_class.AA"")
    def StrongestExtension(class_name : String, extensions : List[String]) : String = {
","def StrongestExtension(class_name: String, extensions: List[String]): String = {
        extensions.map { extension =>
            val capCount = extension.count(_.isUpper)
            val lowerCount = extension.count(_.isLower)
            val strength = capCount - lowerCount
            (extension, strength)
        }.maxBy(_._2)._1
    } match {
        case strongest => s""$class_name.$strongest""
    }
}","    }
    def main(args: Array[String]) = {
    assert(StrongestExtension((""Watashi""), (List[String](""tEN"", ""niNE"", ""eIGHt8OKe""))).equals((""Watashi.eIGHt8OKe"")));
    assert(StrongestExtension((""Boku123""), (List[String](""nani"", ""NazeDa"", ""YEs.WeCaNe"", ""32145tggg""))).equals((""Boku123.YEs.WeCaNe"")));
    assert(StrongestExtension((""__YESIMHERE""), (List[String](""t"", ""eMptY"", ""nothing"", ""zeR00"", ""NuLl__"", ""123NoooneB321""))).equals((""__YESIMHERE.NuLl__"")));
    assert(StrongestExtension((""K""), (List[String](""Ta"", ""TAR"", ""t234An"", ""cosSo""))).equals((""K.TAR"")));
    assert(StrongestExtension((""__HAHA""), (List[String](""Tab"", ""123"", ""781345"", ""-_-""))).equals((""__HAHA.123"")));
    assert(StrongestExtension((""YameRore""), (List[String](""HhAas"", ""okIWILL123"", ""WorkOut"", ""Fails"", ""-_-""))).equals((""YameRore.okIWILL123"")));
    assert(StrongestExtension((""finNNalLLly""), (List[String](""Die"", ""NowW"", ""Wow"", ""WoW""))).equals((""finNNalLLly.WoW"")));
    assert(StrongestExtension((""_""), (List[String](""Bb"", ""91245""))).equals((""_.Bb"")));
    assert(StrongestExtension((""Sp""), (List[String](""671235"", ""Bb""))).equals((""Sp.671235"")));
    }

}
"
HumanEval_154,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //आप 2 शब्द दिए गए हैं. आप सच लौटने की जरूरत है अगर दूसरे शब्द या उसके रोटेशन के किसी भी पहले शब्द में एक सबस्ट्रिंग है     // >>> cycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> cycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> cycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> cycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> cycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> cycpatternCheck((""himenss""), (""simen""))
    // (true)
    def cycpatternCheck(a : String, b : String) : Boolean = {
","def cycpatternCheck(a: String, b: String): Boolean = {
  val bLength = b.length
  val bDouble = b + b // Create a string with b concatenated with itself to represent all rotations
  for (i <- 0 until bLength) {
    val rotation = bDouble.substring(i, i + bLength) // Get the current rotation
    if (a.contains(rotation)) return true
  }
  false
}","    }
    def main(args: Array[String]) = {
    assert(cycpatternCheck((""xyzw""), (""xyw"")) == (false));
    assert(cycpatternCheck((""yello""), (""ell"")) == (true));
    assert(cycpatternCheck((""whattup""), (""ptut"")) == (false));
    assert(cycpatternCheck((""efef""), (""fee"")) == (true));
    assert(cycpatternCheck((""abab""), (""aabb"")) == (false));
    assert(cycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //एक पूर्णांक दिया गया है. एक टपल लौटाएं जिसमें क्रमशः सम और विषम अंकों की संख्या है.     // >>> evenOddCount((-12l))
    // ((1l, 1l))
    // >>> evenOddCount((123l))
    // ((1l, 2l))
    def evenOddCount(num : Long) : Tuple2[Long, Long] = {
","def evenOddCount(num: Long): Tuple2[Long, Long] = {
  val digits = num.abs.toString.map(_.asDigit)
  val evenCount = digits.count(_ % 2 == 0).toLong
  val oddCount = digits.count(_ % 2 != 0).toLong
  (evenCount, oddCount)
}","    }
    def main(args: Array[String]) = {
    assert(evenOddCount((7l)).equals(((0l, 1l))));
    assert(evenOddCount((-78l)).equals(((1l, 1l))));
    assert(evenOddCount((3452l)).equals(((2l, 2l))));
    assert(evenOddCount((346211l)).equals(((3l, 3l))));
    assert(evenOddCount((-345821l)).equals(((3l, 3l))));
    assert(evenOddCount((-2l)).equals(((1l, 0l))));
    assert(evenOddCount((-45347l)).equals(((2l, 3l))));
    assert(evenOddCount((0l)).equals(((1l, 0l))));
    }

}
"
HumanEval_156,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //प्रतिबंधः 1 <= संख्या <= 1000     //और इसे छोटे अक्षरों में लौटाएं।    //एक धनात्मक पूर्णांक दिया गया है, एक स्ट्रिंग के रूप में इसके रोमन अंक समकक्ष प्राप्त करें,     // >>> intToMiniRoman((19l))
    // (""xix"")
    // >>> intToMiniRoman((152l))
    // (""clii"")
    // >>> intToMiniRoman((426l))
    // (""cdxxvi"")
    def intToMiniRoman(number : Long) : String = {
","import scala.collection.mutable._

object Problem {
  def intToMiniRoman(number: Long): String = {
    val romanMap: List[(Int, String)] = List(
      (1000, ""m""),
      (900, ""cm""),
      (500, ""d""),
      (400, ""cd""),
      (100, ""c""),
      (90, ""xc""),
      (50, ""l""),
      (40, ""xl""),
      (10, ""x""),
      (9, ""ix""),
      (5, ""v""),
      (4, ""iv""),
      (1, ""i"")
    )

    var num = number.toInt
    val stringBuilder = new StringBuilder

    for ((value, roman) <- romanMap) {
      while (num >= value) {
        stringBuilder.append(roman)
        num -= value
      }
    }

    stringBuilder.toString()
  }
}","    }
    def main(args: Array[String]) = {
    assert(intToMiniRoman((19l)).equals((""xix"")));
    assert(intToMiniRoman((152l)).equals((""clii"")));
    assert(intToMiniRoman((251l)).equals((""ccli"")));
    assert(intToMiniRoman((426l)).equals((""cdxxvi"")));
    assert(intToMiniRoman((500l)).equals((""d"")));
    assert(intToMiniRoman((1l)).equals((""i"")));
    assert(intToMiniRoman((4l)).equals((""iv"")));
    assert(intToMiniRoman((43l)).equals((""xliii"")));
    assert(intToMiniRoman((90l)).equals((""xc"")));
    assert(intToMiniRoman((94l)).equals((""xciv"")));
    assert(intToMiniRoman((532l)).equals((""dxxxii"")));
    assert(intToMiniRoman((900l)).equals((""cm"")));
    assert(intToMiniRoman((994l)).equals((""cmxciv"")));
    assert(intToMiniRoman((1000l)).equals((""m"")));
    }

}
"
HumanEval_157,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //90 डिग्री।    //एक समकोण त्रिभुज एक त्रिभुज है जिसमें एक कोण समकोण है या     //पक्षों से एक समकोण त्रिभुज बनता है, अन्यथा गलत।    //एक त्रिकोण के तीन पक्षों की लंबाई को देखते हुए। सही लौटाएं यदि तीन     // >>> rightAngleTriangle((3l), (4l), (5l))
    // (true)
    // >>> rightAngleTriangle((1l), (2l), (3l))
    // (false)
    def rightAngleTriangle(a : Long, b : Long, c : Long) : Boolean = {
","def rightAngleTriangle(a: Long, b: Long, c: Long): Boolean = {
        val sides = List(a, b, c).sorted
        pow(sides(0), 2) + pow(sides(1), 2) == pow(sides(2), 2)
    }
}","    }
    def main(args: Array[String]) = {
    assert(rightAngleTriangle((3l), (4l), (5l)) == (true));
    assert(rightAngleTriangle((1l), (2l), (3l)) == (false));
    assert(rightAngleTriangle((10l), (6l), (8l)) == (true));
    assert(rightAngleTriangle((2l), (2l), (2l)) == (false));
    assert(rightAngleTriangle((7l), (24l), (25l)) == (true));
    assert(rightAngleTriangle((10l), (5l), (7l)) == (false));
    assert(rightAngleTriangle((5l), (12l), (13l)) == (true));
    assert(rightAngleTriangle((15l), (8l), (17l)) == (true));
    assert(rightAngleTriangle((48l), (55l), (73l)) == (true));
    assert(rightAngleTriangle((1l), (1l), (1l)) == (false));
    assert(rightAngleTriangle((2l), (2l), (10l)) == (false));
    }

}
"
HumanEval_158,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //अक्षरों में, जो पहले शब्दकोश क्रम में आता है उसे लौटाएं।    //यदि एकाधिक तारों में अद्वितीय  की अधिकतम संख्या है    //सूची में विभिन्न शब्द हैं. अधिकतम संख्या के साथ शब्द लौटाएं     //एक फ़ंक्शन लिखें जो स्ट्रिंग्स की सूची को स्वीकार करता है.    // >>> findMax((List[String](""name"", ""of"", ""string"")))
    // (""string"")
    // >>> findMax((List[String](""name"", ""enam"", ""game"")))
    // (""enam"")
    // >>> findMax((List[String](""aaaaaaa"", ""bb"", ""cc"")))
    // (""aaaaaaa"")
    def findMax(words : List[String]) : String = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def findMax(words: List[String]): String = {
    words.maxBy(word => (word.toSet.size, -word.toLowerCase))
  }
}","    }
    def main(args: Array[String]) = {
    assert(findMax((List[String](""name"", ""of"", ""string""))).equals((""string"")));
    assert(findMax((List[String](""name"", ""enam"", ""game""))).equals((""enam"")));
    assert(findMax((List[String](""aaaaaaa"", ""bb"", ""cc""))).equals((""aaaaaaa"")));
    assert(findMax((List[String](""abc"", ""cba""))).equals((""abc"")));
    assert(findMax((List[String](""play"", ""this"", ""game"", ""of"", ""footbott""))).equals((""footbott"")));
    assert(findMax((List[String](""we"", ""are"", ""gonna"", ""rock""))).equals((""gonna"")));
    assert(findMax((List[String](""we"", ""are"", ""a"", ""mad"", ""nation""))).equals((""nation"")));
    assert(findMax((List[String](""this"", ""is"", ""a"", ""prrk""))).equals((""this"")));
    assert(findMax((List[String](""b""))).equals((""b"")));
    assert(findMax((List[String](""play"", ""play"", ""play""))).equals((""play"")));
    }

}
"
HumanEval_159,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण:     //यदि पर्याप्त गाजर नहीं बचे हैं, तो आप सभी गाजर खा लेंगे, लेकिन फिर भी भूखे रहेंगे।    //आपके भोजन के बाद बचे हुए गाजर की संख्या]     //आपको एक सूची लौटना चाहिए [ भोजन के बाद खाए गए गाजर की कुल संख्या,     //लेकिन अब आपको दिन के भोजन को पूरा करने के लिए और गाजर खाने की जरूरत है।    //आप एक भूखे खरगोश हैं, और आप पहले से ही गाजर की एक निश्चित संख्या खा लिया है,     // >>> eat((5l), (6l), (10l))
    // (List[Long](11l.toLong, 4l.toLong))
    // >>> eat((4l), (8l), (9l))
    // (List[Long](12l.toLong, 1l.toLong))
    // >>> eat((1l), (10l), (10l))
    // (List[Long](11l.toLong, 0l.toLong))
    // >>> eat((2l), (11l), (5l))
    // (List[Long](7l.toLong, 0l.toLong))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    def eat(number : Long, need : Long, remaining : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def eat(number: Long, need: Long, remaining: Long): List[Long] = {
    val totalNeeded = number + need
    if (remaining >= need) {
      List(totalNeeded, remaining - need)
    } else {
      List(number + remaining, 0)
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));
    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));
    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));
    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));
    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));
    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));
    }

}
"
HumanEval_160,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //ऑपरेटर सूची में कम से कम एक ऑपरेटर होता है और ऑपरेन्ड सूची में कम से कम दो ऑपरेन्ड होते हैं।    //ऑपरेन्ड गैर-ऋणात्मक पूर्णांक की सूची है।    //ऑपरेटर सूची की लंबाई ऑपरेन्ड सूची की लंबाई शून्य से एक के बराबर है।    //नोटः     //=> परिणाम = 9     //परिणाम = 2 + 3 * 4 - 5     //सूची = [2, 3, 4, 5]     //ऑपरेटर['+', '*', '-']     //उदाहरण:     //एक्सपोनेंशिएशन (**)    //मंजिल विभाजन ( // )     //गुणा (*)     //घटाना (- )     //जोड़ (+)     //मूल बीजगणित परिचालनः     //अभिव्यक्ति और इस अभिव्यक्ति का मूल्यांकन लौटाएं।    //दूसरी सूची पूर्णांक की सूची है. बीजगणित बनाने के लिए दी गई दो सूचियों का उपयोग करें     //दो सूची ऑपरेटर और संक्रियापद दी गई है। पहली सूची में मूल बीजगणित संचालन हैं, और     def doAlgebra(op : List[String], operand : List[Long]) : Long = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def doAlgebra(op: List[String], operand: List[Long]): Long = {
    var result = operand.head
    for (i <- 0 until op.length) {
      op(i) match {
        case ""+"" => result += operand(i + 1)
        case ""-"" => result -= operand(i + 1)
        case ""*"" => result *= operand(i + 1)
        case ""//"" => result /= operand(i + 1)
        case ""**"" => result = pow(result.toDouble, operand(i + 1).toDouble).toLong
      }
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val operators = List(""+"", ""*"", ""-"")
    val operands = List(2L, 3L, 4L, 5L)
    println(doAlgebra(operators, operands)) // Output: 9
  }
}","    }
    def main(args: Array[String]) = {
    assert(doAlgebra((List[String](""**"", ""*"", ""+"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));
    assert(doAlgebra((List[String](""+"", ""*"", ""-"")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));
    assert(doAlgebra((List[String](""//"", ""*"")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));
    }

}
"
HumanEval_161,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण     //फ़ंक्शन को परिणामी स्ट्रिंग लौटना चाहिए.    //यदि स्ट्रिंग में कोई अक्षर नहीं है, तो स्ट्रिंग को उल्टा करें.    //अन्यथा इसे इस तरह ही रखें।    //यदि s[i] एक अक्षर है, तो इसके केस को निचले से ऊपरी या इसके विपरीत करें,     //आपको एक स्ट्रिंग s दी जाती है.    // >>> solve((""1234""))
    // (""4321"")
    // >>> solve((""ab""))
    // (""AB"")
    // >>> solve((""#a@C""))
    // (""#A@c"")
    def solve(s : String) : String = {
","def solve(s: String): String = {
    if (s.exists(_.isLetter)) {
      s.map {
        case c if c.isLetter && c.isLower => c.toUpper
        case c if c.isLetter && c.isUpper => c.toLower
        case c => c
      }.mkString
    } else {
      s.reverse
    }
  }
}","    }
    def main(args: Array[String]) = {
    assert(solve((""AsDf"")).equals((""aSdF"")));
    assert(solve((""1234"")).equals((""4321"")));
    assert(solve((""ab"")).equals((""AB"")));
    assert(solve((""#a@C"")).equals((""#A@c"")));
    assert(solve((""#AsdfW^45"")).equals((""#aSDFw^45"")));
    assert(solve((""#6@2"")).equals((""2@6#"")));
    assert(solve((""#$a^D"")).equals((""#$A^d"")));
    assert(solve((""#ccc"")).equals((""#CCC"")));
    }

}
"
HumanEval_162,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //यदि 'text' एक खाली स्ट्रिंग है, तो None लौटाएं.    //एक स्ट्रिंग 'text' को देखते हुए, इसके md5 हैश समकक्ष स्ट्रिंग को लौटाएं।    // >>> stringToMd5((""Hello world""))
    // Some(""3e25960a79dbc69b674cd4ec67a72c62"")
    def stringToMd5(text : String) : Option[String] = {
","import java.security.MessageDigest

object Problem {
  def stringToMd5(text: String): Option[String] = {
    if (text.isEmpty) None
    else {
      val md = MessageDigest.getInstance(""MD5"")
      val digest = md.digest(text.getBytes)
      Some(digest.map(""%02x"".format(_)).mkString)
    }
  }
}

// Example usage:
// println(Problem.stringToMd5(""Hello world""))  // Output: Some(""3e25960a79dbc69b674cd4ec67a72c62"")","    }
    def main(args: Array[String]) = {
    assert(stringToMd5((""Hello world"")).equals(Some(""3e25960a79dbc69b674cd4ec67a72c62"")));
    assert(stringToMd5(("""")).equals(None));
    assert(stringToMd5((""A B C"")).equals(Some(""0ef78513b0cb8cef12743f5aeb35f888"")));
    assert(stringToMd5((""password"")).equals(Some(""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,hin_Deva,scala,"import scala.math._
import scala.collection.mutable._
object Problem {
    //उदाहरण के लिए:     //और b, क्रमशः बढ़ते क्रम में।    //दो सकारात्मक पूर्णांक a और b दिए गए हैं, a और b के बीच सम अंक लौटाएँ    // >>> generateIntegers((2l), (8l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((8l), (2l))
    // (List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))
    // >>> generateIntegers((10l), (14l))
    // (List[Long]())
    def generateIntegers(a : Long, b : Long) : List[Long] = {
","import scala.math._
import scala.collection.mutable._

object Problem {
  def generateIntegers(a: Long, b: Long): List[Long] = {
    val start = min(a, b)
    val end = max(a, b)
    val evenNumbers = for (i <- start to end if i % 2 == 0) yield i
    evenNumbers.map(_.toLong).toList
  }
}","    }
    def main(args: Array[String]) = {
    assert(generateIntegers((2l), (10l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((10l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((132l), (2l)).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong))));
    assert(generateIntegers((17l), (89l)).equals((List[Long]())));
    }

}
"
