[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ki\u1ec3m tra xem trong danh s\u00e1ch c\u00e1c s\u1ed1 \u0111\u00e3 cho, c\u00f3 hai s\u1ed1 n\u00e0o g\u1ea7n nhau h\u01a1n ng\u01b0\u1ee1ng \u0111\u00e3 cho hay kh\u00f4ng. V\u00ed d\u1ee5:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" L\u1ec7nh nh\u1eadp c\u1ee7a h\u00e0m n\u00e0y l\u00e0 m\u1ed9t chu\u1ed7i ch\u1ee9a nhi\u1ec1u nh\u00f3m d\u1ea5u ngo\u1eb7c v\u1ecb. M\u1ee5c ti\u00eau c\u1ee7a b\u1ea1n l\u00e0 t\u00e1ch c\u00e1c nh\u00f3m \u0111\u00f3 th\u00e0nh c\u00e1c chu\u1ed7i ri\u00eang bi\u1ec7t v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c chu\u1ed7i \u0111\u00f3. C\u00e1c nh\u00f3m ri\u00eang bi\u1ec7t \u0111\u01b0\u1ee3c c\u00e2n b\u1eb1ng (m\u1ed7i d\u1ea5u ngo\u1eb7c v\u1ecb m\u1edf \u0111\u01b0\u1ee3c \u0111\u00f3ng \u0111\u00fang c\u00e1ch) v\u00e0 kh\u00f4ng \u0111\u01b0\u1ee3c l\u1ed3ng nhau trong m\u1ed7i m\u1ed9t. B\u1ecf qua b\u1ea5t k\u1ef3 kho\u1ea3ng tr\u1ed1ng n\u00e0o trong chu\u1ed7i \u0111\u1ea7u v\u00e0o. V\u00ed d\u1ee5:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Cho m\u1ed9t s\u1ed1 \u0111i\u1ec3m tr\u00f4i d\u01b0\u01a1ng, n\u00f3 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c ph\u00e2n h\u1ee7y th\u00e0nh ph\u1ea7n nguy\u00ean v\u00e0 ph\u1ea7n s\u1ed1 nguy\u00ean l\u1edbn nh\u1ea5t nh\u1ecf h\u01a1n s\u1ed1 \u0111\u00e3 cho) v\u00e0 s\u1ed1 th\u1eadp ph\u00e2n (ph\u1ea7n c\u00f2n l\u1ea1i lu\u00f4n nh\u1ecf h\u01a1n 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" B\u1ea1n \u0111\u01b0\u1ee3c \u0111\u01b0a ra m\u1ed9t danh s\u00e1ch c\u00e1c ho\u1ea1t \u0111\u1ed9ng g\u1eedi v\u00e0 r\u00fat ti\u1ec1n tr\u00ean t\u00e0i kho\u1ea3n ng\u00e2n h\u00e0ng b\u1eaft \u0111\u1ea7u v\u1edbi s\u1ed1 d\u01b0 b\u1eb1ng 0. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 ph\u00e1t hi\u1ec7n n\u1ebfu t\u1ea1i b\u1ea5t k\u1ef3 th\u1eddi \u0111i\u1ec3m n\u00e0o s\u1ed1 d\u01b0 t\u00e0i kho\u1ea3n gi\u1ea3m xu\u1ed1ng d\u01b0\u1edbi 0, v\u00e0 t\u1ea1i th\u1eddi \u0111i\u1ec3m \u0111\u00f3 h\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 True. N\u1ebfu kh\u00f4ng, n\u00f3 s\u1ebd tr\u1ea3 v\u1ec1 False. V\u00ed d\u1ee5:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 \u0111\u1ea7u v\u00e0o, t\u00ednh to\u00e1n Ph\u00e2n sai tuy\u1ec7t \u0111\u1ed1i trung b\u00ecnh xung quanh trung b\u00ecnh c\u1ee7a b\u1ed9 d\u1eef li\u1ec7u n\u00e0y. Ph\u00e2n sai tuy\u1ec7t \u0111\u1ed1i trung b\u00ecnh l\u00e0 s\u1ef1 kh\u00e1c bi\u1ec7t tuy\u1ec7t \u0111\u1ed1i trung b\u00ecnh gi\u1eefa m\u1ed7i y\u1ebfu t\u1ed1 v\u00e0 m\u1ed9t \u0111i\u1ec3m trung t\u00e2m (trong tr\u01b0\u1eddng h\u1ee3p n\u00e0y l\u00e0 trung b\u00ecnh): MAD = trung b\u00ecnh. x - x_mean. V\u00ed d\u1ee5:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Ch\u00e8n m\u1ed9t s\u1ed1 \"\u0111\u1ecbnh gi\u1edbi h\u1ea1n\" gi\u1eefa m\u1ed7i hai ph\u1ea7n t\u1eed li\u00ean ti\u1ebfp c\u1ee7a danh s\u00e1ch \u0111\u1ea7u v\u00e0o `s\u1ed1'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" L\u1ec7nh \u0111\u1ea7u v\u00e0o c\u1ee7a h\u00e0m n\u00e0y l\u00e0 m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho nhi\u1ec1u nh\u00f3m cho c\u00e1c d\u1ea5u ngo\u1eb7c v\u1ecb \u0111\u01b0\u1ee3c t\u00e1ch ra b\u1edfi c\u00e1c kho\u1ea3ng tr\u1ed1ng. \u0110\u1ed1i v\u1edbi m\u1ed7i nh\u00f3m, h\u00e3y \u0111\u1ea7u ra m\u1ee9c \u0111\u1ed9 l\u1ed3ng gh\u00e9p s\u00e2u nh\u1ea5t c\u1ee7a c\u00e1c d\u1ea5u ngo\u1eb7c v\u1ecb. V\u00ed d\u1ee5: (() (()) c\u00f3 t\u1ed1i \u0111a hai c\u1ea5p \u0111\u1ed9 l\u1ed3ng gh\u00e9p trong khi ((())) c\u00f3 ba.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" B\u1ed9 l\u1ecdc danh s\u00e1ch \u0111\u1ea7u v\u00e0o c\u1ee7a chu\u1ed7i ch\u1ec9 cho nh\u1eefng ng\u01b0\u1eddi c\u00f3 ch\u1ee9a substring cho\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean, tr\u1ea3 v\u1ec1 m\u1ed9t tuple bao g\u1ed3m t\u1ed5ng v\u00e0 s\u1ea3n ph\u1ea9m c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c s\u1ed1 nguy\u00ean trong danh s\u00e1ch. T\u1ed5ng r\u1ed7ng ph\u1ea3i b\u1eb1ng 0 v\u00e0 s\u1ea3n ph\u1ea9m r\u1ed7ng ph\u1ea3i b\u1eb1ng 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" T\u1eeb m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean \u0111\u00e3 cho, t\u1ea1o ra m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n t\u1eed t\u1ed1i \u0111a l\u0103n \u0111\u01b0\u1ee3c t\u00ecm th\u1ea5y cho \u0111\u1ebfn th\u1eddi \u0111i\u1ec3m nh\u1ea5t \u0111\u1ecbnh trong chu\u1ed7i.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Ki\u1ec3m tra n\u1ebfu chu\u1ed7i \u0111\u01b0\u1ee3c cho l\u00e0 palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" \u0110\u1ea7u v\u00e0o l\u00e0 hai chu\u1ed7i a v\u00e0 b ch\u1ec9 bao g\u1ed3m 1 v\u00e0 0. Th\u1ef1c hi\u1ec7n XOR nh\u1ecb ph\u00e2n tr\u00ean c\u00e1c \u0111\u1ea7u v\u00e0o n\u00e0y v\u00e0 tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 c\u0169ng nh\u01b0 m\u1ed9t chu\u1ed7i.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Trong danh s\u00e1ch c\u00e1c chu\u1ed7i, tr\u1ea3 v\u1ec1 d\u00e0i nh\u1ea5t. Tr\u1ea3 v\u1ec1 \u0111\u1ea7u ti\u00ean trong tr\u01b0\u1eddng h\u1ee3p c\u00f3 nhi\u1ec1u chu\u1ed7i c\u00f9ng chi\u1ec1u d\u00e0i. Tr\u1ea3 v\u1ec1 Kh\u00f4ng c\u00f3 trong tr\u01b0\u1eddng h\u1ee3p danh s\u00e1ch \u0111\u1ea7u v\u00e0o l\u00e0 tr\u1ed1ng.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Tr\u1ea3 v\u1ec1 m\u1ed9t \u0111\u1ea1i chia chung l\u1edbn nh\u1ea5t c\u1ee7a hai s\u1ed1 nguy\u00ean a v\u00e0 b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Tr\u1ea3 v\u1ec1 danh s\u00e1ch t\u1ea5t c\u1ea3 c\u00e1c ti\u1ec1n t\u1ed1 t\u1eeb ng\u1eafn nh\u1ea5t \u0111\u1ebfn d\u00e0i nh\u1ea5t c\u1ee7a chu\u1ed7i \u0111\u1ea7u v\u00e0o\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i ch\u1ee9a c\u00e1c s\u1ed1 gi\u1edbi h\u1ea1n kh\u00f4ng gian b\u1eaft \u0111\u1ea7u t\u1eeb 0 \u0111\u1ebfn n.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Cho m\u1ed9t chu\u1ed7i, t\u00ecm ra bao nhi\u00eau k\u00fd t\u1ef1 ri\u00eang bi\u1ec7t (cho d\u00f9 tr\u01b0\u1eddng h\u1ee3p) n\u00f3 bao g\u1ed3m\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" L\u1eadp v\u00e0o h\u00e0m n\u00e0y l\u00e0 m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho c\u00e1c n\u1ed1t nh\u1ea1c trong m\u1ed9t \u0111\u1ecbnh d\u1ea1ng ASCII \u0111\u1eb7c bi\u1ec7t. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 ph\u00e2n t\u00edch chu\u1ed7i n\u00e0y v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean t\u01b0\u01a1ng \u1ee9ng v\u1edbi bao nhi\u00eau nh\u1ecbp m\u1ed7i kh\u00f4ng k\u00e9o d\u00e0i. \u0110\u00e2y l\u00e0 m\u1ed9t c\u00e2u chuy\u1ec7n: 'o' - to\u00e0n b\u1ed9 ghi ch\u00fa, k\u00e9o d\u00e0i b\u1ed1n nh\u1ecbp 'o' - n\u1eeda ghi ch\u00fa, k\u00e9o d\u00e0i hai nh\u1ecbp '. 'n\u01a1i' - quater ghi ch\u00fa, k\u00e9o d\u00e0i m\u1ed9t nh\u1ecbp\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" T\u00ecm ra s\u1ed1 l\u1ea7n m\u1ed9t chu\u1ed7i con nh\u1ea5t \u0111\u1ecbnh c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u00ecm th\u1ea5y trong chu\u1ed7i g\u1ed1c. \u0110\u1ebfm c\u00e1c tr\u01b0\u1eddng h\u1ee3p ch\u1ed3ng ch\u00e9o.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" L\u1ec7nh \u0111\u1ea7u v\u00e0o l\u00e0 m\u1ed9t chu\u1ed7i s\u1ed1 gi\u1edbi h\u1ea1n kh\u00f4ng gian t\u1eeb 'kh\u00f4ng' \u0111\u1ebfn 'ch\u00edn'. C\u00e1c l\u1ef1a ch\u1ecdn h\u1ee3p l\u1ec7 l\u00e0 'kh\u00f4ng','m\u1ed9t', 'hai', 'ba', 'b\u1ed1n', 'n\u0103m','s\u00e1u', 'b\u1ea3y', 't\u00e1m' v\u00e0 'ch\u00edn'. Tr\u1ea3 v\u1ec1 chu\u1ed7i v\u1edbi c\u00e1c s\u1ed1 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp t\u1eeb nh\u1ecf nh\u1ea5t \u0111\u1ebfn l\u1edbn nh\u1ea5t\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" T\u1eeb m\u1ed9t danh s\u00e1ch cung c\u1ea5p c\u00e1c s\u1ed1 (c\u00f3 chi\u1ec1u d\u00e0i \u00edt nh\u1ea5t l\u00e0 hai) ch\u1ecdn v\u00e0 tr\u1ea3 v\u1ec1 hai m\u00e0 l\u00e0 g\u1ea7n nh\u1ea5t v\u1edbi nhau v\u00e0 tr\u1ea3 v\u1ec1 ch\u00fang theo th\u1ee9 t\u1ef1 (s\u1ed1 nh\u1ecf h\u01a1n, s\u1ed1 l\u1edbn h\u01a1n).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Cho danh s\u00e1ch c\u00e1c s\u1ed1 (\u00edt nh\u1ea5t hai y\u1ebfu t\u1ed1), \u00e1p d\u1ee5ng m\u1ed9t chuy\u1ec3n \u0111\u1ed5i tuy\u1ebfn t\u00ednh cho danh s\u00e1ch \u0111\u00f3, nh\u01b0 v\u1eady s\u1ed1 nh\u1ecf nh\u1ea5t s\u1ebd tr\u1edf th\u00e0nh 0 v\u00e0 s\u1ed1 l\u1edbn nh\u1ea5t s\u1ebd tr\u1edf th\u00e0nh 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" B\u1ed9 l\u1ecdc danh s\u00e1ch \u0111\u01b0\u1ee3c cho c\u1ee7a b\u1ea5t k\u1ef3 gi\u00e1 tr\u1ecb Python ch\u1ec9 cho s\u1ed1 nguy\u00ean\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" \u0110\u1ed9 d\u00e0i tr\u1ea3 v\u1ec1 c\u1ee7a chu\u1ed7i \u0111\u00e3 cho\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t s\u1ed1 n, t\u00ecm s\u1ed1 l\u1edbn nh\u1ea5t chia n \u0111\u1ec1u, nh\u1ecf h\u01a1n n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c nh\u00e2n s\u1ed1 nguy\u00ean t\u1ed1 c\u1ee7a m\u1ed9t s\u1ed1 nguy\u00ean \u0111\u01b0\u1ee3c \u0111\u01b0a ra theo th\u1ee9 t\u1ef1 t\u1eeb nh\u1ecf nh\u1ea5t \u0111\u1ebfn l\u1edbn nh\u1ea5t. M\u1ed7i nh\u00e2n n\u00ean \u0111\u01b0\u1ee3c li\u1ec7t k\u00ea s\u1ed1 l\u1ea7n t\u01b0\u01a1ng \u1ee9ng v\u1edbi s\u1ed1 l\u1ea7n xu\u1ea5t hi\u1ec7n trong ph\u00e2n gi\u1ea3i. S\u1ed1 \u0111\u1ea7u v\u00e0o ph\u1ea3i b\u1eb1ng v\u1edbi s\u1ea3n ph\u1ea9m c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c nh\u00e2n\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" T\u1eeb m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean, lo\u1ea1i b\u1ecf t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed xu\u1ea5t hi\u1ec7n nhi\u1ec1u h\u01a1n m\u1ed9t l\u1ea7n. Gi\u1eef th\u1ee9 t\u1ef1 c\u1ee7a c\u00e1c ph\u1ea7n t\u1eed c\u00f2n l\u1ea1i gi\u1ed1ng nh\u01b0 trong \u0111\u1ea7u v\u00e0o.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t chu\u1ed7i nh\u1ea5t \u0111\u1ecbnh, xoay c\u00e1c k\u00fd t\u1ef1 ch\u1eef c\u00e1i nh\u1ecf sang ch\u1eef c\u00e1i l\u1edbn v\u00e0 ch\u1eef c\u00e1i l\u1edbn sang ch\u1eef c\u00e1i nh\u1ecf.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" K\u1ebft n\u1ed1i danh s\u00e1ch c\u00e1c chu\u1ed7i th\u00e0nh m\u1ed9t chu\u1ed7i\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" B\u1ed9 l\u1ecdc m\u1ed9t danh s\u00e1ch \u0111\u1ea7u v\u00e0o c\u1ee7a chu\u1ed7i ch\u1ec9 cho nh\u1eefng ng\u01b0\u1eddi b\u1eaft \u0111\u1ea7u v\u1edbi m\u1ed9t ti\u1ec1n t\u1ed1 nh\u1ea5t \u0111\u1ecbnh.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Ch\u1ec9 tr\u1ea3 v\u1ec1 c\u00e1c s\u1ed1 d\u01b0\u01a1ng trong danh s\u00e1ch.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Tr\u1ea3 v\u1ec1 true n\u1ebfu m\u1ed9t s\u1ed1 nh\u1ea5t \u0111\u1ecbnh l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1, v\u00e0 false n\u1ebfu kh\u00f4ng.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u0110\u00e1nh gi\u00e1 \u0111a th\u1ee9c v\u1edbi h\u1ec7 s\u1ed1 xs t\u1ea1i \u0111i\u1ec3m x. tr\u1ea3 v\u1ec1 xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"H\u00e0m n\u00e0y l\u1ea5y m\u1ed9t danh s\u00e1ch l v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch l' nh\u01b0 v\u1eady l\u00e0 l' gi\u1ed1ng h\u1ec7t l trong c\u00e1c ch\u1ec9 s\u1ed1 kh\u00f4ng th\u1ec3 chia cho ba, trong khi gi\u00e1 tr\u1ecb c\u1ee7a n\u00f3 t\u1ea1i c\u00e1c ch\u1ec9 s\u1ed1 c\u00f3 th\u1ec3 chia cho ba b\u1eb1ng c\u00e1c gi\u00e1 tr\u1ecb c\u1ee7a c\u00e1c ch\u1ec9 s\u1ed1 t\u01b0\u01a1ng \u1ee9ng c\u1ee7a l, nh\u01b0ng \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 c\u00e1c ph\u1ea7n t\u1eed duy nh\u1ea5t \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp trong danh s\u00e1ch\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 ph\u1ea7n t\u1eed t\u1ed1i \u0111a trong danh s\u00e1ch.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 s\u1ed1 l\u1ea7n ch\u1eef s\u1ed1 7 xu\u1ea5t hi\u1ec7n trong s\u1ed1 nguy\u00ean nh\u1ecf h\u01a1n n m\u00e0 c\u00f3 th\u1ec3 chia cho 11 ho\u1eb7c 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"H\u00e0m n\u00e0y l\u1ea5y m\u1ed9t danh s\u00e1ch l v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch l' nh\u01b0 v\u1eady m\u00e0 l' l\u00e0 gi\u1ed1ng h\u1ec7t v\u1edbi l trong c\u00e1c ch\u1ec9 s\u1ed1 l\u1ebb, trong khi c\u00e1c gi\u00e1 tr\u1ecb c\u1ee7a n\u00f3 \u1edf c\u00e1c ch\u1ec9 s\u1ed1 ch\u1eb5n l\u00e0 b\u1eb1ng c\u00e1c gi\u00e1 tr\u1ecb c\u1ee7a c\u00e1c ch\u1ec9 s\u1ed1 ch\u1eb5n c\u1ee7a l, nh\u01b0ng \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u01b0\u1ee3c m\u00e3 h\u00f3a b\u1edfi c\u00e1c nh\u00f3m chu k\u1ef3 ba k\u00fd t\u1ef1.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib tr\u1ea3 v\u1ec1 s\u1ed1 n l\u00e0 s\u1ed1 Fibonacci v\u00e0 n\u00f3 c\u0169ng l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero l\u1ea5y m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean l\u00e0m \u0111\u1ea7u v\u00e0o. N\u00f3 tr\u1ea3 v\u1ec1 True n\u1ebfu c\u00f3 ba ph\u1ea7n t\u1eed ri\u00eang bi\u1ec7t trong danh s\u00e1ch c\u00f3 t\u1ed5ng b\u1eb1ng 0, v\u00e0 False n\u1ebfu kh\u00f4ng.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    H\u00e3y t\u01b0\u1edfng t\u01b0\u1ee3ng m\u1ed9t con \u0111\u01b0\u1eddng l\u00e0 m\u1ed9t \u0111\u01b0\u1eddng th\u1eb3ng v\u00f4 c\u00f9ng d\u00e0i. n xe \u0111ang l\u00e1i xe t\u1eeb tr\u00e1i sang ph\u1ea3i; \u0111\u1ed3ng th\u1eddi, m\u1ed9t b\u1ed9 kh\u00e1c nhau c\u1ee7a n xe \u0111ang l\u00e1i xe t\u1eeb ph\u1ea3i sang tr\u00e1i. Hai b\u1ed9 xe b\u1eaft \u0111\u1ea7u r\u1ea5t xa nhau. T\u1ea5t c\u1ea3 c\u00e1c xe di chuy\u1ec3n v\u1edbi c\u00f9ng t\u1ed1c \u0111\u1ed9. Hai chi\u1ebfc xe \u0111\u01b0\u1ee3c cho l\u00e0 va ch\u1ea1m khi m\u1ed9t chi\u1ebfc xe di chuy\u1ec3n t\u1eeb tr\u00e1i sang ph\u1ea3i va ch\u1ea1m v\u00e0o m\u1ed9t chi\u1ebfc xe di chuy\u1ec3n t\u1eeb ph\u1ea3i sang tr\u00e1i. Tuy nhi\u00ean, c\u00e1c xe l\u00e0 v\u00f4 c\u00f9ng v\u1eefng ch\u1eafc v\u00e0 m\u1ea1nh m\u1ebd; k\u1ebft qu\u1ea3 l\u00e0, h\u1ecd ti\u1ebfp t\u1ee5c di chuy\u1ec3n trong qu\u1ef9 \u0111\u1ea1o c\u1ee7a h\u1ecd nh\u01b0 th\u1ec3 h\u1ecd kh\u00f4ng va ch\u1ea1m. H\u00e0m n\u00e0y \u0111\u1ea7u ra s\u1ed1 l\u01b0\u1ee3ng va ch\u1ea1m nh\u01b0 v\u1eady.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Danh s\u00e1ch tr\u1ea3 v\u1ec1 v\u1edbi c\u00e1c y\u1ebfu t\u1ed1 t\u0103ng l\u00ean 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero l\u1ea5y m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean l\u00e0m \u0111\u1ea7u v\u00e0o. N\u00f3 tr\u1ea3 v\u1ec1 True n\u1ebfu c\u00f3 hai ph\u1ea7n t\u1eed kh\u00e1c nhau trong danh s\u00e1ch c\u00f3 t\u1ed5ng b\u1eb1ng 0, v\u00e0 False n\u1ebfu kh\u00f4ng.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Thay \u0111\u1ed5i c\u01a1 s\u1edf s\u1ed1 c\u1ee7a s\u1ed1 \u0111\u1ea7u v\u00e0o x th\u00e0nh c\u01a1 s\u1edf. tr\u1ea3 v\u1ec1 bi\u1ec3u di\u1ec5n chu\u1ed7i sau khi chuy\u1ec3n \u0111\u1ed5i. s\u1ed1 c\u01a1 s\u1edf nh\u1ecf h\u01a1n 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"V\u1edbi chi\u1ec1u d\u00e0i c\u1ee7a m\u1ed9t b\u00ean v\u00e0 v\u00f9ng tr\u1edf l\u1ea1i cao cho m\u1ed9t tam gi\u00e1c.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"D\u00f2ng s\u1ed1 Fib4 l\u00e0 m\u1ed9t chu\u1ed7i t\u01b0\u01a1ng t\u1ef1 nh\u01b0 chu\u1ed7i Fibbonacci \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a nh\u01b0 sau: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Vui l\u00f2ng vi\u1ebft m\u1ed9t h\u00e0m \u0111\u1ec3 t\u00ednh to\u00e1n hi\u1ec7u qu\u1ea3 ph\u1ea7n t\u1eed th\u1ee9 n c\u1ee7a chu\u1ed7i s\u1ed1 fib4. Kh\u00f4ng s\u1eed d\u1ee5ng quy tr\u00ecnh.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Tr\u1ecdng s\u1ed1 tr\u1ea3 v\u1ec1 c\u1ee7a c\u00e1c y\u1ebfu t\u1ed1 trong danh s\u00e1ch l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Ki\u1ec3m tra xem chu\u1ed7i \u0111\u01b0\u1ee3c cho l\u00e0 palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 2 ^ n m\u00f4-\u0111un p (l\u01b0u \u00fd v\u1ec1 s\u1ed1 li\u1ec7u).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u01b0\u1ee3c m\u00e3 h\u00f3a b\u1eb1ng c\u00e1ch d\u1ecbch chuy\u1ec3n m\u1ed7i k\u00fd t\u1ef1 b\u1eb1ng 5 trong b\u1ea3ng ch\u1eef c\u00e1i.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels l\u00e0 m\u1ed9t h\u00e0m l\u1ea5y chu\u1ed7i v\u00e0 tr\u1ea3 v\u1ec1 chu\u1ed7i kh\u00f4ng c\u00f3 nguy\u00ean \u00e2m.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 True n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c s\u1ed1 trong danh s\u00e1ch l d\u01b0\u1edbi ng\u01b0\u1ee1ng t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Th\u00eam hai s\u1ed1 x v\u00e0 y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Ki\u1ec3m tra xem hai t\u1eeb c\u00f3 c\u00f9ng k\u00fd t\u1ef1 kh\u00f4ng.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 s\u1ed1 Fibonacci n-th.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets l\u00e0 m\u1ed9t chu\u1ed7i c\u1ee7a \"<\" v\u00e0 \">\". return True n\u1ebfu m\u1ed7i bracket m\u1edf c\u00f3 m\u1ed9t bracket \u0111\u00f3ng t\u01b0\u01a1ng \u1ee9ng.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 True l\u00e0 c\u00e1c ph\u1ea7n t\u1eed danh s\u00e1ch \u0111ang t\u0103ng ho\u1eb7c gi\u1ea3m m\u1ed9t c\u00e1ch \u0111\u01a1n \u0111i\u1ec7u.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 c\u00e1c ph\u1ea7n t\u1eed chung duy nh\u1ea5t \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp cho hai danh s\u00e1ch.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 nh\u00e2n s\u1ed1 nguy\u00ean t\u1ed1 l\u1edbn nh\u1ea5t c\u1ee7a n. Gi\u1ea3 s\u1eed n > 1 v\u00e0 kh\u00f4ng ph\u1ea3i l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n l\u00e0 m\u1ed9t h\u00e0m t\u1ed5ng s\u1ed1 t\u1eeb 1 \u0111\u1ebfn n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets l\u00e0 m\u1ed9t chu\u1ed7i c\u1ee7a \"(\" v\u00e0 \"\". tr\u1ea3 v\u1ec1 True n\u1ebfu m\u1ed7i bracket m\u1edf c\u00f3 m\u1ed9t bracket \u0111\u00f3ng t\u01b0\u01a1ng \u1ee9ng.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u0111\u1ea1i di\u1ec7n cho h\u1ec7 s\u1ed1 c\u1ee7a m\u1ed9t \u0111a th\u1ee9c. xs[0] + xs[1] * x + xs[2] * x^2 +.... Tr\u1ea3 v\u1ec1 d\u1eabn xu\u1ea5t c\u1ee7a \u0111a th\u1ee9c n\u00e0y trong c\u00f9ng m\u1ed9t h\u00ecnh th\u1ee9c.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"D\u00f2ng s\u1ed1 FibFib l\u00e0 m\u1ed9t chu\u1ed7i t\u01b0\u01a1ng t\u1ef1 nh\u01b0 chu\u1ed7i Fibbonacci \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a nh\u01b0 sau: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Vui l\u00f2ng vi\u1ebft m\u1ed9t h\u00e0m \u0111\u1ec3 t\u00ednh to\u00e1n hi\u1ec7u qu\u1ea3 ph\u1ea7n t\u1eed th\u1ee9 n c\u1ee7a chu\u1ed7i s\u1ed1 fibfib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nTh\u00eam th\u00eam c\u00e1c tr\u01b0\u1eddng h\u1ee3p th\u1eed nghi\u1ec7m.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Chuy\u1ec3n tr\u00f2n c\u00e1c ch\u1eef s\u1ed1 c\u1ee7a s\u1ed1 nguy\u00ean x, chuy\u1ec3n c\u00e1c ch\u1eef s\u1ed1 sang ph\u1ea3i b\u1eb1ng c\u00e1ch chuy\u1ec3n v\u00e0 tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 d\u01b0\u1edbi d\u1ea1ng chu\u1ed7i. N\u1ebfu chuy\u1ec3n > s\u1ed1 ch\u1eef s\u1ed1, tr\u1ea3 v\u1ec1 ch\u1eef s\u1ed1 ng\u01b0\u1ee3c l\u1ea1i.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Nhi\u1ec7m v\u1ee5 Vi\u1ebft m\u1ed9t h\u00e0m l\u1ea5y m\u1ed9t chu\u1ed7i nh\u01b0 \u0111\u1ea7u v\u00e0o v\u00e0 tr\u1ea3 v\u1ec1 t\u1ed5ng c\u00e1c k\u00fd t\u1ef1 tr\u00ean ch\u1ec9 c\u00f3 m\u00e3 ASCII. V\u00ed d\u1ee5: digitSum (((\"\") => 0 digitSum (((\"abAB\") => 131 digitSum (((\"abcCd\") => 67 digitSum (((\"helloE\") => 69 digitSum (((\"woArBld\") => 131 digitSum (((\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Trong nhi\u1ec7m v\u1ee5 n\u00e0y, b\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho m\u1ed9t s\u1ed1 t\u00e1o v\u00e0 cam \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i trong m\u1ed9t gi\u1ecf tr\u00e1i c\u00e2y gi\u1ecf n\u00e0y ch\u1ee9a t\u00e1o, cam v\u00e0 tr\u00e1i c\u00e2y xo\u00e0i. V\u1edbi chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho t\u1ed5ng s\u1ed1 cam v\u00e0 t\u00e1o v\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean \u0111\u1ea1i di\u1ec7n cho t\u1ed5ng s\u1ed1 tr\u00e1i c\u00e2y trong gi\u1ecf tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng tr\u00e1i c\u00e2y xo\u00e0i trong gi\u1ecf. v\u00ed d\u1ee5: fruit_distribution\"5(t\u00f4m v\u00e0 6 qu\u1ea3 cam\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 t\u00e1o v\u00e0 1 qu\u1ea3 cam\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 t\u00e1o v\u00e0 3 qu\u1ea3 cam\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 t\u00e1o v\u00e0 1 qu\u1ea3 cam\"20) \",1 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"\u0110\u01b0\u1ee3c cho l\u00e0 m\u1ed9t m\u1ea3ng \u0111\u1ea1i di\u1ec7n cho m\u1ed9t nh\u00e1nh c\u1ee7a m\u1ed9t c\u00e2y c\u00f3 c\u00e1c n\u00fat nguy\u00ean kh\u00f4ng \u00e2m, nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 nh\u1eb7t m\u1ed9t trong c\u00e1c n\u00fat v\u00e0 tr\u1ea3 v\u1ec1 n\u00f3. M\u1ea1ch \u0111\u01b0\u1ee3c nh\u1eb7t ph\u1ea3i l\u00e0 n\u00fat c\u00f3 gi\u00e1 tr\u1ecb ch\u1eb5n nh\u1ecf nh\u1ea5t. N\u1ebfu t\u00ecm th\u1ea5y nhi\u1ec1u n\u00fat c\u00f3 c\u00f9ng gi\u00e1 tr\u1ecb ch\u1eb5n nh\u1ecf nh\u1ea5t, tr\u1ea3 v\u1ec1 n\u00fat c\u00f3 ch\u1ec9 s\u1ed1 nh\u1ecf nh\u1ea5t. M\u1ea1ch \u0111\u01b0\u1ee3c nh\u1eb7t n\u00ean \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1 trong m\u1ed9t danh s\u00e1ch, [smallest_value, ch\u1ec9 s\u1ed1 c\u1ee7a n\u00f3] N\u1ebfu kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ch\u1eb5n ho\u1eb7c m\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u01b0a ra l\u00e0 tr\u1ed1ng, tr\u1ea3 v\u1ec1 []. V\u00ed d\u1ee5 1: \u0110\u1ea7u v\u00e0o: [4,2,3] \u0110\u1ea7u ra: [2, 1] Gi\u1ea3i th\u00edch: 2 c\u00f3 gi\u00e1 tr\u1ecb ch\u1eb5n nh\u1ecf nh\u1ea5t v\u00e0 2 c\u00f3 ch\u1ec9 s\u1ed1 nh\u1ecf nh\u1ea5t. V\u00ed d\u1ee5 2: \u0110\u1ea7u v\u00e0o: [1,2,3] \u0110\u1ea7u ra: [2, 1] Gi\u1ea3i th\u00edch: 2 c\u00f3 gi\u00e1 tr\u1ecb nh\u1ecf nh\u1ea5t v\u00e0 2 c\u00f3 ch\u1ec9 s\u1ed1 ch\u1eb5n nh\u1ecf nh\u1ea5t. V\u00ed\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    M\u1ed9t m\u1ea3ng palindromic l\u00e0 m\u1ed9t m\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u1ecdc gi\u1ed1ng nhau v\u1ec1 ph\u00eda tr\u01b0\u1edbc v\u00e0 ph\u00eda sau. Trong m\u1ed9t thay \u0111\u1ed5i, b\u1ea1n c\u00f3 th\u1ec3 thay \u0111\u1ed5i m\u1ed9t ph\u1ea7n t\u1eed th\u00e0nh b\u1ea5t k\u1ef3 ph\u1ea7n t\u1eed n\u00e0o kh\u00e1c. V\u00ed d\u1ee5: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m tr\u1ea3 v\u1ec1 true n\u1ebfu s\u1ed1 \u0111\u01b0\u1ee3c \u0111\u01b0a ra l\u00e0 ph\u00e9p nh\u00e2n c\u1ee7a 3 s\u1ed1 nguy\u00ean t\u1ed1 v\u00e0 false n\u1ebfu kh\u00f4ng. Bi\u1ebft r\u1eb1ng (a) nh\u1ecf h\u01a1n 100. V\u00ed d\u1ee5: is_multiply_prime(30) == True 30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 vi\u1ebft m\u1ed9t h\u00e0m tr\u1ea3 v\u1ec1 true n\u1ebfu s\u1ed1 x l\u00e0 m\u1ed9t b\u1eadc \u0111\u01a1n gi\u1ea3n c\u1ee7a n v\u00e0 false trong c\u00e1c tr\u01b0\u1eddng h\u1ee3p kh\u00e1c. x l\u00e0 m\u1ed9t b\u1eadc \u0111\u01a1n gi\u1ea3n c\u1ee7a n n\u1ebfu n**int=x V\u00ed d\u1ee5: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"B\u1ea1n \u0111\u00e3 \u0111\u01b0\u1ee3c giao nhi\u1ec7m v\u1ee5 vi\u1ebft m\u1ed9t h\u00e0m nh\u1eadn \u0111\u01b0\u1ee3c m\u1ed9t s\u1ed1 th\u1eadp ni\u00ean l\u1ee5c l\u00e0 m\u1ed9t chu\u1ed7i v\u00e0 \u0111\u1ebfm s\u1ed1 ch\u1eef s\u1ed1 th\u1eadp ni\u00ean l\u1ee5c l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1 (s\u1ed1 nguy\u00ean t\u1ed1, ho\u1eb7c m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1, l\u00e0 m\u1ed9t s\u1ed1 t\u1ef1 nhi\u00ean l\u1edbn h\u01a1n 1 m\u00e0 kh\u00f4ng ph\u1ea3i l\u00e0 m\u1ed9t s\u1ea3n ph\u1ea9m c\u1ee7a hai s\u1ed1 t\u1ef1 nhi\u00ean nh\u1ecf h\u01a1n). C\u00e1c ch\u1eef s\u1ed1 th\u1eadp ni\u00ean l\u1ee5c l\u00e0 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. C\u00e1c s\u1ed1 nguy\u00ean t\u1ed1 l\u00e0 2, 3, 5, 7, 11, 13, 17,... V\u00ec v\u1eady, b\u1ea1n ph\u1ea3i x\u00e1c \u0111\u1ecbnh m\u1ed9t s\u1ed1 c\u00e1c ch\u1eef s\u1ed1 sau: 2, 3, 5, 7, B (= th\u1eadp ni\u00ean 11), D (= th\u1eadp ni\u00ean 13). L\u01b0u \u00fd: b\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh \u0111\u1ea7u v\u00e0o lu\u00f4n lu\u00f4n \u0111\u00fang ho\u1eb7c tr\u1ed1ng, v\u00e0 c\u00e1c k\u00fd hi\u1ec7u A,B,C,D,E,F lu\u00f4n lu\u00f4n \u0111\u01b0\u1ee3c vi\u1ebft b\u1eb1ng ch\u1eef c\u00e1i l\u1edbn. V\u00ed d\u1ee5: \u0110\u1ed1i v\u1edbi num \"AB\" \u0111\u1ea7u ra n\u00ean l\u00e0 num = 1. \u0110\u1ed1i v\u1edbi num \"10\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c \u0111\u01b0a ra m\u1ed9t s\u1ed1 \u1edf d\u1ea1ng th\u1eadp ph\u00e2n v\u00e0 nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 chuy\u1ec3n \u0111\u1ed5i n\u00f3 th\u00e0nh \u0111\u1ecbnh d\u1ea1ng nh\u1ecb ph\u00e2n. H\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i, v\u1edbi m\u1ed7i k\u00fd t\u1ef1 \u0111\u1ea1i di\u1ec7n cho m\u1ed9t s\u1ed1 nh\u1ecb ph\u00e2n. M\u1ed7i k\u00fd t\u1ef1 trong chu\u1ed7i s\u1ebd l\u00e0 '0' ho\u1eb7c '1'. S\u1ebd c\u00f3 m\u1ed9t c\u1eb7p k\u00fd t\u1ef1 'db' \u1edf \u0111\u1ea7u v\u00e0 cu\u1ed1i chu\u1ed7i. C\u00e1c k\u00fd t\u1ef1 b\u1ed5 sung c\u00f3 \u0111\u1ec3 gi\u00fap \u0111\u1ecbnh d\u1ea1ng. V\u00ed d\u1ee5: decimal_to_binary ((15) # tr\u1ea3 v\u1ec1 \"db1111db\" decimal_to_binary32) # tr\u1ea3 v\u1ec1 \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i s. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 ki\u1ec3m tra xem chu\u1ed7i c\u00f3 h\u1ea1nh ph\u00fac hay kh\u00f4ng. M\u1ed9t chu\u1ed7i l\u00e0 h\u1ea1nh ph\u00fac n\u1ebfu chi\u1ec1u d\u00e0i c\u1ee7a n\u00f3 \u00edt nh\u1ea5t l\u00e0 3 v\u00e0 m\u1ed7i 3 ch\u1eef c\u00e1i li\u00ean ti\u1ebfp l\u00e0 kh\u00e1c nhau V\u00ed d\u1ee5: is_happy (a) => False is_happy (aa) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u0110\u00e2y l\u00e0 tu\u1ea7n cu\u1ed1i c\u00f9ng c\u1ee7a h\u1ecdc k\u1ef3 v\u00e0 gi\u00e1o vi\u00ean ph\u1ea3i \u0111\u01b0a ra \u0111i\u1ec3m cho h\u1ecdc sinh. Gi\u00e1o vi\u00ean \u0111\u00e3 t\u1ea1o ra thu\u1eadt to\u00e1n c\u1ee7a ri\u00eang m\u00ecnh \u0111\u1ec3 \u0111\u00e1nh gi\u00e1. V\u1ea5n \u0111\u1ec1 duy nh\u1ea5t l\u00e0, c\u00f4 \u1ea5y \u0111\u00e3 m\u1ea5t m\u00e3 m\u00e0 c\u00f4 \u1ea5y s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u00e1nh gi\u00e1. C\u00f4 \u1ea5y \u0111\u00e3 cho b\u1ea1n m\u1ed9t danh s\u00e1ch \u0111i\u1ec3m GPA cho m\u1ed9t s\u1ed1 h\u1ecdc sinh v\u00e0 b\u1ea1n ph\u1ea3i vi\u1ebft m\u1ed9t h\u00e0m c\u00f3 th\u1ec3 xu\u1ea5t ra danh s\u00e1ch \u0111i\u1ec3m \u0111i\u1ec3m ch\u1eef c\u00e1i b\u1eb1ng c\u00e1ch s\u1eed d\u1ee5ng b\u1ea3ng sau: GPA.\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m l\u1ea5y m\u1ed9t chu\u1ed7i v\u00e0 tr\u1ea3 v\u1ec1 True n\u1ebfu chi\u1ec1u d\u00e0i chu\u1ed7i l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1 ho\u1eb7c False n\u1ebfu kh\u00f4ng V\u00ed d\u1ee5 prime_length (('Hello') == True prime_length (('abcdcba') == True prime_length (('kittens') == True prime_length (('orange') == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n ch\u1eef s\u1ed1 b\u1eaft \u0111\u1ea7u ho\u1eb7c k\u1ebft th\u00fac b\u1eb1ng 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng N, tr\u1ea3 v\u1ec1 t\u1ed5ng s\u1ed1 c\u00e1c ch\u1eef s\u1ed1 c\u1ee7a n\u00f3 trong d\u1ea1ng nh\u1ecb ph\u00e2n. V\u00ed d\u1ee5 \u0110\u1ed1i v\u1edbi N = 1000, t\u1ed5ng s\u1ed1 c\u00e1c ch\u1eef s\u1ed1 s\u1ebd l\u00e0 1 \u0111\u1ea7u ra n\u00ean l\u00e0 \"1\". \u0110\u1ed1i v\u1edbi N = 150, t\u1ed5ng s\u1ed1 c\u00e1c ch\u1eef s\u1ed1 s\u1ebd l\u00e0 6 \u0111\u1ea7u ra n\u00ean l\u00e0 \"110\". \u0110\u1ed1i v\u1edbi N = 147, t\u1ed5ng s\u1ed1 c\u00e1c ch\u1eef s\u1ed1 s\u1ebd l\u00e0 12 \u0111\u1ea7u ra n\u00ean l\u00e0 \"1100\". Bi\u1ebfn s\u1ed1: @N s\u1ed1 nguy\u00ean Ranh gi\u1edbi h\u1ea1n: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. \u0111\u1ea7u ra: m\u1ed9t chu\u1ed7i s\u1ed1 nh\u1ecb ph\u00e2n\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Cho m\u1ed9t danh s\u00e1ch kh\u00f4ng r\u1ed7ng c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean lst. th\u00eam c\u00e1c ph\u1ea7n t\u1eed ch\u1eb5n c\u00f3 ch\u1ec9 s\u1ed1 l\u1ebb.. V\u00ed d\u1ee5: th\u00eam (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Vi\u1ebft m\u1ed9t h\u00e0m l\u1ea5y m\u1ed9t chu\u1ed7i v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t phi\u00ean b\u1ea3n \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp c\u1ee7a n\u00f3. Phi\u00ean b\u1ea3n \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp c\u1ee7a chu\u1ed7i, l\u00e0 m\u1ed9t chu\u1ed7i trong \u0111\u00f3 t\u1ea5t c\u1ea3 c\u00e1c t\u1eeb (\u0111\u01b0\u1ee3c t\u00e1ch b\u1eb1ng kho\u1ea3ng tr\u1ed1ng) \u0111\u01b0\u1ee3c thay th\u1ebf b\u1eb1ng m\u1ed9t t\u1eeb m\u1edbi trong \u0111\u00f3 t\u1ea5t c\u1ea3 c\u00e1c k\u00fd t\u1ef1 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n d\u1ef1a tr\u00ean gi\u00e1 tr\u1ecb ascii. L\u01b0u \u00fd: B\u1ea1n n\u00ean gi\u1eef th\u1ee9 t\u1ef1 c\u1ee7a c\u00e1c t\u1eeb v\u00e0 kho\u1ea3ng tr\u1ed1ng trong c\u00e2u. V\u00ed d\u1ee5: anti_shuffle ((('Hi') tr\u1ea3 v\u1ec1 'Hi' anti_shuffle ((('hello') tr\u1ea3 v\u1ec1 'ehllo' anti_shuffle (('Hello World!!!') tr\u1ea3 v\u1ec1 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t d\u1eef li\u1ec7u 2 chi\u1ec1u, nh\u01b0 m\u1ed9t danh s\u00e1ch l\u1ed3ng, t\u01b0\u01a1ng t\u1ef1 nh\u01b0 ma tr\u1eadn, tuy nhi\u00ean, kh\u00f4ng gi\u1ed1ng nh\u01b0 ma tr\u1eadn, m\u1ed7i h\u00e0ng c\u00f3 th\u1ec3 ch\u1ee9a m\u1ed9t s\u1ed1 c\u1ed9t kh\u00e1c nhau. V\u1edbi lst, v\u00e0 s\u1ed1 nguy\u00ean x, t\u00ecm s\u1ed1 nguy\u00ean x trong danh s\u00e1ch, v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c tuples, [(x1, y1), (x2, y2)...] nh\u01b0 v\u1eady m\u00e0 m\u1ed7i tuple l\u00e0 m\u1ed9t t\u1ecda \u0111\u1ed9 - (d\u00f2ng, c\u1ed9t), b\u1eaft \u0111\u1ea7u v\u1edbi 0. s\u1eafp x\u1ebfp t\u1ecda \u0111\u1ed9 ban \u0111\u1ea7u theo c\u00e1c h\u00e0ng theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n. Ngo\u00e0i ra, s\u1eafp x\u1ebfp t\u1ecda \u0111\u1ed9 c\u1ee7a h\u00e0ng theo c\u00e1c c\u1ed9t theo th\u1ee9 t\u1ef1 gi\u1ea3m d\u1ea7n. V\u00ed d\u1ee5: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1] ], 1) == [0,0, 0, 0, 1, 4], 0 (1, 4), 0 (2, 5), (2, 0) get_(],\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m, tr\u1ea3 v\u1ec1 m\u1ed9t b\u1ea3n sao c\u1ee7a m\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u01b0a ra sau khi s\u1eafp x\u1ebfp, b\u1ea1n s\u1ebd s\u1eafp x\u1ebfp m\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u01b0a ra theo th\u1ee9 t\u1ef1 t\u0103ng l\u00ean n\u1ebfu t\u1ed5ng s\u1ed1 ((gi\u00e1 tr\u1ecb ch\u1ec9 s\u1ed1 \u0111\u1ea7u ti\u00ean, gi\u00e1 tr\u1ecb ch\u1ec9 s\u1ed1 cu\u1ed1i c\u00f9ng) l\u00e0 l\u1ebb, ho\u1eb7c s\u1eafp x\u1ebfp n\u00f3 theo th\u1ee9 t\u1ef1 gi\u1ea3m xu\u1ed1ng n\u1ebfu t\u1ed5ng s\u1ed1 ((gi\u00e1 tr\u1ecb ch\u1ec9 s\u1ed1 \u0111\u1ea7u ti\u00ean, gi\u00e1 tr\u1ecb ch\u1ec9 s\u1ed1 cu\u1ed1i c\u00f9ng) l\u00e0 ch\u1eb5n. L\u01b0u \u00fd: * kh\u00f4ng thay \u0111\u1ed5i m\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u01b0a ra. V\u00ed d\u1ee5: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"T\u1ea1o m\u1ed9t h\u00e0m m\u00e3 h\u00f3a d\u00f9ng chu\u1ed7i nh\u01b0 m\u1ed9t \u0111\u1ed1i s\u1ed1 v\u00e0 tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u01b0\u1ee3c m\u00e3 h\u00f3a v\u1edbi ch\u1eef c\u00e1i \u0111\u01b0\u1ee3c xoay. B\u1ea3ng ch\u1eef c\u00e1i n\u00ean \u0111\u01b0\u1ee3c xoay theo c\u00e1ch m\u00e0 c\u00e1c ch\u1eef c\u00e1i di chuy\u1ec3n xu\u1ed1ng hai nh\u00e2n hai v\u1ecb tr\u00ed. V\u00ed d\u1ee5: m\u00e3 h\u00f3a (('hi') tr\u1ea3 v\u1ec1 'lm' m\u00e3 h\u00f3a (('asdfghjkl') tr\u1ea3 v\u1ec1 'ewhjklnop' m\u00e3 h\u00f3a (('gf') tr\u1ea3 v\u1ec1 'kj' m\u00e3 h\u00f3a (('et') tr\u1ea3 v\u1ec1 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c \u0111\u01b0a ra m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean. Vi\u1ebft m\u1ed9t h\u00e0m next_smallest (() tr\u1ea3 v\u1ec1 ph\u1ea7n t\u1eed nh\u1ecf th\u1ee9 2 trong danh s\u00e1ch. Tr\u1ea3 v\u1ec1 None n\u1ebfu kh\u00f4ng c\u00f3 ph\u1ea7n t\u1eed nh\u01b0 v\u1eady. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == None next_smallest (([1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i t\u1eeb, v\u00e0 nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 \u0111\u1ebfm s\u1ed1 l\u1ea7n ch\u00e1n. Ch\u00e1n l\u00e0 m\u1ed9t c\u00e2u b\u1eaft \u0111\u1ea7u b\u1eb1ng t\u1eeb \"I\". C\u00e1c c\u00e2u \u0111\u01b0\u1ee3c ph\u00e2n chia b\u1edfi '.', '?' ho\u1eb7c '!'. V\u00ed d\u1ee5:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Vi\u1ebft m\u1ed9t h\u00e0m l\u1ea5y m\u1ed9t th\u00f4ng \u0111i\u1ec7p, v\u00e0 m\u00e3 h\u00f3a theo c\u00e1ch m\u00e0 n\u00f3 trao \u0111\u1ed5i tr\u01b0\u1eddng h\u1ee3p c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c ch\u1eef c\u00e1i, thay th\u1ebf t\u1ea5t c\u1ea3 c\u00e1c nguy\u00ean \u00e2m trong th\u00f4ng \u0111i\u1ec7p v\u1edbi ch\u1eef c\u00e1i xu\u1ea5t hi\u1ec7n 2 v\u1ecb tr\u00ed tr\u01b0\u1edbc nguy\u00ean \u00e2m \u0111\u00f3 trong b\u1ea3ng ch\u1eef c\u00e1i ti\u1ebfng Anh. Gi\u1ea3 s\u1eed ch\u1ec9 c\u00f3 ch\u1eef c\u00e1i. V\u00ed d\u1ee5:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c \u0111\u01b0a ra m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean. B\u1ea1n c\u1ea7n t\u00ecm ra gi\u00e1 tr\u1ecb nguy\u00ean t\u1ed1 l\u1edbn nh\u1ea5t v\u00e0 tr\u1ea3 v\u1ec1 t\u1ed5ng s\u1ed1 c\u00e1c ch\u1eef s\u1ed1 c\u1ee7a n\u00f3. V\u00ed d\u1ee5: \u0110\u1ed1i v\u1edbi lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] \u0111\u1ea7u ra n\u00ean l\u00e0 10 \u0110\u1ed1i v\u1edbi lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] \u0111\u1ea7u ra n\u00ean l\u00e0 25 \u0110\u1ed1i v\u1edbi lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] \u0111\u1ea7u ra n\u00ean l\u00e0 13 \u0110\u1ed1i v\u1edbi lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] \u0111\u1ea7u ra n\u00ean l\u00e0 11 \u0110\u1ed1i v\u1edbi lst = [0,81,12,31,21] \u0111\u1ea7u ra n\u00ean l\u00e0 3 \u0110\u1ed1i v\u1edbi lst\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    N\u1ebfu c\u00f3 t\u1eeb \u0111i\u1ec3n, tr\u1ea3 v\u1ec1 True n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c ph\u00edm l\u00e0 chu\u1ed7i ch\u1eef vi\u1ebft nh\u1ecf ho\u1eb7c t\u1ea5t c\u1ea3 c\u00e1c ph\u00edm l\u00e0 chu\u1ed7i ch\u1eef vi\u1ebft l\u1edbn, n\u1ebfu kh\u00f4ng tr\u1ea3 v\u1ec1 False. H\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 False n\u1ebfu t\u1eeb \u0111i\u1ec3n \u0111\u01b0\u1ee3c cung c\u1ea5p l\u00e0 tr\u1ed1ng. V\u00ed d\u1ee5: check_dict_case{\"a\":\"apple\", \"b\":\"banana\"}) s\u1ebd tr\u1ea3 v\u1ec1 True. check_dict_case{\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) s\u1ebd tr\u1ea3 v\u1ec1 False. check_dict_case{\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) s\u1ebd tr\u1ea3 v\u1ec1 False. check_dict_case{\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) False s\u1ebd tr\u1ea3 v\u1ec1 check.dict_case{\"\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Th\u1ef1c hi\u1ec7n m\u1ed9t h\u00e0m l\u1ea5y m\u1ed9t s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m v\u00e0 tr\u1ea3 v\u1ec1 m\u1ea3ng c\u1ee7a n s\u1ed1 nguy\u00ean \u0111\u1ea7u ti\u00ean l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1 v\u00e0 nh\u1ecf h\u01a1n n. v\u00ed d\u1ee5: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Ho\u00e0n th\u00e0nh h\u00e0m l\u1ea5y hai s\u1ed1 nguy\u00ean v\u00e0 tr\u1ea3 v\u1ec1 s\u1ea3n ph\u1ea9m c\u1ee7a c\u00e1c ch\u1eef s\u1ed1 \u0111\u01a1n v\u1ecb c\u1ee7a ch\u00fang. Gi\u1ea3 s\u1eed \u0111\u1ea7u v\u00e0o lu\u00f4n lu\u00f4n h\u1ee3p l\u1ec7. V\u00ed d\u1ee5: nh\u00e2n 148, 412) s\u1ebd tr\u1ea3 v\u1ec1 16. nh\u00e2n 19 28, 28 s\u1ebd tr\u1ea3 v\u1ec1 72. nh\u00e2n 2020, 1851 s\u1ebd tr\u1ea3 v\u1ec1 0. nh\u00e2n 14-15 s\u1ebd tr\u1ea3 v\u1ec1 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Cho m\u1ed9t chu\u1ed7i s, \u0111\u1ebfm s\u1ed1 nguy\u00ean \u00e2m ch\u1eef c\u00e1i l\u1edbn trong c\u00e1c ch\u1ec9 s\u1ed1 ch\u1eb5n. V\u00ed d\u1ee5: count_upper (('aBCdEf') tr\u1ea3 v\u1ec1 1 count_upper (('abcdefg') tr\u1ea3 v\u1ec1 0 count_upper (('dBBE') tr\u1ea3 v\u1ec1 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, b\u1ea1n ph\u1ea3i t\u1ea1o m\u1ed9t \u0111\u1ed1ng \u0111\u00e1 n c\u1ea5p. C\u1ea5p \u0111\u1ea7u ti\u00ean c\u00f3 n \u0111\u00e1. S\u1ed1 l\u01b0\u1ee3ng \u0111\u00e1 trong c\u1ea5p ti\u1ebfp theo l\u00e0: - s\u1ed1 l\u1ebb ti\u1ebfp theo n\u1ebfu n l\u00e0 s\u1ed1 l\u1ebb. - s\u1ed1 ch\u1eb5n ti\u1ebfp theo n\u1ebfu n l\u00e0 s\u1ed1 ch\u1eb5n. Tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng \u0111\u00e1 trong m\u1ed7i c\u1ea5p trong m\u1ed9t danh s\u00e1ch, trong \u0111\u00f3 ph\u1ea7n t\u1eed \u1edf ch\u1ec9 s\u1ed1 i \u0111\u1ea1i di\u1ec7n cho s\u1ed1 l\u01b0\u1ee3ng \u0111\u00e1 trong c\u1ea5p (i + 1). V\u00ed d\u1ee5:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i t\u1eeb \u0111\u01b0\u1ee3c t\u00e1ch ra b\u1edfi d\u1ea5u ph\u1ea9y ho\u1eb7c kho\u1ea3ng tr\u1ed1ng. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 chia chu\u1ed7i th\u00e0nh c\u00e1c t\u1eeb v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng t\u1eeb. V\u00ed d\u1ee5: words_string ((\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"] words_string ((\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"H\u00e0m n\u00e0y l\u1ea5y hai s\u1ed1 d\u01b0\u01a1ng x v\u00e0 y v\u00e0 tr\u1ea3 v\u1ec1 s\u1ed1 nguy\u00ean ch\u1eb5n l\u1edbn nh\u1ea5t trong ph\u1ea1m vi [x, y] bao g\u1ed3m. N\u1ebfu kh\u00f4ng c\u00f3 s\u1ed1 nh\u01b0 v\u1eady, th\u00ec h\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 -1. V\u00ed d\u1ee5: choose_num(12, 15) = 14 choose_num(13, 12) = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c \u0111\u01b0a ra hai s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n v\u00e0 m, v\u00e0 nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 t\u00ednh trung b\u00ecnh c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean t\u1eeb n \u0111\u1ebfn m (bao g\u1ed3m n v\u00e0 m). X\u1ebfp tr\u00f2n c\u00e2u tr\u1ea3 l\u1eddi \u0111\u1ebfn s\u1ed1 nguy\u00ean g\u1ea7n nh\u1ea5t v\u00e0 chuy\u1ec3n \u0111\u1ed5i n\u00f3 th\u00e0nh nh\u1ecb ph\u00e2n. N\u1ebfu n l\u1edbn h\u01a1n m, tr\u1ea3 v\u1ec1 -1. V\u00ed d\u1ee5: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b11\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Cho m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng x. tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c y\u1ebfu t\u1ed1 m\u00e0 kh\u00f4ng c\u00f3 b\u1ea5t k\u1ef3 ch\u1eef s\u1ed1 ch\u1eb5n. L\u01b0u \u00fd: Danh s\u00e1ch tr\u1ea3 v\u1ec1 n\u00ean \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n. V\u00ed d\u1ee5:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng s\u1ed1 nguy\u00ean, s\u1eafp x\u1ebfp c\u00e1c s\u1ed1 nguy\u00ean n\u1eb1m gi\u1eefa 1 v\u00e0 9 bao g\u1ed3m, \u0111\u1ea3o ng\u01b0\u1ee3c m\u1ea3ng k\u1ebft qu\u1ea3, v\u00e0 sau \u0111\u00f3 thay th\u1ebf m\u1ed7i ch\u1eef s\u1ed1 b\u1eb1ng t\u00ean t\u01b0\u01a1ng \u1ee9ng c\u1ee7a n\u00f3 t\u1eeb \"M\u1ed9t\", \"Hai\", \"Ba\", \"B\u1ed1n\", \"N\u0103m\", \"S\u00e1u\", \"B\u1ea3y\", \"T\u00e1m\", \"Ch\u00edn\". V\u00ed d\u1ee5: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> s\u1eafp x\u1ebfp arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> s\u1eafp x\u1ebfp ng\u01b0\u1ee3c arr -> [8, 5, 4, 3, 2, 2, 1, 1] tr\u1ea3 v\u1ec1 [\"T\u00e1m\", \"B\u1ed1n\", \"Ba\", \"Ba\", \"Hai\", \"Hai\", \"M\u1ed9t\", \"M\u1ed9t\"] N\u1ebfu m\u1ea3ng tr\u1ed1ng, tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng tr\u1ed1ng: arr = [] tr\u1ea3 v\u1ec1 [] N\u1ebfu m\u1ea3ng c\u00f3 b\u1ea5t k\u1ef3 s\u1ed1 k\u1ef3 l\u1ea1 n\u00e0o, b\u1ecf qua n\u00f3: arr = [1, -1, 55] -> s\u1eafp x\u1ebfp -> arr - 1\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Th\u1ef1c hi\u1ec7n h\u00e0m f l\u1ea5y n l\u00e0m tham s\u1ed1, v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch k\u00edch th\u01b0\u1edbc n, nh\u01b0 v\u1eady gi\u00e1 tr\u1ecb c\u1ee7a ph\u1ea7n t\u1eed \u1edf ch\u1ec9 s\u1ed1 i l\u00e0 h\u1ec7 s\u1ed1 c\u1ee7a i n\u1ebfu i l\u00e0 c\u1eb7p ho\u1eb7c t\u1ed5ng c\u00e1c s\u1ed1 t\u1eeb 1 \u0111\u1ebfn i n\u1ebfu kh\u00f4ng. i b\u1eaft \u0111\u1ea7u t\u1eeb 1. h\u1ec7 s\u1ed1 c\u1ee7a i l\u00e0 nh\u00e2n c\u00e1c s\u1ed1 t\u1eeb 1 \u0111\u1ebfn i (1 * 2 *... * i). V\u00ed d\u1ee5: f ((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 m\u1ed9t tuple c\u00f3 s\u1ed1 palindromes nguy\u00ean ch\u1eb5n v\u00e0 l\u1ebb n\u1eb1m trong ph\u1ea1m vi ((1, n), bao g\u1ed3m. V\u00ed d\u1ee51: \u0111\u1ea7u v\u00e0o: 3 \u0110\u1ea7u ra: (1, 2) Gi\u1ea3i th\u00edch: Palindromes nguy\u00ean l\u00e0 1, 2, 3. m\u1ed9t trong s\u1ed1 \u0111\u00f3 l\u00e0 ch\u1eb5n, v\u00e0 hai trong s\u1ed1 \u0111\u00f3 l\u00e0 l\u1ebb. V\u00ed d\u1ee52: \u0111\u1ea7u v\u00e0o: 12 \u0110\u1ea7u ra: (4, 6) Gi\u1ea3i th\u00edch: Palindromes nguy\u00ean l\u00e0 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. b\u1ed1n trong s\u1ed1 \u0111\u00f3 l\u00e0 ch\u1eb5n, v\u00e0 6 trong s\u1ed1 \u0111\u00f3 l\u00e0 l\u1ebb. L\u01b0u \u00fd: 1. 1 <= n <= 10^3 2. tuple \u0111\u00e3 tr\u1ea3 v\u1ec1 s\u1ed1 palindromes nguy\u00ean ch\u1eb5n v\u00e0 l\u1ebb t\u01b0\u01a1ng \u1ee9ng.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Vi\u1ebft h\u00e0m count_nums l\u1ea5y m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean v\u00e0 tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng c\u00e1c ph\u1ea7n t\u1eed c\u00f3 t\u1ed5ng s\u1ed1 ch\u1eef s\u1ed1 > 0. N\u1ebfu m\u1ed9t s\u1ed1 l\u00e0 \u00e2m, th\u00ec ch\u1eef s\u1ed1 \u0111\u1ea7u ti\u00ean \u0111\u01b0\u1ee3c k\u00fd c\u1ee7a n\u00f3 s\u1ebd l\u00e0 \u00e2m: v\u00ed d\u1ee5: -123 c\u00f3 ch\u1eef s\u1ed1 k\u00fd -1, 2 v\u00e0 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Ch\u00fang ta c\u00f3 m\u1ed9t m\u1ea3ng 'arr' g\u1ed3m N s\u1ed1 nguy\u00ean arr[1], arr[2],..., arr[N].C\u00e1c s\u1ed1 trong m\u1ea3ng s\u1ebd \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp ng\u1eabu nhi\u00ean. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 x\u00e1c \u0111\u1ecbnh li\u1ec7u c\u00f3 th\u1ec3 s\u1eafp x\u1ebfp m\u1ed9t m\u1ea3ng theo th\u1ee9 t\u1ef1 kh\u00f4ng gi\u1ea3m b\u1eb1ng c\u00e1ch th\u1ef1c hi\u1ec7n c\u00e1c ho\u1ea1t \u0111\u1ed9ng sau tr\u00ean m\u1ea3ng \u0111\u00e3 cho: B\u1ea1n \u0111\u01b0\u1ee3c ph\u00e9p th\u1ef1c hi\u1ec7n ho\u1ea1t \u0111\u1ed9ng d\u1ecbch chuy\u1ec3n sang ph\u1ea3i b\u1ea5t k\u1ef3 s\u1ed1 l\u1ea7n n\u00e0o. M\u1ed9t ho\u1ea1t \u0111\u1ed9ng d\u1ecbch chuy\u1ec3n sang ph\u1ea3i c\u00f3 ngh\u0129a l\u00e0 d\u1ecbch chuy\u1ec3n t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a m\u1ea3ng b\u1eb1ng m\u1ed9t v\u1ecb tr\u00ed theo h\u01b0\u1edbng ph\u1ea3i. Ph\u1ea7n t\u1eed cu\u1ed1i c\u00f9ng c\u1ee7a m\u1ea3ng s\u1ebd \u0111\u01b0\u1ee3c di chuy\u1ec3n \u0111\u1ebfn v\u1ecb tr\u00ed b\u1eaft \u0111\u1ea7u trong m\u1ea3ng t\u1ee9c l\u00e0 ch\u1ec9 s\u1ed1 0. N\u1ebfu c\u00f3 th\u1ec3 l\u1ea5y m\u1ea3ng \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp b\u1eb1ng c\u00e1ch th\u1ef1c hi\u1ec7n ho\u1ea1t \u0111\u1ed9ng tr\u00ean th\u00ec tr\u1ea3 v\u1ec1 True c\u00f2n tr\u1ea3 v\u1ec1 False. N\u1ebfu m\u1ea3ng \u0111\u00e3 cho tr\u1ed1ng th\u00ec tr\u1ea3 v\u1ec1 True. L\u01b0u \u00fd: Danh s\u00e1ch \u0111\u00e3 cho \u0111\u01b0\u1ee3c \u0111\u1ea3m b\u1ea3o c\u00f3 c\u00e1c ph\u1ea7n t\u1eed duy nh\u1ea5t. V\u00ed d\u1ee5:\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Trong v\u1ea5n \u0111\u1ec1 n\u00e0y, b\u1ea1n s\u1ebd th\u1ef1c hi\u1ec7n m\u1ed9t h\u00e0m l\u1ea5y hai danh s\u00e1ch c\u00e1c s\u1ed1, v\u00e0 x\u00e1c \u0111\u1ecbnh li\u1ec7u c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n m\u1ed9t trao \u0111\u1ed5i c\u00e1c y\u1ebfu t\u1ed1 gi\u1eefa ch\u00fang \u0111\u1ec3 l\u00e0m cho lst1 tr\u1edf th\u00e0nh m\u1ed9t danh s\u00e1ch ch\u1ec9 c\u00f3 c\u00e1c s\u1ed1 ch\u1eb5n hay kh\u00f4ng. Kh\u00f4ng c\u00f3 gi\u1edbi h\u1ea1n v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng c\u00e1c y\u1ebfu t\u1ed1 trao \u0111\u1ed5i gi\u1eefa lst1 v\u00e0 lst2. N\u1ebfu c\u00f3 th\u1ec3 trao \u0111\u1ed5i c\u00e1c y\u1ebfu t\u1ed1 gi\u1eefa lst1 v\u00e0 lst2 \u0111\u1ec3 l\u00e0m cho t\u1ea5t c\u1ea3 c\u00e1c y\u1ebfu t\u1ed1 c\u1ee7a lst1 \u0111\u1ec1u ch\u1eb5n, tr\u1ea3 v\u1ec1 \"YES\". N\u1ebfu kh\u00f4ng, tr\u1ea3 v\u1ec1 \"NO\". V\u00ed d\u1ee5: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" \u0110\u01b0\u1ee3c gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng c\u00e1c danh s\u00e1ch \u0111\u1ea7u v\u00e0o s\u1ebd kh\u00f4ng tr\u1ed1ng.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"V\u00ed d\u1ee5: histogram ((('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram ((('a b b a') == {'a': 2, 'b': 2} histogram ((('a b c a b') == {'a': 2, 'b': 2} histogram ((('b b a') == {'a': 2, 'b': 2} histogram ((('b b a') == {'b 4} histogram'(((') == {'b 4}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Nhi\u1ec7m v\u1ee5 Ch\u00fang ta \u0111\u01b0\u1ee3c cung c\u1ea5p hai chu\u1ed7i s v\u00e0 c, b\u1ea1n ph\u1ea3i x\u00f3a t\u1ea5t c\u1ea3 c\u00e1c k\u00fd t\u1ef1 trong s b\u1eb1ng b\u1ea5t k\u1ef3 k\u00fd t\u1ef1 n\u00e0o trong c sau \u0111\u00f3 ki\u1ec3m tra xem chu\u1ed7i k\u1ebft qu\u1ea3 c\u00f3 ph\u1ea3i l\u00e0 palindrome hay kh\u00f4ng. M\u1ed9t chu\u1ed7i \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 palindrome n\u1ebfu n\u00f3 \u0111\u1ecdc ng\u01b0\u1ee3c c\u00f9ng v\u1edbi ph\u00eda tr\u01b0\u1edbc. B\u1ea1n n\u00ean tr\u1ea3 v\u1ec1 m\u1ed9t tuple ch\u1ee9a chu\u1ed7i k\u1ebft qu\u1ea3 v\u00e0 True\/False \u0111\u1ec3 ki\u1ec3m tra. V\u00ed d\u1ee5 cho s = \"abcde\", c = \"ae\", k\u1ebft qu\u1ea3 n\u00ean l\u00e0 ('bcd', False) cho s = \"abcdef\", c = \"b\" k\u1ebft qu\u1ea3 n\u00ean l\u00e0 ('acdef', False) cho s = \"abcdedcba\", c = \"ab\", k\u1ebft qu\u1ea3 n\u00ean l\u00e0 ('cdedc', True)\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Cho m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i, trong \u0111\u00f3 m\u1ed7i chu\u1ed7i ch\u1ec9 bao g\u1ed3m c\u00e1c ch\u1eef s\u1ed1, tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch. M\u1ed7i ph\u1ea7n t\u1eed i c\u1ee7a \u0111\u1ea7u ra ph\u1ea3i l\u00e0 \"s\u1ed1 c\u00e1c ph\u1ea7n t\u1eed l\u1ebb trong chu\u1ed7i i c\u1ee7a \u0111\u1ea7u v\u00e0o\". n\u01a1i t\u1ea5t c\u1ea3 c\u00e1c i n\u00ean \u0111\u01b0\u1ee3c thay th\u1ebf b\u1eb1ng s\u1ed1 c\u00e1c ch\u1eef s\u1ed1 l\u1ebb trong chu\u1ed7i i c\u1ee7a \u0111\u1ea7u v\u00e0o.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng s\u1ed1 nguy\u00ean n, t\u00ecm t\u1ed5ng t\u1ed1i thi\u1ec3u c\u1ee7a b\u1ea5t k\u1ef3 ti\u1ec3u m\u1ea3ng s\u1ed1 kh\u00f4ng r\u1ed7ng n\u00e0o. V\u00ed d\u1ee5 minSubArraySum (([2, 3, 4, 1, 2, 4]) == 1 minSubArraySum (([-1, -2, -3]) == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t l\u01b0\u1edbi h\u00ecnh ch\u1eef nh\u1eadt c\u1ee7a gi\u1ebfng. M\u1ed7i h\u00e0ng \u0111\u1ea1i di\u1ec7n cho m\u1ed9t gi\u1ebfng duy nh\u1ea5t, v\u00e0 m\u1ed7i 1 trong m\u1ed9t h\u00e0ng \u0111\u1ea1i di\u1ec7n cho m\u1ed9t \u0111\u01a1n v\u1ecb n\u01b0\u1edbc duy nh\u1ea5t. M\u1ed7i gi\u1ebfng c\u00f3 m\u1ed9t x\u00f4 t\u01b0\u01a1ng \u1ee9ng c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 chi\u1ebft xu\u1ea5t n\u01b0\u1edbc t\u1eeb n\u00f3, v\u00e0 t\u1ea5t c\u1ea3 c\u00e1c x\u00f4 c\u00f3 c\u00f9ng dung l\u01b0\u1ee3ng. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 s\u1eed d\u1ee5ng c\u00e1c x\u00f4 \u0111\u1ec3 l\u00e0m tr\u1ed1ng c\u00e1c gi\u1ebfng. Xu\u1ea5t l\u01b0\u1ee3ng s\u1ed1 l\u1ea7n b\u1ea1n c\u1ea7n \u0111\u1ec3 h\u1ea1 xu\u1ed1ng c\u00e1c x\u00f4. V\u00ed d\u1ee5 1: Input: grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]] bucket_capacity: 1 Output: 62: Input: grid: [[0,0,1,1], [0,0,0,0], [1,1,1], [0,1,1]] bucket_capacity: 2 Output: 53: Input: [[:0,0,0], [0,0,0]] bu\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Trong Kata n\u00e0y, b\u1ea1n ph\u1ea3i s\u1eafp x\u1ebfp m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m theo s\u1ed1 m\u1ed9t trong bi\u1ec3u di\u1ec5n nh\u1ecb ph\u00e2n c\u1ee7a ch\u00fang theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n. \u0110\u1ed1i v\u1edbi s\u1ed1 l\u01b0\u1ee3ng t\u01b0\u01a1ng t\u1ef1 c\u1ee7a m\u1ed9t, s\u1eafp x\u1ebfp d\u1ef1a tr\u00ean gi\u00e1 tr\u1ecb th\u1eadp ph\u00e2n. N\u00f3 ph\u1ea3i \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n nh\u01b0 sau:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"N\u1ebfu chu\u1ed7i s l\u00e0 tr\u1ed1ng th\u00ec h\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch tr\u1ed1ng. L\u01b0u \u00fd: b\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh chu\u1ed7i \u0111\u1ea7u v\u00e0o ch\u1ec9 ch\u1ee9a c\u00e1c ch\u1eef c\u00e1i v\u00e0 kho\u1ea3ng tr\u1ed1ng. V\u00ed d\u1ee5: select_words (\"Mary had a little lamb\", 4) ==> [\"little\"] select_words (\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words \"simple white space\", 2) ==> [] select_words (\"Hello world\", 4) ==> [\"world\"] select_words (\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t t\u1eeb. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 t\u00ecm ra nguy\u00ean \u00e2m g\u1ea7n nh\u1ea5t n\u1eb1m gi\u1eefa hai ph\u1ee5 \u00e2m t\u1eeb b\u00ean ph\u1ea3i c\u1ee7a t\u1eeb (c\u00f3 t\u00ednh nh\u1ea1y c\u1ea3m v\u1edbi ch\u1eef c\u00e1i). C\u00e1c nguy\u00ean \u00e2m \u1edf \u0111\u1ea7u v\u00e0 cu\u1ed1i kh\u00f4ng \u0111\u01b0\u1ee3c t\u00ednh. Tr\u1ea3 v\u1ec1 chu\u1ed7i tr\u1ed1ng n\u1ebfu b\u1ea1n kh\u00f4ng t\u00ecm th\u1ea5y b\u1ea5t k\u1ef3 nguy\u00ean \u00e2m n\u00e0o \u0111\u00e1p \u1ee9ng \u0111i\u1ec1u ki\u1ec7n tr\u00ean. B\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng chu\u1ed7i \u0111\u01b0\u1ee3c \u0111\u01b0a ra ch\u1ec9 ch\u1ee9a ch\u1eef c\u00e1i ti\u1ebfng Anh. V\u00ed d\u1ee5: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    C\u1ee5m m\u1ed9t m\u1ea3ng arr c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean v\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng k, tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp chi\u1ec1u d\u00e0i k v\u1edbi s\u1ed1 k t\u1ed1i \u0111a trong arr. V\u00ed d\u1ee51: \u0110\u1ea7u v\u00e0o: arr = [-3, -4, 5], k = 3 \u0110\u1ea7u ra: [-4, -3, 5] V\u00ed d\u1ee52: \u0110\u1ea7u v\u00e0o: arr = [4, -4, 4], k = 2 \u0110\u1ea7u ra: [4, 4] V\u00ed d\u1ee53: \u0110\u1ea7u v\u00e0o: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 \u0110\u1ea7u ra: [2] L\u01b0u \u00fd: 1. chi\u1ec1u d\u00e0i c\u1ee7a m\u1ea3ng s\u1ebd n\u1eb1m trong ph\u1ea1m vi [1, 1000]. 2. C\u00e1c ph\u1ea7n t\u1eed trong m\u1ea3ng s\u1ebd n\u1eb1m trong ph\u1ea1m vi [-1000, 1000]. 3. 0 <= k <= len (arr)\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Cho m\u1ed9t danh s\u00e1ch kh\u00f4ng tr\u1ed1ng c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean, tr\u1ea3 v\u1ec1 t\u1ed5ng c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed l\u1ebb \u1edf v\u1ecb tr\u00ed ch\u1eb5n. V\u00ed d\u1ee5 gi\u1ea3i ph\u00e1p (([5, 8, 7, 1]) ==> 12 gi\u1ea3i ph\u00e1p (([3, 3, 3, 3]) ==> 9 gi\u1ea3i ph\u00e1p (([30, 13, 24, 321]) ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng kh\u00f4ng r\u1ed7ng c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean arr v\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean k, tr\u1ea3 v\u1ec1 t\u1ed5ng c\u00e1c ph\u1ea7n t\u1eed v\u1edbi t\u1ed1i \u0111a hai ch\u1eef s\u1ed1 t\u1eeb c\u00e1c ph\u1ea7n t\u1eed \u0111\u1ea7u ti\u00ean k c\u1ee7a arr. V\u00ed d\u1ee5: \u0111\u1ea7u v\u00e0o: arr = [111,21,3,4000,5,6,7,8,9], k = 4 \u0111\u1ea7u ra: 24 # t\u1ed5ng c\u1ee7a 21 + 3 Ranh gi\u1edbi: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    V\u1edbi m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp c\u00f3 c\u00e1c s\u1ed1 l\u1ebb trong chu\u1ed7i collatz. Gi\u1ea3 thuy\u1ebft Collatz l\u00e0 m\u1ed9t gi\u1ea3 thuy\u1ebft trong to\u00e1n h\u1ecdc li\u00ean quan \u0111\u1ebfn m\u1ed9t chu\u1ed7i \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh nh\u01b0 sau: b\u1eaft \u0111\u1ea7u v\u1edbi b\u1ea5t k\u1ef3 s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n n\u00e0o. Sau \u0111\u00f3, m\u1ed7i thu\u1eadt ng\u1eef \u0111\u01b0\u1ee3c l\u1ea5y t\u1eeb thu\u1eadt ng\u1eef tr\u01b0\u1edbc nh\u01b0 sau: n\u1ebfu thu\u1eadt ng\u1eef tr\u01b0\u1edbc l\u00e0 ch\u1eb5n, thu\u1eadt ng\u1eef ti\u1ebfp theo l\u00e0 m\u1ed9t n\u1eeda c\u1ee7a thu\u1eadt ng\u1eef tr\u01b0\u1edbc. N\u1ebfu thu\u1eadt ng\u1eef tr\u01b0\u1edbc l\u00e0 l\u1ebb, thu\u1eadt ng\u1eef ti\u1ebfp theo l\u00e0 3 l\u1ea7n thu\u1eadt ng\u1eef tr\u01b0\u1edbc c\u1ed9ng 1. Gi\u1ea3 thuy\u1ebft l\u00e0 b\u1ea5t k\u1ec3 gi\u00e1 tr\u1ecb c\u1ee7a n l\u00e0 g\u00ec, chu\u1ed7i s\u1ebd lu\u00f4n \u0111\u1ea1t \u0111\u1ebfn 1. L\u01b0u \u00fd: 1. Collatz(1) l\u00e0 [1].\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"B\u1ea1n ph\u1ea3i vi\u1ebft m\u1ed9t h\u00e0m x\u00e1c nh\u1eadn m\u1ed9t chu\u1ed7i ng\u00e0y nh\u1ea5t \u0111\u1ecbnh v\u00e0 tr\u1ea3 v\u1ec1 True n\u1ebfu ng\u00e0y \u0111\u00f3 l\u00e0 h\u1ee3p l\u1ec7 n\u1ebfu kh\u00f4ng th\u00ec False. Ng\u00e0y s\u1ebd h\u1ee3p l\u1ec7 n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c quy t\u1eafc sau \u0111\u00e2y \u0111\u01b0\u1ee3c \u0111\u00e1p \u1ee9ng: 1. D\u00e3y ng\u00e0y kh\u00f4ng tr\u1ed1ng. 2. S\u1ed1 ng\u00e0y kh\u00f4ng \u00edt h\u01a1n 1 ho\u1eb7c nhi\u1ec1u h\u01a1n 31 ng\u00e0y cho th\u00e1ng 1,3,5,7,8,10,12. V\u00e0 s\u1ed1 ng\u00e0y kh\u00f4ng \u00edt h\u01a1n 1 ho\u1eb7c nhi\u1ec1u h\u01a1n 30 ng\u00e0y cho th\u00e1ng 4,6,9,11. V\u00e0, s\u1ed1 ng\u00e0y kh\u00f4ng \u00edt h\u01a1n 1 ho\u1eb7c nhi\u1ec1u h\u01a1n 29 cho th\u00e1ng 2. 3. C\u00e1c th\u00e1ng kh\u00f4ng n\u00ean \u00edt h\u01a1n 1 ho\u1eb7c nhi\u1ec1u h\u01a1n 12. 4. Ng\u00e0y n\u00ean \u1edf \u0111\u1ecbnh d\u1ea1ng: mm-dd-yyyy v\u00ed d\u1ee5: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date (('04-040') => False_valid_date (('06-04-2020') => True_valid_date (('06\/04\/2020') => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c \u0111\u01b0a ra hai kho\u1ea3ng th\u1eddi gian, trong \u0111\u00f3 m\u1ed7i kho\u1ea3ng l\u00e0 m\u1ed9t c\u1eb7p s\u1ed1 nguy\u00ean. V\u00ed d\u1ee5, kho\u1ea3ng = (b\u1eaft \u0111\u1ea7u, k\u1ebft th\u00fac) = (1, 2). C\u00e1c kho\u1ea3ng th\u1eddi gian \u0111\u01b0\u1ee3c \u0111\u01b0a ra l\u00e0 \u0111\u00f3ng, c\u00f3 ngh\u0129a l\u00e0 kho\u1ea3ng th\u1eddi gian (b\u1eaft \u0111\u1ea7u, k\u1ebft th\u00fac) bao g\u1ed3m c\u1ea3 b\u1eaft \u0111\u1ea7u v\u00e0 k\u1ebft th\u00fac. \u0110\u1ed1i v\u1edbi m\u1ed7i kho\u1ea3ng th\u1eddi gian \u0111\u01b0\u1ee3c \u0111\u01b0a ra, gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng b\u1eaft \u0111\u1ea7u c\u1ee7a n\u00f3 nh\u1ecf h\u01a1n ho\u1eb7c b\u1eb1ng cu\u1ed1i c\u1ee7a n\u00f3. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 x\u00e1c \u0111\u1ecbnh xem chi\u1ec1u d\u00e0i giao \u0111i\u1ec3m c\u1ee7a hai kho\u1ea3ng th\u1eddi gian n\u00e0y l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1. V\u00ed d\u1ee5, \u0111\u01b0\u1eddng giao c\u1ee7a c\u00e1c kho\u1ea3ng th\u1eddi gian (1, 3), (2, 4) l\u00e0 (2, 3) c\u00f3 chi\u1ec1u d\u00e0i l\u00e0 1, m\u00e0 kh\u00f4ng ph\u1ea3i l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1. N\u1ebfu chi\u1ec1u d\u00e0i c\u1ee7a giao \u0111i\u1ec3m l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1, tr\u1ea3 v\u1ec1 \"V\u00c0\", n\u1ebfu kh\u00f4ng, tr\u1ea3 v\u1ec1 \"Kh\u00f4ng\". N\u1ebfu hai kho\u1ea3ng th\u1eddi gian kh\u00f4ng giao nhau, tr\u1ea3 v\u1ec1 \"Kh\u00f4ng\". [input\/output]\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t m\u1ea3ng arr c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean v\u00e0 b\u1ea1n c\u1ea7n ph\u1ea3i tr\u1ea3 v\u1ec1 t\u1ed5ng s\u1ed1 l\u01b0\u1ee3ng c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean nh\u00e2n nh\u00e2n v\u1edbi s\u1ea3n ph\u1ea9m c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c d\u1ea5u hi\u1ec7u c\u1ee7a m\u1ed7i s\u1ed1 trong m\u1ea3ng, \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n b\u1edfi 1, -1 ho\u1eb7c 0. L\u01b0u \u00fd: tr\u1ea3 v\u1ec1 None cho arr tr\u1ed1ng. V\u00ed d\u1ee5:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    B\u1ea1n c\u00f3 th\u1ec3 b\u1eaft \u0111\u1ea7u t\u1eeb b\u1ea5t k\u1ef3 \u00f4 n\u00e0o, v\u00e0 trong m\u1ed7i b\u01b0\u1edbc b\u1ea1n c\u00f3 th\u1ec3 di chuy\u1ec3n \u0111\u1ebfn b\u1ea5t k\u1ef3 \u00f4 h\u00e0ng x\u00f3m n\u00e0o, n\u00f3i c\u00e1ch kh\u00e1c, b\u1ea1n c\u00f3 th\u1ec3 \u0111i \u0111\u1ebfn c\u00e1c \u00f4 c\u00f3 c\u00f9ng c\u1ea1nh v\u1edbi \u00f4 hi\u1ec7n t\u1ea1i c\u1ee7a b\u1ea1n. Xin l\u01b0u \u00fd r\u1eb1ng m\u1ed9t \u0111\u01b0\u1eddng d\u1eabn c\u00f3 chi\u1ec1u d\u00e0i k c\u00f3 ngh\u0129a l\u00e0 truy c\u1eadp ch\u00ednh x\u00e1c k \u00f4 (kh\u00f4ng nh\u1ea5t thi\u1ebft ph\u1ea3i kh\u00e1c bi\u1ec7t). B\u1ea1n KH\u00d4NG THT \u0111i ra kh\u1ecfi l\u01b0\u1edbi. M\u1ed9t \u0111\u01b0\u1eddng d\u1eabn A (d\u00e0i k) \u0111\u01b0\u1ee3c coi l\u00e0 nh\u1ecf h\u01a1n m\u1ed9t \u0111\u01b0\u1eddng d\u1eabn B (d\u00e0i k) n\u1ebfu sau khi l\u1eadp danh s\u00e1ch th\u1ee9 t\u1ef1 c\u00e1c gi\u00e1 tr\u1ecb tr\u00ean c\u00e1c \u00f4 A v\u00e0 B (h\u00e3y g\u1ecdi ch\u00fang l\u00e0 lA_st v\u00e0 lA_st), lA_st l\u00e0 nh\u1ecf h\u01a1n t\u1eeb ng\u1eef lA_st, b\u1eb1ng c\u00e1ch kh\u00e1c, m\u1ed9t ch\u1ec9 s\u1ed1 nguy\u00ean trong l\u01b0\u1edbi c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh l\u00e0: [A_1, lA_1, lA_1, lA_2, lA_1, lA\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"M\u1ecdi ng\u01b0\u1eddi \u0111\u1ec1u bi\u1ebft chu\u1ed7i Fibonacci, n\u00f3 \u0111\u00e3 \u0111\u01b0\u1ee3c c\u00e1c nh\u00e0 to\u00e1n h\u1ecdc nghi\u00ean c\u1ee9u s\u00e2u s\u1eafc trong v\u00e0i th\u1ebf k\u1ef7 qua. Tuy nhi\u00ean, nh\u1eefng g\u00ec m\u1ecdi ng\u01b0\u1eddi kh\u00f4ng bi\u1ebft l\u00e0 chu\u1ed7i Tribonacci. D\u00f2ng chu\u1ed7i Tribonacci \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh b\u1edfi s\u1ef1 l\u1eb7p l\u1ea1i: tri(1) = 3 tri(n) = 1 + n \/ 2, n\u1ebfu n l\u00e0 s\u1ed1 ch\u1eb5n. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), n\u1ebfu n l\u00e0 s\u1ed1 l\u1ebb. V\u00ed d\u1ee5: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m n, b\u1ea1n ph\u1ea3i tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 \u0111\u1ea7u ti\u00ean n + 1 c\u1ee7a chu\u1ed7i Tribonacci. V\u00ed d\u1ee5: tri(3) = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 s\u1ea3n ph\u1ea9m c\u1ee7a c\u00e1c ch\u1eef s\u1ed1 l\u1ebb. tr\u1ea3 v\u1ec1 0 n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c ch\u1eef s\u1ed1 l\u00e0 ch\u1eb5n. V\u00ed d\u1ee5: ch\u1eef s\u1ed1\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c \u0111\u01b0a ra m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1. B\u1ea1n c\u1ea7n tr\u1ea3 v\u1ec1 t\u1ed5ng s\u1ed1 b\u00ecnh ph\u01b0\u01a1ng trong danh s\u00e1ch \u0111\u01b0\u1ee3c \u0111\u01b0a ra, tr\u00f2n m\u1ed7i y\u1ebfu t\u1ed1 trong danh s\u00e1ch l\u00ean \u0111\u1ebfn int tr\u00ean ((Ch\u1ec9) \u0111\u1ea7u ti\u00ean. V\u00ed d\u1ee5: \u0110\u1ed1i v\u1edbi lst = [1,2,3] \u0111\u1ea7u ra n\u00ean l\u00e0 14 \u0110\u1ed1i v\u1edbi lst = [1,4,9] \u0111\u1ea7u ra n\u00ean l\u00e0 98 \u0110\u1ed1i v\u1edbi lst = [1,3,5,7] \u0111\u1ea7u ra n\u00ean l\u00e0 84 \u0110\u1ed1i v\u1edbi lst = [1.4,4.2,0] \u0111\u1ea7u ra n\u00ean l\u00e0 29 \u0110\u1ed1i v\u1edbi lst = [-2.4,1,1] \u0111\u1ea7u ra n\u00ean l\u00e0 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"T\u1ea1o m\u1ed9t h\u00e0m tr\u1ea3 v\u1ec1 ch\u1ec9 s\u1ed1 l\u1edbn nh\u1ea5t c\u1ee7a m\u1ed9t ph\u1ea7n t\u1eed kh\u00f4ng l\u1edbn h\u01a1n ho\u1eb7c b\u1eb1ng ph\u1ea7n t\u1eed ngay tr\u01b0\u1edbc n\u00f3. N\u1ebfu kh\u00f4ng c\u00f3 ph\u1ea7n t\u1eed nh\u01b0 v\u1eady th\u00ec tr\u1ea3 v\u1ec1 -1. M\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u01b0a ra s\u1ebd kh\u00f4ng ch\u1ee9a c\u00e1c gi\u00e1 tr\u1ecb tr\u00f9ng l\u1eb7p. V\u00ed d\u1ee5: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    T\u1ea1o m\u1ed9t h\u00e0m l\u1ea5y s\u1ed1 nguy\u00ean, float, ho\u1eb7c chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho s\u1ed1 th\u1ef1c v\u00e0 tr\u1ea3 v\u1ec1 bi\u1ebfn l\u1edbn h\u01a1n trong lo\u1ea1i bi\u1ebfn \u0111\u00e3 cho. Tr\u1ea3 v\u1ec1 None n\u1ebfu c\u00e1c gi\u00e1 tr\u1ecb l\u00e0 b\u1eb1ng nhau. L\u01b0u \u00fd: N\u1ebfu m\u1ed9t s\u1ed1 th\u1ef1c \u0111\u01b0\u1ee3c \u0111\u1ea1i di\u1ec7n nh\u01b0 m\u1ed9t chu\u1ed7i, \u0111i\u1ec3m tr\u00f4i c\u00f3 th\u1ec3 l\u00e0. ho\u1eb7c, compare_one{1, 2.5) \u00e2 -> 2.5 compare_one{1, \"2,3\") \u00e2 -> \"2,3\" compare_one{5,1\", \"6\") \u00e2 -> \"6\" compare_one{1\", 1) \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"\u0110\u00e1nh gi\u00e1 li\u1ec7u s\u1ed1 n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c vi\u1ebft l\u00e0 t\u1ed5ng c\u1ee7a ch\u00ednh x\u00e1c 4 s\u1ed1 d\u01b0\u01a1ng ch\u1eb5n kh\u00f4ng V\u00ed d\u1ee5 is_equal_to_sum_even (t\u01b0\u01a1ng \u0111\u01b0\u01a1ng) 4) == False is_equal_to_sum_even (t\u01b0\u01a1ng \u0111\u01b0\u01a1ng) 6) == False is_equal_to_sum_even (t\u01b0\u01a1ng \u0111\u01b0\u01a1ng) 8) == True\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"C\u00e1c h\u1ec7 s\u1ed1 Brazil \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a l\u00e0: brazilian_factorial ((n) = n! * (n-1)! * (n-2)! *... * 1! n\u01a1i n > 0 V\u00ed d\u1ee5:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    N\u1ebfu c\u00f3 m\u1ed9t chu\u1ed7i v\u0103n b\u1ea3n, thay th\u1ebf t\u1ea5t c\u1ea3 c\u00e1c kho\u1ea3ng tr\u1ed1ng b\u1eb1ng d\u1ea5u g\u1ea1ch d\u01b0\u1edbi, v\u00e0 n\u1ebfu m\u1ed9t chu\u1ed7i c\u00f3 nhi\u1ec1u h\u01a1n 2 kho\u1ea3ng tr\u1ed1ng li\u00ean ti\u1ebfp, sau \u0111\u00f3 thay th\u1ebf t\u1ea5t c\u1ea3 c\u00e1c kho\u1ea3ng tr\u1ed1ng li\u00ean ti\u1ebfp b\u1eb1ng - fix_spaces ((\"V\u00ed d\u1ee5\") == \"V\u00ed d\u1ee5\" fix_spaces ((\"V\u00ed d\u1ee51\") == \"V\u00ed d\u1ee51\" fix_spaces (((\"V\u00ed d\u1ee52\") == \"_V\u00ed d\u1ee5_2\" fix_spaces ((\"V\u00ed d\u1ee5 3\") == \"_V\u00ed d\u1ee5-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"T\u1ea1o m\u1ed9t h\u00e0m l\u1ea5y m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho t\u00ean t\u1ec7p, v\u00e0 tr\u1ea3 v\u1ec1 'V\u00e2ng' n\u1ebfu t\u00ean t\u1ec7p h\u1ee3p l\u1ec7, v\u00e0 tr\u1ea3 v\u1ec1 'Kh\u00f4ng' n\u1ebfu kh\u00f4ng. T\u00ean t\u1ec7p \u0111\u01b0\u1ee3c coi l\u00e0 h\u1ee3p l\u1ec7 n\u1ebfu v\u00e0 ch\u1ec9 khi t\u1ea5t c\u1ea3 c\u00e1c \u0111i\u1ec1u ki\u1ec7n sau \u0111\u01b0\u1ee3c \u0111\u00e1p \u1ee9ng: - Kh\u00f4ng n\u00ean c\u00f3 nhi\u1ec1u h\u01a1n ba ch\u1eef s\u1ed1 ('0'-'9') trong t\u00ean t\u1ec7p. - T\u00ean t\u1ec7p ch\u1ee9a ch\u00ednh x\u00e1c m\u1ed9t d\u1ea5u ch\u1ea5m '.' - D\u00f2ng ph\u1ee5 tr\u01b0\u1edbc d\u1ea5u ch\u1ea5m kh\u00f4ng n\u00ean tr\u1ed1ng, v\u00e0 n\u00f3 b\u1eaft \u0111\u1ea7u v\u1edbi m\u1ed9t ch\u1eef c\u00e1i t\u1eeb ch\u1eef c\u00e1i Latin ('a'-'z' v\u00e0 'A'Z'). - D\u00f2ng ph\u1ee5 sau d\u1ea5u ch\u1ea5m n\u00ean l\u00e0 m\u1ed9t trong nh\u1eefng ch\u1eef c\u00e1i sau: ['txt', 'exe', 'lld'] V\u00ed d\u1ee5: file_name_check\"(v\u00ed d\u1ee5.txt\") # => 'V\u00e2ng' file_name_check\"(dll.example1\") => 'Kh\u00f4ng' # =>'(\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\"Ch\u1ee9c n\u0103ng n\u00e0y s\u1ebd l\u1ea5y m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean. \u0110\u1ed1i v\u1edbi t\u1ea5t c\u1ea3 c\u00e1c m\u1ee5c trong danh s\u00e1ch, h\u00e0m s\u1ebd b\u00ecnh ph\u01b0\u01a1ng m\u1ee5c nguy\u00ean n\u1ebfu ch\u1ec9 s\u1ed1 c\u1ee7a n\u00f3 l\u00e0 b\u1ed9i s\u1ed1 3 v\u00e0 s\u1ebd l\u1eadp ph\u01b0\u01a1ng m\u1ee5c nguy\u00ean n\u1ebfu ch\u1ec9 s\u1ed1 c\u1ee7a n\u00f3 l\u00e0 b\u1ed9i s\u1ed1 4 v\u00e0 kh\u00f4ng ph\u1ea3i l\u00e0 b\u1ed9i s\u1ed1 3. Ch\u1ee9c n\u0103ng s\u1ebd kh\u00f4ng thay \u0111\u1ed5i c\u00e1c m\u1ee5c trong danh s\u00e1ch m\u00e0 ch\u1ec9 s\u1ed1 kh\u00f4ng ph\u1ea3i l\u00e0 b\u1ed9i s\u1ed1 3 ho\u1eb7c 4. Ch\u1ee9c n\u0103ng sau \u0111\u00f3 s\u1ebd tr\u1ea3 v\u1ec1 t\u1ed5ng c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c m\u1ee5c. V\u00ed d\u1ee5: \u0110\u1ed1i v\u1edbi lst = [1,2,3] \u0111\u1ea7u ra n\u00ean l\u00e0 6 \u0110\u1ed1i v\u1edbi lst = [] \u0111\u1ea7u ra n\u00ean l\u00e0 0 \u0110\u1ed1i v\u1edbi lst = [-1,-5,2,-1,-5] \u0111\u1ea7u ra n\u00ean l\u00e0 -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho m\u1ed9t c\u00e2u, c\u00e2u c\u00f3 ch\u1ee9a m\u1ed9t s\u1ed1 t\u1eeb \u0111\u01b0\u1ee3c t\u00e1ch ra b\u1edfi m\u1ed9t kho\u1ea3ng tr\u1ed1ng, v\u00e0 b\u1ea1n ph\u1ea3i tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i c\u00f3 ch\u1ee9a c\u00e1c t\u1eeb t\u1eeb c\u00e2u ban \u0111\u1ea7u, c\u00f3 chi\u1ec1u d\u00e0i l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1, th\u1ee9 t\u1ef1 c\u1ee7a c\u00e1c t\u1eeb trong chu\u1ed7i m\u1edbi n\u00ean gi\u1ed1ng nh\u01b0 c\u00e2u ban \u0111\u1ea7u. V\u00ed d\u1ee51: \u0110\u1ea7u v\u00e0o: c\u00e2u = \"\u0110\u00e2y l\u00e0 m\u1ed9t b\u00e0i ki\u1ec3m tra\" \u0110\u1ea7u ra: \"l\u00e0\" V\u00ed d\u1ee52: \u0111\u1ea7u v\u00e0o: c\u00e2u = \"ch\u00fang ta \u0111i b\u01a1i\" \u0110\u1ea7u ra: \"\u0111i cho\" Ranh gi\u1edbi: * 1 <= len(sentence) <= 100 * c\u00e2u ch\u1ec9 ch\u1ee9a c\u00e1c ch\u1eef c\u00e1i\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 th\u1ef1c hi\u1ec7n m\u1ed9t h\u00e0m s\u1ebd \u0111\u01a1n gi\u1ea3n h\u00f3a bi\u1ec3u th\u1ee9c x * n. Ch\u1ee9c n\u0103ng tr\u1ea3 v\u1ec1 True n\u1ebfu x * n \u0111\u01b0\u1ee3c \u0111\u1ecbnh gi\u00e1 th\u00e0nh m\u1ed9t s\u1ed1 nguy\u00ean v\u00e0 False n\u1ebfu kh\u00f4ng. C\u1ea3 x v\u00e0 n, l\u00e0 bi\u1ec3u di\u1ec5n chu\u1ed7i c\u1ee7a m\u1ed9t ph\u00e2n s\u1ed1, v\u00e0 c\u00f3 \u0111\u1ecbnh d\u1ea1ng sau, < s\u1ed1>\/< \u0111\u1ecbnh danh> n\u01a1i c\u1ea3 s\u1ed1 v\u00e0 \u0111\u1ecbnh danh l\u00e0 s\u1ed1 nguy\u00ean d\u01b0\u01a1ng. B\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng x, v\u00e0 n l\u00e0 c\u00e1c ph\u00e2n s\u1ed1 h\u1ee3p l\u1ec7, v\u00e0 kh\u00f4ng c\u00f3 s\u1ed1 0 l\u00e0m \u0111\u1ecbnh danh. \u0111\u01a1n gi\u1ea3n h\u00f3a \" 1\/5 \", \"5\/1\") = True \u0111\u01a1n gi\u1ea3n h\u00f3a \" 1\/6 \", \"2\/1\") = False \u0111\u01a1n gi\u1ea3n h\u00f3a \" 7\/10 \", \"10\/2\") = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Vi\u1ebft m\u1ed9t h\u00e0m s\u1eafp x\u1ebfp danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n theo t\u1ed5ng s\u1ed1 ch\u1eef s\u1ed1 c\u1ee7a ch\u00fang. L\u01b0u \u00fd: n\u1ebfu c\u00f3 m\u1ed9t s\u1ed1 m\u1ee5c c\u00f3 t\u1ed5ng s\u1ed1 ch\u1eef s\u1ed1 t\u01b0\u01a1ng t\u1ef1, h\u00e3y s\u1eafp x\u1ebfp ch\u00fang d\u1ef1a tr\u00ean ch\u1ec9 m\u1ee5c c\u1ee7a ch\u00fang trong danh s\u00e1ch ban \u0111\u1ea7u. V\u00ed d\u1ee5:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m l\u1ea5y m\u1ea3ng s\u1ed1 l\u00e0m \u0111\u1ea7u v\u00e0o v\u00e0 tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng c\u00e1c ph\u1ea7n t\u1eed trong m\u1ea3ng l\u1edbn h\u01a1n 10 v\u00e0 c\u1ea3 hai ch\u1eef s\u1ed1 \u0111\u1ea7u ti\u00ean v\u00e0 cu\u1ed1i c\u00f9ng c\u1ee7a m\u1ed9t s\u1ed1 \u0111\u1ec1u l\u00e0 l\u1ebb (1, 3, 5, 7, 9). V\u00ed d\u1ee5: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n. B\u1ea1n ph\u1ea3i t\u1ea1o m\u1ed9t m\u1ea3ng s\u1ed1 nguy\u00ean a c\u00f3 chi\u1ec1u d\u00e0i n. \u0110\u1ed1i v\u1edbi m\u1ed7i i (1 \u2030\u00a4 i \u2030\u00a4 n), gi\u00e1 tr\u1ecb c\u1ee7a a[i] = i * i - i + 1. Tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng ba (a[i], a[j], a[k]) c\u1ee7a a trong \u0111\u00f3 i < j < k, v\u00e0 a[i] + a[j] + a[k] l\u00e0 b\u1ed9i s\u1ed1 c\u1ee7a 3. V\u00ed d\u1ee5: \u0111\u1ea7u v\u00e0o: n = 5 \u0111\u1ea7u ra: 1 Gi\u1ea3i th\u00edch: a = [1, 3, 7, 13, 21] Ch\u1ec9 c\u00f3 ba h\u1ee3p l\u1ec7 l\u00e0 (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m ch\u1ea5p nh\u1eadn m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i nh\u01b0 m\u1ed9t tham s\u1ed1, x\u00f3a c\u00e1c chu\u1ed7i c\u00f3 chi\u1ec1u d\u00e0i l\u1ebb t\u1eeb n\u00f3, v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch k\u1ebft qu\u1ea3 v\u1edbi m\u1ed9t th\u1ee9 t\u1ef1 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp, Danh s\u00e1ch lu\u00f4n l\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i v\u00e0 kh\u00f4ng bao gi\u1edd l\u00e0 m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1, v\u00e0 n\u00f3 c\u00f3 th\u1ec3 ch\u1ee9a tr\u00f9ng l\u1eb7p. Tr\u1eadt t\u1ef1 c\u1ee7a danh s\u00e1ch n\u00ean t\u0103ng theo chi\u1ec1u d\u00e0i c\u1ee7a m\u1ed7i t\u1eeb, v\u00e0 b\u1ea1n n\u00ean tr\u1ea3 l\u1ea1i danh s\u00e1ch \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo quy t\u1eafc \u0111\u00f3. N\u1ebfu hai t\u1eeb c\u00f3 c\u00f9ng chi\u1ec1u d\u00e0i, s\u1eafp x\u1ebfp danh s\u00e1ch theo th\u1ee9 t\u1ef1 b\u1ea3ng. Ch\u1ee9c n\u0103ng n\u00ean tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i theo th\u1ee9 t\u1ef1 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp. B\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng t\u1ea5t c\u1ea3 c\u00e1c t\u1eeb s\u1ebd c\u00f3 c\u00f9ng chi\u1ec1u d\u00e0i. V\u00ed d\u1ee5: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"ab\", \"a\", \"aaa\", \"cd\" => [\"ab\", \"cd\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"M\u1ed9t ch\u01b0\u01a1ng tr\u00ecnh \u0111\u01a1n gi\u1ea3n m\u00e0 s\u1ebd tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb c\u1ee7a x n\u1ebfu n l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1 v\u00e0 s\u1ebd tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb c\u1ee7a y n\u1ebfu kh\u00f4ng. V\u00ed d\u1ee5: cho x_or_y(7, 34, 12) == 34 cho x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"T\u00f4i ngh\u0129 t\u1ea5t c\u1ea3 ch\u00fang ta \u0111\u1ec1u nh\u1edb c\u1ea3m gi\u00e1c \u0111\u00f3 khi k\u1ebft qu\u1ea3 c\u1ee7a m\u1ed9t s\u1ed1 s\u1ef1 ki\u1ec7n \u0111\u01b0\u1ee3c ch\u1edd \u0111\u1ee3i t\u1eeb l\u00e2u cu\u1ed1i c\u00f9ng \u0111\u01b0\u1ee3c bi\u1ebft. Nh\u1eefng c\u1ea3m x\u00fac v\u00e0 suy ngh\u0129 b\u1ea1n c\u00f3 v\u00e0o th\u1eddi \u0111i\u1ec3m \u0111\u00f3 ch\u1eafc ch\u1eafn l\u00e0 \u0111\u00e1ng \u0111\u1ec3 ghi l\u1ea1i v\u00e0 so s\u00e1nh. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 x\u00e1c \u0111\u1ecbnh xem m\u1ed9t ng\u01b0\u1eddi \u0111\u00e3 \u0111o\u00e1n \u0111\u00fang k\u1ebft qu\u1ea3 c\u1ee7a m\u1ed9t s\u1ed1 tr\u1eadn \u0111\u1ea5u. B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p hai m\u1ea3ng \u0111i\u1ec3m s\u1ed1 v\u00e0 ph\u1ecfng \u0111o\u00e1n c\u00f3 chi\u1ec1u d\u00e0i b\u1eb1ng nhau, n\u01a1i m\u1ed7i ch\u1ec9 s\u1ed1 cho th\u1ea5y m\u1ed9t tr\u1eadn \u0111\u1ea5u. Tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng c\u00f9ng chi\u1ec1u d\u00e0i bi\u1ec3u th\u1ecb c\u00e1ch xa c\u1ee7a m\u1ed7i ph\u1ecfng \u0111o\u00e1n. N\u1ebfu h\u1ecd \u0111\u00e3 \u0111o\u00e1n \u0111\u00fang, gi\u00e1 tr\u1ecb l\u00e0 0, v\u00e0 n\u1ebfu kh\u00f4ng, gi\u00e1 tr\u1ecb l\u00e0 s\u1ef1 kh\u00e1c bi\u1ec7t tuy\u1ec7t \u0111\u1ed1i gi\u1eefa ph\u1ecfng \u0111o\u00e1n v\u00e0 \u0111i\u1ec3m s\u1ed1. v\u00ed d\u1ee5: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4,0,1,0,2,4]) -> [4,4,0,1,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p t\u00ean c\u1ee7a m\u1ed9t l\u1edbp (m\u1ed9t chu\u1ed7i) v\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng. C\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 t\u1ea3i c\u00e1c l\u1edbp b\u1ed5 sung v\u00e0o l\u1edbp. \u0110\u1ed9 m\u1ea1nh c\u1ee7a ph\u1ea7n m\u1edf r\u1ed9ng l\u00e0 nh\u01b0 sau: H\u00e3y \u0111\u1ec3 CAP l\u00e0 s\u1ed1 ch\u1eef c\u00e1i l\u1edbn trong t\u00ean ph\u1ea7n m\u1edf r\u1ed9ng, v\u00e0 h\u00e3y \u0111\u1ec3 SM l\u00e0 s\u1ed1 ch\u1eef c\u00e1i nh\u1ecf trong t\u00ean ph\u1ea7n m\u1edf r\u1ed9ng, \u0111\u1ed9 m\u1ea1nh \u0111\u01b0\u1ee3c cung c\u1ea5p b\u1edfi ph\u00e2n s\u1ed1 CAP - SM. B\u1ea1n n\u00ean t\u00ecm ph\u1ea7n m\u1edf r\u1ed9ng m\u1ea1nh nh\u1ea5t v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i trong \u0111\u1ecbnh d\u1ea1ng n\u00e0y: ClassName.StrongestExtensionName. N\u1ebfu c\u00f3 hai ho\u1eb7c nhi\u1ec1u ph\u1ea7n m\u1edf r\u1ed9ng c\u00f3 c\u00f9ng \u0111\u1ed9 m\u1ea1nh, b\u1ea1n n\u00ean ch\u1ecdn m\u1ed9t trong nh\u1eefng th\u1ee9 xu\u1ea5t hi\u1ec7n \u0111\u1ea7u ti\u00ean trong danh s\u00e1ch. V\u00ed d\u1ee5, n\u1ebfu b\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p \"Slices\" nh\u01b0 l\u00e0 l\u1edbp v\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng: ['SEviRNGSliCes', 'Cheese', 'StuFfed'] sau \u0111\u00f3 b\u1ea1n n\u00ean tr\u1ea3\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p 2 t\u1eeb. B\u1ea1n c\u1ea7n tr\u1ea3 v\u1ec1 True n\u1ebfu t\u1eeb th\u1ee9 hai ho\u1eb7c b\u1ea5t k\u1ef3 v\u00f2ng quay n\u00e0o c\u1ee7a n\u00f3 l\u00e0 m\u1ed9t chu\u1ed7i con trong t\u1eeb \u0111\u1ea7u ti\u00ean cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((\"whassup\",\"psus\") => False cycpattern_check (((\"abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Cho m\u1ed9t s\u1ed1 nguy\u00ean. tr\u1ea3 v\u1ec1 m\u1ed9t tuple c\u00f3 s\u1ed1 ch\u1eef s\u1ed1 ch\u1eb5n v\u00e0 l\u1ebb t\u01b0\u01a1ng \u1ee9ng. V\u00ed d\u1ee5: even_odd_count(-12) ==> (1, 1) even_odd_count(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng, l\u1ea5y s\u1ed1 La M\u00e3 t\u01b0\u01a1ng \u0111\u01b0\u01a1ng c\u1ee7a n\u00f3 d\u01b0\u1edbi d\u1ea1ng m\u1ed9t chu\u1ed7i, v\u00e0 tr\u1ea3 v\u1ec1 n\u00f3 b\u1eb1ng ch\u1eef c\u00e1i nh\u1ecf.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m ch\u1ea5p nh\u1eadn m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i. Danh s\u00e1ch ch\u1ee9a c\u00e1c t\u1eeb kh\u00e1c nhau. Tr\u1ea3 v\u1ec1 t\u1eeb v\u1edbi s\u1ed1 l\u01b0\u1ee3ng k\u00fd t\u1ef1 duy nh\u1ea5t t\u1ed1i \u0111a. N\u1ebfu nhi\u1ec1u chu\u1ed7i c\u00f3 s\u1ed1 k\u00fd t\u1ef1 duy nh\u1ea5t t\u1ed1i \u0111a, tr\u1ea3 v\u1ec1 m\u1ed9t trong nh\u1eefng th\u1ee9 m\u00e0 \u0111\u1ebfn \u0111\u1ea7u ti\u00ean theo th\u1ee9 t\u1ef1 t\u1eeb \u0111i\u1ec3n. find_max (([\"name\", \"of\", \"string\"]) == \"string\" find_max (([\"name\", \"enam\", \"game\"]) == \"enam\" find_max (([\"aaaaaaa\", \"bb\", \"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    B\u1ea1n l\u00e0 m\u1ed9t con th\u1ecf \u0111\u00f3i, v\u00e0 b\u1ea1n \u0111\u00e3 \u0103n m\u1ed9t s\u1ed1 l\u01b0\u1ee3ng c\u00e0 r\u1ed1t nh\u1ea5t \u0111\u1ecbnh, nh\u01b0ng b\u00e2y gi\u1edd b\u1ea1n c\u1ea7n ph\u1ea3i \u0103n nhi\u1ec1u c\u00e0 r\u1ed1t h\u01a1n \u0111\u1ec3 ho\u00e0n th\u00e0nh b\u1eefa \u0103n trong ng\u00e0y. b\u1ea1n n\u00ean tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng [t\u1ed5ng s\u1ed1 c\u00e0 r\u1ed1t \u0103n sau b\u1eefa \u0103n c\u1ee7a b\u1ea1n, s\u1ed1 c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i sau b\u1eefa \u0103n c\u1ee7a b\u1ea1n ] n\u1ebfu kh\u00f4ng c\u00f3 \u0111\u1ee7 c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i, b\u1ea1n s\u1ebd \u0103n t\u1ea5t c\u1ea3 c\u00e1c c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i, nh\u01b0ng v\u1eabn s\u1ebd \u0111\u00f3i. V\u00ed d\u1ee5: * \u0103n(5, 6, 10) -> [11, 4] * \u0103n(4, 8, 9) -> [12, 1] * \u0103n(1, 10, 10) -> [11, 0] * \u0103n(2, 11, 5) -> [7, 0] Bi\u1ebfn s\u1ed1: @number: s\u1ed1 nguy\u00ean s\u1ed1 c\u00e0 r\u1ed1t b\u1ea1n \u0111\u00e3 \u0103n. @need: s\u1ed1 nguy\u00ean s\u1ed1 c\u00e0 r\u1ed1t b\u1ea1n c\u1ea7n \u0103n. @remaining: s\u1ed1 nguy\u00ean s\u1ed1 c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i trong kho Constrain:\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. Danh s\u00e1ch \u0111\u1ea7u ti\u00ean c\u00f3 c\u00e1c ho\u1ea1t \u0111\u1ed9ng \u0111\u1ea1i s\u1ed1 c\u01a1 b\u1ea3n, v\u00e0 danh s\u00e1ch th\u1ee9 hai l\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean. S\u1eed d\u1ee5ng hai danh s\u00e1ch \u0111\u01b0\u1ee3c \u0111\u01b0a ra \u0111\u1ec3 x\u00e2y d\u1ef1ng bi\u1ec3u th\u1ee9c \u0111\u1ea1i s\u1ed1 v\u00e0 tr\u1ea3 v\u1ec1 \u0111\u00e1nh gi\u00e1 c\u1ee7a bi\u1ec3u th\u1ee9c n\u00e0y. C\u00e1c ho\u1ea1t \u0111\u1ed9ng \u0111\u1ea1i s\u1ed1 c\u01a1 b\u1ea3n: B\u1ed5 sung ( + ) tr\u1eeb ( - ) Nh\u00e2n ( * ) Ph\u00e2n chia s\u00e0n ( \/\/ ) Ph\u00e2n s\u1ed1 ( ** V\u00ed d\u1ee5 ): nh\u00e0 \u0111i\u1ec1u h\u00e0nh['+', '*', '-'] m\u1ea3ng = [2, 3, 4, 5] k\u1ebft qu\u1ea3 = 2 + 3 * 4 - 5 => k\u1ebft qu\u1ea3 = 9 L\u01b0u \u00fd: Chi\u1ec1u d\u00e0i c\u1ee7a danh s\u00e1ch c\u00e1c nh\u00e0 \u0111i\u1ec1u h\u00e0nh b\u1eb1ng chi\u1ec1u d\u00e0i c\u1ee7a danh s\u00e1ch c\u00e1c nh\u00e0 \u0111i\u1ec1u h\u00e0nh tr\u1eeb m\u1ed9t. C\u00e1c nh\u00e0 \u0111i\u1ec1u h\u00e0nh l\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m. Nh\u00e0 \u0111i\u1ec1u h\u00e0nh c\u00f3 \u00edt nh\u1ea5t m\u1ed9t danh s\u00e1ch c\u00e1c nh\u00e0 \u0111i\u1ec1u h\u00e0nh, v\u00e0 danh s\u00e1ch c\u00e1c nh\u00e0 \u0111i\u1ec1u\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i s. n\u1ebfu s[i] l\u00e0 m\u1ed9t ch\u1eef c\u00e1i, h\u00e3y \u0111\u1ea3o ng\u01b0\u1ee3c ch\u1eef c\u00e1i c\u1ee7a n\u00f3 t\u1eeb d\u01b0\u1edbi l\u00ean tr\u00ean ho\u1eb7c ng\u01b0\u1ee3c l\u1ea1i, n\u1ebfu kh\u00f4ng h\u00e3y gi\u1eef n\u00f3 nh\u01b0 v\u1eady. N\u1ebfu chu\u1ed7i kh\u00f4ng ch\u1ee9a ch\u1eef c\u00e1i, h\u00e3y \u0111\u1ea3o ng\u01b0\u1ee3c chu\u1ed7i. H\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 chu\u1ed7i k\u1ebft qu\u1ea3. V\u00ed d\u1ee5 solve{\"1234\") = \"4321\"{\"ab\") = \"AB\"{\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    N\u1ebfu 'text' l\u00e0 m\u1ed9t chu\u1ed7i tr\u1ed1ng, tr\u1ea3 v\u1ec1 None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Cho hai s\u1ed1 nguy\u00ean d\u01b0\u01a1ng a v\u00e0 b, tr\u1ea3 v\u1ec1 c\u00e1c ch\u1eef s\u1ed1 ch\u1eb5n gi\u1eefa a v\u00e0 b, theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n. V\u00ed d\u1ee5: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]