task_id,nl,pl,prompt,canonical_solution,tests
HumanEval_0,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Verilen eşik.    //Verilen sayılar listesinde, 'den daha yakın iki sayının olup olmadığını kontrol edin.    // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))
    // (false)
    // >>> HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))
    // (true)
    public static bool HasCloseElements(List<float> numbers, float threshold) {
","public static bool HasCloseElements(List<float> numbers, float threshold) {
    numbers.Sort();
    for (int i = 1; i < numbers.Count; i++) {
        if (numbers[i] - numbers[i - 1] < threshold) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.3f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f})), (0.05f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.95f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f})), (0.8f)) == (false));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.1f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (1.0f)) == (true));
    Debug.Assert(HasCloseElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f})), (0.5f)) == (false));
    }

}
"
HumanEval_1,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Girdi dizesindeki boşlukları görmezden gelin.    //Ayrı gruplar dengelenir (her açık brace düzgün bir şekilde kapatılır) ve birbirlerinin içinde yuva yapılmazlar.    //Bu grupları ayrı dizelere ayırın ve bunların listesini geri gönderin.    //Bu fonksiyonun girdi, yuvarlanmış parantezlerin birden fazla grubunu içeren bir dize.    // >>> SeparateParenGroups((""( ) (( )) (( )( ))""))
    // (new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))
    public static List<string> SeparateParenGroups(string paren_string) {
","public static List<string> SeparateParenGroups(string paren_string) {
        List<string> result = new List<string>();
        StringBuilder currentGroup = new StringBuilder();
        int balance = 0;

        foreach (char c in paren_string) {
            if (c == ' ') {
                continue;
            }

            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }

            currentGroup.Append(c);

            // When balance is zero, we have a complete group
            if (balance == 0 && currentGroup.Length > 0) {
                result.Add(currentGroup.ToString());
                currentGroup.Clear();
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SeparateParenGroups((""(()()) ((())) () ((())()())"")).Equals((new List<string>(new string[]{(string)""(()())"", (string)""((()))"", (string)""()"", (string)""((())()())""}))));
    Debug.Assert(SeparateParenGroups((""() (()) ((())) (((())))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""((()))"", (string)""(((())))""}))));
    Debug.Assert(SeparateParenGroups((""(()(())((())))"")).Equals((new List<string>(new string[]{(string)""(()(())((())))""}))));
    Debug.Assert(SeparateParenGroups((""( ) (( )) (( )( ))"")).Equals((new List<string>(new string[]{(string)""()"", (string)""(())"", (string)""(()())""}))));
    }

}
"
HumanEval_2,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Sayının ondalık kısmını döndür.    //(kalan parça her zaman 1'den küçüktür).    //ve tamsayı kısmı (verilen sayıdan küçük olan en büyük tamsayı) ve ondalık     //Pozitif bir dalgalanma noktası numarası verildiğinde,  olarak ayrıştırılabilir.    // >>> TruncateNumber((3.5f))
    // (0.5f)
    public static float TruncateNumber(float number) {
","using System;

class Problem {
    // Given a positive floating point number, it can be decomposed into
    // an integer part (largest integer smaller than the given number) and decimals
    // (leftover part always smaller than 1).
    // Return the decimal part of the number.
    public static float TruncateNumber(float number) {
        return number - (float)Math.Floor(number);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TruncateNumber((3.5f)) == (0.5f));
    Debug.Assert(TruncateNumber((1.25f)) == (0.25f));
    Debug.Assert(TruncateNumber((123.0f)) == (0.0f));
    }

}
"
HumanEval_3,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bu noktada fonksiyon true döndürülmelidir. Aksi takdirde false döndürülmelidir.    //Senin görevin hesap bakiyesinin herhangi bir noktada sıfırdan aşağı düştüğünü tespit etmek ve     //Banka hesabındaki para yatırma ve çekme işlemlerinin bir listesi veriliyor.    // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (false)
    // >>> BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L})))
    // (true)
    public static bool BelowZero(List<long> operations) {
","long balance = 0;
    foreach (var operation in operations) {
        balance += operation;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowZero((new List<long>())) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-3L, (long)1L, (long)2L, (long)-3L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)2L, (long)-4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (false));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-1L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-5L}))) == (true));
    Debug.Assert(BelowZero((new List<long>(new long[]{(long)1L, (long)-2L, (long)2L, (long)-2L, (long)5L, (long)-5L, (long)4L, (long)-4L}))) == (true));
    }

}
"
HumanEval_4,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //MAD = ortalama. x - x_mean.     //element ve bir merkez noktası (bu durumda ortalama):     //Ortalama mutlak sapma her iki     //Bu veri kümesi ortalaması civarında.    //Verilen giriş sayılarının listesi için, Mean Absolute Deviation  hesaplayın.    // >>> MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))
    // (1.0f)
    public static float MeanAbsoluteDeviation(List<float> numbers) {
","if (numbers == null || numbers.Count == 0)
    {
        throw new ArgumentException(""The list of numbers must not be null or empty."");
    }
    
    float sum = 0.0f;
    foreach (float number in numbers)
    {
        sum += number;
    }

    float mean = sum / numbers.Count;
    float absoluteDeviationSum = 0.0f;
    
    foreach (float number in numbers)
    {
        absoluteDeviationSum += Math.Abs(number - mean);
    }
    
    float meanAbsoluteDeviation = absoluteDeviationSum / numbers.Count;
    return meanAbsoluteDeviation;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f}))) == (0.5f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f}))) == (1.0f));
    Debug.Assert(MeanAbsoluteDeviation((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))) == (1.2f));
    }

}
"
HumanEval_5,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Giriş listesinin her iki ardışık öğesi arasında bir ""delimiter"" numarası eklenir `numbers'     // >>> Intersperse((new List<long>()), (4L))
    // (new List<long>())
    // >>> Intersperse((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (4L))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)4L, (long)3L}))
    public static List<long> Intersperse(List<long> numbers, long delimeter) {
","public static List<long> Intersperse(List<long> numbers, long delimeter)
{
    List<long> result = new List<long>();

    if (numbers == null || numbers.Count == 0)
    {
        return result;
    }

    for (int i = 0; i < numbers.Count; i++)
    {
        result.Add(numbers[i]);
        if (i < numbers.Count - 1)
        {
            result.Add(delimeter);
        }
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersperse((new List<long>()), (7L)).Equals((new List<long>())));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)2L})), (8L)).Equals((new List<long>(new long[]{(long)5L, (long)8L, (long)6L, (long)8L, (long)3L, (long)8L, (long)2L}))));
    Debug.Assert(Intersperse((new List<long>(new long[]{(long)2L, (long)2L, (long)2L})), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L, (long)2L, (long)2L}))));
    }

}
"
HumanEval_6,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin (() (()) en fazla iki tane yuvalama seviyesine sahipken ((())) üç taneye sahiptir.     //Grupların her biri için parantezlerin en derin yerleşim seviyesini çıkarın.    //Bu fonksiyonun girişinde, yuvarlanmış parantezler için boşluklarla ayrılmış çoklu gruplar temsil edilen bir dize bulunur.    // >>> ParseNestedParens((""(()()) ((())) () ((())()())""))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))
    public static List<long> ParseNestedParens(string paren_string) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> ParseNestedParens(string paren_string) {
        List<long> nestingLevels = new List<long>();
        string[] groups = paren_string.Split(' ');

        foreach (string group in groups) {
            long currentLevel = 0;
            long maxLevel = 0;

            foreach (char c in group) {
                if (c == '(') {
                    currentLevel++;
                    if (currentLevel > maxLevel) {
                        maxLevel = currentLevel;
                    }
                } else if (c == ')') {
                    currentLevel--;
                }
            }

            nestingLevels.Add(maxLevel);
        }

        return nestingLevels;
    }

    static void Main(string[] args) {
        string input = ""(()()) ((())) () ((())()())"";
        List<long> result = ParseNestedParens(input);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseNestedParens((""(()()) ((())) () ((())()())"")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(ParseNestedParens((""() (()) ((())) (((())))"")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(ParseNestedParens((""(()(())((())))"")).Equals((new List<long>(new long[]{(long)4L}))));
    }

}
"
HumanEval_7,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Sadece verilen alt dizin içeren dizinlerin girdi listesini filtrele .    // >>> FilterBySubstring((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterBySubstring((new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""bacd"", (string)""array""}))
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> FilterBySubstring(List<string> strings, string substring) {
        List<string> result = new List<string>();
        foreach (string str in strings) {
            if (str.Contains(substring)) {
                result.Add(str);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterBySubstring((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""aaaxxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""aaaxxy"", (string)""xxxAAA"", (string)""xxx""}))));
    Debug.Assert(FilterBySubstring((new List<string>(new string[]{(string)""grunt"", (string)""trumpet"", (string)""prune"", (string)""gruesome""})), (""run"")).Equals((new List<string>(new string[]{(string)""grunt"", (string)""prune""}))));
    }

}
"
HumanEval_8,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Boş toplam 0'a eşit olmalı ve boş ürünün 1'e eşit olması gerekir.    //Verilen tamsayılar listesi için, bir listedeki tüm tamsayıların toplamı ve çarpımından oluşan bir tuple döndürün.     // >>> SumProduct((new List<long>()))
    // (Tuple.Create(0L, 1L))
    // >>> SumProduct((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (Tuple.Create(10L, 24L))
    public static Tuple<long, long> SumProduct(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<long, long> SumProduct(List<long> numbers) {
        long sum = 0L;
        long product = 1L;

        foreach (var number in numbers) {
            sum += number;
            product *= number;
        }

        return Tuple.Create(sum, product);
    }

    static void Main(string[] args) {
        // Test cases
        var result1 = SumProduct(new List<long>());
        Console.WriteLine($""({result1.Item1}, {result1.Item2})""); // Should output (0, 1)

        var result2 = SumProduct(new List<long> { 1L, 2L, 3L, 4L });
        Console.WriteLine($""({result2.Item1}, {result2.Item2})""); // Should output (10, 24)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumProduct((new List<long>())).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)1L, (long)1L, (long)1L}))).Equals((Tuple.Create(3L, 1L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)100L, (long)0L}))).Equals((Tuple.Create(100L, 0L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))).Equals((Tuple.Create(15L, 105L))));
    Debug.Assert(SumProduct((new List<long>(new long[]{(long)10L}))).Equals((Tuple.Create(10L, 10L))));
    }

}
"
HumanEval_9,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Sırada.    //Verilen tam sayılar listesinden, verilen ana kadar bulunan yuvarlanan maksimum eleman listesini oluşturun.    // >>> RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L}))
    public static List<long> RollingMax(List<long> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> RollingMax(List<long> numbers) {
        List<long> rollingMaxList = new List<long>();
        long currentMax = long.MinValue;

        foreach (var number in numbers) {
            if (number > currentMax) {
                currentMax = number;
            }
            rollingMaxList.Add(currentMax);
        }

        return rollingMaxList;
    }

    public static void Main(string[] args) {
        List<long> numbers = new List<long> { 1L, 2L, 3L, 2L, 3L, 4L, 2L };
        List<long> result = RollingMax(numbers);
        Console.WriteLine(""Rolling Max: "" + string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RollingMax((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(RollingMax((new List<long>(new long[]{(long)3L, (long)2L, (long)3L, (long)100L, (long)3L}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)100L, (long)100L}))));
    }

}
"
HumanEval_10,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //- Palindromik sonekten önce gelen bir dize önekinin tersini dizinin sonuna ekleyin.    //- Palindrom olan verili dizinin en uzun postfix'ini bulun.     //Algoritma fikri basit:    //Verilen dize ile başlayan en kısa palindromu bulun.     // >>> MakePalindrome((""""))
    // ("""")
    // >>> MakePalindrome((""cat""))
    // (""catac"")
    // >>> MakePalindrome((""cata""))
    // (""catac"")
    public static string MakePalindrome(string str) {
","if (string.IsNullOrEmpty(str)) return str;

    int maxPalindromeLength = 0;
    for (int i = 0; i < str.Length; i++) {
        if (IsPalindrome(str, i, str.Length - 1)) {
            maxPalindromeLength = str.Length - i;
            break;
        }
    }

    string suffixToPrepend = str.Substring(0, str.Length - maxPalindromeLength);
    char[] reversedPrefix = suffixToPrepend.Reverse().ToArray();
    return str + new string(reversedPrefix);
}

private static bool IsPalindrome(string str, int left, int right) {
    while (left < right) {
        if (str[left] != str[right]) return false;
        left++;
        right--;
    }
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakePalindrome(("""")).Equals(("""")));
    Debug.Assert(MakePalindrome((""x"")).Equals((""x"")));
    Debug.Assert(MakePalindrome((""xyz"")).Equals((""xyzyx"")));
    Debug.Assert(MakePalindrome((""xyx"")).Equals((""xyx"")));
    Debug.Assert(MakePalindrome((""jerry"")).Equals((""jerryrrej"")));
    }

}
"
HumanEval_11,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bu girişler üzerinde ikili XOR çalıştırın ve sonucu bir dize olarak da gönderin.    //Giriş, sadece 1 ve 0'lardan oluşan iki dize a ve b'dir.    // >>> StringXor((""010""), (""110""))
    // (""100"")
    public static string StringXor(string a, string b) {
","if (a.Length != b.Length) {
        throw new ArgumentException(""Input strings must be of the same length."");
    }

    StringBuilder result = new StringBuilder(a.Length);

    for (int i = 0; i < a.Length; i++) {
        result.Append(a[i] == b[i] ? '0' : '1');
    }

    return result.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringXor((""111000""), (""101010"")).Equals((""010010"")));
    Debug.Assert(StringXor((""1""), (""1"")).Equals((""0"")));
    Debug.Assert(StringXor((""0101""), (""0000"")).Equals((""0101"")));
    }

}
"
HumanEval_12,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //girdi listesi boşsa null döndürür.    //Listeden en uzun dizeyi ve birden fazla dize olması durumunda ilk dizeyi gönderir.    // >>> Longest((new List<string>()))
    // null
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""a"")
    // >>> Longest((new List<string>(new string[]{(string)""a"", (string)""bb"", (string)""ccc""})))
    // (""ccc"")
    public static string Longest(List<string> strings) {
","if (strings == null || strings.Count == 0)
    {
        return null;
    }
    
    string longest = strings[0];
    
    foreach (string str in strings)
    {
        if (str.Length > longest.Length)
        {
            longest = str;
        }
    }
    
    return longest;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Longest((new List<string>())).Equals(null));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""x"")));
    Debug.Assert(Longest((new List<string>(new string[]{(string)""x"", (string)""yyy"", (string)""zzzz"", (string)""www"", (string)""kkkk"", (string)""abc""}))).Equals((""zzzz"")));
    }

}
"
HumanEval_13,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //İki tam sayının en büyük ortak paydası olan a ve b değerini gönderir .    // >>> GreatestCommonDivisor((3L), (5L))
    // (1L)
    // >>> GreatestCommonDivisor((25L), (15L))
    // (5L)
    public static long GreatestCommonDivisor(long a, long b) {
","// Base case: if b is 0, gcd is a
    if (b == 0)
        return a;
    
    // Recursive call: gcd(a, b) = gcd(b, a % b)
    return GreatestCommonDivisor(b, a % b);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GreatestCommonDivisor((3L), (7L)) == (1L));
    Debug.Assert(GreatestCommonDivisor((10L), (15L)) == (5L));
    Debug.Assert(GreatestCommonDivisor((49L), (14L)) == (7L));
    Debug.Assert(GreatestCommonDivisor((144L), (60L)) == (12L));
    }

}
"
HumanEval_14,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Girdi dizininin en kısaından en uzununa kadar tüm öneklerin listesini döndürür .    // >>> AllPrefixes((""abc""))
    // (new List<string>(new string[]{(string)""a"", (string)""ab"", (string)""abc""}))
    public static List<string> AllPrefixes(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list of all prefixes from shortest to longest of the input string
    public static List<string> AllPrefixes(string str) {
        List<string> prefixes = new List<string>();
        for (int i = 1; i <= str.Length; i++) {
            prefixes.Add(str.Substring(0, i));
        }
        return prefixes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AllPrefixes(("""")).Equals((new List<string>())));
    Debug.Assert(AllPrefixes((""asdfgh"")).Equals((new List<string>(new string[]{(string)""a"", (string)""as"", (string)""asd"", (string)""asdf"", (string)""asdfg"", (string)""asdfgh""}))));
    Debug.Assert(AllPrefixes((""WWW"")).Equals((new List<string>(new string[]{(string)""W"", (string)""WW"", (string)""WWW""}))));
    }

}
"
HumanEval_15,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //0'dan n'a kadar uzayda sınırlı sayıları içeren bir dizeyi döndürür.     // >>> StringSequence((0L))
    // (""0"")
    // >>> StringSequence((5L))
    // (""0 1 2 3 4 5"")
    public static string StringSequence(long n) {
","public static string StringSequence(long n) {
    StringBuilder sb = new StringBuilder();
    for (long i = 0; i <= n; i++) {
        if (i > 0) {
            sb.Append("" "");
        }
        sb.Append(i);
    }
    return sb.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringSequence((0L)).Equals((""0"")));
    Debug.Assert(StringSequence((3L)).Equals((""0 1 2 3"")));
    Debug.Assert(StringSequence((10L)).Equals((""0 1 2 3 4 5 6 7 8 9 10"")));
    }

}
"
HumanEval_16,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bir dize verildiğinde, kaç farklı karakterden oluştuğunu bulun (büyük harf ya da küçük harf)    // >>> CountDistinctCharacters((""xyzXYZ""))
    // (3L)
    // >>> CountDistinctCharacters((""Jerry""))
    // (4L)
    public static long CountDistinctCharacters(string str) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long CountDistinctCharacters(string str) {
        // Convert the string to lower case to handle case insensitivity
        str = str.ToLower();

        // Use a HashSet to store distinct characters
        HashSet<char> distinctChars = new HashSet<char>(str);

        // Return the count of distinct characters
        return distinctChars.Count;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountDistinctCharacters(("""")) == (0L));
    Debug.Assert(CountDistinctCharacters((""abcde"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""abcdecadeCADE"")) == (5L));
    Debug.Assert(CountDistinctCharacters((""aaaaAAAAaaaa"")) == (1L));
    Debug.Assert(CountDistinctCharacters((""Jerry jERRY JeRRRY"")) == (5L));
    }

}
"
HumanEval_17,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //""Haklısın"" - dörtlü nota, bir vuruş sürer.    //'O saçma' - yarım nota, iki vuruş sürer.    //""O"" - tüm nota, dört vuruş sürer.    //İşte bir efsane:    //Son değil.    //Görevin bu dizeyi analiz etmek ve her biri kaç vuruş yaptığını gösteren tam sayılar listesini geri göndermektir .    //Bu fonksiyonun girişinde, özel bir ASCII formatında müzik notalarını temsil eden bir dize bulunur.    // >>> ParseMusic((""o o| .| o| o| .| .| .| .| o o""))
    // (new List<long>(new long[]{(long)4L, (long)2L, (long)1L, (long)2L, (long)2L, (long)1L, (long)1L, (long)1L, (long)1L, (long)4L, (long)4L}))
    public static List<long> ParseMusic(string music_string) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> ParseMusic(string music_string)
    {
        List<long> beats = new List<long>();
        string[] notes = music_string.Split(' ');
        
        foreach (string note in notes)
        {
            switch (note)
            {
                case ""o"":
                    beats.Add(4L);
                    break;
                case ""o|"":
                    beats.Add(2L);
                    break;
                case "".|"":
                    beats.Add(1L);
                    break;
                default:
                    break;
            }
        }
        
        return beats;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ParseMusic(("""")).Equals((new List<long>())));
    Debug.Assert(ParseMusic((""o o o o"")).Equals((new List<long>(new long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic(("".| .| .| .|"")).Equals((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}))));
    Debug.Assert(ParseMusic((""o| o| .| .| o o o o"")).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)1L, (long)1L, (long)4L, (long)4L, (long)4L, (long)4L}))));
    Debug.Assert(ParseMusic((""o| .| o| .| o o| o o|"")).Equals((new List<long>(new long[]{(long)2L, (long)1L, (long)2L, (long)1L, (long)4L, (long)2L, (long)4L, (long)2L}))));
    }

}
"
HumanEval_18,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Verilen alt dizinin orijinal dizinde kaç kez bulunabileceğini bulun. Çakışan vakaları sayın.     // >>> HowManyTimes((""""), (""a""))
    // (0L)
    // >>> HowManyTimes((""aaa""), (""a""))
    // (3L)
    // >>> HowManyTimes((""aaaa""), (""aa""))
    // (3L)
    public static long HowManyTimes(string str, string substring) {
","using System;

class Problem {
    public static long HowManyTimes(string str, string substring) {
        if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(substring)) {
            return 0L;
        }

        long count = 0;
        int index = 0;

        while ((index = str.IndexOf(substring, index)) != -1) {
            count++;
            index++;
        }

        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(HowManyTimes(""aaa"", ""a"")); // Output: 3
        Console.WriteLine(HowManyTimes(""aaaa"", ""aa"")); // Output: 3
        Console.WriteLine(HowManyTimes("""", ""a"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HowManyTimes((""""), (""x"")) == (0L));
    Debug.Assert(HowManyTimes((""xyxyxyx""), (""x"")) == (4L));
    Debug.Assert(HowManyTimes((""cacacacac""), (""cac"")) == (4L));
    Debug.Assert(HowManyTimes((""john doe""), (""john"")) == (1L));
    }

}
"
HumanEval_19,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //En küçükten en büyükte sıralanmış sayılarla dizeyi döndürür .    //Geçerli seçenekler ""sıfır"", ""bir"", ""iki"", ""üç"", ""dört"", ""beş"", ""altı"", ""yedi"", ""sekiz"" ve ""dokuz"" dır.    //Giriş, 'sıfır'dan 'doğuz'a kadar olan numaraların uzayla sınırlı bir dizilisidir.    // >>> SortNumbers((""three one five""))
    // (""one three five"")
    public static string SortNumbers(string numbers) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static string SortNumbers(string numbers)
    {
        Dictionary<string, int> numberWords = new Dictionary<string, int>
        {
            { ""zero"", 0 },
            { ""one"", 1 },
            { ""two"", 2 },
            { ""three"", 3 },
            { ""four"", 4 },
            { ""five"", 5 },
            { ""six"", 6 },
            { ""seven"", 7 },
            { ""eight"", 8 },
            { ""nine"", 9 }
        };

        List<string> numberList = new List<string>(numbers.Split(' '));
        numberList.Sort((a, b) => numberWords[a].CompareTo(numberWords[b]));
        return string.Join("" "", numberList);
    }

    static void Main(string[] args)
    {
        Console.WriteLine(SortNumbers(""three one five"")); // Output: ""one three five""
        Console.WriteLine(SortNumbers(""nine eight seven six"")); // Output: ""six seven eight nine""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortNumbers(("""")).Equals(("""")));
    Debug.Assert(SortNumbers((""three"")).Equals((""three"")));
    Debug.Assert(SortNumbers((""three five nine"")).Equals((""three five nine"")));
    Debug.Assert(SortNumbers((""five zero four seven nine eight"")).Equals((""zero four five seven eight nine"")));
    Debug.Assert(SortNumbers((""six five four three two one zero"")).Equals((""zero one two three four five six"")));
    }

}
"
HumanEval_20,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Diğerleri ve sırayla geri gönderin (daha az sayı, daha fazla sayı).    //Verilen bir sayı listesinden (en az iki uzunlukta) her birine en yakın olan iki sayıyı seçin ve geri gönderin .    // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))
    // (Tuple.Create(2.0f, 2.2f))
    // >>> FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))
    // (Tuple.Create(2.0f, 2.0f))
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
","using System;
using System.Collections.Generic;

class Problem {
    public static Tuple<float, float> FindClosestElements(List<float> numbers) {
        if (numbers == null || numbers.Count < 2) {
            throw new ArgumentException(""List must contain at least two numbers."");
        }
        
        numbers.Sort();
        float minDifference = float.MaxValue;
        Tuple<float, float> closestPair = null;

        for (int i = 0; i < numbers.Count - 1; i++) {
            float difference = numbers[i + 1] - numbers[i];
            if (difference < minDifference) {
                minDifference = difference;
                closestPair = Tuple.Create(numbers[i], numbers[i + 1]);
            }
        }

        return closestPair;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.9f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(3.9f, 4.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)5.9f, (float)4.0f, (float)5.0f}))).Equals((Tuple.Create(5.0f, 5.9f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f}))).Equals((Tuple.Create(2.0f, 2.2f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f}))).Equals((Tuple.Create(2.0f, 2.0f))));
    Debug.Assert(FindClosestElements((new List<float>(new float[]{(float)1.1f, (float)2.2f, (float)3.1f, (float)4.1f, (float)5.1f}))).Equals((Tuple.Create(2.2f, 3.1f))));
    }

}
"
HumanEval_21,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Böylece en küçük sayı 0 , en büyük sayı ise 1 olur .    //Bir sayı listesi verilmişse (en az iki elementten oluşan), bu listeye bir lineer dönüşüm uygulayın,     // >>> RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))
    // (new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))
    public static List<float> RescaleToUnit(List<float> numbers) {
","public static List<float> RescaleToUnit(List<float> numbers) {
        if (numbers == null || numbers.Count < 2)
            throw new ArgumentException(""List must contain at least two elements."");

        float min = numbers.Min();
        float max = numbers.Max();

        if (min == max)
            throw new ArgumentException(""All elements are the same. Cannot rescale."");

        return numbers.Select(num => (num - min) / (max - min)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)100.0f, (float)49.9f}))).Equals((new List<float>(new float[]{(float)1.0f, (float)0.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f}))).Equals((new List<float>(new float[]{(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)2.0f, (float)1.0f, (float)5.0f, (float)3.0f, (float)4.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    Debug.Assert(RescaleToUnit((new List<float>(new float[]{(float)12.0f, (float)11.0f, (float)15.0f, (float)13.0f, (float)14.0f}))).Equals((new List<float>(new float[]{(float)0.25f, (float)0.0f, (float)1.0f, (float)0.5f, (float)0.75f}))));
    }

}
"
HumanEval_22,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Sadece tam sayılar için verilen csthon değerlerinin listesini filtrele .    // >>> FilterIntegers((new List<object>(new string[]{(string)""a"", (string)3.14f, (string)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> FilterIntegers((new List<object>(new object[]{1L, 2L, 3L, ""abc"", new List<object>()})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    public static List<long> FilterIntegers(List<object> values) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> FilterIntegers(List<object> values) {
        List<long> result = new List<long>();
        foreach (var value in values) {
            if (value is long) {
                result.Add((long)value);
            }
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterIntegers((new List<object>())).Equals((new List<long>())));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{4L, new List<object>(), 23.2f, 9L, ""adasd""}))).Equals((new List<long>(new long[]{(long)4L, (long)9L}))));
    Debug.Assert(FilterIntegers((new List<object>(new object[]{3L, ""c"", 3L, 3L, ""a"", ""b""}))).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_23,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Verilen dizinin geri dönüş uzunluğu     // >>> StringLength((""""))
    // (0L)
    // >>> StringLength((""abc""))
    // (3L)
    public static long Strlen(string str) {
","return str.Length;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Strlen(("""")) == (0L));
    Debug.Assert(Strlen((""x"")) == (1L));
    Debug.Assert(Strlen((""asdasnakj"")) == (9L));
    }

}
"
HumanEval_24,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Verilmiş bir n sayısı için, n'i eşit olarak ayıran en büyük sayıyı bul, n'den küçük     // >>> LargestDivisor((15L))
    // (5L)
    public static long LargestDivisor(long n) {
","if (n <= 1)
        {
            throw new ArgumentOutOfRangeException(""n must be greater than 1"");
        }
        for (long i = n / 2; i >= 1; i--)
        {
            if (n % i == 0)
            {
                return i;
            }
        }
        return 1; // This line is theoretically unreachable since 1 is always a divisor of n
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestDivisor((3L)) == (1L));
    Debug.Assert(LargestDivisor((7L)) == (1L));
    Debug.Assert(LargestDivisor((10L)) == (5L));
    Debug.Assert(LargestDivisor((100L)) == (50L));
    Debug.Assert(LargestDivisor((49L)) == (7L));
    }

}
"
HumanEval_25,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Girdi sayısı tüm faktörlerin çarpımına eşit olmalı.    //Her bir faktör, faktörleşmede kaç kez ortaya çıktığına karşılık gelen sayılarla listelenmelidir.    //Verilen tam sayının asal çarpanlarının en küçükten en büyükte sıralanmış listesini döndürür.    // >>> Factorize((8L))
    // (new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))
    // >>> Factorize((25L))
    // (new List<long>(new long[]{(long)5L, (long)5L}))
    // >>> Factorize((70L))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)7L}))
    public static List<long> Factorize(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Factorize(long n) {
        List<long> factors = new List<long>();
        for (long i = 2; i * i <= n; i++) {
            while (n % i == 0) {
                factors.Add(i);
                n /= i;
            }
        }
        if (n > 1) {
            factors.Add(n);
        }
        return factors;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Factorize((2L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Factorize((4L)).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Factorize((8L)).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)2L}))));
    Debug.Assert(Factorize((57L)).Equals((new List<long>(new long[]{(long)3L, (long)19L}))));
    Debug.Assert(Factorize((3249L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((185193L)).Equals((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((20577L)).Equals((new List<long>(new long[]{(long)3L, (long)19L, (long)19L, (long)19L}))));
    Debug.Assert(Factorize((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)3L}))));
    }

}
"
HumanEval_26,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Elemanların sırasını girdilerdeki gibi bırakın.    //Tam sayılar listesinden, birden fazla kez ortaya çıkan tüm öğeleri kaldırın.    // >>> RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)4L}))
    public static List<long> RemoveDuplicates(List<long> numbers) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    // From a list of integers, remove all elements that occur more than once.
    // Keep order of elements left the same as in the input.
    public static List<long> RemoveDuplicates(List<long> numbers)
    {
        var elementCount = numbers.GroupBy(n => n)
                                  .ToDictionary(g => g.Key, g => g.Count());

        return numbers.Where(n => elementCount[n] == 1).ToList();
    }

    static void Main(string[] args)
    {
        List<long> numbers = new List<long> { 1, 2, 3, 2, 4 };
        List<long> result = RemoveDuplicates(numbers);
        Console.WriteLine(string.Join("", "", result));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveDuplicates((new List<long>())).Equals((new List<long>())));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));
    Debug.Assert(RemoveDuplicates((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)4L, (long)3L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)5L}))));
    }

}
"
HumanEval_27,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Verilen bir dize için, küçük harfleri büyük harfe ve büyük harfleri küçük harfe çevirin.    // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
","using System;

class Problem {
    // For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    // >>> FlipCase((""Hello""))
    // (""hELLO"")
    public static string FlipCase(string str) {
        char[] chars = str.ToCharArray();
        for (int i = 0; i < chars.Length; i++) {
            if (char.IsUpper(chars[i])) {
                chars[i] = char.ToLower(chars[i]);
            } else if (char.IsLower(chars[i])) {
                chars[i] = char.ToUpper(chars[i]);
            }
        }
        return new string(chars);
    }
    
    static void Main(string[] args) {
        Console.WriteLine(FlipCase(""Hello"")); // Output should be ""hELLO""
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FlipCase(("""")).Equals(("""")));
    Debug.Assert(FlipCase((""Hello!"")).Equals((""hELLO!"")));
    Debug.Assert(FlipCase((""These violent delights have violent ends"")).Equals((""tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"")));
    }

}
"
HumanEval_28,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Tek bir dize içinde dizileri birleştirmek için .    // >>> Concatenate((new List<string>()))
    // ("""")
    // >>> Concatenate((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""c""})))
    // (""abc"")
    public static string Concatenate(List<string> strings) {
","return string.Concat(strings);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Concatenate((new List<string>())).Equals(("""")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z""}))).Equals((""xyz"")));
    Debug.Assert(Concatenate((new List<string>(new string[]{(string)""x"", (string)""y"", (string)""z"", (string)""w"", (string)""k""}))).Equals((""xyzwk"")));
    }

}
"
HumanEval_29,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Sadece verilen bir önekle başlayan dizileri filtrelemek için giriş dizileri listesini filtreleyin.     // >>> FilterByPrefix((new List<string>()), (""a""))
    // (new List<string>())
    // >>> FilterByPrefix((new List<string>(new string[]{(string)""abc"", (string)""bcd"", (string)""cde"", (string)""array""})), (""a""))
    // (new List<string>(new string[]{(string)""abc"", (string)""array""}))
    public static List<string> FilterByPrefix(List<string> strings, string prefix) {
","return strings.Where(s => s.StartsWith(prefix)).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FilterByPrefix((new List<string>()), (""john"")).Equals((new List<string>())));
    Debug.Assert(FilterByPrefix((new List<string>(new string[]{(string)""xxx"", (string)""asd"", (string)""xxy"", (string)""john doe"", (string)""xxxAAA"", (string)""xxx""})), (""xxx"")).Equals((new List<string>(new string[]{(string)""xxx"", (string)""xxxAAA"", (string)""xxx""}))));
    }

}
"
HumanEval_30,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Listedeki sadece pozitif sayıları döndür.    // >>> GetPositive((new List<long>(new long[]{(long)-1L, (long)2L, (long)-4L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)2L, (long)5L, (long)6L}))
    // >>> GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)9L, (long)123L, (long)1L}))
    public static List<long> GetPositive(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetPositive(List<long> l)
    {
        List<long> positiveNumbers = new List<long>();
        foreach (long number in l)
        {
            if (number > 0)
            {
                positiveNumbers.Add(number);
            }
        }
        return positiveNumbers;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L, (long)4L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)4L, (long)5L, (long)6L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)3L, (long)3L, (long)9L, (long)123L, (long)1L}))));
    Debug.Assert(GetPositive((new List<long>(new long[]{(long)-1L, (long)-2L}))).Equals((new List<long>())));
    Debug.Assert(GetPositive((new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_31,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Verilen sayı asal ise doğru, aksi takdirde yanlış olarak döndürür.    // >>> IsPrime((6L))
    // (false)
    // >>> IsPrime((101L))
    // (true)
    // >>> IsPrime((11L))
    // (true)
    // >>> IsPrime((13441L))
    // (true)
    // >>> IsPrime((61L))
    // (true)
    // >>> IsPrime((4L))
    // (false)
    // >>> IsPrime((1L))
    // (false)
    public static bool IsPrime(long n) {
","public static bool IsPrime(long n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    for (long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    
    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPrime((6L)) == (false));
    Debug.Assert(IsPrime((101L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((13441L)) == (true));
    Debug.Assert(IsPrime((61L)) == (true));
    Debug.Assert(IsPrime((4L)) == (false));
    Debug.Assert(IsPrime((1L)) == (false));
    Debug.Assert(IsPrime((5L)) == (true));
    Debug.Assert(IsPrime((11L)) == (true));
    Debug.Assert(IsPrime((17L)) == (true));
    Debug.Assert(IsPrime((85L)) == (false));
    Debug.Assert(IsPrime((77L)) == (false));
    Debug.Assert(IsPrime((255379L)) == (false));
    }

}
"
HumanEval_33,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //l'nin karşılık gelen indekslerinin değerlerine göre, ama sıralanmıştır.    //l' üçe bölünmeyen indekslerde l ile aynıdır, üçe bölünen indekslerdeki değerleri ise eşittir.    //Bu fonksiyon bir liste alır ve bir liste döndürür l ' böyle ki     // >>> SortThird((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))
    public static List<long> SortThird(List<long> l) {
","public static List<long> SortThird(List<long> l) {
        List<long> sortedValues = new List<long>();

        // Collect values at indices divisible by three
        for (int i = 0; i < l.Count; i++) {
            if (i % 3 == 0) {
                sortedValues.Add(l[i]);
            }
        }

        // Sort the collected values
        sortedValues.Sort();

        // Place sorted values back into their positions
        int sortedIndex = 0;
        List<long> result = new List<long>(l);
        for (int i = 0; i < result.Count; i++) {
            if (i % 3 == 0) {
                result[i] = sortedValues[sortedIndex++];
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)8L, (long)3L, (long)4L, (long)6L, (long)9L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)9L, (long)4L, (long)8L, (long)3L, (long)5L}))));
    Debug.Assert(SortThird((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L, (long)3L, (long)4L, (long)8L, (long)9L, (long)5L, (long)1L}))));
    }

}
"
HumanEval_34,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bir listede sıralanmış benzersiz öğeleri döndürür .    // >>> Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))
    public static List<long> Unique(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return sorted unique elements in a list
    public static List<long> Unique(List<long> l) {
        HashSet<long> uniqueSet = new HashSet<long>(l);
        List<long> uniqueList = new List<long>(uniqueSet);
        uniqueList.Sort();
        return uniqueList;
    }
    
    static void Main(string[] args) {
        List<long> input = new List<long>{5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L};
        List<long> result = Unique(input);
        Console.WriteLine(string.Join("", "", result)); // Output: 0, 2, 3, 5, 9, 123
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Unique((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)5L, (long)9L, (long)123L}))));
    }

}
"
HumanEval_35,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Listedeki en fazla öğeyi döndürür.    // >>> MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (3L)
    // >>> MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L})))
    // (123L)
    public static long MaxElement(List<long> l) {
","return l.Max();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (3L));
    Debug.Assert(MaxElement((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)124L, (long)1L, (long)-10L}))) == (124L));
    }

}
"
HumanEval_36,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Sayı 7'nin 11 veya 13 ile bölünebilen n'den küçük tam sayılar içinde kaç kez göründüğünü gönderir.     // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    // >>> FizzBuzz((50L))
    // (0L)
    // >>> FizzBuzz((78L))
    // (2L)
    // >>> FizzBuzz((79L))
    // (3L)
    public static long FizzBuzz(long n) {
        long count = 0;
        for (long i = 1; i < n; i++) {
            if (i % 11 == 0 || i % 13 == 0) {
                count += CountSevens(i);
            }
        }
        return count;
    }

    private static int CountSevens(long num) {
        int count = 0;
        while (num > 0) {
            if (num % 10 == 7) {
                count++;
            }
            num /= 10;
        }
        return count;
    }

    // You can test the function with the following main method:
    static void Main(string[] args) {
        Console.WriteLine(FizzBuzz(50));  // Output: 0
        Console.WriteLine(FizzBuzz(78));  // Output: 2
        Console.WriteLine(FizzBuzz(79));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FizzBuzz((50L)) == (0L));
    Debug.Assert(FizzBuzz((78L)) == (2L));
    Debug.Assert(FizzBuzz((79L)) == (3L));
    Debug.Assert(FizzBuzz((100L)) == (3L));
    Debug.Assert(FizzBuzz((200L)) == (6L));
    Debug.Assert(FizzBuzz((4000L)) == (192L));
    Debug.Assert(FizzBuzz((10000L)) == (639L));
    Debug.Assert(FizzBuzz((100000L)) == (8026L));
    }

}
"
HumanEval_37,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //l'in çift indekslerinin değerlerine, ama sıralanmış.    //l' tek indekslerde l ile aynıdır, çift indekslerde ise değerleri eşittir.    //Bu fonksiyon bir liste alır ve bir liste döndürür l ' böyle ki     // >>> SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))
    // >>> SortEven((new List<long>(new long[]{(long)5L, (long)6L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)3L, (long)6L, (long)5L, (long)4L}))
    public static List<long> SortEven(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // This function takes a list l and returns a list l' such that
    // l' is identical to l in the odd indices, while its values at the even indices are equal
    // to the values of the even indices of l, but sorted.
    public static List<long> SortEven(List<long> l) {
        List<long> evenIndicesValues = new List<long>();

        // Collect values from even indices
        for (int i = 0; i < l.Count; i += 2) {
            evenIndicesValues.Add(l[i]);
        }

        // Sort the collected even index values
        evenIndicesValues.Sort();

        // Reconstruct the list with sorted values at even indices
        List<long> result = new List<long>(l);

        for (int i = 0, j = 0; i < result.Count; i += 2, j++) {
            result[i] = evenIndicesValues[j];
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortEven((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)9L, (long)0L, (long)123L, (long)1L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-10L, (long)3L, (long)-5L, (long)2L, (long)-3L, (long)3L, (long)5L, (long)0L, (long)9L, (long)1L, (long)123L}))));
    Debug.Assert(SortEven((new List<long>(new long[]{(long)5L, (long)8L, (long)-12L, (long)4L, (long)23L, (long)2L, (long)3L, (long)11L, (long)12L, (long)-10L}))).Equals((new List<long>(new long[]{(long)-12L, (long)8L, (long)3L, (long)4L, (long)5L, (long)2L, (long)12L, (long)11L, (long)23L, (long)-10L}))));
    }

}
"
HumanEval_39,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //prime_fib, aynı zamanda bir Fibonacci sayısı olan ve aynı zamanda bir asal sayı olan n-inci sayıyı gönderir.     // >>> PrimeFib((1L))
    // (2L)
    // >>> PrimeFib((2L))
    // (3L)
    // >>> PrimeFib((3L))
    // (5L)
    // >>> PrimeFib((4L))
    // (13L)
    // >>> PrimeFib((5L))
    // (89L)
    public static long PrimeFib(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Method to check if a number is prime
    public static bool IsPrime(long num)
    {
        if (num <= 1) return false;
        if (num == 2) return true;
        if (num % 2 == 0) return false;

        long boundary = (long)Math.Floor(Math.Sqrt(num));

        for (long i = 3; i <= boundary; i += 2)
        {
            if (num % i == 0)
                return false;
        }

        return true;
    }

    // Method to generate Fibonacci numbers and find the n-th prime Fibonacci
    public static long PrimeFib(long n)
    {
        long a = 1, b = 1;
        long primeFibCount = 0;

        while (true)
        {
            long temp = a;
            a = b;
            b = temp + b;

            if (IsPrime(a))
            {
                primeFibCount++;
                if (primeFibCount == n)
                {
                    return a;
                }
            }
        }
    }

    static void Main(string[] args)
    {
        Console.WriteLine(PrimeFib(1)); // Output: 2
        Console.WriteLine(PrimeFib(2)); // Output: 3
        Console.WriteLine(PrimeFib(3)); // Output: 5
        Console.WriteLine(PrimeFib(4)); // Output: 13
        Console.WriteLine(PrimeFib(5)); // Output: 89
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeFib((1L)) == (2L));
    Debug.Assert(PrimeFib((2L)) == (3L));
    Debug.Assert(PrimeFib((3L)) == (5L));
    Debug.Assert(PrimeFib((4L)) == (13L));
    Debug.Assert(PrimeFib((5L)) == (89L));
    Debug.Assert(PrimeFib((6L)) == (233L));
    Debug.Assert(PrimeFib((7L)) == (1597L));
    Debug.Assert(PrimeFib((8L)) == (28657L));
    Debug.Assert(PrimeFib((9L)) == (514229L));
    Debug.Assert(PrimeFib((10L)) == (433494437L));
    }

}
"
HumanEval_40,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //0'a denk gelir, diğer durumlarda yanlış.    //listede üç farklı öğe varsa doğru olarak döndürür.    //triples_sum_to_zero, bir tamsayı listesi alıyor.    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L})))
    // (true)
    // >>> TriplesSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool TriplesSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool TriplesSumToZero(List<long> l)
    {
        if (l.Count < 3)
            return false;

        l.Sort();

        for (int i = 0; i < l.Count - 2; i++)
        {
            if (i > 0 && l[i] == l[i - 1])
                continue;

            int left = i + 1;
            int right = l.Count - 1;

            while (left < right)
            {
                long sum = l[i] + l[left] + l[right];
                if (sum == 0)
                    return true;
                else if (sum < 0)
                    left++;
                else
                    right--;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)5L, (long)7L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)9L, (long)7L}))) == (true));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)-100L}))) == (false));
    Debug.Assert(TriplesSumToZero((new List<long>(new long[]{(long)100L, (long)3L, (long)5L, (long)-100L}))) == (false));
    }

}
"
HumanEval_41,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bu fonksiyon bu tür çarpışmaların sayısını çıkartır.    //Sanki çarpışmamışlar gibi.    //Ancak arabalar son derece sağlam ve güçlüdür. Sonuç olarak, hareket etmeye devam ederler.    //Soldan sağa giden bir araba, sağdan sola giden bir arabaya çarptığında.    //İki arabanın çarpıştığı söylenir.    //İki araba çetesi çok uzakta.    //n araba soldan sağa gidiyor; aynı anda, farklı bir dizi n araba     //Mükemmel düz, sonsuz uzun bir çizgi olan bir yol hayal edin.    public static long CarRaceCollision(long n) {
","// Each car moving left to right will collide with each car moving right to left.
        // So the total number of collisions is n * n.
        return n * n;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CarRaceCollision(5));  // Example usage
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CarRaceCollision((2L)) == (4L));
    Debug.Assert(CarRaceCollision((3L)) == (9L));
    Debug.Assert(CarRaceCollision((4L)) == (16L));
    Debug.Assert(CarRaceCollision((8L)) == (64L));
    Debug.Assert(CarRaceCollision((10L)) == (100L));
    }

}
"
HumanEval_42,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Geri dönüş listesi, 1 artışlı öğelerle.    // >>> IncrList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))
    // >>> IncrList((new List<long>(new long[]{(long)5L, (long)3L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L})))
    // (new List<long>(new long[]{(long)6L, (long)4L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))
    public static List<long> IncrList(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return list with elements incremented by 1.
    public static List<long> IncrList(List<long> l) {
        return l.Select(x => x + 1).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IncrList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)4L, (long)3L, (long)2L}))));
    Debug.Assert(IncrList((new List<long>(new long[]{(long)5L, (long)2L, (long)5L, (long)2L, (long)3L, (long)3L, (long)9L, (long)0L, (long)123L}))).Equals((new List<long>(new long[]{(long)6L, (long)3L, (long)6L, (long)3L, (long)4L, (long)4L, (long)10L, (long)1L, (long)124L}))));
    }

}
"
HumanEval_43,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //0'a denk gelir, diğer durumlarda yanlış.    //listede iki farklı öğe varsa doğru olarak döndürür.    //pairs_sum_to_zero, bir tamsayı listesi alıyor.    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L})))
    // (false)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L})))
    // (true)
    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L})))
    // (false)
    public static bool PairsSumToZero(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool PairsSumToZero(List<long> l)
    {
        HashSet<long> seenNumbers = new HashSet<long>();

        foreach (long number in l)
        {
            if (seenNumbers.Contains(-number))
            {
                return true;
            }
            seenNumbers.Add(number);
        }

        return false;
    }

    public static void Main(string[] args)
    {
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, 5L, 0L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 3L, -2L, 1L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 1L, 2L, 3L, 7L })); // false
        Console.WriteLine(PairsSumToZero(new List<long> { 2L, 4L, -5L, 3L, 5L, 7L })); // true
        Console.WriteLine(PairsSumToZero(new List<long> { 1L })); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)30L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)31L}))) == (true));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)30L}))) == (false));
    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)31L}))) == (false));
    }

}
"
HumanEval_44,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Temel sayılar 10'dan küçük.    //dönüştürme sonrası string temsilini döndürür.    //Giriş sayısının sayısal tabanını değiştirmek için x.    // >>> ChangeBase((8L), (3L))
    // (""22"")
    // >>> ChangeBase((8L), (2L))
    // (""1000"")
    // >>> ChangeBase((7L), (2L))
    // (""111"")
    public static string ChangeBase(long x, long numBase) {
","using System;
using System.Collections.Generic;

class Problem {
    // Change numerical base of input number x to base.
    // return string representation after the conversion.
    // base numbers are less than 10.
    public static string ChangeBase(long x, long numBase) {
        if (numBase < 2 || numBase > 9) 
            throw new ArgumentException(""Base must be between 2 and 9."");

        if (x < 0) 
            throw new ArgumentException(""Number must be non-negative."");

        if (x == 0) 
            return ""0"";

        string result = string.Empty;
        while (x > 0) {
            long remainder = x % numBase;
            result = remainder + result;
            x /= numBase;
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChangeBase((8L), (3L)).Equals((""22"")));
    Debug.Assert(ChangeBase((9L), (3L)).Equals((""100"")));
    Debug.Assert(ChangeBase((234L), (2L)).Equals((""11101010"")));
    Debug.Assert(ChangeBase((16L), (2L)).Equals((""10000"")));
    Debug.Assert(ChangeBase((8L), (2L)).Equals((""1000"")));
    Debug.Assert(ChangeBase((7L), (2L)).Equals((""111"")));
    Debug.Assert(ChangeBase((2L), (3L)).Equals((""2"")));
    Debug.Assert(ChangeBase((3L), (4L)).Equals((""3"")));
    Debug.Assert(ChangeBase((4L), (5L)).Equals((""4"")));
    Debug.Assert(ChangeBase((5L), (6L)).Equals((""5"")));
    Debug.Assert(ChangeBase((6L), (7L)).Equals((""6"")));
    Debug.Assert(ChangeBase((7L), (8L)).Equals((""7"")));
    }

}
"
HumanEval_45,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bir üçgen için bir kenar uzunluğu ve yüksek dönüş alanı verilmiştir.    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
","using System;

class Problem {
    // Given length of a side and height, return area for a triangle.
    // >>> TriangleArea((5L), (3L))
    // (7.5f)
    public static float TriangleArea(long a, long h) {
        return (a * h) / 2.0f;
    }

    static void Main(string[] args) {
        Console.WriteLine(TriangleArea(5L, 3L)); // Output: 7.5
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((5L), (3L)) == (7.5f));
    Debug.Assert(TriangleArea((2L), (2L)) == (2.0f));
    Debug.Assert(TriangleArea((10L), (8L)) == (40.0f));
    }

}
"
HumanEval_46,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Lütfen fib4 sayılar dizisinin n-inci elemanını verimli bir şekilde hesaplayacak bir fonksiyon yazın.    //fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).    //fib4(3) -> 0     //fib4(2) -> 2     //fib4(1) -> 0     //fib4 ((0) -> 0     //Fib4 sayı dizisi, Fibbonacci dizisine benzer bir dizidir ve aşağıdaki şekilde tanımlanır:     // >>> Fib4((5L))
    // (4L)
    // >>> Fib4((6L))
    // (8L)
    // >>> Fib4((7L))
    // (14L)
    public static long Fib4(long n) {
","public static long Fib4(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 2;
    if (n == 3) return 0;

    long[] fib4Seq = new long[n + 1];
    fib4Seq[0] = 0;
    fib4Seq[1] = 0;
    fib4Seq[2] = 2;
    fib4Seq[3] = 0;

    for (long i = 4; i <= n; i++) {
        fib4Seq[i] = fib4Seq[i - 1] + fib4Seq[i - 2] + fib4Seq[i - 3] + fib4Seq[i - 4];
    }

    return fib4Seq[n];
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib4((5L)) == (4L));
    Debug.Assert(Fib4((8L)) == (28L));
    Debug.Assert(Fib4((10L)) == (104L));
    Debug.Assert(Fib4((12L)) == (386L));
    }

}
"
HumanEval_47,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Listedeki elementlerin geri dönüş medyanı l.     // >>> Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (float)3L
    // >>> Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L})))
    // (15.0f)
    public static float Median(List<long> l) {
","public static float Median(List<long> l) {
        l.Sort();
        int count = l.Count;
        if (count % 2 == 1) {
            return (float)l[count / 2];
        } else {
            long mid1 = l[(count / 2) - 1];
            long mid2 = l[count / 2];
            return (mid1 + mid2) / 2.0f;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Median((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) == (float)3L);
    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L, (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));
    Debug.Assert(Median((new List<long>(new long[]{(long)5L}))) == (float)5L);
    Debug.Assert(Median((new List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));
    Debug.Assert(Median((new List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L, (long)7L}))) == (float)7L);
    }

}
"
HumanEval_48,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Verilen dizinin palindrom olup olmadığını kontrol eder .    // >>> IsPalindrome((""""))
    // (true)
    // >>> IsPalindrome((""aba""))
    // (true)
    // >>> IsPalindrome((""aaaaa""))
    // (true)
    // >>> IsPalindrome((""zbcd""))
    // (false)
    public static bool IsPalindrome(string text) {
","public static bool IsPalindrome(string text) {
    if (string.IsNullOrEmpty(text))
        return true;

    int left = 0;
    int right = text.Length - 1;

    while (left < right) {
        if (text[left] != text[right])
            return false;
        left++;
        right--;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsPalindrome(("""")) == (true));
    Debug.Assert(IsPalindrome((""aba"")) == (true));
    Debug.Assert(IsPalindrome((""aaaaa"")) == (true));
    Debug.Assert(IsPalindrome((""zbcd"")) == (false));
    Debug.Assert(IsPalindrome((""xywyx"")) == (true));
    Debug.Assert(IsPalindrome((""xywyz"")) == (false));
    Debug.Assert(IsPalindrome((""xywzx"")) == (false));
    }

}
"
HumanEval_49,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //2^n modulo p'yi döndürür (sayısal değerleri unutmayın).    // >>> Modp((3L), (5L))
    // (3L)
    // >>> Modp((1101L), (101L))
    // (2L)
    // >>> Modp((0L), (101L))
    // (1L)
    // >>> Modp((3L), (11L))
    // (8L)
    // >>> Modp((100L), (101L))
    // (1L)
    public static long Modp(long n, long p) {
","using System;
using System.Numerics;

class Problem {
    public static long Modp(long n, long p) {
        // Using the property of modular arithmetic: (a^b) % c = ((a % c)^b) % c
        // We are calculating (2^n) % p
        BigInteger baseNum = 2;
        BigInteger result = BigInteger.ModPow(baseNum, n, p);
        return (long)result;
    }

    static void Main(string[] args) {
        Console.WriteLine(Modp(3L, 5L));   // (3L)
        Console.WriteLine(Modp(1101L, 101L)); // (2L)
        Console.WriteLine(Modp(0L, 101L));   // (1L)
        Console.WriteLine(Modp(3L, 11L));   // (8L)
        Console.WriteLine(Modp(100L, 101L));  // (1L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Modp((3L), (5L)) == (3L));
    Debug.Assert(Modp((1101L), (101L)) == (2L));
    Debug.Assert(Modp((0L), (101L)) == (1L));
    Debug.Assert(Modp((3L), (11L)) == (8L));
    Debug.Assert(Modp((100L), (101L)) == (1L));
    Debug.Assert(Modp((30L), (5L)) == (4L));
    Debug.Assert(Modp((31L), (5L)) == (3L));
    }

}
"
HumanEval_51,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //remove_vowels, string alır ve vokallersiz string döndüren bir fonksiyondur.     // >>> RemoveVowels((""""))
    // ("""")
    // >>> RemoveVowels((""abcdef""))
    // (""bcdf"")
    // >>> RemoveVowels((""aaaaa""))
    // ("""")
    // >>> RemoveVowels((""aaBAA""))
    // (""B"")
    // >>> RemoveVowels((""zbcd""))
    // (""zbcd"")
    public static string RemoveVowels(string text) {
","HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        StringBuilder result = new StringBuilder();

        foreach (char c in text) {
            if (!vowels.Contains(c)) {
                result.Append(c);
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RemoveVowels(("""")).Equals(("""")));
    Debug.Assert(RemoveVowels((""abcdef\nghijklm"")).Equals((""bcdf\nghjklm"")));
    Debug.Assert(RemoveVowels((""fedcba"")).Equals((""fdcb"")));
    Debug.Assert(RemoveVowels((""eeeee"")).Equals(("""")));
    Debug.Assert(RemoveVowels((""acBAA"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""EcBOO"")).Equals((""cB"")));
    Debug.Assert(RemoveVowels((""ybcd"")).Equals((""ybcd"")));
    }

}
"
HumanEval_52,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Listedeki tüm sayılar eşik t'nin altında ise true değerini gönderir.     // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L))
    // (true)
    // >>> BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L))
    // (false)
    public static bool BelowThreshold(List<long> l, long t) {
","return l.All(x => x < t);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L})), (100L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (5L)) == (false));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (21L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})), (22L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (11L)) == (true));
    Debug.Assert(BelowThreshold((new List<long>(new long[]{(long)1L, (long)8L, (long)4L, (long)10L})), (10L)) == (false));
    }

}
"
HumanEval_53,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //İki sayı x ve y ekle .    // >>> Add((2L), (3L))
    // (5L)
    // >>> Add((5L), (7L))
    // (12L)
    public static long Add(long x, long y) {
","return x + y;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((0L), (1L)) == (1L));
    Debug.Assert(Add((1L), (0L)) == (1L));
    Debug.Assert(Add((2L), (3L)) == (5L));
    Debug.Assert(Add((5L), (7L)) == (12L));
    Debug.Assert(Add((7L), (5L)) == (12L));
    }

}
"
HumanEval_54,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //İki kelimenin aynı karakterlere sahip olup olmadığını kontrol edin.    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc""))
    // (true)
    // >>> SameChars((""abcd""), (""dddddddabc""))
    // (true)
    // >>> SameChars((""dddddddabc""), (""abcd""))
    // (true)
    // >>> SameChars((""eabcd""), (""dddddddabc""))
    // (false)
    // >>> SameChars((""abcd""), (""dddddddabce""))
    // (false)
    // >>> SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc""))
    // (false)
    public static bool SameChars(string s0, string s1) {
","public static bool SameChars(string s0, string s1) {
        // Return true if s1 contains all characters of s0
        return s0.All(c => s1.Contains(c)) && s1.All(c => s0.Contains(c));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddeddabc"")) == (true));
    Debug.Assert(SameChars((""abcd""), (""dddddddabc"")) == (true));
    Debug.Assert(SameChars((""dddddddabc""), (""abcd"")) == (true));
    Debug.Assert(SameChars((""eabcd""), (""dddddddabc"")) == (false));
    Debug.Assert(SameChars((""abcd""), (""dddddddabcf"")) == (false));
    Debug.Assert(SameChars((""eabcdzzzz""), (""dddzzzzzzzddddabc"")) == (false));
    Debug.Assert(SameChars((""aabb""), (""aaccc"")) == (false));
    }

}
"
HumanEval_55,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Fibonacci sayısını döndür.    // >>> Fib((10L))
    // (55L)
    // >>> Fib((1L))
    // (1L)
    // >>> Fib((8L))
    // (21L)
    public static long Fib(long n) {
","if (n <= 0) return 0;
    if (n == 1) return 1;

    long a = 0;
    long b = 1;

    for (long i = 2; i <= n; i++)
    {
        long temp = a + b;
        a = b;
        b = temp;
    }

    return b;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fib((10L)) == (55L));
    Debug.Assert(Fib((1L)) == (1L));
    Debug.Assert(Fib((8L)) == (21L));
    Debug.Assert(Fib((11L)) == (89L));
    Debug.Assert(Fib((12L)) == (144L));
    }

}
"
HumanEval_56,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //her açılış sütununun bir kapama sütunu varsa true döndür.     //parantezler ""<"" ve "">"" dizisidir.    // >>> CorrectBracketing((""<""))
    // (false)
    // >>> CorrectBracketing((""<>""))
    // (true)
    // >>> CorrectBracketing((""<<><>>""))
    // (true)
    // >>> CorrectBracketing((""><<>""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","public static bool CorrectBracketing(string brackets) 
{
    int balance = 0;
    foreach (char c in brackets) 
    {
        if (c == '<') 
        {
            balance++;
        } 
        else if (c == '>') 
        {
            balance--;
        }
        
        if (balance < 0) 
        {
            return false;
        }
    }

    return balance == 0;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""<>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<><>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<><>><>"")) == (true));
    Debug.Assert(CorrectBracketing((""<><><<<><><>><>><<><><<>>>"")) == (true));
    Debug.Assert(CorrectBracketing((""<<<><>>>>"")) == (false));
    Debug.Assert(CorrectBracketing((""><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<"")) == (false));
    Debug.Assert(CorrectBracketing((""<<<<"")) == (false));
    Debug.Assert(CorrectBracketing(("">"")) == (false));
    Debug.Assert(CorrectBracketing((""<<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>><<>"")) == (false));
    Debug.Assert(CorrectBracketing((""<><><<><>><>>><>"")) == (false));
    }

}
"
HumanEval_57,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Listede bulunan öğelerin monoton olarak artması veya azalması doğru olarak döndürülür.    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L})))
    // (true)
    // >>> Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L})))
    // (false)
    // >>> Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L})))
    // (true)
    public static bool Monotonic(List<long> l) {
","using System;
using System.Collections.Generic;

class Problem {
    // Return true if list elements are monotonically increasing or decreasing.
    public static bool Monotonic(List<long> l) {
        if (l.Count < 2) return true; // Lists with less than 2 elements are trivially monotonic.
        
        bool increasing = true;
        bool decreasing = true;

        for (int i = 1; i < l.Count; i++) {
            if (l[i] > l[i - 1]) {
                decreasing = false;
            } else if (l[i] < l[i - 1]) {
                increasing = false;
            }

            // If both flags are false, the list is not monotonic.
            if (!increasing && !decreasing) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)20L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)20L, (long)4L, (long)10L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)0L, (long)-10L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)5L, (long)60L}))) == (false));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)60L}))) == (true));
    Debug.Assert(Monotonic((new List<long>(new long[]{(long)9L, (long)9L, (long)9L, (long)9L}))) == (true));
    }

}
"
HumanEval_58,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //İki liste için sıralanmış benzersiz ortak öğeleri döndürür.    // >>> Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L})))
    // (new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))
    // >>> Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L})))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    public static List<long> Common(List<long> l1, List<long> l2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> Common(List<long> l1, List<long> l2)
    {
        // Use HashSet to store unique elements of l1
        var set1 = new HashSet<long>(l1);

        // Use HashSet to store unique elements of l2 and filter common elements
        var commonSet = new HashSet<long>(l2.Where(x => set1.Contains(x)));

        // Convert to a list, sort it and return
        var result = commonSet.ToList();
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L, (long)9L, (long)653L, (long)121L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))));
    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>())).Equals((new List<long>())));
    }

}
"
HumanEval_59,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //En büyük n'in asal çarpanını döndür. n > 1 ve asal değil.     // >>> LargestPrimeFactor((13195L))
    // (29L)
    // >>> LargestPrimeFactor((2048L))
    // (2L)
    public static long LargestPrimeFactor(long n) {
","using System;

class Problem {
    public static long LargestPrimeFactor(long n) {
        long largestFactor = -1;
        
        // Remove the factor of 2
        while (n % 2 == 0) {
            largestFactor = 2;
            n /= 2;
        }

        // Check odd factors from 3 upwards
        for (long i = 3; i <= Math.Sqrt(n); i += 2) {
            while (n % i == 0) {
                largestFactor = i;
                n /= i;
            }
        }

        // If n becomes a prime number greater than 2
        if (n > 2) {
            largestFactor = n;
        }

        return largestFactor;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestPrimeFactor((15L)) == (5L));
    Debug.Assert(LargestPrimeFactor((27L)) == (3L));
    Debug.Assert(LargestPrimeFactor((63L)) == (7L));
    Debug.Assert(LargestPrimeFactor((330L)) == (11L));
    Debug.Assert(LargestPrimeFactor((13195L)) == (29L));
    }

}
"
HumanEval_60,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //sum_to_n , 1 ile n arasındaki sayıları toplayan bir fonksiyondur .    // >>> SumToN((30L))
    // (465L)
    // >>> SumToN((100L))
    // (5050L)
    // >>> SumToN((5L))
    // (15L)
    // >>> SumToN((10L))
    // (55L)
    // >>> SumToN((1L))
    // (1L)
    public static long SumToN(long n) {
","return n * (n + 1) / 2;
}
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumToN((1L)) == (1L));
    Debug.Assert(SumToN((6L)) == (21L));
    Debug.Assert(SumToN((11L)) == (66L));
    Debug.Assert(SumToN((30L)) == (465L));
    Debug.Assert(SumToN((100L)) == (5050L));
    }

}
"
HumanEval_61,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //her açılış sütununun bir kapama sütunu varsa true döndür.     //parantezler ""("" ve "" "" ' dizisidir.    // >>> CorrectBracketing((""(""))
    // (false)
    // >>> CorrectBracketing((""()""))
    // (true)
    // >>> CorrectBracketing((""(()())""))
    // (true)
    // >>> CorrectBracketing(("")(()""))
    // (false)
    public static bool CorrectBracketing(string brackets) {
","using System;

class Problem {
    public static bool CorrectBracketing(string brackets) {
        int balance = 0;
        foreach (char c in brackets) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false;
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CorrectBracketing((""()"")) == (true));
    Debug.Assert(CorrectBracketing((""(()())"")) == (true));
    Debug.Assert(CorrectBracketing((""()()(()())()"")) == (true));
    Debug.Assert(CorrectBracketing((""()()((()()())())(()()(()))"")) == (true));
    Debug.Assert(CorrectBracketing((""((()())))"")) == (false));
    Debug.Assert(CorrectBracketing(("")(()"")) == (false));
    Debug.Assert(CorrectBracketing((""("")) == (false));
    Debug.Assert(CorrectBracketing((""(((("")) == (false));
    Debug.Assert(CorrectBracketing(("")"")) == (false));
    Debug.Assert(CorrectBracketing((""(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())())(()"")) == (false));
    Debug.Assert(CorrectBracketing((""()()(()())()))()"")) == (false));
    }

}
"
HumanEval_62,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bu polinomun türevini aynı formda gönder.    //xs[0] + xs[1] * x + xs[2] * x^2 + ....     //xs bir polinomunun katsayısını temsil eder.    // >>> Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))
    // >>> Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)6L}))
    public static List<long> Derivative(List<long> xs) {
","public static List<long> Derivative(List<long> xs) {
        List<long> derivative = new List<long>();
        for (int i = 1; i < xs.Count; i++) {
            derivative.Add(xs[i] * i);
        }
        return derivative;
    }

    static void Main(string[] args) {
        List<long> poly1 = new List<long>{3L, 1L, 2L, 4L, 5L};
        List<long> result1 = Derivative(poly1);
        Console.WriteLine(string.Join("", "", result1));

        List<long> poly2 = new List<long>{1L, 2L, 3L};
        List<long> result2 = Derivative(poly2);
        Console.WriteLine(string.Join("", "", result2));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)12L, (long)20L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)6L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)3L, (long)2L, (long)1L, (long)0L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)0L, (long)16L}))));
    Debug.Assert(Derivative((new List<long>(new long[]{(long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_63,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Lütfen fibfib sayılar dizisinin n-inci elemanını verimli bir şekilde hesaplayacak bir fonksiyon yazın.    //fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3).     //Fibib (fiber)    //Fibfib ((1)) == 0     //Fibfib ((0) == 0     //FibFib sayı dizisi, Fibbonacci dizisine benzer bir dizidir ve aşağıdaki şekilde tanımlanır:     // >>> Fibfib((1L))
    // (0L)
    // >>> Fibfib((5L))
    // (4L)
    // >>> Fibfib((8L))
    // (24L)
    public static long Fibfib(long n) {
","public static long Fibfib(long n) {
    if (n == 0) return 0;
    if (n == 1) return 0;
    if (n == 2) return 1;

    long a = 0, b = 0, c = 1;
    long result = 0;

    for (long i = 3; i <= n; i++) {
        result = a + b + c;
        a = b;
        b = c;
        c = result;
    }

    return result;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Fibfib((2L)) == (1L));
    Debug.Assert(Fibfib((1L)) == (0L));
    Debug.Assert(Fibfib((5L)) == (4L));
    Debug.Assert(Fibfib((8L)) == (24L));
    Debug.Assert(Fibfib((10L)) == (81L));
    Debug.Assert(Fibfib((12L)) == (274L));
    Debug.Assert(Fibfib((14L)) == (927L));
    }

}
"
HumanEval_64,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Vokal, ama sadece verilen kelimenin sonunda olduğunda.    //Bu durumda sesler 'a', 'e', 'i', 'o', 'u'dur. Burada, 'y' de a     //Bir kelime girdi olarak ve dize sesli sayısını döndürür.    //Bir fonksiyon yazın.    // >>> VowelsCount((""abcde""))
    // (2L)
    // >>> VowelsCount((""ACEDY""))
    // (3L)
    public static long VowelsCount(string s) {
","using System;

class Problem {
    public static long VowelsCount(string s) {
        if (s == null) return 0;

        s = s.ToLower();
        long count = 0;
        
        for (int i = 0; i < s.Length; i++) {
            char c = s[i];
            if (""aeiou"".Contains(c) || (c == 'y' && i == s.Length - 1)) {
                count++;
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        Console.WriteLine(VowelsCount(""abcde""));  // Output: 2
        Console.WriteLine(VowelsCount(""ACEDY""));  // Output: 3
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(VowelsCount((""abcde"")) == (2L));
    Debug.Assert(VowelsCount((""Alone"")) == (3L));
    Debug.Assert(VowelsCount((""key"")) == (2L));
    Debug.Assert(VowelsCount((""bye"")) == (1L));
    Debug.Assert(VowelsCount((""keY"")) == (2L));
    Debug.Assert(VowelsCount((""bYe"")) == (1L));
    Debug.Assert(VowelsCount((""ACEDY"")) == (3L));
    }

}
"
HumanEval_65,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Eğer shift > sayısal sayı ise, geriye dönük sayısal sayı.    //ve sonucu bir dize olarak döndürür.     //Dairesel olarak x tam sayısının basamaklarını doğruya kaydırın.    // >>> CircularShift((12L), (1L))
    // (""21"")
    // >>> CircularShift((12L), (2L))
    // (""12"")
    public static string CircularShift(long x, long shift) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    // Circular shift the digits of the integer x, shift the digits right by shift
    // and return the result as a string.
    // If shift > number of digits, return digits reversed.
    
    public static string CircularShift(long x, long shift) {
        string digits = x.ToString();
        int length = digits.Length;
        
        if (shift > length) {
            char[] reversedDigits = digits.ToCharArray();
            Array.Reverse(reversedDigits);
            return new string(reversedDigits);
        }

        shift = shift % length;  // Normalize shift
        string shiftedPart = digits.Substring(length - (int)shift);
        string remainingPart = digits.Substring(0, length - (int)shift);
        return shiftedPart + remainingPart;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CircularShift((100L), (2L)).Equals((""001"")));
    Debug.Assert(CircularShift((12L), (2L)).Equals((""12"")));
    Debug.Assert(CircularShift((97L), (8L)).Equals((""79"")));
    Debug.Assert(CircularShift((12L), (1L)).Equals((""21"")));
    Debug.Assert(CircularShift((11L), (101L)).Equals((""11"")));
    }

}
"
HumanEval_66,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //ASCII kodları.    //Bir dizeyi giriş olarak alan ve yalnızca üst karakterlerin toplamını iade eden bir fonksiyon yazın'     //Görev     // >>> Digitsum((""""))
    // (0L)
    // >>> Digitsum((""abAB""))
    // (131L)
    // >>> Digitsum((""abcCd""))
    // (67L)
    // >>> Digitsum((""helloE""))
    // (69L)
    // >>> Digitsum((""woArBld""))
    // (131L)
    // >>> Digitsum((""aAaaaXa""))
    // (153L)
    public static long Digitsum(string s) {
","public static long Digitsum(string s) {
    long sum = 0;
    foreach (char c in s) {
        if (char.IsUpper(c)) {
            sum += c; // Add ASCII value of the upper case letters.
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digitsum(("""")) == (0L));
    Debug.Assert(Digitsum((""abAB"")) == (131L));
    Debug.Assert(Digitsum((""abcCd"")) == (67L));
    Debug.Assert(Digitsum((""helloE"")) == (69L));
    Debug.Assert(Digitsum((""woArBld"")) == (131L));
    Debug.Assert(Digitsum((""aAaaaXa"")) == (153L));
    Debug.Assert(Digitsum(("" How are yOu?"")) == (151L));
    Debug.Assert(Digitsum((""You arE Very Smart"")) == (327L));
    }

}
"
HumanEval_67,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Çeviri için:    //sepette, sepette bulunan mango meyvelerinin sayısını gönderir.    //Portakal ve elma ve meyvelerin toplam sayısını temsil eden tam sayı     //Elma, portakal ve mango meyveleri.    //Bu sepetin içinde bulunan bir meyve sepetinde dağıtılanlar .    //Bu görevde size bir dizi elma ve portakal verilecek.    // >>> FruitDistribution((""5 apples and 6 oranges""), (19L))
    // (8L)
    // >>> FruitDistribution((""0 apples and 1 oranges""), (3L))
    // (2L)
    // >>> FruitDistribution((""2 apples and 3 oranges""), (100L))
    // (95L)
    // >>> FruitDistribution((""100 apples and 1 oranges""), (120L))
    // (19L)
    public static long FruitDistribution(string s, long n) {
","using System;

class Problem {
    public static long FruitDistribution(string s, long n) {
        var parts = s.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        long apples = long.Parse(parts[0]);
        long oranges = long.Parse(parts[3]);

        long totalApplesAndOranges = apples + oranges;
        long mangoes = n - totalApplesAndOranges;
        
        return mangoes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (19L)) == (8L));
    Debug.Assert(FruitDistribution((""5 apples and 6 oranges""), (21L)) == (10L));
    Debug.Assert(FruitDistribution((""0 apples and 1 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""1 apples and 0 oranges""), (3L)) == (2L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (100L)) == (95L));
    Debug.Assert(FruitDistribution((""2 apples and 3 oranges""), (5L)) == (0L));
    Debug.Assert(FruitDistribution((""1 apples and 100 oranges""), (120L)) == (19L));
    }

}
"
HumanEval_68,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek 1:     //Eğer çift değerler yoksa veya verilen liste boşsa, [] döndürülür.    //Çıkarılan düğüm bir listede döndürülmelidir, [ smalest_value, its index ],     //Aynı en küçük çift değere sahip birden fazla düğüm bulunursa en küçük indeksi olan düğümü döndürür.     //Çıkarılan düğüm, en küçük çift değere sahip düğüm olmalıdır.    //Görevin düğümlerden birini koparıp geri vermek.    //""Negatif olmayan tamsayı düğümleri olan bir ağaç dalını temsil eden bir liste verildiğinde     // >>> Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 2:
    // >>> Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (new List<long>(new long[]{(long)2L, (long)1L}))
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.
    // Example 3:
    // >>> Pluck((new List<long>()))
    // (new List<long>())
    // Example 4:
    // >>> Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L})))
    // (new List<long>(new long[]{(long)0L, (long)1L}))
    // Explanation: 0 is the smallest value, but  there are two zeros,
    // so we will choose the first zero, which has the smallest index.
    // Constraints:
    // * 1 <= nodes.length <= 10000
    // * 0 <= node.value
    public static List<long> Pluck(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Pluck(List<long> arr)
    {
        long smallestEven = long.MaxValue;
        int indexOfSmallest = -1;

        for (int i = 0; i < arr.Count; i++)
        {
            if (arr[i] % 2 == 0 && arr[i] < smallestEven)
            {
                smallestEven = arr[i];
                indexOfSmallest = i;
            }
        }

        if (indexOfSmallest == -1)
        {
            return new List<long>();
        }
        else
        {
            return new List<long> { smallestEven, indexOfSmallest };
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Pluck((new List<long>(new long[]{(long)4L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))).Equals((new List<long>(new long[]{(long)2L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>())).Equals((new List<long>())));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)0L, (long)3L, (long)0L, (long)4L, (long)2L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)0L, (long)5L, (long)3L}))).Equals((new List<long>(new long[]{(long)0L, (long)3L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)5L, (long)4L, (long)8L, (long)4L, (long)8L}))).Equals((new List<long>(new long[]{(long)4L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)6L, (long)7L, (long)1L}))).Equals((new List<long>(new long[]{(long)6L, (long)1L}))));
    Debug.Assert(Pluck((new List<long>(new long[]{(long)7L, (long)9L, (long)7L, (long)1L}))).Equals((new List<long>())));
    }

}
"
HumanEval_69,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Eğer böyle bir değer yoksa, -1 döndürülür.    //Bir tamsayının sıklığı, listede kaç kez göründüğü sayısıdır.    //sıfır ve tamsayının değerinden daha büyük veya eşit bir frekansı vardır.    //Size pozitif tam sayılar listesi veriliyor. 'dan büyük olan en büyük tam sayıyı döndürün.    // >>> Search((new List<long>(new long[]{(long)4L, (long)1L, (long)2L, (long)2L, (long)3L, (long)1L})))
    // (2L)
    // >>> Search((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L, (long)4L})))
    // (3L)
    // >>> Search((new List<long>(new long[]{(long)5L, (long)5L, (long)4L, (long)4L, (long)4L})))
    // (-1L)
    public static long Search(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static long Search(List<long> lst)
    {
        // Create a dictionary to store the frequency of each number
        Dictionary<long, long> frequency = new Dictionary<long, long>();

        // Count the frequency of each number in the list
        foreach (long num in lst)
        {
            if (frequency.ContainsKey(num))
            {
                frequency[num]++;
            }
            else
            {
                frequency[num] = 1;
            }
        }

        // Variable to store the greatest integer found
        long result = -1;

        // Go through each item in the frequency dictionary
        foreach (var kvp in frequency)
        {
            long number = kvp.Key;
            long freq = kvp.Value;

            // Check if the number's frequency is greater than or equal to the number itself
            if (freq >= number && number > 0)
            {
                // Update the result if this number is greater than the current result
                result = Math.Max(result, number);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)4L, (long)1L, (long)4L, (long)1L, (long)4L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)3L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L, (long)8L}))) == (8L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)3L, (long)3L, (long)2L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)7L, (long)8L, (long)8L, (long)4L, (long)8L, (long)7L, (long)3L, (long)9L, (long)6L, (long)5L, (long)10L, (long)4L, (long)3L, (long)6L, (long)7L, (long)1L, (long)7L, (long)4L, (long)10L, (long)8L, (long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)2L, (long)8L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)7L, (long)1L, (long)8L, (long)8L, (long)10L, (long)5L, (long)8L, (long)5L, (long)3L, (long)10L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)3L, (long)6L, (long)5L, (long)6L, (long)4L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)6L, (long)7L, (long)1L, (long)4L, (long)7L, (long)1L, (long)8L, (long)8L, (long)9L, (long)8L, (long)10L, (long)10L, (long)8L, (long)4L, (long)10L, (long)4L, (long)10L, (long)1L, (long)2L, (long)9L, (long)5L, (long)7L, (long)9L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)9L, (long)10L, (long)1L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)6L, (long)9L, (long)7L, (long)5L, (long)8L, (long)7L, (long)5L, (long)3L, (long)7L, (long)5L, (long)10L, (long)10L, (long)3L, (long)6L, (long)10L, (long)2L, (long)8L, (long)6L, (long)5L, (long)4L, (long)9L, (long)5L, (long)3L, (long)10L}))) == (5L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)8L, (long)8L, (long)10L, (long)6L, (long)4L, (long)3L, (long)5L, (long)8L, (long)2L, (long)4L, (long)2L, (long)8L, (long)4L, (long)6L, (long)10L, (long)4L, (long)2L, (long)1L, (long)10L, (long)2L, (long)1L, (long)1L, (long)5L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)10L, (long)4L, (long)8L, (long)2L, (long)10L, (long)5L, (long)1L, (long)2L, (long)9L, (long)5L, (long)5L, (long)6L, (long)3L, (long)8L, (long)6L, (long)4L, (long)10L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)1L, (long)6L, (long)10L, (long)1L, (long)6L, (long)9L, (long)10L, (long)8L, (long)6L, (long)8L, (long)7L, (long)3L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)2L, (long)4L, (long)1L, (long)5L, (long)1L, (long)5L, (long)2L, (long)5L, (long)7L, (long)7L, (long)7L, (long)3L, (long)10L, (long)1L, (long)5L, (long)4L, (long)2L, (long)8L, (long)4L, (long)1L, (long)9L, (long)10L, (long)7L, (long)10L, (long)2L, (long)8L, (long)10L, (long)9L, (long)4L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)2L, (long)6L, (long)4L, (long)2L, (long)8L, (long)7L, (long)5L, (long)6L, (long)4L, (long)10L, (long)4L, (long)6L, (long)3L, (long)7L, (long)8L, (long)8L, (long)3L, (long)1L, (long)4L, (long)2L, (long)2L, (long)10L, (long)7L}))) == (4L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)8L, (long)6L, (long)10L, (long)2L, (long)6L, (long)10L, (long)2L, (long)7L, (long)8L, (long)10L, (long)3L, (long)8L, (long)2L, (long)6L, (long)2L, (long)3L, (long)1L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)5L, (long)3L, (long)9L, (long)5L, (long)6L, (long)3L, (long)2L, (long)8L, (long)5L, (long)6L, (long)10L, (long)10L, (long)6L, (long)8L, (long)4L, (long)10L, (long)7L, (long)7L, (long)10L, (long)8L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)10L}))) == (-1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)9L, (long)7L, (long)7L, (long)2L, (long)4L, (long)7L, (long)2L, (long)10L, (long)9L, (long)7L, (long)5L, (long)7L, (long)2L}))) == (2L));
    Debug.Assert(Search((new List<long>(new long[]{(long)5L, (long)4L, (long)10L, (long)2L, (long)1L, (long)1L, (long)10L, (long)3L, (long)6L, (long)1L, (long)8L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)7L, (long)9L, (long)9L, (long)9L, (long)3L, (long)4L, (long)1L, (long)5L, (long)9L, (long)1L, (long)2L, (long)1L, (long)1L, (long)10L, (long)7L, (long)5L, (long)6L, (long)7L, (long)6L, (long)7L, (long)7L, (long)6L}))) == (1L));
    Debug.Assert(Search((new List<long>(new long[]{(long)3L, (long)10L, (long)10L, (long)9L, (long)2L}))) == (-1L));
    }

}
"
HumanEval_70,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Sonra kalan tam sayılar en yüksek, sonra en düşük ve böyle devam eder.    //Garip sıralama, minimum değerle başladığınızda,     //Tam sayılar listesi verildiğinde, sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra sıra    // >>> StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))
    // >>> StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L})))
    // (new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))
    // >>> StrangeSortList((new List<long>()))
    // (new List<long>())
    public static List<long> StrangeSortList(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> StrangeSortList(List<long> lst) {
        List<long> result = new List<long>();
        lst.Sort();
        int start = 0;
        int end = lst.Count - 1;
        
        while (start <= end) {
            if (start <= end) {
                result.Add(lst[start]);
                start++;
            }
            if (start <= end) {
                result.Add(lst[end]);
                end--;
            }
        }
        
        return result;
    }
    
    static void Main(string[] args) {
        var example1 = StrangeSortList(new List<long> { 1L, 2L, 3L, 4L });
        var example2 = StrangeSortList(new List<long> { 5L, 5L, 5L, 5L });
        var example3 = StrangeSortList(new List<long>());

        Console.WriteLine(string.Join("", "", example1)); // Output: 1, 4, 2, 3
        Console.WriteLine(string.Join("", "", example2)); // Output: 5, 5, 5, 5
        Console.WriteLine(string.Join("", "", example3)); // Output: (empty line)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))).Equals((new List<long>(new long[]{(long)5L, (long)9L, (long)6L, (long)8L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)9L, (long)5L, (long)8L, (long)6L, (long)7L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))).Equals((new List<long>(new long[]{(long)5L, (long)5L, (long)5L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>())).Equals((new List<long>())));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L}))).Equals((new List<long>(new long[]{(long)1L, (long)8L, (long)2L, (long)7L, (long)3L, (long)6L, (long)4L, (long)5L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)0L, (long)2L, (long)2L, (long)2L, (long)5L, (long)5L, (long)-5L, (long)-5L}))).Equals((new List<long>(new long[]{(long)-5L, (long)5L, (long)-5L, (long)5L, (long)0L, (long)2L, (long)2L, (long)2L}))));
    Debug.Assert(StrangeSortList((new List<long>(new long[]{(long)111111L}))).Equals((new List<long>(new long[]{(long)111111L}))));
    }

}
"
HumanEval_71,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Üçüncü tarafta.    //Üç kenarlı üçgen , iki kenarının toplamı daha büyükse geçerlidir .    //Aksi takdirde -1 döndürür .    //Üç kenar geçerli bir üçgen oluşturursa üçgen 2 ondalık noktaya yuvarlanır.     //Bir üçgenin üç kenarının uzunlukları verilmiş.    // >>> TriangleArea((3L), (4L), (5L))
    // (6.0f)
    // >>> TriangleArea((1L), (2L), (10L))
    // (float)-1L
    public static float TriangleArea(long a, long b, long c) {
","public static float TriangleArea(long a, long b, long c) {
    // Check if the sides form a valid triangle using the triangle inequality theorem
    if (a + b > c && a + c > b && b + c > a) {
        // Use Heron's formula to calculate the area of the triangle
        double s = (a + b + c) / 2.0;
        double area = Math.Sqrt(s * (s - a) * (s - b) * (s - c));
        return (float)Math.Round(area, 2);
    }
    return -1;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TriangleArea((3L), (4L), (5L)) == (6.0f));
    Debug.Assert(TriangleArea((1L), (2L), (10L)) == (float)-1L);
    Debug.Assert(TriangleArea((4L), (8L), (5L)) == (8.18f));
    Debug.Assert(TriangleArea((2L), (2L), (2L)) == (1.73f));
    Debug.Assert(TriangleArea((1L), (2L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((10L), (5L), (7L)) == (16.25f));
    Debug.Assert(TriangleArea((2L), (6L), (3L)) == (float)-1L);
    Debug.Assert(TriangleArea((1L), (1L), (1L)) == (0.43f));
    Debug.Assert(TriangleArea((2L), (2L), (10L)) == (float)-1L);
    }

}
"
HumanEval_72,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Objekt q, dengeli ise uçar (bu bir palindromik listedir) ve elemanlarının toplamı mümkün olan maksimum ağırlıktan az veya eşitse w.    //Eğer q nesnesi uçarsa doğru, aksi takdirde yanlış döndüren bir fonksiyon yazın.     // >>> WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L))
    // (false)
    // # 1+2 is less than the maximum possible weight, but it's unbalanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L))
    // (false)
    // # it's balanced, but 3+2+3 is more than the maximum possible weight.
    // >>> WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L))
    // (true)
    // # 3+2+3 is less than the maximum possible weight, and it's balanced.
    // >>> WillItFly((new List<long>(new long[]{(long)3L})), (5L))
    // (true)
    // # 3 is less than the maximum possible weight, and it's balanced.
    public static bool WillItFly(List<long> q, long w) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool WillItFly(List<long> q, long w)
    {
        if (IsPalindromic(q) && SumIsLessThanOrEqual(q, w))
        {
            return true;
        }
        return false;
    }

    private static bool IsPalindromic(List<long> q)
    {
        int count = q.Count;
        for (int i = 0; i < count / 2; i++)
        {
            if (q[i] != q[count - i - 1])
            {
                return false;
            }
        }
        return true;
    }

    private static bool SumIsLessThanOrEqual(List<long> q, long w)
    {
        long sum = 0;
        foreach (var item in q)
        {
            sum += item;
            if (sum > w)
            {
                return false;
            }
        }
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (9L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L})), (5L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L})), (5L)) == (true));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)3L, (long)2L, (long)3L})), (1L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (6L)) == (false));
    Debug.Assert(WillItFly((new List<long>(new long[]{(long)5L})), (5L)) == (true));
    }

}
"
HumanEval_73,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Bir değişimle, bir öğeyi herhangi bir diğer öğeye değiştirebilirsiniz.    //listesi palindromik yapabilmesi için değiştirilmesi gerekir. Palindromik bir liste,     //Bir tam sayılar listesi verildiğinde,                   // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L})))
    // (4L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L})))
    // (1L)
    // >>> SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L})))
    // (0L)
    public static long SmallestChange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SmallestChange(List<long> arr)
    {
        long changes = 0;
        int left = 0;
        int right = arr.Count - 1;

        while (left < right)
        {
            if (arr[left] != arr[right])
            {
                changes++;
            }
            left++;
            right--;
        }

        return changes;
    }

    static void Main()
    {
        // Example usage:
        List<long> list1 = new List<long> { 1L, 2L, 3L, 5L, 4L, 7L, 9L, 6L };
        Console.WriteLine(SmallestChange(list1)); // Output: 4

        List<long> list2 = new List<long> { 1L, 2L, 3L, 4L, 3L, 2L, 2L };
        Console.WriteLine(SmallestChange(list2)); // Output: 1

        List<long> list3 = new List<long> { 1L, 2L, 3L, 2L, 1L };
        Console.WriteLine(SmallestChange(list3)); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L, (long)4L, (long)7L, (long)9L, (long)6L}))) == (4L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)3L, (long)2L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)4L, (long)4L, (long)2L}))) == (1L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)3L, (long)1L, (long)1L, (long)3L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(SmallestChange((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    }

}
"
HumanEval_74,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //Eğer iki listede de aynı sayıda karakter varsa, ilk listeyi geri gönderin.    //Listedeki tüm dizelerdeki karakterlerin toplam sayısı diğer listeden daha az.    //İki dize listesi kabul eden ve  olan listeyi iade eden bir fonksiyon yazın .    // >>> TotalMatch((new List<string>()), (new List<string>()))
    // (new List<string>())
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""})))
    // (new List<string>(new string[]{(string)""hi"", (string)""admin""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""})))
    // (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))
    // >>> TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""})))
    // (new List<string>(new string[]{(string)""4""}))
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<string> TotalMatch(List<string> lst1, List<string> lst2)
    {
        int totalCharsLst1 = lst1.Sum(s => s.Length);
        int totalCharsLst2 = lst2.Sum(s => s.Length);

        if (totalCharsLst1 <= totalCharsLst2)
        {
            return lst1;
        }
        else
        {
            return lst2;
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>())).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hi"", (string)""hi"", (string)""admin"", (string)""project""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""4""})), (new List<string>(new string[]{(string)""1"", (string)""2"", (string)""3"", (string)""4"", (string)""5""}))).Equals((new List<string>(new string[]{(string)""4""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""Hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""Hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))).Equals((new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hi""}))));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""hi"", (string)""admin""})), (new List<string>(new string[]{(string)""hI"", (string)""hi"", (string)""hii""}))).Equals((new List<string>(new string[]{(string)""hi"", (string)""admin""}))));
    Debug.Assert(TotalMatch((new List<string>()), (new List<string>(new string[]{(string)""this""}))).Equals((new List<string>())));
    Debug.Assert(TotalMatch((new List<string>(new string[]{(string)""this""})), (new List<string>())).Equals((new List<string>())));
    }

}
"
HumanEval_75,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //(a) 'nin 100'den küçük olduğunu bilerek.    //Ve yanlış başka.    //Eğer verilen sayı 3 asal sayının çarpımı ise doğru değerini veren bir fonksiyon yazın .    // >>> IsMultiplyPrime((30L))
    // (true)
    // 30 = 2 * 3 * 5
    public static bool IsMultiplyPrime(long a) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsMultiplyPrime(long a) {
        if (a >= 100) return false;
        
        List<long> primes = GeneratePrimes(100);
        
        int count = 0;
        foreach (long prime in primes) {
            while (a % prime == 0) {
                a /= prime;
                count++;
            }
            if (count > 3) break;
        }
        
        return a == 1 && count == 3;
    }

    private static List<long> GeneratePrimes(int max) {
        List<long> primes = new List<long>();
        bool[] isPrime = new bool[max + 1];
        for (int i = 2; i <= max; i++) isPrime[i] = true;

        for (int i = 2; i * i <= max; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= max; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        for (int i = 2; i <= max; i++) {
            if (isPrime[i]) primes.Add(i);
        }

        return primes;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsMultiplyPrime((5L)) == (false));
    Debug.Assert(IsMultiplyPrime((30L)) == (true));
    Debug.Assert(IsMultiplyPrime((8L)) == (true));
    Debug.Assert(IsMultiplyPrime((10L)) == (false));
    Debug.Assert(IsMultiplyPrime((125L)) == (true));
    Debug.Assert(IsMultiplyPrime((105L)) == (true));
    Debug.Assert(IsMultiplyPrime((126L)) == (false));
    Debug.Assert(IsMultiplyPrime((729L)) == (false));
    Debug.Assert(IsMultiplyPrime((891L)) == (false));
    Debug.Assert(IsMultiplyPrime((1001L)) == (true));
    }

}
"
HumanEval_76,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //x, n'in basit bir kuvveti, eğer n**int=x     //n'in kuvveti ve diğer durumlarda false.    //Görevin , bir sayı x basit bir  ise doğru döndüren bir fonksiyon yazmak .    // >>> IsSimplePower((1L), (4L))
    // (true)
    // >>> IsSimplePower((2L), (2L))
    // (true)
    // >>> IsSimplePower((8L), (2L))
    // (true)
    // >>> IsSimplePower((3L), (2L))
    // (false)
    // >>> IsSimplePower((3L), (1L))
    // (false)
    // >>> IsSimplePower((5L), (3L))
    // (false)
    public static bool IsSimplePower(long x, long n) {
","if (x < 1 || n < 2)
        return false;

    while (x > 1)
    {
        if (x % n != 0)
            return false;
        x /= n;
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSimplePower((16L), (2L)) == (true));
    Debug.Assert(IsSimplePower((143214L), (16L)) == (false));
    Debug.Assert(IsSimplePower((4L), (2L)) == (true));
    Debug.Assert(IsSimplePower((9L), (3L)) == (true));
    Debug.Assert(IsSimplePower((16L), (4L)) == (true));
    Debug.Assert(IsSimplePower((24L), (2L)) == (false));
    Debug.Assert(IsSimplePower((128L), (4L)) == (false));
    Debug.Assert(IsSimplePower((12L), (6L)) == (false));
    Debug.Assert(IsSimplePower((1L), (1L)) == (true));
    Debug.Assert(IsSimplePower((1L), (12L)) == (true));
    }

}
"
HumanEval_77,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Not: Girdi her zaman geçerli olduğunu varsayın.    //Eğer bu sayı bir tamsayının küpü ise.    //Bir tamsayı a alıp true döndüren bir fonksiyon yazın .    // >>> Iscube((1L))
    // (true)
    // >>> Iscube((2L))
    // (false)
    // >>> Iscube((-1L))
    // (true)
    // >>> Iscube((64L))
    // (true)
    // >>> Iscube((0L))
    // (true)
    // >>> Iscube((180L))
    // (false)
    public static bool Iscube(long a) {
","using System;

class Problem {
    public static bool Iscube(long a) {
        if (a == 0) return true;
        long absA = Math.Abs(a);
        long cubeRoot = (long)Math.Round(Math.Pow(absA, 1.0 / 3.0));
        return cubeRoot * cubeRoot * cubeRoot == absA;
    }

    static void Main(string[] args) {
        Console.WriteLine(Iscube(1L));    // true
        Console.WriteLine(Iscube(2L));    // false
        Console.WriteLine(Iscube(-1L));   // true
        Console.WriteLine(Iscube(64L));   // true
        Console.WriteLine(Iscube(0L));    // true
        Console.WriteLine(Iscube(180L));  // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Iscube((1L)) == (true));
    Debug.Assert(Iscube((2L)) == (false));
    Debug.Assert(Iscube((-1L)) == (true));
    Debug.Assert(Iscube((64L)) == (true));
    Debug.Assert(Iscube((180L)) == (false));
    Debug.Assert(Iscube((1000L)) == (true));
    Debug.Assert(Iscube((0L)) == (true));
    Debug.Assert(Iscube((1729L)) == (false));
    }

}
"
HumanEval_78,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //ve A,B,C,D,E,F sembolleri her zaman büyük harflerle yazılır.    //Not: Girişin her zaman doğru veya boş dize olduğunu varsayın,     //B (= ondalık 11), D (= ondalık 13).     //Yani aşağıdaki rakamlardan bir tanesini belirlemeniz gerekiyor: 2, 3, 5, 7,     //Asal sayılar 2, 3, 5, 7, 11, 13, 17,...    //Altmışlı basamağı 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.    //1'den büyük olan ve iki küçük doğal sayının çarpımı olmayan).    //Basit sayılar olan basit sayılar (bir basit sayı, doğal bir sayıdır)    //Bir dizi olarak onaltısal bir sayı ve onaltısal sayı sayısını sayıyor     //Sana alıcı bir fonksiyon yazma görevi verildi .    // >>> HexKey((""AB""))
    // (1L)
    // >>> HexKey((""1077E""))
    // (2L)
    // >>> HexKey((""ABED1A33""))
    // (4L)
    // >>> HexKey((""123456789ABCDEF0""))
    // (6L)
    // >>> HexKey((""2020""))
    // (2L)
    public static long HexKey(string num) {
","public static long HexKey(string num) {
    // Define a set of prime hexadecimal digits
    HashSet<char> primeHexDigits = new HashSet<char> { '2', '3', '5', '7', 'B', 'D' };

    long primeCount = 0;

    // Iterate through each character in the input string
    foreach (char c in num) {
        // If the character is in the set of prime hex digits, increase the count
        if (primeHexDigits.Contains(c)) {
            primeCount++;
        }
    }

    return primeCount;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(HexKey((""AB"")) == (1L));
    Debug.Assert(HexKey((""1077E"")) == (2L));
    Debug.Assert(HexKey((""ABED1A33"")) == (4L));
    Debug.Assert(HexKey((""2020"")) == (2L));
    Debug.Assert(HexKey((""123456789ABCDEF0"")) == (6L));
    Debug.Assert(HexKey((""112233445566778899AABBCCDDEEFF00"")) == (12L));
    }

}
"
HumanEval_79,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Ekstra karakterler formatta yardımcı olmak için.    //Bu sayede dizinin başında ve sonunda fazladan bir çift karakter 'db' olur.    //Bu karakterler '0' veya '1' olacak.    //fonksiyon, her karakterin bir ikili     //Size ondalık formda bir sayı verilecek ve görevin onu 'ye dönüştürmek.    // >>> DecimalToBinary((15L))
    // (""db1111db"")
    // >>> DecimalToBinary((32L))
    // (""db100000db"")
    public static string DecimalToBinary(long decimalNum) {
","public static string DecimalToBinary(long decimalNum) {
    string binary = Convert.ToString(decimalNum, 2);
    return ""db"" + binary + ""db"";
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DecimalToBinary((0L)).Equals((""db0db"")));
    Debug.Assert(DecimalToBinary((32L)).Equals((""db100000db"")));
    Debug.Assert(DecimalToBinary((103L)).Equals((""db1100111db"")));
    Debug.Assert(DecimalToBinary((15L)).Equals((""db1111db"")));
    }

}
"
HumanEval_80,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Bir dize hapcs ' tir , eğer uzunluğu en az 3 ve her 3 ardışık harf farklı ise .    //Görevin, dizinin hapcs olup olmadığını kontrol etmek.    //Size bir dize veriliyor.    // >>> IsHappy((""a""))
    // (false)
    // >>> IsHappy((""aa""))
    // (false)
    // >>> IsHappy((""abcd""))
    // (true)
    // >>> IsHappy((""aabb""))
    // (false)
    // >>> IsHappy((""adb""))
    // (true)
    // >>> IsHappy((""xyy""))
    // (false)
    public static bool IsHappy(string s) {
","if (s.Length < 3) {
        return false;
    }

    for (int i = 0; i <= s.Length - 3; i++) {
        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsHappy((""a"")) == (false));
    Debug.Assert(IsHappy((""aa"")) == (false));
    Debug.Assert(IsHappy((""abcd"")) == (true));
    Debug.Assert(IsHappy((""aabb"")) == (false));
    Debug.Assert(IsHappy((""adb"")) == (true));
    Debug.Assert(IsHappy((""xyy"")) == (false));
    Debug.Assert(IsHappy((""iopaxpoi"")) == (true));
    Debug.Assert(IsHappy((""iopaxioi"")) == (false));
    }

}
"
HumanEval_81,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //0.0 E     //> 0.0 D-     //> 0,7 D     //> 1,0 D+     //> 1.3 C-     //> 1.7 C     //> 2.0 C+     //> 2.3 B-     //> 2.7 B     //> 3.0 B+     //> 3.3 A-     //> 3.7 A     //4.0 A+     //Ortalama.    //Aşağıdaki tabloyu kullanarak harf sınıflarının bir listesini çıkarabilen bir işlev:     //Sana bazı öğrencilerin notlarını verdi ve sen de yazman gerekiyor .    //Tek sorun, not vermek için kullandığı kodu kaybetmiş olması.    //Öğretmen kendi not algoritmasını yapıyor.    //Bu dönem son haftası ve öğretmen notları vermek zorunda .    // >>> GradeEquation((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f})))
    // (new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))
    public static List<string> NumericalLetterGrade(List<float> grades) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> NumericalLetterGrade(List<float> grades)
    {
        List<string> letterGrades = new List<string>();

        foreach (var gpa in grades)
        {
            if (gpa == 4.0f)
                letterGrades.Add(""A+"");
            else if (gpa > 3.7f)
                letterGrades.Add(""A"");
            else if (gpa > 3.3f)
                letterGrades.Add(""A-"");
            else if (gpa > 3.0f)
                letterGrades.Add(""B+"");
            else if (gpa > 2.7f)
                letterGrades.Add(""B"");
            else if (gpa > 2.3f)
                letterGrades.Add(""B-"");
            else if (gpa > 2.0f)
                letterGrades.Add(""C+"");
            else if (gpa > 1.7f)
                letterGrades.Add(""C"");
            else if (gpa > 1.3f)
                letterGrades.Add(""C-"");
            else if (gpa > 1.0f)
                letterGrades.Add(""D+"");
            else if (gpa > 0.7f)
                letterGrades.Add(""D"");
            else if (gpa > 0.0f)
                letterGrades.Add(""D-"");
            else
                letterGrades.Add(""E"");
        }

        return letterGrades;
    }

    static void Main(string[] args)
    {
        List<float> gpas = new List<float> { 4.0f, 3.0f, 1.7f, 2.0f, 3.5f };
        List<string> grades = NumericalLetterGrade(gpas);
        Console.WriteLine(string.Join("", "", grades));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)4.0f, (float)3L, (float)1.7f, (float)2L, (float)3.5f}))).Equals((new List<string>(new string[]{(string)""A+"", (string)""B"", (string)""C-"", (string)""C"", (string)""A-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.2f}))).Equals((new List<string>(new string[]{(string)""D+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.5f}))).Equals((new List<string>(new string[]{(string)""D-""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f}))).Equals((new List<string>(new string[]{(string)""E""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)1.0f, (float)0.3f, (float)1.5f, (float)2.8f, (float)3.3f}))).Equals((new List<string>(new string[]{(string)""D"", (string)""D-"", (string)""C-"", (string)""B"", (string)""B+""}))));
    Debug.Assert(NumericalLetterGrade((new List<float>(new float[]{(float)0.0f, (float)0.7f}))).Equals((new List<string>(new string[]{(string)""E"", (string)""D-""}))));
    }

}
"
HumanEval_82,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //uzunluk asal sayıdır ya da yanlış başka     //Bir dizeyi alıp , eğer dize doğru ise doğru döndüren bir fonksiyon yazın .    // >>> PrimeLength((""Hello""))
    // (true)
    // >>> PrimeLength((""abcdcba""))
    // (true)
    // >>> PrimeLength((""kittens""))
    // (true)
    // >>> PrimeLength((""orange""))
    // (false)
    public static bool PrimeLength(string str) {
","using System;

class Problem {
    public static bool PrimeLength(string str) {
        int length = str.Length;
        if (length < 2) return false;
        
        for (int i = 2; i <= Math.Sqrt(length); i++) {
            if (length % i == 0) return false;
        }
        
        return true;
    }
    
    // Example usage
    public static void Main() {
        Console.WriteLine(PrimeLength(""Hello""));    // true
        Console.WriteLine(PrimeLength(""abcdcba""));  // true
        Console.WriteLine(PrimeLength(""kittens""));  // true
        Console.WriteLine(PrimeLength(""orange""));   // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(PrimeLength((""Hello"")) == (true));
    Debug.Assert(PrimeLength((""abcdcba"")) == (true));
    Debug.Assert(PrimeLength((""kittens"")) == (true));
    Debug.Assert(PrimeLength((""orange"")) == (false));
    Debug.Assert(PrimeLength((""wow"")) == (true));
    Debug.Assert(PrimeLength((""world"")) == (true));
    Debug.Assert(PrimeLength((""MadaM"")) == (true));
    Debug.Assert(PrimeLength((""Wow"")) == (true));
    Debug.Assert(PrimeLength(("""")) == (false));
    Debug.Assert(PrimeLength((""HI"")) == (true));
    Debug.Assert(PrimeLength((""go"")) == (true));
    Debug.Assert(PrimeLength((""gogo"")) == (false));
    Debug.Assert(PrimeLength((""aaaaaaaaaaaaaaa"")) == (false));
    Debug.Assert(PrimeLength((""Madam"")) == (true));
    Debug.Assert(PrimeLength((""M"")) == (false));
    Debug.Assert(PrimeLength((""0"")) == (false));
    }

}
"
HumanEval_83,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //1 ile başlayan veya biten pozitif tam sayılar.    //Pozitif bir tamsayı n verilmişse, n-sayıların sayısını döndürün.    public static long StartsOneEnds(long n) {
","if (n == 1) return 1;
        return (long)Math.Pow(10, n - 1) + 9 * (long)Math.Pow(10, n - 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StartsOneEnds((1L)) == (1L));
    Debug.Assert(StartsOneEnds((2L)) == (18L));
    Debug.Assert(StartsOneEnds((3L)) == (180L));
    Debug.Assert(StartsOneEnds((4L)) == (1800L));
    Debug.Assert(StartsOneEnds((5L)) == (18000L));
    }

}
"
HumanEval_84,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek     //Pozitif bir tamsayı N verilmişse, ikili sayılardaki rakamların toplam toplamını gönderir.     // >>> Solve((1000L))
    // (""1"")
    // >>> Solve((150L))
    // (""110"")
    // >>> Solve((147L))
    // (""1100"")
    // Variables:
    // @N integer
    // Constraints: 0 ≤ N ≤ 10000.
    // Output:
    // a string of binary number
    public static string Solve(long N) {
","public static string Solve(long N) {
        int sumOfDigits = 0;
        while (N > 0) {
            sumOfDigits += (int)(N % 10);
            N /= 10;
        }
        return Convert.ToString(sumOfDigits, 2);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((1000L)).Equals((""1"")));
    Debug.Assert(Solve((150L)).Equals((""110"")));
    Debug.Assert(Solve((147L)).Equals((""1100"")));
    Debug.Assert(Solve((333L)).Equals((""1001"")));
    Debug.Assert(Solve((963L)).Equals((""10010"")));
    }

}
"
HumanEval_85,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Boş olmayan bir tamsayı listesi verilirse lst. Çift elemanları tek indekslerde ekle..     // >>> Add((new List<long>(new long[]{(long)4L, (long)2L, (long)6L, (long)7L})))
    // (2L)
    public static long Add(List<long> lst) {
","long sum = 0;
    for (int i = 1; i < lst.Count; i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)88L}))) == (88L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)5L, (long)6L, (long)7L, (long)2L, (long)122L}))) == (122L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)0L, (long)6L, (long)7L}))) == (0L));
    Debug.Assert(Add((new List<long>(new long[]{(long)4L, (long)4L, (long)6L, (long)8L}))) == (12L));
    }

}
"
HumanEval_86,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Not: Kelimelerin ve cümledeki boşlukların sırasını korumalısınız.    //Ascii değerine göre yükselen sıra.    //Yeni bir kelime ile değiştirilmiştir .    //String'in düzenlenmiş versiyonu, tüm kelimelerin (uzayla ayrılmış)     //Bir dizeyi alıp onun düzenli bir versiyonunu döndüren bir fonksiyon yazın.    // >>> AntiShuffle((""Hi""))
    // (""Hi"")
    // >>> AntiShuffle((""hello""))
    // (""ehllo"")
    // >>> AntiShuffle((""Hello World!!!""))
    // (""Hello !!!Wdlor"")
    public static string AntiShuffle(string s) {
","using System;
using System.Linq;

class Problem
{
    public static string AntiShuffle(string s)
    {
        return string.Join("" "", s.Split(' ')
            .Select(word => string.Concat(word.OrderBy(c => c))));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AntiShuffle((""Hi"")).Equals((""Hi"")));
    Debug.Assert(AntiShuffle((""hello"")).Equals((""ehllo"")));
    Debug.Assert(AntiShuffle((""number"")).Equals((""bemnru"")));
    Debug.Assert(AntiShuffle((""abcd"")).Equals((""abcd"")));
    Debug.Assert(AntiShuffle((""Hello World!!!"")).Equals((""Hello !!!Wdlor"")));
    Debug.Assert(AntiShuffle(("""")).Equals(("""")));
    Debug.Assert(AntiShuffle((""Hi. My name is Mister Robot. How are you?"")).Equals(("".Hi My aemn is Meirst .Rboot How aer ?ouy"")));
    }

}
"
HumanEval_87,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Ayrıca, satır koordinatlarını sütunlar sırasıyla aşağı doğru sıralayın.    //Koordinatları ilk önce sıralar sırasıyla sıralayın.    //Her bir tuple bir koordinat - (sıra, sütun) 0 ile başlayan.    //ve bir dizi eşleşme listesi döndürür, [(x1, y1), (x2, y2) ...] böyle ki     //Lst ve tamsayı x verildiğinde, listede tamsayı x bulun,     //Her satır farklı sayıda sütun içerebilir.    //Matrisin aksine matris gibi olan,     //Sana 2 boyutlu bir veri veriliyor, örülmüş bir liste olarak,     // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))
    // >>> GetRow((new List<List<long>>()), (1L))
    // (new List<Tuple<long, long>>())
    // >>> GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L))
    // (new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<Tuple<long, long>> GetRow(List<List<long>> lst, long x) {
        var result = new List<Tuple<long, long>>();
        
        for (long row = 0; row < lst.Count; row++) {
            List<long> currentRow = lst[(int)row];
            var foundIndices = new List<long>();
            
            for (long col = 0; col < currentRow.Count; col++) {
                if (currentRow[(int)col] == x) {
                    foundIndices.Add(col);
                }
            }
            
            foundIndices.Sort((a, b) => b.CompareTo(a)); // Sort columns in descending order
            
            foreach (var col in foundIndices) {
                result.Add(Tuple.Create(row, col));
            }
        }
        
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 4L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 5L), (Tuple<long, long>)Tuple.Create(2L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})})), (2L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 1L), (Tuple<long, long>)Tuple.Create(1L, 1L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(3L, 1L), (Tuple<long, long>)Tuple.Create(4L, 1L), (Tuple<long, long>)Tuple.Create(5L, 1L)}))));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)3L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)1L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})})), (1L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(0L, 0L), (Tuple<long, long>)Tuple.Create(1L, 0L), (Tuple<long, long>)Tuple.Create(2L, 1L), (Tuple<long, long>)Tuple.Create(2L, 0L), (Tuple<long, long>)Tuple.Create(3L, 2L), (Tuple<long, long>)Tuple.Create(3L, 0L), (Tuple<long, long>)Tuple.Create(4L, 3L), (Tuple<long, long>)Tuple.Create(4L, 0L), (Tuple<long, long>)Tuple.Create(5L, 4L), (Tuple<long, long>)Tuple.Create(5L, 0L), (Tuple<long, long>)Tuple.Create(6L, 5L), (Tuple<long, long>)Tuple.Create(6L, 0L)}))));
    Debug.Assert(GetRow((new List<List<long>>()), (1L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L})})), (2L)).Equals((new List<Tuple<long, long>>())));
    Debug.Assert(GetRow((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(), (List<long>)new List<long>(new long[]{(long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})})), (3L)).Equals((new List<Tuple<long, long>>(new Tuple<long, long>[]{(Tuple<long, long>)Tuple.Create(2L, 2L)}))));
    }

}
"
HumanEval_88,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //* Verilen listeyi değiştirmeyin.    //Not:    //veya toplamı ((ilk indeks değeri, son indeks değeri) çift ise, düşüş sırasıyla sıralayın.     //Eğer toplam ((ilk indeks değeri, son indeks değeri) tekse,     //Negatif olmayan tam sayılar listesi verilmişse, sıralama sonrası verilen listeden bir cocs döndürün,     // >>> SortArray((new List<long>()))
    // (new List<long>())
    // >>> SortArray((new List<long>(new long[]{(long)5L})))
    // (new List<long>(new long[]{(long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L})))
    // (new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))
    public static List<long> SortArray(List<long> array) {
","public static List<long> SortArray(List<long> array) {
        if (array == null || array.Count <= 1) {
            return new List<long>(array);
        }
        
        long firstValue = array[0];
        long lastValue = array[array.Count - 1];
        long sum = firstValue + lastValue;

        List<long> sortedArray = new List<long>(array);

        if (sum % 2 != 0) { // sum is odd, sort ascending
            sortedArray.Sort();
        } else { // sum is even, sort descending
            sortedArray.Sort();
            sortedArray.Reverse();
        }

        return sortedArray;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)5L}))).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)3L, (long)0L, (long)1L, (long)5L, (long)6L}))).Equals((new List<long>(new long[]{(long)6L, (long)5L, (long)4L, (long)3L, (long)2L, (long)1L, (long)0L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)15L, (long)42L, (long)87L, (long)32L, (long)11L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)11L, (long)15L, (long)32L, (long)42L, (long)87L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)21L, (long)14L, (long)23L, (long)11L}))).Equals((new List<long>(new long[]{(long)23L, (long)21L, (long)14L, (long)11L}))));
    }

}
"
HumanEval_89,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //İki kere iki yere kaydır.    //Alfabe öyle bir şekilde döndürülmeli ki harfler     //alfabenin döndürülmesiyle şifreli bir dize döndürür.    //Bir dizeyi argüman olarak kullanan bir işlev şifreleme oluşturun ve     // >>> Encrypt((""hi""))
    // (""lm"")
    // >>> Encrypt((""asdfghjkl""))
    // (""ewhjklnop"")
    // >>> Encrypt((""gf""))
    // (""kj"")
    // >>> Encrypt((""et""))
    // (""ix"")
    public static string Encrypt(string s) {
","const int shiftAmount = 4; // 2 multiplied by 2 equals 4.

    StringBuilder encrypted = new StringBuilder();

    foreach (char c in s) {
        if (char.IsLetter(c)) {
            char start = char.IsUpper(c) ? 'A' : 'a';
            char encryptedChar = (char)(start + (c - start + shiftAmount) % 26);
            encrypted.Append(encryptedChar);
        } else {
            encrypted.Append(c); // Non-letter characters are not encrypted.
        }
    }

    return encrypted.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encrypt((""hi"")).Equals((""lm"")));
    Debug.Assert(Encrypt((""asdfghjkl"")).Equals((""ewhjklnop"")));
    Debug.Assert(Encrypt((""gf"")).Equals((""kj"")));
    Debug.Assert(Encrypt((""et"")).Equals((""ix"")));
    Debug.Assert(Encrypt((""faewfawefaewg"")).Equals((""jeiajeaijeiak"")));
    Debug.Assert(Encrypt((""hellomyfriend"")).Equals((""lippsqcjvmirh"")));
    Debug.Assert(Encrypt((""dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh"")).Equals((""hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"")));
    Debug.Assert(Encrypt((""a"")).Equals((""e"")));
    }

}
"
HumanEval_90,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Böyle bir öğe yoksa null döndürür.     //Listedeki en küçük ikinci öğeyi döndüren next_smallest () işlevi yazın.     //Sana tam sayılar listesi veriliyor.    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // 2L
    // >>> NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L})))
    // 2L
    // >>> NextSmallest((new List<long>()))
    // null
    // >>> NextSmallest((new List<long>(new long[]{(long)1L, (long)1L})))
    // null
    public static Nullable<long> NextSmallest(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Nullable<long> NextSmallest(List<long> lst) {
        if (lst == null || lst.Count < 2) {
            return null;
        }

        HashSet<long> uniqueElements = new HashSet<long>(lst);
        if (uniqueElements.Count < 2) {
            return null;
        }

        List<long> sortedUniqueElements = uniqueElements.ToList();
        sortedUniqueElements.Sort();

        return sortedUniqueElements[1];
    }

    static void Main(string[] args) {
        Console.WriteLine(NextSmallest(new List<long> {1, 2, 3, 4, 5})); // 2
        Console.WriteLine(NextSmallest(new List<long> {5, 1, 4, 3, 2})); // 2
        Console.WriteLine(NextSmallest(new List<long>())); // null
        Console.WriteLine(NextSmallest(new List<long> {1, 1})); // null
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L}))).Equals(2L));
    Debug.Assert(NextSmallest((new List<long>())).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)0L}))).Equals(1L));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));
    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));
    }

}
"
HumanEval_91,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Cümleler '.', '?' veya '!' ile sınırlandırılır.     //Sıkıntı, ""ben"" kelimesiyle başlayan bir cümledir.    //Size bir dizi kelime verilecek ve sizin görevinizin sayısı saymak olacak.    // >>> IsBored((""Hello world""))
    // (0L)
    // >>> IsBored((""The sky is blue. The sun is shining. I love this weather""))
    // (1L)
    public static long IsBored(string S) {
","using System;

class Problem {
    public static long IsBored(string S) {
        // Split the input string into sentences based on delimiters '.', '?', '!'
        char[] delimiters = new char[] { '.', '?', '!' };
        string[] sentences = S.Split(delimiters, StringSplitOptions.RemoveEmptyEntries);

        // Count sentences that start with 'I' after trimming leading whitespaces
        long boredomCount = 0;
        foreach (string sentence in sentences) {
            if (sentence.TrimStart().StartsWith(""I"")) {
                boredomCount++;
            }
        }

        return boredomCount;
    }

    static void Main(string[] args) {
        // Example usage:
        Console.WriteLine(IsBored(""Hello world"")); // Output: 0
        Console.WriteLine(IsBored(""The sky is blue. The sun is shining. I love this weather"")); // Output: 1
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsBored((""Hello world"")) == (0L));
    Debug.Assert(IsBored((""Is the sky blue?"")) == (0L));
    Debug.Assert(IsBored((""I love It !"")) == (1L));
    Debug.Assert(IsBored((""bIt"")) == (0L));
    Debug.Assert(IsBored((""I feel good today. I will be productive. will kill It"")) == (2L));
    Debug.Assert(IsBored((""You and I are going for a walk"")) == (0L));
    }

}
"
HumanEval_92,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //Diğer durumlarda false döndürür.    //Eğer sayılar diğer ikisinin toplamına eşitse ve tüm sayılar tamsayılarsa doğru değerini gönderir.    //3 sayı alan bir fonksiyon oluşturun.    // >>> AnyInt((float)5L, (float)2L, (float)7L)
    // (true)
    // >>> AnyInt((float)3L, (float)2L, (float)2L)
    // (false)
    // >>> AnyInt((float)3L, (float)-2L, (float)1L)
    // (true)
    // >>> AnyInt((3.6f), (-2.2f), (float)2L)
    // (false)
    public static bool AnyInt(float x, float y, float z) {
","public static bool AnyInt(float x, float y, float z) {
        if (x == Math.Round(x) && y == Math.Round(y) && z == Math.Round(z)) {
            if (x == y + z || y == x + z || z == x + y) {
                return true;
            }
        }
        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AnyInt((float)2L, (float)3L, (float)1L) == (true));
    Debug.Assert(AnyInt((2.5f), (float)2L, (float)3L) == (false));
    Debug.Assert(AnyInt((1.5f), (float)5L, (3.5f)) == (false));
    Debug.Assert(AnyInt((float)2L, (float)6L, (float)2L) == (false));
    Debug.Assert(AnyInt((float)4L, (float)2L, (float)2L) == (true));
    Debug.Assert(AnyInt((2.2f), (2.2f), (2.2f)) == (false));
    Debug.Assert(AnyInt((float)-4L, (float)6L, (float)2L) == (true));
    Debug.Assert(AnyInt((float)2L, (float)1L, (float)1L) == (true));
    Debug.Assert(AnyInt((float)3L, (float)4L, (float)7L) == (true));
    Debug.Assert(AnyInt((3.0f), (float)4L, (float)7L) == (false));
    }

}
"
HumanEval_93,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Sadece harfler varsayalım.    //İngiliz alfabesindeki bir ses.    //Mesajın önündeki iki mektupla birlikte .    //Bu şekilde tüm harflerin büyük harflerini değiştirir, 'deki tüm sesleri değiştirir.    //Bir mesajı alan ve bu şekilde kodlayan bir fonksiyon yazın.    // >>> Encode((""test""))
    // (""TGST"")
    // >>> Encode((""This is a message""))
    // (""tHKS KS C MGSSCGG"")
    public static string Encode(string message) {
","public static string Encode(string message) {
    // Define vowels and their replacements
    Dictionary<char, char> vowelReplacement = new Dictionary<char, char>
    {
        { 'a', 'c' },
        { 'e', 'g' },
        { 'i', 'k' },
        { 'o', 'q' },
        { 'u', 'w' },
        { 'A', 'C' },
        { 'E', 'G' },
        { 'I', 'K' },
        { 'O', 'Q' },
        { 'U', 'W' }
    };

    StringBuilder encodedMessage = new StringBuilder();

    foreach (char c in message) {
        if (char.IsLetter(c)) {
            // Swap case
            char swappedCaseChar = char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c);

            // Replace vowels according to the defined map
            if (vowelReplacement.ContainsKey(swappedCaseChar)) {
                encodedMessage.Append(vowelReplacement[swappedCaseChar]);
            } else {
                encodedMessage.Append(swappedCaseChar);
            }
        } else {
            // Non-letter characters should be appended as-is (if necessary)
            encodedMessage.Append(c);
        }
    }

    return encodedMessage.ToString();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Encode((""TEST"")).Equals((""tgst"")));
    Debug.Assert(Encode((""Mudasir"")).Equals((""mWDCSKR"")));
    Debug.Assert(Encode((""YES"")).Equals((""ygs"")));
    Debug.Assert(Encode((""This is a message"")).Equals((""tHKS KS C MGSSCGG"")));
    Debug.Assert(Encode((""I DoNt KnOw WhAt tO WrItE"")).Equals((""k dQnT kNqW wHcT Tq wRkTg"")));
    }

}
"
HumanEval_94,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //En büyük asal değeri bulup, rakamlarının toplamını göndermeniz gerekiyor.    //Sana tam sayılar listesi veriliyor.    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L})))
    // (10L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L})))
    // (25L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L})))
    // (13L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L})))
    // (11L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L})))
    // (3L)
    // >>> Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L})))
    // (7L)
    public static long Skjkasdkd(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static long Skjkasdkd(List<long> lst) {
        long largestPrime = -1;

        foreach (var num in lst) {
            if (IsPrime(num) && num > largestPrime) {
                largestPrime = num;
            }
        }

        if (largestPrime == -1) return 0;

        return SumOfDigits(largestPrime);
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;

        if (number % 2 == 0 || number % 3 == 0) return false;

        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }

        return true;
    }

    private static long SumOfDigits(long number) {
        long sum = 0;
        while (number != 0) {
            sum += number % 10;
            number /= 10;
        }
        return sum;
    }
}

// Example of usage:
// var result = Problem.Skjkasdkd(new List<long> {0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3});
// Console.WriteLine(result); // Output will be 10","    }
    public static void Main(string[] args) {
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)3L, (long)2L, (long)1L, (long)3L, (long)5L, (long)7L, (long)4L, (long)5L, (long)5L, (long)5L, (long)2L, (long)181L, (long)32L, (long)4L, (long)32L, (long)3L, (long)2L, (long)32L, (long)324L, (long)4L, (long)3L}))) == (10L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)0L, (long)1L, (long)8L, (long)2L, (long)4597L, (long)2L, (long)1L, (long)3L, (long)40L, (long)1L, (long)2L, (long)1L, (long)2L, (long)4L, (long)2L, (long)5L, (long)1L}))) == (25L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)32L, (long)5107L, (long)34L, (long)83278L, (long)109L, (long)163L, (long)23L, (long)2323L, (long)32L, (long)30L, (long)1L, (long)9L, (long)3L}))) == (13L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)724L, (long)32L, (long)71L, (long)99L, (long)32L, (long)6L, (long)0L, (long)5L, (long)91L, (long)83L, (long)0L, (long)5L, (long)6L}))) == (11L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)81L, (long)12L, (long)3L, (long)1L, (long)21L}))) == (3L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)0L, (long)8L, (long)1L, (long)2L, (long)1L, (long)7L}))) == (7L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)8191L, (long)123456L, (long)127L, (long)7L}))) == (19L));
    Debug.Assert(Skjkasdkd((new List<long>(new long[]{(long)127L, (long)97L, (long)8192L}))) == (10L));
    }

}
"
HumanEval_95,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Verilen sözlük boş ise fonksiyon false döndürmelidir.     //case veya tüm anahtarlar büyük harfli dizilerdir, aksi takdirde false döndürür.     //Sözlük verilmişse, eğer tüm tuşlar lower 'da dizilmişse doğru döndürür.    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""b"", ""banana""}}))
    // (true)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {""A"", ""banana""}, {""B"", ""banana""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""a"", ""apple""}, {8L, ""banana""}, {""a"", ""apple""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}}))
    // (false)
    // >>> CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}}))
    // (true)
    public static bool CheckDictCase(Dictionary<string,string> dict) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static bool CheckDictCase(Dictionary<string, string> dict)
    {
        if (dict.Count == 0)
            return false;

        bool allLower = true;
        bool allUpper = true;

        foreach (var key in dict.Keys)
        {
            if (key != key.ToLower())
                allLower = false;
            if (key != key.ToUpper())
                allUpper = false;
        }

        return allLower || allUpper;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""b"", ""banana""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""A"", ""banana""}, {""B"", ""banana""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""p"", ""pineapple""}, {""5"", ""banana""}, {""a"", ""apple""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""Name"", ""John""}, {""Age"", ""36""}, {""City"", ""Houston""}})) == (false));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""STATE"", ""NC""}, {""ZIP"", ""12345""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>(){{""fruit"", ""Orange""}, {""taste"", ""Sweet""}})) == (true));
    Debug.Assert(CheckDictCase((new Dictionary<string,string>())) == (false));
    }

}
"
HumanEval_96,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Bu sayılar n'den küçük olan asal sayılardır.    //Negatif olmayan bir tamsayı alarak ilk n sayısının listesini döndüren bir fonksiyon uygulayın .    // >>> CountUpTo((5L))
    // (new List<long>(new long[]{(long)2L, (long)3L}))
    // >>> CountUpTo((11L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))
    // >>> CountUpTo((0L))
    // (new List<long>())
    // >>> CountUpTo((20L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))
    // >>> CountUpTo((1L))
    // (new List<long>())
    // >>> CountUpTo((18L))
    // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))
    public static List<long> CountUpTo(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> CountUpTo(long n) {
        List<long> primes = new List<long>();
        if (n <= 2) return primes;

        // Check for prime numbers from 2 up to n-1
        for (long i = 2; i < n; i++) {
            if (IsPrime(i)) {
                primes.Add(i);
            }
        }

        return primes;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number == 2) return true;

        long boundary = (long)Math.Sqrt(number);

        for (long i = 2; i <= boundary; i++) {
            if (number % i == 0) return false;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpTo((5L)).Equals((new List<long>(new long[]{(long)2L, (long)3L}))));
    Debug.Assert(CountUpTo((6L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((7L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))));
    Debug.Assert(CountUpTo((10L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L}))));
    Debug.Assert(CountUpTo((0L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((22L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L}))));
    Debug.Assert(CountUpTo((1L)).Equals((new List<long>())));
    Debug.Assert(CountUpTo((18L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(CountUpTo((47L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L}))));
    Debug.Assert(CountUpTo((101L)).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L, (long)19L, (long)23L, (long)29L, (long)31L, (long)37L, (long)41L, (long)43L, (long)47L, (long)53L, (long)59L, (long)61L, (long)67L, (long)71L, (long)73L, (long)79L, (long)83L, (long)89L, (long)97L}))));
    }

}
"
HumanEval_97,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Girişin her zaman geçerli olduğunu varsayalım.    //Birim rakamlarının çarpımı.    //İki tamsayı alan ve  döndüren işlevi tamamlayın .    // >>> Multiply((148L), (412L))
    // (16L)
    // >>> Multiply((19L), (28L))
    // (72L)
    // >>> Multiply((2020L), (1851L))
    // (0L)
    // >>> Multiply((14L), (-15L))
    // (20L)
    public static long Multiply(long a, long b) {
","public static long Multiply(long a, long b) {
    int unitDigitA = (int)(Math.Abs(a) % 10);
    int unitDigitB = (int)(Math.Abs(b) % 10);
    return (long)(unitDigitA * unitDigitB);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Multiply((148L), (412L)) == (16L));
    Debug.Assert(Multiply((19L), (28L)) == (72L));
    Debug.Assert(Multiply((2020L), (1851L)) == (0L));
    Debug.Assert(Multiply((14L), (-15L)) == (20L));
    Debug.Assert(Multiply((76L), (67L)) == (42L));
    Debug.Assert(Multiply((17L), (27L)) == (49L));
    Debug.Assert(Multiply((0L), (1L)) == (0L));
    Debug.Assert(Multiply((0L), (0L)) == (0L));
    }

}
"
HumanEval_98,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Bir dize s verildiğinde, çift endekslerde büyük harfli seslerin sayısını sayın.    // >>> CountUpper((""aBCdEf""))
    // (1L)
    // >>> CountUpper((""abcdefg""))
    // (0L)
    // >>> CountUpper((""dBBE""))
    // (0L)
    public static long CountUpper(string s) {
","using System;

class Problem {
    public static long CountUpper(string s) {
        long count = 0;
        for (int i = 0; i < s.Length; i += 2) {
            if (""AEIOU"".Contains(s[i])) {
                count++;
            }
        }
        return count;
    }

    public static void Main(string[] args) {
        Console.WriteLine(CountUpper(""aBCdEf"")); // Output: 1
        Console.WriteLine(CountUpper(""abcdefg"")); // Output: 0
        Console.WriteLine(CountUpper(""dBBE"")); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountUpper((""aBCdEf"")) == (1L));
    Debug.Assert(CountUpper((""abcdefg"")) == (0L));
    Debug.Assert(CountUpper((""dBBE"")) == (0L));
    Debug.Assert(CountUpper((""B"")) == (0L));
    Debug.Assert(CountUpper((""U"")) == (1L));
    Debug.Assert(CountUpper(("""")) == (0L));
    Debug.Assert(CountUpper((""EEEE"")) == (2L));
    }

}
"
HumanEval_99,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //İki tam sayıdan sıfırdan uzaklaştırırız.    //ve ona en yakın tamsayıyı gönderir.    //Bir sayıyı temsil eden bir değer (dizi) alan bir fonksiyon oluşturun .    // >>> ClosestInteger((""10""))
    // (10L)
    // >>> ClosestInteger((""15.3""))
    // (15L)
    // Note:
    // Rounding away from zero means that if the given number is equidistant
    // from two integers, the one you should return is the one that is the
    // farthest from zero. For example closest_integer(""14.5"") should
    // return 15 and closest_integer(""-14.5"") should return -15.
    public static long ClosestInteger(string value) {
","public static long ClosestInteger(string value) {
    double number = double.Parse(value);
    return (long)Math.Round(number, MidpointRounding.AwayFromZero);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ClosestInteger((""10"")) == (10L));
    Debug.Assert(ClosestInteger((""14.5"")) == (15L));
    Debug.Assert(ClosestInteger((""-15.5"")) == (-16L));
    Debug.Assert(ClosestInteger((""15.3"")) == (15L));
    Debug.Assert(ClosestInteger((""0"")) == (0L));
    }

}
"
HumanEval_100,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //i, seviye (i+1) 'deki taşların sayısını temsil eder.    //Bir listede, indeks  elementinde her seviyedeki taşların sayısını döndürür.    //- n çiftse bir sonraki çift sayı.    //- n tek sayıysa bir sonraki tek sayıdır.    //Bir sonraki seviyedeki taşların sayısı:    //İlk katın n taşı var.    //Pozitif bir tamsayı n varken, n seviyede taş yığını yapmanız gerekiyor.    // >>> MakeAPile((3L))
    // (new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))
    public static List<long> MakeAPile(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> MakeAPile(long n) {
        List<long> pile = new List<long>();
        long currentStones = n;
        
        for (long i = 0; i < n; i++) {
            pile.Add(currentStones);
            currentStones += (n % 2 == 0) ? 2 : 2;
        }

        return pile;
    }
    
    static void Main(string[] args) {
        List<long> result = MakeAPile(3L);
        Console.WriteLine(string.Join("", "", result));  // Output: 3, 5, 7
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MakeAPile((3L)).Equals((new List<long>(new long[]{(long)3L, (long)5L, (long)7L}))));
    Debug.Assert(MakeAPile((4L)).Equals((new List<long>(new long[]{(long)4L, (long)6L, (long)8L, (long)10L}))));
    Debug.Assert(MakeAPile((5L)).Equals((new List<long>(new long[]{(long)5L, (long)7L, (long)9L, (long)11L, (long)13L}))));
    Debug.Assert(MakeAPile((6L)).Equals((new List<long>(new long[]{(long)6L, (long)8L, (long)10L, (long)12L, (long)14L, (long)16L}))));
    Debug.Assert(MakeAPile((8L)).Equals((new List<long>(new long[]{(long)8L, (long)10L, (long)12L, (long)14L, (long)16L, (long)18L, (long)20L, (long)22L}))));
    }

}
"
HumanEval_101,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Bu sayfalardaki sözcükleri ayırıp, sözcüklerin bir listesini gönderir.    //Size virgül veya boşluklarla ayrılmış bir dizi kelime verilecek.    // >>> WordsString((""Hi, my name is John""))
    // (new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))
    // >>> WordsString((""One, two, three, four, five, six""))
    // (new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))
    public static List<string> WordsString(string s) {
","public static List<string> WordsString(string s) {
    char[] separators = new char[] { ' ', ',' };
    var words = s.Split(separators, StringSplitOptions.RemoveEmptyEntries);
    return new List<string>(words);
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsString((""Hi, my name is John"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name"", (string)""is"", (string)""John""}))));
    Debug.Assert(WordsString((""One, two, three, four, five, six"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString((""Hi, my name"")).Equals((new List<string>(new string[]{(string)""Hi"", (string)""my"", (string)""name""}))));
    Debug.Assert(WordsString((""One,, two, three, four, five, six,"")).Equals((new List<string>(new string[]{(string)""One"", (string)""two"", (string)""three"", (string)""four"", (string)""five"", (string)""six""}))));
    Debug.Assert(WordsString(("""")).Equals((new List<string>())));
    Debug.Assert(WordsString((""ahmed     , gamal"")).Equals((new List<string>(new string[]{(string)""ahmed"", (string)""gamal""}))));
    }

}
"
HumanEval_102,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Eğer böyle bir sayı yoksa, fonksiyon -1 döndürür.    //Eğer , [x, y] dahil aralığındaki en büyük çift tam sayıdır.    //Bu fonksiyon iki pozitif sayı x ve y alır ve  değerini verir .    // >>> ChooseNum((12L), (15L))
    // (14L)
    // >>> ChooseNum((13L), (12L))
    // (-1L)
    public static long ChooseNum(long x, long y) {
","if (x > y) {
            return -1;
        }
        
        // Ensure x is the bigger one for simplicity
        if (x > y) {
            long temp = x;
            x = y;
            y = temp;
        }
        
        // Start searching from y down to x
        for (long i = y; i >= x; i--) {
            if (i % 2 == 0) {
                return i;
            }
        }
        
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ChooseNum((12L), (15L)) == (14L));
    Debug.Assert(ChooseNum((13L), (12L)) == (-1L));
    Debug.Assert(ChooseNum((33L), (12354L)) == (12354L));
    Debug.Assert(ChooseNum((5234L), (5233L)) == (-1L));
    Debug.Assert(ChooseNum((6L), (29L)) == (28L));
    Debug.Assert(ChooseNum((27L), (10L)) == (-1L));
    Debug.Assert(ChooseNum((7L), (7L)) == (-1L));
    Debug.Assert(ChooseNum((546L), (546L)) == (546L));
    }

}
"
HumanEval_104,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Not: Geri gönderilen liste artan sırada sıralanmalıdır.    //Elemanların hiçbiri çift sayı değil.    //Bir pozitif tamsayı listesi verildiğinde x. tüm                         // >>> UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L})))
    // (new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))
    // >>> UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L})))
    // (new List<long>())
    public static List<long> UniqueDigits(List<long> x) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> UniqueDigits(List<long> x) {
        return x.Where(n => !n.ToString().Any(c => ""02468"".Contains(c)))
                .OrderBy(n => n)
                .ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)15L, (long)33L, (long)1422L, (long)1L}))).Equals((new List<long>(new long[]{(long)1L, (long)15L, (long)33L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)152L, (long)323L, (long)1422L, (long)10L}))).Equals((new List<long>())));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)12345L, (long)2033L, (long)111L, (long)151L}))).Equals((new List<long>(new long[]{(long)111L, (long)151L}))));
    Debug.Assert(UniqueDigits((new List<long>(new long[]{(long)135L, (long)103L, (long)31L}))).Equals((new List<long>(new long[]{(long)31L, (long)135L}))));
    }

}
"
HumanEval_105,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Bir, iki, üç, dört, beş, altı, yedi, sekiz, dokuz.    //Sonucun listesi tersine çevrilir ve sonra her bir basamak 'dan karşılık gelen isimle değiştirilir.    //Bir tamsayı listesi verildiğinde, 1 ile 9 arasında olan tamsayıları sıralayın.    // >>> ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L})))
    // (new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))
    // If the list is empty, return an empty list:
    // >>> ByLength((new List<long>()))
    // (new List<string>())
    // If the list has any strange number ignore it:
    // >>> ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L})))
    // (new List<string>(new string[]{(string)""One""}))
    public static List<string> ByLength(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ByLength(List<long> arr) {
        // Define a dictionary to map numbers to their names.
        var digitToName = new Dictionary<long, string> {
            {1, ""One""}, {2, ""Two""}, {3, ""Three""}, {4, ""Four""},
            {5, ""Five""}, {6, ""Six""}, {7, ""Seven""}, {8, ""Eight""}, {9, ""Nine""}
        };

        // Filter the numbers that are between 1 and 9.
        var filtered = arr.Where(x => digitToName.ContainsKey(x)).ToList();

        // Sort the filtered numbers.
        filtered.Sort();

        // Reverse the list.
        filtered.Reverse();

        // Map the numbers to their names using the dictionary.
        return filtered.Select(x => digitToName[x]).ToList();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ByLength((new List<long>(new long[]{(long)2L, (long)1L, (long)1L, (long)4L, (long)5L, (long)8L, (long)2L, (long)3L}))).Equals((new List<string>(new string[]{(string)""Eight"", (string)""Five"", (string)""Four"", (string)""Three"", (string)""Two"", (string)""Two"", (string)""One"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>())).Equals((new List<string>())));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)55L}))).Equals((new List<string>(new string[]{(string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)1L, (long)-1L, (long)3L, (long)2L}))).Equals((new List<string>(new string[]{(string)""Three"", (string)""Two"", (string)""One""}))));
    Debug.Assert(ByLength((new List<long>(new long[]{(long)9L, (long)4L, (long)8L}))).Equals((new List<string>(new string[]{(string)""Nine"", (string)""Eight"", (string)""Four""}))));
    }

}
"
HumanEval_106,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //i ' nin faktörelinin 1 ile i arasındaki sayılarla çarpılmasıdır (1 * 2 * ... * i).    //1'den başlıyorum.    //Ya da 1 ile i arasındaki sayılar toplamı.    //ve n boyutunda bir liste döndürür, böylece indeks i'deki elementin değeri, eğer i çiftse, i'nin faktörelidir.    //Parametresi olarak n'i alan f fonksiyonunu uygulayın,     // >>> F((5L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))
    public static List<long> F(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> F(long n) {
        List<long> result = new List<long>();

        for (long i = 1; i <= n; i++) {
            if (i % 2 == 0) {
                result.Add(Factorial(i));
            } else {
                result.Add(SumUpTo(i));
            }
        }
        
        return result;
    }

    private static long Factorial(long number) {
        if (number == 0) return 1;
        long factorial = 1;
        for (long i = 1; i <= number; i++) {
            factorial *= i;
        }
        return factorial;
    }

    private static long SumUpTo(long number) {
        return (number * (number + 1)) / 2;
    }

    static void Main(string[] args) {
        List<long> result = F(5);
        foreach (long val in result) {
            Console.WriteLine(val);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(F((5L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L}))));
    Debug.Assert(F((7L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L, (long)24L, (long)15L, (long)720L, (long)28L}))));
    Debug.Assert(F((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(F((3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)6L}))));
    }

}
"
HumanEval_107,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek 1:     //aralığı içinde bulunan tamsayı palindromlar ((1, n), dahil.     //Pozitif bir tamsayı n verildiğinde, çift ve tek sayıları olan bir tuple döndürün.    // >>> EvenOddPalindrome((3L))
    // (Tuple.Create(1L, 2L))
    // Explanation:
    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.
    // Example 2:
    // >>> EvenOddPalindrome((12L))
    // (Tuple.Create(4L, 6L))
    // Explanation:
    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.
    // Note:
    // 1. 1 <= n <= 10^3
    // 2. returned tuple has the number of even and odd integer palindromes respectively.
    public static Tuple<long, long> EvenOddPalindrome(long n) {
","public static Tuple<long, long> EvenOddPalindrome(long n) {
    long evenCount = 0;
    long oddCount = 0;

    for (long i = 1; i <= n; i++) {
        if (IsPalindrome(i)) {
            if (i % 2 == 0) {
                evenCount++;
            } else {
                oddCount++;
            }
        }
    }

    return Tuple.Create(evenCount, oddCount);
}

private static bool IsPalindrome(long number) {
    long original = number;
    long reversed = 0;

    while (number > 0) {
        long digit = number % 10;
        reversed = reversed * 10 + digit;
        number /= 10;
    }

    return original == reversed;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddPalindrome((123L)).Equals((Tuple.Create(8L, 13L))));
    Debug.Assert(EvenOddPalindrome((12L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((3L)).Equals((Tuple.Create(1L, 2L))));
    Debug.Assert(EvenOddPalindrome((63L)).Equals((Tuple.Create(6L, 8L))));
    Debug.Assert(EvenOddPalindrome((25L)).Equals((Tuple.Create(5L, 6L))));
    Debug.Assert(EvenOddPalindrome((19L)).Equals((Tuple.Create(4L, 6L))));
    Debug.Assert(EvenOddPalindrome((9L)).Equals((Tuple.Create(4L, 5L))));
    Debug.Assert(EvenOddPalindrome((1L)).Equals((Tuple.Create(0L, 1L))));
    }

}
"
HumanEval_108,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin, -123'in imzaları -1, 2 ve 3'tür.    //Bir sayı negatifse, ilk imzalı basamağı da negatif olacaktır:     //rakamların toplamı > 0 olan element sayısı.     //Bir tamsayı listesi alan ve döndüren count_nums fonksiyonunu yazın.    // >>> CountNums((new List<long>()))
    // (0L)
    // >>> CountNums((new List<long>(new long[]{(long)-1L, (long)11L, (long)-11L})))
    // (1L)
    // >>> CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L})))
    // (3L)
    public static long CountNums(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long CountNums(List<long> arr) {
        long count = 0;

        foreach (long number in arr) {
            long sumOfDigits = 0;
            long num = number;
            
            while (num != 0) {
                long digit = num % 10;
                sumOfDigits += digit;
                num /= 10;
            }

            if (sumOfDigits > 0) {
                count++;
            }
        }

        return count;
    }

    static void Main(string[] args) {
        // Test cases
        Console.WriteLine(CountNums(new List<long>())); // (0L)
        Console.WriteLine(CountNums(new List<long> { -1L, 11L, -11L })); // (1L)
        Console.WriteLine(CountNums(new List<long> { 1L, 1L, 2L })); // (3L)
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CountNums((new List<long>())) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)-1L, (long)-2L, (long)0L}))) == (0L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)1L, (long)2L, (long)-2L, (long)3L, (long)4L, (long)5L}))) == (6L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)6L, (long)9L, (long)-6L, (long)0L, (long)1L, (long)5L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L, (long)100L, (long)98L, (long)-7L, (long)1L, (long)-1L}))) == (4L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)12L, (long)23L, (long)34L, (long)-45L, (long)-56L, (long)0L}))) == (5L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)0L, (long)1L}))) == (1L));
    Debug.Assert(CountNums((new List<long>(new long[]{(long)1L}))) == (1L));
    }

}
"
HumanEval_109,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Not: Verilen listede benzersiz öğelerin olduğu garanti edilir.    //Eğer verilen liste boşsa true döndürür.    //O zaman doğruyu gönder, yoksa yanlışı gönder.    //Yukarıdaki işlemle sıralanmış listeyi elde etmek mümkünse     //Listedeki başlangıç pozisyonu, yani 0'uncu indeks.    //Listedeki son öğe                                                                                                                                                                                                                                                                                                              //Bir sağa kaydırma işleminin anlamı listedeki tüm öğeleri birle kaydırmaktır .    //Sağ kayma işlemini istediğiniz kadar defa yapabilirsiniz.    //verilen listede aşağıdaki işlem:     // yaparak , bir listeyi düşüş sırasına göre sıralamayı elde etmek mümkündür .    //Listedeki numaralar rastgele sıralanır.    //N tam sayıdan oluşan bir listemiz var arr[1], arr[2], ..., arr[N].    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L})))
    // (true)
    // Explanation: By performin 2 right shift operations, non-decreasing order can
    // be achieved for the given list.
    // >>> MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L})))
    // (false)
    // Explanation:It is not possible to get non-decreasing order for the given
    // list by performing any number of right shift operations.
    public static bool MoveOneBall(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool MoveOneBall(List<long> arr) {
        if (arr.Count == 0) return true;

        int n = arr.Count;
        int descentCount = 0;
        int indexOfDescent = -1;

        // Find number of descents in the array
        for (int i = 0; i < n; i++) {
            if (arr[i] > arr[(i + 1) % n]) {
                descentCount++;
                indexOfDescent = (i + 1) % n;
            }
            if (descentCount > 1) {
                return false;
            }
        }

        // No descents means the array is already sorted
        if (descentCount == 0) {
            return true;
        }

        // Check if the single descent allows a circular sorted order
        for (int i = 0; i < n; i++) {
            if (arr[(indexOfDescent + i) % n] > arr[(indexOfDescent + i + 1) % n]) {
                return false;
            }
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)4L, (long)5L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)10L, (long)1L, (long)2L}))) == (true));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)4L, (long)3L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>(new long[]{(long)3L, (long)5L, (long)4L, (long)1L, (long)2L}))) == (false));
    Debug.Assert(MoveOneBall((new List<long>())) == (true));
    }

}
"
HumanEval_110,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Aksi takdirde ""HAYIR"" i iade edin.    //lst1'in tüm öğelerinin çift olması için, ""EVET"" ilet.    //Eğer lst1 ve lst2 arasında değişim yapabilmek mümkünse     //Lst1 ve lst2 arasında değişen elemanların sayısında sınır yok.    //Lst1 sadece çift sayılar içeren bir liste oluşturmak için.    //ve bir değiş tokuş yapmanın mümkün olup olmadığını belirler .    //Bu problemde, iki sayı listesi alan bir fonksiyon uygulayacaksınız,     // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})))
    // (""YES"")
    // >>> Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L})))
    // (""NO"")
    // It is assumed that the input lists will be non-empty.
    public static string Exchange(List<long> lst1, List<long> lst2) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string Exchange(List<long> lst1, List<long> lst2)
    {
        int countOfOddsInLst1 = lst1.Count(x => x % 2 != 0);
        int countOfEvensInLst2 = lst2.Count(x => x % 2 == 0);

        return countOfOddsInLst1 <= countOfEvensInLst2 ? ""YES"" : ""NO"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)1L, (long)5L, (long)3L, (long)4L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L})), (new List<long>(new long[]{(long)2L, (long)1L, (long)4L, (long)3L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)4L}))).Equals((""YES"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)5L, (long)7L, (long)3L})), (new List<long>(new long[]{(long)2L, (long)6L, (long)3L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)3L, (long)2L, (long)6L, (long)1L, (long)8L, (long)9L})), (new List<long>(new long[]{(long)3L, (long)5L, (long)5L, (long)1L, (long)1L, (long)1L}))).Equals((""NO"")));
    Debug.Assert(Exchange((new List<long>(new long[]{(long)100L, (long)200L})), (new List<long>(new long[]{(long)200L, (long)200L}))).Equals((""YES"")));
    }

}
"
HumanEval_111,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Eğer birkaç harf aynı yerde varsa, hepsini geri gönder.    //En çok tekrarlanan ve karşılık gelen sayıyı içeren harfin.    //Boşlukla ayrılmış küçük harfleri temsil eden bir dize verildiğinde, bir sözlük döndür     // >>> Histogram((""a b c""))
    // (new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}})
    // >>> Histogram((""a b b a""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""a b c a b""))
    // (new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})
    // >>> Histogram((""b b b b a""))
    // (new Dictionary<string,long>(){{""b"", 4L}})
    // >>> Histogram((""""))
    // (new Dictionary<string,long>())
    public static Dictionary<string,long> Histogram(string test) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static Dictionary<string, long> Histogram(string test) {
        if (string.IsNullOrWhiteSpace(test)) {
            return new Dictionary<string, long>();
        }

        var words = test.Split(' ');
        var letterCounts = new Dictionary<string, long>();

        // Count the occurrences of each letter
        foreach (var word in words) {
            if (letterCounts.ContainsKey(word)) {
                letterCounts[word]++;
            } else {
                letterCounts[word] = 1;
            }
        }

        // Determine the maximum count
        long maxCount = letterCounts.Values.Max();

        // Create a dictionary for letters with the maximum count
        var result = letterCounts.Where(pair => pair.Value == maxCount)
                                 .ToDictionary(pair => pair.Key, pair => pair.Value);

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Histogram((""a b b a"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c a b"")).Equals((new Dictionary<string,long>(){{""a"", 2L}, {""b"", 2L}})));
    Debug.Assert(Histogram((""a b c d g"")).Equals((new Dictionary<string,long>(){{""a"", 1L}, {""b"", 1L}, {""c"", 1L}, {""d"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram((""b b b b a"")).Equals((new Dictionary<string,long>(){{""b"", 4L}})));
    Debug.Assert(Histogram((""r t g"")).Equals((new Dictionary<string,long>(){{""r"", 1L}, {""t"", 1L}, {""g"", 1L}})));
    Debug.Assert(Histogram(("""")).Equals((new Dictionary<string,long>())));
    Debug.Assert(Histogram((""a"")).Equals((new Dictionary<string,long>(){{""a"", 1L}})));
    }

}
"
HumanEval_112,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek     //Sonuç dizisi ve doğru/yanlış içeren bir tuple iade etmelisiniz.    //Bir dize, ileri ve geriye doğru aynı şekilde okunduğunda palindrom olarak adlandırılır.    //sonra sonuç dizinin palindrom olup olmadığını kontrol edin.     //İki dize s ve c veriliyor, s'deki tüm karakterleri silmeniz gerekiyor.    //Görev     // >>> ReverseDelete((""abcde""), (""ae""))
    // (Tuple.Create(""bcd"", false))
    // >>> ReverseDelete((""abcdef""), (""b""))
    // (Tuple.Create(""acdef"", false))
    // >>> ReverseDelete((""abcdedcba""), (""ab""))
    // (Tuple.Create(""cdedc"", true))
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
","using System;
using System.Linq;

class Problem {
    public static Tuple<string, bool> ReverseDelete(string s, string c) {
        // Remove characters from 's' that are in 'c'
        string resultString = new string(s.Where(ch => !c.Contains(ch)).ToArray());
        
        // Check if the result string is a palindrome
        bool isPalindrome = resultString.SequenceEqual(resultString.Reverse());

        // Return the result string and palindrome check as a tuple
        return Tuple.Create(resultString, isPalindrome);
    }

    // Example usage
    static void Main(string[] args) {
        var example1 = ReverseDelete(""abcde"", ""ae"");
        Console.WriteLine($""(\""bcd\"", false) == ({example1.Item1}, {example1.Item2})"");

        var example2 = ReverseDelete(""abcdef"", ""b"");
        Console.WriteLine($""(\""acdef\"", false) == ({example2.Item1}, {example2.Item2})"");

        var example3 = ReverseDelete(""abcdedcba"", ""ab"");
        Console.WriteLine($""(\""cdedc\"", true) == ({example3.Item1}, {example3.Item2})"");
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ReverseDelete((""abcde""), (""ae"")).Equals((Tuple.Create(""bcd"", false))));
    Debug.Assert(ReverseDelete((""abcdef""), (""b"")).Equals((Tuple.Create(""acdef"", false))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""ab"")).Equals((Tuple.Create(""cdedc"", true))));
    Debug.Assert(ReverseDelete((""dwik""), (""w"")).Equals((Tuple.Create(""dik"", false))));
    Debug.Assert(ReverseDelete((""a""), (""a"")).Equals((Tuple.Create("""", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), ("""")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""abcdedcba""), (""v"")).Equals((Tuple.Create(""abcdedcba"", true))));
    Debug.Assert(ReverseDelete((""vabba""), (""v"")).Equals((Tuple.Create(""abba"", true))));
    Debug.Assert(ReverseDelete((""mamma""), (""mia"")).Equals((Tuple.Create("""", true))));
    }

}
"
HumanEval_113,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Girişin i'inci dizisinde tek sayıların olması.    //"" tüm i'lerin yerine  numaraları geçmelidir.    //Çıktının her bir elemanı ""  tek elementlerin sayısı olmalıdır    //Her bir dizinin sadece rakamlardan oluştuğu bir dizin listesi verildiğinde, bir liste döndürür.    // >>> OddCount((new List<string>(new string[]{(string)""1234567""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))
    // >>> OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""})))
    // (new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))
    public static List<string> OddCount(List<string> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<string> OddCount(List<string> lst)
    {
        List<string> result = new List<string>();
        foreach (var str in lst)
        {
            int oddCount = 0;
            foreach (var c in str)
            {
                if ((c - '0') % 2 != 0) // Check if the digit is odd
                {
                    oddCount++;
                }
            }

            string output = $""the number of odd elements {oddCount}n the str{oddCount}ng {oddCount} of the {oddCount}nput."";
            result.Add(output);
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""1234567""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 4n the str4ng 4 of the 4nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""3"", (string)""11111111""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 1n the str1ng 1 of the 1nput."", (string)""the number of odd elements 8n the str8ng 8 of the 8nput.""}))));
    Debug.Assert(OddCount((new List<string>(new string[]{(string)""271"", (string)""137"", (string)""314""}))).Equals((new List<string>(new string[]{(string)""the number of odd elements 2n the str2ng 2 of the 2nput."", (string)""the number of odd elements 3n the str3ng 3 of the 3nput."", (string)""the number of odd elements 2n the str2ng 2 of the 2nput.""}))));
    }

}
"
HumanEval_114,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek     //- Evet.    //Bir tamsayı listesi verildiğinde, boş olmayan alt listenin en küçük toplamını bulun.    // >>> Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L})))
    // (1L)
    // >>> Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L})))
    // (-6L)
    public static long Minsubarraysum(List<long> nums) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Minsubarraysum(List<long> nums) {
        long minSum = nums[0], currentSum = nums[0];
        
        for (int i = 1; i < nums.Count; i++) {
            currentSum = Math.Min(nums[i], currentSum + nums[i]);
            minSum = Math.Min(minSum, currentSum);
        }
        
        return minSum;
    }

    // Example usage
    public static void Main() {
        Console.WriteLine(Minsubarraysum(new List<long> { 2L, 3L, 4L, 1L, 2L, 4L })); // Output: 1L
        Console.WriteLine(Minsubarraysum(new List<long> { -1L, -2L, -3L }));         // Output: -6L
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)1L, (long)2L, (long)4L}))) == (1L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)2L, (long)-10L}))) == (-14L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-9999999999999999L}))) == (-9999999999999999L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)0L, (long)10L, (long)20L, (long)1000000L}))) == (0L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-1L, (long)-2L, (long)-3L, (long)10L, (long)-5L}))) == (-6L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)10L, (long)11L, (long)13L, (long)8L, (long)3L, (long)4L}))) == (3L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)100L, (long)-33L, (long)32L, (long)-1L, (long)0L, (long)-2L}))) == (-33L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)-10L}))) == (-10L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)7L}))) == (7L));
    Debug.Assert(Minsubarraysum((new List<long>(new long[]{(long)1L, (long)-1L}))) == (-1L));
    }

}
"
HumanEval_115,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek 1:     //Kovaları indirmeniz gereken sayıyı yazın.    //Görevin, kovayı kullanarak kuyuları boşaltmak.    //Ve tüm kovalar aynı kapasiteye sahip.    //Her kuyunun, içinden su çekmek için kullanılabilecek bir kovası vardır.    //ve bir satırdaki her 1 tek bir su birimini temsil eder.    //Size bir kuyuyu temsil eden dikdörtgen bir ızgara veriliyor.    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L))
    // (6L)
    // Example 2:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L))
    // (5L)
    // Example 3:
    // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L))
    // (0L)
    // Constraints:
    // * all wells have the same length
    // * 1 <= grid.length <= 10^2
    // * 1 <= grid[:,1].length <= 10^2
    // * grid[i][j] -> 0 | 1
    // * 1 <= capacity <= 10
    public static long MaxFill(List<List<long>> grid, long capacity) {
","public static long MaxFill(List<List<long>> grid, long capacity) {
    long operations = 0;

    foreach (var row in grid) {
        long waterUnits = row.Sum();
        operations += waterUnits / capacity;
        if (waterUnits % capacity != 0) {
            operations++;
        }
    }

    return operations;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (1L)) == (6L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (2L)) == (5L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (5L)) == (0L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (2L)) == (4L));
    Debug.Assert(MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})})), (9L)) == (2L));
    }

}
"
HumanEval_116,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Şu şekilde uygulanmalı:    //Benzer sayıda birler için, ondalık değere göre sıralayın.    //İkili temsillerinde birlerin sayısı yükselen sırada.    //Bu kata'da, negatif olmayan tam sayılar listesini  şeklinde sıralamalısınız.    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))
    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))
    // (new List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))
    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))
    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))
    public static List<long> SortArray(List<long> arr) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<long> SortArray(List<long> arr) {
        return arr.OrderBy(num => CountOnesInBinary(num))
                  .ThenBy(num => num)
                  .ToList();
    }

    private static int CountOnesInBinary(long num) {
        return Convert.ToString(num, 2).Count(c => c == '1');
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));
    Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));
    }

}
"
HumanEval_117,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Not: Giriş dizesinin sadece harf ve boşluk içerdiğini varsayın.    //Eğer string s boşsa, fonksiyon boş bir liste döndürmelidir.    //n sesli harf, bu kelimelerin s dizeğinde ortaya çıkması için.    //tam olarak  içeren string s ' den tüm kelimelerin listesini döndüren bir fonksiyon .    //Bir dize s ve bir doğal sayı n verildiğinde, uygulamanız istendi.    // >>> SelectWords((""Mary had a little lamb""), (4L))
    // (new List<string>(new string[]{(string)""little""}))
    // >>> SelectWords((""Mary had a little lamb""), (3L))
    // (new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))
    // >>> SelectWords((""simple white space""), (2L))
    // (new List<string>())
    // >>> SelectWords((""Hello world""), (4L))
    // (new List<string>(new string[]{(string)""world""}))
    // >>> SelectWords((""Uncle sam""), (3L))
    // (new List<string>(new string[]{(string)""Uncle""}))
    public static List<string> SelectWords(string s, long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> SelectWords(string s, long n) {
        List<string> result = new List<string>();
        if (string.IsNullOrEmpty(s)) 
            return result;

        string[] words = s.Split(' ');
        string consonants = ""bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"";

        foreach (string word in words) {
            int consonantCount = 0;
            foreach (char c in word) {
                if (consonants.Contains(c)) {
                    consonantCount++;
                }
            }

            if (consonantCount == n) {
                result.Add(word);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SelectWords((""Mary had a little lamb""), (4L)).Equals((new List<string>(new string[]{(string)""little""}))));
    Debug.Assert(SelectWords((""Mary had a little lamb""), (3L)).Equals((new List<string>(new string[]{(string)""Mary"", (string)""lamb""}))));
    Debug.Assert(SelectWords((""simple white space""), (2L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""Hello world""), (4L)).Equals((new List<string>(new string[]{(string)""world""}))));
    Debug.Assert(SelectWords((""Uncle sam""), (3L)).Equals((new List<string>(new string[]{(string)""Uncle""}))));
    Debug.Assert(SelectWords((""""), (4L)).Equals((new List<string>())));
    Debug.Assert(SelectWords((""a b c d e f""), (1L)).Equals((new List<string>(new string[]{(string)""b"", (string)""c"", (string)""d"", (string)""f""}))));
    }

}
"
HumanEval_118,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Verilen dizinin sadece İngilizce harf içerdiğini varsayarsınız.    //Yukarıdaki şartları karşılayan herhangi bir sesli bul.    //Başlangıç ve son sesler sayılmaz. Eğer yapmadıysanız boş bir dize döndürün.    //kelimenin sağ tarafından iki sesli harf (büyük harf hassas).    //Size bir kelime veriliyor. Görevin, aralarında duran en yakın sesli harfi bulmak.    // >>> GetClosestVowel((""yogurt""))
    // (""u"")
    // >>> GetClosestVowel((""FULL""))
    // (""U"")
    // >>> GetClosestVowel((""quick""))
    // ("""")
    // >>> GetClosestVowel((""ab""))
    // ("""")
    public static string GetClosestVowel(string word) {
","using System;

class Problem {
    public static string GetClosestVowel(string word) {
        if (string.IsNullOrWhiteSpace(word) || word.Length < 3) {
            return """";
        }
        
        HashSet<char> vowels = new HashSet<char> { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
        
        for (int i = word.Length - 2; i > 0; i--) {
            if (vowels.Contains(word[i]) && 
                !vowels.Contains(word[i - 1]) && !vowels.Contains(word[i + 1])) {
                return word[i].ToString();
            }
        }
        return """";
    }

    static void Main(string[] args) {
        Console.WriteLine(GetClosestVowel(""yogurt"")); // Output: ""u""
        Console.WriteLine(GetClosestVowel(""FULL""));   // Output: ""U""
        Console.WriteLine(GetClosestVowel(""quick""));  // Output: """"
        Console.WriteLine(GetClosestVowel(""ab""));     // Output: """"
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetClosestVowel((""yogurt"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""full"")).Equals((""u"")));
    Debug.Assert(GetClosestVowel((""easy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""eAsy"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ali"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""bad"")).Equals((""a"")));
    Debug.Assert(GetClosestVowel((""most"")).Equals((""o"")));
    Debug.Assert(GetClosestVowel((""ab"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""ba"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""quick"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""anime"")).Equals((""i"")));
    Debug.Assert(GetClosestVowel((""Asia"")).Equals(("""")));
    Debug.Assert(GetClosestVowel((""Above"")).Equals((""o"")));
    }

}
"
HumanEval_119,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Eğer iyi bir dize oluşturmanın bir yolu varsa 'Evet' i ve aksi takdirde 'Hayır' i iade edin.    //"" (()) "" değil.    //Örneğin: '(((() ' dize iyi, oysa  dize iyi.    //Bir dize S , eğer ve sadece eğer S içindeki tüm parantezler iyiyse iyi olarak kabul edilir .    //Bu yüzden, sonuçta iyi bir dize oluşabilir.    //Senin işin iki dizeyi birbirine bağlamanın mümkün olup olmadığını kontrol etmek .    //sadece parantez "" (("" veya parantezleri kapatın "") "".    //İki dize listesi veriliyor, her iki dize de açık     // >>> MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""})))
    // (""Yes"")
    // >>> MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""})))
    // (""No"")
    public static string MatchParens(List<string> lst) {
","public static string MatchParens(List<string> lst) {
        if (lst.Count != 2) return ""No"";

        string str1 = lst[0];
        string str2 = lst[1];

        // Check both possible concatenations
        if (IsValidParentheses(str1 + str2) || IsValidParentheses(str2 + str1))
            return ""Yes"";
        
        return ""No"";
    }

    private static bool IsValidParentheses(string s) {
        int balance = 0;
        foreach (char c in s) {
            if (c == '(') {
                balance++;
            } else if (c == ')') {
                balance--;
            }
            if (balance < 0) {
                return false; // More closing parens than opening
            }
        }
        return balance == 0;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)"")""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()(())"", (string)""())())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")())"", (string)""(()()(""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(())))"", (string)""(()())((""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""()"", (string)""())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(()("", (string)""()))()""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""(((("", (string)""((())""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")(()"", (string)""(()(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")("", (string)"")(""}))).Equals((""No"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)""("", (string)"")""}))).Equals((""Yes"")));
    Debug.Assert(MatchParens((new List<string>(new string[]{(string)"")"", (string)""(""}))).Equals((""Yes"")));
    }

}
"
HumanEval_120,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek 1:     //Uzunluğu k olan ve en fazla k sayıdaki ar.    //Bir tam sayılar listesi ve pozitif bir tam sayı k verildiğinde, sıralanmış bir liste döndürür     // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L))
    // (new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))
    // Example 2:
    // >>> Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L))
    // (new List<long>(new long[]{(long)4L, (long)4L}))
    // Example 3:
    // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))
    // (new List<long>(new long[]{(long)2L}))
    // Note:
    // 1. The length of the list will be in the range of [1, 1000].
    // 2. The elements in the list will be in the range of [-1000, 1000].
    // 3. 0 <= k <= len(arr)
    public static List<long> Maximum(List<long> arr, long k) {
","public static List<long> Maximum(List<long> arr, long k) {
    return arr.OrderByDescending(n => n).Take((int)k).OrderBy(n => n).ToList();
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L)).Equals((new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})), (2L)).Equals((new List<long>(new long[]{(long)4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L)).Equals((new List<long>(new long[]{(long)2L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)123L, (long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (3L)).Equals((new List<long>(new long[]{(long)2L, (long)20L, (long)123L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})), (4L)).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)20L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)5L, (long)15L, (long)0L, (long)3L, (long)-13L, (long)-8L, (long)0L})), (7L)).Equals((new List<long>(new long[]{(long)-13L, (long)-8L, (long)0L, (long)0L, (long)3L, (long)5L, (long)15L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-1L, (long)0L, (long)2L, (long)5L, (long)3L, (long)-10L})), (2L)).Equals((new List<long>(new long[]{(long)3L, (long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)0L, (long)5L, (long)-7L})), (1L)).Equals((new List<long>(new long[]{(long)5L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)4L, (long)-4L})), (2L)).Equals((new List<long>(new long[]{(long)-4L, (long)4L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)-10L, (long)10L})), (2L)).Equals((new List<long>(new long[]{(long)-10L, (long)10L}))));
    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)-23L, (long)243L, (long)-400L, (long)0L})), (0L)).Equals((new List<long>())));
    }

}
"
HumanEval_121,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //Boş olmayan bir tamsayı listesi verildiğinde, çift konumdaki tüm tek elementlerin toplamını gönderin.     // >>> Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L})))
    // (12L)
    // >>> Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L})))
    // (9L)
    // >>> Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L})))
    // (0L)
    public static long Solution(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long Solution(List<long> lst) {
        long sum = 0;
        for (int i = 0; i < lst.Count; i += 2) { // Iterate over even indices
            if (lst[i] % 2 != 0) { // Check if the element is odd
                sum += lst[i];
            }
        }
        return sum;
    }
    
    static void Main() {
        Console.WriteLine(Solution(new List<long>{5L, 8L, 7L, 1L})); // Output: 12
        Console.WriteLine(Solution(new List<long>{3L, 3L, 3L, 3L, 3L})); // Output: 9
        Console.WriteLine(Solution(new List<long>{30L, 13L, 24L, 321L})); // Output: 0
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)8L, (long)7L, (long)1L}))) == (12L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)3L, (long)3L}))) == (9L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)24L, (long)321L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)5L, (long)9L}))) == (5L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)2L, (long)4L, (long)8L}))) == (0L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)30L, (long)13L, (long)23L, (long)32L}))) == (23L));
    Debug.Assert(Solution((new List<long>(new long[]{(long)3L, (long)13L, (long)2L, (long)9L}))) == (3L));
    }

}
"
HumanEval_122,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //ilk k elementin en fazla iki rakamını içeren elementlerin toplamı.    //Boş olmayan bir tamsayılar listesi verilmiştir ve bir tamsayı k, döndür     // >>> AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L))
    // (24L)
    // Constraints:
    // 1. 1 <= len(arr) <= 100
    // 2. 1 <= k <= len(arr)
    public static long AddElements(List<long> arr, long k) {
","public static long AddElements(List<long> arr, long k) {
        long sum = 0;
        for (int i = 0; i < k; i++) {
            if (arr[i] >= -99 && arr[i] <= 99) {
                sum += arr[i];
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L, (long)-2L, (long)-3L, (long)41L, (long)57L, (long)76L, (long)87L, (long)88L, (long)99L})), (3L)) == (-4L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)121L, (long)3L, (long)4000L, (long)5L, (long)6L})), (2L)) == (0L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)11L, (long)21L, (long)3L, (long)90L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (125L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)111L, (long)21L, (long)3L, (long)4000L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L})), (4L)) == (24L));
    Debug.Assert(AddElements((new List<long>(new long[]{(long)1L})), (1L)) == (1L));
    }

}
"
HumanEval_123,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //get_odd_collatz(5) [1, 5] # 5 için collatz dizisi [5, 16, 8, 4, 2, 1], yani tek sayılar sadece 1 ve 5'tir.     //Örneğin:     //2. geri gönderilen liste artan sırada sıralanmış.    //1. Collatz ((1) [1]     //Not:    //Terim artı 1. Tahminimiz n'in hangi değeri olursa olsun, dizilin her zaman 1'e ulaşmasıdır.    //Eğer önceki terim tekse, bir sonraki terim önceki terimin 3 katı.    //Önceki terim şu şekilde: Eğer önceki terim çiftse, bir sonraki terim 'in yarısıdır.    //aşağıdaki gibi: herhangi bir pozitif tamsayı n ile başlayın. Sonra her terim     //Collatz varsayımı , matematikte tanımlanmış bir diziyle ilgili bir varsayımdır .    //Pozitif bir tamsayı n verildiğinde, collatz dizisinde tek sayıları içeren sıralanmış bir liste döndürür.     // >>> GetOddCollatz((5L))
    // (new List<long>(new long[]{(long)1L, (long)5L}))
    public static List<long> GetOddCollatz(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> GetOddCollatz(long n)
    {
        HashSet<long> oddNumbers = new HashSet<long>();

        while (n != 1)
        {
            if (n % 2 != 0)
            {
                oddNumbers.Add(n);
            }

            if (n % 2 == 0)
            {
                n /= 2;
            }
            else
            {
                n = 3 * n + 1;
            }
        }

        oddNumbers.Add(1); // Add 1 to the set as per problem statement

        List<long> result = new List<long>(oddNumbers);
        result.Sort();

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetOddCollatz((14L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)7L, (long)11L, (long)13L, (long)17L}))));
    Debug.Assert(GetOddCollatz((5L)).Equals((new List<long>(new long[]{(long)1L, (long)5L}))));
    Debug.Assert(GetOddCollatz((12L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)5L}))));
    Debug.Assert(GetOddCollatz((1L)).Equals((new List<long>(new long[]{(long)1L}))));
    }

}
"
HumanEval_124,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //4. Tarih şu şekildedir: mm-dd-yyyy     //3. Aylar 1'den az veya 12'den fazla olmamalı.    //2. Aylar için gün sayısı 1'den az veya 31 günden fazla değil. Aylar için gün sayısı 1'den az veya 30 günden fazla değil. Aylar için gün sayısı 1'den az veya 29 günden fazla değil.    //1. Tarih dizisi boş değil.    //Aşağıdaki kuralların tümü yerine getirildiğinde tarih geçerlidir:     //tarih geçerli ise doğru iade eder, aksi takdirde yanlış.     //Verilen bir tarih dizisini doğrulayan bir fonksiyon yazmalısınız ve     // >>> ValidDate((""03-11-2000""))
    // (true)
    // >>> ValidDate((""15-01-2012""))
    // (false)
    // >>> ValidDate((""04-0-2040""))
    // (false)
    // >>> ValidDate((""06-04-2020""))
    // (true)
    // >>> ValidDate((""06/04/2020""))
    // (false)
    public static bool ValidDate(string date) {
","public static bool ValidDate(string date)
{
    if (string.IsNullOrEmpty(date) || date.Length != 10) return false;

    string[] dateParts = date.Split('-');
    if (dateParts.Length != 3) return false;

    if (!int.TryParse(dateParts[0], out int month) || !int.TryParse(dateParts[1], out int day) || !int.TryParse(dateParts[2], out int year))
    {
        return false;
    }

    if (month < 1 || month > 12) return false;

    if (year < 1) return false;

    bool isValidDay = false;

    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day >= 1 && day <= 31)
    {
        isValidDay = true;
    }
    else if ((month == 4 || month == 6 || month == 9 || month == 11) && day >= 1 && day <= 30)
    {
        isValidDay = true;
    }
    else if (month == 2 && day >= 1 && day <= 29)
    {
        isValidDay = true;
    }

    return isValidDay;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ValidDate((""03-11-2000"")) == (true));
    Debug.Assert(ValidDate((""15-01-2012"")) == (false));
    Debug.Assert(ValidDate((""04-0-2040"")) == (false));
    Debug.Assert(ValidDate((""06-04-2020"")) == (true));
    Debug.Assert(ValidDate((""01-01-2007"")) == (true));
    Debug.Assert(ValidDate((""03-32-2011"")) == (false));
    Debug.Assert(ValidDate(("""")) == (false));
    Debug.Assert(ValidDate((""04-31-3000"")) == (false));
    Debug.Assert(ValidDate((""06-06-2005"")) == (true));
    Debug.Assert(ValidDate((""21-31-2000"")) == (false));
    Debug.Assert(ValidDate((""04-12-2003"")) == (true));
    Debug.Assert(ValidDate((""04122003"")) == (false));
    Debug.Assert(ValidDate((""20030412"")) == (false));
    Debug.Assert(ValidDate((""2003-04"")) == (false));
    Debug.Assert(ValidDate((""2003-04-12"")) == (false));
    Debug.Assert(ValidDate((""04-2003"")) == (false));
    }

}
"
HumanEval_126,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //sayılar, false döndürür. Negatif sayıların ve sadece tam sayılar varsayım.    //Eğer listede aynı sayının birden fazla kopyası varsa     //Bir sayı listesi verildiğinde, sıralanmış olsun ya da olmasın, geri döndürür.    // >>> IsSorted((new List<long>(new long[]{(long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L})))
    // (false)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L})))
    // (true)
    // >>> IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L})))
    // (false)
    public static bool IsSorted(List<long> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static bool IsSorted(List<long> lst) {
        if (lst.Count == 0) return true;

        // To store the occurrence of each number
        var occurrences = new Dictionary<long, int>();

        for (int i = 0; i < lst.Count - 1; i++) {
            // Check if the current number is greater than the next number
            if (lst[i] > lst[i + 1]) {
                return false;
            }

            // Count the occurrences of each number
            if (occurrences.ContainsKey(lst[i])) {
                occurrences[lst[i]]++;
            } else {
                occurrences[lst[i]] = 1;
            }

            // If any number occurs more than twice
            if (occurrences[lst[i]] > 2) {
                return false;
            }
        }

        // Check the last element in the list for more than two occurrences
        if (occurrences.ContainsKey(lst[lst.Count - 1])) {
            occurrences[lst[lst.Count - 1]]++;
            if (occurrences[lst[lst.Count - 1]] > 2) {
                return false;
            }
        } else {
            occurrences[lst[lst.Count - 1]] = 1;
        }

        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)7L}))) == (false));
    Debug.Assert(IsSorted((new List<long>())) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)3L, (long)2L, (long)1L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)2L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L}))) == (false));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)3L, (long)3L, (long)4L}))) == (true));
    Debug.Assert(IsSorted((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))) == (true));
    }

}
"
HumanEval_127,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //[Giriş/çıkış] örnekleri:     //Eğer iki aralık kesişmiyorsa, ""HAYIR"" i iade edin.    //Aksi takdirde ""HAYIR"" i iade edin.    //Çatışmanın uzunluğu asal bir sayı ise, ""EVET"" ilet.    //Uzunluğu 1 olan bir sayı, ki bu bir asal sayı değil.    //Örnek olarak, (1, 3), (2, 4) aralığının kesişme noktası (2, 3)     //Aralıklar bir asal sayıdır.    //Görevin bu iki şeyin kesişim uzunluğunun     //Her bir aralığın başlangıcının bitişinden daha az veya eşit olduğu varsayılır.    //hem başlangıç hem de son içerir.    //Verilen aralıklar kapalıdır, yani aralık (başlangıç, son)     //Her aralığın bir çift tam sayı olduğu, örneğin, aralık = (başlangıç, son) = (1, 2).    //İki zaman aralığı veriliyor.    // >>> Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L)))
    // (""NO"")
    // >>> Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L)))
    // (""YES"")
    public static string Intersection(Tuple<long, long> interval1, Tuple<long, long> interval2) {
","long start1 = interval1.Item1;
    long end1 = interval1.Item2;
    long start2 = interval2.Item1;
    long end2 = interval2.Item2;

    long intersectStart = Math.Max(start1, start2);
    long intersectEnd = Math.Min(end1, end2);

    if (intersectStart > intersectEnd) {
        return ""NO"";
    }

    long intersectionLength = intersectEnd - intersectStart + 1;

    if (IsPrime(intersectionLength)) {
        return ""YES"";
    } else {
        return ""NO"";
    }
}

private static bool IsPrime(long number) {
    if (number < 2) return false;
    if (number == 2) return true;
    if (number % 2 == 0) return false;

    long boundary = (long)Math.Floor(Math.Sqrt(number));

    for (long i = 3; i <= boundary; i += 2) {
        if (number % i == 0) {
            return false;
        }
    }

    return true;
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L, 4L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L, 5L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, 2L)), (Tuple.Create(-4L, 0L))).Equals((""YES"")));
    Debug.Assert(Intersection((Tuple.Create(-11L, 2L)), (Tuple.Create(-1L, -1L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(3L, 5L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(1L, 2L))).Equals((""NO"")));
    Debug.Assert(Intersection((Tuple.Create(-2L, -2L)), (Tuple.Create(-3L, -2L))).Equals((""NO"")));
    }

}
"
HumanEval_128,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Not: boş arg için null döndürür.     //listedeki her sayının 1, -1 veya 0 ile temsil edildiği.    //Bütün sayılardaki büyüklüklerin toplamı , tüm işaretlerin çarpımı ile çarpılmış .    //Size tam sayılar listesi veriliyor ve geri dönmeniz gerekiyor.    // >>> ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L})))
    // 9L
    // >>> ProdSigns((new List<long>(new long[]{(long)0L, (long)1L})))
    // 0L
    // >>> ProdSigns((new List<long>()))
    // null
    public static Nullable<long> ProdSigns(List<long> arr) {
","public static Nullable<long> ProdSigns(List<long> arr) {
        if (arr == null || arr.Count == 0) return null;

        long sumOfMagnitudes = 0;
        long productOfSigns = 1;

        foreach (var num in arr) {
            sumOfMagnitudes += Math.Abs(num);

            if (num > 0) {
                productOfSigns *= 1;
            } else if (num < 0) {
                productOfSigns *= -1;
            } else {
                productOfSigns = 0;
                break;
            }
        }

        return sumOfMagnitudes * productOfSigns;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)2L, (long)2L, (long)-4L}))).Equals(-9L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)0L, (long)1L}))).Equals(0L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)2L, (long)3L, (long)-1L, (long)1L}))).Equals(-10L));
    Debug.Assert(ProdSigns((new List<long>())).Equals(null));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)2L, (long)-1L, (long)-1L, (long)9L}))).Equals(20L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)-1L, (long)1L}))).Equals(4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)1L}))).Equals(-4L));
    Debug.Assert(ProdSigns((new List<long>(new long[]{(long)-1L, (long)1L, (long)1L, (long)0L}))).Equals(0L));
    }

}
"
HumanEval_129,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Minimum yolun geçtiği hücrelerdeki değerlerin sıralanmış bir listesini döndürür.     //Cevabın eşsiz olduğu garantilidir.    //lst_A[j] = lst_B[j].    //lst_A[i] < lst_B[i] ve herhangi bir j (1 <= j < i) için     //lst_B'den daha fazla, başka bir deyişle, bir tamsayı endeksi var i (1 <= i <= k)     //lst_A ve lst_B olarak adlandıralım), lst_A sözlükler arasında daha az     //A ve B hücrelerindeki değerlerin sıralanmış listesini yaptıktan sonra gidin .    //Bir yol A (uzunluğu k) , eğer     //Şebekeden çıkamazsın.    //mutlaka farklıdır).    //Lütfen k uzunluğundaki bir yolun tam olarak k hücreyi ziyaret ettiğini (k  hücreyi değil) belirtin .    //hücre.     //Yani, sizinle kenar paylaşılan hücrelere gidebilirsiniz.    //Her adımda komşu hücrelerden herhangi birine geçebilirsiniz.    //K uzunluğundaki en küçük yolu bulmanız gerekiyor.    //""inclusive"" tam olarak bir kez grid hücrelerinde görünür.    // Her hücre bir değer içerir.  [1, N * N] aralığındaki her tamsayı     //N satır ve N sütunlu (N >= 2) ve pozitif bir tamsayı k olan bir ızgara verildiğinde,     // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L))
    // (new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))
    // >>> Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L))
    // (new List<long>(new long[]{(long)1L}))
    public static List<long> Minpath(List<List<long>> grid, long k) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Minpath(List<List<long>> grid, long k) {
        int n = grid.Count;
        List<long> result = new List<long>();
        long[,] dp = new long[n, n];
        (int, int)[,] parent = new (int, int)[n, n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = long.MaxValue;
            }
        }

        var directions = new List<(int, int)>() { (0, 1), (1, 0), (0, -1), (-1, 0) };
        SortedSet<(long, int, int)> pq = new SortedSet<(long, int, int)>((a, b) => a.Item1 == b.Item1 ? (a.Item2 == b.Item2 ? a.Item3.CompareTo(b.Item3) : a.Item2.CompareTo(b.Item2)) : a.Item1.CompareTo(b.Item1));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i, j] = grid[i][j];
                pq.Add((grid[i][j], i, j));
            }
        }

        while (pq.Count > 0) {
            var curr = pq.Min;
            pq.Remove(curr);
            long currValue = curr.Item1;
            int x = curr.Item2;
            int y = curr.Item3;

            foreach (var dir in directions) {
                int newX = x + dir.Item1;
                int newY = y + dir.Item2;
                if (newX >= 0 && newX < n && newY >= 0 && newY < n) {
                    long newCost = currValue + grid[newX][newY];
                    if (dp[newX, newY] > newCost) {
                        if (dp[newX, newY] != long.MaxValue) {
                            pq.Remove((dp[newX, newY], newX, newY));
                        }
                        dp[newX, newY] = newCost;
                        parent[newX, newY] = (x, y);
                        pq.Add((dp[newX, newY], newX, newY));
                    }
                }
            }
        }

        (int, int) end = (0, 0);
        long minPathSum = long.MaxValue;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (minPathSum > dp[i, j]) {
                    minPathSum = dp[i, j];
                    end = (i, j);
                }
            }
        }

        Stack<long> pathStack = new Stack<long>();
        (int, int) node = end;
        for (int step = 0; step < k; step++) {
            pathStack.Push(grid[node.Item1][node.Item2]);
            node = parent[node.Item1, node.Item2];
        }

        while (pathStack.Count > 0) {
            result.Add(pathStack.Pop());
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})})), (3L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)5L, (long)9L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)2L})})), (1L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)5L, (long)6L, (long)7L, (long)8L}), (List<long>)new List<long>(new long[]{(long)9L, (long)10L, (long)11L, (long)12L}), (List<long>)new List<long>(new long[]{(long)13L, (long)14L, (long)15L, (long)16L})})), (4L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)10L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)12L, (long)1L}), (List<long>)new List<long>(new long[]{(long)3L, (long)16L, (long)11L, (long)15L}), (List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L})})), (7L)).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)1L, (long)10L, (long)1L, (long)10L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)8L, (long)14L, (long)9L, (long)2L}), (List<long>)new List<long>(new long[]{(long)6L, (long)4L, (long)13L, (long)15L}), (List<long>)new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)12L}), (List<long>)new List<long>(new long[]{(long)3L, (long)10L, (long)11L, (long)16L})})), (5L)).Equals((new List<long>(new long[]{(long)1L, (long)7L, (long)1L, (long)7L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L})})), (9L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)12L, (long)13L, (long)10L, (long)1L}), (List<long>)new List<long>(new long[]{(long)9L, (long)3L, (long)15L, (long)6L}), (List<long>)new List<long>(new long[]{(long)5L, (long)16L, (long)14L, (long)4L}), (List<long>)new List<long>(new long[]{(long)11L, (long)8L, (long)7L, (long)2L})})), (12L)).Equals((new List<long>(new long[]{(long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L, (long)1L, (long)6L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)6L, (long)8L, (long)9L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)6L, (long)1L, (long)5L}), (List<long>)new List<long>(new long[]{(long)3L, (long)8L, (long)9L}), (List<long>)new List<long>(new long[]{(long)2L, (long)7L, (long)4L})})), (8L)).Equals((new List<long>(new long[]{(long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L, (long)1L, (long)5L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L, (long)1L, (long)2L}))));
    Debug.Assert(Minpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)3L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L})})), (10L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L, (long)1L, (long)3L}))));
    }

}
"
HumanEval_130,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Tribonacci dizisinin ilk n + 1 numarası.    //Size negatif olmayan bir tamsayı veriliyor, ve size bir liste döndürmek zorundasınız.    //= 2 + 3 + 3 = 8     //tri(3) = tri(2) + tri(1) + tri(4)     //tri ((4) = 3     //tri(2) = 1 + (2 / 2) = 2     //Örneğin:     //tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), eğer n tekse.     //tri (n) = 1 + n / 2, eğer n çiftse.     //tri(1) = 3     //Tribonacci dizisi tekrarlama ile tanımlanır:    //Ancak insanların bilmediği şey Tribonacci dizisi.    //Herkes Fibonacci dizisini bilir, matematikçiler tarafından derinlemesine incelendi.    // >>> Tri((3L))
    // (new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))
    public static List<long> Tri(long n) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Tri(long n)
    {
        List<long> tribonacci = new List<long>(new long[n + 1]);

        for (long i = 0; i <= n; i++)
        {
            if (i == 0)
                tribonacci[(int)i] = 1;
            else if (i == 1)
                tribonacci[(int)i] = 3;
            else if (i % 2 == 0)
                tribonacci[(int)i] = 1 + i / 2;
            else
                tribonacci[(int)i] = tribonacci[(int)(i - 1)] + tribonacci[(int)(i - 2)] + tribonacci[(int)(i + 1)];
        }
        
        return tribonacci;
    }
    
    static void Main(string[] args)
    {
        // Example usage:
        Console.WriteLine(string.Join("", "", Tri(3)));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Tri((3L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L}))));
    Debug.Assert(Tri((4L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L}))));
    Debug.Assert(Tri((5L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L}))));
    Debug.Assert(Tri((6L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L}))));
    Debug.Assert(Tri((7L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L}))));
    Debug.Assert(Tri((8L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L}))));
    Debug.Assert(Tri((9L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L}))));
    Debug.Assert(Tri((20L)).Equals((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)8L, (long)3L, (long)15L, (long)4L, (long)24L, (long)5L, (long)35L, (long)6L, (long)48L, (long)7L, (long)63L, (long)8L, (long)80L, (long)9L, (long)99L, (long)10L, (long)120L, (long)11L}))));
    Debug.Assert(Tri((0L)).Equals((new List<long>(new long[]{(long)1L}))));
    Debug.Assert(Tri((1L)).Equals((new List<long>(new long[]{(long)1L, (long)3L}))));
    }

}
"
HumanEval_131,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Tüm rakamlar çiftse 0 verir.     //Pozitif bir tamsayı n verilmişse, tek basamakların çarpımını gönderin.     // >>> Digits((1L))
    // (1L)
    // >>> Digits((4L))
    // (0L)
    // >>> Digits((235L))
    // (15L)
    public static long Digits(long n) {
","using System;

class Problem {
    public static long Digits(long n) {
        long product = 1;
        bool hasOdd = false;

        while (n > 0) {
            long digit = n % 10;
            if (digit % 2 != 0) {
                product *= digit;
                hasOdd = true;
            }
            n /= 10;
        }

        return hasOdd ? product : 0;
    }

    static void Main(string[] args) {
        Console.WriteLine(Digits(1L));    // Output: 1
        Console.WriteLine(Digits(4L));    // Output: 0
        Console.WriteLine(Digits(235L));  // Output: 15
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Digits((5L)) == (5L));
    Debug.Assert(Digits((54L)) == (5L));
    Debug.Assert(Digits((120L)) == (1L));
    Debug.Assert(Digits((5014L)) == (5L));
    Debug.Assert(Digits((98765L)) == (315L));
    Debug.Assert(Digits((5576543L)) == (2625L));
    Debug.Assert(Digits((2468L)) == (0L));
    }

}
"
HumanEval_132,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Bu sayfalardaki en az bir parantez, bir sonraki sıradaki parantez ile birlikte oluşturulmuştur.    //Eğer ve sadece eğer parantezlerin geçerli bir alt sırası varsa fonksiyon true döndürülmelidir .    //Sadece kare parantez içeren bir dizeyi girdi olarak alan bir fonksiyon oluşturun.    // >>> IsNested((""[[]]""))
    // (true)
    // >>> IsNested((""[]]]]]]][[[[[]""))
    // (false)
    // >>> IsNested((""[][]""))
    // (false)
    // >>> IsNested((""[]""))
    // (false)
    // >>> IsNested((""[[][]]""))
    // (true)
    // >>> IsNested((""[[]][[""))
    // (true)
    public static bool IsNested(string str) {
","using System;
using System.Collections.Generic;

class Problem {
    public static bool IsNested(string str) {
        Stack<char> stack = new Stack<char>();
        bool hasNested = false;
        
        foreach (char ch in str) {
            if (ch == '[') {
                stack.Push(ch);
            } else if (ch == ']') {
                if (stack.Count > 0) {
                    stack.Pop();
                    hasNested = true;
                } else {
                    return false; // More closing brackets than opening
                }
            }

            // Check for nesting
            if (stack.Count > 1) {
                hasNested = true;
            }
        }
        
        return stack.Count == 0 && hasNested;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsNested((""[[]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]][[[[[]"")) == (false));
    Debug.Assert(IsNested((""[][]"")) == (false));
    Debug.Assert(IsNested((""[]"")) == (false));
    Debug.Assert(IsNested((""[[[[]]]]"")) == (true));
    Debug.Assert(IsNested((""[]]]]]]]]]]"")) == (false));
    Debug.Assert(IsNested((""[][][[]]"")) == (true));
    Debug.Assert(IsNested((""[[]"")) == (false));
    Debug.Assert(IsNested((""[]]"")) == (false));
    Debug.Assert(IsNested((""[[]][["")) == (true));
    Debug.Assert(IsNested((""[[][]]"")) == (true));
    Debug.Assert(IsNested(("""")) == (false));
    Debug.Assert(IsNested((""[[[[[[[["")) == (false));
    Debug.Assert(IsNested((""]]]]]]]]"")) == (false));
    }

}
"
HumanEval_133,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Öncelikle listedeki her bir öğeyi üstteki int (En fazla) değerine yuvarlayın.    //Verilen listedeki sayıların karesinin toplamını vermek zorundasınız,     //Sana bir numara listesi veriliyor.    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f})))
    // (14L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)4.0f, (float)9.0f})))
    // (98L)
    // >>> Lst((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))
    // (84L)
    // >>> Lst((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f})))
    // (29L)
    // >>> Lst((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f})))
    // (6L)
    public static long SumSquares(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<float> lst)
    {
        long sum = 0;
        foreach (float num in lst)
        {
            int roundedNum = (int)Math.Ceiling(num);
            sum += (long)(roundedNum * roundedNum);
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)2.0f, (float)3.0f}))) == (14L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f}))) == (84L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)1.4f, (float)4.2f, (float)0.0f}))) == (29L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-2.4f, (float)1.0f, (float)1.0f}))) == (6L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)100.0f, (float)1.0f, (float)15.0f, (float)2.0f}))) == (10230L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)10000.0f, (float)10000.0f}))) == (200000000L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)4.6f, (float)6.3f}))) == (75L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.4f, (float)17.9f, (float)18.9f, (float)19.9f}))) == (1086L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)0.0f}))) == (0L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f}))) == (1L));
    Debug.Assert(SumSquares((new List<float>(new float[]{(float)-1.0f, (float)1.0f, (float)0.0f}))) == (2L));
    }

}
"
HumanEval_134,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Not: ""word"" bir grup karakterdir.    //Bir kelimenin bir parçası, ve diğer türlü yanlış.    //verilen bir dize alfabetik bir karakterdir ve  değildir .    //Son karakter  ise true döndüren bir fonksiyon oluşturun .    // >>> CheckIfLastCharIsALetter((""apple pie""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""apple pi e""))
    // (true)
    // >>> CheckIfLastCharIsALetter((""apple pi e ""))
    // (false)
    // >>> CheckIfLastCharIsALetter((""""))
    // (false)
    public static bool CheckIfLastCharIsALetter(string txt) {
","public static bool CheckIfLastCharIsALetter(string txt) {
        if (string.IsNullOrWhiteSpace(txt)) {
            return false;
        }

        txt = txt.Trim();
        if (txt.Length == 0) {
            return false;
        }

        int lastIndex = txt.Length - 1;
        char lastChar = txt[lastIndex];

        if (!char.IsLetter(lastChar)) {
            return false;
        }

        if (lastIndex == 0 || char.IsWhiteSpace(txt[lastIndex - 1])) {
            return true;
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CheckIfLastCharIsALetter((""apple"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""A"")) == (true));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""Pumpkin pie 1"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter(("""")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""eeeee e "")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pie"")) == (false));
    Debug.Assert(CheckIfLastCharIsALetter((""apple pi e "")) == (false));
    }

}
"
HumanEval_135,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Çifte değerler.    //böyle bir öğe yok ise -1 döndürür. Verilen liste  içermez.    // öncesindeki elementten daha büyük veya eşit değildir.    //                                                                      // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L})))
    // (3L)
    // >>> CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})))
    // (-1L)
    public static long CanArrange(List<long> arr) {
","using System;
using System.Collections.Generic;

class Problem {
    // Create a function which returns the largest index of an element which
    // is not greater than or equal to the element immediately preceding it.
    // If no such element exists, then return -1.
    public static long CanArrange(List<long> arr) {
        for (int i = arr.Count - 1; i > 0; i--) {
            if (arr[i] < arr[i - 1]) {
                return i;
            }
        }
        return -1;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))) == (3L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)5L}))) == (-1L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)1L, (long)4L, (long)2L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L}))) == (2L));
    Debug.Assert(CanArrange((new List<long>(new long[]{(long)4L, (long)8L, (long)5L, (long)7L, (long)3L}))) == (4L));
    Debug.Assert(CanArrange((new List<long>())) == (-1L));
    }

}
"
HumanEval_136,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Eğer negatif veya pozitif tam sayılar yoksa, onları null olarak döndürün.    //Bir listede pozitif tam sayılar.    //En büyük negatif tamsayı ve en küçük olan da b.    //Bir fonksiyon oluşturun ve burada 'a'     // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L})))
    // Tuple.Create((Nullable<long>)null, 1L)
    // >>> LargestSmallestIntegers((new List<long>()))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)0L})))
    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)
    public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
","public static Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst) {
        Nullable<long> largestNegative = null;
        Nullable<long> smallestPositive = null;

        foreach (var number in lst) {
            if (number < 0) {
                if (largestNegative == null || number > largestNegative) {
                    largestNegative = number;
                }
            } else if (number > 0) {
                if (smallestPositive == null || number < smallestPositive) {
                    smallestPositive = number;
                }
            }
        }

        return Tuple.Create(largestNegative, smallestPositive);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L, (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L, (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L, (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L, 2L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L, (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L, (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));
    }

}
"
HumanEval_138,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek     //Verilen sayının n ' in tam olarak 4 pozitif çift sayının toplamı olarak yazılabileceğini değerlendirin .    // >>> IsEqualToSumEven((4L))
    // (false)
    // >>> IsEqualToSumEven((6L))
    // (false)
    // >>> IsEqualToSumEven((8L))
    // (true)
    public static bool IsEqualToSumEven(long n) {
","using System;

class Problem {
    // Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
    public static bool IsEqualToSumEven(long n) {
        // Check if n is at least the sum of the smallest 4 positive even numbers (2 + 2 + 2 + 2 = 8)
        return n >= 8 && n % 2 == 0;
    }
    
    static void Main() {
        Console.WriteLine(IsEqualToSumEven(4L));  // false
        Console.WriteLine(IsEqualToSumEven(6L));  // false
        Console.WriteLine(IsEqualToSumEven(8L));  // true
        Console.WriteLine(IsEqualToSumEven(10L)); // true
        Console.WriteLine(IsEqualToSumEven(12L)); // true
        Console.WriteLine(IsEqualToSumEven(15L)); // false
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IsEqualToSumEven((4L)) == (false));
    Debug.Assert(IsEqualToSumEven((6L)) == (false));
    Debug.Assert(IsEqualToSumEven((8L)) == (true));
    Debug.Assert(IsEqualToSumEven((10L)) == (true));
    Debug.Assert(IsEqualToSumEven((11L)) == (false));
    Debug.Assert(IsEqualToSumEven((12L)) == (true));
    Debug.Assert(IsEqualToSumEven((13L)) == (false));
    Debug.Assert(IsEqualToSumEven((16L)) == (true));
    }

}
"
HumanEval_139,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //n > 0     //brazilian_factorial ((n) = n! * (n-1)! * (n-2)! * ... * 1!     //Brezilya faktörel olarak tanımlanır:     // >>> SpecialFactorial((4L))
    // (288L)
    // The function will receive an integer as input and should return the special
    // factorial of this integer.
    public static long SpecialFactorial(long n) {
","using System;
using System.Numerics;

class Problem {
    public static long SpecialFactorial(long n) {
        if (n <= 0)
            throw new ArgumentException(""n must be greater than 0"");
        
        BigInteger brazilianFactorial = 1;
        
        for (long i = 1; i <= n; i++) {
            brazilianFactorial *= Factorial(i);
        }
        
        return (long)brazilianFactorial;
    }
    
    private static BigInteger Factorial(long num) {
        BigInteger result = 1;
        for (long i = 1; i <= num; i++) {
            result *= i;
        }
        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SpecialFactorial((4L)) == (288L));
    Debug.Assert(SpecialFactorial((5L)) == (34560L));
    Debug.Assert(SpecialFactorial((7L)) == (125411328000L));
    Debug.Assert(SpecialFactorial((1L)) == (1L));
    }

}
"
HumanEval_140,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Ardından , ardışık boşlukların yerine -  yaz .    //ve eğer bir dize 2'den fazla ardışık boşluk içerirse,     //Bir metin dizisi verildiğinde, içindeki tüm boşlukları alt çizgilerle değiştirin,     // >>> FixSpaces(("" Example""))
    // (""Example"")
    // >>> FixSpaces(("" Example 1""))
    // (""Example_1"")
    // >>> FixSpaces(("" Example 2""))
    // (""_Example_2"")
    // >>> FixSpaces(("" Example 3""))
    // (""_Example-3"")
    public static string FixSpaces(string text) {
","public static string FixSpaces(string text) {
        StringBuilder result = new StringBuilder();
        int spaceCount = 0;

        for (int i = 0; i < text.Length; i++) {
            if (text[i] == ' ') {
                spaceCount++;
            } else {
                if (spaceCount > 2) {
                    result.Append('-');
                } else {
                    for (int j = 0; j < spaceCount; j++) {
                        result.Append('_');
                    }
                }
                result.Append(text[i]);
                spaceCount = 0;
            }
        }

        if (spaceCount > 2) {
            result.Append('-');
        } else {
            for (int j = 0; j < spaceCount; j++) {
                result.Append('_');
            }
        }

        return result.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FixSpaces((""Example"")).Equals((""Example"")));
    Debug.Assert(FixSpaces((""Mudasir Hanif "")).Equals((""Mudasir_Hanif_"")));
    Debug.Assert(FixSpaces((""Yellow Yellow  Dirty  Fellow"")).Equals((""Yellow_Yellow__Dirty__Fellow"")));
    Debug.Assert(FixSpaces((""Exa   mple"")).Equals((""Exa-mple"")));
    Debug.Assert(FixSpaces((""   Exa 1 2 2 mple"")).Equals((""-Exa_1_2_2_mple"")));
    }

}
"
HumanEval_141,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //- Noktanın arkasındaki alt dize bunlardan biri olmalı: ['txt', 'exe', 'dll']     //Latin alfabesi ('a'-'z' ve 'A'-'Z').     //- Noktanın önündeki alt dize boş olmamalı ve  harfiyle başlamalı.    //- Dosyanın adı tam olarak tek noktayı içerir.    //- Dosya adında üçten fazla sayı (""0"" - ""9"") olmamalıdır.     //karşılanıyor:     //Bir dosyanın adı, aşağıdaki tüm koşullar sağlanırsa ve yalnızca sağlanırsa geçerli sayılır.    //Dosya adı geçerli ise ""Evet"" ve aksi takdirde ""Hayır"" verir.     //Bir dosyanın adını temsil eden bir dizeyi alan ve  döndüren bir fonksiyon oluşturun.    // >>> FileNameCheck((""example.txt""))
    // (""Yes"")
    // >>> FileNameCheck((""1example.dll""))
    // (""No"")
    public static string FileNameCheck(string file_name) {
","using System;
using System.Text.RegularExpressions;

class Problem {
    public static string FileNameCheck(string file_name) {
        // Regular expression to validate the file name
        string pattern = @""^[a-zA-Z][^.]*\.[^.]+$"";
        
        // Check if there is exactly one dot and matches the overall pattern
        if (Regex.IsMatch(file_name, pattern)) {
            string[] parts = file_name.Split('.');
            
            // Check if the file extension is one of the allowed values
            if (new[] { ""txt"", ""exe"", ""dll"" }.Contains(parts[1])) {
                // Count the number of digits in the file name
                int digitCount = file_name.Count(char.IsDigit);
                
                // Validate the digit count
                if (digitCount <= 3) {
                    return ""Yes"";
                }
            }
        }
        
        return ""No"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FileNameCheck((""example.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1example.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s1sdf3.asd"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""K.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""MY16FILE3.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""His12FILE94.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_Y.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""?aREYA.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""/this_is_valid.dll"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.wow"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""this_is_valid.txtexe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""#this2_i4s_5valid.ten"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""@this1_is6_valid.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""this_is_12valid.6exe4.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""all.exe.txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_No.exe"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""Is3youfault.txt"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""no_one#knows.dll"")).Equals((""Yes"")));
    Debug.Assert(FileNameCheck((""1I563_Yes3.exe"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""I563_Yes3.txtt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final..txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""final132"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""_f4indsartal132."")).Equals((""No"")));
    Debug.Assert(FileNameCheck(("".txt"")).Equals((""No"")));
    Debug.Assert(FileNameCheck((""s."")).Equals((""No"")));
    }

}
"
HumanEval_142,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //İşlev, 3 veya 4'ün katı olmayan liste girişlerini değiştirir.    //3'ün katı ve eğer endeksi 3'ün katı değil de 4'ün katı ise tamsayı girdisini küpleştirecektir.    //Bu fonksiyon tamsayılar listesini alacaktır. Listedeki tüm girdiler için, fonksiyon, endeksi a  ise tamsayı girdisini kareleştirecektir.    //""     // >>> lst
    // (long)new List<long>(new long[]{(long)1L, (long)2L, (long)3L})
    // >>> lst
    // (long)new List<long>()
    // >>> lst
    // (long)new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L})
    public static long SumSquares(List<long> lst) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long SumSquares(List<long> lst)
    {
        for (int i = 0; i < lst.Count; i++)
        {
            if (i % 3 == 0)
            {
                lst[i] = lst[i] * lst[i];
            }
            else if (i % 4 == 0)
            {
                lst[i] = lst[i] * lst[i] * lst[i];
            }
        }
        long sum = 0;
        foreach (long number in lst)
        {
            sum += number;
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)2L, (long)3L}))) == (6L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)4L, (long)9L}))) == (14L));
    Debug.Assert(SumSquares((new List<long>())) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L, (long)1L}))) == (9L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L, (long)-1L}))) == (-3L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)0L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-5L, (long)2L, (long)-1L, (long)-5L}))) == (-126L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-56L, (long)-99L, (long)1L, (long)0L, (long)-2L}))) == (3030L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)-1L}))) == (0L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-16L, (long)-9L, (long)-2L, (long)36L, (long)36L, (long)26L, (long)-20L, (long)25L, (long)-40L, (long)20L, (long)-4L, (long)12L, (long)-26L, (long)35L, (long)37L}))) == (-14196L));
    Debug.Assert(SumSquares((new List<long>(new long[]{(long)-1L, (long)-3L, (long)17L, (long)-1L, (long)-15L, (long)13L, (long)-1L, (long)14L, (long)-14L, (long)-12L, (long)-5L, (long)14L, (long)-14L, (long)6L, (long)13L, (long)11L, (long)16L, (long)16L, (long)4L, (long)10L}))) == (-1448L));
    }

}
"
HumanEval_143,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek 1:     //Yeni dize kelimelerinin sırası orijinal dize ile aynı olmalıdır.    //Uzunlukları asal sayılar olan     //ve orijinal cümlenin kelimelerini içeren bir dizeyi döndürmeniz gerekiyor,     //cümle, boşlukla ayrılmış bazı kelimeler içerir,     //Size bir cümleyi temsil eden bir dize veriliyor.    // >>> WordsInSentence((""This is a test""))
    // (""is"")
    // Example 2:
    // >>> WordsInSentence((""lets go for swimming""))
    // (""go for"")
    // Constraints:
    // * 1 <= len(sentence) <= 100
    // * sentence contains only letters
    public static string WordsInSentence(string sentence) {
","using System;
using System.Collections.Generic;

class Problem {
    public static string WordsInSentence(string sentence) {
        bool IsPrime(int number) {
            if (number <= 1) return false;
            if (number == 2) return true;
            for (int i = 2; i * i <= number; i++) {
                if (number % i == 0) return false;
            }
            return true;
        }

        string[] words = sentence.Split(' ');
        List<string> primeLengthWords = new List<string>();

        foreach (string word in words) {
            if (IsPrime(word.Length)) {
                primeLengthWords.Add(word);
            }
        }

        return string.Join("" "", primeLengthWords);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(WordsInSentence((""This is a test"")).Equals((""is"")));
    Debug.Assert(WordsInSentence((""lets go for swimming"")).Equals((""go for"")));
    Debug.Assert(WordsInSentence((""there is no place available here"")).Equals((""there is no place"")));
    Debug.Assert(WordsInSentence((""Hi I am Hussein"")).Equals((""Hi am Hussein"")));
    Debug.Assert(WordsInSentence((""go for it"")).Equals((""go for it"")));
    Debug.Assert(WordsInSentence((""here"")).Equals(("""")));
    Debug.Assert(WordsInSentence((""here is"")).Equals((""is"")));
    }

}
"
HumanEval_144,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //x ve n'in geçerli kesirler olduğunu ve sıfırın paydaya sahip olmadığını varsayarsınız.    //<sayıcı>/<tanımlayıcı> burada hem sayıcı hem de paydacı pozitif tam sayılardır.     //x ve n, bir kesirin dizilme dizisi ve aşağıdaki biçime sahiptir,     //x * n. Eğer x * n tamsayı değerlendirmesi yapılırsa ve false     //Görevin, ifadeyi basitleştirecek bir fonksiyon uygulamak.    // >>> Simplify((""1/5""), (""5/1""))
    // (true)
    // >>> Simplify((""1/6""), (""2/1""))
    // (false)
    // >>> Simplify((""7/10""), (""10/2""))
    // (false)
    public static bool Simplify(string x, string n) {
","using System;

class Problem {
    public static bool Simplify(string x, string n) {
        var xParts = x.Split('/');
        var nParts = n.Split('/');
        
        int xNumerator = int.Parse(xParts[0]);
        int xDenominator = int.Parse(xParts[1]);
        
        int nNumerator = int.Parse(nParts[0]);
        int nDenominator = int.Parse(nParts[1]);
        
        // Calculate the resulting fraction for x * n
        int resultNumerator = xNumerator * nNumerator;
        int resultDenominator = xDenominator * nDenominator;
        
        // Simplify the fraction by finding the gcd
        int gcd = GCD(resultNumerator, resultDenominator);
        resultNumerator /= gcd;
        resultDenominator /= gcd;
        
        // It is a whole number if the simplified denominator is 1
        return resultDenominator == 1;
    }
    
    private static int GCD(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/6""), (""2/1"")) == (false));
    Debug.Assert(Simplify((""5/1""), (""3/1"")) == (true));
    Debug.Assert(Simplify((""7/10""), (""10/2"")) == (false));
    Debug.Assert(Simplify((""2/10""), (""50/10"")) == (true));
    Debug.Assert(Simplify((""7/2""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""11/6""), (""6/1"")) == (true));
    Debug.Assert(Simplify((""2/3""), (""5/2"")) == (false));
    Debug.Assert(Simplify((""5/2""), (""3/5"")) == (false));
    Debug.Assert(Simplify((""2/4""), (""8/4"")) == (true));
    Debug.Assert(Simplify((""2/4""), (""4/2"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""5/1"")) == (true));
    Debug.Assert(Simplify((""1/5""), (""1/5"")) == (false));
    }

}
"
HumanEval_145,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Onları orijinal listedeki indekslerine göre sıralayın.    //Not: Eğer rakamlarının toplamı benzer olan birkaç madde varsa,     //rakamlarının toplamına göre yükselen sırada.    //Verilen tamsayı listesini sıralayan bir fonksiyon yazın .    // >>> OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L})))
    // (new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))
    // >>> OrderByPoints((new List<long>()))
    // (new List<long>())
    public static List<long> OrderByPoints(List<long> nums) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static List<long> OrderByPoints(List<long> nums)
    {
        return nums.Select((num, index) => new { Number = num, Index = index, DigitSum = SumOfDigits(num) })
                   .OrderBy(item => item.DigitSum)
                   .ThenBy(item => item.Index)
                   .Select(item => item.Number)
                   .ToList();
    }

    private static int SumOfDigits(long number)
    {
        number = Math.Abs(number);
        int sum = 0;
        while (number > 0)
        {
            sum += (int)(number % 10);
            number /= 10;
        }
        return sum;
    }

    static void Main(string[] args)
    {
        var sortedList = OrderByPoints(new List<long> { 1L, 11L, -1L, -11L, -12L });
        Console.WriteLine(string.Join("", "", sortedList));
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)11L, (long)-1L, (long)-11L, (long)-12L}))).Equals((new List<long>(new long[]{(long)-1L, (long)-11L, (long)1L, (long)-12L, (long)11L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1234L, (long)423L, (long)463L, (long)145L, (long)2L, (long)423L, (long)423L, (long)53L, (long)6L, (long)37L, (long)3457L, (long)3L, (long)56L, (long)0L, (long)46L}))).Equals((new List<long>(new long[]{(long)0L, (long)2L, (long)3L, (long)6L, (long)53L, (long)423L, (long)423L, (long)423L, (long)1234L, (long)145L, (long)37L, (long)46L, (long)56L, (long)463L, (long)3457L}))));
    Debug.Assert(OrderByPoints((new List<long>())).Equals((new List<long>())));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)-11L, (long)-32L, (long)43L, (long)54L, (long)-98L, (long)2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)-3L, (long)-32L, (long)-98L, (long)-11L, (long)1L, (long)2L, (long)43L, (long)54L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L, (long)10L, (long)11L}))).Equals((new List<long>(new long[]{(long)1L, (long)10L, (long)2L, (long)11L, (long)3L, (long)4L, (long)5L, (long)6L, (long)7L, (long)8L, (long)9L}))));
    Debug.Assert(OrderByPoints((new List<long>(new long[]{(long)0L, (long)6L, (long)6L, (long)-76L, (long)-21L, (long)23L, (long)4L}))).Equals((new List<long>(new long[]{(long)-76L, (long)-21L, (long)0L, (long)4L, (long)23L, (long)6L, (long)6L}))));
    }

}
"
HumanEval_146,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Bir sayının ilk ve son rakamları tektir (1, 3, 5, 7, 9).    //listede 10 ' dan büyük olan öğelerin sayısı ve her ikisi de     //Bir sayılar listesini girdiler olarak alan ve döndüren bir fonksiyon yazın .    // >>> Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L})))
    // (1L)
    // >>> Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L})))
    // (2L)
    public static long Specialfilter(List<long> nums) {
","public static long Specialfilter(List<long> nums) {
        return nums.Count(num => {
            if (num <= 10) return false;
            long positiveNum = Math.Abs(num);
            string numStr = positiveNum.ToString();
            char firstDigit = numStr[0];
            char lastDigit = numStr[numStr.Length - 1];
            return IsOddDigit(firstDigit) && IsOddDigit(lastDigit);
        });
    }

    private static bool IsOddDigit(char digit) {
        return digit == '1' || digit == '3' || digit == '5' || digit == '7' || digit == '9';
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)5L, (long)-2L, (long)1L, (long)-5L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)15L, (long)-73L, (long)14L, (long)-15L}))) == (1L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)33L, (long)-2L, (long)-3L, (long)45L, (long)21L, (long)109L}))) == (2L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)43L, (long)-12L, (long)93L, (long)125L, (long)121L, (long)109L}))) == (4L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)71L, (long)-2L, (long)-33L, (long)75L, (long)21L, (long)19L}))) == (3L));
    Debug.Assert(Specialfilter((new List<long>(new long[]{(long)1L}))) == (0L));
    Debug.Assert(Specialfilter((new List<long>())) == (0L));
    }

}
"
HumanEval_147,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //ve a[i] + a[j] + a[k] 3'ün katıdır.    //i < j < k,  olan a'nın üçlü sayısını (a[i], a[j], a[k]) döndürür.    //Her i (1 ≤ i ≤ n) için, a[i] = i * i - i + 1 değeridir.     //Size pozitif bir tamsayı veriliyor. Uzunluğu n olan bir tamsayı listesi oluşturmalısınız.    // >>> GetMaxTriples((5L))
    // (1L)
    // Explanation: 
    // a = [1, 3, 7, 13, 21]
    // The only valid triple is (1, 7, 13).
    public static long GetMaxTriples(long n) {
","using System;
using System.Collections.Generic;

class Problem {
    public static long GetMaxTriples(long n) {
        List<long> a = new List<long>();
        for (long i = 1; i <= n; i++) {
            a.Add(i * i - i + 1);
        }

        long count = 0;
        for (int i = 0; i < a.Count; i++) {
            for (int j = i + 1; j < a.Count; j++) {
                for (int k = j + 1; k < a.Count; k++) {
                    if ((a[i] + a[j] + a[k]) % 3 == 0) {
                        count++;
                    }
                }
            }
        }
        
        return count;
    }

    static void Main(string[] args) {
        long n = 5; // Example input
        Console.WriteLine(GetMaxTriples(n)); // Should output 1 based on the example given
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GetMaxTriples((5L)) == (1L));
    Debug.Assert(GetMaxTriples((6L)) == (4L));
    Debug.Assert(GetMaxTriples((10L)) == (36L));
    Debug.Assert(GetMaxTriples((100L)) == (53361L));
    }

}
"
HumanEval_148,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //Bu isimler doğru değil.    //Eğer planet1 veya planet2 ise fonksiyon boş bir tuple döndürmelidir.    //Güneşe yakınlığı.    //Gezegen 1 ve gezegen 2 yörüngeleri arasında yer alan     //Fonksiyon, yörüngeleri     //İki gezegen adı alan bir fonksiyon yazın.    //Uranüs, Neptün.    //Merkur, bir sonraki Venüs, sonra Dünya, Mars, Jüpiter, Satürn,    //Güneş sistemimizde sekiz gezegen var . Güneşe en yakınları .    // >>> Bf((""Jupiter""), (""Neptune""))
    // (new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))
    // >>> Bf((""Earth""), (""Mercury""))
    // (List<string>(""Venus""))
    // >>> Bf((""Mercury""), (""Uranus""))
    // (new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))
    public static List<string> Bf(string planet1, string planet2) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<string> Bf(string planet1, string planet2) {
        List<string> planets = new List<string> { ""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"" };
        int index1 = planets.IndexOf(planet1);
        int index2 = planets.IndexOf(planet2);

        if (index1 == -1 || index2 == -1) {
            return new List<string>();
        }
        
        List<string> result = new List<string>();
        int start = Math.Min(index1, index2);
        int end = Math.Max(index1, index2);

        for (int i = start + 1; i < end; i++) {
            result.Add(planets[i]);
        }

        return result;
    }

    public static void Main() {
        Console.WriteLine(string.Join("", "", Bf(""Jupiter"", ""Neptune""))); // Output: Saturn, Uranus
        Console.WriteLine(string.Join("", "", Bf(""Earth"", ""Mercury"")));   // Output: Venus
        Console.WriteLine(string.Join("", "", Bf(""Mercury"", ""Uranus""))); // Output: Venus, Earth, Mars, Jupiter, Saturn
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Bf((""Jupiter""), (""Neptune"")).Equals((new List<string>(new string[]{(string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Mercury"")).Equals((new List<string>(new string[]{(string)""Venus""}))));
    Debug.Assert(Bf((""Mercury""), (""Uranus"")).Equals((new List<string>(new string[]{(string)""Venus"", (string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn""}))));
    Debug.Assert(Bf((""Neptune""), (""Venus"")).Equals((new List<string>(new string[]{(string)""Earth"", (string)""Mars"", (string)""Jupiter"", (string)""Saturn"", (string)""Uranus""}))));
    Debug.Assert(Bf((""Earth""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Mars""), (""Earth"")).Equals((new List<string>())));
    Debug.Assert(Bf((""Jupiter""), (""Makemake"")).Equals((new List<string>())));
    }

}
"
HumanEval_149,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //Tüm kelimelerin aynı uzunluğa sahip olacağını varsayarsınız.    //Fonksiyon, sıralanmış bir dizi diziyi döndürmelidir.    //İki kelime aynı uzunlukta ise, listeyi alfabetik sıraya koyun.    //Bu kural ile sıralanmış listeyi iade etmeli.    //Listede her kelimenin uzunluğuna göre sıralanmalı ve siz de     //ve kopyaları olabilir.    //Listede her zaman dizinler vardır, asla sayılar yoktur.    //ve sıralanmış bir sırayla sonuçlanan listeyi gönderir,     //Bu sayının tek uzunluklu dizileri silinir.    //Parametrelerden oluşan bir dize listesi kabul eden bir fonksiyon yazın.    // >>> ListSort((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""})))
    // (new List<string>(new string[]{(string)""aa""}))
    // >>> ListSort((new List<string>(new string[]{(string)""ab"", (string)""a"", (string)""aaa"", (string)""cd""})))
    // (new List<string>(new string[]{(string)""ab"", (string)""cd""}))
    public static List<string> SortedListSum(List<string> lst) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem {
    public static List<string> ListSort(List<string> lst) {
        return lst.Where(x => x.Length % 2 == 0)
                  .OrderBy(x => x.Length)
                  .ThenBy(x => x)
                  .ToList();
    }
    
    static void Main() {
        var result1 = ListSort(new List<string> { ""aa"", ""a"", ""aaa"" });
        Console.WriteLine(string.Join("", "", result1)); // Output: aa

        var result2 = ListSort(new List<string> { ""ab"", ""a"", ""aaa"", ""cd"" });
        Console.WriteLine(string.Join("", "", result2)); // Output: ab, cd
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aa"", (string)""a"", (string)""aaa""}))).Equals((new List<string>(new string[]{(string)""aa""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""school"", (string)""AI"", (string)""asdf"", (string)""b""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""asdf"", (string)""school""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""b"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""d"", (string)""dcba"", (string)""abcd"", (string)""a""}))).Equals((new List<string>(new string[]{(string)""abcd"", (string)""dcba""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))).Equals((new List<string>(new string[]{(string)""AI"", (string)""ai"", (string)""au""}))));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""a"", (string)""b"", (string)""b"", (string)""c"", (string)""c"", (string)""a""}))).Equals((new List<string>())));
    Debug.Assert(SortedListSum((new List<string>(new string[]{(string)""aaaa"", (string)""bbbb"", (string)""dd"", (string)""cc""}))).Equals((new List<string>(new string[]{(string)""cc"", (string)""dd"", (string)""aaaa"", (string)""bbbb""}))));
    }

}
"
HumanEval_150,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Bir asal sayı ve y değerini iade etmeli.    //Eğer n  ise x'in değerini döndürmesi gereken basit bir program.    // >>> XOrY((7L), (34L), (12L))
    // (34L)
    // >>> XOrY((15L), (8L), (5L))
    // (5L)
    public static long XOrY(long n, long x, long y) {
","using System;

class Problem {
    public static long XOrY(long n, long x, long y) {
        return IsPrime(n) ? x : y;
    }

    private static bool IsPrime(long number) {
        if (number <= 1) return false;
        if (number <= 3) return true;
        if (number % 2 == 0 || number % 3 == 0) return false;
        
        for (long i = 5; i * i <= number; i += 6) {
            if (number % i == 0 || number % (i + 2) == 0) return false;
        }
        
        return true;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(XOrY((7L), (34L), (12L)) == (34L));
    Debug.Assert(XOrY((15L), (8L), (5L)) == (5L));
    Debug.Assert(XOrY((3L), (33L), (5212L)) == (33L));
    Debug.Assert(XOrY((1259L), (3L), (52L)) == (3L));
    Debug.Assert(XOrY((7919L), (-1L), (12L)) == (-1L));
    Debug.Assert(XOrY((3609L), (1245L), (583L)) == (583L));
    Debug.Assert(XOrY((91L), (56L), (129L)) == (129L));
    Debug.Assert(XOrY((6L), (34L), (1234L)) == (1234L));
    Debug.Assert(XOrY((1L), (2L), (0L)) == (0L));
    Debug.Assert(XOrY((2L), (2L), (0L)) == (2L));
    }

}
"
HumanEval_151,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Listede tek sayılar var. Negatif sayıları veya tam sayıları olmayan sayıları görmezden gelin.    //Bir sayı listesi verildiğinde, sayıların karelerinin toplamını gönderin.    // >>> DoubleTheDifference((new List<float>(new long[]{(long)1L, (long)3L, (long)2L, (long)0L})))
    // (10L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)-1L, (long)-2L, (long)0L})))
    // (0L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)9L, (long)-2L})))
    // (81L)
    // >>> DoubleTheDifference((new List<float>(new long[]{(long)0L})))
    // (0L)
    // If the input list is empty, return 0.
    public static long DoubleTheDifference(List<float> lst) {
","using System;
using System.Collections.Generic;

class Problem {
    // Given a list of numbers, return the sum of squares of the numbers
    // in the list that are odd. Ignore numbers that are negative or not integers.
    public static long DoubleTheDifference(List<float> lst) {
        long sum = 0;
        foreach (var num in lst) {
            if (num >= 0 && num == (long)num && ((long)num % 2) != 0) {
                sum += (long)num * (long)num;
            }
        }
        return sum;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoubleTheDifference((new List<float>())) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)5.0f, (float)4.0f}))) == (25L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.1f, (float)0.2f, (float)0.3f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-10.0f, (float)-20.0f, (float)-30.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-1.0f, (float)-2.0f, (float)8.0f}))) == (0L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)0.2f, (float)3.0f, (float)5.0f}))) == (34L));
    Debug.Assert(DoubleTheDifference((new List<float>(new float[]{(float)-9.0f, (float)-7.0f, (float)-5.0f, (float)-3.0f, (float)-1.0f, (float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f, (float)9.0f}))) == (165L));
    }

}
"
HumanEval_152,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //değeri 0'dur ve eğer değeri 0 değilse tahmin ile puan arasındaki mutlak farkdır.    //Eğer doğru tahmin etmişlerse,     //Size iki puan listesi ve her bir indeksin eşleşen bir eşleşme gösterdiği eşit uzunlukta tahminler veriliyor.    //Görevin, bir kişinin bir dizi maçın sonucunu doğru tahmin edip etmediğini belirlemek.    //Kesinlikle not almaya ve karşılaştırmaya değer.    //O anda sahip olduğunuz duygu ve düşünceler,    //Sanırım hepimiz o duyguyu hatırlıyoruz .    // >>> Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L})))
    // (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))
    // >>> Compare((new List<long>(new long[]{(long)0L, (long)5L, (long)0L, (long)0L, (long)0L, (long)4L})), (new List<long>(new long[]{(long)4L, (long)1L, (long)1L, (long)0L, (long)0L, (long)-2L})))
    // (new List<long>(new long[]{(long)4L, (long)4L, (long)1L, (long)0L, (long)0L, (long)6L}))
    public static List<long> Compare(List<long> game, List<long> guess) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static List<long> Compare(List<long> game, List<long> guess)
    {
        List<long> differences = new List<long>();
        for (int i = 0; i < game.Count; i++)
        {
            differences.Add(Math.Abs(game[i] - guess[i]));
        }
        return differences;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L, (long)1L})), (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)2L, (long)-2L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)3L, (long)3L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L})), (new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))).Equals((new List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L, (long)0L, (long)0L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L})), (new List<long>(new long[]{(long)-1L, (long)-2L, (long)-3L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L}))));
    Debug.Assert(Compare((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)5L})), (new List<long>(new long[]{(long)-1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)0L, (long)0L, (long)1L}))));
    }

}
"
HumanEval_153,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //(gücün -1)     //""Slices.SERVINGSliCes"" i geri döndürün çünkü ""SERVINGSliCes"" en güçlü uzantıdır.    //['SErviNGSliCes', 'Cheese', 'StuFfed'] diye eklersen,     //Örneğin, eğer size sınıf olarak ""Slice"" verilirse ve     //Listede ilk gelenini seç.    //Eğer iki veya daha fazla uzantı aynı güçteyse,    //format: ClassName.StrongestExtensionName.     //En güçlü uzantıyı bulup , bu sayfada bir dize döndürmelisiniz .    //Eklemenin adında, kuvvet CAP - SM kesir ile verilir.     //eklentinin adındaki harfler ve SM küçük harflerin sayısı olsun     //Genişlemenin gücü şöyle: CAP büyük harfin numarası olsun     //Uzantılar, sınıfa ek sınıflar yüklemek için kullanılır.    //Bir sınıfın adı (bir dize) ve bir uzantı listesi verilecektir.    // >>> StrongestExtension((""my_class""), (new List<string>(new string[]{(string)""AA"", (string)""Be"", (string)""CC""})))
    // (""my_class.AA"")
    public static string StrongestExtension(string class_name, List<string> extensions) {
","public static string StrongestExtension(string class_name, List<string> extensions) {
        string strongestExtension = null;
        int maxStrength = int.MinValue;

        foreach (var extension in extensions) {
            int countUpper = extension.Count(char.IsUpper);
            int countLower = extension.Count(char.IsLower);
            int strength = countUpper - countLower;

            if (strength > maxStrength) {
                maxStrength = strength;
                strongestExtension = extension;
            }
        }

        return $""{class_name}.{strongestExtension}"";
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StrongestExtension((""Watashi""), (new List<string>(new string[]{(string)""tEN"", (string)""niNE"", (string)""eIGHt8OKe""}))).Equals((""Watashi.eIGHt8OKe"")));
    Debug.Assert(StrongestExtension((""Boku123""), (new List<string>(new string[]{(string)""nani"", (string)""NazeDa"", (string)""YEs.WeCaNe"", (string)""32145tggg""}))).Equals((""Boku123.YEs.WeCaNe"")));
    Debug.Assert(StrongestExtension((""__YESIMHERE""), (new List<string>(new string[]{(string)""t"", (string)""eMptY"", (string)""nothing"", (string)""zeR00"", (string)""NuLl__"", (string)""123NoooneB321""}))).Equals((""__YESIMHERE.NuLl__"")));
    Debug.Assert(StrongestExtension((""K""), (new List<string>(new string[]{(string)""Ta"", (string)""TAR"", (string)""t234An"", (string)""cosSo""}))).Equals((""K.TAR"")));
    Debug.Assert(StrongestExtension((""__HAHA""), (new List<string>(new string[]{(string)""Tab"", (string)""123"", (string)""781345"", (string)""-_-""}))).Equals((""__HAHA.123"")));
    Debug.Assert(StrongestExtension((""YameRore""), (new List<string>(new string[]{(string)""HhAas"", (string)""okIWILL123"", (string)""WorkOut"", (string)""Fails"", (string)""-_-""}))).Equals((""YameRore.okIWILL123"")));
    Debug.Assert(StrongestExtension((""finNNalLLly""), (new List<string>(new string[]{(string)""Die"", (string)""NowW"", (string)""Wow"", (string)""WoW""}))).Equals((""finNNalLLly.WoW"")));
    Debug.Assert(StrongestExtension((""_""), (new List<string>(new string[]{(string)""Bb"", (string)""91245""}))).Equals((""_.Bb"")));
    Debug.Assert(StrongestExtension((""Sp""), (new List<string>(new string[]{(string)""671235"", (string)""Bb""}))).Equals((""Sp.671235"")));
    }

}
"
HumanEval_154,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Eğer ikinci kelime veya herhangi bir dönüşü ilk kelimede bir alt dize ise doğruyu döndürmeniz gerekir.    // >>> CycpatternCheck((""abcd""), (""abd""))
    // (false)
    // >>> CycpatternCheck((""hello""), (""ell""))
    // (true)
    // >>> CycpatternCheck((""whassup""), (""psus""))
    // (false)
    // >>> CycpatternCheck((""abab""), (""baa""))
    // (true)
    // >>> CycpatternCheck((""efef""), (""eeff""))
    // (false)
    // >>> CycpatternCheck((""himenss""), (""simen""))
    // (true)
    public static bool CycpatternCheck(string a, string b) {
","using System;

class Problem {
    public static bool CycpatternCheck(string a, string b) {
        if (a.Length < b.Length) {
            return false;
        }

        string combinedB = b + b;
        for (int i = 0; i < b.Length; i++) {
            string rotation = combinedB.Substring(i, b.Length);
            if (a.Contains(rotation)) {
                return true;
            }
        }

        return false;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(CycpatternCheck((""xyzw""), (""xyw"")) == (false));
    Debug.Assert(CycpatternCheck((""yello""), (""ell"")) == (true));
    Debug.Assert(CycpatternCheck((""whattup""), (""ptut"")) == (false));
    Debug.Assert(CycpatternCheck((""efef""), (""fee"")) == (true));
    Debug.Assert(CycpatternCheck((""abab""), (""aabb"")) == (false));
    Debug.Assert(CycpatternCheck((""winemtt""), (""tinem"")) == (true));
    }

}
"
HumanEval_155,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Bir tamsayı verildiğinde, sırasıyla çift ve tek basamaklı bir tuple döndürür.     // >>> EvenOddCount((-12L))
    // (Tuple.Create(1L, 1L))
    // >>> EvenOddCount((123L))
    // (Tuple.Create(1L, 2L))
    public static Tuple<long, long> EvenOddCount(long num) {
","using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

class Problem {
    public static Tuple<long, long> EvenOddCount(long num) {
        // Convert the number to positive to handle negative numbers
        num = Math.Abs(num);
        long evenCount = 0;
        long oddCount = 0;
        
        while (num > 0) {
            long digit = num % 10;
            if (digit % 2 == 0)
                evenCount++;
            else
                oddCount++;
            num /= 10;
        }
        
        return Tuple.Create(evenCount, oddCount);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(EvenOddCount((7L)).Equals((Tuple.Create(0L, 1L))));
    Debug.Assert(EvenOddCount((-78L)).Equals((Tuple.Create(1L, 1L))));
    Debug.Assert(EvenOddCount((3452L)).Equals((Tuple.Create(2L, 2L))));
    Debug.Assert(EvenOddCount((346211L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-345821L)).Equals((Tuple.Create(3L, 3L))));
    Debug.Assert(EvenOddCount((-2L)).Equals((Tuple.Create(1L, 0L))));
    Debug.Assert(EvenOddCount((-45347L)).Equals((Tuple.Create(2L, 3L))));
    Debug.Assert(EvenOddCount((0L)).Equals((Tuple.Create(1L, 0L))));
    }

}
"
HumanEval_156,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler:     //Kısıtlamalar: 1 <= num <= 1000     //ve küçük harflerle geri gönder.    //Pozitif bir tamsayı verildiğinde, onun romalı sayılardaki eşdeğerini bir dize olarak elde edin,     // >>> IntToMiniRoman((19L))
    // (""xix"")
    // >>> IntToMiniRoman((152L))
    // (""clii"")
    // >>> IntToMiniRoman((426L))
    // (""cdxxvi"")
    public static string IntToMiniRoman(long number) {
","if (number < 1 || number > 1000)
            throw new ArgumentOutOfRangeException(""number"", ""Input must be between 1 and 1000"");

        // Mapping of Roman numerals
        var romanNumerals = new List<(int value, string numeral)>
        {
            (1000, ""m""), (900, ""cm""), (500, ""d""), (400, ""cd""),
            (100, ""c""), (90, ""xc""), (50, ""l""), (40, ""xl""),
            (10, ""x""), (9, ""ix""), (5, ""v""), (4, ""iv""),
            (1, ""i"")
        };

        var sb = new StringBuilder();

        foreach (var (value, numeral) in romanNumerals)
        {
            while (number >= value)
            {
                sb.Append(numeral);
                number -= value;
            }
        }

        return sb.ToString();
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(IntToMiniRoman((19L)).Equals((""xix"")));
    Debug.Assert(IntToMiniRoman((152L)).Equals((""clii"")));
    Debug.Assert(IntToMiniRoman((251L)).Equals((""ccli"")));
    Debug.Assert(IntToMiniRoman((426L)).Equals((""cdxxvi"")));
    Debug.Assert(IntToMiniRoman((500L)).Equals((""d"")));
    Debug.Assert(IntToMiniRoman((1L)).Equals((""i"")));
    Debug.Assert(IntToMiniRoman((4L)).Equals((""iv"")));
    Debug.Assert(IntToMiniRoman((43L)).Equals((""xliii"")));
    Debug.Assert(IntToMiniRoman((90L)).Equals((""xc"")));
    Debug.Assert(IntToMiniRoman((94L)).Equals((""xciv"")));
    Debug.Assert(IntToMiniRoman((532L)).Equals((""dxxxii"")));
    Debug.Assert(IntToMiniRoman((900L)).Equals((""cm"")));
    Debug.Assert(IntToMiniRoman((994L)).Equals((""cmxciv"")));
    Debug.Assert(IntToMiniRoman((1000L)).Equals((""m"")));
    }

}
"
HumanEval_157,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //90 derece.    //Dikdörtgen üçgen , bir açısının dik açı olduğu üçgen veya     //Yanları dikdörtgen üçgen oluşturuyor, aksi takdirde yanlış.    //Üçgenin üç kenarının uzunlukları verilmişse, üç     // >>> RightAngleTriangle((3L), (4L), (5L))
    // (true)
    // >>> RightAngleTriangle((1L), (2L), (3L))
    // (false)
    public static bool RightAngleTriangle(long a, long b, long c) {
","using System;

class Problem
{
    public static bool RightAngleTriangle(long a, long b, long c)
    {
        // Sort the sides to make it easier to apply the Pythagorean theorem.
        long[] sides = { a, b, c };
        Array.Sort(sides);

        // Check if the sum of the squares of the smaller two sides equals the square of the largest side.
        return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(RightAngleTriangle((3L), (4L), (5L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (2L), (3L)) == (false));
    Debug.Assert(RightAngleTriangle((10L), (6L), (8L)) == (true));
    Debug.Assert(RightAngleTriangle((2L), (2L), (2L)) == (false));
    Debug.Assert(RightAngleTriangle((7L), (24L), (25L)) == (true));
    Debug.Assert(RightAngleTriangle((10L), (5L), (7L)) == (false));
    Debug.Assert(RightAngleTriangle((5L), (12L), (13L)) == (true));
    Debug.Assert(RightAngleTriangle((15L), (8L), (17L)) == (true));
    Debug.Assert(RightAngleTriangle((48L), (55L), (73L)) == (true));
    Debug.Assert(RightAngleTriangle((1L), (1L), (1L)) == (false));
    Debug.Assert(RightAngleTriangle((2L), (2L), (10L)) == (false));
    }

}
"
HumanEval_158,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //karakterler, sözlükler sırasıyla ilk gelen karakterleri gönderir.     //Eğer birden fazla dize en fazla sayıda benzersiz karakter varsa     //Listede farklı kelimeler var. En fazla sayı olan kelimeyi döndürün.    //Bir dize listesi kabul eden bir fonksiyon yazın.    // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""})))
    // (""string"")
    // >>> FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""})))
    // (""enam"")
    // >>> FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""})))
    // (""aaaaaaa"")
    public static string FindMax(List<string> words) {
","using System;
using System.Collections.Generic;
using System.Linq;

class Problem
{
    public static string FindMax(List<string> words)
    {
        string result = string.Empty;
        int maxUniqueChars = 0;

        foreach (var word in words)
        {
            var uniqueChars = word.ToCharArray().Distinct().Count();

            if (uniqueChars > maxUniqueChars || (uniqueChars == maxUniqueChars && string.Compare(word, result, StringComparison.Ordinal) < 0))
            {
                maxUniqueChars = uniqueChars;
                result = word;
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""of"", (string)""string""}))).Equals((""string"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""name"", (string)""enam"", (string)""game""}))).Equals((""enam"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""aaaaaaa"", (string)""bb"", (string)""cc""}))).Equals((""aaaaaaa"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""abc"", (string)""cba""}))).Equals((""abc"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""this"", (string)""game"", (string)""of"", (string)""footbott""}))).Equals((""footbott"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""gonna"", (string)""rock""}))).Equals((""gonna"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""we"", (string)""are"", (string)""a"", (string)""mad"", (string)""nation""}))).Equals((""nation"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""this"", (string)""is"", (string)""a"", (string)""prrk""}))).Equals((""this"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""b""}))).Equals((""b"")));
    Debug.Assert(FindMax((new List<string>(new string[]{(string)""play"", (string)""play"", (string)""play""}))).Equals((""play"")));
    }

}
"
HumanEval_159,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnek:    //Eğer yeterli havuç kalmadıysa, kalan havuçları yiyeceksin ama yine de aç kalacaksın.    //Yemekten sonra kalan havuç sayısını ]     //[yemeklerden sonra yediğiniz havuçların toplam sayısı,     //Ama artık günün yemeklerini tamamlamak için daha fazla havuç yemeniz gerekiyor.    //Aç bir tavşansın ve çoktan bir miktar havuç yedin.    // >>> Eat((5L), (6L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)4L}))
    // >>> Eat((4L), (8L), (9L))
    // (new List<long>(new long[]{(long)12L, (long)1L}))
    // >>> Eat((1L), (10L), (10L))
    // (new List<long>(new long[]{(long)11L, (long)0L}))
    // >>> Eat((2L), (11L), (5L))
    // (new List<long>(new long[]{(long)7L, (long)0L}))
    // Variables:
    // @number : integer
    // the number of carrots that you have eaten.
    // @need : integer
    // the number of carrots that you need to eat.
    // @remaining : integer
    // the number of remaining carrots thet exist in stock
    // Constrain:
    // * 0 <= number <= 1000
    // * 0 <= need <= 1000
    // * 0 <= remaining <= 1000
    // Have fun :)
    public static List<long> Eat(long number, long need, long remaining) {
","using System;
using System.Collections.Generic;

class Problem {
    public static List<long> Eat(long number, long need, long remaining) {
        long totalEaten = number;
        long leftAfterMeals;

        if(remaining >= need) {
            totalEaten += need;
            leftAfterMeals = remaining - need;
        } else {
            totalEaten += remaining;
            leftAfterMeals = 0;
        }
        
        return new List<long>{ totalEaten, leftAfterMeals };
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Eat((5L), (6L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)4L}))));
    Debug.Assert(Eat((4L), (8L), (9L)).Equals((new List<long>(new long[]{(long)12L, (long)1L}))));
    Debug.Assert(Eat((1L), (10L), (10L)).Equals((new List<long>(new long[]{(long)11L, (long)0L}))));
    Debug.Assert(Eat((2L), (11L), (5L)).Equals((new List<long>(new long[]{(long)7L, (long)0L}))));
    Debug.Assert(Eat((4L), (5L), (7L)).Equals((new List<long>(new long[]{(long)9L, (long)2L}))));
    Debug.Assert(Eat((4L), (5L), (1L)).Equals((new List<long>(new long[]{(long)5L, (long)0L}))));
    }

}
"
HumanEval_160,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Operatör listesi en az bir operatör, operand listesi en az iki operand içerir.    //Operand, negatif olmayan tam sayılar listesidir.    //Operatör listesinin uzunluğu, operand listesinin uzunluğunun eksi bir'ine eşittir.    //Not:    //=> Sonuç = 9     //Sonuç = 2 + 3 * 4 - 5     //list = [2, 3, 4, 5]     //operatör['+', '*', '-']     //Örnek:    //Eksponanslandırma (**)     //Kat bölümü ( //)     //Çarpım (*)     //Kaldırma ( - )     //Toplama (+)     //Temel cebir işlemleri:    //ifadeyi ve bu ifadeyi değerlendirmesini döndürür.    //İkinci liste tam sayılar listesidir.    //İlk listede temel cebir işlemleri ve  vardır.    public static long DoAlgebra(List<string> op, List<long> operand) {
","using System;
using System.Collections.Generic;

class Problem
{
    public static long DoAlgebra(List<string> op, List<long> operand)
    {
        if (op.Count + 1 != operand.Count || operand.Count < 2)
        {
            throw new ArgumentException(""Invalid input lists."");
        }

        long result = operand[0];

        for (int i = 0; i < op.Count; i++)
        {
            string currentOp = op[i];
            long currentOperand = operand[i + 1];

            switch (currentOp)
            {
                case ""+"":
                    result += currentOperand;
                    break;
                case ""-"":
                    result -= currentOperand;
                    break;
                case ""*"":
                    result *= currentOperand;
                    break;
                case ""//"":
                    result /= currentOperand;
                    break;
                case ""**"":
                    result = (long)Math.Pow(result, currentOperand);
                    break;
                default:
                    throw new InvalidOperationException($""Unsupported operator: {currentOp}"");
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""**"", (string)""*"", (string)""+""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (37L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""+"", (string)""*"", (string)""-""})), (new List<long>(new long[]{(long)2L, (long)3L, (long)4L, (long)5L}))) == (9L));
    Debug.Assert(DoAlgebra((new List<string>(new string[]{(string)""//"", (string)""*""})), (new List<long>(new long[]{(long)7L, (long)3L, (long)4L}))) == (8L));
    }

}
"
HumanEval_161,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örnekler     //Fonksiyon, sonuçta elde edilen dizeyi döndürmelidir.    //Eğer dize hiç harf içermiyorsa, dizeyi ters çevirin.    //Aksi takdirde, olduğu gibi kalsın.    //Eğer s[i] bir harfse, aşağıdan yukarıya veya tam tersi,     //Size bir dize veriliyor.    // >>> Solve((""1234""))
    // (""4321"")
    // >>> Solve((""ab""))
    // (""AB"")
    // >>> Solve((""#a@C""))
    // (""#A@c"")
    public static string Solve(string s) {
","public static string Solve(string s) {
        bool hasLetter = s.Any(char.IsLetter);
        if (hasLetter) {
            var result = new StringBuilder(s.Length);
            foreach (char c in s) {
                if (char.IsLetter(c)) {
                    result.Append(char.IsUpper(c) ? char.ToLower(c) : char.ToUpper(c));
                } else {
                    result.Append(c);
                }
            }
            return result.ToString();
        } else {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(Solve((""AsDf"")).Equals((""aSdF"")));
    Debug.Assert(Solve((""1234"")).Equals((""4321"")));
    Debug.Assert(Solve((""ab"")).Equals((""AB"")));
    Debug.Assert(Solve((""#a@C"")).Equals((""#A@c"")));
    Debug.Assert(Solve((""#AsdfW^45"")).Equals((""#aSDFw^45"")));
    Debug.Assert(Solve((""#6@2"")).Equals((""2@6#"")));
    Debug.Assert(Solve((""#$a^D"")).Equals((""#$A^d"")));
    Debug.Assert(Solve((""#ccc"")).Equals((""#CCC"")));
    }

}
"
HumanEval_162,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Eğer 'text' boş bir dize ise, null döndür.     //Bir dize 'matsal' verildiğinde, onun md5 hash eşdeğeri dizesini döndürün.     // >>> StringToMd5((""Hello world""))
    // (""3e25960a79dbc69b674cd4ec67a72c62"")
    public static string StringToMd5(string text) {
","using System;
using System.Security.Cryptography;
using System.Text;

class Problem {
    public static string StringToMd5(string text) {
        if (string.IsNullOrEmpty(text)) {
            return null;
        }
        
        using (MD5 md5 = MD5.Create()) {
            byte[] inputBytes = Encoding.UTF8.GetBytes(text);
            byte[] hashBytes = md5.ComputeHash(inputBytes);
            
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < hashBytes.Length; i++) {
                sb.Append(hashBytes[i].ToString(""x2""));
            }
            return sb.ToString();
        }
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(StringToMd5((""Hello world"")).Equals((""3e25960a79dbc69b674cd4ec67a72c62"")));
    Debug.Assert(StringToMd5(("""")).Equals(null));
    Debug.Assert(StringToMd5((""A B C"")).Equals((""0ef78513b0cb8cef12743f5aeb35f888"")));
    Debug.Assert(StringToMd5((""password"")).Equals((""5f4dcc3b5aa765d61d8327deb882cf99"")));
    }

}
"
HumanEval_163,tur_Latn,cs,"using System;
using System.Numerics;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
class Problem {
    //Örneğin:     //ve b, yükselen sırada.    //İki pozitif tam sayı a ve b verildiğinde, a  arasındaki çift basamakları gönder.    // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    public static List<long> GenerateIntegers(long a, long b) {
","using System;
using System.Collections.Generic;

class Problem
{
    // Given two positive integers a and b, return the even digits between a
    // and b, in ascending order.
    // For example:
    // >>> GenerateIntegers((2L), (8L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((8L), (2L))
    // (new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))
    // >>> GenerateIntegers((10L), (14L))
    // (new List<long>())
    
    public static List<long> GenerateIntegers(long a, long b)
    {
        List<long> evenDigits = new List<long> { 2, 4, 6, 8 };
        List<long> result = new List<long>();

        if (a > b)
        {
            // Swap values if a is greater than b to ensure ascending order
            long temp = a;
            a = b;
            b = temp;
        }

        foreach (var even in evenDigits)
        {
            if (even >= a && even <= b)
            {
                result.Add(even);
            }
        }

        return result;
    }
}","    }
    public static void Main(string[] args) {
    Debug.Assert(GenerateIntegers((2L), (10L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((10L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((132L), (2L)).Equals((new List<long>(new long[]{(long)2L, (long)4L, (long)6L, (long)8L}))));
    Debug.Assert(GenerateIntegers((17L), (89L)).Equals((new List<long>())));
    }

}
"
