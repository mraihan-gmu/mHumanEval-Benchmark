[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ellen\u0151rizze, hogy az adott sz\u00e1mlista b\u00e1rmely k\u00e9t sz\u00e1m\u00e1t k\u00f6zelebb \u00e1ll-e egym\u00e1shoz, mint az adott k\u00fcsz\u00f6b\u00e9rt\u00e9k.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" A bevitel a foncti\u00f3hoz egy h\u00far, amely t\u00f6bb csoportot tartalmaz f\u00e9szkel\u0151 z\u00e1r\u00f3jelb\u0151l. A c\u00e9l az, hogy elv\u00e1lassza azokat a csoportokat k\u00fcl\u00f6n h\u00farokba, \u00e9s visszaadja azok list\u00e1j\u00e1t. A k\u00fcl\u00f6n csoportok kiegyens\u00falyozottak (minden nyitott z\u00e1r\u00f3jel megfelel\u0151en z\u00e1rva van), \u00e9s nem f\u00e9szkel\u0151dnek egym\u00e1sba.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Ha egy pozit\u00edv lebeg\u0151pontos sz\u00e1mot kapunk, akkor az oszthat\u00f3 el eg\u00e9sz sz\u00e1mra (a legnagyobb eg\u00e9sz sz\u00e1m kisebb, mint az adott sz\u00e1m) \u00e9s tizedesre (a marad\u00e9k mindig kisebb, mint 1).\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" A bankban a sz\u00e1mla egyenleg\u00e9nek null\u00e1val kezd\u0151d\u0151 bet\u00e9ti \u00e9s kivon\u00e1si m\u0171veleteinek list\u00e1ja jelenik meg. A feladatunk az, hogy \u00e9szlelj\u00fck, ha a sz\u00e1mla egyenlege valamikor null\u00e1n\u00e1l alacsonyabb, \u00e9s akkor a f\u00fcggv\u00e9nynek igaznak kell adnia. Ellenkez\u0151 esetben hamisnak kell adnia. P\u00e9ld\u00e1ul:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Egy adott beviteli sz\u00e1mok list\u00e1j\u00e1hoz sz\u00e1m\u00edtsuk ki az \u00e1tlagos abszol\u00fat elt\u00e9r\u00e9s m\u00e9rt\u00e9ket az adatk\u00e9szlet \u00e1tlag\u00e1val. Az \u00e1tlagos abszol\u00fat elt\u00e9r\u00e9s az egyes elemek \u00e9s a k\u00f6z\u00e9ppont (k\u00f6z\u00e9ps\u00e9g ebben az esetben) k\u00f6z\u00f6tti \u00e1tlagos abszol\u00fat k\u00fcl\u00f6nbs\u00e9g: MAD = \u00e1tlag. x - x_k\u00f6z\u00e9ps\u00e9g. P\u00e9ld\u00e1ul:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" A bevezet\u0151 list\u00e1n minden k\u00e9t egym\u00e1st k\u00f6vet\u0151 elem k\u00f6z\u00f6tt `sz\u00e1mok'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" A f\u00fcggv\u00e9ny bevitele egy sztring, amely t\u00f6bb csoportot k\u00e9pvisel a f\u00e9szkel\u0151 z\u00e1r\u00f3jel\u00f6k sz\u00e1m\u00e1ra, szelv\u00e9nyekkel elv\u00e1lasztva. A csoport mindegyike sz\u00e1m\u00e1ra adja ki a z\u00e1r\u00f3jelek legm\u00e9lyebb f\u00e9szkel\u00e9si szintj\u00e9t. P\u00e9ld\u00e1ul (() (()) a f\u00e9szkel\u00e9s maximum k\u00e9t szintj\u00e9t tartalmazza, m\u00edg ((())) h\u00e1rom.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Csak az adott all\u00e1ncot tartalmaz\u00f3 sorok beviteli list\u00e1j\u00e1t sz\u0171ri\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Egy adott eg\u00e9sz sz\u00e1ml\u00e1k list\u00e1j\u00e1hoz adja vissza a list\u00e1ban szerepl\u0151 \u00f6sszes eg\u00e9sz sz\u00e1m \u00f6sszeg\u00e9b\u0151l \u00e9s szorzat\u00e1b\u00f3l \u00e1ll\u00f3 tupl\u00e1t. Az \u00fcres \u00f6sszegnek 0-val \u00e9s az \u00fcres szorzatnak 1-tel kell egyenl\u0151nek lennie.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Egy adott eg\u00e9sz sz\u00e1mlist\u00e1b\u00f3l a sorozat adott pillanat\u00e1ig megtal\u00e1lhat\u00f3 legnagyobb g\u00f6rd\u00fcl\u0151 elem list\u00e1j\u00e1t \u00e1ll\u00edtja el\u0151.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Megvizsg\u00e1l\u00e1sa, hogy az adott karakterl\u00e1nc palindr\u00f3m-e \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" A bemen\u0151 k\u00e9t a \u00e9s b sor, amely csak 1 \u00e9s 0-b\u00f3l \u00e1ll. E bemen\u0151kkel bin\u00e1ris XOR-t v\u00e9gez, \u00e9s a eredm\u00e9nyt egy sork\u00e9nt adja vissza.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" A list\u00e1b\u00f3l a leghosszabbat adja vissza. Az els\u0151t adja vissza, ha t\u00f6bb, azonos hossz\u00fas\u00e1g\u00fa string van. A null\u00e1t adja vissza, ha a bemeneti lista \u00fcres.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Adja vissza a legnagyobb k\u00f6z\u00f6s oszt\u00f3 k\u00e9t eg\u00e9sz sz\u00e1m a \u00e9s b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" A bevitel sor\u00e1nak a legr\u00f6videbbt\u0151l a leghosszabbig terjed\u0151 \u00f6sszes el\u0151tagj\u00e1nak list\u00e1ja\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" A null\u00e1t\u00f3l n-ig terjed\u0151, t\u00e9rrel hat\u00e1rolt sz\u00e1mokat tartalmaz\u00f3 karakterl\u00e1ncot adja vissza.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Ha egy karakterl\u00e1ncot kapunk, akkor tal\u00e1ljuk ki, hogy h\u00e1ny k\u00fcl\u00f6nb\u00f6z\u0151 karakterb\u0151l \u00e1ll (a nagybet\u0171t\u0151l f\u00fcggetlen\u00fcl).\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" A funkci\u00f3ba egy speci\u00e1lis ASCII form\u00e1tumban l\u00e9v\u0151 zen\u00e9s hangjegyeket \u00e1br\u00e1zol\u00f3 h\u00far ker\u00fcl. A feladatunk az, hogy elemezz\u00fck ezt a h\u00farot \u00e9s visszat\u00e9r\u00edts\u00fck a teljes sz\u00e1mok list\u00e1j\u00e1t, amelyek megfelelnek annak, hogy h\u00e1ny \u00fct\u00e9s nem tart minden egyes. Itt van egy legenda: \"o\" - eg\u00e9sz hangjegy, n\u00e9gy \u00fct\u00e9s tart \"o\" - f\u00e9l hangjegy, k\u00e9t \u00fct\u00e9s tart \"o\" - n\u00e9gyes hangjegy, egy \u00fct\u00e9s tart\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Sz\u00e1molja meg, h\u00e1nyszor tal\u00e1lhat\u00f3 meg egy adott all\u00e1nc az eredeti l\u00e1ncban. Sz\u00e1molja meg az \u00e1tfed\u0151 eseteket.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" A bevitel egy t\u00e9rrel hat\u00e1rolt sz\u00e1ml\u00e1nc, amely a \"null\u00f3l\" a \"kilencig\" terjed. Az \u00e9rv\u00e9nyes v\u00e1laszt\u00e1sok a \"null\u00f3\", \"egy\", \"k\u00e9t\", \"h\u00e1rom\", \"n\u00e9gy\", \"\u00f6t\", \"hat\", \"h\u00e9t\", \"nyolc\" \u00e9s \"kilenc\". A sz\u00e1ml\u00e1ncot a legkisebbt\u0151l a legnagyobbig rendezve adja vissza.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" A megadott sz\u00e1mok list\u00e1j\u00e1b\u00f3l (amely legal\u00e1bb k\u00e9t sz\u00e1m) v\u00e1lasszon ki \u00e9s adja vissza a k\u00e9t sz\u00e1mot, amelyek a legk\u00f6zelebb \u00e1llnak egym\u00e1shoz, \u00e9s adja vissza azokat sorrendben (kisebb sz\u00e1m, nagyobb sz\u00e1m).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" A sz\u00e1mok list\u00e1j\u00e1t (legal\u00e1bb k\u00e9t elemb\u0151l) line\u00e1ris \u00e1talak\u00edt\u00e1ssal kell alkalmazni, hogy a legkisebb sz\u00e1m 0 legyen, a legnagyobb pedig 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" A Python-\u00e9rt\u00e9kek list\u00e1j\u00e1t csak eg\u00e9sz sz\u00e1mokhoz sz\u0171r\u00edthetj\u00fck\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" A megadott sztring visszaad\u00f3 hossza\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Egy adott n sz\u00e1mn\u00e1l, tal\u00e1ljuk meg a legnagyobb sz\u00e1mot, ami egyenletesen osztja n-t, kisebb, mint n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" A megadott eg\u00e9sz sz\u00e1m els\u0151dleges t\u00e9nyez\u0151inek list\u00e1j\u00e1t adja vissza a legkisebbt\u0151l a legnagyobbig sorrendben. A t\u00e9nyez\u0151k mindegyik\u00e9nek meg kell szerepelnie a szorzatban megjelen\u0151 sz\u00e1mnak megfelel\u0151 sz\u00e1m\u00fa alkalommal. A bemeneti sz\u00e1mnak meg kell lennie az \u00f6sszes t\u00e9nyez\u0151 szorzat\u00e1nak.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" A teljes sz\u00e1mok list\u00e1j\u00e1b\u00f3l t\u00e1vol\u00edtsuk el az egyn\u00e9l t\u00f6bbsz\u00f6r el\u0151fordul\u00f3 elemeket. Az elemek sorrendj\u00e9t a bevitelben megtartva hagyjuk.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Egy adott karakterl\u00e1nc eset\u00e9ben a kisbet\u0171ket nagybet\u0171re, a nagybet\u0171ket pedig kisbet\u0171re kell ford\u00edtani.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" A karakterl\u00e1ncok list\u00e1j\u00e1t egyetlen karakterl\u00e1ncba kell \u00f6sszefogni\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" A bevezet\u0151 sorok list\u00e1j\u00e1t csak azokra sz\u0171r\u00edzz\u00fck, amelyek egy adott el\u0151taggal kezd\u0151dnek.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Csak a pozit\u00edv sz\u00e1mokat adja vissza a list\u00e1b\u00f3l.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Ha egy adott sz\u00e1m pr\u00edm, akkor az \u00e9rt\u00e9ke true, m\u00e1sk\u00fcl\u00f6nben false.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u00c9rt\u00e9kel egy polinomiumot xs egy\u00fctthat\u00f3val x pontban. xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Ez a f\u00fcggv\u00e9ny vesz egy l-es list\u00e1t \u00e9s olyan l'-es list\u00e1t ad vissza, hogy az l' azonos legyen az l-el a h\u00e1romra nem oszthat\u00f3 indexekben, m\u00edg az \u00e9rt\u00e9kei az l-nek a h\u00e1romra oszthat\u00f3 indexekn\u00e9l megegyeznek az l megfelel\u0151 indexek \u00e9rt\u00e9keivel, de rendezettek.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Soros\u00edtott egyedi elemek list\u00e1ban\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"A list\u00e1ban tal\u00e1lhat\u00f3 legnagyobb elemet adja vissza.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Adja meg a 7 sz\u00e1mjegy n-n\u00e9l kisebb eg\u00e9sz sz\u00e1mokban val\u00f3 megjelen\u00e9s\u00e9nek sz\u00e1m\u00e1t, amelyek 11 vagy 13 sz\u00e1jjal oszthat\u00f3k.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Ez a f\u00fcggv\u00e9ny vesz egy l-es list\u00e1t \u00e9s olyan l'-es list\u00e1t ad vissza, hogy l' azonos legyen l-el a p\u00e1ratlan indexekben, m\u00edg az \u00e9rt\u00e9kei a p\u00e1ros indexekben megegyeznek az l p\u00e1ros index\u00e9nek \u00e9rt\u00e9keivel, de rendezve.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    h\u00e1rom karakterb\u0151l \u00e1ll\u00f3 ciklusos csoportok \u00e1ltal k\u00f3dolt karakterl\u00e1ncot ad vissza.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib visszaadja az n-edik sz\u00e1mot, ami egy Fibonacci sz\u00e1m \u00e9s egyben pr\u00edm is.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    A triples_sum_to_zero egy eg\u00e9sz sz\u00e1mok list\u00e1j\u00e1t veszi be. Ha h\u00e1rom k\u00fcl\u00f6nb\u00f6z\u0151 elem van a list\u00e1ban, amelyek \u00f6sszege nulla, akkor az \u00e9rt\u00e9ke True, m\u00e1sk\u00fcl\u00f6nben False.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    K\u00e9pzelj\u00fcnk el egy olyan utat, amely egy t\u00f6k\u00e9letesen egyenes v\u00e9gtelen hossz\u00fa vonal. n aut\u00f3 vezet balr\u00f3l jobbra; egyidej\u0171leg, n m\u00e1sik aut\u00f3 vezet jobbr\u00f3l balra. A k\u00e9t aut\u00f3csoport nagyon messze kezd\u0151dik egym\u00e1st\u00f3l. Minden aut\u00f3 ugyanabban a sebess\u00e9gben mozog. K\u00e9t aut\u00f3 \u00fctk\u00f6zik, amikor egy balr\u00f3l jobbra halad\u00f3 aut\u00f3 \u00fctk\u00f6zik egy jobbr\u00f3l balra halad\u00f3 aut\u00f3val. Azonban az aut\u00f3k v\u00e9gtelen\u00fcl er\u0151sek \u00e9s er\u0151sek; ennek eredm\u00e9nyek\u00e9nt tov\u00e1bbra is a p\u00e1ly\u00e1jukon mozognak, mintha nem \u00fctk\u00f6zn\u00e9nek. Ez a f\u00fcggv\u00e9ny az ilyen \u00fctk\u00f6z\u00e9sek sz\u00e1m\u00e1t adja ki.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Visszat\u00e9r\u0151 lista, 1 -vel megn\u00f6velt elemekkel.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    A pairs_sum_to_zero egy eg\u00e9sz sz\u00e1mok list\u00e1j\u00e1t veszi be. Ha k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 elem van a list\u00e1ban, amelyek \u00f6sszege nulla, akkor az \u00e9rt\u00e9ke True, m\u00e1sk\u00fcl\u00f6nben False.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"A bevezet\u0151 x sz\u00e1m sz\u00e1mszer\u0171 alapj\u00e1t alapra v\u00e1ltoztatja. A konverzi\u00f3 ut\u00e1n adja vissza a sztring reprezent\u00e1ci\u00f3j\u00e1t. Az alapsz\u00e1mok kevesebbek, mint 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Egy h\u00e1romsz\u00f6g oldal\u00e1nak hossz\u00e1t \u00e9s a magas visszat\u00e9r\u00e9si ter\u00fcletet.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"A Fib4 sz\u00e1msorozat a Fibbonacci-sorozathoz hasonl\u00f3 sorozat, amelyet a k\u00f6vetkez\u0151k\u00e9ppen defini\u00e1lnak: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). K\u00e9rj\u00fck, \u00edrjon egy olyan f\u00fcggv\u00e9nyt, amely hat\u00e9konyan kisz\u00e1m\u00edtja a fib4 sz\u00e1msorozat n-ik elem\u00e9t.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Az l list\u00e1ban szerepl\u0151 elemek visszaadott medi\u00e1nja.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Ellen\u0151riz, hogy az adott karakterl\u00e1nc palindr\u00f3m-e\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Adja vissza a 2^n modulo p-t (figyeljen a sz\u00e1mokra).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    k\u00f3dolt sztringet ad vissza az \u00e1b\u00e9c\u00e9 minden karakter\u00e9nek 5 - es elmozd\u00edt\u00e1s\u00e1val.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels egy olyan f\u00fcggv\u00e9ny, amely vonalokat vesz \u00e9s vonalokat visszavon vok\u00e1lok n\u00e9lk\u00fcl.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Ha az l-es list\u00e1ban minden sz\u00e1m a t \u00e9rt\u00e9khat\u00e1r alatt van, akkor az \u00e9rt\u00e9ktartalmat True-t adja vissza.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u00d6sszeadunk k\u00e9t sz\u00e1mot, x \u00e9s y.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Ellen\u0151rizze, hogy k\u00e9t sz\u00f3 azonos karakterekkel rendelkezik-e.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Adja vissza az n-edik Fibonacci-sz\u00e1mot.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" a \"<\" \u00e9s \">\" sorokb\u00f3l \u00e1ll\u00f3 string. az \"<\" \u00e9s \">\" sorokb\u00f3l \u00e1ll\u00f3 string. return True, ha minden nyit\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Az igaz visszaad\u00e1sa az, ha a lista elemei monoton m\u00f3don n\u00f6vekednek vagy cs\u00f6kkennek.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"K\u00e9t lista rendezett egyedi k\u00f6z\u00f6s elemeit adja vissza.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Adja vissza a legnagyobb pr\u00edmszorz\u00f3t az n-b\u0151l. Tegy\u00fck fel, hogy n > 1 \u00e9s nem pr\u00edmsz\u00e1m.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"A sum_to_n egy olyan f\u00fcggv\u00e9ny, amely 1 \u00e9s n k\u00f6z\u00f6tti sz\u00e1mokat sz\u00e1mol \u00f6ssze.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" a brackets egy \"(\" \u00e9s \"\") sor. az True-t adja vissza, ha minden nyit\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3 z\u00e1r\u00f3val rendelkezik.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs egy t\u00f6bbn\u00e9v egy\u00fctthat\u00f3it jel\u00f6li. xs[0] + xs[1] * x + xs[2] * x^2 +.... A t\u00f6bbn\u00e9v sz\u00e1rmaz\u00e9k\u00e1t ugyanabban a form\u00e1ban adja vissza.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"A FibFib sz\u00e1msorozat a Fibbonacci-sorozathoz hasonl\u00f3 sorozat, amelyet a k\u00f6vetkez\u0151k\u00e9ppen defini\u00e1lnak: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). K\u00e9rj\u00fck, \u00edrjon egy funkci\u00f3t a fibfib sz\u00e1msorozat n-ik elem\u00e9nek hat\u00e9kony kisz\u00e1m\u00edt\u00e1s\u00e1ra.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nAdj hozz\u00e1 t\u00f6bb tesztel\u00e9si esetet.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"K\u00f6rbe helyezz\u00fck az x eg\u00e9sz sz\u00e1m sz\u00e1mjegyeit, a sz\u00e1mjegyek jobbra helyezz\u00fck el, \u00e9s a sztring form\u00e1j\u00e1ban adja vissza az eredm\u00e9nyt. Ha a shift > sz\u00e1mjegyek sz\u00e1ma, akkor a sz\u00e1mjegyek visszaford\u00edtva.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Feladat Olyan f\u00fcggv\u00e9ny \u00edr\u00e1sa, amely bevitelk\u00e9nt egy karakterl\u00e1ncot vesz \u00e9s csak a fels\u0151 karakterek \u00f6sszeg\u00e9t adja vissza ASCII k\u00f3dok. P\u00e9ld\u00e1k: digitSum(\"\") => 0 digitSum(\"abAB\") => 131 digitSum(\"abcCd\") => 67 digitSum(\"helloE\") => 69 digitSum(\"woArBld\") => 131 digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Ebben a feladatban kap egy olyan h\u00far, amely egy gy\u00fcm\u00f6lcskos\u00e1rban elosztott alm\u00e1kat \u00e9s narancsokat jel\u00f6l, ez a kos\u00e1r alm\u00e1t, narancsot \u00e9s mang\u00f3 gy\u00fcm\u00f6lcs\u00f6ket tartalmaz. Ha a h\u00far jel\u00f6li a narancsok \u00e9s alm\u00e1kat \u00e9s egy eg\u00e9sz sz\u00e1m, amely a gy\u00fcm\u00f6lcs\u00f6k sz\u00e1m\u00e1t jel\u00f6li, adja vissza a mang\u00f3 gy\u00fcm\u00f6lcs\u00f6k sz\u00e1m\u00e1t a kos\u00e1rban. P\u00e9ld\u00e1ul: fruit_distribution\"5(alm\u00e1kat \u00e9s 6 narancsot\", 19) -> 19 - 5 - 6 = 8 fruit_distribution\"0 alm\u00e1t \u00e9s 1 narancsot\",3) -> 3 - 0 - 1 = 2 fruit_distribution\"2 alm\u00e1t \u00e9s 3 narancsot\", 100) -> 100 - 2 - 3 = 95 fruit_distribution\"100 alm\u00e1t \u00e9s 1 narancsot\" (120) -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Ha egy sor egy olyan fa\u00e1g\u00e1t k\u00e9pviseli, amelynek nem negat\u00edv eg\u00e9sz sz\u00e1m\u00fa csom\u00f3pontjai vannak, a feladatunk az, hogy kivessz\u00fck az egyik csom\u00f3pontot \u00e9s visszaadjuk. A kivessz\u00fck csom\u00f3pontnak a legkisebb p\u00e1ros \u00e9rt\u00e9k\u0171 csom\u00f3pontnak kell lennie. Ha t\u00f6bb csom\u00f3pontot tal\u00e1lunk, amelyek ugyanazon legkisebb p\u00e1ros \u00e9rt\u00e9kkel vannak, akkor visszaadjuk a legkisebb index\u0171 csom\u00f3pontot. A kivessz\u00fck csom\u00f3pontot egy list\u00e1ban kell visszaadni, [smallest_value, index] Ha nincsenek p\u00e1ros \u00e9rt\u00e9kek, vagy az adott sor \u00fcres, akkor visszaadjuk []. P\u00e9ld\u00e1ul: 1: Bevitel: [4,2,3] Kivitel: [2, 1] Magyar\u00e1zat: 2 a legkisebb p\u00e1ros \u00e9rt\u00e9k\u0171, \u00e9s 2 a legkisebb index\u0171. P\u00e9ld\u00e1ul: Bevitel:\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Ha egy eg\u00e9sz sz\u00e1mokb\u00f3l \u00e1ll\u00f3 sorrendet adunk, akkor a sorrend palindromikus\u00e1 t\u00e9tel\u00e9hez a legkisebb elemek sz\u00e1m\u00e1t kell megv\u00e1ltani. A palindromikus sor olyan sor, amely ugyanazt olvasja el\u0151re \u00e9s h\u00e1tra. Egy v\u00e1ltoz\u00e1s sor\u00e1n egy elemet b\u00e1rmelyik m\u00e1sik elemre v\u00e1ltoztathat. P\u00e9ld\u00e1ul: smallest_change (([1,2,3,5,4,7,9,6]) == 4 smallest_change (([1, 2, 3, 4, 3, 2, 2]) == 1 smallest_change (([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"\u00cdrjunk egy olyan f\u00fcggv\u00e9nyt, amely igaz, ha a megadott sz\u00e1m 3 pr\u00edmsz\u00e1m szorzata, \u00e9s m\u00e1sk\u00fcl\u00f6nben hamis.\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"A feladatunk az, hogy \u00edrjunk egy olyan f\u00fcggv\u00e9nyt, amely igazat ad, ha egy sz\u00e1m x n egyszer\u0171 hat\u00f3dja, \u00e9s hamis m\u00e1s esetekben. x n egyszer\u0171 hat\u00f3dja, ha n**int=x P\u00e9ld\u00e1ul: is_simple_power(1, 4) => true is_simple_power(2, 2) => true is_simple_power(8, 2) => true is_simple_power(3, 2) => false is_simple_power(3, 1) false => is_simple_power(5, 3) => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"A hexadecim\u00e1lis sz\u00e1mok a k\u00f6vetkez\u0151k: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. A pr\u00edmsz\u00e1mok a k\u00f6vetkez\u0151k: 2, 3, 5, 7, 11, 13, 17,... Megjegyz\u00e9s: felt\u00e9telezhetj\u00fck, hogy a bemeneti sz\u00e1m mindig helyes vagy \u00fcres, \u00e9s az A, B, C, D, E, F szimb\u00f3lumok mindig nagybet\u0171kkel vannak meg\u00edrva. P\u00e9ld\u00e1k: A num = AB, a kimeneti sz\u00e1mnak 1. kell lennie. A num = 1077E kimeneti sz\u00e1mnak 2. kell lennie. A num = AB331EDA a num = 4. kell lennie. A num = 4. kell lennie. A num = 6.01289ABCDEFD67. A kimeneti sz\u00e1mnak 2. kell lennie.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"A f\u00fcggv\u00e9nynek egy karakterl\u00e1ncot kell visszaadnia, ahol minden karakter egy bin\u00e1ris sz\u00e1mot k\u00e9pvisel. A karakterl\u00e1nc minden egyes karaktere 0 vagy 1. A karakterl\u00e1nc elej\u00e9n \u00e9s v\u00e9g\u00e9n egy p\u00e1r extra karakter lesz, a db. A t\u00f6bblet karakterek a form\u00e1tumban seg\u00edtenek. P\u00e9ld\u00e1k: decimal_to_binary (\\displaystyle db_{1111db}\\,\\displaystyle db_{1}\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\) # visszaadja a \"db1111db\" -et, \u00e9s minden karakter egy bin\u00e1ris sz\u00e1mot k\u00e9pvisel. A karakterl\u00e1nc minden egyes karaktere 0 vagy 1 lesz. A karakterl\u00e1nc ele\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"A string akkor happy, ha legal\u00e1bb 3 bet\u0171vel rendelkezik, \u00e9s minden 3 egym\u00e1st k\u00f6vet\u0151 bet\u0171 megk\u00fcl\u00f6nb\u00f6ztethet\u0151. P\u00e9ld\u00e1ul: is_happy (a) => False is_happy (aa) => False is_happy (abcd) => True is_happy (aabb) => False is_happy (adb) => True is_happy (xyy) => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"A tan\u00e1r a tan\u00e1roknak a jegyeket adta. A tan\u00e1r a saj\u00e1t algoritmusa alapj\u00e1n oszt\u00e1lyozta a di\u00e1kokat. Az egyetlen probl\u00e9ma az, hogy elvesztette a k\u00f3dot, amit a oszt\u00e1lyoz\u00e1shoz haszn\u00e1lt. Adott egy list\u00e1t a GPA-kr\u00f3l n\u00e9h\u00e1ny di\u00e1k sz\u00e1m\u00e1ra, \u00e9s egy olyan f\u00fcggv\u00e9nyt kell \u00edrnod, amely a k\u00f6vetkez\u0151 t\u00e1bl\u00e1zat seg\u00edts\u00e9g\u00e9vel adhat ki egy list\u00e1t a bet\u0171i oszt\u00e1lyzatokr\u00f3l: GPA  Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B- > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E: grade_equation (([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"\u00cdrjunk egy olyan f\u00fcggv\u00e9nyt, amely egy stringet vesz \u00e9s True-t ad vissza, ha a string hossza egy pr\u00edmsz\u00e1m, vagy False-t, ha nem. P\u00e9ld\u00e1k prime_length{\"Hello\") == True prime_length{\"abcdcba\") == True prime_length{\"kittens\") == True prime_length{\"orange\") == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Ha egy n pozit\u00edv eg\u00e9sz sz\u00e1mot kapunk, adja meg az n-jegy\u0171 pozit\u00edv eg\u00e9sz sz\u00e1mok sz\u00e1m\u00e1t, amelyek 1-el kezd\u0151dnek vagy v\u00e9gz\u0151dnek.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Ha egy N pozit\u00edv eg\u00e9sz sz\u00e1mot kapunk, adja vissza a sz\u00e1mjegyek bin\u00e1ris \u00f6sszegeit. P\u00e9ld\u00e1ul N = 1000 eset\u00e9n a sz\u00e1mjegyek \u00f6sszege 1 lesz, a kimen\u0151nek \"1\" kell lennie. N = 150 eset\u00e9n a sz\u00e1mjegyek \u00f6sszege 6 lesz, a kimen\u0151nek \"110\" kell lennie. N = 147 eset\u00e9n a sz\u00e1mjegyek \u00f6sszege 12 lesz, a kimen\u0151nek \"1100\" kell lennie. V\u00e1ltoz\u00f3k: @N eg\u00e9sz sz\u00e1m Korl\u00e1toz\u00e1sok: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000. Kivitel: bin\u00e1ris sz\u00e1mok sora\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Ha egy nem \u00fcres eg\u00e9sz sz\u00e1mlist\u00e1t l\u00e1tunk, lst. a p\u00e1ros elemeket, amelyek p\u00e1ratlan indexekben vannak, hozz\u00e1adjuk. P\u00e9ld\u00e1k: add (([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    \u00cdrjunk egy olyan f\u00fcggv\u00e9nyt, amely egy h\u00farb\u00f3l egy sorrendbe rendezett v\u00e1ltozatot ad vissza. A h\u00far sorrendbe rendezett v\u00e1ltozata olyan h\u00far, ahol minden sz\u00f3t (t\u00e9rrel elv\u00e1lasztva) egy \u00faj sz\u00f3 v\u00e1lt ki, ahol az \u00f6sszes karakter emelked\u0151 sorrendben van elrendezve az ascii \u00e9rt\u00e9k alapj\u00e1n. Megjegyz\u00e9s: Meg kell tartani a szavak \u00e9s a sz\u00f3k\u00f6z\u00f6k sorrendj\u00e9t a mondatban. P\u00e9ld\u00e1ul: anti_shuffle ((('Hi') visszaadja az 'Hi' anti_shuffle ((('hello') visszaadja az 'ehllo' anti_shuffle (('Hello World!!!') visszaadja az 'Hello!!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    A matrixhoz hasonl\u00f3an, de a m\u00e1trixokt\u00f3l elt\u00e9r\u0151en, minden sor tartalmazhat k\u00fcl\u00f6nb\u00f6z\u0151 sz\u00e1m\u00fa oszlopot. Az lst \u00e9s az x eg\u00e9sz sz\u00e1mot megadva, tal\u00e1lj x eg\u00e9sz sz\u00e1mot a list\u00e1ban, \u00e9s t\u00e9rj vissza a tuplek list\u00e1j\u00e1hoz, [(x1, y1), (x2, y2)...] oly m\u00f3don, hogy minden tuple egy koordin\u00e1t\u00e1t - (sor, oszlopok), kezdve a 0-val. Sorolja \u00f6ssze a koordin\u00e1t\u00e1kat kezdetben sorok szerint emelked\u0151 sorrendben. Tov\u00e1bb\u00e1 sorolja \u00f6ssze a sor koordin\u00e1t\u00e1it oszlopok szerint cs\u00f6kken\u0151 sorrendben. P\u00e9ld\u00e1ul: get_row [1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1], 1) == [0,0, 0, 0, 1, 4], 0 (2, 5), (2, 0) get_(], 1) [] == [0, 1,\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Ha egy nem negat\u00edv eg\u00e9sz sz\u00e1mokb\u00f3l \u00e1ll\u00f3 t\u00f6mbet adunk, a rendez\u00e9s ut\u00e1n k\u00fcldj\u00fcnk vissza egy m\u00e1solatot a megadott t\u00f6mbr\u0151l, \u00e9s soroljunk felfel\u00e9, ha a summa ((az els\u0151 index\u00e9rt\u00e9k, az utols\u00f3 index\u00e9rt\u00e9k) p\u00e1ratlan, vagy soroljunk lefel\u00e9, ha a summa ((az els\u0151 index\u00e9rt\u00e9k, az utols\u00f3 index\u00e9rt\u00e9k) p\u00e1ros. Megjegyz\u00e9s: * ne v\u00e1ltoztassunk az adott t\u00f6mb\u00f6n. P\u00e9ld\u00e1k: * sort_array[(]) => [] * sort_array[5]) => [5] * sort_array[2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5] * sort_array[2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 5, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Hozzon l\u00e9tre egy encrypt funkci\u00f3t, amely egy stringet vesz \u00e9rvk\u00e9nt, \u00e9s egy k\u00f3dolt stringet ad vissza az \u00e1b\u00e9c\u00e9 forgat\u00e1s\u00e1val. Az \u00e1b\u00e9c\u00e9 olyan m\u00f3don forgathat\u00f3, hogy a bet\u0171k lejjebb k\u00e9t szorozva k\u00e9t helyre ker\u00fcljenek. P\u00e9ld\u00e1ul: encrypt('hi') adja vissza 'lm' encrypt('asdfghjkl') adja vissza 'ewhjklnop' encrypt('gf') adja vissza 'kj' encrypt('et') adja vissza 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u00cdrj egy funkci\u00f3t, amely a list\u00e1n l\u00e9v\u0151 m\u00e1sodik legkisebb elemet adja vissza. Ha nincs ilyen elem, akkor a null\u00e1t adja vissza. next_smallest (([1, 2, 3, 4, 5]) == 2 next_smallest (([5, 1, 4, 3, 2]) == 2 next_smallest (([]) == next_smallest (([1, 1]) == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Egy mondat egy \"I\" bet\u0171vel kezd\u0151dik, \u00e9s a mondatokat \"\", \"?\" vagy \"!\" hat\u00e1rolja.\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    \u00cdrjunk egy olyan funkci\u00f3t, amely egy \u00fczenetet vesz, \u00e9s \u00fagy k\u00f3dol, hogy az \u00f6sszes bet\u0171 case-j\u00e1t cser\u00e9li, az \u00fczenet \u00f6sszes mag\u00e1nhangz\u00f3j\u00e1t az angol \u00e1b\u00e9c\u00e9ben az \u00f6nhangz\u00f3 el\u0151tt 2 helyen megjelen\u0151 bet\u0171vel helyettes\u00edti.\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"A teljes sz\u00e1mok list\u00e1ja van. Meg kell tal\u00e1lni a legnagyobb pr\u00edm\u00e9rt\u00e9ket \u00e9s vissza kell adni a sz\u00e1mjegyek \u00f6sszeg\u00e9t. P\u00e9ld\u00e1k: Ha lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] a kimen\u0151 \u00e9rt\u00e9k 10 Ha lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] a kimen\u0151 \u00e9rt\u00e9k 25 Ha lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] a kimen\u0151 \u00e9rt\u00e9k 13 Ha lst = [0,724,32,71,99,32,60,5,91,83,0,5,6] a kimen\u0151 \u00e9rt\u00e9k 11 Ha lst = [0,81,12,31,21] a kimen\u0151 \u00e9rt\u00e9k 3 Ha lst = [\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Ha egy sz\u00f3t\u00e1rban minden kulcs kisebb bet\u0171kkel vagy nagyobb bet\u0171kkel van, akkor a funkci\u00f3 az Igazot adja vissza, ha az \u00f6sszes kulcs kisebb bet\u0171kkel vagy nagyobb bet\u0171kkel van, m\u00e1sk\u00fcl\u00f6nben a Val\u00f3t. Ha a megadott sz\u00f3t\u00e1r \u00fcres, a funkci\u00f3nak Val\u00f3t kell adnia. P\u00e9ld\u00e1k: check_dict_case{\"a\":\"alma\", \"b\":\"ban\u00e1n\"}) Val\u00f3t kell adnia. check_dict_case{\"a\":\"alma\", \"A\":\"ban\u00e1n\", \"B\":\"ban\u00e1n\"}) Val\u00f3t kell adnia. check_dict_case{\"a\":\"alma\", 8:\"ban\u00e1n\", \"a\":\"alma\"}) Val\u00f3t kell adnia. Check_dict_case{\"N\u00e9v\", \"John\", \"Eredet\", \"36\", \"City\", \"\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Olyan f\u00fcggv\u00e9ny v\u00e9grehajt\u00e1sa, amely nem negat\u00edv eg\u00e9sz sz\u00e1mot vesz \u00e9s az els\u0151 n eg\u00e9sz sz\u00e1mokb\u00f3l \u00e1ll\u00f3 t\u00f6mb\u00f6t ad vissza, amelyek pr\u00edmsz\u00e1mok \u00e9s kisebbek, mint n. P\u00e9ld\u00e1ul: count_up_to(5) => [2,3] count_up_to(11) => [2,3,5,7] count_up_to(0) => [] count_up_to(20) => [2,3,5,7,11,13,17,19] count_up_to(1) => [] count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"A f\u00fcggv\u00e9ny teljes\u00edt\u00e9se, amely k\u00e9t eg\u00e9sz sz\u00e1mot veszi \u00e9s az egys\u00e9gjegyek szorzat\u00e1t adja vissza.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Egy s-es karakterl\u00e1ncban sz\u00e1mold meg a p\u00e1ros jelz\u00e9s\u0171 f\u0151sz\u00f3val bet\u0171zett mag\u00e1nhangz\u00f3k sz\u00e1m\u00e1t. P\u00e9ld\u00e1ul: count_upper (('aBCdEf') 1 sz\u00e1mot ad vissza count_upper (('abcdefg') 0 sz\u00e1mot ad vissza count_upper (('dBBE') 0-ot ad vissza\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Ha egy n pozit\u00edv eg\u00e9sz sz\u00e1mot adunk, akkor egy n k\u0151b\u0151l \u00e1ll\u00f3 halommal kell rendelkeznie. Az els\u0151 szint n k\u0151b\u0151l \u00e1ll. A k\u00f6vetkez\u0151 szintben a k\u0151sz\u00e1mok sz\u00e1ma: - a k\u00f6vetkez\u0151 p\u00e1ratlan sz\u00e1m, ha n p\u00e1ratlan. - a k\u00f6vetkez\u0151 p\u00e1ros sz\u00e1m, ha n p\u00e1ros. Adja vissza a k\u0151sz\u00e1mokat az egyes szintekben egy list\u00e1ban, ahol az i index\u0171 elem az i szint k\u0151sz\u00e1m\u00e1t k\u00e9pviseli (i + 1). P\u00e9ld\u00e1k:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    A feladatunk, hogy sz\u00e9tv\u00e1lasztjuk a sz\u00e1lakat szavakra \u00e9s visszaadjuk a szavak t\u00f6mb\u00e9t. P\u00e9ld\u00e1ul: words_string ((\"Szia, a nevem John\") == [\"Szia\", \"az eny\u00e9m\", \"n\u00e9v\", \"az\", \"John\"] words_string ((\"Egy, kett\u0151, h\u00e1rom, n\u00e9gy, \u00f6t, hat\") == [\"Egy\", \"kett\u0151\", \"h\u00e1rom\", \"n\u00e9gy\", \"\u00f6t\", \"hat\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Ez a f\u00fcggv\u00e9ny k\u00e9t pozit\u00edv sz\u00e1mot vesz fel, x \u00e9s y, \u00e9s a legnagyobb p\u00e1ros eg\u00e9sz sz\u00e1mot adja vissza, amely [x, y] tartom\u00e1nyban van.\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"A v\u00e1lasz a legk\u00f6zelebbi eg\u00e9sz sz\u00e1mra kerek\u00edtve, majd bin\u00e1risra konvert\u00e1lva. Ha n nagyobb mint m, adja vissza a -1-et. P\u00e9ld\u00e1ul: rounded_avg ((1, 5) => \"0b11\" rounded_avg ((7, 5) => -1 rounded_avg ((10, 20) => \"0b1111\" rounded_avg ((20, 33) => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"A pozit\u00edv eg\u00e9sz sz\u00e1mok list\u00e1ja x. A list\u00e1ban szerepl\u0151 elemek sorrendj\u00e9t adja vissza, amely nem tartalmaz p\u00e1ros sz\u00e1mjegyet. Megjegyz\u00e9s: A list\u00e1t n\u00f6vekv\u0151 sorrendben kell sorolni. P\u00e9ld\u00e1ul:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Ha egy eg\u00e9sz sz\u00e1mok sor\u00e1t kapunk, akkor rendezz\u00fck az 1-t\u0151l 9-ig terjed\u0151 eg\u00e9sz sz\u00e1mokat, ford\u00edtjuk meg az ered\u0151 sorrendet, majd minden egyes sz\u00e1mjegyet helyettes\u00edt\u00fcnk a megfelel\u0151 n\u00e9vvel az \"Egy\", \"K\u00e9t\", \"H\u00e1rom\", \"N\u00e9gy\", \"\u00d6t\", \"Hat\", \"H\u00e9t\", \"Nyolc\", \"Kilenc\" sorrendb\u0151l. P\u00e9ld\u00e1ul: arr = [2, 1, 1, 4, 5, 8, 2, 3] -> rendezz\u00fck arr -> [1, 1, 2, 2, 3, 4, 5, 8] -> ford\u00edtott arr -> [8, 5, 4, 3, 2, 2, 1, 1] visszaadunk [\"H\u00e9t\", \"N\u00e9gy\", \"H\u00e1rom\", \"K\u00e9t\", \"K\u00e9t\", \"Egy\", \"Egy\"] Ha az \u00e1bra \u00fcres, akkor t\u00e9r\u00fcnk vissza egy eg\u00e9sz sz\u00e1mot: arr = [] visszaadunk [] Ha az \u00e1br\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" A f f\u00fcggv\u00e9nyt, amely n-et vesz param\u00e9ternek, \u00e9s egy n-es list\u00e1t ad vissza, hogy az i indexben l\u00e9v\u0151 elem \u00e9rt\u00e9ke i-nek a faktoriala, ha i p\u00e1ros, vagy az 1-t\u0151l i-ig terjed\u0151 sz\u00e1mok \u00f6sszege. i 1-t\u0151l kezd\u0151dik. i-nek a faktoriala az 1-t\u0151l i-ig terjed\u0151 sz\u00e1mok szorz\u00e1sa (1 * 2 *... * i). P\u00e9ld\u00e1ul: f (((5) == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Ha egy n pozit\u00edv eg\u00e9sz sz\u00e1mot kapunk, akkor egy olyan tuplot adunk vissza, amely a ((1, n) tartom\u00e1nyba tartoz\u00f3 p\u00e1ros \u00e9s p\u00e1ratlan eg\u00e9sz sz\u00e1m\u00fa palindr\u00f3m\u00e1k sz\u00e1m\u00e1t tartalmazza. P\u00e9ld\u00e1ul1: bemenet: 3 kimenet: (1, 2) magyar\u00e1zat: eg\u00e9sz sz\u00e1m\u00fa palindr\u00f3m\u00e1k: 1, 2, 3. ezek k\u00f6z\u00fcl az egyik p\u00e1ros, kett\u0151 pedig p\u00e1ratlan. P\u00e9ld\u00e1ul2: bemenet: 12 kimenet: (4, 6) magyar\u00e1zat: eg\u00e9sz sz\u00e1m\u00fa palindr\u00f3m\u00e1k: 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. n\u00e9gy k\u00f6z\u00fcl\u00fck p\u00e1ros, \u00e9s hat k\u00f6z\u00fcl\u00fck p\u00e1ratlan. Megjegyz\u00e9s: 1. 1 <= n <= 10^3 2. a tupl visszaadta a p\u00e1ros \u00e9s p\u00e1ratlan eg\u00e9sz sz\u00e1m\u00fa palindr\u00f3m\u00e1k sz\u00e1m\u00e1t.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    \u00cdrjunk egy count_nums f\u00fcggv\u00e9nyt, amely egy eg\u00e9sz sz\u00e1mokb\u00f3l \u00e1ll\u00f3 t\u00f6mb\u00f6t vesz \u00e9s olyan elemek sz\u00e1m\u00e1t adja vissza, amelyek sz\u00e1ma > 0. Ha egy sz\u00e1m negat\u00edv, akkor az els\u0151 jelezett sz\u00e1mjegye negat\u00edv lesz: pl. -123 jelezett sz\u00e1mjegye -1, 2 \u00e9s 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"A sorban l\u00e9v\u0151 sz\u00e1mok v\u00e9letlenszer\u0171en lesznek rendezve. A feladatod az, hogy eld\u00f6ntsd, lehets\u00e9ges-e egy sorrendet nem cs\u00f6kken\u0151 sorrendben rendezni az adott sorrendben az al\u00e1bbi m\u0171velet v\u00e9grehajt\u00e1s\u00e1val: B\u00e1rmikor megengedett a jobb oldali mozg\u00e1s m\u0171velete. Egy jobb oldali mozg\u00e1s m\u0171velet azt jelenti, hogy az \u00f6sszes elemet az array egy poz\u00edci\u00f3val a jobb ir\u00e1nyba mozgatja. Az utols\u00f3 elem az array kezd\u0151 poz\u00edci\u00f3j\u00e1ba ker\u00fcl az arrayban, azaz 0-as index. Ha lehets\u00e9ges a rendezett sorrendet az el\u0151z\u0151 m\u0171velet v\u00e9grehajt\u00e1s\u00e1val, akkor True vissza, m\u00e1s esetben False vissza. Ha az adott sor \u00fcres, akkor True vissza. Megjegyz\u00e9s: Az adott list\u00e1ban garant\u00e1ltan egyedi elemek vannak. P\u00e9ld\u00e1ul: move_one_{\\displaystyle {\\displaystyle _{\\displaystyle _{\\text{one}}{\\\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Ebben a probl\u00e9ma, akkor megval\u00f3s\u00edtani egy f\u00fcggv\u00e9ny, amely k\u00e9t list\u00e1t sz\u00e1mok, \u00e9s meghat\u00e1rozza, hogy lehets\u00e9ges-e, hogy egy cser\u00e9t elemek k\u00f6z\u00f6tt, hogy lst1 egy list\u00e1t csak p\u00e1ros sz\u00e1mok. Nincs korl\u00e1t a sz\u00e1m\u00e1t elemek cser\u00e9je k\u00f6z\u00f6tt lst1 \u00e9s lst2. Ha lehets\u00e9ges, hogy elemek cser\u00e9je k\u00f6z\u00f6tt lst1 \u00e9s lst2 hogy az \u00f6sszes elemek lst1 p\u00e1ros, vissza \"Igen\". Ellenkez\u0151 esetben, vissza \"NEM\". P\u00e9ld\u00e1ul: exchange[(1, 2, 3, 4], [1, 2, 3, 4]) => \"Igen\" exchange[(1, 2, 3, 4], [1, 5, 3, 4]) => \"NEM\" Felt\u00e9telezz\u00fck, hogy a bemen\u0151 list\u00e1k nem \u00fcres.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Ha egy karakterl\u00e1nc egy t\u00e9rrel elv\u00e1lasztott kisbet\u0171s bet\u0171sz\u00e1mot mutat, akkor a legt\u00f6bbet ism\u00e9telt bet\u0171 sz\u00f3t\u00e1r\u00e1t kell visszak\u00fcldeni, amely tartalmazza a megfelel\u0151 sz\u00e1mot. Ha t\u00f6bb bet\u0171nek is ugyanaz a megjelen\u00e9se, akkor mindegyiket kell visszak\u00fcldeni. P\u00e9ld\u00e1ul: histogram (('a b c') == {'a': 1, 'b': 1, 'c': 1} histogram (('a b b a') == {'a': 2, 'b': 2} histogram (('a b c a b') == {'a': 2, 'b': 2} histogram (('b b a b') == {'b 4}: histogram (('a') == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Feladat K\u00e9t s \u00e9s c karakterl\u00e1nc van, t\u00f6r\u00f6lni kell az s-ben l\u00e9v\u0151 karaktereket, amelyek egyenl\u0151ek a c karakter\u00e9vel, majd ellen\u0151rizni kell, hogy az eredm\u00e9nyl\u00e1nc palindr\u00f3m-e. Egy string palindr\u00f3mnak nevezik, ha ugyanazt olvassa visszafel\u00e9, mint el\u0151re. Vissza kell adnia egy tupl\u00e1t, amely tartalmazza az eredm\u00e9nyl\u00e1ncot \u00e9s a True\/False-t a ellen\u0151rz\u00e9shez. P\u00e9ld\u00e1ul az s = \"abcde\", c = \"ae\" eset\u00e9n az eredm\u00e9nynek az ('bcd',False) kell lennie az s = \"abcdef\", c = \"b\" eset\u00e9n az eredm\u00e9nynek az ('acdef',False) kell lennie az s = \"abcdedcba\", c = \"ab\", az eredm\u00e9nynek az ('cdedc',True) kell lennie\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Ha egy olyan string list\u00e1t kapunk, ahol minden egyes string csak sz\u00e1mjegyekb\u0151l \u00e1ll, akkor egy list\u00e1t kell visszaadnunk. Az output minden egyes i elem\u00e9nek \"a p\u00e1ratlan elemek sz\u00e1ma az input i string-\u00e9ben\". ahol az \u00f6sszes i-t a bevitel i-edik string-\u00e9ben l\u00e9v\u0151 p\u00e1ratlan sz\u00e1mjegyek sz\u00e1m\u00e1val kell helyettes\u00edteni.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Egy n eg\u00e9sz sz\u00e1m\u00fa t\u00f6mbben tal\u00e1ljuk meg a n-ek nem \u00fcres al-t\u00f6mb\u00e9nek minim\u00e1lis \u00f6sszeg\u00e9t.\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    A v\u00edzbevon\u00e1s a v\u00edzbevon\u00e1sb\u00f3l, a v\u00edzbevon\u00e1sb\u00f3l \u00e9s a v\u00edzbevon\u00e1sb\u00f3l t\u00f6rt\u00e9nik. A v\u00edzbevon\u00e1s a v\u00edzbevon\u00e1sb\u00f3l \u00e9s a v\u00edzbevon\u00e1sb\u00f3l t\u00f6rt\u00e9nik. A v\u00edzbevon\u00e1s a v\u00edzbevon\u00e1sb\u00f3l \u00e9s a v\u00edzbevon\u00e1sb\u00f3l t\u00f6rt\u00e9nik. A v\u00edzbevon\u00e1s a v\u00edzbevon\u00e1sb\u00f3l \u00e9s a v\u00edzbevon\u00e1sb\u00f3l t\u00f6rt\u00e9nik. A v\u00edzbevon\u00e1s a v\u00edzbevon\u00e1sb\u00f3l \u00e9s a v\u00edzbevon\u00e1sb\u00f3l t\u00f6rt\u00e9nik.\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Ebben a kata-ban, egy sor nem negat\u00edv eg\u00e9sz sz\u00e1mot kell rendezn\u00fcnk a bin\u00e1ris \u00e1br\u00e1zol\u00e1sukban az egyesek sz\u00e1m\u00e1nak megfelel\u0151en emelked\u0151 sorrendben.\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Ha egy s-es h\u00far \u00e9s egy n-es term\u00e9szetes sz\u00e1m van, akkor egy olyan f\u00fcggv\u00e9nyt kell v\u00e9grehajtani, amely az s-es h\u00far \u00f6sszes olyan szav\u00e1nak list\u00e1j\u00e1t adja vissza, amelyek pontosan n konson\u00e1nt tartalmaznak, hogy ezek a szavak az s-es h\u00farban jelenjenek meg. Ha az s-es h\u00far \u00fcres, akkor a f\u00fcggv\u00e9nynek egy \u00fcres list\u00e1t kell adnia vissza. Megjegyz\u00e9s: felt\u00e9telezhetj\u00fck, hogy a bemeneti h\u00far csak bet\u0171ket \u00e9s \u0171r\u00f6ket tartalmaz. P\u00e9ld\u00e1k: select_words \"Mary had a little lamb\" (4) ==> [\"little\"] select_words \"Mary had a little lamb\" (3) ==> [\"Mary\", \"lamb\"] select_words \"simple white space\" (2) ==> [] select_words \"Hello world\" (4) ==> [\"world\"] select_words \"Uncle sam\"\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Egy sz\u00f3 van megadva. A feladatod az, hogy megtal\u00e1ld a legk\u00f6zelebbi mag\u00e1nhangz\u00f3t, amely a sz\u00f3 jobb oldal\u00e1n k\u00e9t konson\u00e1ns k\u00f6z\u00f6tt \u00e1ll (a nagybet\u0171kkel \u00e9rz\u00e9keny). A kezdeti \u00e9s a v\u00e9gs\u0151 mag\u00e1nhangz\u00f3k nem sz\u00e1m\u00edtanak. \u00dcres h\u00farot k\u00fcldj vissza, ha nem tal\u00e1lt\u00e1l semmilyen mag\u00e1nhangz\u00f3t, amely megfelel a fenti felt\u00e9telnek. Felt\u00e9telezheted, hogy az adott h\u00far csak angol bet\u0171t tartalmaz. P\u00e9ld\u00e1ul: get_closest_vowel (((\"yogurt\") ==> \"u\" get_closest_vowel (((\"F\") ==> \"U\" get_closest_vowel (((\"quick\") ==> \"\" get_closest_vowel\" (((ab\") ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Ha egy eg\u00e9sz sz\u00e1mokb\u00f3l \u00e1ll\u00f3 arr \u00e9s egy k pozit\u00edv eg\u00e9sz sz\u00e1mot kapunk, akkor egy k hossz\u00fas\u00e1g\u00fa, sorolt list\u00e1t adunk vissza, amely az arr-ben l\u00e9v\u0151 k sz\u00e1mok maxim\u00e1lis sz\u00e1m\u00e1t tartalmazza. P\u00e9ld\u00e1ul1: bemenet: arr = [-3, -4, 5], k = 3 kimenet: [-4, -3, 5] P\u00e9ld\u00e1ul2: bemenet: arr = [4, -4, 4], k = 2 kimenet: [4, 4] P\u00e9ld\u00e1ul3: bemenet: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1 kimenet: [2] Megjegyz\u00e9s: 1. Az array hossz\u00fas\u00e1ga [1, 1000] tartom\u00e1nyban lesz. 2. Az array elemei [-1000, 1000] tartom\u00e1nyban lesznek.\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Ha egy nem \u00fcres eg\u00e9sz sz\u00e1mlist\u00e1t kapunk, akkor adja vissza a p\u00e1ros poz\u00edci\u00f3ban l\u00e9v\u0151 \u00f6sszes p\u00e1ratlan elem \u00f6sszeg\u00e9t. P\u00e9ld\u00e1k megold\u00e1s (([5, 8, 7, 1]) ==> 12 megold\u00e1s (([3, 3, 3, 3]) ==> 9 megold\u00e1s (([30, 13, 24, 321]) ==>0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Ha egy nem \u00fcres t\u00f6mbben van az arr eg\u00e9sz sz\u00e1m \u00e9s egy k eg\u00e9sz sz\u00e1m, akkor adja vissza az arr els\u0151 k elem\u00e9nek legfeljebb k\u00e9t sz\u00e1mjeggyel rendelkez\u0151 elemeinek \u00f6sszeg\u00e9t. P\u00e9ld\u00e1ul: bemenet: arr = [111,21,3,4000,5,6,7,8,9], k = 4 kimenet: 24 # 21 + 3 \u00f6sszeg Korl\u00e1toz\u00e1sok: 1. 1 <= lenarr) <= 100 2. 1 <= k <= lenarr)\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Ha egy n pozit\u00edv eg\u00e9sz sz\u00e1mot kapunk, akkor egy sorolt list\u00e1t kell visszak\u00fcldeni, amely a p\u00e1ratlan sz\u00e1mokat tartalmazza a Collatz-sorozatban. A Collatz-elm\u00e9let a matematika egy olyan felt\u00e9telez\u00e9se, amely a k\u00f6vetkez\u0151k\u00e9ppen meghat\u00e1rozott sorrendet \u00e9rinti: kezdj\u00fck b\u00e1rmely n pozit\u00edv eg\u00e9sz sz\u00e1mmal. Azt\u00e1n minden egyes kifejez\u00e9st az el\u0151z\u0151 kifejez\u00e9sb\u0151l az al\u00e1bbiak szerint kapjuk: ha az el\u0151z\u0151 kifejez\u00e9s p\u00e1ros, a k\u00f6vetkez\u0151 kifejez\u00e9s az el\u0151z\u0151 kifejez\u00e9s fele. Ha az el\u0151z\u0151 kifejez\u00e9s p\u00e1ratlan, a k\u00f6vetkez\u0151 kifejez\u00e9s az el\u0151z\u0151 kifejez\u00e9s 3szerese plusz 1. Az elm\u00e9let az, hogy nem sz\u00e1m\u00edt, hogy mekkora az n \u00e9rt\u00e9ke, a sorrend mindig el\u00e9r 1. Megjegyz\u00e9s: 1. Collatz(1) [1] 2. Visszat\u00e9rt lista sorolt n\u00f6vekv\u0151 sorrendben. P\u00e9ld\u00e1ul: get_odd_collatz(5) [1,\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"\u00cdrjon egy olyan f\u00fcggv\u00e9nyt, amely \u00e9rv\u00e9nyes\u00edti az adott d\u00e1tuml\u00e1ncot \u00e9s az Igazat adja vissza, ha a d\u00e1tum \u00e9rv\u00e9nyes, m\u00e1sk\u00fcl\u00f6nben T\u00e9ves. A d\u00e1tum \u00e9rv\u00e9nyes, ha az al\u00e1bbi szab\u00e1lyok mindegyike teljes\u00fcl: 1. A d\u00e1tuml\u00e1nc nem \u00fcres. 2. A napok sz\u00e1ma nem kevesebb, mint 1 vagy t\u00f6bb, mint 31 nap a h\u00f3napok eset\u00e9ben 1,3,5,7,8,10,12. \u00c9s a napok sz\u00e1ma nem kevesebb, mint 1 vagy t\u00f6bb, mint 30 nap a h\u00f3napok eset\u00e9ben 4,6,9,11. \u00c9s a napok sz\u00e1ma nem kevesebb, mint 1 vagy t\u00f6bb, mint 29 a h\u00f3nap eset\u00e9ben 2. 3. A h\u00f3napok sz\u00e1ma nem lehet kevesebb, mint 1 vagy t\u00f6bb, mint 12. 4. A d\u00e1tumnak a k\u00f6vetkez\u0151 form\u00e1tumban kell lennie: mm-dd-yyyy-yy p\u00e9ld\u00e1ul: valid_date (('03-11-2000') => True_valid_date (('15-01-2012') => False valid_date\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"A k\u00e9t intervallum egy eg\u00e9sz sz\u00e1m p\u00e1rja. P\u00e9ld\u00e1ul: intervallum = (kezd\u00e9s, v\u00e9g) = (1, 2). A megadott intervallumok z\u00e1rt, ami azt jelenti, hogy az intervallum (kezd\u00e9s, v\u00e9g) tartalmazza mind a kezdetet, mind a v\u00e9get. Minden adott intervallum eset\u00e9ben felt\u00e9telezz\u00fck, hogy a kezdet kisebb vagy egyenl\u0151 a v\u00e9g\u00e9vel. A feladatunk az, hogy meghat\u00e1rozzuk, hogy a k\u00e9t intervallum keresztez\u0151d\u00e9s\u00e9nek hossza pr\u00edmsz\u00e1m-e. P\u00e9ld\u00e1ul: az intervallumok (1, 3), (2, 4) keresztez\u0151d\u00e9s\u00e9nek hossza (2, 3) az 1, ami nem pr\u00edmsz\u00e1m. Ha a keresztez\u0151d\u00e9s hossza pr\u00edmsz\u00e1m, akkor adja vissza az \"Igen\", m\u00e1sk\u00fcl\u00f6nben adja vissza a \"Nem\". Ha a k\u00e9t intervallum nem keresztez\u0151dik, adja vissza a \"Nem\"-\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Egy eg\u00e9sz sz\u00e1mokb\u00f3l \u00e1ll\u00f3 array-t kapunk, \u00e9s a teljes sz\u00e1mok nagys\u00e1g\u00e1nak \u00f6sszeg\u00e9t kell megadni, amit az \u00f6sszes sz\u00e1m jeleinek szorzata adja az array-ban, 1, -1 vagy 0-val. Megjegyz\u00e9s: az \u00fcres arr-hoz nem ad semmit. P\u00e9ld\u00e1ul:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Ha egy r\u00e1csban N sor \u00e9s N oszlop van (N >= 2), \u00e9s minden cell\u00e1ja k pozit\u00edv eg\u00e9sz sz\u00e1m, akkor minden cell\u00e1ja tartalmaz egy \u00e9rt\u00e9ket. Minden eg\u00e9sz sz\u00e1m a [1, N * N] tartom\u00e1nyban pontosan egyszer jelenik meg a r\u00e1cs sejtjein. Meg kell tal\u00e1lnod a minim\u00e1lis k hossz\u00fas\u00e1g\u00fa utat a r\u00e1csban. B\u00e1rmelyik cell\u00e1b\u00f3l indulhatsz, \u00e9s minden l\u00e9p\u00e9sn\u00e9l a szomsz\u00e9dos sejtek b\u00e1rmelyik\u00e9re mozoghatsz, m\u00e1s szavakkal, olyan sejtekbe mehetsz, amelyek egy sz\u00e9le van a jelenlegi sejteddel. K\u00e9rj\u00fck, vegye figyelembe, hogy a k hossz\u00fas\u00e1g\u00fa \u00fat pontosan k sejtet jelent (nem felt\u00e9tlen\u00fcl k\u00fcl\u00f6nb\u00f6z\u0151). NEM mehet ki a r\u00e1csb\u00f3l. Egy A (k hossz\u00fas\u00e1g\u00fa) \u00fat kisebb, mint egy B (k hossz\u00fas\u00e1g\u00fa) \u00fat, ha\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"A Fibonacci-szekvenci\u00e1t mindenki ismeri, a matematikusok az elm\u00falt n\u00e9h\u00e1ny \u00e9vsz\u00e1zadban m\u00e9lyen tanulm\u00e1nyozt\u00e1k. Azonban amit az emberek nem ismernek, az a Tribonacci-szekvenci\u00e1t. A Tribonacci-szekvenci\u00e1t az ism\u00e9tl\u0151d\u00e9s hat\u00e1rozza meg: tri(1) = 3 tri(n) = 1 + n \/ 2, ha n p\u00e1ros. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ha n p\u00e1ratlan. P\u00e9ld\u00e1ul: tri(2) = 1 + (2 \/ 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Adunk egy nem negat\u00edv eg\u00e9sz sz\u00e1mot n, vissza kell adnunk a Tribonacci-szekvenci\u00e1nak els\u0151 n + 1 sz\u00e1m\u00e1nak list\u00e1j\u00e1t. P\u00e9ld\u00e1k: tri(3) =\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Ha egy n pozit\u00edv eg\u00e9sz sz\u00e1mot adunk, akkor a p\u00e1ratlan sz\u00e1mjegyek szorzata. Ha minden sz\u00e1mjegy p\u00e1ros, akkor 0-t adunk. P\u00e9ld\u00e1ul: sz\u00e1mjegyek(1) == 1 sz\u00e1mjegy(4) == 0 sz\u00e1mjegy(235) == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"A sz\u00e1mok list\u00e1ja van. Vissza kell adnia a megadott lista n\u00e9gyzet\u00e9n l\u00e9v\u0151 sz\u00e1mok \u00f6sszeg\u00e9t, el\u0151sz\u00f6r kerek\u00edtse be a lista minden elem\u00e9t a fels\u0151 int-re. P\u00e9ld\u00e1k: lst = [1,2,3] kimenete 14 lst = [1,4,9] kimenete 98 lst = [1,3,5,7] kimenete 84 lst = [1.4,4.2,0] kimenete 29 lst = [-2.4,1,1] kimenete 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Hozzon l\u00e9tre egy olyan f\u00fcggv\u00e9nyt, amely olyan elem legnagyobb index\u00e9t adja vissza, amely nem nagyobb vagy egyenl\u0151 az k\u00f6zvetlen\u00fcl el\u0151tte l\u00e9v\u0151 elemgel. Ha ilyen elem nem l\u00e9tezik, akkor adja vissza a -1-et. Az adott t\u00f6mb nem tartalmaz duplik\u00e1lt \u00e9rt\u00e9keket. P\u00e9ld\u00e1k: can_arrange (([1,2,4,3,5]) = 3 can_arrange[(1,2,3]) = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Hozzon l\u00e9tre egy olyan f\u00fcggv\u00e9nyt, amely a val\u00f3s sz\u00e1mokat reprezent\u00e1l\u00f3 eg\u00e9sz sz\u00e1mokat, lebeg\u0151 sz\u00e1mokat vagy sztringeket veszi \u00e9s a nagyobb v\u00e1ltoz\u00f3t megadott v\u00e1ltoz\u00f3t\u00edpus\u00e1ban adja vissza. Ha az \u00e9rt\u00e9kek egyenl\u0151ek, akkor a null\u00e1t adja vissza. Megjegyz\u00e9s: Ha egy val\u00f3s sz\u00e1mot sztringk\u00e9nt mutatnak be, akkor a lebeg\u0151 pont lehet. vagy, compare_one{1,2,5} -> 2.5 compare_one{1,2,3}) -> \"2,3\" compare_one{5,1}\", \"6\") -> \"6\" compare_one{1}\", 1) -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"\u00c9rt\u00e9kelje, hogy az adott n sz\u00e1m pontosan 4 pozit\u00edv p\u00e1ros sz\u00e1m \u00f6sszegek\u00e9nt \u00edrhat\u00f3-e be. P\u00e9ld\u00e1ul: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151: egyenl\u0151:\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"A brazil faktori\u00e1l a k\u00f6vetkez\u0151k\u00e9ppen defini\u00e1lhat\u00f3: brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1! ahol n > 0 P\u00e9ld\u00e1ul:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Ha egy sz\u00f6vegl\u00e1ncban t\u00f6bb mint 2 egym\u00e1st k\u00f6vet\u0151 hely van, akkor a hely\u00e9t a - fix_spaces (((\"P\u00e9ld\u00e1ny\") == \"P\u00e9ld\u00e1ny\" fix_spaces (((\"P\u00e9ld\u00e1ny1\") == \"P\u00e9ld\u00e1ny1\" fix_spaces (((\"P\u00e9ld\u00e1ny2\") == \"P\u00e9ld\u00e1ny_2\" fix_spaces (((\"P\u00e9ld\u00e1ny3\") == \"P\u00e9ld\u00e1ny-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Hozzon l\u00e9tre egy olyan f\u00fcggv\u00e9nyt, amely egy f\u00e1jl nev\u00e9t reprezent\u00e1l\u00f3 karakterl\u00e1ncot vesz, \u00e9s ha a f\u00e1jl neve \u00e9rv\u00e9nyes, akkor \"Igen\", ha nem, akkor \"Nem\" jelz\u00e9st ad. Egy f\u00e1jl neve akkor \u00e9s csak akkor tekinthet\u0151 \u00e9rv\u00e9nyesnek, ha az al\u00e1bbi felt\u00e9telek teljes\u00fclnek: - A f\u00e1jl nev\u00e9ben nem lehet t\u00f6bb, mint h\u00e1rom sz\u00e1mjegy ('0'-'9'). - A f\u00e1jl neve pontosan egy pontot tartalmaz '.' - A pont el\u0151tti all\u00e1nc nem lehet \u00fcres, \u00e9s a latin bet\u0171kkel kezd\u0151dik ('a'-'z' \u00e9s 'A'Z'). - A pontot k\u00f6vet\u0151 all\u00e1ncnak az al\u00e1bbiak valamelyik\u00e9vel kell kezd\u0151dnie: ['txt', 'exe', 'lld'] P\u00e9ldak: file_name_check\"(example.txt\") # => 'Igen' => 'file_name_check\"(example\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\" Ez a f\u00fcggv\u00e9ny egy eg\u00e9sz sz\u00e1mok list\u00e1j\u00e1t veszi. A list\u00e1ban l\u00e9v\u0151 \u00f6sszes bejegyz\u00e9s eset\u00e9ben a f\u00fcggv\u00e9ny n\u00e9gyzetre emeli a teljes sz\u00e1mot, ha az index 3-as, \u00e9s a teljes sz\u00e1mot k\u00f6bk\u00e9 teszi, ha az index 4-es, \u00e9s nem 3-as, a f\u00fcggv\u00e9ny nem v\u00e1ltoztatja meg a list\u00e1ban l\u00e9v\u0151 bejegyz\u00e9seket, ha az index nem 3-as vagy 4-es. A f\u00fcggv\u00e9nynek az \u00f6sszes bejegyz\u00e9s \u00f6sszeg\u00e9t kell visszaadnia. P\u00e9ld\u00e1k: lst = [1,2,3] kimenete 6 lst = [] kimenete 0 lst = [-1,-5,2,-1,-5] kimenete -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Egy mondatot \u00e1br\u00e1zol\u00f3 h\u00far van megadva, a mondat n\u00e9h\u00e1ny sz\u00f3t tartalmaz, amelyeket egy \u0171r v\u00e1laszt el, \u00e9s vissza kell adnia egy h\u00farot, amely tartalmazza az eredeti mondat szavaiit, amelyek hossz\u00fas\u00e1ga pr\u00edmsz\u00e1mok, az \u00faj h\u00far szavai sorrendj\u00e9nek meg kell felelnie az eredetinek. P\u00e9ld\u00e1ul1: Bevitel: mondat = \"Ez egy teszt\" Kivitel: \"az\" P\u00e9ld\u00e1ul2: Bevitel: mondat = \"megy\u00fcnk \u00faszni\" Kivitel: \"megy\u00fcnk\" Korl\u00e1toz\u00e1sok: * 1 <= len(mondat) <= 100 * A mondat csak bet\u0171ket tartalmaz\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"A feladatunk az, hogy egy olyan f\u00fcggv\u00e9nyt val\u00f3s\u00edtsunk meg, amely egyszer\u0171s\u00edti az x * n kifejez\u00e9st. A f\u00fcggv\u00e9ny akkor ad vissza Val\u00f3t, ha x * n eg\u00e9sz sz\u00e1mra \u00e9rt\u00e9kelik, \u00e9s Hazug, ha nem. Mind az x, mind az n egy t\u00f6red\u00e9k sztringjelz\u00e9se, \u00e9s a k\u00f6vetkez\u0151 form\u00e1tummal rendelkezik, <sz\u00e1ml\u00e1l\u00f3>\/<nev\u00e9nyez\u0151>, ahol mind a sz\u00e1ml\u00e1l\u00f3, mind a nevez\u0151 pozit\u00edv eg\u00e9sz sz\u00e1mok. Felt\u00e9telezhetj\u00fck, hogy az x \u00e9s az n \u00e9rv\u00e9nyes t\u00f6red\u00e9kek, \u00e9s nem nulla a nevez\u0151. egyszer\u0171s\u00edtve: \"1\/5\", \"5\/1\") = Val\u00f3, egyszer\u0171s\u00edtve: \"1\/6\", \"2\/1\") = T\u00e9ves, egyszer\u0171s\u00edtve: \"7\/10\", \"10\/2\") = T\u00e9ves\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    \u00cdrjunk egy olyan f\u00fcggv\u00e9nyt, amely a teljes sz\u00e1mok megadott list\u00e1j\u00e1t emelked\u0151 sorrendben rendezi a sz\u00e1mjegyek \u00f6sszeg\u00e9nek megfelel\u0151en.\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"\u00cdrjunk egy olyan f\u00fcggv\u00e9nyt, amely a sz\u00e1mok sor\u00e1t veszi be, \u00e9s olyan elemek sz\u00e1m\u00e1t adja vissza, amelyek nagyobbak, mint 10, \u00e9s egy sz\u00e1m els\u0151 \u00e9s utols\u00f3 sz\u00e1mjegye p\u00e1ratlan (1, 3, 5, 7, 9). P\u00e9ld\u00e1ul: specialFilter (([15, -73, 14, -15]) => 1 specialFilter (([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Egy pozit\u00edv eg\u00e9sz sz\u00e1m n van. Egy eg\u00e9sz sz\u00e1m-m\u00e1trixot kell l\u00e9trehoznunk, amelynek hossza n. Minden i (1 \u2030\u00a4 i \u2030\u00a4 n) sz\u00e1m\u00e1ra a [i] = i * i - i + 1. Adja vissza az a h\u00e1rmasok sz\u00e1m\u00e1t (a [i], a [j], a [k]) ahol i < j < k, \u00e9s az a [i] + a [j] + a [k] a 3-as t\u00f6bbsz\u00f6r\u00f6se. P\u00e9ld\u00e1ul: bemenet: n = 5 kimenet: 1 magyar\u00e1zat: a = [1, 3, 7, 13, 21] Az egyetlen \u00e9rv\u00e9nyes h\u00e1rmas az (1, 7, 13).\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"\u00cdrjunk egy olyan f\u00fcggv\u00e9nyt, amely elfogadja a szalagok list\u00e1j\u00e1t param\u00e9ternek, t\u00f6rli a p\u00e1ratlan hossz\u00fas\u00e1g\u00fa szalagokat, \u00e9s rendezett sorrendben adja vissza az eredm\u00e9nyt. A lista mindig egy szalaglista, \u00e9s soha nem egy sz\u00e1mok t\u00f6mbje, \u00e9s lehet, hogy duplik\u00e1tumokat tartalmaz. A lista sorrendj\u00e9nek felfel\u00e9 kell emelkednie az egyes szavak hossz\u00fas\u00e1ga szerint, \u00e9s a list\u00e1t ennek a szab\u00e1lynak megfelel\u0151en kell rendezni. Ha k\u00e9t sz\u00f3 azonos hossz\u00fas\u00e1g\u00fa, sorolja a list\u00e1t alfabetikus sorrendben. A f\u00fcggv\u00e9nynek sorolt sorrendben kell visszaadnia a szalagok list\u00e1j\u00e1t. Felt\u00e9telezhetj\u00fck, hogy minden sz\u00f3 ugyanolyan hossz\u00fas\u00e1g\u00fa lesz. P\u00e9ld\u00e1ul: assert list_sort[\"aa\", \"a\", \"aaa\"]) => assert list_sort[\"\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Egy egyszer\u0171 program, amely visszaadja az x \u00e9rt\u00e9k\u00e9t, ha n pr\u00edmsz\u00e1m, \u00e9s m\u00e1sk\u00fcl\u00f6nben visszaadja az y \u00e9rt\u00e9k\u00e9t. P\u00e9ld\u00e1k: x_or_y(7, 34, 12) == 34 x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Azt hiszem, mindannyian eml\u00e9ksz\u00fcnk arra az \u00e9rz\u00e9sre, amikor egy r\u00e9g\u00f3ta v\u00e1rt esem\u00e9ny eredm\u00e9nye v\u00e9gre ismert. Az abban a pillanatban \u00e9rzett \u00e9rz\u00e9sek \u00e9s gondolatok biztosan \u00e9rdemes feljegyezni \u00e9s \u00f6sszehasonl\u00edtani. A feladatod az, hogy eld\u00f6ntsd, hogy egy szem\u00e9ly helyesen tal\u00e1lta-e ki a t\u00f6bb m\u00e9rk\u0151z\u00e9s eredm\u00e9ny\u00e9t. K\u00e9t egyenl\u0151 hossz\u00fas\u00e1g\u00fa pontsz\u00e1m \u00e9s tal\u00e1lgat\u00e1s t\u00e1rsult, ahol minden index egy m\u00e9rk\u0151z\u00e9st mutat. Visszaad egy azonos hossz\u00fas\u00e1g\u00fa t\u00e1rsulatot, amely jelzi, hogy milyen messze volt az egyes tippek. Ha helyesen tal\u00e1lt\u00e1k ki, az \u00e9rt\u00e9k 0, \u00e9s ha nem, az \u00e9rt\u00e9k a tipp \u00e9s a pontsz\u00e1m k\u00f6z\u00f6tti abszol\u00fat k\u00fcl\u00f6nbs\u00e9g. P\u00e9ld\u00e1ul: (([1,2,3,4,5,1],[1,2,3,4,2,]) -> [0,0,0,0,3,3] compare (([0,5,0,4,0,\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"A kiterjeszt\u00e9s ereje a k\u00f6vetkez\u0151: A CAP legyen a kiterjeszt\u00e9s nev\u00e9ben l\u00e9v\u0151 nagybet\u0171k sz\u00e1ma, \u00e9s az SM legyen a kiterjeszt\u00e9s nev\u00e9ben l\u00e9v\u0151 kisbet\u0171k sz\u00e1ma, az er\u0151 a CAP - SM t\u00f6red\u00e9kkel ad\u00f3dik. Meg kell tal\u00e1lnia a leger\u0151sebb kiterjeszt\u00e9st, \u00e9s egy olyan sort kell visszak\u00fcldeni, amely az al\u00e1bbi form\u00e1tumban jelenik meg: ClassName.StrongestExtensionName. Ha k\u00e9t vagy t\u00f6bb kiterjeszt\u00e9s azonos er\u0151vel rendelkezik, akkor azt kell v\u00e1lasztania, amelyik az els\u0151 a list\u00e1ban. P\u00e9ld\u00e1ul, ha \"Slices\" az oszt\u00e1lyk\u00e9nt \u00e9s a kiterjeszt\u00e9sek list\u00e1jak\u00e9nt: ['SEviviviSNGClies', 'Cheese', 'StuFfed'], akkor vissza kell adnia a 'Slices.SEviSNGClies' 'SviviSNGClies\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"K\u00e9t sz\u00f3 van megadva. Ha a m\u00e1sodik sz\u00f3 vagy b\u00e1rmelyik forgat\u00e1sa az els\u0151 sz\u00f3 all\u00e1nca, akkor a True \u00e9rt\u00e9k\u00e9t kell megadnia. cycpattern_check (((\"abcd\",\"abd\") => False cycpattern_check (((\"hello\",\"ell\") => True cycpattern_check (((whassup\",\"psus\") => False cycpattern_check (((abab\",\"baa\") => True cycpattern_check (((\"efef\",\"eeff\") => False cycpattern_check (((hims\",\"simen\") => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Egy eg\u00e9sz sz\u00e1m megad\u00e1sa eset\u00e9n egy p\u00e1ros \u00e9s p\u00e1ratlan sz\u00e1mjegyeket tartalmaz\u00f3 tuplust ad vissza. P\u00e9ld\u00e1ul: p\u00e1ros_egyenetlen_sz\u00e1m(-12) ==> (1, 1) p\u00e1ros_egyenetlen_sz\u00e1m(123) ==> (1, 2)\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Ha pozit\u00edv eg\u00e9sz sz\u00e1mot kapunk, szerezz\u00fck meg a r\u00f3mai sz\u00e1mok egyen\u00e9rt\u00e9k\u00e9t egy string form\u00e1j\u00e1ban, \u00e9s k\u00fcldj\u00fck vissza kisbet\u0171vel.\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"\u00cdrjunk egy olyan funkci\u00f3t, amely elfogadja a szalagok list\u00e1j\u00e1t. A lista k\u00fcl\u00f6nb\u00f6z\u0151 szavakat tartalmaz. Visszaadja a sz\u00f3t, amely a legmagasabb sz\u00e1m\u00fa egyedi karakterrel rendelkezik. Ha t\u00f6bb szalagban van a legmagasabb sz\u00e1m\u00fa egyedi karakter, adja vissza azt, amelyik a lexikogr\u00e1fiai sorrendben az els\u0151.\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Te egy \u00e9hes ny\u00fal vagy, \u00e9s m\u00e1r ett\u00e9l egy bizonyos sz\u00e1m\u00fa r\u00e9p\u00e1t, de most m\u00e9g t\u00f6bb r\u00e9p\u00e1t kell enned, hogy befejezd a napi \u00e9tkez\u00e9st. Adj vissza egy [ teljes sz\u00e1m\u00fa elfogyasztott r\u00e9p\u00e1t \u00e9tkez\u00e9s ut\u00e1n, a marad\u00e9k r\u00e9p\u00e1k sz\u00e1ma \u00e9tkez\u00e9s ut\u00e1n ] matric\u00e1t, ha nincs el\u00e9g marad\u00e9k r\u00e9p\u00e1t, akkor megeszed az \u00f6sszes marad\u00e9k r\u00e9p\u00e1t, de m\u00e9g mindig \u00e9hes leszel. P\u00e9ld\u00e1ul: * enni ((5, 6, 10) -> [11, 4] * enni ((4, 8, 9) -> [12, 1] * enni ((1, 10, 10) -> [11, 0] * enni ((2, 11, 5) -> [7, 0] Variablek: @sz\u00e1m: eg\u00e9sz sz\u00e1m\u00fa r\u00e9p\u00e1t, amit ett\u00e9l. @sz\u00fcks\u00e9glet: eg\u00e9sz sz\u00e1m\u00fa r\u00e9p\u00e1t, amit meg kell enni. @marad\u00e9k: eg\u00e9sz sz\u00e1m\u00fa marad\u00e9k r\u00e9p\u00e1t a k\u00e9szletben.\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Az els\u0151 list\u00e1ban az alap algebrai m\u0171veletek vannak, a m\u00e1sodik list\u00e1ban pedig a teljes sz\u00e1mok list\u00e1ja. Haszn\u00e1lja a k\u00e9t list\u00e1t az algebrai kifejez\u00e9s l\u00e9trehoz\u00e1s\u00e1hoz \u00e9s adja vissza a kifejez\u00e9s \u00e9rt\u00e9k\u00e9t. Az alap algebrai m\u0171veletek: \u00d6sszead\u00e1s (+) Levon\u00e1s (- ) Szoroz\u00e1s (*) L\u00e9pcs\u0151oszt\u00e1s (\/\/) K\u00e9pes\u00edt\u00e9s (**) P\u00e9ld\u00e1ul: oper\u00e1tor['+', '*', '-'] t\u00f6mb = [2, 3, 4, 5] eredm\u00e9ny = 2 + 3 * 4 - 5 => eredm\u00e9ny = 9 Megjegyz\u00e9s: Az oper\u00e1torok list\u00e1j\u00e1nak hossza egyenl\u0151 az operand list\u00e1j\u00e1nak hossza m\u00ednusz egy. Az operand nem negat\u00edv eg\u00e9sz sz\u00e1mok list\u00e1ja. Az oper\u00e1tornak legal\u00e1bb egy oper\u00e1tor list\u00e1ja van, \u00e9s az operand list\u00e1nak legal\u00e1bb k\u00e9t operandja van.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Ha a s[i] egy bet\u0171, ford\u00edtsa a bet\u0171t az als\u00f3 bet\u0171t\u0151l a fels\u0151 bet\u0171ig, vagy ford\u00edtva, m\u00e1sk\u00fcl\u00f6nben tartsa meg. Ha a string nem tartalmaz bet\u0171ket, ford\u00edtsa meg a stringet. A f\u00fcggv\u00e9nynek vissza kell adnia az eredm\u00e9nyt. P\u00e9ld\u00e1k megold\u00e1s ((\"1234\") = \"4321\" megold\u00e1s ((\"ab\") = \"AB\" megold\u00e1s ((\"#a@C\") = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Ha a 'text' egy \u00fcres karakterl\u00e1nc, akkor a None \u00e9rt\u00e9ket adja vissza.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    K\u00e9t pozit\u00edv eg\u00e9sz sz\u00e1m a \u00e9s b eset\u00e9n a \u00e9s b k\u00f6z\u00f6tti p\u00e1ros sz\u00e1mjegyeket emelked\u0151 sorrendben adja vissza. P\u00e9ld\u00e1ul: generate_integers ((2, 8) => [2, 4, 6, 8] generate_integers ((8, 2) => [2, 4, 6, 8] generate_integers ((10, 14) => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]