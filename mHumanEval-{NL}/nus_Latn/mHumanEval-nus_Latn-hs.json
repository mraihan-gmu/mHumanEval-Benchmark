[{"task_id":"HumanEval_0","nl":"nus_Latn","pl":"hs","prompt":"--pek in ca ŋun.--Ɣɔ̱ɔ̱n, guic ɛni̱ mi̱ tekɛ nämbäri̱ ti̱ thi̱ääk ti̱ röm kɛn rɔ̱ ɛ läny kɛn nämbäri̱ ti̱ ca ŋun ɛ la nämbäri̱ ti̱ ŋuan.--  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =","canonical_solution":"hasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold = any (\\(x,y) -> abs (x - y) < threshold) [(a, b) | a <- numbers, b <- numbers, a \/= b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_1","nl":"nus_Latn","pl":"hs","prompt":"--\/Cu wargakni̱ tin te kamdiɛn rɛy inpuɔɔth i̱thti̱riŋä.--Bun ti̱ gööl la kɛn rɔ̱ laa pa̱a̱rkɛ (kä bi̱ ramɔ rɔ gaŋ kɛ mi̱ caa rɔ̱ yiath piny) kä \/ci̱kɛ rɔ̱ laa mat kɛɛl.--la̱thkɛ buɔ̱n ɛ tɔ̱ kɛ rɛy thärkäni̱ ti̱ gööl kä locni̱ li̱thdiɛn.--inpuot kɛ la̱t ɛmɛ ɛ thi̱ŋdɛ kɛ bun ti̱ ŋuan ti̱ ca mat kɛ parentheses.--  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =","canonical_solution":"separateParenGroups :: String -> [String]\nseparateParenGroups paren_string = go paren_string 0 [] \"\" []\n  where\n    go [] _ _ current acc = if null current then acc else acc ++ [current]\n    go (x:xs) depth stack current acc\n      | x == ' ' = go xs depth stack current acc\n      | x == '(' = go xs (depth + 1) ('(':stack) (current ++ [x]) acc\n      | x == ')' =\n          let newCurrent = current ++ [x]\n              newDepth = depth - 1\n          in if newDepth == 0\n             then go xs newDepth (tail stack) \"\" (acc ++ [newCurrent])\n             else go xs newDepth (tail stack) newCurrent acc\n      | otherwise = error \"Unexpected character\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_2","nl":"nus_Latn","pl":"hs","prompt":"--Lɔ̱a̱rkɛ pek in ca ŋun ɛ nämbär.--(cu tha̱a̱ŋdɛ min ci̱ duɔth ɛ mi̱ tɔt ni̱ ciaaŋ mi̱ kuiy ni̱ jɛn kä 1).--kä inteji̱ɛr (inteji̱ɛr in di̱tni̱ jɛn kä kuiy ni̱ jɛn kä nämbär in ca ŋun) kɛnɛ deci̱malni̱ --Mi̱ ca jɛ ŋun ɛ la mi̱ tekɛ po̱jitib floating point nämbär, jɛn ba cu riali̱kä piny ɛ la --  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =","canonical_solution":"truncateNumber :: Float -> Float\ntruncateNumber number = number - fromIntegral (floor number)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_3","nl":"nus_Latn","pl":"hs","prompt":"--kä ɛn gua̱a̱th ɛmɔ pa̱ŋciin bɛ yi̱k loc i̱ thuɔ̱k. mi̱ \/ci̱ mɔ ɛ jɛn bɛ yi̱k loc i̱ kac.--kä mi̱ ci̱ thöp-du-piny ɛ ɣöö bi̱ ji̱ek mi̱ ci̱ thöp-du-piny ɛ wä piny kä dhɛrö, kä --Bi̱ ji̱ moc kɛ li̱th duŋ depödhi̱öt kɛnɛ pɛthtöri̱ kä ba̱nk account min bi̱ tuɔk kɛ --  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =","canonical_solution":"belowZero :: [Int] -> Bool\nbelowZero operations = any (< 0) $ scanl (+) 0 operations","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_4","nl":"nus_Latn","pl":"hs","prompt":"--MAD = average.  -     --ɛlɛmɛni̱ kɛnɛ däär (rɛy kä mɛmɛ): --Mean Absolute Deviation ɛ jɛn in te dääk kamdiɛn --kɛ gua̱th mi̱ ci̱e̱e̱ kɛ gua̱th in tä databɛt thi̱n.--Kɛ kui̱ kä min ca ŋun kä nämbäri̱ tin ca ŋun, kuɛn Mean Absolute Deviation.--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =","canonical_solution":"meanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers = sum absoluteDifferences \/ fromIntegral (length numbers)\n  where\n    mean = sum numbers \/ fromIntegral (length numbers)\n    absoluteDifferences = map (\\x -> abs (x - mean)) numbers","tests":"\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_5","nl":"nus_Latn","pl":"hs","prompt":"--ɛ̈ɛ̈ŋ nämbär 'delimɛtɛr' kam kä tin guɔ̱rkɛrɔ̱ ɛlɛmɛni̱ tin te rɛy läätdä ∀number' --  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =","canonical_solution":"intersperse :: [Int] -> Int -> [Int]\nintersperse [] _ = []\nintersperse [x] _ = [x]\nintersperse (x:xs) delimeter = x : delimeter : intersperse xs delimeter","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_6","nl":"nus_Latn","pl":"hs","prompt":"--C.d. (() (()) tekɛ ti̱ ŋuan ti̱ ŋuan ti̱ ci̱ rɔ̱ mat gua̱th kɛl kä ((())) tekɛ diɔ̱k. --Kɛ kui̱ bunä kɛl, ka̱m raar ni̱bɛl in te piny ɛlɔ̱ŋ kä ca la̱th kɛ kam pa̱rkɛthɛthä.--ëë ji̱o̱liɛn kɛ la̱t ɛmɛ ɛ la̱t mi̱ cuŋ kɛ kui̱ bunä ti̱ ŋuan kɛ kui̱ kä tin ca da̱a̱k ɛ parɛthethi̱th mi̱ ca da̱a̱k ɛ kamni̱.--  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =","canonical_solution":"parseNestedParens :: String -> [Int]\nparseNestedParens paren_string = map maxDepth (words paren_string)\n  where\n    maxDepth :: String -> Int\n    maxDepth = go 0 0\n      where\n        go :: Int -> Int -> String -> Int\n        go currentDepth maxDepth [] = maxDepth\n        go currentDepth maxDepth (c:cs)\n          | c == '('  = go (currentDepth + 1) (max currentDepth maxDepth) cs\n          | c == ')'  = go (currentDepth - 1) maxDepth cs\n          | otherwise = go currentDepth maxDepth cs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_7","nl":"nus_Latn","pl":"hs","prompt":"--ilter ɛ mi̱ la̱thkɛ rɛy li̱thä min te rɛy thärkithä ɛ la tin te rɛy thärkithä min ca ŋun--  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =","canonical_solution":"filterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring = filter (substring `isInfixOf`) strings\n  where isInfixOf = isInfixOf","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_8","nl":"nus_Latn","pl":"hs","prompt":"--Ɛni̱ mi̱\/thiɛl luɔt bɛ dhil pa̱a̱r kɛ 0 kɛnɛ ɣöö bi̱ min ca nööŋ ɛ mi̱\/thiɛl luɔt bɛ dhil pa̱a̱r kɛ 1.--ëë ci̱ li̱th intejeri̱ thöp, locni̱ tuple mi̱ tekɛ mat kɛnɛ ɣöö ba kulɛ nööŋ ɛ la mi̱ ca la̱t ɛ intejeri̱ diaal rɛy li̱thä.--  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =","canonical_solution":"sumProduct :: [Int] -> (Int, Int)\nsumProduct numbers = (sum numbers, product numbers)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_9","nl":"nus_Latn","pl":"hs","prompt":"--kɛ gua̱th mi̱ ci̱ rɔ̱ lot.--Mi̱ ca ŋun ɛ la mi̱ caa lɛl ɛ la mi̱ caa mat kä intɛrjiɛri̱, ba mi̱ caa lɛl ɛ la mi̱ caa mat kä ɛlɛmɛni̱ tin caa jek ɛ la tin di̱t ɛlɔ̱ŋ ɛ wɔ̱ ni̱ wal.--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =","canonical_solution":"rollingMax :: [Int] -> [Int]\nrollingMax = scanl1 max","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_10","nl":"nus_Latn","pl":"hs","prompt":"--- Ji̱n bi̱ yi̱k la̱th kä guutdɛ kɛ min ca la̱t ɛ la mi̱ ci̱ rɔ gɛɛr kä bi̱ ben ɛ la mi̱ ci̱ rɔ gɛɛr kä bi̱ ben ɛ la palindromic suffix.--- Ji̱n bi postfix in bäär kä ci̱ duɔth ɛ la palindrɔm jek.--Alɣo̱ri̱thi̱m cärɛ ɛ mi̱ thi̱a̱k: --ɛ̈n palindrɔm in ciɛk ciɛk in took rɔ kɛ ciɛk in ca ŋun.--  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =","canonical_solution":"makePalindrome :: String -> String\nmakePalindrome string = string ++ reverse (take (length string - palindromeLength) string)\n  where\n    palindromeLength = longestPalindromicSuffix string\n\nlongestPalindromicSuffix :: String -> Int\nlongestPalindromicSuffix str = maximum [l | l <- [0..length str], isPalindrome (drop l str)]\n\nisPalindrome :: String -> Bool\nisPalindrome s = s == reverse s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_11","nl":"nus_Latn","pl":"hs","prompt":"--Lätni̱ bainäri̱ XOR kä tin ca la̱th kä bi̱ ben raar ɛ la ti̱ ca gɔ̱r ɛ la ti̱ ŋuan.--inpuut ɛ rɛw ti̱ la̱tkɛ ɛ a kɛnɛ b ti̱ tekɛ 1 kɛnɛ 0 kärɔ̱.--  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =","canonical_solution":"stringXor :: String -> String -> String\nstringXor a b = [if x == y then '0' else '1' | (x, y) <- zip a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_12","nl":"nus_Latn","pl":"hs","prompt":"--Mi̱ ci̱ li̱th in caa kuëŋ thi̱n \/ci̱ɛɛ jɛn, \/ci̱ɛɛ jɛn bi̱ loc.--Mi̱ ci̱kɛ ti̱ ŋuan, bi̱kɛ lɛ loc ni̱ kɛl in bär ni̱ jɛn.--  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =","canonical_solution":"longest :: [String] -> Maybe String\nlongest [] = Nothing\nlongest strings = Just $ foldl1 (\\acc x -> if length x > length acc then x else acc) strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_13","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ ɛ la min di̱tni̱ jɛn kä dääk kä intejeri̱ rɛw a kɛnɛ b --  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =","canonical_solution":"greatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b\n  | b == 0    = a\n  | otherwise = greatestCommonDivisor b (a `mod` b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_14","nl":"nus_Latn","pl":"hs","prompt":"--ëë cɛ li̱th duŋ prepi̱dhɛkni̱ diaal luɔ̱c ɛ tokɛ kä mi̱ ciɛk ɛ wä kä mi̱ bäär kä inpuɔth thi̱rɛnd --  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =","canonical_solution":"allPrefixes :: String -> [String]\nallPrefixes string = [take n string | n <- [1 .. length string]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_15","nl":"nus_Latn","pl":"hs","prompt":"--ëë ci̱kɛ loc ɛ la mi̱ tekɛ nämbäri̱ ti̱ ca lɛy ɛ räth kä 0 ɛ wä kä n ɛ matkɛ.--  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =","canonical_solution":"stringSequence :: Int -> String\nstringSequence n = unwords $ map show [0..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_16","nl":"nus_Latn","pl":"hs","prompt":"--Mi̱ ca ji̱ ka̱m i̱thtirind, görɛ jɛ i̱ ɛ pek in di̱i̱t i̱di̱ (ɛ\/ci̱kɛ bi̱ te rɛy gua̱th in ca ji̱ ka̱m i̱thtirind) kä bi̱ kɛn te thi̱n.--  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =","canonical_solution":"import Data.Char (toLower)\nimport Data.Set (fromList, size)\n\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string = size . fromList $ map toLower string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_17","nl":"nus_Latn","pl":"hs","prompt":"--'Hajɛ' - quater note, bɛ thɛm kɛ gua̱a̱th mi̱ tɔt.--'o Saji' - tha̱a̱ŋ no̱o̱tni̱, la duɔthkɛ ni̱ kä rɛw.--'o' - no̱o̱ŋ kɛɛliw, bɛ ŋot kɛ mi̱ cɛ wɔ̱ ni̱ kä ŋuaan.--Nɛmɛ ɛ jɛn ruac ëë wal:--\/ci̱kɛ jɔak.--La̱tdu ɛ ɣöö bi̱ kɛ kuɛn kä bi̱ kɛ lɛ loc ɛ la li̱th duŋ intejeri̱ tin luɔtkɛ rɔ̱ kɛ pek in bi̱ kɛ wɔ̱ kɛ kɛl.--inpuot kɛ la̱t ɛmɛ ɛ thärk mi̱ cuŋ kɛ no̱o̱ŋni̱ kɛ ca̱a̱p ti̱ gööl kä ASCII. --  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =","canonical_solution":"parseMusic :: String -> [Int]\nparseMusic music_string = map beats (words music_string)\n  where\n    beats \"o\" = 4\n    beats \"o|\" = 2\n    beats \".|\" = 1\n    beats _ = 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_18","nl":"nus_Latn","pl":"hs","prompt":"--Ŋäc ni pek in ci rɔ lot kɛ duɔr kä ci rɔ lot kɛ duɔr in ci rɔ lot kɛ duɔr in dɔ̱ŋ--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =","canonical_solution":"howManyTimes :: String -> String -> Int\nhowManyTimes string substring\n  | null substring = 0\n  | otherwise = length . filter isPrefixOfSubstring $ tails string\n  where\n    isPrefixOfSubstring = isPrefixOf substring\n    isPrefixOf :: Eq a => [a] -> [a] -> Bool\n    isPrefixOf prefix str = prefix `isPrefixOf` str","tests":"\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_19","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ jɔk kä nämbäri̱ ti̱ ca riali̱kä kä tin tɔatni̱ ɛ wɔ̱ ni̱ kä tin di̱t --Thurɛ tin lät kɛn kɛ 'dhɛrö', 'kɛl', ' rɛw', 'diɔ̱k', 'ŋuaan', 'li̱e̱c', 'dath', ' bärɔw', 'bärɔw' kɛnɛ 'ŋuɔ̱k'.--Input ɛ mi̱ ca lɛy ɛ nämbäri̱ tin la̱thkɛ rɛy gua̱th ɛ tokɛ kä dhɛrö ɛ wä kä dhɛrö ɛ wä kä dhɛ̈ɛ̈ŋ.--  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =","canonical_solution":"import Data.List (sort)\nimport Data.Maybe (fromJust)\nimport Data.Map (Map, fromList, lookup)\n\nsortNumbers :: String -> String\nsortNumbers numbers = unwords $ map snd $ sort $ map (\\w -> (fromJust $ lookup w wordToNumber, w)) (words numbers)\n  where\n    wordToNumber :: Map String Int\n    wordToNumber = fromList [(\"zero\", 0), (\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4),\n                             (\"five\", 5), (\"six\", 6), (\"seven\", 7), (\"eight\", 8), (\"nine\", 9)]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_20","nl":"nus_Latn","pl":"hs","prompt":"--Kä cu kɛn tin kɔ̱ŋ cu loc kɛ duɔ̱ɔ̱p mi̱ (mi̱ tɔt, mi̱ di̱i̱t).--◯ Kä li̱th nämbäri̱ tin ca ŋun (kɛ pek mi̱ kuiy ni̱ kɛn kä rɛw) kuany kɛnɛ locni̱ rɛw tin thia̱k kɛ kɛl --  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =","canonical_solution":"findClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers = head . foldr1 minByDiff $ zip sortedNumbers (tail sortedNumbers)\n  where\n    sortedNumbers = sort numbers\n    minByDiff (a1, b1) (a2, b2)\n      | abs (a1 - b1) < abs (a2 - b2) = (a1, b1)\n      | otherwise = (a2, b2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_21","nl":"nus_Latn","pl":"hs","prompt":"--kɛ ɣöö bi̱ nämbär in kuiy ni̱ jɛn kä bɛc bɛ ben ɛ 0 kɛnɛ ɣöö bi̱ nämbär in di̱t ni̱ jɛn bɛ ben ɛ 1 --Mi̱ ca ŋun ɛ la li̱th nämbäri̱ (kɛ ɛlɛmɛni̱ rɛw), la̱th li̱ni̱e̱e̱r tra̱ni̱thpörm kä li̱th ɛmɔ, --  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =","canonical_solution":"rescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers = map (\\x -> (x - minVal) \/ range) numbers\n  where\n    minVal = minimum numbers\n    maxVal = maximum numbers\n    range = maxVal - minVal","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_23","nl":"nus_Latn","pl":"hs","prompt":"--ëë ci̱ duäc in ca ŋun ɛ la mi̱ ci̱ rɔ lot --  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =","canonical_solution":"strlen :: String -> Int\nstrlen string = length string","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_24","nl":"nus_Latn","pl":"hs","prompt":"--Kɛ kui̱ nämbäri̱ ti̱ n, gör nämbäri̱ tin di̱t tin bi̱ n da̱a̱k ɛ päär, tin kuiyni̱kɛn kä n.--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =","canonical_solution":"largestDivisor :: Int -> Int\nlargestDivisor n = head [ x | x <- [n-1, n-2..1], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_25","nl":"nus_Latn","pl":"hs","prompt":"--Input number ba päär kɛ min ca pith kä ŋɔak diaal tin ca la̱t --Kɛn ŋɔak diaal tin caa la̱th piny bi̱ kɛ rɔ̱ cu mat kä pek in ci̱kɛ jɔɔc rɛy kä tin caa la̱th piny.--ëë ci̱ lɛl ɛ la mi̱ ca lɛl ɛ la mi̱ ca la̱th kä prämim paktɔri̱ kä intɛrjɛr min ca ŋun kä min tɔt ɛ wä kä min di̱i̱t.--  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =","canonical_solution":"factorize :: Int -> [Int]\nfactorize n = factorize' n 2\n  where\n    factorize' 1 _ = []\n    factorize' m f\n      | m `mod` f == 0 = f : factorize' (m `div` f) f\n      | otherwise      = factorize' m (f + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_26","nl":"nus_Latn","pl":"hs","prompt":"--Guic ni̱ min ca la̱t kɛ kui̱ kä tin ca la̱th piny.--ëë ɛ li̱th duŋ intejeri̱, woc ɛlɛmɛni̱ diaal tin ci̱ tuɔɔk ni̱ kä kɛɛl.--  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =","canonical_solution":"removeDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers = filter (\\x -> count x numbers == 1) numbers\n  where\n    count x = length . filter (== x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_27","nl":"nus_Latn","pl":"hs","prompt":"--ä mi ca ŋun, locni̱kɛ kɛ piny kä bi̱kɛ cuɔt kä min di̱t kɛnɛ min di̱t.--  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =","canonical_solution":"flipCase :: String -> String\nflipCase = map flipChar\n  where\n    flipChar c\n      | c >= 'a' && c <= 'z' = toEnum (fromEnum c - 32)\n      | c >= 'A' && c <= 'Z' = toEnum (fromEnum c + 32)\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_28","nl":"nus_Latn","pl":"hs","prompt":"--ɛ̈ɛ̈r kɛ kuën kä tin ca gɔ̱r kä ɛ kɛl ɛ̈ɛ̈r kɛ kuën kä tin ca gɔ̱r kä ɛ kɛl--  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =","canonical_solution":"concatenate :: [String] -> String\nconcatenate strings = concat strings","tests":"\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_29","nl":"nus_Latn","pl":"hs","prompt":"--ltr ɛ mi̱ la̱thkɛ rɛy li̱thä min te kɛn thi̱rndɛrni̱ thi̱n kɛ kui̱ kä tin tokɛ rɔ̱ kɛ prepi̱dhɛth mi̱ ca ŋun. --  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =","canonical_solution":"filterByPrefix strings prefix = filter (isPrefixOf prefix) strings\n  where\n    isPrefixOf pfx str = take (length pfx) str == pfx","tests":"\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_30","nl":"nus_Latn","pl":"hs","prompt":"--ëë ci̱ kɔnɛ lɛ loc ni̱ nämbäri̱ tin te rɛy li̱thä.--  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =","canonical_solution":"getPositive :: [Int] -> [Int]\ngetPositive l = filter (> 0) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_31","nl":"nus_Latn","pl":"hs","prompt":"--Mi̱ ca ŋun ɛ nämbär mi̱ ca ŋun ɛ la praam, bɛ loc ni̱ thuɔ̱k, kä mi̱ ca ŋun ɛ mi̱ \/ci̱ mɔ a thuɔ̱k.--  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =","canonical_solution":"isPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = not (any (\\x -> n `mod` x == 0) [3,5..floor (sqrt (fromIntegral n))])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_33","nl":"nus_Latn","pl":"hs","prompt":"--Kä cua kɛ la̱th kä ta̱a̱ in ca lat ɛ la mi̱ ca mat kä indi̱i̱ci̱ni̱ tin ca mat kä l, duŋni̱ ɣöö cua kɛ da̱a̱k.--l' päärɛ kɛ l kä indi̱ci̱ni̱ tin \/ca de da̱a̱k ɛ diɔ̱k, kä bi̱ tin te thi̱n kä indi̱ci̱ni̱ tin de da̱a̱k ɛ diɔ̱k pa̱a̱r.--La̱t ɛmɛ naŋɛ li̱th l kä bɛ l lɔɔd l mi̱ ce̱tkɛ jɛn--  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =","canonical_solution":"sortThird :: [Int] -> [Int]\nsortThird l = map selectElem indexed\n  where\n    indexed = zip [0..] l\n    thirdIndicesElems = [elem | (i, elem) <- indexed, i `mod` 3 == 0]\n    sortedThirdElems = sortedElems thirdIndicesElems\n    sortedElems = id -- or List.sort if imported\n    selectElem (i, x)\n      | i `mod` 3 == 0 = head sortedThirdElems\n      | otherwise = x\n    replaceSortedElem xs sorted = map selectElem indexed\n      where\n        replaceElem i (x:xs)\n          | i == 0 = x:xs\n          | otherwise = replaceElem (i - 1) xs\n        selectElem (i, x)\n          | i `mod` 3 == 0 = head (replaceElem (i `div` 3) sortedThirdElems)\n          | otherwise = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_34","nl":"nus_Latn","pl":"hs","prompt":"--Lätni̱kɛ ɛlɛmɛni̱ tin ca riali̱kä rɛy li̱thä--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =","canonical_solution":"unique :: [Int] -> [Int]\nunique l = sort $ nub l\n  where\n    -- | Remove duplicate elements from a list.\n    nub :: (Eq a) => [a] -> [a]\n    nub [] = []\n    nub (x:xs) = x : nub (filter (\/= x) xs)\n\n    -- | Sort a list of elements (using QuickSort algorithm).\n    sort :: (Ord a) => [a] -> [a]\n    sort [] = []\n    sort (x:xs) =\n      let smallerSorted = sort [a | a <- xs, a <= x]\n          biggerSorted = sort [a | a <- xs, a > x]\n      in  smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_35","nl":"nus_Latn","pl":"hs","prompt":"--│ Luɔ̱cdɛ kɛ min di̱tni̱ jɛn kä ti̱ ŋuan rɛy li̱thä. │--  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =","canonical_solution":"maxElement :: [Int] -> Int\nmaxElement [] = error \"List cannot be empty\"\nmaxElement (x:xs) = maxElementHelper xs x\n  where\n    maxElementHelper [] currentMax = currentMax\n    maxElementHelper (y:ys) currentMax = maxElementHelper ys (max y currentMax)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_36","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ ni̱ nämbär in ci̱ 7 jɔɔc rɛy intejeri̱ tin kuiyni̱kɛn kä n tin de da̱a̱k kɛ 11 kiɛ 13.--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =","canonical_solution":"fizzBuzz :: Int -> Int\nfizzBuzz n = length [x | x <- [1..n-1], (x `mod` 11 == 0 || x `mod` 13 == 0), '7' `elem` show x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_37","nl":"nus_Latn","pl":"hs","prompt":"--Kä ɛni̱ mi̱ ca riali̱kä ɛ la mi̱ ca mat kä ɛni̱ mi̱ ca mat kä ɛni̱ mi̱ te kɛɛl kä ɛni̱ mi̱ te kɛɛl.--l' päärɛ kɛ l kä indi̱ci̱ni̱ tin \/ci̱ tɔt, niɛ gua̱a̱ mɔ bi̱ tin te thi̱n kä indi̱ci̱ni̱ tin \/ci̱ tɔt päär --La̱t ɛmɛ naŋɛ li̱th l kä bɛ l lɔɔd l mi̱ ce̱tkɛ jɛn--  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =","canonical_solution":"sortEven :: [Int] -> [Int]\nsortEven l = merge odds sortedEvens\n  where\n    (odds, evens) = partitionList l\n    sortedEvens = sort evens\n\n    partitionList :: [Int] -> ([Int], [Int])\n    partitionList [] = ([], [])\n    partitionList [x] = ([x], [])\n    partitionList (x:y:xs) = (x:xsOdds, y:xsEvens)\n      where\n        (xsOdds, xsEvens) = partitionList xs\n\n    merge :: [Int] -> [Int] -> [Int]\n    merge [] ys = ys\n    merge (x:xs) [] = x:xs\n    merge (x:xs) (y:ys) = x:y:merge xs ys","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_39","nl":"nus_Latn","pl":"hs","prompt":"--prime_fib la̱tdɛ nämbärä min la n-th kä ɛ nämbär Fibönakci kä jɛn bä ɛ praim.--  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =","canonical_solution":"primeFib :: Int -> Int\nprimeFib n = primeFibs !! (n - 1)\n  where\n    primeFibs = filter isPrime fibs\n    fibs = map fst $ iterate (\\(a, b) -> (b, a + b)) (0, 1)\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2 = False\n  | k == 2 = True\n  | even k = False\n  | otherwise = null [x | x <- [3,5..upperLimit], k `mod` x == 0]\n  where\n    upperLimit = floor . sqrt $ fromIntegral k","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_40","nl":"nus_Latn","pl":"hs","prompt":"--matkɛ ni̱ dhɛrö, kɛnɛ mi̱ \/ci̱kɛ thuɔ̱k.--la loc ɛ thuɔ̱k mi̱ tëë kɛ ŋɔak da̱ŋ diɔ̱k ti̱ gööl rɛy li̱thä min bi̱ --_triple_sum_to_zero la naŋɛ li̱th intejeri̱ ɛ la mi̱ ca la̱th rɛy. --  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =","canonical_solution":"triplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l = any (== 0) [x + y + z | (x:ys) <- tails l, (y:zs) <- tails ys, z <- zs]\n  where\n    tails [] = []\n    tails xs@(_:xs') = xs : tails xs'","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_41","nl":"nus_Latn","pl":"hs","prompt":"--Ɛn pa̱ŋciin ɛmɛ bɛ pek in ci̱ ben raar kä tin ci̱ rɔ̱ röm thi̱n nööŋ.--kɛ duɔ̱ɔ̱p in ci̱ kɛ wɔ̱ kɛ jɛ, ce̱tkɛ mi̱ \/ken kɛn rɔ̱ ku lɛ röm.--Duŋdɛ ɣöö, kɛn thurbiɛli̱ tin la̱tkɛ ɛ naath bumɛ ɛlɔ̱ŋ, kä ɛ jɛn in jak kɛ kä jälkɛ.--Mi̱ ci̱ thurbil mi̱ jäl caam kä cuec bɛ röm kɛ thurbil mi̱ jäl cuec kä caam.--Kɛn thurbiɛli̱ diaal jälkɛ kɛ pek mi̱ päär. Kɛn thurbiɛli̱ da̱ŋ rɛw la kɛn a la̱tkɛ ɛ la ti̱ bi̱ rɔ̱ kuɛl.--Ɛn ɣöö baa kɛ kulɛ woc ɛ la̱a̱t tin kɔ̱ŋ tin laa jäl kɛ kui̱i̱ ca̱ŋ ɛ la tin kɔ̱ŋ.--Ɛn thurbil n bɛ wä caam kä bɛ wä cuëëc; kɛ jɛn gua̱a̱th ɛmɔ, bi̱ thurbilni̱ ti̱ ŋuan ti̱ gööl rɔ̱ cu tok.--Ti̱ti̱ kɛ dup ti̱ \/ci̱ rɔ̱ dee luäŋ kɛ yor piny.carRaceCollision :: Int -> Int\ncarRaceCollision n =","canonical_solution":"carRaceCollision :: Int -> Int\ncarRaceCollision n = n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_42","nl":"nus_Latn","pl":"hs","prompt":"--Lätni̱ kɛ ɛlɛmɛni̱ ti̱ ci̱ rɔ̱ rep ɛ la 1.--  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =","canonical_solution":"incrList :: [Int] -> [Int]\nincrList l = map (+1) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_43","nl":"nus_Latn","pl":"hs","prompt":"--matkɛ ni̱ dhɛrö, kɛnɛ mi̱ \/ci̱kɛ thuɔ̱k.--la loc ɛ la thuɔ̱k mi̱ tëë kɛ rɛw ti̱ gööl rɛy li̱thä min bi̱ --Pairs_sum_to_zero la naŋɛ ni̱ li̱th intejeri̱ cie mi̱ ɛ mi̱ ca la̱th rɛy.--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =","canonical_solution":"pairsSumToZero :: [Int] -> Bool\npairsSumToZero l = any (\\x -> -x `elem` l) l && (length l > 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_44","nl":"nus_Latn","pl":"hs","prompt":"--pek in te piny kä 10--locni̱ min ca la̱t kɛ kui̱ kä min ca locni̱kɛ.--ɛ gɛr nämerikal baath kä inpuut nämbär x kɛ baath. --  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =","canonical_solution":"changeBase :: Int -> Int -> String\nchangeBase x base\n  | x < base  = show x\n  | otherwise = changeBase (x `div` base) base ++ show (x `mod` base)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_45","nl":"nus_Latn","pl":"hs","prompt":"--ëë ci̱ wä bäär kä ɛ jɛn gua̱a̱th in ci̱ rɔ loc thi̱n kä di̱ɔ̱k.--  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =","canonical_solution":"triangleArea :: Int -> Int -> Float\ntriangleArea a h = 0.5 * fromIntegral a * fromIntegral h","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_46","nl":"nus_Latn","pl":"hs","prompt":"--Gɔ̱r pa̱ŋciin mi̱ bi̱ lät kɛ ɣöö ba pek ɛ la n-th kä ɛlɛmɛni̱ kä fib4 nämbäri̱ tin guɔ̱ɔ̱rkɛ rɔ̱. \/Cu rɔ̱ nyɔk kɛ lätni̱.--fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).--fib4(3) -> 0 --fib4(2) -> 2 --fib4(1) -> 0 --fib4(0) -> 0 --Kä Fib4 nämbär thekuɛnthi̱ ɛ thekuɛnthi̱ mi̱ cäät kɛ Fibbonacci thekuɛnthi̱ min ca lat i̱:--  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =","canonical_solution":"fib4 :: Int -> Int\nfib4 n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 2\n  | n == 3 = 0\n  | otherwise = iter 0 0 2 0 n\n  where\n    iter a b c d 4 = a + b + c + d\n    iter a b c d n = iter b c d (a + b + c + d) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_47","nl":"nus_Latn","pl":"hs","prompt":"--│ Luɔ̱cdɛ kɛ mediaan kä elɛmɛni̱ rɛy li̱thä l. │--  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =","canonical_solution":"median :: [Int] -> Float\nmedian l \n  | odd n     = fromIntegral $ sorted !! mid\n  | otherwise = (fromIntegral (sorted !! (mid - 1)) + fromIntegral (sorted !! mid)) \/ 2\n  where\n    sorted = sort l\n    n = length l\n    mid = n `div` 2\n    sort = sortBy compare","tests":"\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_48","nl":"nus_Latn","pl":"hs","prompt":"--ëë guic mi̱ ca ŋun ɛ la pa̱li̱ndrɔm--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =","canonical_solution":"isPalindrome :: String -> Bool\nisPalindrome text = text == reverse text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_49","nl":"nus_Latn","pl":"hs","prompt":"--Lɔ̱a̱r 2^n mödulo p (ŋi̱c kɛ nämerikni̱).--  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =","canonical_solution":"modp :: Int -> Int -> Int\nmodp n p = powMod 2 n p\n\npowMod :: Int -> Int -> Int -> Int\npowMod base exp modulus\n  | modulus == 1 = 0\n  | exp == 0     = 1\n  | exp == 1     = base `mod` modulus\n  | otherwise    = if odd exp\n                   then (base * halfExp * halfExp) `mod` modulus\n                   else (halfExp * halfExp) `mod` modulus\n  where\n    halfExp = powMod base (exp `div` 2) modulus","tests":"\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_51","nl":"nus_Latn","pl":"hs","prompt":"--remove_vowels ɛ mi̱ la̱t mi̱ naŋkɛ kä la̱tkɛ ɛ thi̱ŋdɛr kä la̱tkɛ jɛ ɛ thi̱ŋdɛr mi̱ thiɛl jɔw.--  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =","canonical_solution":"removeVowels :: String -> String\nremoveVowels text = filter (`notElem` \"aeiouAEIOU\") text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_52","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ ɛ thuɔ̱k mi̱ ci̱ nämbäri̱ diaal rɛy li̱thä l te piny kä thärkäl t.--  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =","canonical_solution":"belowThreshold l t = all (< t) l","tests":"\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_53","nl":"nus_Latn","pl":"hs","prompt":"--Mi̱ matkɛ nämbäri̱ rɛw x kɛnɛ y.--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =","canonical_solution":"add :: Int -> Int -> Int\nadd x y = x + y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_54","nl":"nus_Latn","pl":"hs","prompt":"--◯ Guic mi̱ ci̱ rie̱e̱t da̱ŋ rɛw tekɛ kɛ luɔt mi̱ cäät.--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =","canonical_solution":"import Data.List (nub, sort)\n\nsameChars :: String -> String -> Bool\nsameChars s0 s1 = sort (nub s0) == sort (nub s1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_55","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ kɛ nämbär Fibönakci min la n-diɛn.--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =","canonical_solution":"fib :: Int -> Int\nfib n = fibHelper 0 1 n\n  where\n    fibHelper a _ 0 = a\n    fibHelper a b n = fibHelper b (a + b) (n - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_56","nl":"nus_Latn","pl":"hs","prompt":"--loc ni̱ thuɔ̱k mi̱ ci̱kɛ rɔ̱ tok kɛ mi̱ ci̱kɛ rɔ̱ tok kɛ mi̱ ci̱kɛ rɔ̱ tok kɛ mi̱ ci̱kɛ rɔ̱ tok.-- ɛ mi̱ la la̱tkɛ ɛ \"<\" kɛnɛ \">\". --  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBrackets brackets 0 == 0\n\ncheckBrackets :: String -> Int -> Int\ncheckBrackets [] n = n\ncheckBrackets (x:xs) n\n  | n < 0 = -1\n  | x == '<' = checkBrackets xs (n + 1)\n  | x == '>' = checkBrackets xs (n - 1)\n  | otherwise = checkBrackets xs n","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_57","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ kɛ thuɔ̱k ɛ jɛn ɣöö kɛn elɛmɛni̱ li̱thä ɛ ti̱ ŋuan kiɛ kuiy kɛn kɛ duɔ̱ɔ̱p mi̱ cäät.--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =","canonical_solution":"monotonic :: [Int] -> Bool\nmonotonic l = increasing l || decreasing l\n  where\n    increasing xs = all (uncurry (<=)) (zip xs (tail xs))\n    decreasing xs = all (uncurry (>=)) (zip xs (tail xs))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_58","nl":"nus_Latn","pl":"hs","prompt":"--│ Luɔ̱cdɛ kɛ ti̱ ca da̱a̱k ti̱ cäät kä li̱thti̱ni̱ da̱ŋ rɛw. │--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =","canonical_solution":"common :: [Int] -> [Int] -> [Int]\ncommon l1 l2 = uniqueSortedCommon\n  where\n    commonElements = filter (`elem` l2) l1\n    uniqueCommon = removeDuplicates commonElements\n    uniqueSortedCommon = sort uniqueCommon\n\n    removeDuplicates :: [Int] -> [Int]\n    removeDuplicates = foldr (\\x seen -> if x `elem` seen then seen else x : seen) []\n\n    sort :: [Int] -> [Int]\n    sort [] = []\n    sort (p:xs) = (sort lesser) ++ [p] ++ (sort greater)\n      where\n        lesser  = filter (< p) xs\n        greater = filter (>= p) xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_59","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ kɛ ɣöö ba prämik pëndi̱i̱t mi̱ di̱i̱t kä n loc. Nɛmɛ ɛ mi̱ di̱i̱t ni̱ jɛn kä 1 kä \/ci̱kɛ prämik.--  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =","canonical_solution":"largestPrimeFactor :: Int -> Int\nlargestPrimeFactor n = helper n 2\n  where\n    helper n factor\n      | factor * factor > n = n\n      | n `mod` factor == 0 = helper (n `div` factor) factor\n      | otherwise = helper n (factor + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_60","nl":"nus_Latn","pl":"hs","prompt":"--sum_to_n ɛ la̱t mi̱ la mat nämbäri̱ kä 1 ɛ wä kä n.--  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =","canonical_solution":"sumToN :: Int -> Int\nsumToN n = sum [1..n]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_61","nl":"nus_Latn","pl":"hs","prompt":"--loc ni̱ thuɔ̱k mi̱ ci̱kɛ rɔ̱ tok kɛ mi̱ ci̱kɛ rɔ̱ tok kɛ mi̱ ci̱kɛ rɔ̱ tok kɛ mi̱ ci̱kɛ rɔ̱ tok.--ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =","canonical_solution":"correctBracketing :: String -> Bool\ncorrectBracketing brackets = checkBalance brackets 0\n  where\n    checkBalance [] 0 = True\n    checkBalance [] _ = False\n    checkBalance (x:xs) n\n      | x == '('  = checkBalance xs (n + 1)\n      | x == ')' && n > 0 = checkBalance xs (n - 1)\n      | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_62","nl":"nus_Latn","pl":"hs","prompt":"--Lätdɛ kɛ deri̱ba̱t duŋ pöli̱nömial ɛmɛ rɛy ta̱a̱dɛ mi̱ päär.--xs[0] + xs[1] * x + xs[2] * x^2 + .... --Xs ɛ jɛn in nyothkɛ ɛ la mi̱ ca ŋun ɛ pöli̱nömial.--  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =","canonical_solution":"derivative :: [Int] -> [Int]\nderivative xs = zipWith (*) (tail xs) [1..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_63","nl":"nus_Latn","pl":"hs","prompt":"--Gɔ̱r pa̱ŋciin mi̱ bi̱ lät kɛ ɣöö ba pek ɛ la n-th kä ɛlɛmɛni̱ kä fib-bi̱d nämbäri̱ tin guɔ̱lkɛ rɔ̱.--fibfib ((n) == fibfib ((n-1) + fibfib ((n-2) + fibfib ((n-3). --fib fib ((2) == 1 --fib fib ((1) == 0 --fib fib ((0) == 0 --Kä FibFib nämbär thekuɛnthi̱ ɛ thekuɛnthi̱ mi̱ cäät kɛ Fibbonacci thekuɛnthi̱ min ca lat i̱ ɛ jɛn i̱nɔ:--  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =","canonical_solution":"fibfib :: Int -> Int\nfibfib n\n  | n == 0 = 0\n  | n == 1 = 0\n  | n == 2 = 1\n  | otherwise = fibs !! n\n  where\n    fibs = 0 : 0 : 1 : zipWith3 (\\a b c -> a + b + c) fibs (tail fibs) (drop 2 fibs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_64","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Vowel, duŋdɛ ɣöö jɛn kärɔa mi̱ jɛn te rɛy guutdä ri̱e̱e̱t in ca ŋun.--Kɛn jɔw-kɛl tin caa la̱t ɛ mɛ ɛ 'a', 'e', 'i', 'o', 'u'.--Ɛn riet ɛ mɔ ɛ mi̱ caa kuëŋ kä bɛ pek in tä kɛ jɔw rɛy rie̱tdä kulɛ loc.--ɛ gɔ̱r kɛ min la vowels_count mi̱ naŋɛ ni̱ la̱t mi̱ cuŋkɛ ɛ la --  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =","canonical_solution":"vowelsCount :: String -> Int\nvowelsCount s = length $ filter isVowel $ zip s [1..]\n  where\n    isVowel (c, pos) =\n      let lowercaseC = toLower c\n          isRegularVowel = lowercaseC `elem` \"aeiou\"\n          isLastCharY = lowercaseC == 'y' && pos == length s\n      in isRegularVowel || isLastCharY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_65","nl":"nus_Latn","pl":"hs","prompt":"--Mi̱ ci̱ shift > nämbär di̱ji̱tni̱, bi̱ di̱ji̱tni̱ loc jɔk.--kä luɔ̱c min ca jiek ɛ la mi̱ la ri̱e̱t.--ɛ̈ɛ̈r ɛ mi̱ ci̱ rɔ ri̱e̱t kä digji̱tni̱ intejeri̱ x, ci̱ digji̱tni̱ rɔ ri̱e̱t ɛ wä kui̱c ɛ wä kui̱c.--  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =","canonical_solution":"circularShift :: Int -> Int -> String\ncircularShift x shift =\n  let digits = show x\n      len = length digits\n      effectiveShift = shift `mod` len\n  in if shift > len\n     then reverse digits\n     else let (begin, end) = splitAt (len - effectiveShift) digits\n          in end ++ begin","tests":"\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_66","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Kɔɔdni̱ ASCII.--Gɔ̱r pa̱ŋciin mi̱ naŋkɛ thärk ɛ la inpuut kä locni̱ mat kä tin di̱t kärɔ̱' --Lät mi̱ la̱tkɛ--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =","canonical_solution":"digitsum :: String -> Int\ndigitsum s = sum $ map fromEnum $ filter isUpper s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_67","nl":"nus_Latn","pl":"hs","prompt":"--kɛ kui̱ kä min ca lat: --rɛy tharbët (basket) la̱tdɛ nämbär kä dɛy Mango rɛy tharbët.--kä yua̱a̱r kɛnɛ tuɔm kɛnɛ intejeri̱ tin cuŋkɛ kɛ pek in matkɛ kä dɛy --Kɛn gua̱th tin laa kuɛɛ laa täth kɛ dɛy, laa täth kɛ dɛy, laa täth kɛ dɛy, laa täth kɛ dɛy, laa täth kɛ dɛy, laa täth kɛ dɛy, laa täth kɛ dɛy.--tin caa da̱a̱k rɛy thärkä mi̱ tä dɛw thi̱n--Kɛ la̱t ɛmɛ, ba ji̱ ka̱m biɛl mi̱ cuŋ kɛ nämbär duŋ tuɔp kɛnɛ apɛlɛkni̱.--  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =","canonical_solution":"import Text.Read (readMaybe)\n\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n = n - totalApplesOranges\n  where\n    totalApplesOranges = sum $ map (readNumber . words) [\"apples\", \"oranges\"]\n    readNumber keyword = case dropWhile (not . (==\" \") . dropWhile (\/=' ')) $ words s of\n      [] -> 0\n      (num:_:rest) -> if num `elem` keyword then read num :: Int else 0","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_68","nl":"nus_Latn","pl":"hs","prompt":"--Cäät 1: --Mi̱ thiɛlɛ mi̱ ca mat ɛ päär kiɛ mi̱ ci̱ li̱th in ca ŋun te baaŋ, locni̱ [].--Kä no̱o̱p in ca jiek ba yi̱k loc rɛy li̱thä, [tha̱mälthti̱_ba̱li̱ö, ɛ indi̱dhɛthdɛ], --Mi̱ ca nändöni̱ ti̱ ŋuan jiek ti̱ tekɛ pe̱k mi̱ tɔt mi̱ päär, loc ni̱ nändö min te indi̱th in tɔt ni̱ jɛn.--Kä nɔ̱ɔ̱l in ca ji̱ek ba yi̱k ɛ nɔ̱ɔ̱l mi̱ tɔt mi̱ te pek mi̱ tɔt mi̱ päär.--la̱tdu ɛ ɣöö bi̱ ji̱n kɛl kä nyin duëli̱ kä bi̱ kɛ loc jɔk.--\"Mi̱ ca ŋun ɛ la li̱th mi̱ cuŋ kɛ kui̱ karä jiathä mi̱ tekɛ nämbäri̱ ti̱ \/ci̱ tɔ̱ a nämbäri̱ ti̱ ci̱ duɔth piny.--  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =","canonical_solution":"pluck :: [Int] -> [Int]\npluck arr = case filter (\\(x, _) -> even x) (zip arr [0..]) of\n    [] -> []\n    evens -> let (value, index) = minimum evens in [value, index]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_69","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Mi̱ thiɛlɛ mi̱ ce̱tkɛ ba̱li̱öm ɛmɔ, bɛ loc ɛ la -1.--Kä pek in te intejiɛr thi̱n ɛ pek in ci̱ jɔɔc rɛy li̱thä.--ɛ dhɛrö, kɛnɛ ɣöö jɛn tëkɛ prekuɛnthi̱ min di̱tni̱ jɛn kiɛ päär kɛ min ca ŋun ɛ intejeri̱ kärɔa.--Mi̱ ca ji̱ ka̱m li̱th mi̱ \/ci̱ɛɛ baŋ kä puci̱tip intejeri̱, locni̱ intejeri̱ tin di̱t ni̱ kɛn kä --  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nsearch :: [Int] -> Int\nsearch lst = \n    let frequencies = map (\\g -> (head g, length g)) . group . sort $ lst\n        candidates = filter (\\(val, freq) -> freq >= val) frequencies\n    in case candidates of\n         [] -> -1\n         _  -> fst . maximum $ candidates","tests":"\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_70","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Kä min di̱tni̱ jɛn kä intɛrjiɛri̱ tin ci̱ duɔth, kä min kuiyni̱ jɛn kä tin kɔ̱kiɛn.--Mi̱ ci̱ duɔ̱ɔ̱r tok kɛ mi̱ tɔt, bi̱ kɛ cu tok kɛ mi̱ tɔt.--Mi̱ ca ji̱ ka̱m li̱th intejeri̱, bi̱ ji̱ lɛ loc ni̱ li̱th rɛy la̱tdɛ mi̱ \/ci̱ rɔ lot.--  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =","canonical_solution":"strangeSortList :: [Int] -> [Int]\nstrangeSortList [] = []\nstrangeSortList lst = go (sort lst) True\n  where\n    go [] _ = []\n    go xs toggle\n      | toggle    = head xs : go (tail xs) False\n      | otherwise = last xs : go (init xs) True","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_71","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Kä min diɔ̱ɔ̱kdiɛn ɛ jɛn kui̱c.--Tha̱a̱ŋ diɔ̱k ti̱ ca̱a̱t ɛ la̱tdiɛn ɛ mi̱ ca kɛ mat ɛ kɛn gua̱th da̱ŋ rɛw tin di̱t.--Mi̱ \/ci̱ ɛ jɛn, bi̱ loc ni̱ -1 --kä di̱ri̱kali̱ ɛ mi̱ ca riali̱kä ɛ wä kä 2 decimal pöthi̱ni̱ mi̱ ci̱ thärkäl ɛ la di̱ri̱kali̱ mi̱ tekɛ kui̱c mi̱ ro̱ŋ.--Mi̱ ca pek ɛ wä kä kui̱c in diɔ̱k ɛ wä kä kui̱c in diɔ̱k ɛ wä kä kui̱c in diɔ̱k.--  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =","canonical_solution":"import Text.Printf (printf)\n\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c\n    | isValidTriangle a b c = roundToTwoDecimals (sqrt (s * (s - fromIntegral a) * (s - fromIntegral b) * (s - fromIntegral c)))\n    | otherwise = -1\n  where\n    s = (fromIntegral (a + b + c)) \/ 2\n    isValidTriangle x y z = x + y > z && x + z > y && y + z > x\n    roundToTwoDecimals x = read (printf \"%.2f\" x) :: Float","tests":"\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_72","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Kä duɔ̱ɔ̱r q bɛ rɔ cu jiɛc mi̱ cɛ päär (ɛ jɛn palindromic list) kɛnɛ ɣöö bi̱ mat ŋɔaani̱kɛ cu kuɛ̈ɛ̈ kiɛ päär kɛ pek in di̱tni̱ jɛn kä de rɔ lot w.--Gɔ̱r ni̱ pa̱ŋcin mi̱ bi̱ loc ni̱ thuɔ̱k mi̱ ci̱ duɔ̱ɔ̱r ɛ q rɔ bi̱ pa̱l piny, kɛnɛ ɣöö mi̱ ci̱ ɛ jɛn \/cɛ bi̱ pa̱l piny.--  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =","canonical_solution":"willItFly :: [Int] -> Int -> Bool\nwillItFly q w = isPalindrome q && sum q <= w\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome xs = xs == reverse xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_73","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Ɛ jɛn min kuɛnkɛ ɛ päärɛ jɔk kɛnɛ nhiam. kɛ duɔ̱ɔ̱p kɛl, deri duɔ̱ɔ̱r gɛr kä duɔ̱ɔ̱r mi̱ dɔ̱ŋ.--ɛ mi̱ go̱o̱r ɣöö ba gɛr kɛ ɣöö ba li̱th la̱t ɛ palindrɔmik. ɛ palindrɔmik ɛ li̱th mi̱ bi̱ --Mi̱ ca ŋun ɛ la li̱th arr duŋ intejeri̱, ji̱n bi̱ nämbär in kuiyni̱ jɛn kä elɛmɛni̱ tin bi̱ --  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =","canonical_solution":"smallestChange :: [Int] -> Int\nsmallestChange arr = sum $ zipWith (\\x y -> if x \/= y then 1 else 0) arr (reverse arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_74","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱ --Mi̱ ci̱ li̱tni̱ rɛw tekɛ kɛ pek mi̱ päär kä karani̱, locni̱ li̱tni̱ min nhiam.--pek in matkɛ ɛ la mi̱ tɔt kä kɛn diaal tin te rɛy li̱thä min dɔ̱ŋ.--ɛ gɔ̱r pa̱ŋciin mi̱ bi̱ matni̱ rɛw ti̱ ci̱ rɔ̱ mat kä bi̱ lɛ loc ni̱ min ci̱ rɔ̱ mat kä ci̱ rɔ̱ mat kä ci̱ rɔ̱ mat kä ci̱ rɔ̱ mat kä ci̱ rɔ̱ mat kä ci̱ rɔ̱ mat kä ci̱ rɔ̱ mat kä ci̱ rɔ̱ mat--  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =","canonical_solution":"totalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2\n  | totalChars lst1 < totalChars lst2 = lst1\n  | totalChars lst1 > totalChars lst2 = lst2\n  | otherwise = lst1\n  where\n    totalChars = sum . map length","tests":"\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_75","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Mi̱ ŋa̱cnɛ i̱ (a) ɛ kuiy ni̱ jɛn kä 100.--kä kac kɛ min dɔ̱ŋ.--ɛ gɔ̱r pa̱ŋciin mi̱ loc ni̱ thuɔ̱k mi̱ ca ŋun ɛ nämbär mi̱ ca loc ɛ la mälti̱pli̱kaciɔn duŋ pri̱i̱m nämbäri̱ da̱ŋ diɔ̱k --  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =","canonical_solution":"isMultiplyPrime :: Int -> Bool\nisMultiplyPrime a = any isTriplePrimeProduct primeTriples\n  where\n    primes = filter isPrime [2..99]\n    primeTriples = [(x, y, z) | x <- primes, y <- primes, z <- primes, x <= y, y <= z]\n    isTriplePrimeProduct (x, y, z) = x * y * z == a\n\nisPrime :: Int -> Bool\nisPrime n \n  | n < 2     = False\n  | otherwise = not (any (\\d -> n `mod` d == 0) [2..(floor . sqrt . fromIntegral) n])","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_76","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --x ɛ mi̱ ca la̱t ɛ thi̱a̱k kä n mi̱ n**int=x --kä buɔ̱m duŋ n kɛnɛ kac rɛy gua̱thni̱ kɔ̱kiɛn.--Lätdu ɛ ɣöö bi̱ la̱t mi̱ bi̱ loc ni̱ thuɔ̱k mi̱ ɛ nämbär x ɛ thi̱mpil.--  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =","canonical_solution":"isSimplePower :: Int -> Int -> Bool\nisSimplePower x n\n  | x < 1 || n < 1 = False\n  | n == 1 = x == 1\n  | otherwise = x == n ^ round (logBase (fromIntegral n) (fromIntegral x))","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_77","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Note: deri̱ jɛ car i̱ ɛn min ca la̱th rɛy la̱t ɛ mi̱ la thuɔ̱k ni̱ ciaŋ.--Mi̱ ca inegɛra̱th ɛmɛ cuub duŋ intejeri̱ ti̱ ŋuan.--ɛ gɔ̱r pa̱ŋcin mi̱ naŋ intejiɛr a kä loc ni̱ thuɔ̱k.--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =","canonical_solution":"iscube :: Int -> Bool\niscube a = let n = round (fromIntegral a ** (1\/3)) in n^3 == a","tests":"\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_78","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --kä bi̱ thi̱i̱mbuɔli̱ A,B,C,D,E,F ni̱ ciaaŋ la gɔ̱rkɛ kɛ wargak mi̱ di̱i̱t.--Nöth: deri̱ jɛ car i̱ ɛn inpuut bɛ ni̱ ciaaŋ la thuɔ̱k kiɛ bɛ te baaŋ, --B (= decimal 11), D (= decimal 13). --Mi̱ ci̱i̱ jɛ la̱t, bi̱ kɛ lɛ be̱n go̱r ɛn ɣöö bi̱ kɛ ɛ nämbär mi̱ de̱e̱ kɛ wä kä di̱jitni̱ ti̱ti̱: 2, 3, 5, 7, --Präm nämbäri̱ kɛn kɛ 2, 3, 5, 7, 11, 13, 17,...--Hexadecimal digits ɛ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. --min di̱tni̱ jɛn kä 1 min \/ci̱kɛ la pi̱löd duŋ näci̱ral nämbäri̱ rɛw tin kuiyni̱kɛn).--Di̱jitni̱ tin la praam nämbäri̱ (praam nämbär, kiɛ praam, ɛ näci̱ral nämbär --Ɛ ɣɛkdathedhimal nämbär ɛ la thärkɛn kä kuɛnɛ nämbär ɣɛkdathedhimal --ëë ji̱ caa la̱t kɛ ɣöö bi̱ la̱t mi̱ bi̱ ji̱ luäk kulɛ gɔ̱r.--  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =","canonical_solution":"hexKey :: String -> Int\nhexKey num = length . filter (`elem` primeHexDigits) $ num\n  where\n    primeHexDigits = \"2357BD\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_79","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Kɛn wargakni̱ tin ca mat thi̱n kɛ ɣöö bi̱ kɛ wɔ̱ a gɔaa.--Bi̱ tekɛ kaar ti̱ ŋuan ti̱ ba gɔ̱r i̱ 'db' kä tukdɛ kɛnɛ guutdɛ kä thëm.--Kä bi̱ ramɔ kä biɛl rɛy thi̱rɛndä bi̱ kɛnɛ '0' kiɛ '1'.--la̱t bi̱ kɛnɛ yi̱k loc kä bi̱ la̱t ɛmɔ ɛ la mi̱ bi̱ la̱t mi̱ bi̱ la̱t ɛ la binary.--Bi̱ ji̱n ɛ ŋun ɛ la mi̱ bi̱ pekdɛ kulɛ wä kä decimal kä bi̱ la̱tdu ɛ ɣöö bi̱ jɛ loc kä --  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =","canonical_solution":"decimalToBinary :: Int -> String\ndecimalToBinary decimal = \"db\" ++ toBinary decimal ++ \"db\"\n  where\n    toBinary 0 = \"0\"\n    toBinary n = reverse (binaryHelper n)\n\n    binaryHelper 0 = \"\"\n    binaryHelper n = let (q, r) = n `divMod` 2 in show r ++ binaryHelper q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_80","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Ɛ thi̱ri̱n mi̱ la hapdh mi̱ jɛn bäärɛ ɛ mi̱ kuiyni̱ jɛn kä 3 kɛnɛ ɣöö kɛn diɔ̱k tin guɔ̱rkɛ rɔ̱ ɛ ti̱ gööl --La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ ɛ i̱thkuɛrɛn ɛ hapdh kiɛ \/cɛ.--ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ--  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =","canonical_solution":"isHappy :: String -> Bool\nisHappy s\n  | length s < 3 = False\n  | otherwise = all distinctTriples (windows 3 s)\n  where\n    distinctTriples [x, y, z] = x \/= y && y \/= z && x \/= z\n    distinctTriples _ = False\n    windows n xs\n      | length xs < n = []\n      | otherwise = take n xs : windows n (tail xs)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_81","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --0.0 E --> 0.0 D- --> 0.7 D --> 1.0 D+ --> 1.3 C- --> 1.7 C --> 2.0 C+ --> 2.3 B- --> 2.7 B --> 3.0 B+ --> 3.3 A- --> 3.7 A --4.0 A+ --GPA. Letter grade. GPA. Letter grade.--la̱t mi̱ de raar ɛ la li̱th duŋ kä i̱thtëri̱ ki̱lɛ̈ɛ̈tni̱ kɛ la̱tdɛ kɛ ta̱a̱ in ba lat piny: --Cɛ ji̱ moc kɛ li̱th GPA kɛ kui̱ tha̱a̱ŋ ji̱ duël-gɔ̱rä kä bi̱ ji̱n ɛ gɔ̱r piny.--Kä riɛk kärɔa, jɛn cuɛ thiɛl kɔd min la̱tdɛ kɛ ɣöö bɛ di̱l ɛ la̱t.--Ŋi̱i̱cdɛ ɛn ɣöö bɛ gɔ̱a̱r ɛ la ram mi̱ bi̱ naath jakä ŋa̱ckɛ tin gɔ̱rkɛ.--Ɛ jɛn juɔk in jɔak kä thɛmthɛdɛr kä ŋi̱i̱c bɛ ji̱ ŋieec ka̱m ŋieec.--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =","canonical_solution":"numericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades = map gpaToLetterGrade grades\n  where\n    gpaToLetterGrade gpa\n      | gpa == 4.0 = \"A+\"\n      | gpa > 3.7  = \"A\"\n      | gpa > 3.3  = \"A-\"\n      | gpa > 3.0  = \"B+\"\n      | gpa > 2.7  = \"B\"\n      | gpa > 2.3  = \"B-\"\n      | gpa > 2.0  = \"C+\"\n      | gpa > 1.7  = \"C\"\n      | gpa > 1.3  = \"C-\"\n      | gpa > 1.0  = \"D+\"\n      | gpa > 0.7  = \"D\"\n      | gpa > 0.0  = \"D-\"\n      | otherwise  = \"E\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_82","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱ --mi̱ ci̱ pekdɛ ɛ mi̱ la praam nämbär kiɛ mi̱ \/ci̱ mɔ ɛ thuɔ̱k --ɛ gɔ̱r pa̱ŋciin mi̱ naŋkɛ thärkdɛ kä loc ɛ thuɔ̱k mi̱ ci̱ thärkdɛ --  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =","canonical_solution":"primeLength :: String -> Bool\nprimeLength string = isPrime (length string)\n\nisPrime :: Int -> Bool\nisPrime n\n  | n < 2     = False\n  | n == 2    = True\n  | even n    = False\n  | otherwise = null [ x | x <- [3, 5 .. floor (sqrt (fromIntegral n))], n `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_83","nl":"nus_Latn","pl":"hs","prompt":"--Puɔ̱thitib intjerni̱ tin tokɛ kiɛ thukɛ kɛ 1.--Mi ca ŋun ɛ la mi̱ tekɛ puɔ̱thitib intejer n, locni̱ nämbäri̱ tin te kä n-dhi̱jitstartsOneEnds :: Int -> Int\nstartsOneEnds n =","canonical_solution":"startsOneEnds :: Int -> Int\nstartsOneEnds n\n  | n <= 0    = 0\n  | n == 1    = 1\n  | otherwise = 18 * 10^(n-2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_84","nl":"nus_Latn","pl":"hs","prompt":"--Cäät --Mi ca ŋun ɛ la mi̱ tekɛ puɔthtip intejer N, locni̱ mat di̱jitni̱kɛ rɛy bainairi̱.--  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 ≤ N ≤ 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =","canonical_solution":"solve :: Int -> String\nsolve N = toBinary (sumOfDigits N)\n  where\n    sumOfDigits 0 = 0\n    sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)\n\n    toBinary 0 = \"0\"\n    toBinary n = reverse (toBinary' n)\n      where\n        toBinary' 0 = \"\"\n        toBinary' x = let (q, r) = x `divMod` 2 in intToDigit r : toBinary' q","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_85","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Mi̱ ca ŋun ɛ la mi̱ \/ci̱ te baaŋ kä intɛrjiɛrni̱ lst, matni̱ ɛlɛmɛni̱ ti̱ päär ti̱ te kä indi̱dhi̱thni̱ ti̱ \/ci̱ päär.--  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =","canonical_solution":"add :: [Int] -> Int\nadd lst = sum [x | (i, x) <- zip [0..] lst, odd i, even x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_86","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Ruacni ti̱ti̱: Ji̱n bi̱ kɛ dhil la̱t kɛ duɔ̱ɔ̱p in ci̱kɛ la̱t kɛ jɛ kɛnɛ gua̱th tin ci̱kɛ la̱t kɛ jɛ.--kä min wä nhial kä min wä nhial kä min ca la̱th kä ɣɛkpi̱ri̱mɛni̱.--ɛ mi̱ la̱tkɛ ɛ riet mi̱ pay tuɔɔk mi̱ bi̱ kɛn ciɛŋ diaal tin caa riali̱kä rɛy --Mi̱ ca riali̱kä kä ca̱p in ca gɔ̱r, ɛ mi̱ la rie̱t diaal (tin ca da̱a̱k ɛ kam)--ɛ gɔ̱r pa̱ŋciin mi̱ naŋkɛ thärkdɛ kä locni̱ ta̱a̱dɛ mi̱ ca riali̱kä.--  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =","canonical_solution":"import Data.List (sort)\nimport Data.Char (isAlpha)\n\nantiShuffle :: String -> String\nantiShuffle s = unwords $ map sortWord (wordsAndSpaces s)\n  where\n    sortWord word = if all isAlpha word then sort word else word\n    wordsAndSpaces [] = []\n    wordsAndSpaces xs = if head xs == ' ' \n                        then \" \" : wordsAndSpaces (dropWhile (== ' ') xs)\n                        else let (word, rest) = break (== ' ') xs\n                             in word : wordsAndSpaces rest","tests":"\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_87","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Ɛ nyɔk bä, ca̱a̱t kɛ min ca mat kä röm ɛ la kɔlömni̱ kɛ ɣöö bɛ wä piny.--Thɔ̱rbi̱ri̱ni̱ tin caa la̱t kɛ nhiam kɛ duɔ̱ɔ̱p mi̱ wä nhial.--kä tuple ɛ kɛl mi̱ la kɔrdi̱nɛt - (rɛy, ɛ kɔlömni̱), ɛ tokɛ kä 0.--kä locni̱ li̱th duŋ tupula, [(x1, y1), (x2, y2) ...] ce̱tkɛ mi̱ cie jɛn --Mi̱ ca ŋun lst, kɛnɛ intejer x, jiek intejeri̱ x rɛy li̱thä, --kä ri̱w kɛl dɔ̱ŋ bɛ tekɛ nämbär mi̱ göl kä kɔlömni̱.--min cät kɛ matrik, duŋni̱ ɣöö, \/cɛ cät kɛ matrikni̱, --ëë ji̱ moc kɛ data ti̱ tekɛ dääk da̱ŋ rɛw, cetkɛ li̱th ti̱ ca mat, --  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =","canonical_solution":"getRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x = concatMap processRow (zip [0..] lst)\n  where\n    processRow (rowIndex, row) = \n      let colIndices = reverse $ findIndices (== x) row\n      in [(rowIndex, colIndex) | colIndex <- colIndices]\n\nfindIndices :: (a -> Bool) -> [a] -> [Int]\nfindIndices p lst = [i | (i, val) <- zip [0..] lst, p val]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_88","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --* \/cu li̱t in ca ŋun gɛr. --Nöt: --kiɛ dääkdɛ kɛ jɛ kɛ min wä piny mi̱ ci̱ mat ((kä min nhiam kä indi̱i̱th ba̱li̱öm, kä min jɔak kä indi̱i̱th ba̱li̱öm) ɛ pa̱r.--bi̱ ji̱n li̱th in ca ŋun käp kɛ duɔ̱ɔ̱p mi̱ wä nhial mi̱ ci̱ mat ((kä index ba̱li̱ö min nhiam, kä index ba̱li̱ö min jɔak) ɛ mi̱ \/ci̱ mɔ a kɛl, --Mi̱ ca ŋun ɛ la li̱th duŋ nön-negɛtib intejeri̱, locni̱ ɛ la cohs kä li̱th in ca ŋun kɛ kɔr kä mi̱ ca kɛ da̱a̱k, --  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =","canonical_solution":"sortArray :: [Int] -> [Int]\nsortArray array\n  | null array = array\n  | otherwise =\n    let first = head array\n        last = last array\n        sumFirstLast = first + last\n    in if odd sumFirstLast\n       then sort array\n       else reverse (sort array)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_89","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --kɛ rɛw ti̱ ŋuan kɛ gua̱th rɛw.--Ɛn aljɛbi̱t ba yi̱k loc kɛ duɔ̱ɔ̱p mi̱ bi̱ lɛ̈t ɛ la --la loc ɛ la mi̱ ca gɔ̱r ɛ la ki̱i̱thtɛr mi̱ ca rɔ̱ gɛr kä alpabet.--ɛ la̱t kɛ ɣöö bɛ la̱t ɛ ci̱ rɔ gɛr kɛ ɣöö bɛ rɔ gɛr ɛ la mi̱ ci̱ rɔ gɛr kä --  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =","canonical_solution":"encrypt :: String -> String\nencrypt s = map shiftChar s\n  where\n    shiftChar c\n      | 'a' <= c && c <= 'z' = chr ((ord c - ord 'a' + 4) `mod` 26 + ord 'a')\n      | 'A' <= c && c <= 'Z' = chr ((ord c - ord 'A' + 4) `mod` 26 + ord 'A')\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_90","nl":"nus_Latn","pl":"hs","prompt":"--Mi̱ thiɛlɛ mi̱ ce̱tkɛ mi̱ te thi̱n, \/ci̱kɛ bi̱ loc ɛ la ti̱ti̱.--Gɔ̱r la̱t in dɔ̱ŋ min bi̱ loc ni̱ jɛn in rɛwdɛ min kuiy ni̱ jɛn kä li̱th.--ëë ji̱ moc kɛ li̱th duŋ intejeri̱.--  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =","canonical_solution":"nextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =\n  let uniqueSorted = removeDuplicates $ quicksort lst\n  in if length uniqueSorted < 2\n     then Nothing\n     else Just (uniqueSorted !! 1)\n\nremoveDuplicates :: (Ord a) => [a] -> [a]\nremoveDuplicates = foldr (\\x acc -> if x `elem` acc then acc else x : acc) []\n\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n  let smallerSorted = quicksort [a | a <- xs, a <= x]\n      biggerSorted = quicksort [a | a <- xs, a > x]\n  in smallerSorted ++ [x] ++ biggerSorted","tests":"\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_91","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Thënci̱ni̱ ba kɛ yiath piny ɛ la '.', '?' kiɛ '!'.--Ɛn \"boredom\" ɛ mi̱ la tuk rie̱tdä kä \"I\".--Bi̱ ji̱ moc rieet ti̱ ŋuan, kä bi̱ pekdiɛn kuɛn.--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =","canonical_solution":"isBored :: String -> Int\nisBored s = length $ filter (startsWithI . words) $ splitSentences s\n  where\n    splitSentences :: String -> [String]\n    splitSentences = filter (not . null) . map (dropWhile (== ' ')) . splitOnDelimiters \".?!\"\n    \n    splitOnDelimiters :: String -> String -> [String]\n    splitOnDelimiters delims str = case dropWhile (`elem` delims) str of\n      \"\" -> []\n      s' -> let (w, s'') = break (`elem` delims) s' in w : splitOnDelimiters delims s''\n    \n    startsWithI :: [String] -> Bool\n    startsWithI [] = False\n    startsWithI (x:_) = map toLower x == \"i\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_92","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱ --Lätdɛ ɛ kac rɛy kä ti̱ kɔ̱kiɛn.--La loc ɛ thuɔ̱k mi̱ kɛl kä nämbäri̱ ɛ mi̱ päär kɛ mat nämbäri̱ rɛw tin kɔ̱kiɛn, kɛnɛ nämbäri̱ diaal tin te rɛy intejeri̱.--ɛ la̱t mi̱ naŋɛ nämbäri̱ da̱ŋ diɔ̱k.--  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =","canonical_solution":"anyInt :: Float -> Float -> Float -> Bool\nanyInt x y z\n  | x == fromInteger (round x) && y == fromInteger (round y) && z == fromInteger (round z) =\n      x == y + z || y == x + z || z == x + y\n  | otherwise = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_93","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Lätni̱ wargakni̱ kärɔ̱.--Ɛn vowel rɛy Liŋli̱th alpabet.--Ɛn wargak mi̱ caa gɔ̱r ɛ mi̱ tä gua̱a̱th da̱ŋ rɛw nhiamdɛ--Ɛn duɔ̱ɔ̱p in laa jɛ laa gɛrkɛ ɛ la mi̱ laa gɔ̱a̱rkɛ kɛ gua̱a̱th warɛgakni̱ diaal, laa jɛ laa gɛrkɛ ɛ la mi̱ laa gɔ̱rkɛ kɛ gua̱a̱th kɛl.--ɛ gɔ̱r pa̱ŋciin mi̱ naŋ ruac, kä bɛ jɛ kuëŋ rɛy ɛ--  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =","canonical_solution":"encode :: String -> String\nencode = map transformChar\n  where\n    transformChar :: Char -> Char\n    transformChar c\n      | isVowel lowerC = toEnum (fromEnum lowerC + 2) `swapCase` c\n      | otherwise      = swapCase c c\n      where\n        lowerC = toLower c\n\n    isVowel :: Char -> Bool\n    isVowel c = c `elem` \"aeiou\"\n\n    swapCase :: Char -> Char -> Char\n    swapCase origC c\n      | isUpper origC = toLower c\n      | otherwise     = toUpper c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_94","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Ji̱n go̱o̱ri ɣöö bi̱ min di̱tni̱ jɛn kä prɔmmi̱ɛr mi̱ cɛ di̱t kä bi̱ loc ni̱ dääri̱ di̱jitädɛ.--ëë ji̱ moc kɛ li̱th duŋ intejeri̱.--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =","canonical_solution":"skjkasdkd :: [Int] -> Int\nskjkasdkd lst = sumDigits (largestPrime lst)\n\n-- Function to check if a number is prime\nisPrime :: Int -> Bool\nisPrime n\n  | n <= 1 = False\n  | n == 2 = True\n  | even n = False\n  | otherwise = null [x | x <- [3,5..isqrt n], n `mod` x == 0]\n\n-- Integer square root using binary search, O(log n)\nisqrt :: Int -> Int\nisqrt n = floor . sqrt $ fromIntegral n\n\n-- Function to find the largest prime in the list\nlargestPrime :: [Int] -> Int\nlargestPrime = foldr (\\x acc -> if isPrime x && x > acc then x else acc) 0\n\n-- Function to calculate the sum of the digits of a number\nsumDigits :: Int -> Int\nsumDigits 0 = 0\nsumDigits n = n `mod` 10 + sumDigits (n `div` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_95","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Kä pa̱ŋciin bɛ yi̱k loc i̱ Ji̱äk ɛ jɛn min ca ŋun ɛ matkɛ ɛ la mi̱ thiɛl luɔt.--Kä mi̱ ca gɔ̱r ɛ la mi̱ di̱i̱t kiɛ bi̱kɛ diaal ɛ ti̱ ŋuan, mi̱ \/ci̱ mɔ ɛ thuɔ̱k.--Mi ca ji̱ moc kɛ mi̱ bi̱ ji̱ek, bi̱ yi̱k ɛ la mi̱ bi̱ kulɛ thuɔ̱k mi̱ ci̱ kɛn diaal ɛ ti̱ bi̱ tä kɛ mi̱ tɔt.--  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =","canonical_solution":"import Data.Char (isUpper, isLower)\n\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase [] = False\ncheckDictCase dict = all isLower allKeys || all isUpper allKeys\n  where\n    allKeys = concatMap fst dict","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_96","nl":"nus_Latn","pl":"hs","prompt":"--cäätdɛ: --intejeri̱ tin la praam nämbäri̱ kɛnɛ tin kuiyni̱kɛn kä n.--Lätdɛ kɛ pa̱ŋcin mi̱ naŋkɛ ni̱ nämbär mi̱ \/ci̱ negative kä locni̱ li̱th duŋ n in nhiamdiɛn.--  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =","canonical_solution":"countUpTo :: Int -> [Int]\ncountUpTo n = filter isPrime [2..n-1]\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..isqrt k], k `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_97","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Lätdɛ jɛ i̱ ɛn inpuut bɛ te lät ni̱ ciaaŋ.--kä min la matkɛ ɛ nämbäri̱ yunitni̱kiɛn.--ëëp la̱t min naŋ intejeri̱ rɛw kä loc ɛ ëëp la̱t mi̱ ci̱ cop kä intjeri̱ rɛw kä loc ɛ ëëp--  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =","canonical_solution":"multiply :: Int -> Int -> Int\nmultiply a b = (abs a `mod` 10) * (abs b `mod` 10)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_98","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --ɛ mi̱ ca ŋun ɛ la thärkdɛ (string) s, kuɛn nämbäri̱ kä tin ca gɔ̱r kɛ i̱ ɛ bok (vowel) mi̱ di̱i̱t mi̱ te rɛy i̱thpëthi̱dethä. --  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =","canonical_solution":"countUpper :: String -> Int\ncountUpper s = length [c | (i, c) <- zip [0..] s, i `mod` 2 == 0, c `elem` \"AEIOU\"]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_99","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱ --Kä ɛni̱ intejeri̱ rɛw, ba kɛ cu riali̱kä ɛ wä kä dhɛrö.--Kä cuɛ loc ni̱ intejiɛr in thi̱a̱k ɛlɔ̱ŋ kɛ jɛ. Mi̱ jɛn nämbär ɛ päär gua̱a̱th in te thi̱n.--Lätni̱ mi̱ la̱tkɛ kɛ ɣöö ba pekdɛ (thɛrɛn) nyoth ɛ la nämbär--  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =","canonical_solution":"closestInteger :: String -> Int\nclosestInteger value = \n  let n = read value :: Double\n  in if n > 0 then floor (n + 0.5) else ceiling (n - 0.5)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_100","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --i ɛ nämbär pämni̱ rɛy kä ti̱e̱c (i+1).--Lätdɛ kɛ pek pämni̱ rɛy kä röm kɛl kɛrɔ̱ rɛy li̱thä, gua̱th in bi̱ ɛlɛmɛni̱ ɛ wɔ̱ kä indi̱dhɛth --- kä nämbär in dɔ̱ŋ ɛ päär mi̱ n ɛ päär.--- kä nämbär in dɔ̱ŋ mi̱ \/ci̱ päär mi̱ n ɛ mi̱ \/ci̱ päär.--Kä pek päämni̱ tin te rɛy la̱t in dɔ̱ŋ ɛ: --Kä min nhiamdiɛn ɛ mi̱ tekɛ pääm n.--Mi ca ŋun ɛ nämbär puɔthtip intejiɛr n, bi̱ ji̱n ɛ la̱t kɛ pääm ti̱ tekɛ n i̱thki̱e̱li̱.--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =","canonical_solution":"makeAPile :: Int -> [Int]\nmakeAPile n = take n [n, n + 2 ..]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_101","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --kɛ däkdɛ kä rieet kɛnɛ locdɛ kɛ li̱th rieetni̱.--Bi̱ ji̱ moc rieet ti̱ caa da̱a̱k kɛ kɔma kiɛ kam.--  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =","canonical_solution":"wordsString :: String -> [String]\nwordsString s = words $ map (\\c -> if c == ',' then ' ' else c) s","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_102","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --\/Thiɛlɛ nämbär mi̱ ce̱tkɛ nɔ, kä ba pa̱ŋcin loc ɛ -1--ɛ jɛn in di̱tni̱jɛn kä pek in te rɛy gua̱th in te (x,y) thi̱n ɛ matkɛ jɛ.--Ɛn pa̱ŋciin ɛmɛ naŋɛ nämbäri̱ rɛw ti̱ puɔthtip (positive) x kɛnɛ y kä bɛ loc ni̱ --  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =","canonical_solution":"chooseNum :: Int -> Int -> Int\nchooseNum x y\n    | x > y = -1\n    | even upperBound = upperBound\n    | even (upperBound - 1) = upperBound - 1\n    | otherwise = -1\n  where\n    upperBound = max x y","tests":"\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_104","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Nöth: Li̱th ëë ca luɔ̱c jɔk ba yi̱k riali̱kä kɛ ɣöö bɛ rɔ re̱p.--ɛlɛmɛni̱ tin thiɛl ɛni̱ pari̱ dijit.--Mi̱ ca ŋun ɛ la li̱th duŋ puci̱tib intejeri̱ (x), bi̱ min ca riali̱kä ɛ la li̱th duŋ i̱thti̱ri̱ diaal.--  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =","canonical_solution":"uniqueDigits :: [Int] -> [Int]\nuniqueDigits x = sort $ filter (all odd . map (read . (:[])) . show) x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_105","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --\"Kɛl\", \"Kä rɛw\", \"Kä Diɔ̱ɔ̱k\", \"Kä Ŋuaan\", \"Kä Bädäk\", \"Kä Bäkɛl\", \"Kä bärɔw\", \"Kä Bädäk\", \"Kä Däk\".--la̱thdɛ piny kä min ca jiek, kä bɛ di̱jitni̱ diaal gɛr kɛ ci̱ötdiɛn min lot rɔ kä --Mi̱ ca ji̱ ka̱m li̱t intejeri̱, bi̱ i̱thti̱ri̱ tin te kam 1 kɛnɛ 9 cu määni̱ kɛn diaal, --  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the list is empty, return an empty list:\n--  >>> byLength []\n--  []\n--  If the list has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =","canonical_solution":"byLength :: [Int] -> [String]\nbyLength arr = map digitName . reverse . sort . filter isValid $ arr\n  where\n    isValid x = x >= 1 && x <= 9\n    digitName x = case x of\n      1 -> \"One\"\n      2 -> \"Two\"\n      3 -> \"Three\"\n      4 -> \"Four\"\n      5 -> \"Five\"\n      6 -> \"Six\"\n      7 -> \"Seven\"\n      8 -> \"Eight\"\n      9 -> \"Nine\"\n      _ -> error \"Unexpected number\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_106","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Kä paktɔriɔl duŋ i ɛ mi̱ la di̱tni̱ jɛn kä nämbäri̱ tin la̱tkɛ ɛ 1 ɛ wä kä i (1 * 2 * ... * i).--i bɛ tok kä 1. --kiɛ mat nämbäri̱ kä 1 ɛ wä kä i mi̱ dɔ̱ŋ.--kä cuɛ liny ɛ la mi̱ di̱i̱t kä n, ce̱tkɛ mi̱ ba pek ɛlɛmɛni̱ kä indi̱th i ɛ jɛn paktɔriɔl duŋ i mi̱ i ɛ pa̱r.--ɛ la̱t kä f mi̱ naŋ n ɛ la parɛmatɛr, --  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =","canonical_solution":"f :: Int -> [Int]\nf n = map g [1..n]\n  where\n    g i\n      | even i    = factorial i\n      | otherwise = sum [1..i]\n    \n    factorial 0 = 1\n    factorial m = product [1..m]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_107","nl":"nus_Latn","pl":"hs","prompt":"--Cäät 1: --intejiɛr palindrɔmi̱ tin la pɛn rɛy gua̱th in te ((1, n), ɛ matkɛ.--Mi ca ŋun ɛ la mi̱ tekɛ nämbär mi̱ thuɔ̱k mi̱ la n, locni̱ nämbär mi̱ tekɛ nämbär mi̱ päär kɛnɛ mi̱ \/ci̱ päär.--  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =","canonical_solution":"evenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n = (length evens, length odds)\n  where\n    isPalindrome x = show x == reverse (show x)\n    palindromes = filter isPalindrome [1..n]\n    evens = filter even palindromes\n    odds  = filter odd palindromes","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_108","nl":"nus_Latn","pl":"hs","prompt":"--c.d. -123 cɛ di̱jitni̱ -1, 2, kɛnɛ 3.--Mi̱ ci̱ nämbär ɛ mi̱negɛtib, kä ɛn di̱jit in nhiam in ca la̱th thi̱n bɛ cu te ni̱negɛtib: --Kä nämbäri̱ ɛlɛmɛni̱ tin tekɛ dääkä di̱ji̱tni̱ > 0.--ɛ gɔ̱r la̱t mi̱ cɔali̱ count_nums min bi̱ lɛlni̱ nämbäri̱ ti̱ ci̱ thuɔ̱k kä bi̱ kɛ loc.--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =","canonical_solution":"countNums :: [Int] -> Int\ncountNums arr = length $ filter ((> 0) . sumDigits) arr\n  where\n    sumDigits 0 = 0\n    sumDigits n = let digits = if n < 0 then -1 : map (read . (:[])) (tail (show (-n))) else map (read . (:[])) (show n)\n                  in sum digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_109","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Nöb: Kä li̱ɛt in ca ŋun ɛ mi̱ ca ŋun i̱ bɛ tekɛ ɛlɛmɛni̱ ti̱ gööl.--Mi̱ ca li̱th in ca ŋun ɛ mi̱ te baaŋ bɛ loc ni̱ thuɔ̱k.--kä bɛ loc i̱ thuɔ̱k kiɛ bɛ loc i̱ kac.--Mi̱ jɛn lotdɛ rɔ kɛ ɣöö ba riali̱kä ɛ la mi̱ ca riali̱kä ɛ la̱t ɛ te nhial ɛ la̱t --Kä min nhiam kä li̱th ɛ 0th indi̱dhɛth.--Kä ɛlɛmɛni̱ tin jɔak kä li̱th ba kɛ naŋ kä --Mi̱ ci̱ duɔ̱ɔ̱r rɔ gɛɛr kui̱c ɛ wä kui̱c lotdɛ ni̱ ɣöö bi̱ ŋɔak diaal tin te rɛy li̱thä rɔ gɛr ɛ kɛl.--Deri̱ la̱t mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱.--Ɛn la̱t in guurɛ rɛy li̱thä min ca ŋun:--ɛ jɛn min de rɔ lot kɛ ɣöö ba li̱th riali̱kä rɛy kä mi̱ \/ci̱ wä piny kɛ la̱tdiɛn --Kuenɛ kɛ ɣöö bi̱ kɛ rɔ̱ɔ̱diɛn kuëŋ rɛy li̱thä.--Ta̱nɛ kɛ li̱th 'arr' duŋ N intejeri̱ arr[1], arr[2], ..., arr[N].--  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given list.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  list by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =","canonical_solution":"moveOneBall :: [Int] -> Bool\nmoveOneBall [] = True\nmoveOneBall arr = canBeSorted (arr ++ arr)\n  where\n    n = length arr\n    canBeSorted xs = any isSorted (take n <$> tails xs)\n    isSorted ys = and $ zipWith (<=) ys (tail ys)\n    tails [] = []\n    tails l@(_:xs) = l : tails xs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_110","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Mi̱ \/ci̱ ɛ jɛn, locni̱ \"ƔËË\".--Kä ɛni̱ elɛmɛni̱ diaal kä lst1 kɛ ɣöö ba pa̱a̱r, luɔ̱c \"YƐƐ\".--Mi̱ ca rɔ lot kɛ ɣöö ba ŋɔaani̱ gɛɛr kam lst1 kɛnɛ lst2 kɛ ɣöö ba kɛ la̱t --\/Thiɛlɛ mi̱ ca thɛm kä nämbär in ba la̱th thi̱n kam lst1 kɛnɛ lst2.--Kä min nhiamdiɛn ɛ ɣöö ba la̱t ɛ la mi̱ tekɛ nämbäri̱ ti̱ matkɛ kärɔ̱.--kä bɛ ji̱ek mi̱ de rɔ lot kɛ ɣöö ba la̱t ɛ la̱t mi̱ ci̱ rɔ gɛr kɛ tin kɔ̱ŋ --Rɛy ri̱e̱e̱tni̱ ti̱ti̱, bi̱ nɛy lät kɛ pa̱ŋciin mi̱ naŋɛ nämbäri̱ ti̱ ŋuan ti̱ gööl,--  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =","canonical_solution":"exchange :: [Int] -> [Int] -> String\nexchange lst1 lst2\n  | all even lst1 = \"YES\"\n  | null oddLst1 || null evenLst2 = \"NO\"\n  | otherwise = let possibility = all even ([x | x <- lst1, even x] ++ evenLst2)\n                in if possibility then \"YES\" else \"NO\"\n  where\n    oddLst1 = filter odd lst1\n    evenLst2 = filter even lst2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_111","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Mi̱ ci̱ warɛgakni̱ ti̱ ŋuan te kɛɛl, locni̱kɛ diaal.--Kä wargak in caa loc ni̱ ciaaŋ kä tä kɛ pek in lot rɔ.--Mi ca ji̱ ka̱m string mi nyothni̱ mi̱ te kam kamni̱ warɛgakni̱ tin tɔatni̱, bi̱ yi̱k ɛ nyɔk kɛ locni̱ mi̱ ca mat piny.--  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =","canonical_solution":"import Data.List (group, sort)\nimport Data.Ord (comparing)\n\nhistogram :: String -> [(String, Int)]\nhistogram input =\n  let wordsList = words input\n      grouped = group $ sort wordsList\n      countList = map (\\ws -> (head ws, length ws)) grouped\n      maxCount = if null countList then 0 else maximum $ map snd countList\n  in filter ((== maxCount) . snd) countList","tests":"\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_112","nl":"nus_Latn","pl":"hs","prompt":"--Cäät --Bi̱diöö ɛ mɔ bi̱ ben ɛ la tuple mi̱ te kä ba̱li̱dɛ kɛnɛ thuɔ̱k\/ji̱ääk kɛ ɣöö ba kuɛn.--Ɛ thi̱ri̱ndɛr cɔalɛ palindrɔm mi̱ jɛn kuɛnɛ ni̱ duɔ̱ɔ̱p kɛl mi̱ päär kɛ min ca gɔ̱r jɔkdɛ kɛnɛ nhiamdɛ.--Kä kɛ kɔrɛ ba guic mi̱ ci̱ min bi̱ ben raar ɛ pa̱li̱ndrɔm.--Kɔn ka̱mnɛ ni̱ käl rɛw ti̱ cɔali̱ s kɛnɛ c, bi̱ kɔn ɛ dhil woc kä käl tin tä kä s tin päärkɛ kɛ käl tin tä kä c.--Lät mi̱ la̱tkɛ--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =","canonical_solution":"import Data.List (filter)\n\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =\n  let result = filter (`notElem` c) s\n  in (result, result == reverse result)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_113","nl":"nus_Latn","pl":"hs","prompt":"--Kä ɛni̱ di̱jitni̱ tin \/ci̱ tɔt rɛy i̱thtring kä inpuut.--Kä i̱thti̱riŋ i̱thti̱riŋ in caa kuëŋ thi̱n. \" gua̱th in bi̱ i̱thti̱riŋni̱ diaal cua kɛ gɛr ɛ nämbär --Ɛlɛmɛni̱ tin la̱tkɛ raar i bi̱ kɛnɛ nämbär ɛlɛmɛni̱ tin \/ci̱ tɔ̱ a kɛl rɛy --Mi ca ji̱ ka̱m li̱th ti̱ ŋuan, kä bi̱ kɛ tä kɛ di̱jitni̱, bi̱ kɛ lɛ loc ni̱ li̱th.--  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =","canonical_solution":"oddCount :: [String] -> [String]\noddCount lst = map formatString lst\n  where\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"\n\n    countOdds :: String -> Int\n    countOdds str = length $ filter isOddDigit str\n\n    formatString :: String -> String\n    formatString str =\n      let oddCount = countOdds str in\n      \"the number of odd elements \" ++ show oddCount ++ \n      \"n the str\" ++ show oddCount ++ \"ng \" ++ show oddCount ++\n      \" of the \" ++ show oddCount ++ \"nput.\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_114","nl":"nus_Latn","pl":"hs","prompt":"--Cäät --ɛ nums. --Mi̱ ca ŋun ɛ la li̱th intejeri̱, görɛ min kuiy ni̱ jɛn kä ɛni̱ tha̱b-li̱th mi̱ \/ci̱ la duŋ duŋ i̱thti̱ri̱.--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =","canonical_solution":"minsubarraysum :: [Int] -> Int\nminsubarraysum nums = minimum $ scanl1 (\\acc x -> min x (acc + x)) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_115","nl":"nus_Latn","pl":"hs","prompt":"--Cäät 1: --Nyoth pek in go̱o̱ri kɛ ɣöö bi̱ ji̱o̱mni̱ tin la̱tkɛ kɛ bi̱ɛl wä piny.--La̱tdu ɛ ɣöö bi̱ ji̱th tin te rɛy yiëër diaal luäŋ kɛ pi̱eth.--Kä kɛn dha̱a̱ri̱ diaal tekɛ kɛ lua̱ŋ mi̱ päär.--Kä te puɔ̱l pi̱i̱ni̱ diaal kɛ mi̱ päär mi̱ dëë la̱th thi̱n kɛ ɣöö ba pi̱w kulɛ ka̱m raar,--kä 1 ɛ kɛl rɛy la̱t ɛ nyothɛ yunit kɛl mi̱ la pi̱w.--ëë ji̱ moc kɛ gua̱a̱th mi̱ cuŋ ɛ la gëëk mi̱ tekɛ kɔ̱kiɛn.--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =","canonical_solution":"maxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity = ceiling (fromIntegral totalWater \/ fromIntegral capacity)\n  where\n    totalWater = sum (map sum grid)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_116","nl":"nus_Latn","pl":"hs","prompt":"--Jɛn ba yi̱k la̱t kɛ duɔ̱ɔ̱p ɛmɛ:--Kɛ kui̱ nämbäri̱ ti̱ cäät kä kɛl, ba kɛ da̱a̱k kɛ ɣöö ba pek decimal kulɛ jiek.--pek in tekɛ kɛl rɛy bainäri̱diɛn kɛ ɣöö bɛ rɔ re̱p.--Ɛn Kata ɛmɛ, bi̱ yɛn ɛ go̱r ɛn ɣöö bi̱ nɛy tin \/ci̱ kuɛnkɛ kuɛn kɛ kuɛn kɛ duɔ̱ɔ̱p in lot rɔ kɛ kɛ.--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =","canonical_solution":"import Data.Bits (popCount)\nimport Data.List (sortBy)\n\nsortArray :: [Int] -> [Int]\nsortArray arr = sortBy compareOnesAndValues arr\n  where\n    compareOnesAndValues x y =\n      let onesX = popCount x\n          onesY = popCount y\n      in if onesX == onesY\n         then compare x y\n         else compare onesX onesY","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_117","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Nöth: deri̱ jɛ car i̱ kɛn inpuɔɔ thi̱nrɛdni̱ tekɛ kɛɛ wargakni̱ kɛnɛ i̱thpëthni̱ kärɔ̱.--Mi̱ ci̱ ki̱rɛnd s te baaŋ, bi̱ pa̱ŋciin ɛ nyɔk kɛ locni̱ ɛ la li̱th mi̱ baaŋ.--n kɛ̈l kɛ̈ɛ̈li̱, kɛ ɣöö bi̱ kɛn rieet ti̱ti̱ jɔɔc rɛy thärkälä s. --mi̱ la̱t mi̱ locni̱ rie̱t diaal kä thärkdɛ (string) s tin tekɛ ɛ päär --Mi ca ji̱ moc string s kɛnɛ näci̱ral nämbär n, ba ji̱ moc la̱t kɛ ɣöö bi̱ kɛ ku lɛ la̱t kɛ jɛ.--  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =","canonical_solution":"selectWords :: String -> Int -> [String]\nselectWords s n = filter (\\word -> countConsonants word == n) (words s)\n  where\n    countConsonants = length . filter (`elem` consonants)\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_118","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Deri jɛ car i̱ ɛn thärk in ca ŋun bɛ tekɛ lɛt Ji̱ Liŋli̱th kärɔa.--jekni min la jɔc ɛ te thi̱n kä min ca lat ɛ nhial.--Mi̱ ci̱ i̱thkuɛrni̱ te rɛy tukädɛ kɛnɛ guutdɛ \/ca bi̱ kuɛn. Mi̱ ci̱ i̱thkuɛrni̱ te jɔ̱ɔ̱r, bi̱ kɛ cu loc ɛ la i̱thkuɛrni̱ ti̱ thiɛl luɔt.--Kɛn gua̱th da̱ŋ rɛw tin te kamdiɛn ɛ wä kui̱c cuëëc kä ri̱e̱t (kä cɛrika in di̱t).--Mi̱ ca ji̱ moc riet, bi̱ la̱tdu ɛ ɣöö bi̱ riet mi̱ thi̱a̱k jek mi̱ te kamdɛ kɛnɛ ri̱e̱t.--  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =","canonical_solution":"getClosestVowel :: String -> String\ngetClosestVowel word = go (reverse word) False\n  where\n    vowels = \"aeiouAEIOU\"\n    go [] _ = \"\"\n    go (x:xs) lastWasConsonant\n      | x `elem` vowels && lastWasConsonant = if null xs || not (head xs `elem` vowels) then [x] else go xs False\n      | x `notElem` vowels = go xs True\n      | otherwise = go xs False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_119","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Lɔ̱k 'Ɣɔ̱ɔ̱n' mi̱ tëëkɛ duɔ̱ɔ̱p mi̱ ba la̱t ɛ la mi̱ gɔaa, kä lɔ̱k '\/Cɛ' mi̱ dɔ̱ŋ.--\" (()) \" \/ciɛ jɛn.--ɛ ti̱ caa pa̱a̱r. Cäätdɛ: ɛn thärkɛn '(()))) ɛ mi̱ gɔaa, kä thärkɛn --Ɛ thi̱rɛnd S caar jɛ i̱ de gɔaa mi̱ kɛnɛ ɛni̱ mi̱ kɛn parenteethethethni̱ diaal rɛy S --tha̱a̱ŋ la̱t, min bi̱ ben raar bɛ a mi̱ gɔaa.--La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ de rɔ lot kɛ ɣöö bi̱ kɛn rɛw ti̱ti̱ mat kɛɛl rɛy gua̱th in ci̱kɛ thuɔ̱k.--kɛ kamni̱ tin te \" (() \" kiɛ kamni̱ tin te \") \" kärɔ̱.--ɛ ji̱n bi̱ lɛl mi̱ tekɛ tha̱a̱ŋ rɛw ti̱ ci̱ rɔ̱ la̱th thi̱n, kɛn tha̱a̱ŋ rɛw diaal bi̱kɛ te kɛ open--  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =","canonical_solution":"matchParens :: [String] -> String\nmatchParens [a, b] =\n    if isValid (a ++ b) || isValid (b ++ a) then \"Yes\" else \"No\"\n  where\n    isValid :: String -> Bool\n    isValid = go 0\n      where\n        go 0 [] = True\n        go _ [] = False\n        go n (x:xs)\n            | x == '('  = go (n + 1) xs\n            | x == ')'  = n > 0 && go (n - 1) xs\n    isValid _ = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_120","nl":"nus_Latn","pl":"hs","prompt":"--Cäät 1: --kä räthdɛ kä k kä ɛ mi̱ di̱i̱t kä k nämbäri̱ rɛy arr.--Mi ca ŋun ɛ la li̱th arr kä intejeri̱ kɛnɛ puɔ̱thi̱tip intejeri̱ k, locni̱ li̱th mi̱ ca riali̱kä--  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the list will be in the range of [1, 1000].\n--  2. The elements in the list will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =","canonical_solution":"maximum :: [Int] -> Int -> [Int]\nmaximum arr k = take k $ reverse $ sort arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_121","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱ --Mi̱ ca ŋun ɛ la mi̱ \/ci̱ la mi̱ te jɔ̱ɔ̱r kä intɛrjiɛrni̱, locni̱ mat kä ɛlɛmɛni̱ diaal tin te i̱thpethi̱thni̱ ti̱ ji̱di̱tni̱.--  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =","canonical_solution":"solution :: [Int] -> Int\nsolution lst = sum [x | (i, x) <- zip [0..] lst, odd x, even i]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_122","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Kä mat ŋɔaani̱ tin tekɛ di̱jitni̱ rɛw ɛlɔ̱ŋ kä kɛn tin nhiam k tin te kä arr.--Mi̱ ca ŋun ɛ la mi̱ \/ci̱ la mi̱ te jɔ̱ɔ̱r kä intejeri̱ arr kɛnɛ intejeri̱ k, locni̱kɛ --  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =","canonical_solution":"addElements :: [Int] -> Int -> Int\naddElements arr k = sum $ filter (\\x -> x >= -99 && x <= 99) $ take k arr","tests":"\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_123","nl":"nus_Latn","pl":"hs","prompt":"--get_odd_collatz(5) locni̱ [1, 5] # Kä collatz thekuɛnthi̱ kɛ kui̱ 5 ɛ [5, 16, 8, 4, 2, 1], kɛ kui̱c ɛmɔ nämbäri̱ tin \/ci̱ tɔ̱ a kɛl ɛ 1, kɛnɛ 5. --Ciee cäät ɛmɛ: --2. li̱th mi̱ ca luɔ̱c jɔk kä ca riali̱kä kɛ ɣöö bɛ rɔ re̱e̱p.--1. Collatz ((1) ɛ [1]. --Nöt: --Kä kɔnjeciɛr ɛ jɛn i̱ ɛni̱ mi̱ tekɛ luɔt kä n, bi̱ thi̱kuɛnthi̱ ni̱ ciaaŋ cop 1.--Mi̱ ci̱ ci̱öl ëë nhiam ɛ mi̱ \/ci̱ päär, bi̱ ci̱öl in dɔ̱ŋ ɛ mi̱ ca loc ɛ 3 kä ci̱öl ëë nhiam.--kɛ kɔr kä mi̱ ci̱kɛ te kɛɛl, bi̱ kɛ cu te kɛɛl ɛ la nuth kä --cetkɛ min ba lat: tokɛ kɛ pek mi̱ tekɛ thuɔ̱k mi̱ ca mat ɛ la intejeri̱ n. Kä kɛ kɔrɛ ba mi̱ ca mat ɛ la mi̱ ji̱o̱li̱kɛn ɛ jiek kä --Kä Köllatdh kɔnjeciɛr ɛ kɔnjeciɛr rɛy mɛthä min ruac kɛ kui̱ kä min ca lat kä thi̱kuɛnthi̱ --Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔthtip intejiɛr n, locni̱ li̱th mi̱ ca riali̱kä min tekɛ nämbäri̱ ti̱ ji̱di̱t rɛy thekuɛnthi̱ Köllatz.--  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =","canonical_solution":"getOddCollatz :: Int -> [Int]\ngetOddCollatz n = sort . filter odd $ collatzSequence n\n  where\n    collatzSequence 1 = [1]\n    collatzSequence x\n      | even x    = x : collatzSequence (x `div` 2)\n      | otherwise = x : collatzSequence (3 * x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_124","nl":"nus_Latn","pl":"hs","prompt":"--4.Ɛ cäŋ ɛmɔ ba̱rɛ ɛ mi̱ ca la̱t kɛ ca̱p mi̱ cie: mm-dd-yyyy --3. Kä päth \/ci̱kɛ bi̱ te piny 1 kiɛ bi̱ di̱t ni̱ kä 12.--2. \/Ci̱ pek ni̱ni̱ tɔ̱tɔ̱ bi̱ kuɛ̈ɛ̈ ni̱ kä 1 kiɛ bi̱kɛ di̱t ni̱ kä 31 kɛ päth 1,3,5,7,8,10,12. \/Ci̱ pek ni̱ni̱ tɔ̱tɔ̱ bi̱ kuɛ̈ɛ̈ ni̱ kä 1 kiɛ bi̱kɛ di̱t ni̱ kä 30 kɛ päth 4,6,9,11. \/Ci̱ pek ni̱ni̱ tɔ̱tɔ̱ bi̱ kuɛ̈ɛ̈ ni̱ kä 1 kiɛ bi̱kɛ di̱t ni̱ kä 29 kɛ päth 2.--1. Kä cäŋ ɛ\/ciɛɛ mi̱ te jɔ̱ɔ̱r.--Ɛn cäŋ ɛ mi̱ la thuɔ̱k mi̱ caa ŋuɔ̱t ti̱ti̱ diaal la̱th thi̱n:--loc ni̱ thuɔ̱k mi̱ ci̱ cäŋ ɛ thuɔ̱k mi̱ dɔ̱ŋ ɛ kac.--ëë ji̱n bi̱ la̱t mi̱ bi̱ la̱t mi̱ ci̱ rɔ lot kɛ gua̱th in ca ŋun kɛnɛ --  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06\/04\/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =","canonical_solution":"import Text.Read (readMaybe)\nimport Data.List.Split (splitOn)\n\nvalidDate :: String -> Bool\nvalidDate date =\n    case splitOn \"-\" date of\n        [m, d, y] -> isValidMonthDayYear m d y\n        _         -> False\n\nisValidMonthDayYear :: String -> String -> String -> Bool\nisValidMonthDayYear m d y =\n    case (readMaybe m :: Maybe Int, readMaybe d :: Maybe Int, readMaybe y :: Maybe Int) of\n        (Just month, Just day, Just year) -> isValidMonth month && isValidDay month day\n        _ -> False\n\nisValidMonth :: Int -> Bool\nisValidMonth month = month >= 1 && month <= 12\n\nisValidDay :: Int -> Int -> Bool\nisValidDay month day\n    | month `elem` [1, 3, 5, 7, 8, 10, 12] = day >= 1 && day <= 31\n    | month `elem` [4, 6, 9, 11]           = day >= 1 && day <= 30\n    | month == 2                           = day >= 1 && day <= 29\n    | otherwise                            = False","tests":"\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_126","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱ --Nömber, locni̱ mi̱ la kac. \/Cuɛ naŋni̱ nämbäri̱ ti̱ jiek kä ɛ intejeri̱ kärɔ̱.--Mi̱ ci̱ li̱th tekɛ ti̱ ŋuan kä kɛl, bi̱ kɛ cu wä nhial kɛ duɔ̱ɔ̱p mi̱ päär.--Mi ca ji̱ moc kɛ li̱th nämbäri̱, bi̱ kɛ loc ɛ la ti̱ ca riali̱kä kiɛ \/ka̱n riali̱kä.--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =","canonical_solution":"isSorted :: [Int] -> Bool\nisSorted lst = go lst Nothing\n  where\n    go [] _ = True\n    go [x] _ = True\n    go (x:y:xs) prev\n      | x > y = False\n      | x == y && prev == Just x = False\n      | otherwise = go (y:xs) (Just x)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_127","nl":"nus_Latn","pl":"hs","prompt":"--[input\/output] samples: --Mi̱ ci̱ kamni̱ da̱ŋ rɛw \/ci̱kɛ bi̱ te kɛɛl, bi̱ loc ni̱ \"ƔE\".--mi̱ \/ci̱e jɛn, locni̱ \"\/CƐ\".--Mi̱ ci̱ pek in ci̱ rɔ röm ɛ mi̱ la praam nämbär, locni̱ \"YƐƐ\", --Kä min la bäärɛ ɛ 1, min \/ci̱kɛ la praam nämbär.--Cäätdɛ, ɛn kam kamni̱ gua̱th in te kam (1, 3), (2, 4) ɛ (2, 3) --Kä gua̱th ɛ la nämbär präm.--La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ ɛ pek in ci̱ kamdiɛn rɔ̱ röm kɛ kɛn rɛw ti̱ti̱ --Kɛ gua̱th in ca ŋun, jɛn ba naŋ i̱ jɛn tukdɛ ɛ kuiy kiɛ päärkɛ kɛ guutdɛ.--matkɛ tuk kɛnɛ guut.--Kä gua̱th tin ca ŋun tëkɛ mi̱ ca gäk min lotni̱ ɣöö gua̱th (ka̱m raar, guut)--gua̱th in bi̱ kamni̱ diaal ɛ la pek mi̱ matkɛ ɛ la intejeri̱. Cäät, kamni̱ = (ka̱m raar, guut) = (1, 2).--Ji̱n caa ji̱ moc gua̱th da̱ŋ rɛw,--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =","canonical_solution":"intersection :: (Int, Int) -> (Int, Int) -> String\nintersection (start1, end1) (start2, end2) = \n    if intersectionLength > 0 && isPrime intersectionLength\n    then \"YES\"\n    else \"NO\"\n  where\n    intersectionStart = max start1 start2\n    intersectionEnd = min end1 end2\n    intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    isPrime :: Int -> Bool\n    isPrime n\n      | n <= 1 = False\n      | n == 2 = True\n      | otherwise = null [x | x <- [2..(floor . sqrt . fromIntegral) n], n `mod` x == 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_128","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --No̱o̱ŋ: \/thiɛlɛ mi̱ ba loc kɛ kui̱ kä mi̱ thiɛl luɔt.--kä nämbärni̱ diaal rɛy li̱thä, cuŋkɛ ɛ la 1, -1 kiɛ 0.--Kɛn matdiɛn kɛn nyin intejeri̱ tin di̱t tin ca pi̱e̱e̱l ɛ la tin ca la̱t ɛ kɛn tin la nyuuthni̱kɛ diaal.--Mi̱ ci̱i̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱ mi̱ ci̱e̱.--  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =","canonical_solution":"prodSigns :: [Int] -> Maybe Int\nprodSigns [] = Nothing\nprodSigns arr = Just $ sum (map abs arr) * product (map signum arr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_129","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Mi̱ ci̱ duɔ̱ɔ̱r loc thi̱n ɛ la mi̱ ca riali̱kä kä bi̱ pekdɛ kulɛ te rɛy thëlli̱ min bi̱ min kuiy ni̱ jɛn kulɛ wä thi̱n.--Jɛn cua ŋun i̱ luɔcdɛ bɛ a kɛl kärɔa.--lst_A[j] = lst_B[j]. --cetkɛ lst_A[i] < lst_B[i] kɛnɛ j (1 <= j < i) mi̱ tekɛ --kä lst_B, kɛ rie̱t ti̱ kɔ̱kiɛn, tëkɛ intejeri̱ indi̱dhɛth i (1 <= i <= k) --kɛ (nɛy kɛ ciöt i̱ lst_A kɛnɛ lst_B), lst_A ɛ mi̱ kuiy kä kɛ̈l kɛ̈ɛ̈li̱--kɛ kɔr kä mi̱ ca riali̱kä kɛ kui̱ kä min ca la̱t kä ba̱li̱öni̱ kä ba̱li̱öni̱ tin wä A kɛnɛ B --Ɛn duɔ̱ɔ̱p A (mi̱ bäärkɛ k) ba naŋ i̱ kuiy ni̱ jɛn kä duɔ̱ɔ̱p B (mi̱ bäärkɛ k) mi̱ --\/Ci̱ rɔ bi̱ lot ɛn ɣöö bi̱ ji̱n rɔ bath kä ji̱n.--\/Ci̱kɛ bi̱ lɛ dääk).--Titdɛ ɛn ɣöö duɔ̱ɔ̱p mi̱ bäär k lotdɛ ni̱ ɣöö ba thëlli̱ k wä thi̱n (\/ci̱kɛ --thɛl. --kɛ rieet ti kɔ̱ŋ, deri wä kä thëlli̱ tin nyuak yi̱k kɛ ji̱ ɛntäämɛ --kä thëlli̱, kä kɛ duɔ̱ɔ̱p kɛl, deri̱ wä kä thëlli̱ tin thieek kɛ ji̱, --Ji̱n bi̱ yi̱k duɔ̱ɔ̱p mi̱ tɔt mi̱ bi̱ jɔɔc kä k rɛy gua̱th in ca ji̱ yi̱k yi̱k yi̱k yi̱k yi̱k.--inclusive bɛ jɔɔc ɛ la kɛl kärɔa kä thëlli̱ kä gi̱ri̱d.--Kä thëlli̱ diaal kä gi̱ri̱d tekɛ kɛ ba̱li̱ö. ɛ intejeri̱ diaal rɛy gua̱th in te [1, N * N] --Mi̱ ca ŋun ɛ la mi̱ tekɛ N (N) rɔɔmni̱ kɛnɛ N (N) kɔlömni̱ (N >= 2) kɛnɛ ɣöö ɛ mi̱ tekɛ puɔthtip intejer k, --  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =","canonical_solution":"import Data.List (sort, sortBy)\nimport Data.Ord (comparing)\nimport Control.Monad (guard)\n\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k = head $ sort paths\n  where\n    n = length grid\n    cells = [(r, c) | r <- [0..n-1], c <- [0..n-1]]\n    neighbors (r, c) = filter inBounds [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n      where\n        inBounds (x, y) = x >= 0 && x < n && y >= 0 && y < n\n    value (r, c) = grid !! r !! c\n    paths = do\n      start <- cells\n      findPaths k [start]\n    findPaths 1 path = return $ map value path\n    findPaths l path@(current:_) = do\n      next <- neighbors current\n      findPaths (l-1) (next : path)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_130","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --N + 1 tin nhiam kä Tri̱bönatci̱ thi̱kuɛnthi̱.--Ji̱n ca ji̱ ka̱m nämbär mi̱ \/ci̱ mɔ a nägativ, bi̱ ji̱n ɛ go̱r i̱ bi̱ loc ni̱ li̱th duŋ kä --= 2 + 3 + 3 = 8 --Tri ((3) = tri ((2) + tri ((1) + tri ((4) --trɛ ((4) = 3 --tri(2) = 1 + (2 \/ 2) = 2 --Ciee cäät ɛmɛ: --trɛ (n) = trɛ (n - 1) + trɛ (n - 2) + trɛ (n + 1), mi̱ n ɛ mi̱ \/ci̱ mɔ a kɛl.--trithn) = 1 + n \/ 2, mi̱ n ɛ päär.--tri(1) = 3 --Tribönaki̱ thi̱kuɛnthi̱ ɛ mi̱ la latkɛ ɛ la mi̱ ci̱ rɔ nyɔk kɛ luɔ̱c:--Kä min \/ca ŋäc ɛ nɛy diaal ɛ jɛn Tribönaki̱ thi̱kuɛnthi̱.--Kɛn diaal ŋa̱ckɛ pe̱k in la Fibönatci, jɛn cua ŋi̱e̱e̱c ɛlɔ̱ŋ ɛ mɛthemati̱ciani̱ rɛy--  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =","canonical_solution":"tri :: Int -> [Int]\ntri n = map tribonacci [0..n]\n  where\n    -- Define the recursive function to calculate the tribonacci value for a given n\n    tribonacci :: Int -> Int\n    tribonacci 0 = 1\n    tribonacci 1 = 3\n    tribonacci x\n      | even x    = 1 + x `div` 2\n      | otherwise = tribonacci (x - 1) + tribonacci (x - 2) + tribonacci (x + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_131","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Lɔ̱a̱r 0 mi̱ ci̱ digitni̱ diaal ɛ pari̱.--Mi ca ŋun ɛ la mi̱ tekɛ puɔthtip intejer n, locni̱ pröda̱kciɔn duŋ di̱jitni̱ tin \/ci̱ tɔt.--  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =","canonical_solution":"digits :: Int -> Int\ndigits n\n  | null oddDigits = 0\n  | otherwise      = product oddDigits\n  where\n    oddDigits = [digit | digit <- map (read . (:[])) (show n), odd digit]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_132","nl":"nus_Latn","pl":"hs","prompt":"--gua̱th in bi̱ kɛ rɔ̱ mat thi̱n ɛ la kɛl kä bi̱kɛ rɔ̱ mat thi̱n.--La̱t ba loc i̱ ɛ thuɔ̱k mi̱ kɛnɛ ɛni̱ mi̱ tekɛ mi̱ ca la̱th piny mi̱ lot rɔ kɛ kɛ.--Lätdɛ kɛ ɣöö bɛ la̱t mi̱ bi̱ te thi̱n kä bi̱ te ni̱ kɛ gua̱th mi̱ ci̱e̱e̱ gua̱a̱th in ca gɔ̱a̱r thi̱n.--  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =","canonical_solution":"isNested :: String -> Bool\nisNested string = go string 0 False\n  where\n    go [] _ nested = nested\n    go (x:xs) depth nested\n      | x == '['  = go xs (depth + 1) (nested || depth >= 1)\n      | x == ']' && depth > 0 = go xs (depth - 1) nested\n      | otherwise = go xs depth nested","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_133","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --la̱t kɛ̈l kɛ̈ɛ̈li̱ rɛy li̱thä ɛ wä kä min te nhial int ((Thäl) kɛ nhiam.--Ji̱n bi̱ yi̱k loc ni̱ pek nämbäri̱ tin ca kuëŋ kä i̱thkuɛr rɛy li̱thä min ca ŋun, --❑ Ca ji̱ moc kɛ li̱th nämbäri̱.--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =","canonical_solution":"import Data.List (foldl')\nimport Prelude hiding (sum)\n\nsumSquares :: [Float] -> Int\nsumSquares lst = foldl' (\\acc x -> acc + ceiling x ^ 2) 0 lst","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_134","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Nöb: \"Ruac\" ɛ buɔ̱n kä tin ca da̱a̱k ɛ kam.--ɛ tha̱a̱ŋ ruac, kä kac ɛ mi̱ dɔ̱ŋ.--kä min ca ŋun kä thi̱rŋ ɛ alpabetik kä \/ci̱ɛ --Lätni̱ mi̱ bi̱ loc ni̱ thuɔ̱k mi̱ ci̱kɛ thuɔ̱k kä bi̱kɛ cu te thi̱n ɛ la bi̱kɛ cu te thi̱n ɛ la bi̱kɛ cu te thi̱n.--  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =","canonical_solution":"checkIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt = \n    let trimmed = reverse . dropWhile (== ' ') $ reverse txt\n    in case trimmed of\n        [] -> False\n        (x:xs) -> isAlpha x && (null xs || head xs == ' ')","tests":"\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_135","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --duplikɛtni̱ ba̱li̱öni̱.--\/thiɛlɛ mi̱ ce̱tkɛ ɛn ɛlɛmɛni̱ ɛ te thi̱n ɛn wa̱nɔ bɛ loc -1. Kä li̱th min ca ŋun bɛ thiɛl --\/ci̱kɛ di̱tni̱ kɛn kiɛ päärkɛ kɛ ɛlɛmɛni̱ tin te thi̱n ni̱ wän.--Lätni̱ mi̱ la̱tkɛ kɛ ɣöö bɛ läätni̱ tin di̱t ni̱ kɛn diaal luɔ̱c jɔk kä ɛlɛmɛni̱ tin ca lɛy ɛ la --  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =","canonical_solution":"canArrange :: [Int] -> Int\ncanArrange arr = go arr (-1) 0\n  where\n    go [] maxIdx _ = maxIdx\n    go [_] maxIdx _ = maxIdx\n    go (x:y:xs) maxIdx idx\n      | x >= y    = go (y:xs) idx (idx + 1)\n      | otherwise = go (y:xs) maxIdx (idx + 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_136","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Mi̱ thiɛlɛ negɛtib kiɛ puɔ̱thitib intejeri̱, bi̱ kɛn loc ɛ la Nothɛr.--Kä min ca la̱t ɛ la mi̱ ca mat kä puci̱tib intejeri̱ rɛy li̱thä.--Kä min di̱tni̱ jɛn kä min ca mat ɛ mi̱ \/ci̱ gɔaa, kä b ɛ mi̱ tɔt kä kɛndial.--Lätni̱ mi̱ la̱tkɛ kɛ ɣöö bɛ locni̱ tuple (a, b), gua̱th in bi̱ 'a' ɛ --  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =","canonical_solution":"largestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst = (largestNegative, smallestPositive)\n  where\n    negatives = filter (< 0) lst\n    positives = filter (> 0) lst\n    largestNegative = if null negatives then Nothing else Just (maximum negatives)\n    smallestPositive = if null positives then Nothing else Just (minimum positives)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_138","nl":"nus_Latn","pl":"hs","prompt":"--Cäät --Ɣo̱thdɛ ɛn nämbär n ɛ mi̱ de gɔ̱r ɛ la mat nämbäri̱ ti̱ ŋuan ti̱ puɔthtip.--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =","canonical_solution":"isEqualToSumEven :: Int -> Bool\nisEqualToSumEven n = n > 0 && n `mod` 2 == 0 && n >= 8","tests":"\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_139","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --gua̱th in n > 0 --brazilian_factorial (n) = n! * (n-1)! * (n-2)! * ... * 1! --Kä Brazil ɛ mi̱ la̱tkɛ ɛ la̱t ɛ latdɛ i̱:--  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =","canonical_solution":"specialFactorial :: Int -> Int\nspecialFactorial n = product [factorial x | x <- [1..n]]\n  where\n    factorial 0 = 1\n    factorial k = k * factorial (k - 1)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_140","nl":"nus_Latn","pl":"hs","prompt":"--kä bɛ kamni̱ diaal tin guɔ̱rkɛ rɔ̱ gɛr kɛ - --kä mi̱ ci̱ thärkdɛ tekɛ gua̱th ti̱ ŋuan ti̱ läny 2 ti̱ guɔ̱rkɛ rɔ̱, --Mi ca ji̱ moc biɛl mi̱ gɔa, loc kamni̱ diaal kɛ biɛl in te piny, --  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =","canonical_solution":"fixSpaces :: String -> String\nfixSpaces text = concatMap replaceSpaces (groupSpaces text)\n  where\n    groupSpaces :: String -> [String]\n    groupSpaces [] = []\n    groupSpaces xs@(x:_) = let (g, rest) = span (== x) xs in g : groupSpaces rest\n\n    replaceSpaces :: String -> String\n    replaceSpaces spaces@(x:_)\n      | x == ' ' && length spaces > 2 = \"-\"\n      | x == ' ' = replicate (length spaces) '_'\n      | otherwise = spaces","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_141","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --- Kä thöp-thɛrn in guur dot ba yi̱k la kɛl kä ti̱ti̱: ['txt', 'exe', 'dll'] --kä Latin alphabet ('a'-'z' kɛnɛ 'A'-'Z').--- Kä thöp-thɛrn ɛ ŋot \/cɛ bi̱ te baaŋ, kä jɛn bɛ tok kɛ wargak mi̱ bëë kä --- Kä ciöt in ca gɔ̱r thi̱n ɛ mi̱ tekɛ dot kɛl '.' --- \/Ci̱kɛ bi̱ tekɛ di̱jitni̱ ti̱ ŋuan kä diɔ̱k ('0'-'9') rɛy ci̱ötdä kɛ kui̱ kä min ca gɔ̱r.--caa kɛ luäŋ: --Ɛn ciöt in caa gɔ̱r ɛ la mi̱ lot rɔdɛ kä tin diaal tin caa lat piny ɛ mɛ.--\"Ɣɔ̱ɔ̱n\" mi̱ ci̱ ciöt in ca gɔ̱r ɛ thuɔ̱k, kä luɔcɛ \"\/Cɛ\" mi̱ dɔ̱ŋ.--Lätni̱kɛ pa̱ŋciin mi̱ naŋkɛ ciöt kä pa̱l-tɛ-rɛl, kä luɔ̱c kɛ ɛ pa̱l-tɛ-rɛl--  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =","canonical_solution":"import Data.Char (isDigit, isLetter)\n\nfileNameCheck :: String -> String\nfileNameCheck file_name \n  | countDots \/= 1 = \"No\"\n  | length digits > 3 = \"No\"\n  | null beforeDot || not (isLetter (head beforeDot)) = \"No\"\n  | afterDot `notElem` validExtensions = \"No\"\n  | otherwise = \"Yes\"\n  where \n    (beforeDot, afterDot) = span (\/= '.') file_name\n    countDots = length $ filter (== '.') file_name\n    digits = filter isDigit file_name\n    validExtensions = [\"txt\", \"exe\", \"dll\"]\n    afterDot = if null dotAndAfter then \"\" else tail dotAndAfter\n    dotAndAfter = dropWhile (\/= '.') file_name","tests":"\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"\/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_142","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Ɛn pa̱ŋciin bɛ kulɛ loc ni̱ min ca mat kä tin ca gɔ̱r piny ɛ la tin \/ci̱ ŋuan kɛ 3 kiɛ 4.--ɛ mi̱ la ti̱ ŋuan kä 3 kä bi̱ cubi̱ la̱t intejeri̱ mi̱ ci̱ i̱ndɛkdɛ ɛ mi̱ la ti̱ ŋuan kä 4 kä \/ci̱ɛɛ mi̱ la ti̱ ŋuan kä 3.--La̱t ɛmɛ bɛ naŋ ɛ la li̱th duŋ intejeri̱. kɛ kui̱ kä tin ca gɔ̱r rɛy li̱thä, la̱t bɛ i̱thkuɛr intejeri̱ i̱thkuɛr mi̱ indi̱dhɛthdɛ ɛ a --\" --  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =","canonical_solution":"sumSquares :: [Int] -> Int\nsumSquares lst = sum $ zipWith transform [0..] lst\n  where\n    transform idx x\n      | idx `mod` 3 == 0 = x * x\n      | idx `mod` 4 == 0 = x * x * x\n      | otherwise        = x","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_143","nl":"nus_Latn","pl":"hs","prompt":"--Cäät 1: --kä min ca lat kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot kä ci̱ rɔ lot.--min bäärɛ ɛ mi̱ la praam nämbäri̱, --kä bi̱ ji̱n ɛ loc i̱thtiring mi̱ te rieetkɛ thi̱n kä thënci̱ɛr in nhiam, --ɛn thanyni̱ tëkɛ rieet ti̱ caa da̱a̱k ɛ kam, --ëë ji̱ moc kɛ bi̱ɛl mi̱ cuŋ kɛ kui̱ thënciɛn, --  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =","canonical_solution":"import Data.List (intercalate)\n\nwordsInSentence :: String -> String\nwordsInSentence sentence = intercalate \" \" $ filter (isPrime . length) (words sentence)\n\nisPrime :: Int -> Bool\nisPrime n | n < 2     = False\n          | otherwise = null [ x | x <- [2..isqrt n], n `mod` x == 0 ]\n\nisqrt :: Int -> Int\nisqrt = floor . sqrt . fromIntegral","tests":"\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_144","nl":"nus_Latn","pl":"hs","prompt":"--Deri jɛ car i̱ x, kɛnɛ n kɛn kɛ pi̱rɛkciɔni̱ ti̱ la̱tkɛ, kä \/ci̱kɛ la̱tkɛ ɛ dhɛrö.--<numerator>\/<denominator> gua̱th in bi̱ kɛn da̱ŋ rɛw ɛ la nämerɛtɔr kɛnɛ denominɛtɔr ɛ la puɔ̱thitib nämbäri̱ ti̱ rɛlrɔ̱.--Kɛn x kɛnɛ n, kɛn kɛ rɛw ti̱ cuŋkɛ ɛ la ti̱ ca ŋun, kä tekɛ kɛ ta̱a̱ in guur, --x * n. La̱t ɛ nyɔk kɛ loc ɛ la thuɔ̱k mi̱ x * n ɛ mi̱ ca pekdɛ ŋa̱c kä ɛ mi̱ la thuɔ̱k kä ɛ mi̱ \/ci̱ thuɔ̱k.--Lätdu ɛ ɣöö bi̱ la̱t ɛ la̱t mi̱ bi̱ duɔ̱ɔ̱r jakä kuiy ɛ la mi̱ bi̱ duɔ̱ɔ̱r jakä bum.--  >>> simplify \"1\/5\" \"5\/1\"\n--  True\n--  >>> simplify \"1\/6\" \"2\/1\"\n--  False\n--  >>> simplify \"7\/10\" \"10\/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =","canonical_solution":"import Data.Ratio (denominator, numerator, (%))\n\nsimplify :: String -> String -> Bool\nsimplify x n =\n  let (xNum, xDen) = toFraction x\n      (nNum, nDen) = toFraction n\n      result = (xNum * nNum) % (xDen * nDen)\n  in denominator result == 1\n\ntoFraction :: String -> (Integer, Integer)\ntoFraction s =\n  let (numStr, _:denStr) = break (=='\/') s\n  in (read numStr, read denStr)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/6\" \"2\/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/1\" \"3\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/10\" \"10\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/10\" \"50\/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7\/2\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11\/6\" \"6\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/3\" \"5\/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5\/2\" \"3\/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"8\/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2\/4\" \"4\/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"5\/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1\/5\" \"1\/5\" == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_145","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --la̱thkɛ kɛ kä indexdiɛn rɛy li̱thä min nhiamdiɛn.--No̱o̱ŋ: mi̱ tëë kɛ ti̱ ŋuan ti̱ te kɛɛl kɛ pek mi̱ cäät kä di̱jitni̱kiɛn, --kɛ räthdiɛn nhial kɛ duɔ̱ɔ̱p in wä nhial kɛ pek di̱jitni̱kiɛn.--ɛ gɔ̱r pa̱ŋciin min bi̱ lɛlni̱ tin ca ŋun kä intɛrjiɛrni̱--  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =","canonical_solution":"import Data.List (sortBy)\nimport Data.Function (on)\n\norderByPoints :: [Int] -> [Int]\norderByPoints nums = map snd $ sortBy (compare `on` fst) indexedNums\n  where\n    sumOfDigits :: Int -> Int\n    sumOfDigits n = sum (map (abs . read . return) $ show $ abs n)\n    \n    indexedNums :: [(Int, Int)]\n    indexedNums = zip (map sumOfDigits nums) nums","tests":"\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_146","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --ɛni̱ di̱jitni̱ tin nhiam kɛnɛ tin jɔak kä nämbär ɛ la tin \/ci̱ rɔ̱ pa̱a̱r (1, 3, 5, 7, 9).--pek in di̱tni̱ jɛn kä 10 kä kɛn rɛw diaal tin te rɛy li̱thä--ɛ gɔ̱r pa̱ŋciin mi̱ naŋɛ nämbäri̱ ti̱ ŋuan kä bɛ kɛ loc ɛ la inpuut.--  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =","canonical_solution":"specialfilter :: [Int] -> Int\nspecialfilter nums = length $ filter isSpecial nums\n  where\n    isSpecial n = n > 10 && isOddFirstAndLast (abs n)\n\n    isOddFirstAndLast :: Int -> Bool\n    isOddFirstAndLast x = isOddDigit firstDigit && isOddDigit lastDigit\n      where\n        xStr = show x\n        firstDigit = head xStr\n        lastDigit = last xStr\n\n    isOddDigit :: Char -> Bool\n    isOddDigit c = c `elem` \"13579\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_147","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --kä a[i] + a[j] + a[k] ɛ mi̱ ca loc ɛ 3.--Lätdɛ kɛ nämbär kä diɔ̱k (a[i], a[j], a[k]) kä a gua̱th in i < j < k, --Kɛ i̱thkuɛr i̱thkuɛrä (1 ≤ i ≤ n), kä ba̱li̱ö duŋ a[i] = i * i - i + 1. --ëë ji̱ ka̱m kɛ nämbär puɔthtip intejer n. Ji̱n bi̱ yi̱k ni̱ la̱t intejer list mi̱ bäär ɛ n.--  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =","canonical_solution":"getMaxTriples :: Int -> Int\ngetMaxTriples n = length [(a[i], a[j], a[k]) | i <- [0..n-1], j <- [i+1..n-1], k <- [j+1..n-1], (a !! i + a !! j + a !! k) `mod` 3 == 0]\n  where\n    a = [i * i - i + 1 | i <- [1..n]]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_149","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --Deri̱ jɛ car i̱ kɛn rie̱e̱t diaal bi̱ kɛ tekɛ pe̱k mi̱ päär.--Kä pa̱ŋciin bɛ yi̱k luɔ̱c raar kä thärkdɛ kɛ ɣöö ba kɛ riali̱kä.--Mi̱ ci̱ rie̱e̱t da̱ŋ rɛw tekɛ kɛ pek mi̱ päär, riali̱kɛ kɛn li̱th ɛ la alpɛbët.--bi̱ kɛ lɛni̱ lɛ loc kä min ca riali̱kä ɛ ŋuɔ̱t ɛmɔ.--Kä riali̱kä min ca gɔ̱r ba yi̱k kulɛ wä nhial kɛ pek rie̱tdä, kä bi̱ ji̱n ɛ go̱r i̱ bi̱ kulɛ wä nhial.--kä derɛ tekɛ duplikɛtni̱.--Kä li̱th ni̱ ciaaŋ ɛ li̱th duŋ thi̱ri̱ndi̱ni̱ kä \/ci̱ɛɛ li̱th nämbäri̱, --kä cuɛ min ca jiek luɔ̱c jɔk kɛ li̱thdɛ kɛ duɔ̱ɔ̱p mi̱ ca riali̱kä, --la̱thkɛ ni̱ thɛrndni̱ tin tekɛ pe̱k ti̱ na̱n kɛ jɛ, --ɛ gɔ̱r pa̱ŋciin mi̱ bi̱ rɔ lot kɛ li̱th ti̱ ca gɔ̱r piny ɛ la parɛmatɛr, --  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =","canonical_solution":"sortedListSum :: [String] -> [String]\nsortedListSum lst = sortBy compareStrings (filter evenLength lst)\n  where\n    evenLength s = even (length s)\n    compareStrings s1 s2\n      | length s1 == length s2 = compare s1 s2\n      | otherwise = compare (length s1) (length s2)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_150","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --ɛ prɔmjɛr nämbär kä bi̱ yi̱o̱w luɔ̱c kä ba̱li̱ö duŋ y mi̱ dɔ̱ŋ.--Ɛ prɔgi̱ra̱m mi̱ thi̱a̱k mi̱ bi̱ luɔ̱c i̱ ɛ ŋu kä x mi̱ n ɛ --  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =","canonical_solution":"xOrY :: Int -> Int -> Int -> Int\nxOrY n x y = if isPrime n then x else y\n\nisPrime :: Int -> Bool\nisPrime k\n  | k < 2     = False\n  | otherwise = null [ x | x <- [2..k-1], k `mod` x == 0 ]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_151","nl":"nus_Latn","pl":"hs","prompt":"--Kä \/ci̱kɛ bi̱ te rɛy li̱thä min la pe̱kdiɛn. \/Cuɛ pe̱kdiɛn lot kɛ ɣöö \/ci̱kɛ bi̱ te rɛy intejeri̱.--Mi ca ji̱ ka̱m li̱t nämbäri̱, locni̱ pek nämbäri̱ tin ca i̱kuɛrkɛ--  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =","canonical_solution":"doubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst = \n    sum [x * x | x <- map round lst, x > 0, odd x]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_152","nl":"nus_Latn","pl":"hs","prompt":"--cäät: --Kä ba̱li̱öm ɛ 0, kä mi̱ \/ci̱ jɛn ba̱li̱öm ɛ dääk mi̱ thuɔ̱k kam guäc kɛnɛ pek in ca ŋun.--Läthni̱ li̱th mi̱ päär bäärɛ kɛ pek in ci̱ rɔ rɛl kɛ jɛ. Mi̱ ci̱kɛ jɛ car i̱ ɛ thuɔ̱k, --Ji̱n caa ji̱ moc li̱thni̱ rɛw ti̱ tä kɛ puny kɛnɛ guäc ti̱ päär, gua̱th in bi̱ index in kɛl ɛ nyoth ɛ päär.--La̱tdu ɛ ɣöö bi̱ ji̱n ɛ ŋa̱c i̱ mi̱ ci̱ raan ɛ ŋa̱c i̱ de pek in ci̱ ben raar kä matni̱kɛ thuɔ̱k.--Ɛ mi̱ gɔaa i̱ dëë kuɛn kä dëë pa̱a̱r.--Ɛn min ci̱ tuɔɔk kä ji̱ ɛ min ci̱ tuɔɔk kä nɛy diaal tin te rɛy wec.--Cä jɛ car ɛn ɣöö bi̱ nɛy diaal ɛ tim ɛn ɣöö ci̱ nɛy rɔ̱ car kɛ pek mi̱ bäär.--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =","canonical_solution":"compare :: [Int] -> [Int] -> [Int]\ncompare game guess = zipWith (\\g s -> abs (g - s)) game guess","tests":"\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_153","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --(kä buɔ̱mdɛ ɛ -1).--locni̱ 'Slices.SErviNGSliCes' ni̱ mëë 'SErviNGSliCes' ɛ jɛn in bumni̱jɛn kä repni̱kɛ --mi̱ ci̱kɛ lɛ be̱n gɔ̱r: ['SErviNGSliCes', 'Cheese', 'StuFfed'] bi̱ kɛ ku lɛ gɔ̱r i̱ --Ciee cäät ɛmɛ, mi ca ji̱ moc \"Slices\" ɛ la ki̱lɛth kɛnɛ li̱t mi̱ caa lɛl kɛ --mɛk ni min te nhiam kä li̱th.--Mi̱ tëë kɛ rɛw kiɛ ti̱ ŋuan ti̱ ci̱ rɔ̱ re̱p kɛ buɔ̱m mi̱ päär, bi̱ ji̱n rɔ bi̱ lɛ luäŋ kɛ ɣöö bi̱ kɛ kuëŋ.--format: ClassName.StrongestExtensionName. --Ji̱n bi̱ yi̱k ji̱ek kɛ ɣöö bi̱ ji̱ek mi̱ di̱i̱t kä bi̱ yi̱k loc ɛ la mi̱ te rɛy kä nɛmɛ.--kä ciöt in caa lɛp, ɛn buɔ̱m in caa ka̱m ji̱kɛ ɛ CAP - SM. --wargakni̱ rɛy ciöt in ca gɔ̱r ɛ nɛy ti̱ ŋuan, kɛnɛ ɣöö SM ɛ nämbär wargakni̱ tin tɔatni̱ --Kä buɔ̱m in ca ŋun ɛ mi̱ cie min ba lat: Mi̱ ca CAP la̱th kä nämbäri̱ tin ca gɔ̱r kɛ ci̱öt mi̱ di̱i̱t --Kä repdiɛn ba la̱t kɛ ɣöö ba la̱th kɛ kɔ̱kiɛn tin ba mat rɛy ki̱lɛthä.--Bi̱ ji̱n bi̱ ciöt ki̱lɛthä (thɛrnd) kɛnɛ li̱th ti̱ ŋuan ti̱ ba kulɛ gɔ̱r piny.--  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =","canonical_solution":"strongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions = class_name ++ \".\" ++ strongestExt\n  where\n    calculateStrength :: String -> Int\n    calculateStrength ext = length (filter (`elem` ['A'..'Z']) ext) - length (filter (`elem` ['a'..'z']) ext)\n    \n    strongestExt = fst $ foldl1 maxStrength $ zip extensions (map calculateStrength extensions)\n    \n    maxStrength :: (String, Int) -> (String, Int) -> (String, Int)\n    maxStrength ext1 ext2\n      | snd ext1 > snd ext2 = ext1\n      | otherwise           = ext2","tests":"\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_154","nl":"nus_Latn","pl":"hs","prompt":"--Bi̱diöö ɛ ciɛk-ciɛk in nhiam ɛ mi̱ la̱tkɛ ɛ ri̱e̱t mi̱ ci̱ rɔ ri̱e̱t kɛ ci̱öt in rɛwdɛ kiɛ mi̱ ci̱ rɔ ri̱e̱t kɛ ci̱öt in nhiam.--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =","canonical_solution":"cycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b = any (`isInfixOf` a) rotations\n  where\n    rotations = take (length b) $ map (take (length b)) $ tails (b ++ b)","tests":"\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_155","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Mi̱ ca ŋun ɛ la intejeri̱, bi̱ tuple mi̱ tekɛ nämbär mi̱ päär kɛnɛ i̱thpethi̱d di̱jitni̱ loc.--  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =","canonical_solution":"evenOddCount :: Int -> (Int, Int)\nevenOddCount num = (length evens, length odds)\n  where\n    digits = map (read . (:[])) . show . abs $ num\n    evens = filter even digits\n    odds  = filter odd digits","tests":"\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_156","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱: --Ri̱thääcni̱: 1 <= num <= 1000 --kä luɔ̱c jɛ kɛ gɔ̱r piny.--Mi̱ ca ŋun ɛ la mi̱ tekɛ puɔ̱thitib intejeri̱, ka̱mkɛ nämbäri̱ tin päärkɛ kɛ nämbäri̱ Röman cie ɛ thi̱ri̱n,--  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =","canonical_solution":"intToMiniRoman :: Int -> String\nintToMiniRoman number = concatMap (replicateSymbol number) romanNumerals\n  where\n    romanNumerals = [(1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"),\n                     (100, \"c\"), (90, \"xc\"), (50, \"l\"), (40, \"xl\"),\n                     (10, \"x\"), (9, \"ix\"), (5, \"v\"), (4, \"iv\"), (1, \"i\")]\n    \n    replicateSymbol :: Int -> (Int, String) -> String\n    replicateSymbol n (value, symbol)\n      | n >= value = symbol ++ replicateSymbol (n - value) (value, symbol)\n      | otherwise = \"\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_157","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --90 di̱gri̱i̱. --Ɛ rektha̱ŋgi̱li̱ ɛ jɛn rektha̱ŋgi̱li̱ mi̱ tekɛ ɛlɛmɛni̱ ti̱ cuŋ ɛ la rektha̱ŋgi̱li̱ kiɛ ɛlɛmɛni̱ ti̱ cuŋ.--Kä kui̱c ɛ mɔ, bi̱ kɛn tekɛ gua̱th ti̱ cuŋ ɛ la ti̱cdɛrɔ̱.--Mi̱ ca pek ɛ wä kä kui̱c in diɔ̱k kä ki̱li̱ögi̱ön, bi̱ luɔc ni̱ thuɔ̱k mi̱ ci̱ kɛn diɔ̱k ɛ wä kä kui̱c in diɔ̱k.--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =","canonical_solution":"rightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c = \n    let [x, y, z] = sort [a, b, c]\n    in x^2 + y^2 == z^2\n    where sort = Data.List.sort","tests":"\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_158","nl":"nus_Latn","pl":"hs","prompt":"--kä bi̱ ram min ci̱ ben nhiam ɛ wɔ̱ nhiam kä leksikɔgrapi̱kal.--Mi̱ ci̱ la̱t ɛ ŋuan kä bi̱ kɛn tekɛ nämbär mi̱ di̱i̱t kä bi̱ kɛn tekɛ dääk.--Kä li̱th ɛmɛ tëkɛ rie̱e̱t ti̱ gööl. Lätni̱ rie̱e̱t kɛ pek in di̱tni̱ jɛn kä ŋuan.--ɛ gɔ̱r pa̱ŋciin mi̱ bi̱ rɔ lot kɛ li̱th ti̱ ŋuan.--  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =","canonical_solution":"import Data.List (nub, sort)\n\nfindMax :: [String] -> String\nfindMax words = \n    head . sort . map snd . filter (\\(n, _) -> n == maxUnique) $ wordUniquePairs\n  where\n    wordUniquePairs = [(length . nub $ word, word) | word <- words]\n    maxUnique = maximum $ map fst wordUniquePairs","tests":"\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_159","nl":"nus_Latn","pl":"hs","prompt":"--Cäät: --Mi̱ \/thiɛlɛ karɔ̱a̱m ti̱ ro̱ŋ ti̱ ci̱ duɔth, bi̱ ji̱n karɔ̱a̱m diaal tin ci̱ duɔth cam, duŋni̱ ɣöö bi̱ ji̱n ŋot kɛ mi̱ näk ji̱ buɔth.--pek in ci̱ duɔth kä karɔ̱tni̱ kɛ kɔr mi̱ethdu] --bi dhil locni wargak mi [ pek in ca cam kɛ kɔr mieth, --Kä ɛn täämɛ, bi̱diöö ɛ tɔ̱tɔ̱ go̱o̱rɛ ɣöö bi̱diöö in bi̱ raan ɛ cam kɛ jɛn cäŋ ɛmɔ kɛɛliw.--❑ Ji̱n ɛ ji̱n muul mi̱ näk buɔth ɛ, kä ci̱ thëëm mi̱ ro̱ŋ mi̱ ci̱ cam, ❑--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =","canonical_solution":"eat :: Int -> Int -> Int -> [Int]\neat number need remaining\n  | remaining >= need = [number + need, remaining - need]\n  | otherwise = [number + remaining, 0]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_160","nl":"nus_Latn","pl":"hs","prompt":"--Kä li̱th öperɛtɔrä tekɛ ɛni̱ öperɛtɔr kɛl, kä li̱th öperand tekɛ ɛni̱ öperandni̱ rɛw.--Operand ɛ mi̱ la li̱th duŋ kä tin \/ci̱ negative intejeri̱.--Kä bäär in te rɛy läätdä ɛ päär kɛ bäär in te rɛy läätdä min ca mat ɛ kɛl.--Nöt: --=> luɔc = 9 --kä min bɛ nööŋ bɛ a 2 + 3 * 4 - 5 --list = [2, 3, 4, 5] --la̱t['+', '*', '-'] --Cäät: --Ɛkpönɛnti̱eciɔn (**) --Kä dääk piny ( \/\/) --Mälti̱pli̱këcin (*) --Thɔ̱kciɔn ( - ) --Matkɛ (+) --Kä aljɛbra min la̱tkɛ ni̱ wän:--Ɛn expression kɛnɛ return ɛ la mi̱ la̱tkɛ kä expression.--Kä li̱th in rɛwdɛ ɛ li̱th intejeri̱. La̱tdɛ kɛ li̱thni̱ rɛw tin ca ŋun kɛ ta̱th aljɛbri̱ka.--Lëë mëët lëty, lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy, lëë mëët lëty ëëy.doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =","canonical_solution":"doAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand = evaluate operand operator\n  where\n    evaluate [x] [] = x\n    evaluate (x:y:ys) (op:ops) = evaluate (result:ys) ops\n      where\n        result = applyOperation op x y\n\n    applyOperation \"+\" a b = a + b\n    applyOperation \"-\" a b = a - b\n    applyOperation \"*\" a b = a * b\n    applyOperation \"\/\/\" a b = a `div` b\n    applyOperation \"**\" a b = a ^ b\n    applyOperation _ _ _ = error \"Unsupported operation\"","tests":"\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"\/\/\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_161","nl":"nus_Latn","pl":"hs","prompt":"--Cäätni̱ --Kä pa̱ŋciin bɛ yi̱k loc ni̱ min ca nööŋ ɛ la thärk.--Mi̱ thiɛlɛ ci̱öt ti̱ te rɛy thärkäl, bi̱ thärkäl loc jɔk.--mi̱ \/ci̱ mɔ ɛ jɛn, titdɛ jɛ i̱ ɛ jɛn.--mi̱ ci̱ s[i] ɛ wargak, la̱thdɛ jɔk kä piny ɛ wä nhial kiɛ mi̱ caa loc jɔk, --ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ ɛ--  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =","canonical_solution":"solve :: String -> String\nsolve s\n  | any (`elem` ['a'..'z'] ++ ['A'..'Z']) s = map toggleCase s\n  | otherwise = reverse s\n  where\n    toggleCase c\n      | c `elem` ['a'..'z'] = toEnum (fromEnum c - 32) :: Char\n      | c `elem` ['A'..'Z'] = toEnum (fromEnum c + 32) :: Char\n      | otherwise = c","tests":"\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_162","nl":"nus_Latn","pl":"hs","prompt":"--Mi̱ ci̱ 'thuɔ̱r' ɛ mi̱ thiɛl luɔt, bi̱ loc ni̱ mi̱ thiɛl luɔt.--Mi ca thärkdɛ 'text' ŋun, locni jɛ kä md5 mi päär kɛ thärkdɛ.--  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =","canonical_solution":"import qualified Data.ByteString.Char8 as C\nimport qualified Data.Digest.Pure.MD5 as MD5\n\nstringToMd5 :: String -> Maybe String\nstringToMd5 text\n  | null text = Nothing\n  | otherwise = Just $ show $ MD5.md5 $ C.pack text","tests":"\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()"},{"task_id":"HumanEval_163","nl":"nus_Latn","pl":"hs","prompt":"--Ciee cäät ɛmɛ: --kä b, kɛ räthdɛ nhial.--Mi̱ ca ŋun ɛ la ɣöö ba pek in ca ŋun ɛ la rɛw ti̱ puɔthtip intejeri̱ a kɛnɛ b, locni̱ ɛni̱ di̱jitni̱ ti̱ päär kam a kɛnɛ b.--  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =","canonical_solution":"generateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b = filter even [min a b .. max a b]","tests":"\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()"}]